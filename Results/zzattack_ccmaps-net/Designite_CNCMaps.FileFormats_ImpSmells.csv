Implementation smell,Namespace,Class,File,Method,Description
Long Method,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The method has 127 lines of code.
Long Method,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The method has 139 lines of code.
Complex Method,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,Cyclomatic complexity of the method is 12
Complex Method,CNCMaps.FileFormats.VirtualFileSystem,VFS,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\VirtualFileSystem\VFS.cs,GetFormatFromTypeclass,Cyclomatic complexity of the method is 12
Complex Method,CNCMaps.FileFormats.VirtualFileSystem,VFS,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\VirtualFileSystem\VFS.cs,LoadMixes,Cyclomatic complexity of the method is 31
Long Parameter List,CNCMaps.FileFormats,CsfFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\CsfFile.cs,CsfFile,The method has 5 parameters. Parameters: baseStream' filename' baseOffset' fileSize' isBuffered
Long Parameter List,CNCMaps.FileFormats,FormatHelper,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\FormatHelper.cs,OpenAsFormat,The method has 6 parameters. Parameters: baseStream' filename' offset' length' format' m
Long Parameter List,CNCMaps.FileFormats,HvaFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\HvaFile.cs,HvaFile,The method has 5 parameters. Parameters: baseStream' filename' baseOffset' fileSize' isBuffered
Long Parameter List,CNCMaps.FileFormats,IniFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\IniFile.cs,IniFile,The method has 5 parameters. Parameters: baseStream' filename' baseOffset' fileSize' isBuffered
Long Parameter List,CNCMaps.FileFormats,MissionsFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MissionsFile.cs,MissionsFile,The method has 5 parameters. Parameters: baseStream' filename' offset' length' isBuffered
Long Parameter List,CNCMaps.FileFormats,MixFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MixFile.cs,MixFile,The method has 6 parameters. Parameters: baseStream' filename' baseOffset' fileSize' isBuffered' parseHeader
Long Parameter List,CNCMaps.FileFormats,PalFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\PalFile.cs,PalFile,The method has 5 parameters. Parameters: baseStream' filename' baseOffset' fileSize' isBuffered
Long Parameter List,CNCMaps.FileFormats,PktFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\PktFile.cs,PktFile,The method has 5 parameters. Parameters: baseStream' filename' offset' length' isBuffered
Long Parameter List,CNCMaps.FileFormats,ShpFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\ShpFile.cs,ShpFile,The method has 5 parameters. Parameters: baseStream' filename' baseOffset' fileSize' isBuffered
Long Parameter List,CNCMaps.FileFormats,TmpFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\TmpFile.cs,TmpFile,The method has 5 parameters. Parameters: baseStream' filename' baseOffset' fileSize' isBuffered
Long Parameter List,CNCMaps.FileFormats,VplFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\VplFile.cs,VplFile,The method has 5 parameters. Parameters: baseStream' filename' baseOffset' fileSize' isBuffered
Long Parameter List,CNCMaps.FileFormats,VxlFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\VxlFile.cs,VxlFile,The method has 5 parameters. Parameters: baseStream' filename' baseOffset' fileSize' isBuffered
Long Parameter List,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,sub_bignum,The method has 5 parameters. Parameters: dest' src1' src2' carry' len
Long Parameter List,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,sub_bignum,The method has 5 parameters. Parameters: dest' src1' src2' carry' len
Long Parameter List,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,calc_a_key,The method has 5 parameters. Parameters: n1' n2' n3' n4' len
Long Parameter List,CNCMaps.FileFormats.Encodings,Format3,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Format3.cs,DecodeInto,The method has 5 parameters. Parameters: src' srcLen' dst' cx' cy
Long Parameter List,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The method has 6 parameters. Parameters: in' in_len' out' out_len' ti' wrkmem
Long Parameter List,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress,The method has 5 parameters. Parameters: in' in_len' out' out_len' wrkmem
Long Parameter List,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The method has 5 parameters. Parameters: in' in_len' out' out_len' wrkmem
Long Parameter List,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,MapFile,The method has 5 parameters. Parameters: baseStream' filename' offset' length' isBuffered
Long Parameter List,CNCMaps.FileFormats.Map,IsoTile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapObjects.cs,IsoTile,The method has 7 parameters. Parameters: p1' p2' rx' ry' z' tilenum' subtile
Long Parameter List,CNCMaps.FileFormats.Map,Aircraft,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapObjects.cs,Aircraft,The method has 5 parameters. Parameters: owner' name' health' direction' onBridge
Long Parameter List,CNCMaps.FileFormats.Map,Infantry,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapObjects.cs,Infantry,The method has 5 parameters. Parameters: owner' name' health' direction' onBridge
Long Parameter List,CNCMaps.FileFormats.Map,Unit,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapObjects.cs,Unit,The method has 5 parameters. Parameters: owner' name' health' direction' onBridge
Long Parameter List,CNCMaps.FileFormats.VirtualFileSystem,VirtualFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\VirtualFileSystem\VirtualFile.cs,VirtualFile,The method has 5 parameters. Parameters: baseStream' filename' baseOffset' fileSize' isBuffered
Long Parameter List,CNCMaps.FileFormats.VirtualFileSystem,VirtualTextFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\VirtualFileSystem\VirtualTextFile.cs,VirtualTextFile,The method has 5 parameters. Parameters: file' filename' baseOffset' length' isBuffered
Long Statement,CNCMaps.FileFormats,IniSection,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\IniFile.cs,ReadColor,The length of the statement  "				if (colorParts.Length == 3 && int.TryParse(colorParts[0]' out r) && int.TryParse(colorParts[0]' out g) && int.TryParse(colorParts[0]' out b)) " is 141.
Long Statement,CNCMaps.FileFormats,MixFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MixFile.cs,IsValid,The length of the statement  "				return numFiles > 0 && 84 + (6 + numFiles * 12 + 7 & ~7) + dataSize + ((signature & (uint)MixFileFlags.Checksum) != 0 ? 20 : 0) == Length; " is 138.
Long Statement,CNCMaps.FileFormats,MixFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MixFile.cs,IsValid,The length of the statement  "				return numFiles > 0 && 4 + 6 + numFiles * 12 + dataSize + ((signature & (uint)MixFileFlags.Checksum) != 0 ? 20 : 0) == Length; " is 126.
Complex Conditional,CNCMaps.FileFormats,IniSection,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\IniFile.cs,ReadColor,The conditional expression  "colorParts.Length == 3 && int.TryParse(colorParts[0]' out r) && int.TryParse(colorParts[0]' out g) && int.TryParse(colorParts[0]' out b)"  is complex.
Complex Conditional,CNCMaps.FileFormats,TmpImage,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\TmpFile.cs,Read,The conditional expression  "HasZData && HasExtraData && 0 < _extraZDataOffset && _extraZDataOffset < f.Length"  is complex.
Complex Conditional,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadTiles,The conditional expression  "dx >= 0 && dx < 2 * Tiles.Width &&  					dy >= 0 && dy < 2 * Tiles.Height"  is complex.
Complex Conditional,CNCMaps.FileFormats.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\TileLayer.cs,GetTileR,The conditional expression  "dx < 0 || dy < 0 || dx >= isoTiles.GetLength(0) || (dy / 2) >= isoTiles.GetLength(1)"  is complex.
Empty Catch Block,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadSmudges,The method has an empty catch block.
Empty Catch Block,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadInfantry,The method has an empty catch block.
Empty Catch Block,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadInfantry,The method has an empty catch block.
Empty Catch Block,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadUnits,The method has an empty catch block.
Empty Catch Block,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadUnits,The method has an empty catch block.
Empty Catch Block,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadAircraft,The method has an empty catch block.
Empty Catch Block,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadAircraft,The method has an empty catch block.
Empty Catch Block,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadStructures,The method has an empty catch block.
Empty Catch Block,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadStructures,The method has an empty catch block.
Empty Catch Block,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadWaypoints,The method has an empty catch block.
Magic Number,CNCMaps.FileFormats,CsfFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\CsfFile.cs,ReadWstring,The following statement contains a magic number: return ConvertToString(Encoding.Unicode.GetString(Read(ReadInt32() * 2)));
Magic Number,CNCMaps.FileFormats,HvaFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\HvaFile.cs,Initialize,The following statement contains a magic number: ReadCString(16);
Magic Number,CNCMaps.FileFormats,HvaFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\HvaFile.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < numSections; i++)  				Sections.Add(new Section(NumFrames) {  					Name = ReadCString(16)  				});
Magic Number,CNCMaps.FileFormats,HvaFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\HvaFile.cs,ReadMatrix,The following statement contains a magic number: var ret = new float[12];
Magic Number,CNCMaps.FileFormats,HvaFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\HvaFile.cs,ReadMatrix,The following statement contains a magic number: for (int i = 0; i < 12; i++) {  				ret[i] = ReadFloat();  			}
Magic Number,CNCMaps.FileFormats,HvaFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\HvaFile.cs,ToGLMatrix,The following statement contains a magic number: return new Matrix4(  				hvaMatrix[0]' hvaMatrix[4]' hvaMatrix[8]' 0'  				hvaMatrix[1]' hvaMatrix[5]' hvaMatrix[9]' 0'  				hvaMatrix[2]' hvaMatrix[6]' hvaMatrix[10]' 0'  				hvaMatrix[3]' hvaMatrix[7]' hvaMatrix[11]' 1);
Magic Number,CNCMaps.FileFormats,HvaFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\HvaFile.cs,ToGLMatrix,The following statement contains a magic number: return new Matrix4(  				hvaMatrix[0]' hvaMatrix[4]' hvaMatrix[8]' 0'  				hvaMatrix[1]' hvaMatrix[5]' hvaMatrix[9]' 0'  				hvaMatrix[2]' hvaMatrix[6]' hvaMatrix[10]' 0'  				hvaMatrix[3]' hvaMatrix[7]' hvaMatrix[11]' 1);
Magic Number,CNCMaps.FileFormats,HvaFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\HvaFile.cs,ToGLMatrix,The following statement contains a magic number: return new Matrix4(  				hvaMatrix[0]' hvaMatrix[4]' hvaMatrix[8]' 0'  				hvaMatrix[1]' hvaMatrix[5]' hvaMatrix[9]' 0'  				hvaMatrix[2]' hvaMatrix[6]' hvaMatrix[10]' 0'  				hvaMatrix[3]' hvaMatrix[7]' hvaMatrix[11]' 1);
Magic Number,CNCMaps.FileFormats,HvaFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\HvaFile.cs,ToGLMatrix,The following statement contains a magic number: return new Matrix4(  				hvaMatrix[0]' hvaMatrix[4]' hvaMatrix[8]' 0'  				hvaMatrix[1]' hvaMatrix[5]' hvaMatrix[9]' 0'  				hvaMatrix[2]' hvaMatrix[6]' hvaMatrix[10]' 0'  				hvaMatrix[3]' hvaMatrix[7]' hvaMatrix[11]' 1);
Magic Number,CNCMaps.FileFormats,HvaFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\HvaFile.cs,ToGLMatrix,The following statement contains a magic number: return new Matrix4(  				hvaMatrix[0]' hvaMatrix[4]' hvaMatrix[8]' 0'  				hvaMatrix[1]' hvaMatrix[5]' hvaMatrix[9]' 0'  				hvaMatrix[2]' hvaMatrix[6]' hvaMatrix[10]' 0'  				hvaMatrix[3]' hvaMatrix[7]' hvaMatrix[11]' 1);
Magic Number,CNCMaps.FileFormats,HvaFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\HvaFile.cs,ToGLMatrix,The following statement contains a magic number: return new Matrix4(  				hvaMatrix[0]' hvaMatrix[4]' hvaMatrix[8]' 0'  				hvaMatrix[1]' hvaMatrix[5]' hvaMatrix[9]' 0'  				hvaMatrix[2]' hvaMatrix[6]' hvaMatrix[10]' 0'  				hvaMatrix[3]' hvaMatrix[7]' hvaMatrix[11]' 1);
Magic Number,CNCMaps.FileFormats,HvaFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\HvaFile.cs,ToGLMatrix,The following statement contains a magic number: return new Matrix4(  				hvaMatrix[0]' hvaMatrix[4]' hvaMatrix[8]' 0'  				hvaMatrix[1]' hvaMatrix[5]' hvaMatrix[9]' 0'  				hvaMatrix[2]' hvaMatrix[6]' hvaMatrix[10]' 0'  				hvaMatrix[3]' hvaMatrix[7]' hvaMatrix[11]' 1);
Magic Number,CNCMaps.FileFormats,HvaFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\HvaFile.cs,ToGLMatrix,The following statement contains a magic number: return new Matrix4(  				hvaMatrix[0]' hvaMatrix[4]' hvaMatrix[8]' 0'  				hvaMatrix[1]' hvaMatrix[5]' hvaMatrix[9]' 0'  				hvaMatrix[2]' hvaMatrix[6]' hvaMatrix[10]' 0'  				hvaMatrix[3]' hvaMatrix[7]' hvaMatrix[11]' 1);
Magic Number,CNCMaps.FileFormats,HvaFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\HvaFile.cs,ToGLMatrix,The following statement contains a magic number: return new Matrix4(  				hvaMatrix[0]' hvaMatrix[4]' hvaMatrix[8]' 0'  				hvaMatrix[1]' hvaMatrix[5]' hvaMatrix[9]' 0'  				hvaMatrix[2]' hvaMatrix[6]' hvaMatrix[10]' 0'  				hvaMatrix[3]' hvaMatrix[7]' hvaMatrix[11]' 1);
Magic Number,CNCMaps.FileFormats,HvaFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\HvaFile.cs,ToGLMatrix,The following statement contains a magic number: return new Matrix4(  				hvaMatrix[0]' hvaMatrix[4]' hvaMatrix[8]' 0'  				hvaMatrix[1]' hvaMatrix[5]' hvaMatrix[9]' 0'  				hvaMatrix[2]' hvaMatrix[6]' hvaMatrix[10]' 0'  				hvaMatrix[3]' hvaMatrix[7]' hvaMatrix[11]' 1);
Magic Number,CNCMaps.FileFormats,Section,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\HvaFile.cs,ReadHeader,The following statement contains a magic number: Name = f.ReadCString(16);
Magic Number,CNCMaps.FileFormats,Section,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\HvaFile.cs,GetNormals,The following statement contains a magic number: switch (NormalsMode) {  					case 1:  						return Normals1;  					case 2:  						return Normals2;  					case 3:  						return Normals3;  					case 4:  						return Normals4;  					default:  						throw new ArgumentException();  				}
Magic Number,CNCMaps.FileFormats,Section,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\HvaFile.cs,GetNormals,The following statement contains a magic number: switch (NormalsMode) {  					case 1:  						return Normals1;  					case 2:  						return Normals2;  					case 3:  						return Normals3;  					case 4:  						return Normals4;  					default:  						throw new ArgumentException();  				}
Magic Number,CNCMaps.FileFormats,Section,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\HvaFile.cs,GetNormals,The following statement contains a magic number: switch (NormalsMode) {  					case 1:  						return Normals1;  					case 2:  						return Normals2;  					case 3:  						return Normals3;  					case 4:  						return Normals4;  					default:  						throw new ArgumentException();  				}
Magic Number,CNCMaps.FileFormats,IniFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\IniFile.cs,ProcessLine,The following statement contains a magic number: if ((line[0] == '[') && (line[line.Length - 1] == ']')) {  				string sectionName = line.Substring(1' line.Length - 2);  				var iniSection = new IniSection(sectionName' Sections.Count);  				logger.Trace("Loading ini section {0}"' sectionName);  				Sections.Add(iniSection);  				CurrentSection = iniSection;  			}  			else if (CurrentSection != null) {  				return CurrentSection.ParseLine(line);  			}
Magic Number,CNCMaps.FileFormats,IniFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\IniFile.cs,Save,The following statement contains a magic number: var sw = new StreamWriter(filename' false' Encoding.Default' 64 * 1024);
Magic Number,CNCMaps.FileFormats,IniFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\IniFile.cs,Save,The following statement contains a magic number: var sw = new StreamWriter(filename' false' Encoding.Default' 64 * 1024);
Magic Number,CNCMaps.FileFormats,IniSection,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\IniFile.cs,ReadColor,The following statement contains a magic number: if (colorParts.Length == 3 && int.TryParse(colorParts[0]' out r) && int.TryParse(colorParts[0]' out g) && int.TryParse(colorParts[0]' out b))  					return Color.FromArgb(r' g' b);
Magic Number,CNCMaps.FileFormats,IniSection,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\IniFile.cs,ReadXYZ,The following statement contains a magic number: if (int.TryParse(parts[0]' out x) && int.TryParse(parts[1]' out y) && int.TryParse(parts[2]' out z))  					return new Vector3(x' y' z);
Magic Number,CNCMaps.FileFormats,MixFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MixFile.cs,IsValid,The following statement contains a magic number: if ((signature & (uint)MixFileFlags.Encrypted) != 0) {  				byte[] keyblock = Read(80);  				byte[] blowfishKey = new BlowfishKeyProvider().DecryptKey(keyblock);    				uint[] h = ReadUints(this' 2);  				var fish = new Blowfish(blowfishKey);  				MemoryStream ms = Decrypt(h' fish);  				var reader2 = new BinaryReader(ms);    				ushort numFiles = reader2.ReadUInt16();  				uint dataSize = reader2.ReadUInt32(); /*datasize*/  				return numFiles > 0 && 84 + (6 + numFiles * 12 + 7 & ~7) + dataSize + ((signature & (uint)MixFileFlags.Checksum) != 0 ? 20 : 0) == Length;  			}  			else {  				ushort numFiles = ReadUInt16();  				uint dataSize = ReadUInt32();  				return numFiles > 0 && 4 + 6 + numFiles * 12 + dataSize + ((signature & (uint)MixFileFlags.Checksum) != 0 ? 20 : 0) == Length;  			}
Magic Number,CNCMaps.FileFormats,MixFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MixFile.cs,IsValid,The following statement contains a magic number: if ((signature & (uint)MixFileFlags.Encrypted) != 0) {  				byte[] keyblock = Read(80);  				byte[] blowfishKey = new BlowfishKeyProvider().DecryptKey(keyblock);    				uint[] h = ReadUints(this' 2);  				var fish = new Blowfish(blowfishKey);  				MemoryStream ms = Decrypt(h' fish);  				var reader2 = new BinaryReader(ms);    				ushort numFiles = reader2.ReadUInt16();  				uint dataSize = reader2.ReadUInt32(); /*datasize*/  				return numFiles > 0 && 84 + (6 + numFiles * 12 + 7 & ~7) + dataSize + ((signature & (uint)MixFileFlags.Checksum) != 0 ? 20 : 0) == Length;  			}  			else {  				ushort numFiles = ReadUInt16();  				uint dataSize = ReadUInt32();  				return numFiles > 0 && 4 + 6 + numFiles * 12 + dataSize + ((signature & (uint)MixFileFlags.Checksum) != 0 ? 20 : 0) == Length;  			}
Magic Number,CNCMaps.FileFormats,MixFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MixFile.cs,IsValid,The following statement contains a magic number: if ((signature & (uint)MixFileFlags.Encrypted) != 0) {  				byte[] keyblock = Read(80);  				byte[] blowfishKey = new BlowfishKeyProvider().DecryptKey(keyblock);    				uint[] h = ReadUints(this' 2);  				var fish = new Blowfish(blowfishKey);  				MemoryStream ms = Decrypt(h' fish);  				var reader2 = new BinaryReader(ms);    				ushort numFiles = reader2.ReadUInt16();  				uint dataSize = reader2.ReadUInt32(); /*datasize*/  				return numFiles > 0 && 84 + (6 + numFiles * 12 + 7 & ~7) + dataSize + ((signature & (uint)MixFileFlags.Checksum) != 0 ? 20 : 0) == Length;  			}  			else {  				ushort numFiles = ReadUInt16();  				uint dataSize = ReadUInt32();  				return numFiles > 0 && 4 + 6 + numFiles * 12 + dataSize + ((signature & (uint)MixFileFlags.Checksum) != 0 ? 20 : 0) == Length;  			}
Magic Number,CNCMaps.FileFormats,MixFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MixFile.cs,IsValid,The following statement contains a magic number: if ((signature & (uint)MixFileFlags.Encrypted) != 0) {  				byte[] keyblock = Read(80);  				byte[] blowfishKey = new BlowfishKeyProvider().DecryptKey(keyblock);    				uint[] h = ReadUints(this' 2);  				var fish = new Blowfish(blowfishKey);  				MemoryStream ms = Decrypt(h' fish);  				var reader2 = new BinaryReader(ms);    				ushort numFiles = reader2.ReadUInt16();  				uint dataSize = reader2.ReadUInt32(); /*datasize*/  				return numFiles > 0 && 84 + (6 + numFiles * 12 + 7 & ~7) + dataSize + ((signature & (uint)MixFileFlags.Checksum) != 0 ? 20 : 0) == Length;  			}  			else {  				ushort numFiles = ReadUInt16();  				uint dataSize = ReadUInt32();  				return numFiles > 0 && 4 + 6 + numFiles * 12 + dataSize + ((signature & (uint)MixFileFlags.Checksum) != 0 ? 20 : 0) == Length;  			}
Magic Number,CNCMaps.FileFormats,MixFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MixFile.cs,IsValid,The following statement contains a magic number: if ((signature & (uint)MixFileFlags.Encrypted) != 0) {  				byte[] keyblock = Read(80);  				byte[] blowfishKey = new BlowfishKeyProvider().DecryptKey(keyblock);    				uint[] h = ReadUints(this' 2);  				var fish = new Blowfish(blowfishKey);  				MemoryStream ms = Decrypt(h' fish);  				var reader2 = new BinaryReader(ms);    				ushort numFiles = reader2.ReadUInt16();  				uint dataSize = reader2.ReadUInt32(); /*datasize*/  				return numFiles > 0 && 84 + (6 + numFiles * 12 + 7 & ~7) + dataSize + ((signature & (uint)MixFileFlags.Checksum) != 0 ? 20 : 0) == Length;  			}  			else {  				ushort numFiles = ReadUInt16();  				uint dataSize = ReadUInt32();  				return numFiles > 0 && 4 + 6 + numFiles * 12 + dataSize + ((signature & (uint)MixFileFlags.Checksum) != 0 ? 20 : 0) == Length;  			}
Magic Number,CNCMaps.FileFormats,MixFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MixFile.cs,IsValid,The following statement contains a magic number: if ((signature & (uint)MixFileFlags.Encrypted) != 0) {  				byte[] keyblock = Read(80);  				byte[] blowfishKey = new BlowfishKeyProvider().DecryptKey(keyblock);    				uint[] h = ReadUints(this' 2);  				var fish = new Blowfish(blowfishKey);  				MemoryStream ms = Decrypt(h' fish);  				var reader2 = new BinaryReader(ms);    				ushort numFiles = reader2.ReadUInt16();  				uint dataSize = reader2.ReadUInt32(); /*datasize*/  				return numFiles > 0 && 84 + (6 + numFiles * 12 + 7 & ~7) + dataSize + ((signature & (uint)MixFileFlags.Checksum) != 0 ? 20 : 0) == Length;  			}  			else {  				ushort numFiles = ReadUInt16();  				uint dataSize = ReadUInt32();  				return numFiles > 0 && 4 + 6 + numFiles * 12 + dataSize + ((signature & (uint)MixFileFlags.Checksum) != 0 ? 20 : 0) == Length;  			}
Magic Number,CNCMaps.FileFormats,MixFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MixFile.cs,IsValid,The following statement contains a magic number: if ((signature & (uint)MixFileFlags.Encrypted) != 0) {  				byte[] keyblock = Read(80);  				byte[] blowfishKey = new BlowfishKeyProvider().DecryptKey(keyblock);    				uint[] h = ReadUints(this' 2);  				var fish = new Blowfish(blowfishKey);  				MemoryStream ms = Decrypt(h' fish);  				var reader2 = new BinaryReader(ms);    				ushort numFiles = reader2.ReadUInt16();  				uint dataSize = reader2.ReadUInt32(); /*datasize*/  				return numFiles > 0 && 84 + (6 + numFiles * 12 + 7 & ~7) + dataSize + ((signature & (uint)MixFileFlags.Checksum) != 0 ? 20 : 0) == Length;  			}  			else {  				ushort numFiles = ReadUInt16();  				uint dataSize = ReadUInt32();  				return numFiles > 0 && 4 + 6 + numFiles * 12 + dataSize + ((signature & (uint)MixFileFlags.Checksum) != 0 ? 20 : 0) == Length;  			}
Magic Number,CNCMaps.FileFormats,MixFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MixFile.cs,IsValid,The following statement contains a magic number: if ((signature & (uint)MixFileFlags.Encrypted) != 0) {  				byte[] keyblock = Read(80);  				byte[] blowfishKey = new BlowfishKeyProvider().DecryptKey(keyblock);    				uint[] h = ReadUints(this' 2);  				var fish = new Blowfish(blowfishKey);  				MemoryStream ms = Decrypt(h' fish);  				var reader2 = new BinaryReader(ms);    				ushort numFiles = reader2.ReadUInt16();  				uint dataSize = reader2.ReadUInt32(); /*datasize*/  				return numFiles > 0 && 84 + (6 + numFiles * 12 + 7 & ~7) + dataSize + ((signature & (uint)MixFileFlags.Checksum) != 0 ? 20 : 0) == Length;  			}  			else {  				ushort numFiles = ReadUInt16();  				uint dataSize = ReadUInt32();  				return numFiles > 0 && 4 + 6 + numFiles * 12 + dataSize + ((signature & (uint)MixFileFlags.Checksum) != 0 ? 20 : 0) == Length;  			}
Magic Number,CNCMaps.FileFormats,MixFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MixFile.cs,IsValid,The following statement contains a magic number: if ((signature & (uint)MixFileFlags.Encrypted) != 0) {  				byte[] keyblock = Read(80);  				byte[] blowfishKey = new BlowfishKeyProvider().DecryptKey(keyblock);    				uint[] h = ReadUints(this' 2);  				var fish = new Blowfish(blowfishKey);  				MemoryStream ms = Decrypt(h' fish);  				var reader2 = new BinaryReader(ms);    				ushort numFiles = reader2.ReadUInt16();  				uint dataSize = reader2.ReadUInt32(); /*datasize*/  				return numFiles > 0 && 84 + (6 + numFiles * 12 + 7 & ~7) + dataSize + ((signature & (uint)MixFileFlags.Checksum) != 0 ? 20 : 0) == Length;  			}  			else {  				ushort numFiles = ReadUInt16();  				uint dataSize = ReadUInt32();  				return numFiles > 0 && 4 + 6 + numFiles * 12 + dataSize + ((signature & (uint)MixFileFlags.Checksum) != 0 ? 20 : 0) == Length;  			}
Magic Number,CNCMaps.FileFormats,MixFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MixFile.cs,IsValid,The following statement contains a magic number: if ((signature & (uint)MixFileFlags.Encrypted) != 0) {  				byte[] keyblock = Read(80);  				byte[] blowfishKey = new BlowfishKeyProvider().DecryptKey(keyblock);    				uint[] h = ReadUints(this' 2);  				var fish = new Blowfish(blowfishKey);  				MemoryStream ms = Decrypt(h' fish);  				var reader2 = new BinaryReader(ms);    				ushort numFiles = reader2.ReadUInt16();  				uint dataSize = reader2.ReadUInt32(); /*datasize*/  				return numFiles > 0 && 84 + (6 + numFiles * 12 + 7 & ~7) + dataSize + ((signature & (uint)MixFileFlags.Checksum) != 0 ? 20 : 0) == Length;  			}  			else {  				ushort numFiles = ReadUInt16();  				uint dataSize = ReadUInt32();  				return numFiles > 0 && 4 + 6 + numFiles * 12 + dataSize + ((signature & (uint)MixFileFlags.Checksum) != 0 ? 20 : 0) == Length;  			}
Magic Number,CNCMaps.FileFormats,MixFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MixFile.cs,IsValid,The following statement contains a magic number: if ((signature & (uint)MixFileFlags.Encrypted) != 0) {  				byte[] keyblock = Read(80);  				byte[] blowfishKey = new BlowfishKeyProvider().DecryptKey(keyblock);    				uint[] h = ReadUints(this' 2);  				var fish = new Blowfish(blowfishKey);  				MemoryStream ms = Decrypt(h' fish);  				var reader2 = new BinaryReader(ms);    				ushort numFiles = reader2.ReadUInt16();  				uint dataSize = reader2.ReadUInt32(); /*datasize*/  				return numFiles > 0 && 84 + (6 + numFiles * 12 + 7 & ~7) + dataSize + ((signature & (uint)MixFileFlags.Checksum) != 0 ? 20 : 0) == Length;  			}  			else {  				ushort numFiles = ReadUInt16();  				uint dataSize = ReadUInt32();  				return numFiles > 0 && 4 + 6 + numFiles * 12 + dataSize + ((signature & (uint)MixFileFlags.Checksum) != 0 ? 20 : 0) == Length;  			}
Magic Number,CNCMaps.FileFormats,MixFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MixFile.cs,IsValid,The following statement contains a magic number: if ((signature & (uint)MixFileFlags.Encrypted) != 0) {  				byte[] keyblock = Read(80);  				byte[] blowfishKey = new BlowfishKeyProvider().DecryptKey(keyblock);    				uint[] h = ReadUints(this' 2);  				var fish = new Blowfish(blowfishKey);  				MemoryStream ms = Decrypt(h' fish);  				var reader2 = new BinaryReader(ms);    				ushort numFiles = reader2.ReadUInt16();  				uint dataSize = reader2.ReadUInt32(); /*datasize*/  				return numFiles > 0 && 84 + (6 + numFiles * 12 + 7 & ~7) + dataSize + ((signature & (uint)MixFileFlags.Checksum) != 0 ? 20 : 0) == Length;  			}  			else {  				ushort numFiles = ReadUInt16();  				uint dataSize = ReadUInt32();  				return numFiles > 0 && 4 + 6 + numFiles * 12 + dataSize + ((signature & (uint)MixFileFlags.Checksum) != 0 ? 20 : 0) == Length;  			}
Magic Number,CNCMaps.FileFormats,MixFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MixFile.cs,ParseRaHeader,The following statement contains a magic number: byte[] keyblock = reader.Read(80);
Magic Number,CNCMaps.FileFormats,MixFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MixFile.cs,ParseRaHeader,The following statement contains a magic number: uint[] h = ReadUints(reader' 2);
Magic Number,CNCMaps.FileFormats,MixFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MixFile.cs,ParseRaHeader,The following statement contains a magic number: int byteCount = 6 + numFiles * MixEntry.Size;
Magic Number,CNCMaps.FileFormats,MixFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MixFile.cs,ParseRaHeader,The following statement contains a magic number: h = ReadUints(reader' (byteCount + 3) / 4);
Magic Number,CNCMaps.FileFormats,MixFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MixFile.cs,ParseRaHeader,The following statement contains a magic number: h = ReadUints(reader' (byteCount + 3) / 4);
Magic Number,CNCMaps.FileFormats,MixFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MixFile.cs,ParseRaHeader,The following statement contains a magic number: dataStart = headerStart + byteCount + ((~byteCount + 1) & 7);
Magic Number,CNCMaps.FileFormats,MixEntry,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MixFile.cs,HashFilename,The following statement contains a magic number: int a = l >> 2;
Magic Number,CNCMaps.FileFormats,MixEntry,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MixFile.cs,HashFilename,The following statement contains a magic number: if ((l & 3) != 0) {  					filename += (char)(l - (a << 2));  					int i = 3 - (l & 3);  					while (i-- != 0) filename += filename[a << 2];  				}
Magic Number,CNCMaps.FileFormats,MixEntry,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MixFile.cs,HashFilename,The following statement contains a magic number: if ((l & 3) != 0) {  					filename += (char)(l - (a << 2));  					int i = 3 - (l & 3);  					while (i-- != 0) filename += filename[a << 2];  				}
Magic Number,CNCMaps.FileFormats,MixEntry,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MixFile.cs,HashFilename,The following statement contains a magic number: if ((l & 3) != 0) {  					filename += (char)(l - (a << 2));  					int i = 3 - (l & 3);  					while (i-- != 0) filename += filename[a << 2];  				}
Magic Number,CNCMaps.FileFormats,MixEntry,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MixFile.cs,HashFilename,The following statement contains a magic number: if ((l & 3) != 0) {  					filename += (char)(l - (a << 2));  					int i = 3 - (l & 3);  					while (i-- != 0) filename += filename[a << 2];  				}
Magic Number,CNCMaps.FileFormats,MixEntry,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\MixFile.cs,HashFilename,The following statement contains a magic number: if ((l & 3) != 0) {  					filename += (char)(l - (a << 2));  					int i = 3 - (l & 3);  					while (i-- != 0) filename += filename[a << 2];  				}
Magic Number,CNCMaps.FileFormats,PalFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\PalFile.cs,GetOriginalColors,The following statement contains a magic number: return Read(256 * 3);
Magic Number,CNCMaps.FileFormats,PalFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\PalFile.cs,GetOriginalColors,The following statement contains a magic number: return Read(256 * 3);
Magic Number,CNCMaps.FileFormats,ShpImage,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\ShpFile.cs,GetImageData,The following statement contains a magic number: if (_decompressedImage == null) {  					_f.Seek(ImgDataOffset' SeekOrigin.Begin);  					int c_px = Width * Height;    					// img.Header.compression &= 0x03;  					if (CompressionType <= 1) {  						// Raw 8 bits-per-pixel image data  						_decompressedImage = _f.Read(c_px);  					}  					else if (CompressionType == 2) {  						// Image data divided into scanlines {  						// -- Length of scanline (ImageHeader.width + 2) : uint16  						// -- Raw 8 bits-per-pixel image data : uint8[ImageHeader.width]  						_decompressedImage = new byte[c_px];  						int lineOffset = 0;  						for (int y = 0; y < Height; y++) {  							ushort scanlineLength = (ushort)(_f.ReadUInt16() - sizeof(ushort));  							_f.Read(_decompressedImage' lineOffset' scanlineLength);  							lineOffset += scanlineLength;  						}  					}  					else if (CompressionType == 3) {  						_decompressedImage = new byte[c_px];  						var compressedEnd = (int)_f.Length;  						if (_frameIndex < _f.Images.Count - 1)  							compressedEnd = _f.Images[_frameIndex + 1].ImgDataOffset;  						if (compressedEnd < ImgDataOffset)  							compressedEnd = (int)_f.Length;  						Format3.DecodeInto(_f.Read(compressedEnd - ImgDataOffset)' _decompressedImage' Width' Height);  					}  					else {  						Logger.Debug("SHP image {0} frame {1} has unknown compression!"' _f.FileName' _frameIndex);  					}  				}
Magic Number,CNCMaps.FileFormats,ShpImage,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\ShpFile.cs,GetImageData,The following statement contains a magic number: if (_decompressedImage == null) {  					_f.Seek(ImgDataOffset' SeekOrigin.Begin);  					int c_px = Width * Height;    					// img.Header.compression &= 0x03;  					if (CompressionType <= 1) {  						// Raw 8 bits-per-pixel image data  						_decompressedImage = _f.Read(c_px);  					}  					else if (CompressionType == 2) {  						// Image data divided into scanlines {  						// -- Length of scanline (ImageHeader.width + 2) : uint16  						// -- Raw 8 bits-per-pixel image data : uint8[ImageHeader.width]  						_decompressedImage = new byte[c_px];  						int lineOffset = 0;  						for (int y = 0; y < Height; y++) {  							ushort scanlineLength = (ushort)(_f.ReadUInt16() - sizeof(ushort));  							_f.Read(_decompressedImage' lineOffset' scanlineLength);  							lineOffset += scanlineLength;  						}  					}  					else if (CompressionType == 3) {  						_decompressedImage = new byte[c_px];  						var compressedEnd = (int)_f.Length;  						if (_frameIndex < _f.Images.Count - 1)  							compressedEnd = _f.Images[_frameIndex + 1].ImgDataOffset;  						if (compressedEnd < ImgDataOffset)  							compressedEnd = (int)_f.Length;  						Format3.DecodeInto(_f.Read(compressedEnd - ImgDataOffset)' _decompressedImage' Width' Height);  					}  					else {  						Logger.Debug("SHP image {0} frame {1} has unknown compression!"' _f.FileName' _frameIndex);  					}  				}
Magic Number,CNCMaps.FileFormats,TmpFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\TmpFile.cs,Initialize,The following statement contains a magic number: for (int x = 0; x < Width * Height; x++) {  				int imageData = BitConverter.ToInt32(index' x * 4);  				Seek(imageData' SeekOrigin.Begin);  				var img = new TmpImage();  				img.Read(this);  				Images.Add(img);  			}
Magic Number,CNCMaps.FileFormats,TmpImage,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\TmpFile.cs,Read,The following statement contains a magic number: f.Read(3);
Magic Number,CNCMaps.FileFormats,TmpImage,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\TmpFile.cs,Read,The following statement contains a magic number: TileData = f.Read(f.BlockWidth * f.BlockHeight / 2);
Magic Number,CNCMaps.FileFormats,TmpImage,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\TmpFile.cs,Read,The following statement contains a magic number: if (HasZData)  					ZData = f.Read(f.BlockWidth * f.BlockHeight / 2);
Magic Number,CNCMaps.FileFormats,VplFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\VplFile.cs,Parse,The following statement contains a magic number: var pal = Read(768);
Magic Number,CNCMaps.FileFormats,VplFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\VplFile.cs,Parse,The following statement contains a magic number: for (uint i = 0; i < _numSections; i++)  				_lookupSections.Add(Read(256));
Magic Number,CNCMaps.FileFormats,FileHeader,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\VxlFile.cs,Read,The following statement contains a magic number: FileName = f.ReadCString(16);
Magic Number,CNCMaps.FileFormats,FileHeader,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\VxlFile.cs,Read,The following statement contains a magic number: var pal = f.Read(768);
Magic Number,CNCMaps.FileFormats,TransfMatrix,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\VxlFile.cs,Read,The following statement contains a magic number: for (var i = 0; i < 3; ++i) {  					V[i].X = f.ReadFloat();  					V[i].Y = f.ReadFloat();  					V[i].Z = f.ReadFloat();  					V[i].W = f.ReadFloat();  				}
Magic Number,CNCMaps.FileFormats.Encodings,Blowfish,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Blowfish.cs,Blowfish,The following statement contains a magic number: for (int i = 0' j = 0; i < 18; ++i) {  				uint a = key[j++%key.Length];  				uint b = key[j++%key.Length];  				uint c = key[j++%key.Length];  				uint d = key[j++%key.Length];    				m_p[i] ^= a << 24 | b << 16 | c << 8 | d;  			}
Magic Number,CNCMaps.FileFormats.Encodings,Blowfish,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Blowfish.cs,Blowfish,The following statement contains a magic number: for (int i = 0' j = 0; i < 18; ++i) {  				uint a = key[j++%key.Length];  				uint b = key[j++%key.Length];  				uint c = key[j++%key.Length];  				uint d = key[j++%key.Length];    				m_p[i] ^= a << 24 | b << 16 | c << 8 | d;  			}
Magic Number,CNCMaps.FileFormats.Encodings,Blowfish,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Blowfish.cs,Blowfish,The following statement contains a magic number: for (int i = 0' j = 0; i < 18; ++i) {  				uint a = key[j++%key.Length];  				uint b = key[j++%key.Length];  				uint c = key[j++%key.Length];  				uint d = key[j++%key.Length];    				m_p[i] ^= a << 24 | b << 16 | c << 8 | d;  			}
Magic Number,CNCMaps.FileFormats.Encodings,Blowfish,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Blowfish.cs,Blowfish,The following statement contains a magic number: for (int i = 0' j = 0; i < 18; ++i) {  				uint a = key[j++%key.Length];  				uint b = key[j++%key.Length];  				uint c = key[j++%key.Length];  				uint d = key[j++%key.Length];    				m_p[i] ^= a << 24 | b << 16 | c << 8 | d;  			}
Magic Number,CNCMaps.FileFormats.Encodings,Blowfish,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Blowfish.cs,Blowfish,The following statement contains a magic number: for (int i = 0; i < 18;) {  				Encrypt(ref l' ref r);  				m_p[i++] = l;  				m_p[i++] = r;  			}
Magic Number,CNCMaps.FileFormats.Encodings,Blowfish,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Blowfish.cs,Blowfish,The following statement contains a magic number: for (int i = 0; i < 4; ++i)  				for (int j = 0; j < 256;) {  					Encrypt(ref l' ref r);  					m_s[i' j++] = l;  					m_s[i' j++] = r;  				}
Magic Number,CNCMaps.FileFormats.Encodings,Blowfish,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Blowfish.cs,Blowfish,The following statement contains a magic number: for (int i = 0; i < 4; ++i)  				for (int j = 0; j < 256;) {  					Encrypt(ref l' ref r);  					m_s[i' j++] = l;  					m_s[i' j++] = r;  				}
Magic Number,CNCMaps.FileFormats.Encodings,Blowfish,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Blowfish.cs,RunCipher,The following statement contains a magic number: int size = data.Length/2;
Magic Number,CNCMaps.FileFormats.Encodings,Blowfish,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Blowfish.cs,Encrypt,The following statement contains a magic number: for (int i = 1; i <= 16; i++' x ^= true) {  				if (x)  					Round(ref _a' _b' i);  				else  					Round(ref _b' _a' i);  			}
Magic Number,CNCMaps.FileFormats.Encodings,Blowfish,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Blowfish.cs,Encrypt,The following statement contains a magic number: _b ^= m_p[17];
Magic Number,CNCMaps.FileFormats.Encodings,Blowfish,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Blowfish.cs,Decrypt,The following statement contains a magic number: _a ^= m_p[17];
Magic Number,CNCMaps.FileFormats.Encodings,Blowfish,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Blowfish.cs,Decrypt,The following statement contains a magic number: for (int i = 16; i >= 1; i--' x ^= true) {  				if (x)  					Round(ref _a' _b' i);  				else  					Round(ref _b' _a' i);  			}
Magic Number,CNCMaps.FileFormats.Encodings,Blowfish,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Blowfish.cs,S,The following statement contains a magic number: return m_s[i' (x >> ((3 - i) << 3)) & 0xff];
Magic Number,CNCMaps.FileFormats.Encodings,Blowfish,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Blowfish.cs,S,The following statement contains a magic number: return m_s[i' (x >> ((3 - i) << 3)) & 0xff];
Magic Number,CNCMaps.FileFormats.Encodings,Blowfish,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Blowfish.cs,bf_f,The following statement contains a magic number: return ((S(x' 0) + S(x' 1)) ^ S(x' 2)) + S(x' 3);
Magic Number,CNCMaps.FileFormats.Encodings,Blowfish,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Blowfish.cs,bf_f,The following statement contains a magic number: return ((S(x' 0) + S(x' 1)) ^ S(x' 2)) + S(x' 3);
Magic Number,CNCMaps.FileFormats.Encodings,Blowfish,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Blowfish.cs,SwapBytes,The following statement contains a magic number: i = (i << 16) | (i >> 16);
Magic Number,CNCMaps.FileFormats.Encodings,Blowfish,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Blowfish.cs,SwapBytes,The following statement contains a magic number: i = (i << 16) | (i >> 16);
Magic Number,CNCMaps.FileFormats.Encodings,Blowfish,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Blowfish.cs,SwapBytes,The following statement contains a magic number: i = ((i << 8) & 0xff00ff00) | ((i >> 8) & 0x00ff00ff);
Magic Number,CNCMaps.FileFormats.Encodings,Blowfish,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Blowfish.cs,SwapBytes,The following statement contains a magic number: i = ((i << 8) & 0xff00ff00) | ((i >> 8) & 0x00ff00ff);
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,move_key_to_big,The following statement contains a magic number: unsafe {  				fixed (uint* _pn = &n[0]) {  					var pn = (byte*) _pn;  					uint i = blen*4;  					for (; i > klen; i--) pn[i - 1] = sign;  					for (; i > 0; i--) pn[i - 1] = key[klen - i];  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,key_to_bignum,The following statement contains a magic number: if (key[j] != 2) return;
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,key_to_bignum,The following statement contains a magic number: if ((key[j] & 0x80) != 0) {  				keylen = 0;  				for (i = 0; i < (key[j] & 0x7f); i++) keylen = (keylen << 8) | key[j + i + 1];  				j += (key[j] & 0x7f) + 1;  			}  			else {  				keylen = key[j];  				j++;  			}
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,key_to_bignum,The following statement contains a magic number: if (keylen <= len*4)  				move_key_to_big(n' key.Skip(j).ToArray()' keylen' len);
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,bitlen_bignum,The following statement contains a magic number: bitlen = ddlen*32;
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,init_pubkey,The following statement contains a magic number: var keytmp = new byte[256];
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,init_pubkey,The following statement contains a magic number: init_bignum(pubkey.key2' 0x10001' 64);
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,init_pubkey,The following statement contains a magic number: while (i < pubkeyStr.Length) {  				tmp = (uint) char2num[pubkeyStr[i++]];  				tmp <<= 6;  				tmp |= (byte) char2num[pubkeyStr[i++]];  				tmp <<= 6;  				tmp |= (byte) char2num[pubkeyStr[i++]];  				tmp <<= 6;  				tmp |= (byte) char2num[pubkeyStr[i++]];  				keytmp[i2++] = (byte) ((tmp >> 16) & 0xff);  				keytmp[i2++] = (byte) ((tmp >> 8) & 0xff);  				keytmp[i2++] = (byte) (tmp & 0xff);  			}
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,init_pubkey,The following statement contains a magic number: while (i < pubkeyStr.Length) {  				tmp = (uint) char2num[pubkeyStr[i++]];  				tmp <<= 6;  				tmp |= (byte) char2num[pubkeyStr[i++]];  				tmp <<= 6;  				tmp |= (byte) char2num[pubkeyStr[i++]];  				tmp <<= 6;  				tmp |= (byte) char2num[pubkeyStr[i++]];  				keytmp[i2++] = (byte) ((tmp >> 16) & 0xff);  				keytmp[i2++] = (byte) ((tmp >> 8) & 0xff);  				keytmp[i2++] = (byte) (tmp & 0xff);  			}
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,init_pubkey,The following statement contains a magic number: while (i < pubkeyStr.Length) {  				tmp = (uint) char2num[pubkeyStr[i++]];  				tmp <<= 6;  				tmp |= (byte) char2num[pubkeyStr[i++]];  				tmp <<= 6;  				tmp |= (byte) char2num[pubkeyStr[i++]];  				tmp <<= 6;  				tmp |= (byte) char2num[pubkeyStr[i++]];  				keytmp[i2++] = (byte) ((tmp >> 16) & 0xff);  				keytmp[i2++] = (byte) ((tmp >> 8) & 0xff);  				keytmp[i2++] = (byte) (tmp & 0xff);  			}
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,init_pubkey,The following statement contains a magic number: while (i < pubkeyStr.Length) {  				tmp = (uint) char2num[pubkeyStr[i++]];  				tmp <<= 6;  				tmp |= (byte) char2num[pubkeyStr[i++]];  				tmp <<= 6;  				tmp |= (byte) char2num[pubkeyStr[i++]];  				tmp <<= 6;  				tmp |= (byte) char2num[pubkeyStr[i++]];  				keytmp[i2++] = (byte) ((tmp >> 16) & 0xff);  				keytmp[i2++] = (byte) ((tmp >> 8) & 0xff);  				keytmp[i2++] = (byte) (tmp & 0xff);  			}
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,init_pubkey,The following statement contains a magic number: while (i < pubkeyStr.Length) {  				tmp = (uint) char2num[pubkeyStr[i++]];  				tmp <<= 6;  				tmp |= (byte) char2num[pubkeyStr[i++]];  				tmp <<= 6;  				tmp |= (byte) char2num[pubkeyStr[i++]];  				tmp <<= 6;  				tmp |= (byte) char2num[pubkeyStr[i++]];  				keytmp[i2++] = (byte) ((tmp >> 16) & 0xff);  				keytmp[i2++] = (byte) ((tmp >> 8) & 0xff);  				keytmp[i2++] = (byte) (tmp & 0xff);  			}
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,init_pubkey,The following statement contains a magic number: key_to_bignum(pubkey.key1' keytmp' 64);
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,init_pubkey,The following statement contains a magic number: pubkey.len = bitlen_bignum(pubkey.key1' 64) - 1;
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,len_predata,The following statement contains a magic number: uint a = (pubkey.len - 1)/8;
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,len_predata,The following statement contains a magic number: return (55/a + 1)*(a + 1);
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,shr_bignum,The following statement contains a magic number: int i2 = bits/32;
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,shr_bignum,The following statement contains a magic number: if (i2 > 0) {  				for (i = 0; i < len - i2; i++) n[i] = n[i + i2];  				for (; i < len; i++) n[i] = 0;  				bits = bits%32;  			}
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,shr_bignum,The following statement contains a magic number: for (i = 0; i < len - 1; i++)  				n[i] = (n[i] >> bits) | (n[i + 1] << (32 -  				                                      bits));
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,shl_bignum,The following statement contains a magic number: i2 = bits/32;
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,shl_bignum,The following statement contains a magic number: if (i2 > 0) {  				for (i = len - 1; i > i2; i--) n[i] = n[i - i2];  				for (; i > 0; i--) n[i] = 0;  				bits = bits%32;  			}
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,shl_bignum,The following statement contains a magic number: for (i = len - 1; i > 0; i--)  				n[i] = (n[i] << bits) | (n[i - 1] >> (32 -  				                                      bits));
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,inv_bignum,The following statement contains a magic number: var n_tmp = new uint[64];
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,inv_bignum,The following statement contains a magic number: bit = ((uint) 1) << (n2_bitlen%32);
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,inv_bignum,The following statement contains a magic number: j = ((n2_bitlen + 32)/32) - 1;
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,inv_bignum,The following statement contains a magic number: j = ((n2_bitlen + 32)/32) - 1;
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,inv_bignum,The following statement contains a magic number: n2_bytelen = (uint) ((n2_bitlen - 1)/32)*4;
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,inv_bignum,The following statement contains a magic number: n2_bytelen = (uint) ((n2_bitlen - 1)/32)*4;
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,inv_bignum,The following statement contains a magic number: n_tmp[n2_bytelen/4] |= ((uint) 1) << ((n2_bitlen - 1) & 0x1f);
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: glob1_len_x2 = (glob1_bitlen + 15)/16;
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: glob1_len_x2 = (glob1_bitlen + 15)/16;
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: mov_bignum(glob1_hi' glob1.Skip((int) len_bignum(glob1' len) - 2).ToArray()' 2);
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: mov_bignum(glob1_hi' glob1.Skip((int) len_bignum(glob1' len) - 2).ToArray()' 2);
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: glob1_hi_bitlen = bitlen_bignum(glob1_hi' 2) - 32;
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: glob1_hi_bitlen = bitlen_bignum(glob1_hi' 2) - 32;
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: shr_bignum(glob1_hi' (int) glob1_hi_bitlen' 2);
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: inv_bignum(glob1_hi_inv' glob1_hi' 2);
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: shr_bignum(glob1_hi_inv' 1' 2);
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: glob1_hi_bitlen = (glob1_hi_bitlen + 15)%16 + 1;
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: glob1_hi_bitlen = (glob1_hi_bitlen + 15)%16 + 1;
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: inc_bignum(glob1_hi_inv' 2);
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: if (bitlen_bignum(glob1_hi_inv' 2) > 32) {  				shr_bignum(glob1_hi_inv' 1' 2);  				glob1_hi_bitlen--;  			}
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: if (bitlen_bignum(glob1_hi_inv' 2) > 32) {  				shr_bignum(glob1_hi_inv' 1' 2);  				glob1_hi_bitlen--;  			}
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: if (bitlen_bignum(glob1_hi_inv' 2) > 32) {  				shr_bignum(glob1_hi_inv' 1' 2);  				glob1_hi_bitlen--;  			}
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,init_two_dw,The following statement contains a magic number: glob1_hi_inv_hi = (ushort) (glob1_hi_inv[0] >> 16);
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,mul_bignum_word,The following statement contains a magic number: fixed (uint* _pn2 = &n2[0]) {  				var pn2 = (ushort*) _pn2;    				tmp = 0;  				for (i = 0; i < len; i++) {  					tmp = mul*(*pn2) + (*pn1) + tmp;  					*pn1 = (ushort) tmp;  					pn1++;  					pn2++;  					tmp >>= 16;  				}  				*pn1 += (ushort) tmp;  			}
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,mul_bignum,The following statement contains a magic number: unsafe {  				fixed (uint* _psrc2 = &src2[0])  				fixed (uint* _pdest = &dest[0]) {  					var psrc2 = (ushort*) _psrc2;  					var pdest = (ushort*) _pdest;    					init_bignum(dest' 0' len*2);  					for (i = 0; i < len*2; i++)  						mul_bignum_word(pdest++' src1' *psrc2++' len*2);  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,mul_bignum,The following statement contains a magic number: unsafe {  				fixed (uint* _psrc2 = &src2[0])  				fixed (uint* _pdest = &dest[0]) {  					var psrc2 = (ushort*) _psrc2;  					var pdest = (ushort*) _pdest;    					init_bignum(dest' 0' len*2);  					for (i = 0; i < len*2; i++)  						mul_bignum_word(pdest++' src1' *psrc2++' len*2);  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,mul_bignum,The following statement contains a magic number: unsafe {  				fixed (uint* _psrc2 = &src2[0])  				fixed (uint* _pdest = &dest[0]) {  					var psrc2 = (ushort*) _psrc2;  					var pdest = (ushort*) _pdest;    					init_bignum(dest' 0' len*2);  					for (i = 0; i < len*2; i++)  						mul_bignum_word(pdest++' src1' *psrc2++' len*2);  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,get_mulword,The following statement contains a magic number: var i = (uint) ((((((((((*(wn - 1) ^ 0xffff) & 0xffff)*glob1_hi_inv_lo + 0x10000) >> 1)  			                     + (((*(wn - 2) ^ 0xffff)*glob1_hi_inv_hi + glob1_hi_inv_hi) >> 1) + 1)  			                    >> 16) + ((((*(wn - 1) ^ 0xffff) & 0xffff)*glob1_hi_inv_hi) >> 1) +  			                   (((*wn ^ 0xffff)*glob1_hi_inv_lo) >> 1) + 1) >> 14) + glob1_hi_inv_hi  			                 *(*wn ^ 0xffff)*2) >> (int) glob1_hi_bitlen);
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,get_mulword,The following statement contains a magic number: var i = (uint) ((((((((((*(wn - 1) ^ 0xffff) & 0xffff)*glob1_hi_inv_lo + 0x10000) >> 1)  			                     + (((*(wn - 2) ^ 0xffff)*glob1_hi_inv_hi + glob1_hi_inv_hi) >> 1) + 1)  			                    >> 16) + ((((*(wn - 1) ^ 0xffff) & 0xffff)*glob1_hi_inv_hi) >> 1) +  			                   (((*wn ^ 0xffff)*glob1_hi_inv_lo) >> 1) + 1) >> 14) + glob1_hi_inv_hi  			                 *(*wn ^ 0xffff)*2) >> (int) glob1_hi_bitlen);
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,get_mulword,The following statement contains a magic number: var i = (uint) ((((((((((*(wn - 1) ^ 0xffff) & 0xffff)*glob1_hi_inv_lo + 0x10000) >> 1)  			                     + (((*(wn - 2) ^ 0xffff)*glob1_hi_inv_hi + glob1_hi_inv_hi) >> 1) + 1)  			                    >> 16) + ((((*(wn - 1) ^ 0xffff) & 0xffff)*glob1_hi_inv_hi) >> 1) +  			                   (((*wn ^ 0xffff)*glob1_hi_inv_lo) >> 1) + 1) >> 14) + glob1_hi_inv_hi  			                 *(*wn ^ 0xffff)*2) >> (int) glob1_hi_bitlen);
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,get_mulword,The following statement contains a magic number: var i = (uint) ((((((((((*(wn - 1) ^ 0xffff) & 0xffff)*glob1_hi_inv_lo + 0x10000) >> 1)  			                     + (((*(wn - 2) ^ 0xffff)*glob1_hi_inv_hi + glob1_hi_inv_hi) >> 1) + 1)  			                    >> 16) + ((((*(wn - 1) ^ 0xffff) & 0xffff)*glob1_hi_inv_hi) >> 1) +  			                   (((*wn ^ 0xffff)*glob1_hi_inv_lo) >> 1) + 1) >> 14) + glob1_hi_inv_hi  			                 *(*wn ^ 0xffff)*2) >> (int) glob1_hi_bitlen);
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,calc_a_bignum,The following statement contains a magic number: unsafe {  				fixed (uint* g1 = &glob1[0])  				fixed (uint* g2 = &glob2[0]) {  					mul_bignum(glob2' n2' n3' len);  					glob2[len*2] = 0;  					g2_len_x2 = len_bignum(glob2' len*2 + 1)*2;  					if (g2_len_x2 >= glob1_len_x2) {  						inc_bignum(glob2' len*2 + 1);  						neg_bignum(glob2' len*2 + 1);  						len_diff = g2_len_x2 + 1 - glob1_len_x2;  						ushort* esi = ((ushort*) g2) + (1 + g2_len_x2 - glob1_len_x2);  						ushort* edi = ((ushort*) g2) + (g2_len_x2 + 1);  						for (; len_diff != 0; len_diff--) {  							edi--;  							uint tmp = get_mulword((uint*) edi);  							esi--;  							if (tmp > 0) {  								mul_bignum_word(esi' glob1' tmp' 2*len);  								if ((*edi & 0x8000) == 0) {  									if (0 != sub_bignum((uint*) esi' (uint*) esi' g1' 0' (int) len)) (*edi)--;  								}  							}  						}  						neg_bignum(glob2' len);  						dec_bignum(glob2' len);  					}  					mov_bignum(n1' glob2' len);  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,calc_a_bignum,The following statement contains a magic number: unsafe {  				fixed (uint* g1 = &glob1[0])  				fixed (uint* g2 = &glob2[0]) {  					mul_bignum(glob2' n2' n3' len);  					glob2[len*2] = 0;  					g2_len_x2 = len_bignum(glob2' len*2 + 1)*2;  					if (g2_len_x2 >= glob1_len_x2) {  						inc_bignum(glob2' len*2 + 1);  						neg_bignum(glob2' len*2 + 1);  						len_diff = g2_len_x2 + 1 - glob1_len_x2;  						ushort* esi = ((ushort*) g2) + (1 + g2_len_x2 - glob1_len_x2);  						ushort* edi = ((ushort*) g2) + (g2_len_x2 + 1);  						for (; len_diff != 0; len_diff--) {  							edi--;  							uint tmp = get_mulword((uint*) edi);  							esi--;  							if (tmp > 0) {  								mul_bignum_word(esi' glob1' tmp' 2*len);  								if ((*edi & 0x8000) == 0) {  									if (0 != sub_bignum((uint*) esi' (uint*) esi' g1' 0' (int) len)) (*edi)--;  								}  							}  						}  						neg_bignum(glob2' len);  						dec_bignum(glob2' len);  					}  					mov_bignum(n1' glob2' len);  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,calc_a_bignum,The following statement contains a magic number: unsafe {  				fixed (uint* g1 = &glob1[0])  				fixed (uint* g2 = &glob2[0]) {  					mul_bignum(glob2' n2' n3' len);  					glob2[len*2] = 0;  					g2_len_x2 = len_bignum(glob2' len*2 + 1)*2;  					if (g2_len_x2 >= glob1_len_x2) {  						inc_bignum(glob2' len*2 + 1);  						neg_bignum(glob2' len*2 + 1);  						len_diff = g2_len_x2 + 1 - glob1_len_x2;  						ushort* esi = ((ushort*) g2) + (1 + g2_len_x2 - glob1_len_x2);  						ushort* edi = ((ushort*) g2) + (g2_len_x2 + 1);  						for (; len_diff != 0; len_diff--) {  							edi--;  							uint tmp = get_mulword((uint*) edi);  							esi--;  							if (tmp > 0) {  								mul_bignum_word(esi' glob1' tmp' 2*len);  								if ((*edi & 0x8000) == 0) {  									if (0 != sub_bignum((uint*) esi' (uint*) esi' g1' 0' (int) len)) (*edi)--;  								}  							}  						}  						neg_bignum(glob2' len);  						dec_bignum(glob2' len);  					}  					mov_bignum(n1' glob2' len);  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,calc_a_bignum,The following statement contains a magic number: unsafe {  				fixed (uint* g1 = &glob1[0])  				fixed (uint* g2 = &glob2[0]) {  					mul_bignum(glob2' n2' n3' len);  					glob2[len*2] = 0;  					g2_len_x2 = len_bignum(glob2' len*2 + 1)*2;  					if (g2_len_x2 >= glob1_len_x2) {  						inc_bignum(glob2' len*2 + 1);  						neg_bignum(glob2' len*2 + 1);  						len_diff = g2_len_x2 + 1 - glob1_len_x2;  						ushort* esi = ((ushort*) g2) + (1 + g2_len_x2 - glob1_len_x2);  						ushort* edi = ((ushort*) g2) + (g2_len_x2 + 1);  						for (; len_diff != 0; len_diff--) {  							edi--;  							uint tmp = get_mulword((uint*) edi);  							esi--;  							if (tmp > 0) {  								mul_bignum_word(esi' glob1' tmp' 2*len);  								if ((*edi & 0x8000) == 0) {  									if (0 != sub_bignum((uint*) esi' (uint*) esi' g1' 0' (int) len)) (*edi)--;  								}  							}  						}  						neg_bignum(glob2' len);  						dec_bignum(glob2' len);  					}  					mov_bignum(n1' glob2' len);  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,calc_a_bignum,The following statement contains a magic number: unsafe {  				fixed (uint* g1 = &glob1[0])  				fixed (uint* g2 = &glob2[0]) {  					mul_bignum(glob2' n2' n3' len);  					glob2[len*2] = 0;  					g2_len_x2 = len_bignum(glob2' len*2 + 1)*2;  					if (g2_len_x2 >= glob1_len_x2) {  						inc_bignum(glob2' len*2 + 1);  						neg_bignum(glob2' len*2 + 1);  						len_diff = g2_len_x2 + 1 - glob1_len_x2;  						ushort* esi = ((ushort*) g2) + (1 + g2_len_x2 - glob1_len_x2);  						ushort* edi = ((ushort*) g2) + (g2_len_x2 + 1);  						for (; len_diff != 0; len_diff--) {  							edi--;  							uint tmp = get_mulword((uint*) edi);  							esi--;  							if (tmp > 0) {  								mul_bignum_word(esi' glob1' tmp' 2*len);  								if ((*edi & 0x8000) == 0) {  									if (0 != sub_bignum((uint*) esi' (uint*) esi' g1' 0' (int) len)) (*edi)--;  								}  							}  						}  						neg_bignum(glob2' len);  						dec_bignum(glob2' len);  					}  					mov_bignum(n1' glob2' len);  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,calc_a_bignum,The following statement contains a magic number: unsafe {  				fixed (uint* g1 = &glob1[0])  				fixed (uint* g2 = &glob2[0]) {  					mul_bignum(glob2' n2' n3' len);  					glob2[len*2] = 0;  					g2_len_x2 = len_bignum(glob2' len*2 + 1)*2;  					if (g2_len_x2 >= glob1_len_x2) {  						inc_bignum(glob2' len*2 + 1);  						neg_bignum(glob2' len*2 + 1);  						len_diff = g2_len_x2 + 1 - glob1_len_x2;  						ushort* esi = ((ushort*) g2) + (1 + g2_len_x2 - glob1_len_x2);  						ushort* edi = ((ushort*) g2) + (g2_len_x2 + 1);  						for (; len_diff != 0; len_diff--) {  							edi--;  							uint tmp = get_mulword((uint*) edi);  							esi--;  							if (tmp > 0) {  								mul_bignum_word(esi' glob1' tmp' 2*len);  								if ((*edi & 0x8000) == 0) {  									if (0 != sub_bignum((uint*) esi' (uint*) esi' g1' 0' (int) len)) (*edi)--;  								}  							}  						}  						neg_bignum(glob2' len);  						dec_bignum(glob2' len);  					}  					mov_bignum(n1' glob2' len);  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,clear_tmp_vars,The following statement contains a magic number: init_bignum(glob1_hi_inv' 0' 4);
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,clear_tmp_vars,The following statement contains a magic number: init_bignum(glob1_hi' 0' 4);
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,calc_a_key,The following statement contains a magic number: var n_tmp = new uint[64];
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,calc_a_key,The following statement contains a magic number: unsafe {  				fixed (uint* _pn3 = &n3[0]) {  					uint* pn3 = _pn3;    					init_bignum(n1' 1' len);  					n4_len = len_bignum(n4' len);  					init_two_dw(n4' n4_len);  					n3_bitlen = (int) bitlen_bignum(n3' n4_len);  					n3_len = (uint) ((n3_bitlen + 31)/32);  					bit_mask = (((uint) 1) << ((n3_bitlen - 1)%32)) >> 1;  					pn3 += n3_len - 1;  					n3_bitlen--;  					mov_bignum(n1' n2' n4_len);  					while (--n3_bitlen != -1) {  						if (bit_mask == 0) {  							bit_mask = 0x80000000;  							pn3--;  						}  						calc_a_bignum(n_tmp' n1' n1' n4_len);  						if ((*pn3 & bit_mask) != 0)  							calc_a_bignum(n1' n_tmp' n2' n4_len);  						else  							mov_bignum(n1' n_tmp' n4_len);  						bit_mask >>= 1;  					}  					init_bignum(n_tmp' 0' n4_len);  					clear_tmp_vars(len);  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,calc_a_key,The following statement contains a magic number: unsafe {  				fixed (uint* _pn3 = &n3[0]) {  					uint* pn3 = _pn3;    					init_bignum(n1' 1' len);  					n4_len = len_bignum(n4' len);  					init_two_dw(n4' n4_len);  					n3_bitlen = (int) bitlen_bignum(n3' n4_len);  					n3_len = (uint) ((n3_bitlen + 31)/32);  					bit_mask = (((uint) 1) << ((n3_bitlen - 1)%32)) >> 1;  					pn3 += n3_len - 1;  					n3_bitlen--;  					mov_bignum(n1' n2' n4_len);  					while (--n3_bitlen != -1) {  						if (bit_mask == 0) {  							bit_mask = 0x80000000;  							pn3--;  						}  						calc_a_bignum(n_tmp' n1' n1' n4_len);  						if ((*pn3 & bit_mask) != 0)  							calc_a_bignum(n1' n_tmp' n2' n4_len);  						else  							mov_bignum(n1' n_tmp' n4_len);  						bit_mask >>= 1;  					}  					init_bignum(n_tmp' 0' n4_len);  					clear_tmp_vars(len);  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,calc_a_key,The following statement contains a magic number: unsafe {  				fixed (uint* _pn3 = &n3[0]) {  					uint* pn3 = _pn3;    					init_bignum(n1' 1' len);  					n4_len = len_bignum(n4' len);  					init_two_dw(n4' n4_len);  					n3_bitlen = (int) bitlen_bignum(n3' n4_len);  					n3_len = (uint) ((n3_bitlen + 31)/32);  					bit_mask = (((uint) 1) << ((n3_bitlen - 1)%32)) >> 1;  					pn3 += n3_len - 1;  					n3_bitlen--;  					mov_bignum(n1' n2' n4_len);  					while (--n3_bitlen != -1) {  						if (bit_mask == 0) {  							bit_mask = 0x80000000;  							pn3--;  						}  						calc_a_bignum(n_tmp' n1' n1' n4_len);  						if ((*pn3 & bit_mask) != 0)  							calc_a_bignum(n1' n_tmp' n2' n4_len);  						else  							mov_bignum(n1' n_tmp' n4_len);  						bit_mask >>= 1;  					}  					init_bignum(n_tmp' 0' n4_len);  					clear_tmp_vars(len);  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,process_predata,The following statement contains a magic number: var n2 = new uint[64];
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,process_predata,The following statement contains a magic number: var n3 = new uint[64];
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,process_predata,The following statement contains a magic number: uint a = (pubkey.len - 1)/8;
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,process_predata,The following statement contains a magic number: while (a + 1 <= pre_len) {  				init_bignum(n2' 0' 64);  				fixed (uint* pn2 = &n2[0])  					memcpy((byte*) pn2' pre' (int) a + 1);  				calc_a_key(n3' n2' pubkey.key2' pubkey.key1' 64);    				fixed (uint* pn3 = &n3[0])  					memcpy(buf' (byte*) pn3' (int) a);    				pre_len -= a + 1;  				pre += a + 1;  				buf += a;  			}
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,process_predata,The following statement contains a magic number: while (a + 1 <= pre_len) {  				init_bignum(n2' 0' 64);  				fixed (uint* pn2 = &n2[0])  					memcpy((byte*) pn2' pre' (int) a + 1);  				calc_a_key(n3' n2' pubkey.key2' pubkey.key1' 64);    				fixed (uint* pn3 = &n3[0])  					memcpy(buf' (byte*) pn3' (int) a);    				pre_len -= a + 1;  				pre += a + 1;  				buf += a;  			}
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,DecryptKey,The following statement contains a magic number: var dest = new byte[256];
Magic Number,CNCMaps.FileFormats.Encodings,BlowfishKeyProvider,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\BlowfishKeyProvider.cs,DecryptKey,The following statement contains a magic number: return dest.Take(56).ToArray();
Magic Number,CNCMaps.FileFormats.Encodings,CRC32,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\CRC32.cs,CalculateCrc,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  				crc = (crc >> 8) ^ LookUp[(crc & 0xFF) ^ data[i]];  			}
Magic Number,CNCMaps.FileFormats.Encodings,CRC32,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\CRC32.cs,CalculateCrc,The following statement contains a magic number: for (int i = 0; i < len; i++)  				crc = (crc >> 8) ^ LookUp[(crc & 0xFF) ^ *data++];
Magic Number,CNCMaps.FileFormats.Encodings,Format3,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Format3.cs,DecodeInto,The following statement contains a magic number: for (int y = 0; y < cy; y++) {  				var count = (ushort) (*(ushort*) r - 2);  				r += 2;  				int x = 0;  				while (count-- > 0) {  					byte v = *r++;  					if (v != 0) {  						x++;  						*w++ = v;  					}  					else {  						count--;  						v = *r++;  						if (x + v > cx)  							v = (byte) (cx - x);  						x += v;  						while (v-- != 0)  							*w++ = 0;  					}  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,Format3,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Format3.cs,DecodeInto,The following statement contains a magic number: for (int y = 0; y < cy; y++) {  				var count = (ushort) (*(ushort*) r - 2);  				r += 2;  				int x = 0;  				while (count-- > 0) {  					byte v = *r++;  					if (v != 0) {  						x++;  						*w++ = v;  					}  					else {  						count--;  						v = *r++;  						if (x + v > cx)  							v = (byte) (cx - x);  						x += v;  						while (v-- != 0)  							*w++ = 0;  					}  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,Format40,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Format40.cs,DecodeInto,The following statement contains a magic number: while (true) {  				byte i = *src++;  				if ((i & 0x80) == 0) {  					int count = i & 0x7F;  					if (count == 0) {  						// case 6  						count = *src++;  						byte value = *src++;  						for (int end = destIndex + count; destIndex < end; destIndex++)  							dest[destIndex] ^= value;  					}  					else {  						// case 5  						for (int end = destIndex + count; destIndex < end; destIndex++)  							dest[destIndex] ^= *src++;  					}  				}  				else {  					int count = i & 0x7F;  					if (count == 0) {  						count = (*src << 8) + *(src + 1);  						src += 2;  						if (count == 0)  							return destIndex;    						if ((count & 0x8000) == 0) {  							// case 2  							destIndex += (count & 0x7FFF);  						}  						else if ((count & 0x4000) == 0) {  							// case 3  							for (int end = destIndex + (count & 0x3FFF); destIndex < end; destIndex++)  								dest[destIndex] ^= *src++;  						}  						else {  							// case 4  							byte value = *src++;  							for (int end = destIndex + (count & 0x3FFF); destIndex < end; destIndex++)  								dest[destIndex] ^= value;  						}  					}  					else {  						// case 1  						destIndex += count;  					}  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,Format40,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Format40.cs,DecodeInto,The following statement contains a magic number: while (true) {  				byte i = *src++;  				if ((i & 0x80) == 0) {  					int count = i & 0x7F;  					if (count == 0) {  						// case 6  						count = *src++;  						byte value = *src++;  						for (int end = destIndex + count; destIndex < end; destIndex++)  							dest[destIndex] ^= value;  					}  					else {  						// case 5  						for (int end = destIndex + count; destIndex < end; destIndex++)  							dest[destIndex] ^= *src++;  					}  				}  				else {  					int count = i & 0x7F;  					if (count == 0) {  						count = (*src << 8) + *(src + 1);  						src += 2;  						if (count == 0)  							return destIndex;    						if ((count & 0x8000) == 0) {  							// case 2  							destIndex += (count & 0x7FFF);  						}  						else if ((count & 0x4000) == 0) {  							// case 3  							for (int end = destIndex + (count & 0x3FFF); destIndex < end; destIndex++)  								dest[destIndex] ^= *src++;  						}  						else {  							// case 4  							byte value = *src++;  							for (int end = destIndex + (count & 0x3FFF); destIndex < end; destIndex++)  								dest[destIndex] ^= value;  						}  					}  					else {  						// case 1  						destIndex += count;  					}  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,Format5,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Format5.cs,DecodeInto,The following statement contains a magic number: fixed (byte* pr = src' pw = dest) {  				byte* r = pr' w = pw;  				byte* w_end = w + dest.Length;    				while (w < w_end) {  					ushort size_in = *(ushort*)r;  					r += 2;  					uint size_out = *(ushort*)r;  					r += 2;    					if (size_in == 0 || size_out == 0)  						break;    					if (format == 80)  						Format80.DecodeInto(r' w);  					else  						MiniLZO.Decompress(r' size_in' w' ref size_out);  					r += size_in;  					w += size_out;  				}  				return (uint)(w - pw);  			}
Magic Number,CNCMaps.FileFormats.Encodings,Format5,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Format5.cs,DecodeInto,The following statement contains a magic number: fixed (byte* pr = src' pw = dest) {  				byte* r = pr' w = pw;  				byte* w_end = w + dest.Length;    				while (w < w_end) {  					ushort size_in = *(ushort*)r;  					r += 2;  					uint size_out = *(ushort*)r;  					r += 2;    					if (size_in == 0 || size_out == 0)  						break;    					if (format == 80)  						Format80.DecodeInto(r' w);  					else  						MiniLZO.Decompress(r' size_in' w' ref size_out);  					r += size_in;  					w += size_out;  				}  				return (uint)(w - pw);  			}
Magic Number,CNCMaps.FileFormats.Encodings,Format5,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Format5.cs,DecodeInto,The following statement contains a magic number: fixed (byte* pr = src' pw = dest) {  				byte* r = pr' w = pw;  				byte* w_end = w + dest.Length;    				while (w < w_end) {  					ushort size_in = *(ushort*)r;  					r += 2;  					uint size_out = *(ushort*)r;  					r += 2;    					if (size_in == 0 || size_out == 0)  						break;    					if (format == 80)  						Format80.DecodeInto(r' w);  					else  						MiniLZO.Decompress(r' size_in' w' ref size_out);  					r += size_in;  					w += size_out;  				}  				return (uint)(w - pw);  			}
Magic Number,CNCMaps.FileFormats.Encodings,Format5,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Format5.cs,Encode,The following statement contains a magic number: var dest = new byte[source.Length * 2];
Magic Number,CNCMaps.FileFormats.Encodings,Format5,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Format5.cs,Encode,The following statement contains a magic number: while (!src.Eof) {  				var cb_in = (short)Math.Min(src.Remaining' 8192);  				var chunk_in = src.Read(cb_in);  				var chunk_out = format == 80 ? Format80.Encode(chunk_in) : EncodeSection(chunk_in);  				uint cb_out = (ushort)chunk_out.Length;    				Array.Copy(BitConverter.GetBytes(cb_out)' 0' dest' w' 2);  				w += 2;  				Array.Copy(BitConverter.GetBytes(cb_in)' 0' dest' w' 2);  				w += 2;  				Array.Copy(chunk_out' 0' dest' w' chunk_out.Length);  				w += chunk_out.Length;  			}
Magic Number,CNCMaps.FileFormats.Encodings,Format5,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Format5.cs,Encode,The following statement contains a magic number: while (!src.Eof) {  				var cb_in = (short)Math.Min(src.Remaining' 8192);  				var chunk_in = src.Read(cb_in);  				var chunk_out = format == 80 ? Format80.Encode(chunk_in) : EncodeSection(chunk_in);  				uint cb_out = (ushort)chunk_out.Length;    				Array.Copy(BitConverter.GetBytes(cb_out)' 0' dest' w' 2);  				w += 2;  				Array.Copy(BitConverter.GetBytes(cb_in)' 0' dest' w' 2);  				w += 2;  				Array.Copy(chunk_out' 0' dest' w' chunk_out.Length);  				w += chunk_out.Length;  			}
Magic Number,CNCMaps.FileFormats.Encodings,Format5,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Format5.cs,Encode,The following statement contains a magic number: while (!src.Eof) {  				var cb_in = (short)Math.Min(src.Remaining' 8192);  				var chunk_in = src.Read(cb_in);  				var chunk_out = format == 80 ? Format80.Encode(chunk_in) : EncodeSection(chunk_in);  				uint cb_out = (ushort)chunk_out.Length;    				Array.Copy(BitConverter.GetBytes(cb_out)' 0' dest' w' 2);  				w += 2;  				Array.Copy(BitConverter.GetBytes(cb_in)' 0' dest' w' 2);  				w += 2;  				Array.Copy(chunk_out' 0' dest' w' chunk_out.Length);  				w += chunk_out.Length;  			}
Magic Number,CNCMaps.FileFormats.Encodings,Format5,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Format5.cs,Encode,The following statement contains a magic number: while (!src.Eof) {  				var cb_in = (short)Math.Min(src.Remaining' 8192);  				var chunk_in = src.Read(cb_in);  				var chunk_out = format == 80 ? Format80.Encode(chunk_in) : EncodeSection(chunk_in);  				uint cb_out = (ushort)chunk_out.Length;    				Array.Copy(BitConverter.GetBytes(cb_out)' 0' dest' w' 2);  				w += 2;  				Array.Copy(BitConverter.GetBytes(cb_in)' 0' dest' w' 2);  				w += 2;  				Array.Copy(chunk_out' 0' dest' w' chunk_out.Length);  				w += chunk_out.Length;  			}
Magic Number,CNCMaps.FileFormats.Encodings,Format5,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Format5.cs,Encode,The following statement contains a magic number: while (!src.Eof) {  				var cb_in = (short)Math.Min(src.Remaining' 8192);  				var chunk_in = src.Read(cb_in);  				var chunk_out = format == 80 ? Format80.Encode(chunk_in) : EncodeSection(chunk_in);  				uint cb_out = (ushort)chunk_out.Length;    				Array.Copy(BitConverter.GetBytes(cb_out)' 0' dest' w' 2);  				w += 2;  				Array.Copy(BitConverter.GetBytes(cb_in)' 0' dest' w' 2);  				w += 2;  				Array.Copy(chunk_out' 0' dest' w' chunk_out.Length);  				w += chunk_out.Length;  			}
Magic Number,CNCMaps.FileFormats.Encodings,Format5,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Format5.cs,Encode,The following statement contains a magic number: while (!src.Eof) {  				var cb_in = (short)Math.Min(src.Remaining' 8192);  				var chunk_in = src.Read(cb_in);  				var chunk_out = format == 80 ? Format80.Encode(chunk_in) : EncodeSection(chunk_in);  				uint cb_out = (ushort)chunk_out.Length;    				Array.Copy(BitConverter.GetBytes(cb_out)' 0' dest' w' 2);  				w += 2;  				Array.Copy(BitConverter.GetBytes(cb_in)' 0' dest' w' 2);  				w += 2;  				Array.Copy(chunk_out' 0' dest' w' chunk_out.Length);  				w += chunk_out.Length;  			}
Magic Number,CNCMaps.FileFormats.Encodings,Format80,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Format80.cs,DecodeInto,The following statement contains a magic number: while (true) {  				byte i = ctx.ReadByte();  				if ((i & 0x80) == 0) {  					// case 2  					byte secondByte = ctx.ReadByte();  					int count = ((i & 0x70) >> 4) + 3;  					int rpos = ((i & 0xf) << 8) + secondByte;    					ReplicatePrevious(dest' destIndex' destIndex - rpos' count);  					destIndex += count;  				}  				else if ((i & 0x40) == 0) {  					// case 1  					int count = i & 0x3F;  					if (count == 0)  						return destIndex;    					ctx.Read(dest' destIndex' count);  					destIndex += count;  				}  				else {  					int count3 = i & 0x3F;  					if (count3 == 0x3E) {  						// case 4  						int count = ctx.ReadInt16();  						byte color = ctx.ReadByte();    						for (int end = destIndex + count; destIndex < end; destIndex++)  							dest[destIndex] = color;  					}  					else if (count3 == 0x3F) {  						// case 5  						int count = ctx.ReadInt16();  						int srcIndex = ctx.ReadInt16();  						if (srcIndex >= destIndex)  							throw new NotImplementedException(string.Format("srcIndex >= destIndex  {0}  {1}"' srcIndex' destIndex));    						for (int end = destIndex + count; destIndex < end; destIndex++)  							dest[destIndex] = dest[srcIndex++];  					}  					else {  						// case 3  						int count = count3 + 3;  						int srcIndex = ctx.ReadInt16();  						if (srcIndex >= destIndex)  							throw new NotImplementedException(string.Format("srcIndex >= destIndex  {0}  {1}"' srcIndex' destIndex));    						for (int end = destIndex + count; destIndex < end; destIndex++)  							dest[destIndex] = dest[srcIndex++];  					}  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,Format80,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Format80.cs,DecodeInto,The following statement contains a magic number: while (true) {  				byte i = ctx.ReadByte();  				if ((i & 0x80) == 0) {  					// case 2  					byte secondByte = ctx.ReadByte();  					int count = ((i & 0x70) >> 4) + 3;  					int rpos = ((i & 0xf) << 8) + secondByte;    					ReplicatePrevious(dest' destIndex' destIndex - rpos' count);  					destIndex += count;  				}  				else if ((i & 0x40) == 0) {  					// case 1  					int count = i & 0x3F;  					if (count == 0)  						return destIndex;    					ctx.Read(dest' destIndex' count);  					destIndex += count;  				}  				else {  					int count3 = i & 0x3F;  					if (count3 == 0x3E) {  						// case 4  						int count = ctx.ReadInt16();  						byte color = ctx.ReadByte();    						for (int end = destIndex + count; destIndex < end; destIndex++)  							dest[destIndex] = color;  					}  					else if (count3 == 0x3F) {  						// case 5  						int count = ctx.ReadInt16();  						int srcIndex = ctx.ReadInt16();  						if (srcIndex >= destIndex)  							throw new NotImplementedException(string.Format("srcIndex >= destIndex  {0}  {1}"' srcIndex' destIndex));    						for (int end = destIndex + count; destIndex < end; destIndex++)  							dest[destIndex] = dest[srcIndex++];  					}  					else {  						// case 3  						int count = count3 + 3;  						int srcIndex = ctx.ReadInt16();  						if (srcIndex >= destIndex)  							throw new NotImplementedException(string.Format("srcIndex >= destIndex  {0}  {1}"' srcIndex' destIndex));    						for (int end = destIndex + count; destIndex < end; destIndex++)  							dest[destIndex] = dest[srcIndex++];  					}  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,Format80,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Format80.cs,DecodeInto,The following statement contains a magic number: while (true) {  				byte i = ctx.ReadByte();  				if ((i & 0x80) == 0) {  					// case 2  					byte secondByte = ctx.ReadByte();  					int count = ((i & 0x70) >> 4) + 3;  					int rpos = ((i & 0xf) << 8) + secondByte;    					ReplicatePrevious(dest' destIndex' destIndex - rpos' count);  					destIndex += count;  				}  				else if ((i & 0x40) == 0) {  					// case 1  					int count = i & 0x3F;  					if (count == 0)  						return destIndex;    					ctx.Read(dest' destIndex' count);  					destIndex += count;  				}  				else {  					int count3 = i & 0x3F;  					if (count3 == 0x3E) {  						// case 4  						int count = ctx.ReadInt16();  						byte color = ctx.ReadByte();    						for (int end = destIndex + count; destIndex < end; destIndex++)  							dest[destIndex] = color;  					}  					else if (count3 == 0x3F) {  						// case 5  						int count = ctx.ReadInt16();  						int srcIndex = ctx.ReadInt16();  						if (srcIndex >= destIndex)  							throw new NotImplementedException(string.Format("srcIndex >= destIndex  {0}  {1}"' srcIndex' destIndex));    						for (int end = destIndex + count; destIndex < end; destIndex++)  							dest[destIndex] = dest[srcIndex++];  					}  					else {  						// case 3  						int count = count3 + 3;  						int srcIndex = ctx.ReadInt16();  						if (srcIndex >= destIndex)  							throw new NotImplementedException(string.Format("srcIndex >= destIndex  {0}  {1}"' srcIndex' destIndex));    						for (int end = destIndex + count; destIndex < end; destIndex++)  							dest[destIndex] = dest[srcIndex++];  					}  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,Format80,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Format80.cs,DecodeInto,The following statement contains a magic number: while (true) {  				byte i = ctx.ReadByte();  				if ((i & 0x80) == 0) {  					// case 2  					byte secondByte = ctx.ReadByte();  					int count = ((i & 0x70) >> 4) + 3;  					int rpos = ((i & 0xf) << 8) + secondByte;    					ReplicatePrevious(dest' destIndex' destIndex - rpos' count);  					destIndex += count;  				}  				else if ((i & 0x40) == 0) {  					// case 1  					int count = i & 0x3F;  					if (count == 0)  						return destIndex;    					ctx.Read(dest' destIndex' count);  					destIndex += count;  				}  				else {  					int count3 = i & 0x3F;  					if (count3 == 0x3E) {  						// case 4  						int count = ctx.ReadInt16();  						byte color = ctx.ReadByte();    						for (int end = destIndex + count; destIndex < end; destIndex++)  							dest[destIndex] = color;  					}  					else if (count3 == 0x3F) {  						// case 5  						int count = ctx.ReadInt16();  						int srcIndex = ctx.ReadInt16();  						if (srcIndex >= destIndex)  							throw new NotImplementedException(string.Format("srcIndex >= destIndex  {0}  {1}"' srcIndex' destIndex));    						for (int end = destIndex + count; destIndex < end; destIndex++)  							dest[destIndex] = dest[srcIndex++];  					}  					else {  						// case 3  						int count = count3 + 3;  						int srcIndex = ctx.ReadInt16();  						if (srcIndex >= destIndex)  							throw new NotImplementedException(string.Format("srcIndex >= destIndex  {0}  {1}"' srcIndex' destIndex));    						for (int end = destIndex + count; destIndex < end; destIndex++)  							dest[destIndex] = dest[srcIndex++];  					}  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,Format80,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Format80.cs,DecodeInto,The following statement contains a magic number: while (true) {  				byte code = *readp++;  				byte* copyp;  				int count;  				if ((~code & 0x80) != 0) {  					//bit 7 = 0  					//command 0 (0cccpppp p): copy  					count = (code >> 4) + 3;  					copyp = writep - (((code & 0xf) << 8) + *readp++);  					while (count-- != 0)  						*writep++ = *copyp++;  				}  				else {  					//bit 7 = 1  					count = code & 0x3f;  					if ((~code & 0x40) != 0) {  						//bit 6 = 0  						if (count == 0)  							//end of image  							break;  						//command 1 (10cccccc): copy  						while (count-- != 0)  							*writep++ = *readp++;  					}  					else {  						//bit 6 = 1  						if (count < 0x3e) {  							//command 2 (11cccccc p p): copy  							count += 3;  							copyp = &pdest[*(ushort*) readp];    							readp += 2;  							while (count-- != 0)  								*writep++ = *copyp++;  						}  						else if (count == 0x3e) {  							//command 3 (11111110 c c v): fill  							count = *(ushort*) readp;  							readp += 2;  							code = *readp++;  							while (count-- != 0)  								*writep++ = code;  						}  						else {  							//command 4 (copy 11111111 c c p p): copy  							count = *(ushort*) readp;  							readp += 2;  							copyp = &pdest[*(ushort*) readp];  							readp += 2;  							while (count-- != 0)  								*writep++ = *copyp++;  						}  					}  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,Format80,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Format80.cs,DecodeInto,The following statement contains a magic number: while (true) {  				byte code = *readp++;  				byte* copyp;  				int count;  				if ((~code & 0x80) != 0) {  					//bit 7 = 0  					//command 0 (0cccpppp p): copy  					count = (code >> 4) + 3;  					copyp = writep - (((code & 0xf) << 8) + *readp++);  					while (count-- != 0)  						*writep++ = *copyp++;  				}  				else {  					//bit 7 = 1  					count = code & 0x3f;  					if ((~code & 0x40) != 0) {  						//bit 6 = 0  						if (count == 0)  							//end of image  							break;  						//command 1 (10cccccc): copy  						while (count-- != 0)  							*writep++ = *readp++;  					}  					else {  						//bit 6 = 1  						if (count < 0x3e) {  							//command 2 (11cccccc p p): copy  							count += 3;  							copyp = &pdest[*(ushort*) readp];    							readp += 2;  							while (count-- != 0)  								*writep++ = *copyp++;  						}  						else if (count == 0x3e) {  							//command 3 (11111110 c c v): fill  							count = *(ushort*) readp;  							readp += 2;  							code = *readp++;  							while (count-- != 0)  								*writep++ = code;  						}  						else {  							//command 4 (copy 11111111 c c p p): copy  							count = *(ushort*) readp;  							readp += 2;  							copyp = &pdest[*(ushort*) readp];  							readp += 2;  							while (count-- != 0)  								*writep++ = *copyp++;  						}  					}  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,Format80,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Format80.cs,DecodeInto,The following statement contains a magic number: while (true) {  				byte code = *readp++;  				byte* copyp;  				int count;  				if ((~code & 0x80) != 0) {  					//bit 7 = 0  					//command 0 (0cccpppp p): copy  					count = (code >> 4) + 3;  					copyp = writep - (((code & 0xf) << 8) + *readp++);  					while (count-- != 0)  						*writep++ = *copyp++;  				}  				else {  					//bit 7 = 1  					count = code & 0x3f;  					if ((~code & 0x40) != 0) {  						//bit 6 = 0  						if (count == 0)  							//end of image  							break;  						//command 1 (10cccccc): copy  						while (count-- != 0)  							*writep++ = *readp++;  					}  					else {  						//bit 6 = 1  						if (count < 0x3e) {  							//command 2 (11cccccc p p): copy  							count += 3;  							copyp = &pdest[*(ushort*) readp];    							readp += 2;  							while (count-- != 0)  								*writep++ = *copyp++;  						}  						else if (count == 0x3e) {  							//command 3 (11111110 c c v): fill  							count = *(ushort*) readp;  							readp += 2;  							code = *readp++;  							while (count-- != 0)  								*writep++ = code;  						}  						else {  							//command 4 (copy 11111111 c c p p): copy  							count = *(ushort*) readp;  							readp += 2;  							copyp = &pdest[*(ushort*) readp];  							readp += 2;  							while (count-- != 0)  								*writep++ = *copyp++;  						}  					}  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,Format80,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Format80.cs,DecodeInto,The following statement contains a magic number: while (true) {  				byte code = *readp++;  				byte* copyp;  				int count;  				if ((~code & 0x80) != 0) {  					//bit 7 = 0  					//command 0 (0cccpppp p): copy  					count = (code >> 4) + 3;  					copyp = writep - (((code & 0xf) << 8) + *readp++);  					while (count-- != 0)  						*writep++ = *copyp++;  				}  				else {  					//bit 7 = 1  					count = code & 0x3f;  					if ((~code & 0x40) != 0) {  						//bit 6 = 0  						if (count == 0)  							//end of image  							break;  						//command 1 (10cccccc): copy  						while (count-- != 0)  							*writep++ = *readp++;  					}  					else {  						//bit 6 = 1  						if (count < 0x3e) {  							//command 2 (11cccccc p p): copy  							count += 3;  							copyp = &pdest[*(ushort*) readp];    							readp += 2;  							while (count-- != 0)  								*writep++ = *copyp++;  						}  						else if (count == 0x3e) {  							//command 3 (11111110 c c v): fill  							count = *(ushort*) readp;  							readp += 2;  							code = *readp++;  							while (count-- != 0)  								*writep++ = code;  						}  						else {  							//command 4 (copy 11111111 c c p p): copy  							count = *(ushort*) readp;  							readp += 2;  							copyp = &pdest[*(ushort*) readp];  							readp += 2;  							while (count-- != 0)  								*writep++ = *copyp++;  						}  					}  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,Format80,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Format80.cs,DecodeInto,The following statement contains a magic number: while (true) {  				byte code = *readp++;  				byte* copyp;  				int count;  				if ((~code & 0x80) != 0) {  					//bit 7 = 0  					//command 0 (0cccpppp p): copy  					count = (code >> 4) + 3;  					copyp = writep - (((code & 0xf) << 8) + *readp++);  					while (count-- != 0)  						*writep++ = *copyp++;  				}  				else {  					//bit 7 = 1  					count = code & 0x3f;  					if ((~code & 0x40) != 0) {  						//bit 6 = 0  						if (count == 0)  							//end of image  							break;  						//command 1 (10cccccc): copy  						while (count-- != 0)  							*writep++ = *readp++;  					}  					else {  						//bit 6 = 1  						if (count < 0x3e) {  							//command 2 (11cccccc p p): copy  							count += 3;  							copyp = &pdest[*(ushort*) readp];    							readp += 2;  							while (count-- != 0)  								*writep++ = *copyp++;  						}  						else if (count == 0x3e) {  							//command 3 (11111110 c c v): fill  							count = *(ushort*) readp;  							readp += 2;  							code = *readp++;  							while (count-- != 0)  								*writep++ = code;  						}  						else {  							//command 4 (copy 11111111 c c p p): copy  							count = *(ushort*) readp;  							readp += 2;  							copyp = &pdest[*(ushort*) readp];  							readp += 2;  							while (count-- != 0)  								*writep++ = *copyp++;  						}  					}  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,Format80,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Format80.cs,DecodeInto,The following statement contains a magic number: while (true) {  				byte code = *readp++;  				byte* copyp;  				int count;  				if ((~code & 0x80) != 0) {  					//bit 7 = 0  					//command 0 (0cccpppp p): copy  					count = (code >> 4) + 3;  					copyp = writep - (((code & 0xf) << 8) + *readp++);  					while (count-- != 0)  						*writep++ = *copyp++;  				}  				else {  					//bit 7 = 1  					count = code & 0x3f;  					if ((~code & 0x40) != 0) {  						//bit 6 = 0  						if (count == 0)  							//end of image  							break;  						//command 1 (10cccccc): copy  						while (count-- != 0)  							*writep++ = *readp++;  					}  					else {  						//bit 6 = 1  						if (count < 0x3e) {  							//command 2 (11cccccc p p): copy  							count += 3;  							copyp = &pdest[*(ushort*) readp];    							readp += 2;  							while (count-- != 0)  								*writep++ = *copyp++;  						}  						else if (count == 0x3e) {  							//command 3 (11111110 c c v): fill  							count = *(ushort*) readp;  							readp += 2;  							code = *readp++;  							while (count-- != 0)  								*writep++ = code;  						}  						else {  							//command 4 (copy 11111111 c c p p): copy  							count = *(ushort*) readp;  							readp += 2;  							copyp = &pdest[*(ushort*) readp];  							readp += 2;  							while (count-- != 0)  								*writep++ = *copyp++;  						}  					}  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,Format80,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Format80.cs,DecodeInto,The following statement contains a magic number: while (true) {  				byte code = *readp++;  				byte* copyp;  				int count;  				if ((~code & 0x80) != 0) {  					//bit 7 = 0  					//command 0 (0cccpppp p): copy  					count = (code >> 4) + 3;  					copyp = writep - (((code & 0xf) << 8) + *readp++);  					while (count-- != 0)  						*writep++ = *copyp++;  				}  				else {  					//bit 7 = 1  					count = code & 0x3f;  					if ((~code & 0x40) != 0) {  						//bit 6 = 0  						if (count == 0)  							//end of image  							break;  						//command 1 (10cccccc): copy  						while (count-- != 0)  							*writep++ = *readp++;  					}  					else {  						//bit 6 = 1  						if (count < 0x3e) {  							//command 2 (11cccccc p p): copy  							count += 3;  							copyp = &pdest[*(ushort*) readp];    							readp += 2;  							while (count-- != 0)  								*writep++ = *copyp++;  						}  						else if (count == 0x3e) {  							//command 3 (11111110 c c v): fill  							count = *(ushort*) readp;  							readp += 2;  							code = *readp++;  							while (count-- != 0)  								*writep++ = code;  						}  						else {  							//command 4 (copy 11111111 c c p p): copy  							count = *(ushort*) readp;  							readp += 2;  							copyp = &pdest[*(ushort*) readp];  							readp += 2;  							while (count-- != 0)  								*writep++ = *copyp++;  						}  					}  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,Format80,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\Format80.cs,DecodeInto,The following statement contains a magic number: while (true) {  				byte code = *readp++;  				byte* copyp;  				int count;  				if ((~code & 0x80) != 0) {  					//bit 7 = 0  					//command 0 (0cccpppp p): copy  					count = (code >> 4) + 3;  					copyp = writep - (((code & 0xf) << 8) + *readp++);  					while (count-- != 0)  						*writep++ = *copyp++;  				}  				else {  					//bit 7 = 1  					count = code & 0x3f;  					if ((~code & 0x40) != 0) {  						//bit 6 = 0  						if (count == 0)  							//end of image  							break;  						//command 1 (10cccccc): copy  						while (count-- != 0)  							*writep++ = *readp++;  					}  					else {  						//bit 6 = 1  						if (count < 0x3e) {  							//command 2 (11cccccc p p): copy  							count += 3;  							copyp = &pdest[*(ushort*) readp];    							readp += 2;  							while (count-- != 0)  								*writep++ = *copyp++;  						}  						else if (count == 0x3e) {  							//command 3 (11111110 c c v): fill  							count = *(ushort*) readp;  							readp += 2;  							code = *readp++;  							while (count-- != 0)  								*writep++ = code;  						}  						else {  							//command 4 (copy 11111111 c c p p): copy  							count = *(ushort*) readp;  							readp += 2;  							copyp = &pdest[*(ushort*) readp];  							readp += 2;  							while (count-- != 0)  								*writep++ = *copyp++;  						}  					}  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: byte* ip_end = @in + in_len - 20;
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: ip += ti < 4 ? 4 - ti : 0;
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: ip += ti < 4 ? 4 - ti : 0;
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress_core,The following statement contains a magic number: for (; ; ) {    				uint dv;  				uint dindex;  			literal:  				ip += 1 + ((ip - ii) >> 5);  			next:  				if (ip >= ip_end)  					break;  				dv = (*(uint*)(void*)(ip));  				dindex = ((uint)(((((((uint)((0x1824429d) * (dv)))) >> (32 - 14))) & (((1u << (14)) - 1) >> (0))) << (0)));  				m_pos = @in + dict[dindex];  				dict[dindex] = ((ushort)((uint)((ip) - (@in))));  				if (dv != (*(uint*)(void*)(m_pos)))  					goto literal;    				ii -= ti; ti = 0;  				{  					uint t = ((uint)((ip) - (ii)));  					if (t != 0) {  						if (t <= 3) {  							op[-2] |= ((byte)(t));  							*(uint*)(op) = *(uint*)(ii);  							op += t;  						}  						else if (t <= 16) {  							*op++ = ((byte)(t - 3));  							*(uint*)(op) = *(uint*)(ii);  							*(uint*)(op + 4) = *(uint*)(ii + 4);  							*(uint*)(op + 8) = *(uint*)(ii + 8);  							*(uint*)(op + 12) = *(uint*)(ii + 12);  							op += t;  						}  						else {  							if (t <= 18)  								*op++ = ((byte)(t - 3));  							else {  								uint tt = t - 18;  								*op++ = 0;  								while (tt > 255) {  									tt -= 255;  									*(byte*)op++ = 0;  								}    								*op++ = ((byte)(tt));  							}  							do {  								*(uint*)(op) = *(uint*)(ii);  								*(uint*)(op + 4) = *(uint*)(ii + 4);  								*(uint*)(op + 8) = *(uint*)(ii + 8);  								*(uint*)(op + 12) = *(uint*)(ii + 12);  								op += 16; ii += 16; t -= 16;  							} while (t >= 16); if (t > 0) { do *op++ = *ii++; while (--t > 0); }  						}  					}  				}  				m_len = 4;  				{  					uint v;  					v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  					if (v == 0) {  						do {  							m_len += 4;  							v = (*(uint*)(void*)(ip + m_len)) ^ (*(uint*)(void*)(m_pos + m_len));  							if (ip + m_len >= ip_end)  								goto m_len_done;  						} while (v == 0);  					}  					m_len += (uint)lzo_bitops_ctz32(v) / 8;  				}  			m_len_done:  				m_off = ((uint)((ip) - (m_pos)));  				ip += m_len;  				ii = ip;  				if (m_len <= 8 && m_off <= 0x0800) {  					m_off -= 1;  					*op++ = ((byte)(((m_len - 1) << 5) | ((m_off & 7) << 2)));  					*op++ = ((byte)(m_off >> 3));  				}  				else if (m_off <= 0x4000) {  					m_off -= 1;  					if (m_len <= 33)  						*op++ = ((byte)(32 | (m_len - 2)));  					else {  						m_len -= 33;  						*op++ = 32 | 0;  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				else {  					m_off -= 0x4000;  					if (m_len <= 9)  						*op++ = ((byte)(16 | ((m_off >> 11) & 8) | (m_len - 2)));  					else {  						m_len -= 9;  						*op++ = ((byte)(16 | ((m_off >> 11) & 8)));  						while (m_len > 255) {  							m_len -= 255;  							*(byte*)op++ = 0;  						}  						*op++ = ((byte)(m_len));  					}  					*op++ = ((byte)(m_off << 2));  					*op++ = ((byte)(m_off >> 6));  				}  				goto next;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo_bitops_ctz32,The following statement contains a magic number: return MultiplyDeBruijnBitPosition[((uint)((v & -v) * 0x077CB531U)) >> 27];
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress,The following statement contains a magic number: while (l > 20) {  				uint ll = l;  				ulong ll_end;  				ll = ((ll) <= (49152) ? (ll) : (49152));  				ll_end = (ulong)ip + ll;  				if ((ll_end + ((t + ll) >> 5)) <= ll_end || (byte*)(ll_end + ((t + ll) >> 5)) <= ip + ll)  					break;    				for (int i = 0; i < (1 << 14) * sizeof(ushort); i++)  					wrkmem[i] = 0;  				t = lzo1x_1_compress_core(ip' ll' op' ref out_len' t' wrkmem);  				ip += ll;  				op += out_len;  				l -= ll;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress,The following statement contains a magic number: while (l > 20) {  				uint ll = l;  				ulong ll_end;  				ll = ((ll) <= (49152) ? (ll) : (49152));  				ll_end = (ulong)ip + ll;  				if ((ll_end + ((t + ll) >> 5)) <= ll_end || (byte*)(ll_end + ((t + ll) >> 5)) <= ip + ll)  					break;    				for (int i = 0; i < (1 << 14) * sizeof(ushort); i++)  					wrkmem[i] = 0;  				t = lzo1x_1_compress_core(ip' ll' op' ref out_len' t' wrkmem);  				ip += ll;  				op += out_len;  				l -= ll;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress,The following statement contains a magic number: while (l > 20) {  				uint ll = l;  				ulong ll_end;  				ll = ((ll) <= (49152) ? (ll) : (49152));  				ll_end = (ulong)ip + ll;  				if ((ll_end + ((t + ll) >> 5)) <= ll_end || (byte*)(ll_end + ((t + ll) >> 5)) <= ip + ll)  					break;    				for (int i = 0; i < (1 << 14) * sizeof(ushort); i++)  					wrkmem[i] = 0;  				t = lzo1x_1_compress_core(ip' ll' op' ref out_len' t' wrkmem);  				ip += ll;  				op += out_len;  				l -= ll;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress,The following statement contains a magic number: while (l > 20) {  				uint ll = l;  				ulong ll_end;  				ll = ((ll) <= (49152) ? (ll) : (49152));  				ll_end = (ulong)ip + ll;  				if ((ll_end + ((t + ll) >> 5)) <= ll_end || (byte*)(ll_end + ((t + ll) >> 5)) <= ip + ll)  					break;    				for (int i = 0; i < (1 << 14) * sizeof(ushort); i++)  					wrkmem[i] = 0;  				t = lzo1x_1_compress_core(ip' ll' op' ref out_len' t' wrkmem);  				ip += ll;  				op += out_len;  				l -= ll;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress,The following statement contains a magic number: while (l > 20) {  				uint ll = l;  				ulong ll_end;  				ll = ((ll) <= (49152) ? (ll) : (49152));  				ll_end = (ulong)ip + ll;  				if ((ll_end + ((t + ll) >> 5)) <= ll_end || (byte*)(ll_end + ((t + ll) >> 5)) <= ip + ll)  					break;    				for (int i = 0; i < (1 << 14) * sizeof(ushort); i++)  					wrkmem[i] = 0;  				t = lzo1x_1_compress_core(ip' ll' op' ref out_len' t' wrkmem);  				ip += ll;  				op += out_len;  				l -= ll;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress,The following statement contains a magic number: while (l > 20) {  				uint ll = l;  				ulong ll_end;  				ll = ((ll) <= (49152) ? (ll) : (49152));  				ll_end = (ulong)ip + ll;  				if ((ll_end + ((t + ll) >> 5)) <= ll_end || (byte*)(ll_end + ((t + ll) >> 5)) <= ip + ll)  					break;    				for (int i = 0; i < (1 << 14) * sizeof(ushort); i++)  					wrkmem[i] = 0;  				t = lzo1x_1_compress_core(ip' ll' op' ref out_len' t' wrkmem);  				ip += ll;  				op += out_len;  				l -= ll;  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress,The following statement contains a magic number: if (t > 0) {  				byte* ii = @in + in_len - t;  				if (op == @out && t <= 238)  					*op++ = ((byte)(17 + t));  				else if (t <= 3)  					op[-2] |= ((byte)(t));  				else if (t <= 18)  					*op++ = ((byte)(t - 3));  				else {  					uint tt = t - 18;  					*op++ = 0;  					while (tt > 255) {  						tt -= 255;  						*(byte*)op++ = 0;  					}    					*op++ = ((byte)(tt));  				}  				do *op++ = *ii++; while (--t > 0);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress,The following statement contains a magic number: if (t > 0) {  				byte* ii = @in + in_len - t;  				if (op == @out && t <= 238)  					*op++ = ((byte)(17 + t));  				else if (t <= 3)  					op[-2] |= ((byte)(t));  				else if (t <= 18)  					*op++ = ((byte)(t - 3));  				else {  					uint tt = t - 18;  					*op++ = 0;  					while (tt > 255) {  						tt -= 255;  						*(byte*)op++ = 0;  					}    					*op++ = ((byte)(tt));  				}  				do *op++ = *ii++; while (--t > 0);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress,The following statement contains a magic number: if (t > 0) {  				byte* ii = @in + in_len - t;  				if (op == @out && t <= 238)  					*op++ = ((byte)(17 + t));  				else if (t <= 3)  					op[-2] |= ((byte)(t));  				else if (t <= 18)  					*op++ = ((byte)(t - 3));  				else {  					uint tt = t - 18;  					*op++ = 0;  					while (tt > 255) {  						tt -= 255;  						*(byte*)op++ = 0;  					}    					*op++ = ((byte)(tt));  				}  				do *op++ = *ii++; while (--t > 0);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress,The following statement contains a magic number: if (t > 0) {  				byte* ii = @in + in_len - t;  				if (op == @out && t <= 238)  					*op++ = ((byte)(17 + t));  				else if (t <= 3)  					op[-2] |= ((byte)(t));  				else if (t <= 18)  					*op++ = ((byte)(t - 3));  				else {  					uint tt = t - 18;  					*op++ = 0;  					while (tt > 255) {  						tt -= 255;  						*(byte*)op++ = 0;  					}    					*op++ = ((byte)(tt));  				}  				do *op++ = *ii++; while (--t > 0);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress,The following statement contains a magic number: if (t > 0) {  				byte* ii = @in + in_len - t;  				if (op == @out && t <= 238)  					*op++ = ((byte)(17 + t));  				else if (t <= 3)  					op[-2] |= ((byte)(t));  				else if (t <= 18)  					*op++ = ((byte)(t - 3));  				else {  					uint tt = t - 18;  					*op++ = 0;  					while (tt > 255) {  						tt -= 255;  						*(byte*)op++ = 0;  					}    					*op++ = ((byte)(tt));  				}  				do *op++ = *ii++; while (--t > 0);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress,The following statement contains a magic number: if (t > 0) {  				byte* ii = @in + in_len - t;  				if (op == @out && t <= 238)  					*op++ = ((byte)(17 + t));  				else if (t <= 3)  					op[-2] |= ((byte)(t));  				else if (t <= 18)  					*op++ = ((byte)(t - 3));  				else {  					uint tt = t - 18;  					*op++ = 0;  					while (tt > 255) {  						tt -= 255;  						*(byte*)op++ = 0;  					}    					*op++ = ((byte)(tt));  				}  				do *op++ = *ii++; while (--t > 0);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress,The following statement contains a magic number: if (t > 0) {  				byte* ii = @in + in_len - t;  				if (op == @out && t <= 238)  					*op++ = ((byte)(17 + t));  				else if (t <= 3)  					op[-2] |= ((byte)(t));  				else if (t <= 18)  					*op++ = ((byte)(t - 3));  				else {  					uint tt = t - 18;  					*op++ = 0;  					while (tt > 255) {  						tt -= 255;  						*(byte*)op++ = 0;  					}    					*op++ = ((byte)(tt));  				}  				do *op++ = *ii++; while (--t > 0);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress,The following statement contains a magic number: if (t > 0) {  				byte* ii = @in + in_len - t;  				if (op == @out && t <= 238)  					*op++ = ((byte)(17 + t));  				else if (t <= 3)  					op[-2] |= ((byte)(t));  				else if (t <= 18)  					*op++ = ((byte)(t - 3));  				else {  					uint tt = t - 18;  					*op++ = 0;  					while (tt > 255) {  						tt -= 255;  						*(byte*)op++ = 0;  					}    					*op++ = ((byte)(tt));  				}  				do *op++ = *ii++; while (--t > 0);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress,The following statement contains a magic number: if (t > 0) {  				byte* ii = @in + in_len - t;  				if (op == @out && t <= 238)  					*op++ = ((byte)(17 + t));  				else if (t <= 3)  					op[-2] |= ((byte)(t));  				else if (t <= 18)  					*op++ = ((byte)(t - 3));  				else {  					uint tt = t - 18;  					*op++ = 0;  					while (tt > 255) {  						tt -= 255;  						*(byte*)op++ = 0;  					}    					*op++ = ((byte)(tt));  				}  				do *op++ = *ii++; while (--t > 0);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_1_compress,The following statement contains a magic number: *op++ = 16 | 1;
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: if (*ip > 17) {  				t = (uint)(*ip++ - 17);  				if (t < 4) {  					match_next(ref op' ref ip' ref t);  				}  				else {  					do *op++ = *ip++; while (--t > 0);  					gt_first_literal_run = true;  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: if (*ip > 17) {  				t = (uint)(*ip++ - 17);  				if (t < 4) {  					match_next(ref op' ref ip' ref t);  				}  				else {  					do *op++ = *ip++; while (--t > 0);  					gt_first_literal_run = true;  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: if (*ip > 17) {  				t = (uint)(*ip++ - 17);  				if (t < 4) {  					match_next(ref op' ref ip' ref t);  				}  				else {  					do *op++ = *ip++; while (--t > 0);  					gt_first_literal_run = true;  				}  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: while (true) {  				if (gt_first_literal_run) {  					gt_first_literal_run = false;  					goto first_literal_run;  				}    				t = *ip++;  				if (t >= 16)  					goto match;  				if (t == 0) {  					while (*ip == 0) {  						t += 255;  						ip++;  					}  					t += (uint)(15 + *ip++);  				}  				*(uint*)op = *(uint*)ip;  				op += 4; ip += 4;  				if (--t > 0) {  					if (t >= 4) {  						do {  							*(uint*)op = *(uint*)ip;  							op += 4; ip += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *ip++; while (--t > 0);  					}  					else  						do *op++ = *ip++; while (--t > 0);  				}  			first_literal_run:  				t = *ip++;  				if (t >= 16)  					goto match;  				m_pos = op - (1 + 0x0800);  				m_pos -= t >> 2;  				m_pos -= *ip++ << 2;    				*op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;  				gt_match_done = true;    			match:  				do {  					if (gt_match_done) {  						gt_match_done = false;  						goto match_done;  						;  					}  					if (t >= 64) {  						m_pos = op - 1;  						m_pos -= (t >> 2) & 7;  						m_pos -= *ip++ << 3;  						t = (t >> 5) - 1;    						copy_match(ref op' ref m_pos' ref t);  						goto match_done;  					}  					else if (t >= 32) {  						t &= 31;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(31 + *ip++);  						}  						m_pos = op - 1;  						m_pos -= (*(ushort*)(void*)(ip)) >> 2;  						ip += 2;  					}  					else if (t >= 16) {  						m_pos = op;  						m_pos -= (t & 8) << 11;  						t &= 7;  						if (t == 0) {  							while (*ip == 0) {  								t += 255;  								ip++;  							}  							t += (uint)(7 + *ip++);  						}  						m_pos -= (*(ushort*)ip) >> 2;  						ip += 2;  						if (m_pos == op)  							goto eof_found;  						m_pos -= 0x4000;  					}  					else {  						m_pos = op - 1;  						m_pos -= t >> 2;  						m_pos -= *ip++ << 2;  						*op++ = *m_pos++; *op++ = *m_pos;  						goto match_done;  					}    					if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {  						*(uint*)op = *(uint*)m_pos;  						op += 4; m_pos += 4; t -= 4 - (3 - 1);  						do {  							*(uint*)op = *(uint*)m_pos;  							op += 4; m_pos += 4; t -= 4;  						} while (t >= 4);  						if (t > 0) do *op++ = *m_pos++; while (--t > 0);  					}  					else {  					// copy_match:  						*op++ = *m_pos++; *op++ = *m_pos++;  						do *op++ = *m_pos++; while (--t > 0);  					}  				match_done:  					t = (uint)(ip[-2] & 3);  					if (t == 0)  						break;  				// match_next:  					*op++ = *ip++;  					if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }  					t = *ip++;  				} while (true);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: return (ip == ip_end ? 0 :  				   (ip < ip_end ? (-8) : (-4)));
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,lzo1x_decompress,The following statement contains a magic number: return (ip == ip_end ? 0 :  				   (ip < ip_end ? (-8) : (-4)));
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* @pIn = @in' wrkmem = new byte[IntPtr.Size * 16384]' pOut = @out) {  				lzo1x_decompress(pIn' (uint)@in.Length' @pOut' ref @out_len' wrkmem);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,Decompress,The following statement contains a magic number: fixed (byte* wrkmem = new byte[IntPtr.Size * 16384]) {  				lzo1x_decompress(r' size_in' w' ref size_out' wrkmem);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,Compress,The following statement contains a magic number: byte[] @out = new byte[input.Length + (input.Length / 16) + 64 + 3];
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,Compress,The following statement contains a magic number: byte[] @out = new byte[input.Length + (input.Length / 16) + 64 + 3];
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,Compress,The following statement contains a magic number: byte[] @out = new byte[input.Length + (input.Length / 16) + 64 + 3];
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,Compress,The following statement contains a magic number: fixed (byte* @pIn = input' wrkmem = new byte[IntPtr.Size * 16384]' pOut = @out) {  				lzo1x_1_compress(pIn' (uint)input.Length' @pOut' ref @out_len' wrkmem);  			}
Magic Number,CNCMaps.FileFormats.Encodings,MiniLZO,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Encodings\MiniLZO.cs,Compress,The following statement contains a magic number: fixed (byte* wrkmem = new byte[IntPtr.Size * 16384]) {  				lzo1x_1_compress(r' size_in' w' ref size_out' wrkmem);  			}
Magic Number,CNCMaps.FileFormats.Map,Lighting,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\Lighting.cs,Lighting,The following statement contains a magic number: Level = iniSection.ReadDouble("Level"' 0.032);
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,Initialize,The following statement contains a magic number: FullSize = new Rectangle(int.Parse(size[0])' int.Parse(size[1])' int.Parse(size[2])' int.Parse(size[3]));
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,Initialize,The following statement contains a magic number: FullSize = new Rectangle(int.Parse(size[0])' int.Parse(size[1])' int.Parse(size[2])' int.Parse(size[3]));
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,Initialize,The following statement contains a magic number: LocalSize = new Rectangle(int.Parse(size[0])' int.Parse(size[1])' int.Parse(size[2])' int.Parse(size[3]));
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,Initialize,The following statement contains a magic number: LocalSize = new Rectangle(int.Parse(size[0])' int.Parse(size[1])' int.Parse(size[2])' int.Parse(size[3]));
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadTiles,The following statement contains a magic number: int cells = (FullSize.Width * 2 - 1) * FullSize.Height;
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadTiles,The following statement contains a magic number: int lzoPackSize = cells * 11 + 4;
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadTiles,The following statement contains a magic number: int lzoPackSize = cells * 11 + 4;
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadTiles,The following statement contains a magic number: for (int i = 0; i < cells; i++) {  				ushort rx = mf.ReadUInt16();  				ushort ry = mf.ReadUInt16();  				short tilenum = mf.ReadInt16();  				short zero1 = mf.ReadInt16();  				byte subtile = mf.ReadByte();  				byte z = mf.ReadByte();  				byte zero2 = mf.ReadByte();    				int dx = rx - ry + FullSize.Width - 1;  				int dy = rx + ry - FullSize.Width - 1;  				numtiles++;  				if (dx >= 0 && dx < 2 * Tiles.Width &&  					dy >= 0 && dy < 2 * Tiles.Height) {  					var tile = new IsoTile((ushort)dx' (ushort)dy' rx' ry' z' tilenum' subtile);  					Tiles[(ushort)dx' (ushort)dy / 2] = tile;  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadTiles,The following statement contains a magic number: for (int i = 0; i < cells; i++) {  				ushort rx = mf.ReadUInt16();  				ushort ry = mf.ReadUInt16();  				short tilenum = mf.ReadInt16();  				short zero1 = mf.ReadInt16();  				byte subtile = mf.ReadByte();  				byte z = mf.ReadByte();  				byte zero2 = mf.ReadByte();    				int dx = rx - ry + FullSize.Width - 1;  				int dy = rx + ry - FullSize.Width - 1;  				numtiles++;  				if (dx >= 0 && dx < 2 * Tiles.Width &&  					dy >= 0 && dy < 2 * Tiles.Height) {  					var tile = new IsoTile((ushort)dx' (ushort)dy' rx' ry' z' tilenum' subtile);  					Tiles[(ushort)dx' (ushort)dy / 2] = tile;  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadTiles,The following statement contains a magic number: for (int i = 0; i < cells; i++) {  				ushort rx = mf.ReadUInt16();  				ushort ry = mf.ReadUInt16();  				short tilenum = mf.ReadInt16();  				short zero1 = mf.ReadInt16();  				byte subtile = mf.ReadByte();  				byte z = mf.ReadByte();  				byte zero2 = mf.ReadByte();    				int dx = rx - ry + FullSize.Width - 1;  				int dy = rx + ry - FullSize.Width - 1;  				numtiles++;  				if (dx >= 0 && dx < 2 * Tiles.Width &&  					dy >= 0 && dy < 2 * Tiles.Height) {  					var tile = new IsoTile((ushort)dx' (ushort)dy' rx' ry' z' tilenum' subtile);  					Tiles[(ushort)dx' (ushort)dy / 2] = tile;  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadTiles,The following statement contains a magic number: for (ushort y = 0; y < FullSize.Height; y++) {  				for (ushort x = 0; x <= FullSize.Width * 2 - 2; x++) {  					var isoTile = Tiles[x' y];  					if (isoTile == null) {  						// fix null tiles to blank  						ushort dx = (ushort)(x);  						ushort dy = (ushort)(y * 2 + x % 2);  						ushort rx = (ushort)((dx + dy) / 2 + 1);  						ushort ry = (ushort)(dy - rx + FullSize.Width + 1);  						Tiles[x' y] = new IsoTile(dx' dy' rx' ry' 0' 0' 0);  					}  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadTiles,The following statement contains a magic number: for (ushort y = 0; y < FullSize.Height; y++) {  				for (ushort x = 0; x <= FullSize.Width * 2 - 2; x++) {  					var isoTile = Tiles[x' y];  					if (isoTile == null) {  						// fix null tiles to blank  						ushort dx = (ushort)(x);  						ushort dy = (ushort)(y * 2 + x % 2);  						ushort rx = (ushort)((dx + dy) / 2 + 1);  						ushort ry = (ushort)(dy - rx + FullSize.Width + 1);  						Tiles[x' y] = new IsoTile(dx' dy' rx' ry' 0' 0' 0);  					}  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadTiles,The following statement contains a magic number: for (ushort y = 0; y < FullSize.Height; y++) {  				for (ushort x = 0; x <= FullSize.Width * 2 - 2; x++) {  					var isoTile = Tiles[x' y];  					if (isoTile == null) {  						// fix null tiles to blank  						ushort dx = (ushort)(x);  						ushort dy = (ushort)(y * 2 + x % 2);  						ushort rx = (ushort)((dx + dy) / 2 + 1);  						ushort ry = (ushort)(dy - rx + FullSize.Width + 1);  						Tiles[x' y] = new IsoTile(dx' dy' rx' ry' 0' 0' 0);  					}  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadTiles,The following statement contains a magic number: for (ushort y = 0; y < FullSize.Height; y++) {  				for (ushort x = 0; x <= FullSize.Width * 2 - 2; x++) {  					var isoTile = Tiles[x' y];  					if (isoTile == null) {  						// fix null tiles to blank  						ushort dx = (ushort)(x);  						ushort dy = (ushort)(y * 2 + x % 2);  						ushort rx = (ushort)((dx + dy) / 2 + 1);  						ushort ry = (ushort)(dy - rx + FullSize.Width + 1);  						Tiles[x' y] = new IsoTile(dx' dy' rx' ry' 0' 0' 0);  					}  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadTiles,The following statement contains a magic number: for (ushort y = 0; y < FullSize.Height; y++) {  				for (ushort x = 0; x <= FullSize.Width * 2 - 2; x++) {  					var isoTile = Tiles[x' y];  					if (isoTile == null) {  						// fix null tiles to blank  						ushort dx = (ushort)(x);  						ushort dy = (ushort)(y * 2 + x % 2);  						ushort rx = (ushort)((dx + dy) / 2 + 1);  						ushort ry = (ushort)(dy - rx + FullSize.Width + 1);  						Tiles[x' y] = new IsoTile(dx' dy' rx' ry' 0' 0' 0);  					}  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadTerrain,The following statement contains a magic number: foreach (var v in terrainSection.OrderedEntries) {  				int pos;  				if (int.TryParse(v.Key' out pos)) {  					string name = v.Value;  					int rx = pos % 1000;  					int ry = pos / 1000;  					var t = new Terrain(name);  					t.Tile = Tiles.GetTileR(rx' ry);  					if (t.Tile != null)  						Terrains.Add(t);  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadTerrain,The following statement contains a magic number: foreach (var v in terrainSection.OrderedEntries) {  				int pos;  				if (int.TryParse(v.Key' out pos)) {  					string name = v.Value;  					int rx = pos % 1000;  					int ry = pos / 1000;  					var t = new Terrain(name);  					t.Tile = Tiles.GetTileR(rx' ry);  					if (t.Tile != null)  						Terrains.Add(t);  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadSmudges,The following statement contains a magic number: foreach (var v in smudgesSection.OrderedEntries) {  				try {  					string[] entries = ((string)v.Value).Split(''');  					if (entries.Length <= 2) continue;  					string name = entries[0];  					int rx = int.Parse(entries[1]);  					int ry = int.Parse(entries[2]);  					var s = new Smudge(name);  					s.Tile = Tiles.GetTileR(rx' ry);  					if (s.Tile != null)   						Smudges.Add(s);  				}  				catch (FormatException) {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadSmudges,The following statement contains a magic number: foreach (var v in smudgesSection.OrderedEntries) {  				try {  					string[] entries = ((string)v.Value).Split(''');  					if (entries.Length <= 2) continue;  					string name = entries[0];  					int rx = int.Parse(entries[1]);  					int ry = int.Parse(entries[2]);  					var s = new Smudge(name);  					s.Tile = Tiles.GetTileR(rx' ry);  					if (s.Tile != null)   						Smudges.Add(s);  				}  				catch (FormatException) {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadOverlay,The following statement contains a magic number: var overlayPack = new byte[1 << 18];
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadOverlay,The following statement contains a magic number: Format5.DecodeInto(format80Data' overlayPack' 80);
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadOverlay,The following statement contains a magic number: var overlayDataPack = new byte[1 << 18];
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadOverlay,The following statement contains a magic number: Format5.DecodeInto(format80Data' overlayDataPack' 80);
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadOverlay,The following statement contains a magic number: for (int y = 0; y < FullSize.Height; y++) {  				for (int x = FullSize.Width * 2 - 2; x >= 0; x--) {  					var t = Tiles[x' y];  					if (t == null) continue;  					int idx = t.Rx + 512 * t.Ry;  					byte overlay_id = overlayPack[idx];  					if (overlay_id != 0xFF) {  						byte overlay_value = overlayDataPack[idx];  						var ovl = new Overlay(overlay_id' overlay_value);  						ovl.Tile = t;  						Overlays.Add(ovl);  					}  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadOverlay,The following statement contains a magic number: for (int y = 0; y < FullSize.Height; y++) {  				for (int x = FullSize.Width * 2 - 2; x >= 0; x--) {  					var t = Tiles[x' y];  					if (t == null) continue;  					int idx = t.Rx + 512 * t.Ry;  					byte overlay_id = overlayPack[idx];  					if (overlay_id != 0xFF) {  						byte overlay_value = overlayDataPack[idx];  						var ovl = new Overlay(overlay_id' overlay_value);  						ovl.Tile = t;  						Overlays.Add(ovl);  					}  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadOverlay,The following statement contains a magic number: for (int y = 0; y < FullSize.Height; y++) {  				for (int x = FullSize.Width * 2 - 2; x >= 0; x--) {  					var t = Tiles[x' y];  					if (t == null) continue;  					int idx = t.Rx + 512 * t.Ry;  					byte overlay_id = overlayPack[idx];  					if (overlay_id != 0xFF) {  						byte overlay_value = overlayDataPack[idx];  						var ovl = new Overlay(overlay_id' overlay_value);  						ovl.Tile = t;  						Overlays.Add(ovl);  					}  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadInfantry,The following statement contains a magic number: foreach (var v in infantrySection.OrderedEntries) {  				try {    					string[] entries = ((string)v.Value).Split(''');  					if (entries.Length <= 8) continue;  					string owner = entries[0];  					string name = entries[1];  					short health = short.Parse(entries[2]);  					int rx = int.Parse(entries[3]);  					int ry = int.Parse(entries[4]);  					short direction = short.Parse(entries[7]);  					bool onBridge = entries[11] == "1";  					var i = new Infantry(owner' name' health' direction' onBridge);  					i.Tile = Tiles.GetTileR(rx' ry);  					if (i.Tile != null)  						Infantries.Add(i);  				}  				catch (IndexOutOfRangeException) {  				}  				catch (FormatException) {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadInfantry,The following statement contains a magic number: foreach (var v in infantrySection.OrderedEntries) {  				try {    					string[] entries = ((string)v.Value).Split(''');  					if (entries.Length <= 8) continue;  					string owner = entries[0];  					string name = entries[1];  					short health = short.Parse(entries[2]);  					int rx = int.Parse(entries[3]);  					int ry = int.Parse(entries[4]);  					short direction = short.Parse(entries[7]);  					bool onBridge = entries[11] == "1";  					var i = new Infantry(owner' name' health' direction' onBridge);  					i.Tile = Tiles.GetTileR(rx' ry);  					if (i.Tile != null)  						Infantries.Add(i);  				}  				catch (IndexOutOfRangeException) {  				}  				catch (FormatException) {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadInfantry,The following statement contains a magic number: foreach (var v in infantrySection.OrderedEntries) {  				try {    					string[] entries = ((string)v.Value).Split(''');  					if (entries.Length <= 8) continue;  					string owner = entries[0];  					string name = entries[1];  					short health = short.Parse(entries[2]);  					int rx = int.Parse(entries[3]);  					int ry = int.Parse(entries[4]);  					short direction = short.Parse(entries[7]);  					bool onBridge = entries[11] == "1";  					var i = new Infantry(owner' name' health' direction' onBridge);  					i.Tile = Tiles.GetTileR(rx' ry);  					if (i.Tile != null)  						Infantries.Add(i);  				}  				catch (IndexOutOfRangeException) {  				}  				catch (FormatException) {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadInfantry,The following statement contains a magic number: foreach (var v in infantrySection.OrderedEntries) {  				try {    					string[] entries = ((string)v.Value).Split(''');  					if (entries.Length <= 8) continue;  					string owner = entries[0];  					string name = entries[1];  					short health = short.Parse(entries[2]);  					int rx = int.Parse(entries[3]);  					int ry = int.Parse(entries[4]);  					short direction = short.Parse(entries[7]);  					bool onBridge = entries[11] == "1";  					var i = new Infantry(owner' name' health' direction' onBridge);  					i.Tile = Tiles.GetTileR(rx' ry);  					if (i.Tile != null)  						Infantries.Add(i);  				}  				catch (IndexOutOfRangeException) {  				}  				catch (FormatException) {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadInfantry,The following statement contains a magic number: foreach (var v in infantrySection.OrderedEntries) {  				try {    					string[] entries = ((string)v.Value).Split(''');  					if (entries.Length <= 8) continue;  					string owner = entries[0];  					string name = entries[1];  					short health = short.Parse(entries[2]);  					int rx = int.Parse(entries[3]);  					int ry = int.Parse(entries[4]);  					short direction = short.Parse(entries[7]);  					bool onBridge = entries[11] == "1";  					var i = new Infantry(owner' name' health' direction' onBridge);  					i.Tile = Tiles.GetTileR(rx' ry);  					if (i.Tile != null)  						Infantries.Add(i);  				}  				catch (IndexOutOfRangeException) {  				}  				catch (FormatException) {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadInfantry,The following statement contains a magic number: foreach (var v in infantrySection.OrderedEntries) {  				try {    					string[] entries = ((string)v.Value).Split(''');  					if (entries.Length <= 8) continue;  					string owner = entries[0];  					string name = entries[1];  					short health = short.Parse(entries[2]);  					int rx = int.Parse(entries[3]);  					int ry = int.Parse(entries[4]);  					short direction = short.Parse(entries[7]);  					bool onBridge = entries[11] == "1";  					var i = new Infantry(owner' name' health' direction' onBridge);  					i.Tile = Tiles.GetTileR(rx' ry);  					if (i.Tile != null)  						Infantries.Add(i);  				}  				catch (IndexOutOfRangeException) {  				}  				catch (FormatException) {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadUnits,The following statement contains a magic number: foreach (var v in unitsSection.OrderedEntries) {  				try {  					string[] entries = ((string)v.Value).Split(''');  					if (entries.Length <= 11) continue;    					string owner = entries[0];  					string name = entries[1];  					short health = short.Parse(entries[2]);  					int rx = int.Parse(entries[3]);  					int ry = int.Parse(entries[4]);  					short direction = short.Parse(entries[5]);  					bool onBridge = entries[10] == "1";  					var u = new Unit(owner' name' health' direction' onBridge);  						u.Tile = Tiles.GetTileR(rx' ry);  					if (u.Tile != null)  						Units.Add(u);  				}  				catch (FormatException) {  				}  				catch (IndexOutOfRangeException) {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadUnits,The following statement contains a magic number: foreach (var v in unitsSection.OrderedEntries) {  				try {  					string[] entries = ((string)v.Value).Split(''');  					if (entries.Length <= 11) continue;    					string owner = entries[0];  					string name = entries[1];  					short health = short.Parse(entries[2]);  					int rx = int.Parse(entries[3]);  					int ry = int.Parse(entries[4]);  					short direction = short.Parse(entries[5]);  					bool onBridge = entries[10] == "1";  					var u = new Unit(owner' name' health' direction' onBridge);  						u.Tile = Tiles.GetTileR(rx' ry);  					if (u.Tile != null)  						Units.Add(u);  				}  				catch (FormatException) {  				}  				catch (IndexOutOfRangeException) {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadUnits,The following statement contains a magic number: foreach (var v in unitsSection.OrderedEntries) {  				try {  					string[] entries = ((string)v.Value).Split(''');  					if (entries.Length <= 11) continue;    					string owner = entries[0];  					string name = entries[1];  					short health = short.Parse(entries[2]);  					int rx = int.Parse(entries[3]);  					int ry = int.Parse(entries[4]);  					short direction = short.Parse(entries[5]);  					bool onBridge = entries[10] == "1";  					var u = new Unit(owner' name' health' direction' onBridge);  						u.Tile = Tiles.GetTileR(rx' ry);  					if (u.Tile != null)  						Units.Add(u);  				}  				catch (FormatException) {  				}  				catch (IndexOutOfRangeException) {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadUnits,The following statement contains a magic number: foreach (var v in unitsSection.OrderedEntries) {  				try {  					string[] entries = ((string)v.Value).Split(''');  					if (entries.Length <= 11) continue;    					string owner = entries[0];  					string name = entries[1];  					short health = short.Parse(entries[2]);  					int rx = int.Parse(entries[3]);  					int ry = int.Parse(entries[4]);  					short direction = short.Parse(entries[5]);  					bool onBridge = entries[10] == "1";  					var u = new Unit(owner' name' health' direction' onBridge);  						u.Tile = Tiles.GetTileR(rx' ry);  					if (u.Tile != null)  						Units.Add(u);  				}  				catch (FormatException) {  				}  				catch (IndexOutOfRangeException) {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadUnits,The following statement contains a magic number: foreach (var v in unitsSection.OrderedEntries) {  				try {  					string[] entries = ((string)v.Value).Split(''');  					if (entries.Length <= 11) continue;    					string owner = entries[0];  					string name = entries[1];  					short health = short.Parse(entries[2]);  					int rx = int.Parse(entries[3]);  					int ry = int.Parse(entries[4]);  					short direction = short.Parse(entries[5]);  					bool onBridge = entries[10] == "1";  					var u = new Unit(owner' name' health' direction' onBridge);  						u.Tile = Tiles.GetTileR(rx' ry);  					if (u.Tile != null)  						Units.Add(u);  				}  				catch (FormatException) {  				}  				catch (IndexOutOfRangeException) {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadUnits,The following statement contains a magic number: foreach (var v in unitsSection.OrderedEntries) {  				try {  					string[] entries = ((string)v.Value).Split(''');  					if (entries.Length <= 11) continue;    					string owner = entries[0];  					string name = entries[1];  					short health = short.Parse(entries[2]);  					int rx = int.Parse(entries[3]);  					int ry = int.Parse(entries[4]);  					short direction = short.Parse(entries[5]);  					bool onBridge = entries[10] == "1";  					var u = new Unit(owner' name' health' direction' onBridge);  						u.Tile = Tiles.GetTileR(rx' ry);  					if (u.Tile != null)  						Units.Add(u);  				}  				catch (FormatException) {  				}  				catch (IndexOutOfRangeException) {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadAircraft,The following statement contains a magic number: foreach (var v in aircraftSection.OrderedEntries) {  				try {  					string[] entries = ((string)v.Value).Split(''');  					string owner = entries[0];  					string name = entries[1];  					short health = short.Parse(entries[2]);  					int rx = int.Parse(entries[3]);  					int ry = int.Parse(entries[4]);  					short direction = short.Parse(entries[5]);  					bool onBridge = entries[entries.Length - 4] == "1";  					var a = new Aircraft(owner' name' health' direction' onBridge);  					a.Tile = Tiles.GetTileR(rx' ry);  					if (a.Tile != null)  						Aircrafts.Add(a);  				}  				catch (FormatException) {  				}  				catch (IndexOutOfRangeException) {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadAircraft,The following statement contains a magic number: foreach (var v in aircraftSection.OrderedEntries) {  				try {  					string[] entries = ((string)v.Value).Split(''');  					string owner = entries[0];  					string name = entries[1];  					short health = short.Parse(entries[2]);  					int rx = int.Parse(entries[3]);  					int ry = int.Parse(entries[4]);  					short direction = short.Parse(entries[5]);  					bool onBridge = entries[entries.Length - 4] == "1";  					var a = new Aircraft(owner' name' health' direction' onBridge);  					a.Tile = Tiles.GetTileR(rx' ry);  					if (a.Tile != null)  						Aircrafts.Add(a);  				}  				catch (FormatException) {  				}  				catch (IndexOutOfRangeException) {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadAircraft,The following statement contains a magic number: foreach (var v in aircraftSection.OrderedEntries) {  				try {  					string[] entries = ((string)v.Value).Split(''');  					string owner = entries[0];  					string name = entries[1];  					short health = short.Parse(entries[2]);  					int rx = int.Parse(entries[3]);  					int ry = int.Parse(entries[4]);  					short direction = short.Parse(entries[5]);  					bool onBridge = entries[entries.Length - 4] == "1";  					var a = new Aircraft(owner' name' health' direction' onBridge);  					a.Tile = Tiles.GetTileR(rx' ry);  					if (a.Tile != null)  						Aircrafts.Add(a);  				}  				catch (FormatException) {  				}  				catch (IndexOutOfRangeException) {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadAircraft,The following statement contains a magic number: foreach (var v in aircraftSection.OrderedEntries) {  				try {  					string[] entries = ((string)v.Value).Split(''');  					string owner = entries[0];  					string name = entries[1];  					short health = short.Parse(entries[2]);  					int rx = int.Parse(entries[3]);  					int ry = int.Parse(entries[4]);  					short direction = short.Parse(entries[5]);  					bool onBridge = entries[entries.Length - 4] == "1";  					var a = new Aircraft(owner' name' health' direction' onBridge);  					a.Tile = Tiles.GetTileR(rx' ry);  					if (a.Tile != null)  						Aircrafts.Add(a);  				}  				catch (FormatException) {  				}  				catch (IndexOutOfRangeException) {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadAircraft,The following statement contains a magic number: foreach (var v in aircraftSection.OrderedEntries) {  				try {  					string[] entries = ((string)v.Value).Split(''');  					string owner = entries[0];  					string name = entries[1];  					short health = short.Parse(entries[2]);  					int rx = int.Parse(entries[3]);  					int ry = int.Parse(entries[4]);  					short direction = short.Parse(entries[5]);  					bool onBridge = entries[entries.Length - 4] == "1";  					var a = new Aircraft(owner' name' health' direction' onBridge);  					a.Tile = Tiles.GetTileR(rx' ry);  					if (a.Tile != null)  						Aircrafts.Add(a);  				}  				catch (FormatException) {  				}  				catch (IndexOutOfRangeException) {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadStructures,The following statement contains a magic number: foreach (var v in structsSection.OrderedEntries) {  				try {  					string[] entries = ((string)v.Value).Split(''');  					if (entries.Length <= 15) continue;  					string owner = entries[0];  					string name = entries[1];  					short health = short.Parse(entries[2]);  					int rx = int.Parse(entries[3]);  					int ry = int.Parse(entries[4]);  					short direction = short.Parse(entries[5]);  					var s = new Structure(owner' name' health' direction);  					s.Upgrade1 = entries[12];  					s.Upgrade2 = entries[13];  					s.Upgrade3 = entries[14];  					s.Tile = Tiles.GetTileR(rx' ry);    					if (s.Tile != null)  						Structures.Add(s);  				}  				catch (IndexOutOfRangeException) {  				} // catch invalid entries  				catch (FormatException) {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadStructures,The following statement contains a magic number: foreach (var v in structsSection.OrderedEntries) {  				try {  					string[] entries = ((string)v.Value).Split(''');  					if (entries.Length <= 15) continue;  					string owner = entries[0];  					string name = entries[1];  					short health = short.Parse(entries[2]);  					int rx = int.Parse(entries[3]);  					int ry = int.Parse(entries[4]);  					short direction = short.Parse(entries[5]);  					var s = new Structure(owner' name' health' direction);  					s.Upgrade1 = entries[12];  					s.Upgrade2 = entries[13];  					s.Upgrade3 = entries[14];  					s.Tile = Tiles.GetTileR(rx' ry);    					if (s.Tile != null)  						Structures.Add(s);  				}  				catch (IndexOutOfRangeException) {  				} // catch invalid entries  				catch (FormatException) {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadStructures,The following statement contains a magic number: foreach (var v in structsSection.OrderedEntries) {  				try {  					string[] entries = ((string)v.Value).Split(''');  					if (entries.Length <= 15) continue;  					string owner = entries[0];  					string name = entries[1];  					short health = short.Parse(entries[2]);  					int rx = int.Parse(entries[3]);  					int ry = int.Parse(entries[4]);  					short direction = short.Parse(entries[5]);  					var s = new Structure(owner' name' health' direction);  					s.Upgrade1 = entries[12];  					s.Upgrade2 = entries[13];  					s.Upgrade3 = entries[14];  					s.Tile = Tiles.GetTileR(rx' ry);    					if (s.Tile != null)  						Structures.Add(s);  				}  				catch (IndexOutOfRangeException) {  				} // catch invalid entries  				catch (FormatException) {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadStructures,The following statement contains a magic number: foreach (var v in structsSection.OrderedEntries) {  				try {  					string[] entries = ((string)v.Value).Split(''');  					if (entries.Length <= 15) continue;  					string owner = entries[0];  					string name = entries[1];  					short health = short.Parse(entries[2]);  					int rx = int.Parse(entries[3]);  					int ry = int.Parse(entries[4]);  					short direction = short.Parse(entries[5]);  					var s = new Structure(owner' name' health' direction);  					s.Upgrade1 = entries[12];  					s.Upgrade2 = entries[13];  					s.Upgrade3 = entries[14];  					s.Tile = Tiles.GetTileR(rx' ry);    					if (s.Tile != null)  						Structures.Add(s);  				}  				catch (IndexOutOfRangeException) {  				} // catch invalid entries  				catch (FormatException) {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadStructures,The following statement contains a magic number: foreach (var v in structsSection.OrderedEntries) {  				try {  					string[] entries = ((string)v.Value).Split(''');  					if (entries.Length <= 15) continue;  					string owner = entries[0];  					string name = entries[1];  					short health = short.Parse(entries[2]);  					int rx = int.Parse(entries[3]);  					int ry = int.Parse(entries[4]);  					short direction = short.Parse(entries[5]);  					var s = new Structure(owner' name' health' direction);  					s.Upgrade1 = entries[12];  					s.Upgrade2 = entries[13];  					s.Upgrade3 = entries[14];  					s.Tile = Tiles.GetTileR(rx' ry);    					if (s.Tile != null)  						Structures.Add(s);  				}  				catch (IndexOutOfRangeException) {  				} // catch invalid entries  				catch (FormatException) {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadStructures,The following statement contains a magic number: foreach (var v in structsSection.OrderedEntries) {  				try {  					string[] entries = ((string)v.Value).Split(''');  					if (entries.Length <= 15) continue;  					string owner = entries[0];  					string name = entries[1];  					short health = short.Parse(entries[2]);  					int rx = int.Parse(entries[3]);  					int ry = int.Parse(entries[4]);  					short direction = short.Parse(entries[5]);  					var s = new Structure(owner' name' health' direction);  					s.Upgrade1 = entries[12];  					s.Upgrade2 = entries[13];  					s.Upgrade3 = entries[14];  					s.Tile = Tiles.GetTileR(rx' ry);    					if (s.Tile != null)  						Structures.Add(s);  				}  				catch (IndexOutOfRangeException) {  				} // catch invalid entries  				catch (FormatException) {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadStructures,The following statement contains a magic number: foreach (var v in structsSection.OrderedEntries) {  				try {  					string[] entries = ((string)v.Value).Split(''');  					if (entries.Length <= 15) continue;  					string owner = entries[0];  					string name = entries[1];  					short health = short.Parse(entries[2]);  					int rx = int.Parse(entries[3]);  					int ry = int.Parse(entries[4]);  					short direction = short.Parse(entries[5]);  					var s = new Structure(owner' name' health' direction);  					s.Upgrade1 = entries[12];  					s.Upgrade2 = entries[13];  					s.Upgrade3 = entries[14];  					s.Tile = Tiles.GetTileR(rx' ry);    					if (s.Tile != null)  						Structures.Add(s);  				}  				catch (IndexOutOfRangeException) {  				} // catch invalid entries  				catch (FormatException) {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadStructures,The following statement contains a magic number: foreach (var v in structsSection.OrderedEntries) {  				try {  					string[] entries = ((string)v.Value).Split(''');  					if (entries.Length <= 15) continue;  					string owner = entries[0];  					string name = entries[1];  					short health = short.Parse(entries[2]);  					int rx = int.Parse(entries[3]);  					int ry = int.Parse(entries[4]);  					short direction = short.Parse(entries[5]);  					var s = new Structure(owner' name' health' direction);  					s.Upgrade1 = entries[12];  					s.Upgrade2 = entries[13];  					s.Upgrade3 = entries[14];  					s.Tile = Tiles.GetTileR(rx' ry);    					if (s.Tile != null)  						Structures.Add(s);  				}  				catch (IndexOutOfRangeException) {  				} // catch invalid entries  				catch (FormatException) {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadWaypoints,The following statement contains a magic number: foreach (var entry in waypoints.OrderedEntries) {  				try {  					int num' pos;  					if (int.TryParse(entry.Key' out num) && int.TryParse(entry.Value' out pos)) {  						int ry = pos / 1000;  						int rx = pos - ry * 1000;    						Waypoints.Add(new Waypoint {  							Number = int.Parse(entry.Key)'  							Tile = Tiles.GetTileR(rx' ry)'  						});  					}  				}  				catch {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,MapFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\MapFile.cs,ReadWaypoints,The following statement contains a magic number: foreach (var entry in waypoints.OrderedEntries) {  				try {  					int num' pos;  					if (int.TryParse(entry.Key' out num) && int.TryParse(entry.Value' out pos)) {  						int ry = pos / 1000;  						int rx = pos - ry * 1000;    						Waypoints.Add(new Waypoint {  							Number = int.Parse(entry.Key)'  							Tile = Tiles.GetTileR(rx' ry)'  						});  					}  				}  				catch {  				}  			}
Magic Number,CNCMaps.FileFormats.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\TileLayer.cs,TileLayer,The following statement contains a magic number: isoTiles = new IsoTile[fullSize.Width * 2 - 1' fullSize.Height];
Magic Number,CNCMaps.FileFormats.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\TileLayer.cs,GetTileR,The following statement contains a magic number: if (dx < 0 || dy < 0 || dx >= isoTiles.GetLength(0) || (dy / 2) >= isoTiles.GetLength(1))  				return null;  			else  				return GetTile(dx' dy / 2);
Magic Number,CNCMaps.FileFormats.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\TileLayer.cs,GetTileR,The following statement contains a magic number: if (dx < 0 || dy < 0 || dx >= isoTiles.GetLength(0) || (dy / 2) >= isoTiles.GetLength(1))  				return null;  			else  				return GetTile(dx' dy / 2);
Magic Number,CNCMaps.FileFormats.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\TileLayer.cs,SerializeIsoMapPack5,The following statement contains a magic number: int cells = (Width * 2 - 1) * Height;
Magic Number,CNCMaps.FileFormats.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\TileLayer.cs,SerializeIsoMapPack5,The following statement contains a magic number: int lzoPackSize = cells * 11 + 4;
Magic Number,CNCMaps.FileFormats.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\TileLayer.cs,SerializeIsoMapPack5,The following statement contains a magic number: int lzoPackSize = cells * 11 + 4;
Magic Number,CNCMaps.FileFormats.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\TileLayer.cs,SerializeIsoMapPack5,The following statement contains a magic number: foreach (var tile in this.isoTiles) {  				var bs = tile.ToMapPack5Entry().ToArray();  				Array.Copy(bs' 0' isoMapPack' di' 11);  				di += 11;  			}
Magic Number,CNCMaps.FileFormats.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\TileLayer.cs,SerializeIsoMapPack5,The following statement contains a magic number: foreach (var tile in this.isoTiles) {  				var bs = tile.ToMapPack5Entry().ToArray();  				Array.Copy(bs' 0' isoMapPack' di' 11);  				di += 11;  			}
Magic Number,CNCMaps.FileFormats.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\TileLayer.cs,SerializeIsoMapPack5,The following statement contains a magic number: var compressed = Format5.Encode(isoMapPack' 5);
Magic Number,CNCMaps.FileFormats.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\Map\TileLayer.cs,SerializeIsoMapPack5,The following statement contains a magic number: while (idx < compressed64.Length) {  				int adv = Math.Min(74' compressed64.Length - idx);  				isoMapPack5.SetValue(i++.ToString()' compressed64.Substring(idx' adv));  				idx += adv;  			}
Magic Number,CNCMaps.FileFormats.VirtualFileSystem,VFS,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\VirtualFileSystem\VFS.cs,LoadMixes,The following statement contains a magic number: for (int i = 99; i >= 0; i--) {  				string file = "expand" + i.ToString("00") + ".mix";  				if (FileExists(file))  					AddItem(file);  				if (engine == EngineType.YurisRevenge) {  					file = "expandmd" + i.ToString("00") + ".mix";  					if (FileExists(file))  						AddItem(file);  				}  			}
Magic Number,CNCMaps.FileFormats.VirtualFileSystem,VFS,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\VirtualFileSystem\VFS.cs,LoadMixes,The following statement contains a magic number: if (engine <= EngineType.Firestorm) {  				for (int i = 99; i >= 0; i--) {  					string file = string.Format("ecache{0:d2}.mix"' i);  					if (FileExists(file))  						AddItem(file);  				}  			}
Magic Number,CNCMaps.FileFormats.VirtualFileSystem,VFS,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\VirtualFileSystem\VFS.cs,LoadMixes,The following statement contains a magic number: if (engine >= EngineType.RedAlert2) {  				for (int i = 99; i >= 0; i--) {  					string file = string.Format("ecache{0:d2}.mix"' i);  					if (FileExists(file))  						AddItem(file);  				}  			}
Magic Number,CNCMaps.FileFormats.VirtualFileSystem,VFS,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\VirtualFileSystem\VFS.cs,LoadMixes,The following statement contains a magic number: for (int i = 99; i >= 0; i--) {  				string file = string.Format("elocal{0:d2}.mix"' i);  				if (FileExists(file))  					AddItem(file);  			}
Magic Number,CNCMaps.FileFormats.VirtualFileSystem,VirtualFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\VirtualFileSystem\VirtualFile.cs,ReadFloat2,The following statement contains a magic number: byte[] rev = new[] {ori[3]' ori[2]' ori[1]' ori[0]};
Magic Number,CNCMaps.FileFormats.VirtualFileSystem,VirtualFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\VirtualFileSystem\VirtualFile.cs,ReadFloat2,The following statement contains a magic number: byte[] rev = new[] {ori[3]' ori[2]' ori[1]' ori[0]};
Magic Number,CNCMaps.FileFormats.VirtualFileSystem,VirtualTextFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\VirtualFileSystem\VirtualTextFile.cs,ReadLine,The following statement contains a magic number: var builder = new StringBuilder(80);
Missing Default,CNCMaps.FileFormats.VirtualFileSystem,VirtualFile,C:\repos\zzattack_ccmaps-net\CNCMaps.FileFormats\VirtualFileSystem\VirtualFile.cs,Seek,The following switch statement is missing a default case: switch (origin) {  				case SeekOrigin.Begin:  					Position = offset;  					break;  				case SeekOrigin.Current:  					Position += offset;  					break;  				case SeekOrigin.End:  					Position = Length - offset;  					break;  			}
