Implementation smell,Namespace,Class,File,Method,Description
Long Method,CNCMaps.Engine,EngineSettings,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\EngineSettings.cs,Execute,The method has 160 lines of code.
Long Method,CNCMaps.Engine,EngineSettings,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\EngineSettings.cs,DetermineMapName,The method has 146 lines of code.
Long Method,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,LoadFromRulesFull,The method has 110 lines of code.
Long Method,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The method has 110 lines of code.
Long Method,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,The method has 176 lines of code.
Long Method,CNCMaps.Engine.Types,TechnoType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\TechnoType.cs,LoadRules,The method has 300 lines of code.
Complex Method,CNCMaps.Engine,EngineSettings,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\EngineSettings.cs,Execute,Cyclomatic complexity of the method is 27
Complex Method,CNCMaps.Engine,EngineSettings,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\EngineSettings.cs,DetermineMapName,Cyclomatic complexity of the method is 10
Complex Method,CNCMaps.Engine.Game,TileCollection,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\TileCollection.cs,InitTilesets,Cyclomatic complexity of the method is 9
Complex Method,CNCMaps.Engine.Game,BuildingDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\BuildingDrawable.cs,LoadFromRules,Cyclomatic complexity of the method is 14
Complex Method,CNCMaps.Engine.Game,BuildingDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\BuildingDrawable.cs,Draw,Cyclomatic complexity of the method is 9
Complex Method,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,LoadAllObjects,Cyclomatic complexity of the method is 9
Complex Method,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,LoadPalettes,Cyclomatic complexity of the method is 8
Complex Method,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,ApplyRemappables,Cyclomatic complexity of the method is 9
Complex Method,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,ApplyLightSources,Cyclomatic complexity of the method is 8
Complex Method,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,UndrawTiledStartPositions,Cyclomatic complexity of the method is 9
Complex Method,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,RedrawOreAndGems,Cyclomatic complexity of the method is 13
Complex Method,CNCMaps.Engine.Map,EngineDetector,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\EngineDetector.cs,DetectEngineType,Cyclomatic complexity of the method is 12
Complex Method,CNCMaps.Engine.Map,ObjectSorter,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ObjectSorter.cs,GetFrontBlock,Cyclomatic complexity of the method is 11
Complex Method,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateVeinsSpread,Cyclomatic complexity of the method is 9
Complex Method,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,FixTiles,Cyclomatic complexity of the method is 10
Complex Method,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,LoadFromRulesFull,Cyclomatic complexity of the method is 15
Complex Method,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,Draw,Cyclomatic complexity of the method is 11
Complex Method,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawShadow,Cyclomatic complexity of the method is 9
Complex Method,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,Cyclomatic complexity of the method is 16
Complex Method,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,Cyclomatic complexity of the method is 10
Long Parameter List,CNCMaps.Engine.Game,GameCollection,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\GameCollection.cs,GameCollection,The method has 5 parameters. Parameters: type' theater' engine' rules' art
Long Parameter List,CNCMaps.Engine.Game,ObjectCollection,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\ObjectCollection.cs,ObjectCollection,The method has 7 parameters. Parameters: type' theater' engine' rules' art' objectsList' palettes
Long Parameter List,CNCMaps.Engine.Game,TileCollection,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\TileCollection.cs,TileCollection,The method has 7 parameters. Parameters: type' theater' engine' rules' art' theaterSettings' theaterIni
Long Parameter List,CNCMaps.Engine.Map,EngineDetector,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\EngineDetector.cs,DetectEngineFromRules,The method has 13 parameters. Parameters: mf' rulesTS' rulesFS' rulesRA2' rulesYR' theaterTS' theaterFS' theaterRA2' theaterYR' vfsTS' vfsFS' vfsRA2' vfsYR
Long Parameter List,CNCMaps.Engine.Map,AircraftObject,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\GameObjects.cs,AircraftObject,The method has 5 parameters. Parameters: owner' name' health' direction' onBridge
Long Parameter List,CNCMaps.Engine.Map,InfantryObject,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\GameObjects.cs,InfantryObject,The method has 5 parameters. Parameters: owner' name' health' direction' onBridge
Long Parameter List,CNCMaps.Engine.Map,UnitObject,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\GameObjects.cs,UnitObject,The method has 5 parameters. Parameters: owner' name' health' direction' onBridge
Long Parameter List,CNCMaps.Engine.Map,MapTile,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\MapTile.cs,MapTile,The method has 9 parameters. Parameters: dx' dy' rx' ry' rz' tilenum' subtile' layer' setnum
Long Parameter List,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,CountNeighbouringVeins,The method has 5 parameters. Parameters: ne' se' sw' nw' test
Long Parameter List,CNCMaps.Engine.Rendering,DrawingSurface,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\DrawingSurface.cs,SavePNG,The method has 6 parameters. Parameters: path' compressionLevel' left' top' width' height
Long Parameter List,CNCMaps.Engine.Rendering,DrawingSurface,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\DrawingSurface.cs,SaveJPEG,The method has 6 parameters. Parameters: path' compression' left' top' width' height
Long Parameter List,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,Draw,The method has 6 parameters. Parameters: shp' obj' dr' props' ds' transLucency
Long Parameter List,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,GetBuildingZ,The method has 5 parameters. Parameters: x' y' shp' img' obj
Long Identifier,CNCMaps.Engine.Types,TechnoType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\TechnoType.cs,,The length of the parameter VoiceSecondaryEliteWeaponAttack is 31.
Long Identifier,CNCMaps.Engine.Types,TechnoType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\TechnoType.cs,,The length of the parameter TargetEffectivenessCoefficient is 30.
Long Identifier,CNCMaps.Engine.Types,TechnoType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\TechnoType.cs,,The length of the parameter TargetSpecialThreatCoefficient is 30.
Long Statement,CNCMaps.Engine,EngineSettings,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\EngineSettings.cs,Execute,The length of the statement  "				if (!map.Initialize(mapFile' Settings.Engine' ModConfig.ActiveConfig.CustomRulesIniFiles' ModConfig.ActiveConfig.CustomArtIniFiles)) { " is 134.
Long Statement,CNCMaps.Engine.Game,ObjectCollection,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\ObjectCollection.cs,ApplyNewTheaterIfNeeded,The length of the statement  "				// the tag will only work if the ID for the object starts with either G' N or C and its second letter is A (for Arctic/Snow theater) or T (for Temperate theater) " is 161.
Long Statement,CNCMaps.Engine.Game,ObjectCollection,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\ObjectCollection.cs,ApplyNewTheaterIfNeeded,The length of the statement  "				// In RA2' for the tag to work' it must start with either G' N or C' and its second letter must be A' T or U (Urban theater).  " is 125.
Long Statement,CNCMaps.Engine.Game,ObjectCollection,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\ObjectCollection.cs,ApplyNewTheaterIfNeeded,The length of the statement  "                // Ares allows use of any letter as the first letter. This is an experimental change seeing if enabling this behaviour without checking if Ares is in use " is 153.
Long Statement,CNCMaps.Engine.Game,ObjectCollection,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\ObjectCollection.cs,ApplyNewTheaterIfNeeded,The length of the statement  "				// if (new[] { 'G'' 'N'' 'C'' 'Y' }.Contains(artName[0]) && new[] { 'A'' 'T'' 'U'' 'D'' 'L'' 'N' }.Contains(artName[1])) " is 120.
Long Statement,CNCMaps.Engine.Game,Theater,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\Theater.cs,Initialize,The length of the statement  "            _palettes.UnitPalette = new Palette(VFS.Open<PalFile>(ModConfig.ActiveTheater.UnitPaletteName)' ModConfig.ActiveTheater.UnitPaletteName' true); " is 143.
Long Statement,CNCMaps.Engine.Game,PaletteCollection,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\PaletteCollection.cs,GetCustomPalette,The length of the statement  "                // Starkku: If the original does not exist' it means the file it should use does not exist. It now returns a null in this case' which is " is 136.
Long Statement,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,ApplyRemappables,The length of the statement  "			foreach (OwnableObject obj in _structureObjects.Cast<OwnableObject>().Union(_unitObjects).Union(_aircraftObjects).Union(_infantryObjects)) { " is 140.
Long Statement,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,RedrawOreAndGems,The length of the statement  "			var checkFunc = new Func<OverlayObject' bool>(delegate (OverlayObject ovl) { return SpecialOverlays.GetOverlayTibType(ovl' Engine) != OverlayTibType.NotSpecial; }); " is 164.
Long Statement,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,Draw,The length of the statement  "			_drawingSurface = new DrawingSurface(FullSize.Width * TileWidth' FullSize.Height * TileHeight' PixelFormat.Format24bppRgb); " is 123.
Long Statement,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,FixupTileLayer,The length of the statement  "					Logger.Warn("Removing tile at ({0}'{1}) with tilenum {2} because it is not valid in this theather's tileset"' tile.Rx' tile.Ry' tile.TileNum); " is 142.
Long Statement,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,FixupTileLayer,The length of the statement  "					Logger.Warn("Removing tile at ({0}'{1}) with tilenum {2} because no definition for it was found"' tile.Rx' tile.Ry' tile.TileNum); " is 130.
Long Statement,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,FixupTileLayer,The length of the statement  "					Logger.Warn(string.Format("Removing tile #{2}@({0}'{1}) because no tmp file for it was found; set {3} ({4})' expected filename {5}xx{6}"' " is 137.
Long Statement,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,FixupTileLayer,The length of the statement  "						tile.Rx' tile.Ry' tile.TileNum' drawable.Name' drawable.TsEntry?.MemberOfSet?.SetName ?? ""' drawable.TsEntry?.MemberOfSet?.FileName ?? ""' ModConfig.ActiveTheater.Extension)); " is 176.
Long Statement,CNCMaps.Engine.Map,EngineDetector,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\EngineDetector.cs,DetectEngineType,The length of the statement  "			var ret = DetectEngineFromRules(mf' rulesTS' rulesFS' rulesRA2' rulesYR' thsTS' thsFS' thsRA2' thsYR' vfsTS' vfsFS' vfsRA2' vfsYR); " is 131.
Long Statement,CNCMaps.Engine.Map,EngineDetector,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\EngineDetector.cs,PercentageObjectsKnown,The length of the statement  "					return section.OrderedEntries.Any(kvp => kvp.Value.ToString().Equals(name' StringComparison.InvariantCultureIgnoreCase)); " is 121.
Long Statement,CNCMaps.Engine.Map,ObjectSorter,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ObjectSorter.cs,AddDependency,The length of the statement  "				// if (added) Debug.WriteLine("dependency (" + obj + "@" + obj.Tile + " --> " + dependency + "@" + dependency.Tile + ") added because " + reason); " is 146.
Long Statement,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,IsFullVeins,The length of the statement  "			return o != null && !o.IsGeneratedVeins && o.Drawable.IsVeins && (o.Drawable.IsVeinHoleMonster || o.OverlayValue / 3 == 16); " is 124.
Long Statement,CNCMaps.Engine.Map,ThumbInjector,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ThumbInjector.cs,InjectThumb,The length of the statement  "			BitmapData bmd = preview.LockBits(new Rectangle(0' 0' preview.Width' preview.Height)' ImageLockMode.ReadOnly' PixelFormat.Format24bppRgb); " is 138.
Long Statement,CNCMaps.Engine.Map,ThumbInjector,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ThumbInjector.cs,InjectThumb,The length of the statement  "				section.SetValue(rowNum++.ToString(CultureInfo.InvariantCulture)' image_base64.Substring(i' Math.Min(70' image_base64.Length - i))); " is 132.
Long Statement,CNCMaps.Engine.Map,ThumbInjector,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ThumbInjector.cs,ExtractThumb,The length of the statement  "			BitmapData bmd = preview.LockBits(new Rectangle(0' 0' preview.Width' preview.Height)' ImageLockMode.WriteOnly' PixelFormat.Format24bppRgb); " is 139.
Long Statement,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,testNeighbours,The length of the statement  "			Debug.Assert(GetNeighbourTile(x' y' TileDirection.Bottom).Dx == x_ + 0 && GetNeighbourTile(x' y' TileDirection.Bottom).Dy == y_ + 2); " is 133.
Long Statement,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,testNeighbours,The length of the statement  "			Debug.Assert(GetNeighbourTile(x' y' TileDirection.BottomLeft).Dx == x_ - 1 && GetNeighbourTile(x' y' TileDirection.BottomLeft).Dy == y_ + 1); " is 141.
Long Statement,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,testNeighbours,The length of the statement  "			Debug.Assert(GetNeighbourTile(x' y' TileDirection.BottomRight).Dx == x_ + 1 && GetNeighbourTile(x' y' TileDirection.BottomRight).Dy == y_ + 1); " is 143.
Long Statement,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,testNeighbours,The length of the statement  "			Debug.Assert(GetNeighbourTile(x' y' TileDirection.Left).Dx == x_ - 2 && GetNeighbourTile(x' y' TileDirection.Left).Dy == y_ + 0); " is 129.
Long Statement,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,testNeighbours,The length of the statement  "			Debug.Assert(GetNeighbourTile(x' y' TileDirection.Right).Dx == x_ + 2 && GetNeighbourTile(x' y' TileDirection.Right).Dy == y_ + 0); " is 131.
Long Statement,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,testNeighbours,The length of the statement  "			Debug.Assert(GetNeighbourTile(x' y' TileDirection.Top).Dx == x_ + 0 && GetNeighbourTile(x' y' TileDirection.Top).Dy == y_ - 2); " is 127.
Long Statement,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,testNeighbours,The length of the statement  "			Debug.Assert(GetNeighbourTile(x' y' TileDirection.TopLeft).Dx == x_ - 1 && GetNeighbourTile(x' y' TileDirection.TopLeft).Dy == y_ - 1); " is 135.
Long Statement,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,testNeighbours,The length of the statement  "			Debug.Assert(GetNeighbourTile(x' y' TileDirection.TopRight).Dx == x_ + 1 && GetNeighbourTile(x' y' TileDirection.TopRight).Dy == y_ - 1); " is 137.
Long Statement,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,LoadFromRulesFull,The length of the statement  "            // Starkku: Jumpjet units placed on maps actually start at same height as ground units so adjusting this for the renderer makes no sense. " is 137.
Long Statement,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,DrawBoundingBox,The length of the statement  "			var bottom = obj.Tile.Layer.GetTileR(obj.TopTile.Rx + obj.Drawable.Foundation.Width' obj.TopTile.Ry + obj.Drawable.Foundation.Height); " is 134.
Long Statement,CNCMaps.Engine.Rendering,DebugDrawingSurfaceWindow,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\DebugDrawingSurfaceWindow.cs,pictureBox1_MouseMove,The length of the statement  "				sb.AppendFormat("   Tile {4}: d({0}'{1}) r({2}'{3})"' tile.Dx' tile.Dy' tile.Rx' tile.Ry' (tileFile?.FileName??"").ToUpper()); " is 126.
Long Statement,CNCMaps.Engine.Rendering,DebugDrawingSurfaceWindow,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\DebugDrawingSurfaceWindow.cs,InitializeComponent,The length of the statement  "			this.panel1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)  " is 142.
Long Statement,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Recalculate,The length of the statement  "            // Starkku: What is the purpose of this? Can cause weird discoloration issues when you hit this ceiling when recalculating palettes f.ex " is 136.
Long Statement,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Recalculate,The length of the statement  "            // from light sources' something that does not happen in the game (it lightens stuff up until it's near white and so on. " is 120.
Long Statement,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The length of the statement  "					short zBufVal = (short)((tile.Rx + tile.Ry) * tmp.BlockHeight / 2 + (img.ExtraZData != null ? img.ExtraZData[rIdx] : 0)); " is 121.
Long Statement,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Initialize,The length of the statement  "				Logger.Error("Voxel rendering will not be available because an exception occurred while initializing OpenGL: {0}"' exc.ToString()); " is 131.
Long Statement,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,CreateContext,The length of the statement  "			// logger.Debug("Creating graphics context' trying {0} first"' Program.Settings.PreferOSMesa ? "OSMesa" : "Window Manager"); " is 124.
Long Statement,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,The length of the statement  "			var persp = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(30)' _surface.BitmapData.Width / (float)_surface.BitmapData.Height' 1' _surface.BitmapData.Height); " is 176.
Long Statement,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,The length of the statement  "			var colors = new[] { Color.Red' Color.Green' Color.Blue' Color.Yellow' Color.Orange' Color.Black' Color.Purple' Color.SlateBlue' Color.DimGray' Color.White' Color.Teal' Color.Tan }; " is 181.
Long Statement,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,The length of the statement  "			GL.ReadPixels(0' 0' _surface.BitmapData.Width' _surface.BitmapData.Height' OpenTK.Graphics.OpenGL.PixelFormat.Bgra' PixelType.UnsignedByte' _surface.BitmapData.Scan0); " is 167.
Long Statement,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,GetBounds,The length of the statement  "				int FminX = (int)Math.Floor(Math.Min(Math.Min(Math.Min(floorTopLeft.X' floorTopRight.X)' floorBottomRight.X)' floorBottomLeft.X)); " is 130.
Long Statement,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,GetBounds,The length of the statement  "				int FmaxX = (int)Math.Ceiling(Math.Max(Math.Max(Math.Max(floorTopLeft.X' floorTopRight.X)' floorBottomRight.X)' floorBottomLeft.X)); " is 132.
Long Statement,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,GetBounds,The length of the statement  "				int FminY = (int)Math.Floor(Math.Min(Math.Min(Math.Min(floorTopLeft.Y' floorTopRight.Y)' floorBottomRight.Y)' floorBottomLeft.Y)); " is 130.
Long Statement,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,GetBounds,The length of the statement  "				int FmaxY = (int)Math.Ceiling(Math.Max(Math.Max(Math.Max(floorTopLeft.Y' floorTopRight.Y)' floorBottomRight.Y)' floorBottomLeft.Y)); " is 132.
Long Statement,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,GetBounds,The length of the statement  "				int TminX = (int)Math.Floor(Math.Min(Math.Min(Math.Min(ceilTopLeft.X' ceilTopRight.X)' ceilBottomRight.X)' ceilBottomLeft.X)); " is 126.
Long Statement,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,GetBounds,The length of the statement  "				int TmaxX = (int)Math.Ceiling(Math.Max(Math.Max(Math.Max(ceilTopLeft.X' ceilTopRight.X)' ceilBottomRight.X)' ceilBottomLeft.X)); " is 128.
Long Statement,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,GetBounds,The length of the statement  "				int TminY = (int)Math.Floor(Math.Min(Math.Min(Math.Min(ceilTopLeft.Y' ceilTopRight.Y)' ceilBottomRight.Y)' ceilBottomLeft.Y)); " is 126.
Long Statement,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,GetBounds,The length of the statement  "				int TmaxY = (int)Math.Ceiling(Math.Max(Math.Max(Math.Max(ceilTopLeft.Y' ceilTopRight.Y)' ceilBottomRight.Y)' ceilBottomLeft.Y)); " is 128.
Long Statement,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,SetupFramebuffer,The length of the statement  "			GL.Ext.RenderbufferStorage(RenderbufferTarget.RenderbufferExt' RenderbufferStorage.DepthComponent32' _surface.BitmapData.Width' _surface.BitmapData.Height); " is 156.
Long Statement,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,SetupFramebuffer,The length of the statement  "			GL.Ext.FramebufferRenderbuffer(FramebufferTarget.FramebufferExt' FramebufferAttachment.DepthAttachmentExt' RenderbufferTarget.RenderbufferExt' depthbuffer); " is 156.
Long Statement,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,SetupFramebuffer,The length of the statement  "			GL.Ext.RenderbufferStorage(RenderbufferTarget.RenderbufferExt' RenderbufferStorage.Rgba8' _surface.BitmapData.Width' _surface.BitmapData.Height); " is 145.
Long Statement,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,SetupFramebuffer,The length of the statement  "			GL.Ext.FramebufferRenderbuffer(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0Ext' RenderbufferTarget.RenderbufferExt' rgb_rb); " is 152.
Complex Conditional,CNCMaps.Engine,EngineSettings,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\EngineSettings.cs,ValidateSettings,The conditional expression  "!Settings.SaveJPEG && !Settings.SavePNG && !Settings.GeneratePreviewPack && !Settings.FixupTiles"  is complex.
Complex Conditional,CNCMaps.Engine,EngineSettings,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\EngineSettings.cs,DetermineMapName,The conditional expression  "mapExt == ".map" && pkt != null && !pkt.MapEntries.ContainsKey(pktEntryName) && engine >= EngineType.RedAlert2"  is complex.
Complex Conditional,CNCMaps.Engine.Game,TileCollection,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\TileCollection.cs,ConnectTiles,The conditional expression  "setNum1 == GreenTile && setNum2 == ShorePieces ||  				(setNum2 == GreenTile && setNum1 == ShorePieces)"  is complex.
Complex Conditional,CNCMaps.Engine.Game,TileCollection,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\TileCollection.cs,ConnectTiles,The conditional expression  "setNum1 == GreenTile && setNum2 == WaterBridge ||  				(setNum2 == GreenTile && setNum1 == WaterBridge)"  is complex.
Complex Conditional,CNCMaps.Engine.Game,TileCollection,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\TileCollection.cs,ConnectTiles,The conditional expression  "setNum1 == PaveTile && setNum2 == PavedRoads ||  				(setNum2 == PaveTile && setNum1 == PavedRoads)"  is complex.
Complex Conditional,CNCMaps.Engine.Game,TileCollection,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\TileCollection.cs,ConnectTiles,The conditional expression  "setNum1 == PaveTile && setNum2 == Medians ||  				(setNum2 == PaveTile && setNum1 == Medians)"  is complex.
Complex Conditional,CNCMaps.Engine.Game,BuildingDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\BuildingDrawable.cs,LoadExtraImage,The conditional expression  "extraArt.HasKey("YSortAdjust") || Art.HasKey(extraImage + "YSort") ||  				extraArt.HasKey("ZAdjust") || Art.HasKey(extraImage + "ZAdjust")"  is complex.
Complex Conditional,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GetAutoSizePixels,The conditional expression  "Math.Abs(full.Left - local.Left) / (double)full.Width < delta  				&& Math.Abs(full.Width - local.Width) / (double)full.Width < delta  				&& Math.Abs(full.Top - local.Top) / (double)full.Height < delta  				&& Math.Abs(full.Bottom - local.Bottom) / (double)full.Height < delta"  is complex.
Complex Conditional,CNCMaps.Engine.Map,ObjectSorter,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ObjectSorter.cs,GetFrontBlock,The conditional expression  "objA is OverlayObject && SpecialOverlays.IsHighBridge(objA as OverlayObject)                  && objB is OwnableObject && (objB as OwnableObject).OnBridge"  is complex.
Complex Conditional,CNCMaps.Engine.Map,ObjectSorter,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ObjectSorter.cs,GetFrontBlock,The conditional expression  "objB is OverlayObject && SpecialOverlays.IsHighBridge(objB as OverlayObject)                       && objA is OwnableObject && (objA as OwnableObject).OnBridge"  is complex.
Complex Conditional,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetTileR,The conditional expression  "dx < 0 || dy < 0 || dx >= tiles.GetLength(0) || (dy / 2) >= tiles.GetLength(1)"  is complex.
Complex Conditional,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawShadow,The conditional expression  "0 <= offset.X + x && offset.X + x < ds.Width && 0 <= y + offset.Y && y + offset.Y < ds.Height  						&& imgData[rIdx] != 0 && !shadows[zIdx]   						//&& zBufVal >= zBuffer[zIdx]   						&& castHeight >= heightBuffer[zIdx]"  is complex.
Complex Conditional,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawAlpha,The conditional expression  "c_px <= 0 || img.Width < 0 || img.Height < 0 || frameIndex > shp.NumImages"  is complex.
Complex Conditional,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The conditional expression  "paletteValue != 0 && w_low <= w && w < w_high && zBufVal >= zBuffer[zIdx]"  is complex.
Complex Conditional,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The conditional expression  "paletteValue != 0 && w_low <= w && w < w_high && zBufVal >= zBuffer[zIdx]"  is complex.
Complex Conditional,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The conditional expression  "paletteValue != 0 && w_low <= w && w < w_high && zBufVal >= zBuffer[zIdx]"  is complex.
Complex Conditional,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,The conditional expression  "0 <= screenPos.X && screenPos.X < _surface.Width && 0 <= screenPos.Y && screenPos.Y < _surface.Height"  is complex.
Empty Catch Block,CNCMaps.Engine,EngineSettings,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\EngineSettings.cs,DetermineMapName,The method has an empty catch block.
Empty Catch Block,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,DrawSquaredStartPositions,The method has an empty catch block.
Empty Catch Block,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,DrawSquaredStartPositions,The method has an empty catch block.
Magic Number,CNCMaps.Engine,EngineSettings,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\EngineSettings.cs,Execute,The following statement contains a magic number: try {  				_logger.Info("Initializing virtual filesystem");    				var mapStream = File.Open(Settings.InputFile' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  				VirtualFile vmapFile;  				var mixMap = new MixFile(mapStream' Settings.InputFile' 0' mapStream.Length' false' false);  				if (mixMap.IsValid()) { // input max is a mix  					var mapArchive = new MixFile(mapStream' Path.GetFileName(Settings.InputFile)' true);  					// grab the largest file in the archive  					var mixEntry = mapArchive.Index.OrderByDescending(me => me.Value.Length).First();  					vmapFile = mapArchive.OpenFile(mixEntry.Key);  				}  				else {  					vmapFile = new VirtualFile(mapStream' Path.GetFileName(Settings.InputFile)' true);  				}  				var mapFile = new MapFile(vmapFile' Path.GetFileName(Settings.InputFile));    				if (!string.IsNullOrEmpty(Settings.ModConfig)) {  					if (File.Exists(Settings.ModConfig)) {  						ModConfig cfg;  						try {  							using (FileStream f = File.OpenRead(Settings.ModConfig))  								cfg = ModConfig.Deserialize(f);  							ModConfig.ActiveConfig = cfg;  							if (Settings.Engine != EngineType.AutoDetect) {  								if (Settings.Engine != cfg.Engine)  									_logger.Warn("Provided engine override does not match mod config.");  							}  							else  								Settings.Engine = ModConfig.ActiveConfig.Engine;  						}  						catch (IOException) {  							_logger.Fatal("IOException while loading mod config");  						}  						catch (XmlException) {  							_logger.Fatal("XmlException while loading mod config");  						}  						catch (SerializationException) {  							_logger.Fatal("Serialization exception while loading mod config");  						}  					}  					else {  						_logger.Fatal("Invalid mod config file specified");  					}  				}    				if (Settings.Engine == EngineType.AutoDetect) {  					Settings.Engine = EngineDetector.DetectEngineType(mapFile);  					_logger.Info("Engine autodetect result: {0}"' Settings.Engine);  				}    				// ---------------------------------------------------------------  				// Code to organize moving of maps in a directory for themselves  				/*  				string mapName = DetermineMapName(mapFile' Settings.Engine);  				string ndir = Path.Combine(Path.GetDirectoryName(Settings.InputFile)' mapName);  				if (!Directory.Exists(ndir)) Directory.CreateDirectory(ndir);  				mapFile.Close();  				mapFile.Dispose();  				File.Move(Settings.InputFile' Path.Combine(ndir' Path.GetFileName(mapFile.FileName)));  				return 0;*/  				// ---------------------------------------------------------------    				// enginetype is now definitive' load mod config  				if (ModConfig.ActiveConfig == null)  					ModConfig.LoadDefaultConfig(Settings.Engine);    				// first add the dirs' then load the extra mixes' then scan the dirs  				foreach (string modDir in ModConfig.ActiveConfig.Directories)  					VFS.Add(modDir);    				// add mixdir to VFS (if it's not included in the mod config)  				if (!ModConfig.ActiveConfig.Directories.Any()) {  					string mixDir = VFS.DetermineMixDir(Settings.MixFilesDirectory' Settings.Engine);  					VFS.Add(mixDir);  				}  				foreach (string mixFile in ModConfig.ActiveConfig.ExtraMixes)  					VFS.Add(mixFile);    				VFS.Instance.LoadMixes(Settings.Engine);    				var map = new Map.Map {  					IgnoreLighting = Settings.IgnoreLighting'  					StartPosMarking = Settings.StartPositionMarking'  					MarkOreFields = Settings.MarkOreFields  				};    				if (!map.Initialize(mapFile' Settings.Engine' ModConfig.ActiveConfig.CustomRulesIniFiles' ModConfig.ActiveConfig.CustomArtIniFiles)) {  					_logger.Error("Could not successfully load this map. Try specifying the engine type manually.");  					return EngineResult.LoadRulesFailed;  				}    				if (!map.LoadTheater()) {  					_logger.Error("Could not successfully load all required components for this map. Aborting.");  					return EngineResult.LoadTheaterFailed;  				}    				if (Settings.StartPositionMarking == StartPositionMarking.Tiled)  					map.MarkTiledStartPositions();    				if (Settings.MarkOreFields)  					map.MarkOreAndGems();    				if (Settings.FixupTiles) map.FixupTileLayer();  				map.Draw();  				  				if (Settings.StartPositionMarking == StartPositionMarking.Squared)  					map.DrawSquaredStartPositions();    #if DEBUG  				// ====================================================================================  				using (var form = new DebugDrawingSurfaceWindow(map.GetDrawingSurface()' map.GetTiles()' map.GetTheater()' map)) {  					form.RequestTileEvaluate += map.DebugDrawTile; form.ShowDialog();  				}  				// ====================================================================================  #endif    				if (Settings.OutputFile == "")  					Settings.OutputFile = DetermineMapName(mapFile' Settings.Engine);    				if (Settings.OutputDir == "")  					Settings.OutputDir = Path.GetDirectoryName(Settings.InputFile);    				// free up as much memory as possible before saving the large images  				Rectangle saveRect = map.GetSizePixels(Settings.SizeMode);  				DrawingSurface ds = map.GetDrawingSurface();                  saveRect.Intersect(new Rectangle(0' 0' ds.Width' ds.Height));                  // if we don't need this data anymore' we can try to save some memory                  if (!Settings.GeneratePreviewPack) {  					ds.FreeNonBitmap();  					map.FreeUseless();  					GC.Collect();  				}    				if (Settings.SaveJPEG)  					ds.SaveJPEG(Path.Combine(Settings.OutputDir' Settings.OutputFile + ".jpg")' Settings.JPEGCompression' saveRect);    				if (Settings.SavePNG)  					ds.SavePNG(Path.Combine(Settings.OutputDir' Settings.OutputFile + ".png")' Settings.PNGQuality' saveRect);    				Regex reThumb = new Regex(@"(\+|)?\((\d+)'(\d+)\)");  				var match = reThumb.Match(Settings.ThumbnailConfig);  				if (match.Success) {  					Size dimensions = new Size(  						int.Parse(match.Groups[2].Captures[0].Value)'  						int.Parse(match.Groups[3].Captures[0].Value));  					var cutRect = map.GetSizePixels(Settings.SizeMode);    					if (match.Groups[1].Captures[0].Value == "+") {  						// + means maintain aspect ratio  						double aspectRatio = cutRect.Width / (double)cutRect.Height;  						if (dimensions.Width / (double)dimensions.Height > aspectRatio) {  							dimensions.Height = (int)(dimensions.Width / aspectRatio);  						}  						else {  							dimensions.Width = (int)(dimensions.Height / aspectRatio);  						}  					}  					_logger.Info("Saving thumbnail with dimensions {0}x{1}"' dimensions.Width' dimensions.Height);  					ds.SaveThumb(dimensions' cutRect' Path.Combine(Settings.OutputDir' "thumb_" + Settings.OutputFile + ".jpg"));  				}    				if (Settings.GeneratePreviewPack || Settings.FixupTiles) {  					if (mapFile.BaseStream is MixFile)  						_logger.Error("Cannot fix tile layer or inject thumbnail into an archive (.mmx/.yro/.mix)!");  					else {  						if (Settings.GeneratePreviewPack)  							map.GeneratePreviewPack(Settings.PreviewMarkers' Settings.SizeMode' mapFile' Settings.FixPreviewDimensions);    						_logger.Info("Saving map to " + Settings.InputFile);  						mapFile.Save(Settings.InputFile);  					}  				}  			}  			catch (Exception exc) {  				_logger.Error(string.Format("An unknown fatal exception occured: {0}"' exc)' exc);  #if DEBUG  				throw;  #endif  				return EngineResult.Exception;  			}
Magic Number,CNCMaps.Engine,EngineSettings,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\EngineSettings.cs,Execute,The following statement contains a magic number: try {  				_logger.Info("Initializing virtual filesystem");    				var mapStream = File.Open(Settings.InputFile' FileMode.Open' FileAccess.Read' FileShare.ReadWrite);  				VirtualFile vmapFile;  				var mixMap = new MixFile(mapStream' Settings.InputFile' 0' mapStream.Length' false' false);  				if (mixMap.IsValid()) { // input max is a mix  					var mapArchive = new MixFile(mapStream' Path.GetFileName(Settings.InputFile)' true);  					// grab the largest file in the archive  					var mixEntry = mapArchive.Index.OrderByDescending(me => me.Value.Length).First();  					vmapFile = mapArchive.OpenFile(mixEntry.Key);  				}  				else {  					vmapFile = new VirtualFile(mapStream' Path.GetFileName(Settings.InputFile)' true);  				}  				var mapFile = new MapFile(vmapFile' Path.GetFileName(Settings.InputFile));    				if (!string.IsNullOrEmpty(Settings.ModConfig)) {  					if (File.Exists(Settings.ModConfig)) {  						ModConfig cfg;  						try {  							using (FileStream f = File.OpenRead(Settings.ModConfig))  								cfg = ModConfig.Deserialize(f);  							ModConfig.ActiveConfig = cfg;  							if (Settings.Engine != EngineType.AutoDetect) {  								if (Settings.Engine != cfg.Engine)  									_logger.Warn("Provided engine override does not match mod config.");  							}  							else  								Settings.Engine = ModConfig.ActiveConfig.Engine;  						}  						catch (IOException) {  							_logger.Fatal("IOException while loading mod config");  						}  						catch (XmlException) {  							_logger.Fatal("XmlException while loading mod config");  						}  						catch (SerializationException) {  							_logger.Fatal("Serialization exception while loading mod config");  						}  					}  					else {  						_logger.Fatal("Invalid mod config file specified");  					}  				}    				if (Settings.Engine == EngineType.AutoDetect) {  					Settings.Engine = EngineDetector.DetectEngineType(mapFile);  					_logger.Info("Engine autodetect result: {0}"' Settings.Engine);  				}    				// ---------------------------------------------------------------  				// Code to organize moving of maps in a directory for themselves  				/*  				string mapName = DetermineMapName(mapFile' Settings.Engine);  				string ndir = Path.Combine(Path.GetDirectoryName(Settings.InputFile)' mapName);  				if (!Directory.Exists(ndir)) Directory.CreateDirectory(ndir);  				mapFile.Close();  				mapFile.Dispose();  				File.Move(Settings.InputFile' Path.Combine(ndir' Path.GetFileName(mapFile.FileName)));  				return 0;*/  				// ---------------------------------------------------------------    				// enginetype is now definitive' load mod config  				if (ModConfig.ActiveConfig == null)  					ModConfig.LoadDefaultConfig(Settings.Engine);    				// first add the dirs' then load the extra mixes' then scan the dirs  				foreach (string modDir in ModConfig.ActiveConfig.Directories)  					VFS.Add(modDir);    				// add mixdir to VFS (if it's not included in the mod config)  				if (!ModConfig.ActiveConfig.Directories.Any()) {  					string mixDir = VFS.DetermineMixDir(Settings.MixFilesDirectory' Settings.Engine);  					VFS.Add(mixDir);  				}  				foreach (string mixFile in ModConfig.ActiveConfig.ExtraMixes)  					VFS.Add(mixFile);    				VFS.Instance.LoadMixes(Settings.Engine);    				var map = new Map.Map {  					IgnoreLighting = Settings.IgnoreLighting'  					StartPosMarking = Settings.StartPositionMarking'  					MarkOreFields = Settings.MarkOreFields  				};    				if (!map.Initialize(mapFile' Settings.Engine' ModConfig.ActiveConfig.CustomRulesIniFiles' ModConfig.ActiveConfig.CustomArtIniFiles)) {  					_logger.Error("Could not successfully load this map. Try specifying the engine type manually.");  					return EngineResult.LoadRulesFailed;  				}    				if (!map.LoadTheater()) {  					_logger.Error("Could not successfully load all required components for this map. Aborting.");  					return EngineResult.LoadTheaterFailed;  				}    				if (Settings.StartPositionMarking == StartPositionMarking.Tiled)  					map.MarkTiledStartPositions();    				if (Settings.MarkOreFields)  					map.MarkOreAndGems();    				if (Settings.FixupTiles) map.FixupTileLayer();  				map.Draw();  				  				if (Settings.StartPositionMarking == StartPositionMarking.Squared)  					map.DrawSquaredStartPositions();    #if DEBUG  				// ====================================================================================  				using (var form = new DebugDrawingSurfaceWindow(map.GetDrawingSurface()' map.GetTiles()' map.GetTheater()' map)) {  					form.RequestTileEvaluate += map.DebugDrawTile; form.ShowDialog();  				}  				// ====================================================================================  #endif    				if (Settings.OutputFile == "")  					Settings.OutputFile = DetermineMapName(mapFile' Settings.Engine);    				if (Settings.OutputDir == "")  					Settings.OutputDir = Path.GetDirectoryName(Settings.InputFile);    				// free up as much memory as possible before saving the large images  				Rectangle saveRect = map.GetSizePixels(Settings.SizeMode);  				DrawingSurface ds = map.GetDrawingSurface();                  saveRect.Intersect(new Rectangle(0' 0' ds.Width' ds.Height));                  // if we don't need this data anymore' we can try to save some memory                  if (!Settings.GeneratePreviewPack) {  					ds.FreeNonBitmap();  					map.FreeUseless();  					GC.Collect();  				}    				if (Settings.SaveJPEG)  					ds.SaveJPEG(Path.Combine(Settings.OutputDir' Settings.OutputFile + ".jpg")' Settings.JPEGCompression' saveRect);    				if (Settings.SavePNG)  					ds.SavePNG(Path.Combine(Settings.OutputDir' Settings.OutputFile + ".png")' Settings.PNGQuality' saveRect);    				Regex reThumb = new Regex(@"(\+|)?\((\d+)'(\d+)\)");  				var match = reThumb.Match(Settings.ThumbnailConfig);  				if (match.Success) {  					Size dimensions = new Size(  						int.Parse(match.Groups[2].Captures[0].Value)'  						int.Parse(match.Groups[3].Captures[0].Value));  					var cutRect = map.GetSizePixels(Settings.SizeMode);    					if (match.Groups[1].Captures[0].Value == "+") {  						// + means maintain aspect ratio  						double aspectRatio = cutRect.Width / (double)cutRect.Height;  						if (dimensions.Width / (double)dimensions.Height > aspectRatio) {  							dimensions.Height = (int)(dimensions.Width / aspectRatio);  						}  						else {  							dimensions.Width = (int)(dimensions.Height / aspectRatio);  						}  					}  					_logger.Info("Saving thumbnail with dimensions {0}x{1}"' dimensions.Width' dimensions.Height);  					ds.SaveThumb(dimensions' cutRect' Path.Combine(Settings.OutputDir' "thumb_" + Settings.OutputFile + ".jpg"));  				}    				if (Settings.GeneratePreviewPack || Settings.FixupTiles) {  					if (mapFile.BaseStream is MixFile)  						_logger.Error("Cannot fix tile layer or inject thumbnail into an archive (.mmx/.yro/.mix)!");  					else {  						if (Settings.GeneratePreviewPack)  							map.GeneratePreviewPack(Settings.PreviewMarkers' Settings.SizeMode' mapFile' Settings.FixPreviewDimensions);    						_logger.Info("Saving map to " + Settings.InputFile);  						mapFile.Save(Settings.InputFile);  					}  				}  			}  			catch (Exception exc) {  				_logger.Error(string.Format("An unknown fatal exception occured: {0}"' exc)' exc);  #if DEBUG  				throw;  #endif  				return EngineResult.Exception;  			}
Magic Number,CNCMaps.Engine,EngineSettings,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\EngineSettings.cs,DetermineMapName,The following statement contains a magic number: if (engine <= EngineType.Firestorm) {  				if (pktMapEntry != null)  					mapName = pktMapEntry.Description;  				else if (missionEntry != null) {  					if (engine == EngineType.TiberianSun) {  						string campaignSide;  						string missionNumber;    						if (missionEntry.Briefing.Length >= 3) {  							campaignSide = missionEntry.Briefing.Substring(0' 3);  							missionNumber = missionEntry.Briefing.Length > 3 ? missionEntry.Briefing.Substring(3) : "";  							missionName = "";  							mapName = string.Format("{0} {1} - {2}"' campaignSide' missionNumber.TrimEnd('A').PadLeft(2' '0')' missionName);  						}  						else if (missionEntry.Name.Length >= 10) {  							mapName = missionEntry.Name;  						}  					}  					else {  						// FS map names are constructed a bit easier  						mapName = missionName.Replace(":"' " - ");  					}  				}  				else if (!string.IsNullOrEmpty(basic.ReadString("Name")))  					mapName = basic.ReadString("Name"' fileNameWithoutExtension);  			}    				// if this is a RA2/YR mission (csfEntry set) or official map with valid pktMapEntry  			else if (missionEntry != null || pktMapEntry != null) {  				string csfEntryName = missionEntry != null ? missionName : pktMapEntry.Description;    				string csfFile = engine == EngineType.YurisRevenge ? "ra2md.csf" : "ra2.csf";  				_logger.Info("Loading csf file {0}"' csfFile);  				var csf = VFS.Open<CsfFile>(csfFile);  				mapName = csf.GetValue(csfEntryName.ToLower());    				if (missionEntry != null) {  					if (mapName.Contains("Operation: ")) {  						string missionMapName = Path.GetFileName(map.FileName);  						if (char.IsDigit(missionMapName[3]) && char.IsDigit(missionMapName[4])) {  							string missionNr = Path.GetFileName(map.FileName).Substring(3' 2);  							mapName = mapName.Substring(0' mapName.IndexOf(":")) + " " + missionNr + " -" +  									  mapName.Substring(mapName.IndexOf(":") + 1);  						}  					}  				}  				else {  					// not standard map  					if ((pktMapEntry.GameModes & PktFile.GameMode.Standard) == 0) {  						if ((pktMapEntry.GameModes & PktFile.GameMode.Megawealth) == PktFile.GameMode.Megawealth)  							mapName += " (Megawealth)";  						if ((pktMapEntry.GameModes & PktFile.GameMode.Duel) == PktFile.GameMode.Duel)  							mapName += " (Land Rush)";  						if ((pktMapEntry.GameModes & PktFile.GameMode.NavalWar) == PktFile.GameMode.NavalWar)  							mapName += " (Naval War)";  					}  				}  			}
Magic Number,CNCMaps.Engine,EngineSettings,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\EngineSettings.cs,DetermineMapName,The following statement contains a magic number: if (engine <= EngineType.Firestorm) {  				if (pktMapEntry != null)  					mapName = pktMapEntry.Description;  				else if (missionEntry != null) {  					if (engine == EngineType.TiberianSun) {  						string campaignSide;  						string missionNumber;    						if (missionEntry.Briefing.Length >= 3) {  							campaignSide = missionEntry.Briefing.Substring(0' 3);  							missionNumber = missionEntry.Briefing.Length > 3 ? missionEntry.Briefing.Substring(3) : "";  							missionName = "";  							mapName = string.Format("{0} {1} - {2}"' campaignSide' missionNumber.TrimEnd('A').PadLeft(2' '0')' missionName);  						}  						else if (missionEntry.Name.Length >= 10) {  							mapName = missionEntry.Name;  						}  					}  					else {  						// FS map names are constructed a bit easier  						mapName = missionName.Replace(":"' " - ");  					}  				}  				else if (!string.IsNullOrEmpty(basic.ReadString("Name")))  					mapName = basic.ReadString("Name"' fileNameWithoutExtension);  			}    				// if this is a RA2/YR mission (csfEntry set) or official map with valid pktMapEntry  			else if (missionEntry != null || pktMapEntry != null) {  				string csfEntryName = missionEntry != null ? missionName : pktMapEntry.Description;    				string csfFile = engine == EngineType.YurisRevenge ? "ra2md.csf" : "ra2.csf";  				_logger.Info("Loading csf file {0}"' csfFile);  				var csf = VFS.Open<CsfFile>(csfFile);  				mapName = csf.GetValue(csfEntryName.ToLower());    				if (missionEntry != null) {  					if (mapName.Contains("Operation: ")) {  						string missionMapName = Path.GetFileName(map.FileName);  						if (char.IsDigit(missionMapName[3]) && char.IsDigit(missionMapName[4])) {  							string missionNr = Path.GetFileName(map.FileName).Substring(3' 2);  							mapName = mapName.Substring(0' mapName.IndexOf(":")) + " " + missionNr + " -" +  									  mapName.Substring(mapName.IndexOf(":") + 1);  						}  					}  				}  				else {  					// not standard map  					if ((pktMapEntry.GameModes & PktFile.GameMode.Standard) == 0) {  						if ((pktMapEntry.GameModes & PktFile.GameMode.Megawealth) == PktFile.GameMode.Megawealth)  							mapName += " (Megawealth)";  						if ((pktMapEntry.GameModes & PktFile.GameMode.Duel) == PktFile.GameMode.Duel)  							mapName += " (Land Rush)";  						if ((pktMapEntry.GameModes & PktFile.GameMode.NavalWar) == PktFile.GameMode.NavalWar)  							mapName += " (Naval War)";  					}  				}  			}
Magic Number,CNCMaps.Engine,EngineSettings,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\EngineSettings.cs,DetermineMapName,The following statement contains a magic number: if (engine <= EngineType.Firestorm) {  				if (pktMapEntry != null)  					mapName = pktMapEntry.Description;  				else if (missionEntry != null) {  					if (engine == EngineType.TiberianSun) {  						string campaignSide;  						string missionNumber;    						if (missionEntry.Briefing.Length >= 3) {  							campaignSide = missionEntry.Briefing.Substring(0' 3);  							missionNumber = missionEntry.Briefing.Length > 3 ? missionEntry.Briefing.Substring(3) : "";  							missionName = "";  							mapName = string.Format("{0} {1} - {2}"' campaignSide' missionNumber.TrimEnd('A').PadLeft(2' '0')' missionName);  						}  						else if (missionEntry.Name.Length >= 10) {  							mapName = missionEntry.Name;  						}  					}  					else {  						// FS map names are constructed a bit easier  						mapName = missionName.Replace(":"' " - ");  					}  				}  				else if (!string.IsNullOrEmpty(basic.ReadString("Name")))  					mapName = basic.ReadString("Name"' fileNameWithoutExtension);  			}    				// if this is a RA2/YR mission (csfEntry set) or official map with valid pktMapEntry  			else if (missionEntry != null || pktMapEntry != null) {  				string csfEntryName = missionEntry != null ? missionName : pktMapEntry.Description;    				string csfFile = engine == EngineType.YurisRevenge ? "ra2md.csf" : "ra2.csf";  				_logger.Info("Loading csf file {0}"' csfFile);  				var csf = VFS.Open<CsfFile>(csfFile);  				mapName = csf.GetValue(csfEntryName.ToLower());    				if (missionEntry != null) {  					if (mapName.Contains("Operation: ")) {  						string missionMapName = Path.GetFileName(map.FileName);  						if (char.IsDigit(missionMapName[3]) && char.IsDigit(missionMapName[4])) {  							string missionNr = Path.GetFileName(map.FileName).Substring(3' 2);  							mapName = mapName.Substring(0' mapName.IndexOf(":")) + " " + missionNr + " -" +  									  mapName.Substring(mapName.IndexOf(":") + 1);  						}  					}  				}  				else {  					// not standard map  					if ((pktMapEntry.GameModes & PktFile.GameMode.Standard) == 0) {  						if ((pktMapEntry.GameModes & PktFile.GameMode.Megawealth) == PktFile.GameMode.Megawealth)  							mapName += " (Megawealth)";  						if ((pktMapEntry.GameModes & PktFile.GameMode.Duel) == PktFile.GameMode.Duel)  							mapName += " (Land Rush)";  						if ((pktMapEntry.GameModes & PktFile.GameMode.NavalWar) == PktFile.GameMode.NavalWar)  							mapName += " (Naval War)";  					}  				}  			}
Magic Number,CNCMaps.Engine,EngineSettings,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\EngineSettings.cs,DetermineMapName,The following statement contains a magic number: if (engine <= EngineType.Firestorm) {  				if (pktMapEntry != null)  					mapName = pktMapEntry.Description;  				else if (missionEntry != null) {  					if (engine == EngineType.TiberianSun) {  						string campaignSide;  						string missionNumber;    						if (missionEntry.Briefing.Length >= 3) {  							campaignSide = missionEntry.Briefing.Substring(0' 3);  							missionNumber = missionEntry.Briefing.Length > 3 ? missionEntry.Briefing.Substring(3) : "";  							missionName = "";  							mapName = string.Format("{0} {1} - {2}"' campaignSide' missionNumber.TrimEnd('A').PadLeft(2' '0')' missionName);  						}  						else if (missionEntry.Name.Length >= 10) {  							mapName = missionEntry.Name;  						}  					}  					else {  						// FS map names are constructed a bit easier  						mapName = missionName.Replace(":"' " - ");  					}  				}  				else if (!string.IsNullOrEmpty(basic.ReadString("Name")))  					mapName = basic.ReadString("Name"' fileNameWithoutExtension);  			}    				// if this is a RA2/YR mission (csfEntry set) or official map with valid pktMapEntry  			else if (missionEntry != null || pktMapEntry != null) {  				string csfEntryName = missionEntry != null ? missionName : pktMapEntry.Description;    				string csfFile = engine == EngineType.YurisRevenge ? "ra2md.csf" : "ra2.csf";  				_logger.Info("Loading csf file {0}"' csfFile);  				var csf = VFS.Open<CsfFile>(csfFile);  				mapName = csf.GetValue(csfEntryName.ToLower());    				if (missionEntry != null) {  					if (mapName.Contains("Operation: ")) {  						string missionMapName = Path.GetFileName(map.FileName);  						if (char.IsDigit(missionMapName[3]) && char.IsDigit(missionMapName[4])) {  							string missionNr = Path.GetFileName(map.FileName).Substring(3' 2);  							mapName = mapName.Substring(0' mapName.IndexOf(":")) + " " + missionNr + " -" +  									  mapName.Substring(mapName.IndexOf(":") + 1);  						}  					}  				}  				else {  					// not standard map  					if ((pktMapEntry.GameModes & PktFile.GameMode.Standard) == 0) {  						if ((pktMapEntry.GameModes & PktFile.GameMode.Megawealth) == PktFile.GameMode.Megawealth)  							mapName += " (Megawealth)";  						if ((pktMapEntry.GameModes & PktFile.GameMode.Duel) == PktFile.GameMode.Duel)  							mapName += " (Land Rush)";  						if ((pktMapEntry.GameModes & PktFile.GameMode.NavalWar) == PktFile.GameMode.NavalWar)  							mapName += " (Naval War)";  					}  				}  			}
Magic Number,CNCMaps.Engine,EngineSettings,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\EngineSettings.cs,DetermineMapName,The following statement contains a magic number: if (engine <= EngineType.Firestorm) {  				if (pktMapEntry != null)  					mapName = pktMapEntry.Description;  				else if (missionEntry != null) {  					if (engine == EngineType.TiberianSun) {  						string campaignSide;  						string missionNumber;    						if (missionEntry.Briefing.Length >= 3) {  							campaignSide = missionEntry.Briefing.Substring(0' 3);  							missionNumber = missionEntry.Briefing.Length > 3 ? missionEntry.Briefing.Substring(3) : "";  							missionName = "";  							mapName = string.Format("{0} {1} - {2}"' campaignSide' missionNumber.TrimEnd('A').PadLeft(2' '0')' missionName);  						}  						else if (missionEntry.Name.Length >= 10) {  							mapName = missionEntry.Name;  						}  					}  					else {  						// FS map names are constructed a bit easier  						mapName = missionName.Replace(":"' " - ");  					}  				}  				else if (!string.IsNullOrEmpty(basic.ReadString("Name")))  					mapName = basic.ReadString("Name"' fileNameWithoutExtension);  			}    				// if this is a RA2/YR mission (csfEntry set) or official map with valid pktMapEntry  			else if (missionEntry != null || pktMapEntry != null) {  				string csfEntryName = missionEntry != null ? missionName : pktMapEntry.Description;    				string csfFile = engine == EngineType.YurisRevenge ? "ra2md.csf" : "ra2.csf";  				_logger.Info("Loading csf file {0}"' csfFile);  				var csf = VFS.Open<CsfFile>(csfFile);  				mapName = csf.GetValue(csfEntryName.ToLower());    				if (missionEntry != null) {  					if (mapName.Contains("Operation: ")) {  						string missionMapName = Path.GetFileName(map.FileName);  						if (char.IsDigit(missionMapName[3]) && char.IsDigit(missionMapName[4])) {  							string missionNr = Path.GetFileName(map.FileName).Substring(3' 2);  							mapName = mapName.Substring(0' mapName.IndexOf(":")) + " " + missionNr + " -" +  									  mapName.Substring(mapName.IndexOf(":") + 1);  						}  					}  				}  				else {  					// not standard map  					if ((pktMapEntry.GameModes & PktFile.GameMode.Standard) == 0) {  						if ((pktMapEntry.GameModes & PktFile.GameMode.Megawealth) == PktFile.GameMode.Megawealth)  							mapName += " (Megawealth)";  						if ((pktMapEntry.GameModes & PktFile.GameMode.Duel) == PktFile.GameMode.Duel)  							mapName += " (Land Rush)";  						if ((pktMapEntry.GameModes & PktFile.GameMode.NavalWar) == PktFile.GameMode.NavalWar)  							mapName += " (Naval War)";  					}  				}  			}
Magic Number,CNCMaps.Engine,EngineSettings,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\EngineSettings.cs,DetermineMapName,The following statement contains a magic number: if (engine <= EngineType.Firestorm) {  				if (pktMapEntry != null)  					mapName = pktMapEntry.Description;  				else if (missionEntry != null) {  					if (engine == EngineType.TiberianSun) {  						string campaignSide;  						string missionNumber;    						if (missionEntry.Briefing.Length >= 3) {  							campaignSide = missionEntry.Briefing.Substring(0' 3);  							missionNumber = missionEntry.Briefing.Length > 3 ? missionEntry.Briefing.Substring(3) : "";  							missionName = "";  							mapName = string.Format("{0} {1} - {2}"' campaignSide' missionNumber.TrimEnd('A').PadLeft(2' '0')' missionName);  						}  						else if (missionEntry.Name.Length >= 10) {  							mapName = missionEntry.Name;  						}  					}  					else {  						// FS map names are constructed a bit easier  						mapName = missionName.Replace(":"' " - ");  					}  				}  				else if (!string.IsNullOrEmpty(basic.ReadString("Name")))  					mapName = basic.ReadString("Name"' fileNameWithoutExtension);  			}    				// if this is a RA2/YR mission (csfEntry set) or official map with valid pktMapEntry  			else if (missionEntry != null || pktMapEntry != null) {  				string csfEntryName = missionEntry != null ? missionName : pktMapEntry.Description;    				string csfFile = engine == EngineType.YurisRevenge ? "ra2md.csf" : "ra2.csf";  				_logger.Info("Loading csf file {0}"' csfFile);  				var csf = VFS.Open<CsfFile>(csfFile);  				mapName = csf.GetValue(csfEntryName.ToLower());    				if (missionEntry != null) {  					if (mapName.Contains("Operation: ")) {  						string missionMapName = Path.GetFileName(map.FileName);  						if (char.IsDigit(missionMapName[3]) && char.IsDigit(missionMapName[4])) {  							string missionNr = Path.GetFileName(map.FileName).Substring(3' 2);  							mapName = mapName.Substring(0' mapName.IndexOf(":")) + " " + missionNr + " -" +  									  mapName.Substring(mapName.IndexOf(":") + 1);  						}  					}  				}  				else {  					// not standard map  					if ((pktMapEntry.GameModes & PktFile.GameMode.Standard) == 0) {  						if ((pktMapEntry.GameModes & PktFile.GameMode.Megawealth) == PktFile.GameMode.Megawealth)  							mapName += " (Megawealth)";  						if ((pktMapEntry.GameModes & PktFile.GameMode.Duel) == PktFile.GameMode.Duel)  							mapName += " (Land Rush)";  						if ((pktMapEntry.GameModes & PktFile.GameMode.NavalWar) == PktFile.GameMode.NavalWar)  							mapName += " (Naval War)";  					}  				}  			}
Magic Number,CNCMaps.Engine,EngineSettings,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\EngineSettings.cs,DetermineMapName,The following statement contains a magic number: if (engine <= EngineType.Firestorm) {  				if (pktMapEntry != null)  					mapName = pktMapEntry.Description;  				else if (missionEntry != null) {  					if (engine == EngineType.TiberianSun) {  						string campaignSide;  						string missionNumber;    						if (missionEntry.Briefing.Length >= 3) {  							campaignSide = missionEntry.Briefing.Substring(0' 3);  							missionNumber = missionEntry.Briefing.Length > 3 ? missionEntry.Briefing.Substring(3) : "";  							missionName = "";  							mapName = string.Format("{0} {1} - {2}"' campaignSide' missionNumber.TrimEnd('A').PadLeft(2' '0')' missionName);  						}  						else if (missionEntry.Name.Length >= 10) {  							mapName = missionEntry.Name;  						}  					}  					else {  						// FS map names are constructed a bit easier  						mapName = missionName.Replace(":"' " - ");  					}  				}  				else if (!string.IsNullOrEmpty(basic.ReadString("Name")))  					mapName = basic.ReadString("Name"' fileNameWithoutExtension);  			}    				// if this is a RA2/YR mission (csfEntry set) or official map with valid pktMapEntry  			else if (missionEntry != null || pktMapEntry != null) {  				string csfEntryName = missionEntry != null ? missionName : pktMapEntry.Description;    				string csfFile = engine == EngineType.YurisRevenge ? "ra2md.csf" : "ra2.csf";  				_logger.Info("Loading csf file {0}"' csfFile);  				var csf = VFS.Open<CsfFile>(csfFile);  				mapName = csf.GetValue(csfEntryName.ToLower());    				if (missionEntry != null) {  					if (mapName.Contains("Operation: ")) {  						string missionMapName = Path.GetFileName(map.FileName);  						if (char.IsDigit(missionMapName[3]) && char.IsDigit(missionMapName[4])) {  							string missionNr = Path.GetFileName(map.FileName).Substring(3' 2);  							mapName = mapName.Substring(0' mapName.IndexOf(":")) + " " + missionNr + " -" +  									  mapName.Substring(mapName.IndexOf(":") + 1);  						}  					}  				}  				else {  					// not standard map  					if ((pktMapEntry.GameModes & PktFile.GameMode.Standard) == 0) {  						if ((pktMapEntry.GameModes & PktFile.GameMode.Megawealth) == PktFile.GameMode.Megawealth)  							mapName += " (Megawealth)";  						if ((pktMapEntry.GameModes & PktFile.GameMode.Duel) == PktFile.GameMode.Duel)  							mapName += " (Land Rush)";  						if ((pktMapEntry.GameModes & PktFile.GameMode.NavalWar) == PktFile.GameMode.NavalWar)  							mapName += " (Naval War)";  					}  				}  			}
Magic Number,CNCMaps.Engine,EngineSettings,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\EngineSettings.cs,DetermineMapName,The following statement contains a magic number: if (engine <= EngineType.Firestorm) {  				if (pktMapEntry != null)  					mapName = pktMapEntry.Description;  				else if (missionEntry != null) {  					if (engine == EngineType.TiberianSun) {  						string campaignSide;  						string missionNumber;    						if (missionEntry.Briefing.Length >= 3) {  							campaignSide = missionEntry.Briefing.Substring(0' 3);  							missionNumber = missionEntry.Briefing.Length > 3 ? missionEntry.Briefing.Substring(3) : "";  							missionName = "";  							mapName = string.Format("{0} {1} - {2}"' campaignSide' missionNumber.TrimEnd('A').PadLeft(2' '0')' missionName);  						}  						else if (missionEntry.Name.Length >= 10) {  							mapName = missionEntry.Name;  						}  					}  					else {  						// FS map names are constructed a bit easier  						mapName = missionName.Replace(":"' " - ");  					}  				}  				else if (!string.IsNullOrEmpty(basic.ReadString("Name")))  					mapName = basic.ReadString("Name"' fileNameWithoutExtension);  			}    				// if this is a RA2/YR mission (csfEntry set) or official map with valid pktMapEntry  			else if (missionEntry != null || pktMapEntry != null) {  				string csfEntryName = missionEntry != null ? missionName : pktMapEntry.Description;    				string csfFile = engine == EngineType.YurisRevenge ? "ra2md.csf" : "ra2.csf";  				_logger.Info("Loading csf file {0}"' csfFile);  				var csf = VFS.Open<CsfFile>(csfFile);  				mapName = csf.GetValue(csfEntryName.ToLower());    				if (missionEntry != null) {  					if (mapName.Contains("Operation: ")) {  						string missionMapName = Path.GetFileName(map.FileName);  						if (char.IsDigit(missionMapName[3]) && char.IsDigit(missionMapName[4])) {  							string missionNr = Path.GetFileName(map.FileName).Substring(3' 2);  							mapName = mapName.Substring(0' mapName.IndexOf(":")) + " " + missionNr + " -" +  									  mapName.Substring(mapName.IndexOf(":") + 1);  						}  					}  				}  				else {  					// not standard map  					if ((pktMapEntry.GameModes & PktFile.GameMode.Standard) == 0) {  						if ((pktMapEntry.GameModes & PktFile.GameMode.Megawealth) == PktFile.GameMode.Megawealth)  							mapName += " (Megawealth)";  						if ((pktMapEntry.GameModes & PktFile.GameMode.Duel) == PktFile.GameMode.Duel)  							mapName += " (Land Rush)";  						if ((pktMapEntry.GameModes & PktFile.GameMode.NavalWar) == PktFile.GameMode.NavalWar)  							mapName += " (Naval War)";  					}  				}  			}
Magic Number,CNCMaps.Engine,EngineSettings,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\EngineSettings.cs,DetermineMapName,The following statement contains a magic number: if (engine <= EngineType.Firestorm) {  				if (pktMapEntry != null)  					mapName = pktMapEntry.Description;  				else if (missionEntry != null) {  					if (engine == EngineType.TiberianSun) {  						string campaignSide;  						string missionNumber;    						if (missionEntry.Briefing.Length >= 3) {  							campaignSide = missionEntry.Briefing.Substring(0' 3);  							missionNumber = missionEntry.Briefing.Length > 3 ? missionEntry.Briefing.Substring(3) : "";  							missionName = "";  							mapName = string.Format("{0} {1} - {2}"' campaignSide' missionNumber.TrimEnd('A').PadLeft(2' '0')' missionName);  						}  						else if (missionEntry.Name.Length >= 10) {  							mapName = missionEntry.Name;  						}  					}  					else {  						// FS map names are constructed a bit easier  						mapName = missionName.Replace(":"' " - ");  					}  				}  				else if (!string.IsNullOrEmpty(basic.ReadString("Name")))  					mapName = basic.ReadString("Name"' fileNameWithoutExtension);  			}    				// if this is a RA2/YR mission (csfEntry set) or official map with valid pktMapEntry  			else if (missionEntry != null || pktMapEntry != null) {  				string csfEntryName = missionEntry != null ? missionName : pktMapEntry.Description;    				string csfFile = engine == EngineType.YurisRevenge ? "ra2md.csf" : "ra2.csf";  				_logger.Info("Loading csf file {0}"' csfFile);  				var csf = VFS.Open<CsfFile>(csfFile);  				mapName = csf.GetValue(csfEntryName.ToLower());    				if (missionEntry != null) {  					if (mapName.Contains("Operation: ")) {  						string missionMapName = Path.GetFileName(map.FileName);  						if (char.IsDigit(missionMapName[3]) && char.IsDigit(missionMapName[4])) {  							string missionNr = Path.GetFileName(map.FileName).Substring(3' 2);  							mapName = mapName.Substring(0' mapName.IndexOf(":")) + " " + missionNr + " -" +  									  mapName.Substring(mapName.IndexOf(":") + 1);  						}  					}  				}  				else {  					// not standard map  					if ((pktMapEntry.GameModes & PktFile.GameMode.Standard) == 0) {  						if ((pktMapEntry.GameModes & PktFile.GameMode.Megawealth) == PktFile.GameMode.Megawealth)  							mapName += " (Megawealth)";  						if ((pktMapEntry.GameModes & PktFile.GameMode.Duel) == PktFile.GameMode.Duel)  							mapName += " (Land Rush)";  						if ((pktMapEntry.GameModes & PktFile.GameMode.NavalWar) == PktFile.GameMode.NavalWar)  							mapName += " (Naval War)";  					}  				}  			}
Magic Number,CNCMaps.Engine,EngineSettings,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\EngineSettings.cs,DetermineMapName,The following statement contains a magic number: if (engine <= EngineType.Firestorm) {  				if (pktMapEntry != null)  					mapName = pktMapEntry.Description;  				else if (missionEntry != null) {  					if (engine == EngineType.TiberianSun) {  						string campaignSide;  						string missionNumber;    						if (missionEntry.Briefing.Length >= 3) {  							campaignSide = missionEntry.Briefing.Substring(0' 3);  							missionNumber = missionEntry.Briefing.Length > 3 ? missionEntry.Briefing.Substring(3) : "";  							missionName = "";  							mapName = string.Format("{0} {1} - {2}"' campaignSide' missionNumber.TrimEnd('A').PadLeft(2' '0')' missionName);  						}  						else if (missionEntry.Name.Length >= 10) {  							mapName = missionEntry.Name;  						}  					}  					else {  						// FS map names are constructed a bit easier  						mapName = missionName.Replace(":"' " - ");  					}  				}  				else if (!string.IsNullOrEmpty(basic.ReadString("Name")))  					mapName = basic.ReadString("Name"' fileNameWithoutExtension);  			}    				// if this is a RA2/YR mission (csfEntry set) or official map with valid pktMapEntry  			else if (missionEntry != null || pktMapEntry != null) {  				string csfEntryName = missionEntry != null ? missionName : pktMapEntry.Description;    				string csfFile = engine == EngineType.YurisRevenge ? "ra2md.csf" : "ra2.csf";  				_logger.Info("Loading csf file {0}"' csfFile);  				var csf = VFS.Open<CsfFile>(csfFile);  				mapName = csf.GetValue(csfEntryName.ToLower());    				if (missionEntry != null) {  					if (mapName.Contains("Operation: ")) {  						string missionMapName = Path.GetFileName(map.FileName);  						if (char.IsDigit(missionMapName[3]) && char.IsDigit(missionMapName[4])) {  							string missionNr = Path.GetFileName(map.FileName).Substring(3' 2);  							mapName = mapName.Substring(0' mapName.IndexOf(":")) + " " + missionNr + " -" +  									  mapName.Substring(mapName.IndexOf(":") + 1);  						}  					}  				}  				else {  					// not standard map  					if ((pktMapEntry.GameModes & PktFile.GameMode.Standard) == 0) {  						if ((pktMapEntry.GameModes & PktFile.GameMode.Megawealth) == PktFile.GameMode.Megawealth)  							mapName += " (Megawealth)";  						if ((pktMapEntry.GameModes & PktFile.GameMode.Duel) == PktFile.GameMode.Duel)  							mapName += " (Land Rush)";  						if ((pktMapEntry.GameModes & PktFile.GameMode.NavalWar) == PktFile.GameMode.NavalWar)  							mapName += " (Naval War)";  					}  				}  			}
Magic Number,CNCMaps.Engine.Game,FrameDeciders,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\FrameDeciders.cs,AlphaImageFrameDecider,The following statement contains a magic number: return delegate(GameObject obj) {  				int direction = 0;  				if (obj is OwnableObject)  					direction = (obj as OwnableObject).Direction;  				shp.Initialize(); // header needs to be loaded at least  				int imgCount = shp.NumImages;  				if (imgCount % 8 == 0)  					return (imgCount / 8) * (direction / 32);  				else  					return 0;  			};
Magic Number,CNCMaps.Engine.Game,FrameDeciders,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\FrameDeciders.cs,AlphaImageFrameDecider,The following statement contains a magic number: return delegate(GameObject obj) {  				int direction = 0;  				if (obj is OwnableObject)  					direction = (obj as OwnableObject).Direction;  				shp.Initialize(); // header needs to be loaded at least  				int imgCount = shp.NumImages;  				if (imgCount % 8 == 0)  					return (imgCount / 8) * (direction / 32);  				else  					return 0;  			};
Magic Number,CNCMaps.Engine.Game,FrameDeciders,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\FrameDeciders.cs,AlphaImageFrameDecider,The following statement contains a magic number: return delegate(GameObject obj) {  				int direction = 0;  				if (obj is OwnableObject)  					direction = (obj as OwnableObject).Direction;  				shp.Initialize(); // header needs to be loaded at least  				int imgCount = shp.NumImages;  				if (imgCount % 8 == 0)  					return (imgCount / 8) * (direction / 32);  				else  					return 0;  			};
Magic Number,CNCMaps.Engine.Game,FrameDeciders,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\FrameDeciders.cs,SHPVehicleFrameDecider,The following statement contains a magic number: return delegate(GameObject obj)              {                  int direction = 0;  				if (obj is OwnableObject)  					direction = (obj as OwnableObject).Direction;                  if (StandingFrames > 0) return StartStandFrame + (((direction / 32)+1) * StandingFrames);                  return StartStandFrame;              };
Magic Number,CNCMaps.Engine.Game,ObjectCollection,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\ObjectCollection.cs,InitDrawableDefaults,The following statement contains a magic number: switch (Type) {  				case CollectionType.Building:  				case CollectionType.Overlay:  				case CollectionType.Smudge:  					drawable.Props.Offset.Offset(Drawable.TileWidth / 2' 0);  					break;  				case CollectionType.Terrain:  				case CollectionType.Vehicle:  				case CollectionType.Infantry:  				case CollectionType.Aircraft:  				case CollectionType.Animation:  					drawable.Props.Offset.Offset(Drawable.TileWidth / 2' Drawable.TileHeight / 2);  					break;  			}
Magic Number,CNCMaps.Engine.Game,ObjectCollection,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\ObjectCollection.cs,InitDrawableDefaults,The following statement contains a magic number: switch (Type) {  				case CollectionType.Building:  				case CollectionType.Overlay:  				case CollectionType.Smudge:  					drawable.Props.Offset.Offset(Drawable.TileWidth / 2' 0);  					break;  				case CollectionType.Terrain:  				case CollectionType.Vehicle:  				case CollectionType.Infantry:  				case CollectionType.Aircraft:  				case CollectionType.Animation:  					drawable.Props.Offset.Offset(Drawable.TileWidth / 2' Drawable.TileHeight / 2);  					break;  			}
Magic Number,CNCMaps.Engine.Game,ObjectCollection,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\ObjectCollection.cs,InitDrawableDefaults,The following statement contains a magic number: switch (Type) {  				case CollectionType.Building:  				case CollectionType.Overlay:  				case CollectionType.Smudge:  					drawable.Props.Offset.Offset(Drawable.TileWidth / 2' 0);  					break;  				case CollectionType.Terrain:  				case CollectionType.Vehicle:  				case CollectionType.Infantry:  				case CollectionType.Aircraft:  				case CollectionType.Animation:  					drawable.Props.Offset.Offset(Drawable.TileWidth / 2' Drawable.TileHeight / 2);  					break;  			}
Magic Number,CNCMaps.Engine.Game,ObjectCollection,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\ObjectCollection.cs,LoadOverlayDrawable,The following statement contains a magic number: if (Engine >= EngineType.RedAlert2) {  				if (tibType != OverlayTibType.NotSpecial) {  					props.FrameDecider = FrameDeciders.OverlayValueFrameDecider;  					props.PaletteType = PaletteType.Overlay;  					props.LightingType = LightingType.None;  				}  				else if (SpecialOverlays.IsHighBridge(ovl)) {  					props.OffsetHack = OffsetHacks.RA2BridgeOffsets;  					props.ShadowOffsetHack = OffsetHacks.RA2BridgeShadowOffsets;  					drawable.TileElevation = 4; // for lighting  					drawable.Foundation = new Size(3' 1); // ensures they're drawn later --> fixes overlap  				}  			}  			else if (Engine <= EngineType.Firestorm) {  				if (tibType != OverlayTibType.NotSpecial) {  					props.FrameDecider = FrameDeciders.OverlayValueFrameDecider;  					props.PaletteType = PaletteType.Unit;  					props.LightingType = LightingType.None;  					drawable.IsRemapable = true;  				}  				else if (SpecialOverlays.IsHighBridge(ovl) || SpecialOverlays.IsTSHighRailsBridge(ovl)) {  					props.OffsetHack = OffsetHacks.TSBridgeOffsets;  					props.ShadowOffsetHack = OffsetHacks.TSBridgeShadowOffsets;  					drawable.TileElevation = 4; // for lighting  					//drawable.Foundation = new Size(3' 1); // ensures they're drawn later --> fixes overlap  				}  			}
Magic Number,CNCMaps.Engine.Game,ObjectCollection,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\ObjectCollection.cs,LoadOverlayDrawable,The following statement contains a magic number: if (Engine >= EngineType.RedAlert2) {  				if (tibType != OverlayTibType.NotSpecial) {  					props.FrameDecider = FrameDeciders.OverlayValueFrameDecider;  					props.PaletteType = PaletteType.Overlay;  					props.LightingType = LightingType.None;  				}  				else if (SpecialOverlays.IsHighBridge(ovl)) {  					props.OffsetHack = OffsetHacks.RA2BridgeOffsets;  					props.ShadowOffsetHack = OffsetHacks.RA2BridgeShadowOffsets;  					drawable.TileElevation = 4; // for lighting  					drawable.Foundation = new Size(3' 1); // ensures they're drawn later --> fixes overlap  				}  			}  			else if (Engine <= EngineType.Firestorm) {  				if (tibType != OverlayTibType.NotSpecial) {  					props.FrameDecider = FrameDeciders.OverlayValueFrameDecider;  					props.PaletteType = PaletteType.Unit;  					props.LightingType = LightingType.None;  					drawable.IsRemapable = true;  				}  				else if (SpecialOverlays.IsHighBridge(ovl) || SpecialOverlays.IsTSHighRailsBridge(ovl)) {  					props.OffsetHack = OffsetHacks.TSBridgeOffsets;  					props.ShadowOffsetHack = OffsetHacks.TSBridgeShadowOffsets;  					drawable.TileElevation = 4; // for lighting  					//drawable.Foundation = new Size(3' 1); // ensures they're drawn later --> fixes overlap  				}  			}
Magic Number,CNCMaps.Engine.Game,ObjectCollection,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\ObjectCollection.cs,LoadOverlayDrawable,The following statement contains a magic number: if (Engine >= EngineType.RedAlert2) {  				if (tibType != OverlayTibType.NotSpecial) {  					props.FrameDecider = FrameDeciders.OverlayValueFrameDecider;  					props.PaletteType = PaletteType.Overlay;  					props.LightingType = LightingType.None;  				}  				else if (SpecialOverlays.IsHighBridge(ovl)) {  					props.OffsetHack = OffsetHacks.RA2BridgeOffsets;  					props.ShadowOffsetHack = OffsetHacks.RA2BridgeShadowOffsets;  					drawable.TileElevation = 4; // for lighting  					drawable.Foundation = new Size(3' 1); // ensures they're drawn later --> fixes overlap  				}  			}  			else if (Engine <= EngineType.Firestorm) {  				if (tibType != OverlayTibType.NotSpecial) {  					props.FrameDecider = FrameDeciders.OverlayValueFrameDecider;  					props.PaletteType = PaletteType.Unit;  					props.LightingType = LightingType.None;  					drawable.IsRemapable = true;  				}  				else if (SpecialOverlays.IsHighBridge(ovl) || SpecialOverlays.IsTSHighRailsBridge(ovl)) {  					props.OffsetHack = OffsetHacks.TSBridgeOffsets;  					props.ShadowOffsetHack = OffsetHacks.TSBridgeShadowOffsets;  					drawable.TileElevation = 4; // for lighting  					//drawable.Foundation = new Size(3' 1); // ensures they're drawn later --> fixes overlap  				}  			}
Magic Number,CNCMaps.Engine.Game,SpecialOverlays,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\SpecialOverlays.cs,IsHighBridge,The following statement contains a magic number: return o.OverlayID == 24 || o.OverlayID == 25 || o.OverlayID == 238 || o.OverlayID == 237;
Magic Number,CNCMaps.Engine.Game,SpecialOverlays,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\SpecialOverlays.cs,IsHighBridge,The following statement contains a magic number: return o.OverlayID == 24 || o.OverlayID == 25 || o.OverlayID == 238 || o.OverlayID == 237;
Magic Number,CNCMaps.Engine.Game,SpecialOverlays,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\SpecialOverlays.cs,IsHighBridge,The following statement contains a magic number: return o.OverlayID == 24 || o.OverlayID == 25 || o.OverlayID == 238 || o.OverlayID == 237;
Magic Number,CNCMaps.Engine.Game,SpecialOverlays,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\SpecialOverlays.cs,IsHighBridge,The following statement contains a magic number: return o.OverlayID == 24 || o.OverlayID == 25 || o.OverlayID == 238 || o.OverlayID == 237;
Magic Number,CNCMaps.Engine.Game,SpecialOverlays,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\SpecialOverlays.cs,IsTSHighRailsBridge,The following statement contains a magic number: return o.OverlayID == 59 || o.OverlayID == 60;
Magic Number,CNCMaps.Engine.Game,SpecialOverlays,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\SpecialOverlays.cs,IsTSHighRailsBridge,The following statement contains a magic number: return o.OverlayID == 59 || o.OverlayID == 60;
Magic Number,CNCMaps.Engine.Game,AlphaDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\AlphaDrawable.cs,AlphaDrawable,The following statement contains a magic number: Props.Offset = new Point(0' 15);
Magic Number,CNCMaps.Engine.Game,AlphaDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\AlphaDrawable.cs,AlphaDrawable,The following statement contains a magic number: Props.Offset = new Point(0' 15);
Magic Number,CNCMaps.Engine.Game,AnimDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\AnimDrawable.cs,LoadFromRules,The following statement contains a magic number: TransLucency = Art.ReadBool("Translucent") ? 50 : Art.ReadInt("Translucency"' 0);
Magic Number,CNCMaps.Engine.Game,BuildingDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\BuildingDrawable.cs,LoadFromRules,The following statement contains a magic number: if (!foundation.Equals("custom"' StringComparison.InvariantCultureIgnoreCase)) {  				int fx = foundation[0] - '0';  				int fy = foundation[2] - '0';  				Foundation = new Size(fx' fy);  			}  			else {  				int fx = Art.ReadInt("Foundation.X"' 1);  				int fy = Art.ReadInt("Foundation.Y"' 1);  				Foundation = new Size(fx' fy);  			}
Magic Number,CNCMaps.Engine.Game,BuildingDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\BuildingDrawable.cs,LoadFromRules,The following statement contains a magic number: for (int i = 1; i <= 3; i++) {  				if (!Art.HasKey(String.Format("PowerUp{0}LocXX"' i))) break;  				_powerupSlots.Add(new PowerupSlot {  					X = Art.ReadInt(String.Format("PowerUp{0}LocXX"' i))'  					Y = Art.ReadInt(String.Format("PowerUp{0}LocYY"' i))'  					Z = Art.ReadInt(String.Format("PowerUp{0}LocZZ"' i))'  					YSort = Art.ReadInt(String.Format("PowerUp{0}LocYSort"' i))'  				});  			}
Magic Number,CNCMaps.Engine.Game,BuildingDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\BuildingDrawable.cs,Draw,The following statement contains a magic number: if (obj is StructureObject && (obj as StructureObject).Health < 128) {  				drawList.AddRange(_animsDamaged);  				drawList.AddRange(_fires);  			}  			else  				drawList.AddRange(_anims);
Magic Number,CNCMaps.Engine.Game,BuildingDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\BuildingDrawable.cs,Draw,The following statement contains a magic number: if (!strObj.Upgrade2.Equals("None"' StringComparison.InvariantCultureIgnoreCase) && _powerupSlots.Count >= 2) {  				var powerup = OwnerCollection.GetDrawable(strObj.Upgrade2);  				DrawPowerup(obj' powerup' 1' ds);  			}
Magic Number,CNCMaps.Engine.Game,BuildingDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\BuildingDrawable.cs,Draw,The following statement contains a magic number: if (!strObj.Upgrade3.Equals("None"' StringComparison.InvariantCultureIgnoreCase) && _powerupSlots.Count >= 3) {  				var powerup = OwnerCollection.GetDrawable(strObj.Upgrade3);  				DrawPowerup(obj' powerup' 2' ds);  			}
Magic Number,CNCMaps.Engine.Game,BuildingDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\BuildingDrawable.cs,Draw,The following statement contains a magic number: if (!strObj.Upgrade3.Equals("None"' StringComparison.InvariantCultureIgnoreCase) && _powerupSlots.Count >= 3) {  				var powerup = OwnerCollection.GetDrawable(strObj.Upgrade3);  				DrawPowerup(obj' powerup' 2' ds);  			}
Magic Number,CNCMaps.Engine.Game,ShpDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\ShpDrawable.cs,GetBounds,The following statement contains a magic number: bounds.Offset(obj.Tile.Dx * TileWidth / 2' (obj.Tile.Dy - obj.Tile.Z) * TileHeight / 2);
Magic Number,CNCMaps.Engine.Game,ShpDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\ShpDrawable.cs,GetBounds,The following statement contains a magic number: bounds.Offset(obj.Tile.Dx * TileWidth / 2' (obj.Tile.Dy - obj.Tile.Z) * TileHeight / 2);
Magic Number,CNCMaps.Engine.Game,UnitDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\UnitDrawable.cs,Draw,The following statement contains a magic number: if (obj is OwnableObject && (obj as OwnableObject).OnBridge)  				onBridgeOffset = new Size(0' -4 * TileHeight / 2);
Magic Number,CNCMaps.Engine.Game,UnitDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\UnitDrawable.cs,Draw,The following statement contains a magic number: if (obj is OwnableObject && (obj as OwnableObject).OnBridge)  				onBridgeOffset = new Size(0' -4 * TileHeight / 2);
Magic Number,CNCMaps.Engine.Game,UnitDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\UnitDrawable.cs,GetBounds,The following statement contains a magic number: if (obj is OwnableObject && (obj as OwnableObject).OnBridge)  				onBridgeOffset = new Point(0' -4 * TileHeight / 2);
Magic Number,CNCMaps.Engine.Game,UnitDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\UnitDrawable.cs,GetBounds,The following statement contains a magic number: if (obj is OwnableObject && (obj as OwnableObject).OnBridge)  				onBridgeOffset = new Point(0' -4 * TileHeight / 2);
Magic Number,CNCMaps.Engine.Game,VoxelDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\VoxelDrawable.cs,GetBounds,The following statement contains a magic number: bounds.Offset(obj.Tile.Dx * TileWidth / 2' (obj.Tile.Dy - obj.Tile.Z) * TileHeight / 2);
Magic Number,CNCMaps.Engine.Game,VoxelDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\VoxelDrawable.cs,GetBounds,The following statement contains a magic number: bounds.Offset(obj.Tile.Dx * TileWidth / 2' (obj.Tile.Dy - obj.Tile.Z) * TileHeight / 2);
Magic Number,CNCMaps.Engine.Game,VoxelDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\VoxelDrawable.cs,BlitVoxelToSurface,The following statement contains a magic number: Point d = new Point(obj.Tile.Dx * TileWidth / 2' (obj.Tile.Dy - obj.Tile.Z) * TileHeight / 2);
Magic Number,CNCMaps.Engine.Game,VoxelDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\VoxelDrawable.cs,BlitVoxelToSurface,The following statement contains a magic number: Point d = new Point(obj.Tile.Dx * TileWidth / 2' (obj.Tile.Dy - obj.Tile.Z) * TileHeight / 2);
Magic Number,CNCMaps.Engine.Game,VoxelDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\VoxelDrawable.cs,BlitVoxelToSurface,The following statement contains a magic number: d.Offset(-vxl_ds.BitmapData.Width / 2' -vxl_ds.BitmapData.Height / 2);
Magic Number,CNCMaps.Engine.Game,VoxelDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\VoxelDrawable.cs,BlitVoxelToSurface,The following statement contains a magic number: d.Offset(-vxl_ds.BitmapData.Width / 2' -vxl_ds.BitmapData.Height / 2);
Magic Number,CNCMaps.Engine.Game,VoxelDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\VoxelDrawable.cs,BlitVoxelToSurface,The following statement contains a magic number: for (int y = 0; y < vxl_ds.Height; y++) {  				byte* src_row = (byte*)vxl_ds.BitmapData.Scan0 + vxl_ds.BitmapData.Stride * (vxl_ds.Height - y - 1);  				byte* dst_row = ((byte*)ds.BitmapData.Scan0 + (d.Y + y) * ds.BitmapData.Stride + d.X * 3);  				int zIdx = (d.Y + y) * ds.Width + d.X;  				if (dst_row < w_low || dst_row >= w_high) continue;    				for (int x = 0; x < vxl_ds.Width; x++) {  					// only non-transparent pixels  					if (*(src_row + x * 4 + 3) > 0) {  						*(dst_row + x * 3) = *(src_row + x * 4);  						*(dst_row + x * 3 + 1) = *(src_row + x * 4 + 1);  						*(dst_row + x * 3 + 2) = *(src_row + x * 4 + 2);    						// if (y < firstRowTouched)  						// 	firstRowTouched = (short)y;    						short zBufVal = (short)((obj.Tile.Rx + obj.Tile.Ry + obj.Tile.Z) * TileHeight / 2);  						if (zBufVal >= zBuffer[zIdx])  							zBuffer[zIdx] = zBufVal;  					}  					// or shadows  					else if (shadowBufVxl[x + y * vxl_ds.Height]) {  						int shadIdx = (d.Y + y) * ds.Width + d.X + x;  						if (!shadowBuf[shadIdx]) {  							*(dst_row + x * 3) /= 2;  							*(dst_row + x * 3 + 1) /= 2;  							*(dst_row + x * 3 + 2) /= 2;  							shadowBuf[shadIdx] = true;  						}  					}  					zIdx++;  				}  			}
Magic Number,CNCMaps.Engine.Game,VoxelDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\VoxelDrawable.cs,BlitVoxelToSurface,The following statement contains a magic number: for (int y = 0; y < vxl_ds.Height; y++) {  				byte* src_row = (byte*)vxl_ds.BitmapData.Scan0 + vxl_ds.BitmapData.Stride * (vxl_ds.Height - y - 1);  				byte* dst_row = ((byte*)ds.BitmapData.Scan0 + (d.Y + y) * ds.BitmapData.Stride + d.X * 3);  				int zIdx = (d.Y + y) * ds.Width + d.X;  				if (dst_row < w_low || dst_row >= w_high) continue;    				for (int x = 0; x < vxl_ds.Width; x++) {  					// only non-transparent pixels  					if (*(src_row + x * 4 + 3) > 0) {  						*(dst_row + x * 3) = *(src_row + x * 4);  						*(dst_row + x * 3 + 1) = *(src_row + x * 4 + 1);  						*(dst_row + x * 3 + 2) = *(src_row + x * 4 + 2);    						// if (y < firstRowTouched)  						// 	firstRowTouched = (short)y;    						short zBufVal = (short)((obj.Tile.Rx + obj.Tile.Ry + obj.Tile.Z) * TileHeight / 2);  						if (zBufVal >= zBuffer[zIdx])  							zBuffer[zIdx] = zBufVal;  					}  					// or shadows  					else if (shadowBufVxl[x + y * vxl_ds.Height]) {  						int shadIdx = (d.Y + y) * ds.Width + d.X + x;  						if (!shadowBuf[shadIdx]) {  							*(dst_row + x * 3) /= 2;  							*(dst_row + x * 3 + 1) /= 2;  							*(dst_row + x * 3 + 2) /= 2;  							shadowBuf[shadIdx] = true;  						}  					}  					zIdx++;  				}  			}
Magic Number,CNCMaps.Engine.Game,VoxelDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\VoxelDrawable.cs,BlitVoxelToSurface,The following statement contains a magic number: for (int y = 0; y < vxl_ds.Height; y++) {  				byte* src_row = (byte*)vxl_ds.BitmapData.Scan0 + vxl_ds.BitmapData.Stride * (vxl_ds.Height - y - 1);  				byte* dst_row = ((byte*)ds.BitmapData.Scan0 + (d.Y + y) * ds.BitmapData.Stride + d.X * 3);  				int zIdx = (d.Y + y) * ds.Width + d.X;  				if (dst_row < w_low || dst_row >= w_high) continue;    				for (int x = 0; x < vxl_ds.Width; x++) {  					// only non-transparent pixels  					if (*(src_row + x * 4 + 3) > 0) {  						*(dst_row + x * 3) = *(src_row + x * 4);  						*(dst_row + x * 3 + 1) = *(src_row + x * 4 + 1);  						*(dst_row + x * 3 + 2) = *(src_row + x * 4 + 2);    						// if (y < firstRowTouched)  						// 	firstRowTouched = (short)y;    						short zBufVal = (short)((obj.Tile.Rx + obj.Tile.Ry + obj.Tile.Z) * TileHeight / 2);  						if (zBufVal >= zBuffer[zIdx])  							zBuffer[zIdx] = zBufVal;  					}  					// or shadows  					else if (shadowBufVxl[x + y * vxl_ds.Height]) {  						int shadIdx = (d.Y + y) * ds.Width + d.X + x;  						if (!shadowBuf[shadIdx]) {  							*(dst_row + x * 3) /= 2;  							*(dst_row + x * 3 + 1) /= 2;  							*(dst_row + x * 3 + 2) /= 2;  							shadowBuf[shadIdx] = true;  						}  					}  					zIdx++;  				}  			}
Magic Number,CNCMaps.Engine.Game,VoxelDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\VoxelDrawable.cs,BlitVoxelToSurface,The following statement contains a magic number: for (int y = 0; y < vxl_ds.Height; y++) {  				byte* src_row = (byte*)vxl_ds.BitmapData.Scan0 + vxl_ds.BitmapData.Stride * (vxl_ds.Height - y - 1);  				byte* dst_row = ((byte*)ds.BitmapData.Scan0 + (d.Y + y) * ds.BitmapData.Stride + d.X * 3);  				int zIdx = (d.Y + y) * ds.Width + d.X;  				if (dst_row < w_low || dst_row >= w_high) continue;    				for (int x = 0; x < vxl_ds.Width; x++) {  					// only non-transparent pixels  					if (*(src_row + x * 4 + 3) > 0) {  						*(dst_row + x * 3) = *(src_row + x * 4);  						*(dst_row + x * 3 + 1) = *(src_row + x * 4 + 1);  						*(dst_row + x * 3 + 2) = *(src_row + x * 4 + 2);    						// if (y < firstRowTouched)  						// 	firstRowTouched = (short)y;    						short zBufVal = (short)((obj.Tile.Rx + obj.Tile.Ry + obj.Tile.Z) * TileHeight / 2);  						if (zBufVal >= zBuffer[zIdx])  							zBuffer[zIdx] = zBufVal;  					}  					// or shadows  					else if (shadowBufVxl[x + y * vxl_ds.Height]) {  						int shadIdx = (d.Y + y) * ds.Width + d.X + x;  						if (!shadowBuf[shadIdx]) {  							*(dst_row + x * 3) /= 2;  							*(dst_row + x * 3 + 1) /= 2;  							*(dst_row + x * 3 + 2) /= 2;  							shadowBuf[shadIdx] = true;  						}  					}  					zIdx++;  				}  			}
Magic Number,CNCMaps.Engine.Game,VoxelDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\VoxelDrawable.cs,BlitVoxelToSurface,The following statement contains a magic number: for (int y = 0; y < vxl_ds.Height; y++) {  				byte* src_row = (byte*)vxl_ds.BitmapData.Scan0 + vxl_ds.BitmapData.Stride * (vxl_ds.Height - y - 1);  				byte* dst_row = ((byte*)ds.BitmapData.Scan0 + (d.Y + y) * ds.BitmapData.Stride + d.X * 3);  				int zIdx = (d.Y + y) * ds.Width + d.X;  				if (dst_row < w_low || dst_row >= w_high) continue;    				for (int x = 0; x < vxl_ds.Width; x++) {  					// only non-transparent pixels  					if (*(src_row + x * 4 + 3) > 0) {  						*(dst_row + x * 3) = *(src_row + x * 4);  						*(dst_row + x * 3 + 1) = *(src_row + x * 4 + 1);  						*(dst_row + x * 3 + 2) = *(src_row + x * 4 + 2);    						// if (y < firstRowTouched)  						// 	firstRowTouched = (short)y;    						short zBufVal = (short)((obj.Tile.Rx + obj.Tile.Ry + obj.Tile.Z) * TileHeight / 2);  						if (zBufVal >= zBuffer[zIdx])  							zBuffer[zIdx] = zBufVal;  					}  					// or shadows  					else if (shadowBufVxl[x + y * vxl_ds.Height]) {  						int shadIdx = (d.Y + y) * ds.Width + d.X + x;  						if (!shadowBuf[shadIdx]) {  							*(dst_row + x * 3) /= 2;  							*(dst_row + x * 3 + 1) /= 2;  							*(dst_row + x * 3 + 2) /= 2;  							shadowBuf[shadIdx] = true;  						}  					}  					zIdx++;  				}  			}
Magic Number,CNCMaps.Engine.Game,VoxelDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\VoxelDrawable.cs,BlitVoxelToSurface,The following statement contains a magic number: for (int y = 0; y < vxl_ds.Height; y++) {  				byte* src_row = (byte*)vxl_ds.BitmapData.Scan0 + vxl_ds.BitmapData.Stride * (vxl_ds.Height - y - 1);  				byte* dst_row = ((byte*)ds.BitmapData.Scan0 + (d.Y + y) * ds.BitmapData.Stride + d.X * 3);  				int zIdx = (d.Y + y) * ds.Width + d.X;  				if (dst_row < w_low || dst_row >= w_high) continue;    				for (int x = 0; x < vxl_ds.Width; x++) {  					// only non-transparent pixels  					if (*(src_row + x * 4 + 3) > 0) {  						*(dst_row + x * 3) = *(src_row + x * 4);  						*(dst_row + x * 3 + 1) = *(src_row + x * 4 + 1);  						*(dst_row + x * 3 + 2) = *(src_row + x * 4 + 2);    						// if (y < firstRowTouched)  						// 	firstRowTouched = (short)y;    						short zBufVal = (short)((obj.Tile.Rx + obj.Tile.Ry + obj.Tile.Z) * TileHeight / 2);  						if (zBufVal >= zBuffer[zIdx])  							zBuffer[zIdx] = zBufVal;  					}  					// or shadows  					else if (shadowBufVxl[x + y * vxl_ds.Height]) {  						int shadIdx = (d.Y + y) * ds.Width + d.X + x;  						if (!shadowBuf[shadIdx]) {  							*(dst_row + x * 3) /= 2;  							*(dst_row + x * 3 + 1) /= 2;  							*(dst_row + x * 3 + 2) /= 2;  							shadowBuf[shadIdx] = true;  						}  					}  					zIdx++;  				}  			}
Magic Number,CNCMaps.Engine.Game,VoxelDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\VoxelDrawable.cs,BlitVoxelToSurface,The following statement contains a magic number: for (int y = 0; y < vxl_ds.Height; y++) {  				byte* src_row = (byte*)vxl_ds.BitmapData.Scan0 + vxl_ds.BitmapData.Stride * (vxl_ds.Height - y - 1);  				byte* dst_row = ((byte*)ds.BitmapData.Scan0 + (d.Y + y) * ds.BitmapData.Stride + d.X * 3);  				int zIdx = (d.Y + y) * ds.Width + d.X;  				if (dst_row < w_low || dst_row >= w_high) continue;    				for (int x = 0; x < vxl_ds.Width; x++) {  					// only non-transparent pixels  					if (*(src_row + x * 4 + 3) > 0) {  						*(dst_row + x * 3) = *(src_row + x * 4);  						*(dst_row + x * 3 + 1) = *(src_row + x * 4 + 1);  						*(dst_row + x * 3 + 2) = *(src_row + x * 4 + 2);    						// if (y < firstRowTouched)  						// 	firstRowTouched = (short)y;    						short zBufVal = (short)((obj.Tile.Rx + obj.Tile.Ry + obj.Tile.Z) * TileHeight / 2);  						if (zBufVal >= zBuffer[zIdx])  							zBuffer[zIdx] = zBufVal;  					}  					// or shadows  					else if (shadowBufVxl[x + y * vxl_ds.Height]) {  						int shadIdx = (d.Y + y) * ds.Width + d.X + x;  						if (!shadowBuf[shadIdx]) {  							*(dst_row + x * 3) /= 2;  							*(dst_row + x * 3 + 1) /= 2;  							*(dst_row + x * 3 + 2) /= 2;  							shadowBuf[shadIdx] = true;  						}  					}  					zIdx++;  				}  			}
Magic Number,CNCMaps.Engine.Game,VoxelDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\VoxelDrawable.cs,BlitVoxelToSurface,The following statement contains a magic number: for (int y = 0; y < vxl_ds.Height; y++) {  				byte* src_row = (byte*)vxl_ds.BitmapData.Scan0 + vxl_ds.BitmapData.Stride * (vxl_ds.Height - y - 1);  				byte* dst_row = ((byte*)ds.BitmapData.Scan0 + (d.Y + y) * ds.BitmapData.Stride + d.X * 3);  				int zIdx = (d.Y + y) * ds.Width + d.X;  				if (dst_row < w_low || dst_row >= w_high) continue;    				for (int x = 0; x < vxl_ds.Width; x++) {  					// only non-transparent pixels  					if (*(src_row + x * 4 + 3) > 0) {  						*(dst_row + x * 3) = *(src_row + x * 4);  						*(dst_row + x * 3 + 1) = *(src_row + x * 4 + 1);  						*(dst_row + x * 3 + 2) = *(src_row + x * 4 + 2);    						// if (y < firstRowTouched)  						// 	firstRowTouched = (short)y;    						short zBufVal = (short)((obj.Tile.Rx + obj.Tile.Ry + obj.Tile.Z) * TileHeight / 2);  						if (zBufVal >= zBuffer[zIdx])  							zBuffer[zIdx] = zBufVal;  					}  					// or shadows  					else if (shadowBufVxl[x + y * vxl_ds.Height]) {  						int shadIdx = (d.Y + y) * ds.Width + d.X + x;  						if (!shadowBuf[shadIdx]) {  							*(dst_row + x * 3) /= 2;  							*(dst_row + x * 3 + 1) /= 2;  							*(dst_row + x * 3 + 2) /= 2;  							shadowBuf[shadIdx] = true;  						}  					}  					zIdx++;  				}  			}
Magic Number,CNCMaps.Engine.Game,VoxelDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\VoxelDrawable.cs,BlitVoxelToSurface,The following statement contains a magic number: for (int y = 0; y < vxl_ds.Height; y++) {  				byte* src_row = (byte*)vxl_ds.BitmapData.Scan0 + vxl_ds.BitmapData.Stride * (vxl_ds.Height - y - 1);  				byte* dst_row = ((byte*)ds.BitmapData.Scan0 + (d.Y + y) * ds.BitmapData.Stride + d.X * 3);  				int zIdx = (d.Y + y) * ds.Width + d.X;  				if (dst_row < w_low || dst_row >= w_high) continue;    				for (int x = 0; x < vxl_ds.Width; x++) {  					// only non-transparent pixels  					if (*(src_row + x * 4 + 3) > 0) {  						*(dst_row + x * 3) = *(src_row + x * 4);  						*(dst_row + x * 3 + 1) = *(src_row + x * 4 + 1);  						*(dst_row + x * 3 + 2) = *(src_row + x * 4 + 2);    						// if (y < firstRowTouched)  						// 	firstRowTouched = (short)y;    						short zBufVal = (short)((obj.Tile.Rx + obj.Tile.Ry + obj.Tile.Z) * TileHeight / 2);  						if (zBufVal >= zBuffer[zIdx])  							zBuffer[zIdx] = zBufVal;  					}  					// or shadows  					else if (shadowBufVxl[x + y * vxl_ds.Height]) {  						int shadIdx = (d.Y + y) * ds.Width + d.X + x;  						if (!shadowBuf[shadIdx]) {  							*(dst_row + x * 3) /= 2;  							*(dst_row + x * 3 + 1) /= 2;  							*(dst_row + x * 3 + 2) /= 2;  							shadowBuf[shadIdx] = true;  						}  					}  					zIdx++;  				}  			}
Magic Number,CNCMaps.Engine.Game,VoxelDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\VoxelDrawable.cs,BlitVoxelToSurface,The following statement contains a magic number: for (int y = 0; y < vxl_ds.Height; y++) {  				byte* src_row = (byte*)vxl_ds.BitmapData.Scan0 + vxl_ds.BitmapData.Stride * (vxl_ds.Height - y - 1);  				byte* dst_row = ((byte*)ds.BitmapData.Scan0 + (d.Y + y) * ds.BitmapData.Stride + d.X * 3);  				int zIdx = (d.Y + y) * ds.Width + d.X;  				if (dst_row < w_low || dst_row >= w_high) continue;    				for (int x = 0; x < vxl_ds.Width; x++) {  					// only non-transparent pixels  					if (*(src_row + x * 4 + 3) > 0) {  						*(dst_row + x * 3) = *(src_row + x * 4);  						*(dst_row + x * 3 + 1) = *(src_row + x * 4 + 1);  						*(dst_row + x * 3 + 2) = *(src_row + x * 4 + 2);    						// if (y < firstRowTouched)  						// 	firstRowTouched = (short)y;    						short zBufVal = (short)((obj.Tile.Rx + obj.Tile.Ry + obj.Tile.Z) * TileHeight / 2);  						if (zBufVal >= zBuffer[zIdx])  							zBuffer[zIdx] = zBufVal;  					}  					// or shadows  					else if (shadowBufVxl[x + y * vxl_ds.Height]) {  						int shadIdx = (d.Y + y) * ds.Width + d.X + x;  						if (!shadowBuf[shadIdx]) {  							*(dst_row + x * 3) /= 2;  							*(dst_row + x * 3 + 1) /= 2;  							*(dst_row + x * 3 + 2) /= 2;  							shadowBuf[shadIdx] = true;  						}  					}  					zIdx++;  				}  			}
Magic Number,CNCMaps.Engine.Game,VoxelDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\VoxelDrawable.cs,BlitVoxelToSurface,The following statement contains a magic number: for (int y = 0; y < vxl_ds.Height; y++) {  				byte* src_row = (byte*)vxl_ds.BitmapData.Scan0 + vxl_ds.BitmapData.Stride * (vxl_ds.Height - y - 1);  				byte* dst_row = ((byte*)ds.BitmapData.Scan0 + (d.Y + y) * ds.BitmapData.Stride + d.X * 3);  				int zIdx = (d.Y + y) * ds.Width + d.X;  				if (dst_row < w_low || dst_row >= w_high) continue;    				for (int x = 0; x < vxl_ds.Width; x++) {  					// only non-transparent pixels  					if (*(src_row + x * 4 + 3) > 0) {  						*(dst_row + x * 3) = *(src_row + x * 4);  						*(dst_row + x * 3 + 1) = *(src_row + x * 4 + 1);  						*(dst_row + x * 3 + 2) = *(src_row + x * 4 + 2);    						// if (y < firstRowTouched)  						// 	firstRowTouched = (short)y;    						short zBufVal = (short)((obj.Tile.Rx + obj.Tile.Ry + obj.Tile.Z) * TileHeight / 2);  						if (zBufVal >= zBuffer[zIdx])  							zBuffer[zIdx] = zBufVal;  					}  					// or shadows  					else if (shadowBufVxl[x + y * vxl_ds.Height]) {  						int shadIdx = (d.Y + y) * ds.Width + d.X + x;  						if (!shadowBuf[shadIdx]) {  							*(dst_row + x * 3) /= 2;  							*(dst_row + x * 3 + 1) /= 2;  							*(dst_row + x * 3 + 2) /= 2;  							shadowBuf[shadIdx] = true;  						}  					}  					zIdx++;  				}  			}
Magic Number,CNCMaps.Engine.Game,VoxelDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\VoxelDrawable.cs,BlitVoxelToSurface,The following statement contains a magic number: for (int y = 0; y < vxl_ds.Height; y++) {  				byte* src_row = (byte*)vxl_ds.BitmapData.Scan0 + vxl_ds.BitmapData.Stride * (vxl_ds.Height - y - 1);  				byte* dst_row = ((byte*)ds.BitmapData.Scan0 + (d.Y + y) * ds.BitmapData.Stride + d.X * 3);  				int zIdx = (d.Y + y) * ds.Width + d.X;  				if (dst_row < w_low || dst_row >= w_high) continue;    				for (int x = 0; x < vxl_ds.Width; x++) {  					// only non-transparent pixels  					if (*(src_row + x * 4 + 3) > 0) {  						*(dst_row + x * 3) = *(src_row + x * 4);  						*(dst_row + x * 3 + 1) = *(src_row + x * 4 + 1);  						*(dst_row + x * 3 + 2) = *(src_row + x * 4 + 2);    						// if (y < firstRowTouched)  						// 	firstRowTouched = (short)y;    						short zBufVal = (short)((obj.Tile.Rx + obj.Tile.Ry + obj.Tile.Z) * TileHeight / 2);  						if (zBufVal >= zBuffer[zIdx])  							zBuffer[zIdx] = zBufVal;  					}  					// or shadows  					else if (shadowBufVxl[x + y * vxl_ds.Height]) {  						int shadIdx = (d.Y + y) * ds.Width + d.X + x;  						if (!shadowBuf[shadIdx]) {  							*(dst_row + x * 3) /= 2;  							*(dst_row + x * 3 + 1) /= 2;  							*(dst_row + x * 3 + 2) /= 2;  							shadowBuf[shadIdx] = true;  						}  					}  					zIdx++;  				}  			}
Magic Number,CNCMaps.Engine.Game,VoxelDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\VoxelDrawable.cs,BlitVoxelToSurface,The following statement contains a magic number: for (int y = 0; y < vxl_ds.Height; y++) {  				byte* src_row = (byte*)vxl_ds.BitmapData.Scan0 + vxl_ds.BitmapData.Stride * (vxl_ds.Height - y - 1);  				byte* dst_row = ((byte*)ds.BitmapData.Scan0 + (d.Y + y) * ds.BitmapData.Stride + d.X * 3);  				int zIdx = (d.Y + y) * ds.Width + d.X;  				if (dst_row < w_low || dst_row >= w_high) continue;    				for (int x = 0; x < vxl_ds.Width; x++) {  					// only non-transparent pixels  					if (*(src_row + x * 4 + 3) > 0) {  						*(dst_row + x * 3) = *(src_row + x * 4);  						*(dst_row + x * 3 + 1) = *(src_row + x * 4 + 1);  						*(dst_row + x * 3 + 2) = *(src_row + x * 4 + 2);    						// if (y < firstRowTouched)  						// 	firstRowTouched = (short)y;    						short zBufVal = (short)((obj.Tile.Rx + obj.Tile.Ry + obj.Tile.Z) * TileHeight / 2);  						if (zBufVal >= zBuffer[zIdx])  							zBuffer[zIdx] = zBufVal;  					}  					// or shadows  					else if (shadowBufVxl[x + y * vxl_ds.Height]) {  						int shadIdx = (d.Y + y) * ds.Width + d.X + x;  						if (!shadowBuf[shadIdx]) {  							*(dst_row + x * 3) /= 2;  							*(dst_row + x * 3 + 1) /= 2;  							*(dst_row + x * 3 + 2) /= 2;  							shadowBuf[shadIdx] = true;  						}  					}  					zIdx++;  				}  			}
Magic Number,CNCMaps.Engine.Game,VoxelDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\VoxelDrawable.cs,BlitVoxelToSurface,The following statement contains a magic number: for (int y = 0; y < vxl_ds.Height; y++) {  				byte* src_row = (byte*)vxl_ds.BitmapData.Scan0 + vxl_ds.BitmapData.Stride * (vxl_ds.Height - y - 1);  				byte* dst_row = ((byte*)ds.BitmapData.Scan0 + (d.Y + y) * ds.BitmapData.Stride + d.X * 3);  				int zIdx = (d.Y + y) * ds.Width + d.X;  				if (dst_row < w_low || dst_row >= w_high) continue;    				for (int x = 0; x < vxl_ds.Width; x++) {  					// only non-transparent pixels  					if (*(src_row + x * 4 + 3) > 0) {  						*(dst_row + x * 3) = *(src_row + x * 4);  						*(dst_row + x * 3 + 1) = *(src_row + x * 4 + 1);  						*(dst_row + x * 3 + 2) = *(src_row + x * 4 + 2);    						// if (y < firstRowTouched)  						// 	firstRowTouched = (short)y;    						short zBufVal = (short)((obj.Tile.Rx + obj.Tile.Ry + obj.Tile.Z) * TileHeight / 2);  						if (zBufVal >= zBuffer[zIdx])  							zBuffer[zIdx] = zBufVal;  					}  					// or shadows  					else if (shadowBufVxl[x + y * vxl_ds.Height]) {  						int shadIdx = (d.Y + y) * ds.Width + d.X + x;  						if (!shadowBuf[shadIdx]) {  							*(dst_row + x * 3) /= 2;  							*(dst_row + x * 3 + 1) /= 2;  							*(dst_row + x * 3 + 2) /= 2;  							shadowBuf[shadIdx] = true;  						}  					}  					zIdx++;  				}  			}
Magic Number,CNCMaps.Engine.Game,VoxelDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\VoxelDrawable.cs,BlitVoxelToSurface,The following statement contains a magic number: for (int y = 0; y < vxl_ds.Height; y++) {  				byte* src_row = (byte*)vxl_ds.BitmapData.Scan0 + vxl_ds.BitmapData.Stride * (vxl_ds.Height - y - 1);  				byte* dst_row = ((byte*)ds.BitmapData.Scan0 + (d.Y + y) * ds.BitmapData.Stride + d.X * 3);  				int zIdx = (d.Y + y) * ds.Width + d.X;  				if (dst_row < w_low || dst_row >= w_high) continue;    				for (int x = 0; x < vxl_ds.Width; x++) {  					// only non-transparent pixels  					if (*(src_row + x * 4 + 3) > 0) {  						*(dst_row + x * 3) = *(src_row + x * 4);  						*(dst_row + x * 3 + 1) = *(src_row + x * 4 + 1);  						*(dst_row + x * 3 + 2) = *(src_row + x * 4 + 2);    						// if (y < firstRowTouched)  						// 	firstRowTouched = (short)y;    						short zBufVal = (short)((obj.Tile.Rx + obj.Tile.Ry + obj.Tile.Z) * TileHeight / 2);  						if (zBufVal >= zBuffer[zIdx])  							zBuffer[zIdx] = zBufVal;  					}  					// or shadows  					else if (shadowBufVxl[x + y * vxl_ds.Height]) {  						int shadIdx = (d.Y + y) * ds.Width + d.X + x;  						if (!shadowBuf[shadIdx]) {  							*(dst_row + x * 3) /= 2;  							*(dst_row + x * 3 + 1) /= 2;  							*(dst_row + x * 3 + 2) /= 2;  							shadowBuf[shadIdx] = true;  						}  					}  					zIdx++;  				}  			}
Magic Number,CNCMaps.Engine.Game,VoxelDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\VoxelDrawable.cs,BlitVoxelToSurface,The following statement contains a magic number: for (int y = 0; y < vxl_ds.Height; y++) {  				byte* src_row = (byte*)vxl_ds.BitmapData.Scan0 + vxl_ds.BitmapData.Stride * (vxl_ds.Height - y - 1);  				byte* dst_row = ((byte*)ds.BitmapData.Scan0 + (d.Y + y) * ds.BitmapData.Stride + d.X * 3);  				int zIdx = (d.Y + y) * ds.Width + d.X;  				if (dst_row < w_low || dst_row >= w_high) continue;    				for (int x = 0; x < vxl_ds.Width; x++) {  					// only non-transparent pixels  					if (*(src_row + x * 4 + 3) > 0) {  						*(dst_row + x * 3) = *(src_row + x * 4);  						*(dst_row + x * 3 + 1) = *(src_row + x * 4 + 1);  						*(dst_row + x * 3 + 2) = *(src_row + x * 4 + 2);    						// if (y < firstRowTouched)  						// 	firstRowTouched = (short)y;    						short zBufVal = (short)((obj.Tile.Rx + obj.Tile.Ry + obj.Tile.Z) * TileHeight / 2);  						if (zBufVal >= zBuffer[zIdx])  							zBuffer[zIdx] = zBufVal;  					}  					// or shadows  					else if (shadowBufVxl[x + y * vxl_ds.Height]) {  						int shadIdx = (d.Y + y) * ds.Width + d.X + x;  						if (!shadowBuf[shadIdx]) {  							*(dst_row + x * 3) /= 2;  							*(dst_row + x * 3 + 1) /= 2;  							*(dst_row + x * 3 + 2) /= 2;  							shadowBuf[shadIdx] = true;  						}  					}  					zIdx++;  				}  			}
Magic Number,CNCMaps.Engine.Game,VoxelDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\VoxelDrawable.cs,BlitVoxelToSurface,The following statement contains a magic number: for (int y = 0; y < vxl_ds.Height; y++) {  				byte* src_row = (byte*)vxl_ds.BitmapData.Scan0 + vxl_ds.BitmapData.Stride * (vxl_ds.Height - y - 1);  				byte* dst_row = ((byte*)ds.BitmapData.Scan0 + (d.Y + y) * ds.BitmapData.Stride + d.X * 3);  				int zIdx = (d.Y + y) * ds.Width + d.X;  				if (dst_row < w_low || dst_row >= w_high) continue;    				for (int x = 0; x < vxl_ds.Width; x++) {  					// only non-transparent pixels  					if (*(src_row + x * 4 + 3) > 0) {  						*(dst_row + x * 3) = *(src_row + x * 4);  						*(dst_row + x * 3 + 1) = *(src_row + x * 4 + 1);  						*(dst_row + x * 3 + 2) = *(src_row + x * 4 + 2);    						// if (y < firstRowTouched)  						// 	firstRowTouched = (short)y;    						short zBufVal = (short)((obj.Tile.Rx + obj.Tile.Ry + obj.Tile.Z) * TileHeight / 2);  						if (zBufVal >= zBuffer[zIdx])  							zBuffer[zIdx] = zBufVal;  					}  					// or shadows  					else if (shadowBufVxl[x + y * vxl_ds.Height]) {  						int shadIdx = (d.Y + y) * ds.Width + d.X + x;  						if (!shadowBuf[shadIdx]) {  							*(dst_row + x * 3) /= 2;  							*(dst_row + x * 3 + 1) /= 2;  							*(dst_row + x * 3 + 2) /= 2;  							shadowBuf[shadIdx] = true;  						}  					}  					zIdx++;  				}  			}
Magic Number,CNCMaps.Engine.Game,VoxelDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\VoxelDrawable.cs,BlitVoxelToSurface,The following statement contains a magic number: for (int y = 0; y < vxl_ds.Height; y++) {  				byte* src_row = (byte*)vxl_ds.BitmapData.Scan0 + vxl_ds.BitmapData.Stride * (vxl_ds.Height - y - 1);  				byte* dst_row = ((byte*)ds.BitmapData.Scan0 + (d.Y + y) * ds.BitmapData.Stride + d.X * 3);  				int zIdx = (d.Y + y) * ds.Width + d.X;  				if (dst_row < w_low || dst_row >= w_high) continue;    				for (int x = 0; x < vxl_ds.Width; x++) {  					// only non-transparent pixels  					if (*(src_row + x * 4 + 3) > 0) {  						*(dst_row + x * 3) = *(src_row + x * 4);  						*(dst_row + x * 3 + 1) = *(src_row + x * 4 + 1);  						*(dst_row + x * 3 + 2) = *(src_row + x * 4 + 2);    						// if (y < firstRowTouched)  						// 	firstRowTouched = (short)y;    						short zBufVal = (short)((obj.Tile.Rx + obj.Tile.Ry + obj.Tile.Z) * TileHeight / 2);  						if (zBufVal >= zBuffer[zIdx])  							zBuffer[zIdx] = zBufVal;  					}  					// or shadows  					else if (shadowBufVxl[x + y * vxl_ds.Height]) {  						int shadIdx = (d.Y + y) * ds.Width + d.X + x;  						if (!shadowBuf[shadIdx]) {  							*(dst_row + x * 3) /= 2;  							*(dst_row + x * 3 + 1) /= 2;  							*(dst_row + x * 3 + 2) /= 2;  							shadowBuf[shadIdx] = true;  						}  					}  					zIdx++;  				}  			}
Magic Number,CNCMaps.Engine.Game,VoxelDrawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\VoxelDrawable.cs,BlitVoxelToSurface,The following statement contains a magic number: for (int y = 0; y < vxl_ds.Height; y++) {  				byte* src_row = (byte*)vxl_ds.BitmapData.Scan0 + vxl_ds.BitmapData.Stride * (vxl_ds.Height - y - 1);  				byte* dst_row = ((byte*)ds.BitmapData.Scan0 + (d.Y + y) * ds.BitmapData.Stride + d.X * 3);  				int zIdx = (d.Y + y) * ds.Width + d.X;  				if (dst_row < w_low || dst_row >= w_high) continue;    				for (int x = 0; x < vxl_ds.Width; x++) {  					// only non-transparent pixels  					if (*(src_row + x * 4 + 3) > 0) {  						*(dst_row + x * 3) = *(src_row + x * 4);  						*(dst_row + x * 3 + 1) = *(src_row + x * 4 + 1);  						*(dst_row + x * 3 + 2) = *(src_row + x * 4 + 2);    						// if (y < firstRowTouched)  						// 	firstRowTouched = (short)y;    						short zBufVal = (short)((obj.Tile.Rx + obj.Tile.Ry + obj.Tile.Z) * TileHeight / 2);  						if (zBufVal >= zBuffer[zIdx])  							zBuffer[zIdx] = zBufVal;  					}  					// or shadows  					else if (shadowBufVxl[x + y * vxl_ds.Height]) {  						int shadIdx = (d.Y + y) * ds.Width + d.X + x;  						if (!shadowBuf[shadIdx]) {  							*(dst_row + x * 3) /= 2;  							*(dst_row + x * 3 + 1) /= 2;  							*(dst_row + x * 3 + 2) /= 2;  							shadowBuf[shadIdx] = true;  						}  					}  					zIdx++;  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,LoadAllObjects,The following statement contains a magic number: foreach (var iso in mf.Tiles)  				_tiles[iso.Dx' iso.Dy / 2] = new MapTile(iso.Dx' iso.Dy' iso.Rx' iso.Ry' iso.Z' iso.TileNum' iso.SubTile' _tiles);
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,SetBaseTiles,The following statement contains a magic number: foreach (GameObject obj in _unitObjects.Cast<GameObject>().Union(_aircraftObjects).Union(_infantryObjects)) {  				var bounds = obj.GetBounds();  				// bounds to foundation  				Size occupy = new Size(  					(int)Math.Max(1' Math.Ceiling(bounds.Width / (double)Drawable.TileWidth))'  					(int)Math.Max(1' Math.Ceiling(bounds.Height / (double)Drawable.TileHeight)));    				int bridge = (obj as OwnableObject).OnBridge ? -2 : 0;  				var top = _tiles.GetTileR(obj.Tile.Rx + bridge - 1 + occupy.Width' obj.Tile.Ry + bridge - 1 + occupy.Height);  				var bottom = _tiles.GetTileR(obj.Tile.Rx' obj.Tile.Ry);  				obj.BottomTile = bottom ?? obj.Tile;  				obj.TopTile = top ?? obj.Tile;  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,SetBaseTiles,The following statement contains a magic number: foreach (OverlayObject obj in _overlayObjects.Where(SpecialOverlays.IsHighBridge)) {  				var bottom = _tiles.GetTileR(obj.Tile.Rx + 2' obj.Tile.Ry + 2);  				obj.BottomTile = bottom ?? obj.Tile;  				obj.TopTile = obj.BottomTile;  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,SetBaseTiles,The following statement contains a magic number: foreach (OverlayObject obj in _overlayObjects.Where(SpecialOverlays.IsHighBridge)) {  				var bottom = _tiles.GetTileR(obj.Tile.Rx + 2' obj.Tile.Ry + 2);  				obj.BottomTile = bottom ?? obj.Tile;  				obj.TopTile = obj.BottomTile;  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,CreateLevelPalettes,The following statement contains a magic number: for (int i = 0; i < 19; i++) {  				Palette isoHeight = palettes.IsoPalette.Clone();  				isoHeight.ApplyLighting(_lighting' i);  				isoHeight.IsShared = true;  				isoHeight.Name = string.Format("{0} lvl.{1}"' isoHeight.Name' i);  				_palettePerLevel.Add(isoHeight);  				_palettesToBeRecalculated.Add(isoHeight);  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,MarkTiledStartPositions,The following statement contains a magic number: foreach (var w in _wayPoints.Where(w => w.Number < 8)) {  				// Draw 4x4 cell around start pos  				for (int x = w.Tile.Rx - 1; x < w.Tile.Rx + 3; x++) {  					for (int y = w.Tile.Ry - 1; y < w.Tile.Ry + 3; y++) {  						MapTile t = _tiles.GetTileR(x' y);  						if (t != null) {  							t.Palette = Palette.Merge(t.Palette' red' 0.4);  							//foreach (var o in t.AllObjects.OfType<SmudgeObject>().Cast<GameObject>().Union(t.AllObjects.OfType<OverlayObject>()))  							//	o.Palette = Palette.Merge(o.Palette' red' 0.4);  						}  					}  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,MarkTiledStartPositions,The following statement contains a magic number: foreach (var w in _wayPoints.Where(w => w.Number < 8)) {  				// Draw 4x4 cell around start pos  				for (int x = w.Tile.Rx - 1; x < w.Tile.Rx + 3; x++) {  					for (int y = w.Tile.Ry - 1; y < w.Tile.Ry + 3; y++) {  						MapTile t = _tiles.GetTileR(x' y);  						if (t != null) {  							t.Palette = Palette.Merge(t.Palette' red' 0.4);  							//foreach (var o in t.AllObjects.OfType<SmudgeObject>().Cast<GameObject>().Union(t.AllObjects.OfType<OverlayObject>()))  							//	o.Palette = Palette.Merge(o.Palette' red' 0.4);  						}  					}  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,MarkTiledStartPositions,The following statement contains a magic number: foreach (var w in _wayPoints.Where(w => w.Number < 8)) {  				// Draw 4x4 cell around start pos  				for (int x = w.Tile.Rx - 1; x < w.Tile.Rx + 3; x++) {  					for (int y = w.Tile.Ry - 1; y < w.Tile.Ry + 3; y++) {  						MapTile t = _tiles.GetTileR(x' y);  						if (t != null) {  							t.Palette = Palette.Merge(t.Palette' red' 0.4);  							//foreach (var o in t.AllObjects.OfType<SmudgeObject>().Cast<GameObject>().Union(t.AllObjects.OfType<OverlayObject>()))  							//	o.Palette = Palette.Merge(o.Palette' red' 0.4);  						}  					}  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,MarkTiledStartPositions,The following statement contains a magic number: foreach (var w in _wayPoints.Where(w => w.Number < 8)) {  				// Draw 4x4 cell around start pos  				for (int x = w.Tile.Rx - 1; x < w.Tile.Rx + 3; x++) {  					for (int y = w.Tile.Ry - 1; y < w.Tile.Ry + 3; y++) {  						MapTile t = _tiles.GetTileR(x' y);  						if (t != null) {  							t.Palette = Palette.Merge(t.Palette' red' 0.4);  							//foreach (var o in t.AllObjects.OfType<SmudgeObject>().Cast<GameObject>().Union(t.AllObjects.OfType<OverlayObject>()))  							//	o.Palette = Palette.Merge(o.Palette' red' 0.4);  						}  					}  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,UndrawTiledStartPositions,The following statement contains a magic number: foreach (var w in _wayPoints.Where(w => w.Tile != null)) {  				// Redraw the 4x4 cell around start pos with original palette;  				// first the tiles' then the objects  				for (int x = w.Tile.Rx - 2; x < w.Tile.Rx + 2; x++) {  					for (int y = w.Tile.Ry - 2; y < w.Tile.Ry + 2; y++) {  						MapTile t = _tiles.GetTileR(x' y);  						if (t == null) continue;  						t.Palette = _palettePerLevel[t.Z];  						// redraw tile  						_theater.Draw(t' _drawingSurface);  					}  				}  				for (int x = w.Tile.Rx - 5; x < w.Tile.Rx + 5; x++) {  					for (int y = w.Tile.Ry - 5; y < w.Tile.Ry + 5; y++) {  						MapTile t = _tiles.GetTileR(x' y);  						if (t == null) continue;  						// redraw objects on here  						List<GameObject> objs = GetObjectsAt(t.Dx' t.Dy / 2);  						foreach (GameObject o in objs)  							_theater.Draw(o' _drawingSurface);  					}  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,UndrawTiledStartPositions,The following statement contains a magic number: foreach (var w in _wayPoints.Where(w => w.Tile != null)) {  				// Redraw the 4x4 cell around start pos with original palette;  				// first the tiles' then the objects  				for (int x = w.Tile.Rx - 2; x < w.Tile.Rx + 2; x++) {  					for (int y = w.Tile.Ry - 2; y < w.Tile.Ry + 2; y++) {  						MapTile t = _tiles.GetTileR(x' y);  						if (t == null) continue;  						t.Palette = _palettePerLevel[t.Z];  						// redraw tile  						_theater.Draw(t' _drawingSurface);  					}  				}  				for (int x = w.Tile.Rx - 5; x < w.Tile.Rx + 5; x++) {  					for (int y = w.Tile.Ry - 5; y < w.Tile.Ry + 5; y++) {  						MapTile t = _tiles.GetTileR(x' y);  						if (t == null) continue;  						// redraw objects on here  						List<GameObject> objs = GetObjectsAt(t.Dx' t.Dy / 2);  						foreach (GameObject o in objs)  							_theater.Draw(o' _drawingSurface);  					}  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,UndrawTiledStartPositions,The following statement contains a magic number: foreach (var w in _wayPoints.Where(w => w.Tile != null)) {  				// Redraw the 4x4 cell around start pos with original palette;  				// first the tiles' then the objects  				for (int x = w.Tile.Rx - 2; x < w.Tile.Rx + 2; x++) {  					for (int y = w.Tile.Ry - 2; y < w.Tile.Ry + 2; y++) {  						MapTile t = _tiles.GetTileR(x' y);  						if (t == null) continue;  						t.Palette = _palettePerLevel[t.Z];  						// redraw tile  						_theater.Draw(t' _drawingSurface);  					}  				}  				for (int x = w.Tile.Rx - 5; x < w.Tile.Rx + 5; x++) {  					for (int y = w.Tile.Ry - 5; y < w.Tile.Ry + 5; y++) {  						MapTile t = _tiles.GetTileR(x' y);  						if (t == null) continue;  						// redraw objects on here  						List<GameObject> objs = GetObjectsAt(t.Dx' t.Dy / 2);  						foreach (GameObject o in objs)  							_theater.Draw(o' _drawingSurface);  					}  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,UndrawTiledStartPositions,The following statement contains a magic number: foreach (var w in _wayPoints.Where(w => w.Tile != null)) {  				// Redraw the 4x4 cell around start pos with original palette;  				// first the tiles' then the objects  				for (int x = w.Tile.Rx - 2; x < w.Tile.Rx + 2; x++) {  					for (int y = w.Tile.Ry - 2; y < w.Tile.Ry + 2; y++) {  						MapTile t = _tiles.GetTileR(x' y);  						if (t == null) continue;  						t.Palette = _palettePerLevel[t.Z];  						// redraw tile  						_theater.Draw(t' _drawingSurface);  					}  				}  				for (int x = w.Tile.Rx - 5; x < w.Tile.Rx + 5; x++) {  					for (int y = w.Tile.Ry - 5; y < w.Tile.Ry + 5; y++) {  						MapTile t = _tiles.GetTileR(x' y);  						if (t == null) continue;  						// redraw objects on here  						List<GameObject> objs = GetObjectsAt(t.Dx' t.Dy / 2);  						foreach (GameObject o in objs)  							_theater.Draw(o' _drawingSurface);  					}  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,UndrawTiledStartPositions,The following statement contains a magic number: foreach (var w in _wayPoints.Where(w => w.Tile != null)) {  				// Redraw the 4x4 cell around start pos with original palette;  				// first the tiles' then the objects  				for (int x = w.Tile.Rx - 2; x < w.Tile.Rx + 2; x++) {  					for (int y = w.Tile.Ry - 2; y < w.Tile.Ry + 2; y++) {  						MapTile t = _tiles.GetTileR(x' y);  						if (t == null) continue;  						t.Palette = _palettePerLevel[t.Z];  						// redraw tile  						_theater.Draw(t' _drawingSurface);  					}  				}  				for (int x = w.Tile.Rx - 5; x < w.Tile.Rx + 5; x++) {  					for (int y = w.Tile.Ry - 5; y < w.Tile.Ry + 5; y++) {  						MapTile t = _tiles.GetTileR(x' y);  						if (t == null) continue;  						// redraw objects on here  						List<GameObject> objs = GetObjectsAt(t.Dx' t.Dy / 2);  						foreach (GameObject o in objs)  							_theater.Draw(o' _drawingSurface);  					}  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,UndrawTiledStartPositions,The following statement contains a magic number: foreach (var w in _wayPoints.Where(w => w.Tile != null)) {  				// Redraw the 4x4 cell around start pos with original palette;  				// first the tiles' then the objects  				for (int x = w.Tile.Rx - 2; x < w.Tile.Rx + 2; x++) {  					for (int y = w.Tile.Ry - 2; y < w.Tile.Ry + 2; y++) {  						MapTile t = _tiles.GetTileR(x' y);  						if (t == null) continue;  						t.Palette = _palettePerLevel[t.Z];  						// redraw tile  						_theater.Draw(t' _drawingSurface);  					}  				}  				for (int x = w.Tile.Rx - 5; x < w.Tile.Rx + 5; x++) {  					for (int y = w.Tile.Ry - 5; y < w.Tile.Ry + 5; y++) {  						MapTile t = _tiles.GetTileR(x' y);  						if (t == null) continue;  						// redraw objects on here  						List<GameObject> objs = GetObjectsAt(t.Dx' t.Dy / 2);  						foreach (GameObject o in objs)  							_theater.Draw(o' _drawingSurface);  					}  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,UndrawTiledStartPositions,The following statement contains a magic number: foreach (var w in _wayPoints.Where(w => w.Tile != null)) {  				// Redraw the 4x4 cell around start pos with original palette;  				// first the tiles' then the objects  				for (int x = w.Tile.Rx - 2; x < w.Tile.Rx + 2; x++) {  					for (int y = w.Tile.Ry - 2; y < w.Tile.Ry + 2; y++) {  						MapTile t = _tiles.GetTileR(x' y);  						if (t == null) continue;  						t.Palette = _palettePerLevel[t.Z];  						// redraw tile  						_theater.Draw(t' _drawingSurface);  					}  				}  				for (int x = w.Tile.Rx - 5; x < w.Tile.Rx + 5; x++) {  					for (int y = w.Tile.Ry - 5; y < w.Tile.Ry + 5; y++) {  						MapTile t = _tiles.GetTileR(x' y);  						if (t == null) continue;  						// redraw objects on here  						List<GameObject> objs = GetObjectsAt(t.Dx' t.Dy / 2);  						foreach (GameObject o in objs)  							_theater.Draw(o' _drawingSurface);  					}  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,UndrawTiledStartPositions,The following statement contains a magic number: foreach (var w in _wayPoints.Where(w => w.Tile != null)) {  				// Redraw the 4x4 cell around start pos with original palette;  				// first the tiles' then the objects  				for (int x = w.Tile.Rx - 2; x < w.Tile.Rx + 2; x++) {  					for (int y = w.Tile.Ry - 2; y < w.Tile.Ry + 2; y++) {  						MapTile t = _tiles.GetTileR(x' y);  						if (t == null) continue;  						t.Palette = _palettePerLevel[t.Z];  						// redraw tile  						_theater.Draw(t' _drawingSurface);  					}  				}  				for (int x = w.Tile.Rx - 5; x < w.Tile.Rx + 5; x++) {  					for (int y = w.Tile.Ry - 5; y < w.Tile.Ry + 5; y++) {  						MapTile t = _tiles.GetTileR(x' y);  						if (t == null) continue;  						// redraw objects on here  						List<GameObject> objs = GetObjectsAt(t.Dx' t.Dy / 2);  						foreach (GameObject o in objs)  							_theater.Draw(o' _drawingSurface);  					}  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,UndrawTiledStartPositions,The following statement contains a magic number: foreach (var w in _wayPoints.Where(w => w.Tile != null)) {  				// Redraw the 4x4 cell around start pos with original palette;  				// first the tiles' then the objects  				for (int x = w.Tile.Rx - 2; x < w.Tile.Rx + 2; x++) {  					for (int y = w.Tile.Ry - 2; y < w.Tile.Ry + 2; y++) {  						MapTile t = _tiles.GetTileR(x' y);  						if (t == null) continue;  						t.Palette = _palettePerLevel[t.Z];  						// redraw tile  						_theater.Draw(t' _drawingSurface);  					}  				}  				for (int x = w.Tile.Rx - 5; x < w.Tile.Rx + 5; x++) {  					for (int y = w.Tile.Ry - 5; y < w.Tile.Ry + 5; y++) {  						MapTile t = _tiles.GetTileR(x' y);  						if (t == null) continue;  						// redraw objects on here  						List<GameObject> objs = GetObjectsAt(t.Dx' t.Dy / 2);  						foreach (GameObject o in objs)  							_theater.Draw(o' _drawingSurface);  					}  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,DrawStartMarkersBittah,The following statement contains a magic number: foreach (var w in _wayPoints.Where(w => w.Number < 8)) {  				var t = _tiles.GetTile(w.Tile);  				var center = new Point(t.Dx * Drawable.TileWidth / 2' (t.Dy - t.Z) * Drawable.TileHeight / 2);  				// project to preview dimensions  				double pctFullX = (center.X - fullImage.Left) / (double)fullImage.Width;  				double pctFullY = (center.Y - fullImage.Top) / (double)fullImage.Height;  				Point dest = new Point((int)(pctFullX * previewImage.Width)' (int)(pctFullY * previewImage.Height));  				var img = Resources.ResourceManager.GetObject("bittah_marker_" + (w.Number + 1)) as Image;  				if (img != null) {  					// center marker img  					dest.Offset(-img.Width / 2' -img.Height / 2);  					// draw it  					gfx.DrawImage(img' dest);  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,DrawStartMarkersBittah,The following statement contains a magic number: foreach (var w in _wayPoints.Where(w => w.Number < 8)) {  				var t = _tiles.GetTile(w.Tile);  				var center = new Point(t.Dx * Drawable.TileWidth / 2' (t.Dy - t.Z) * Drawable.TileHeight / 2);  				// project to preview dimensions  				double pctFullX = (center.X - fullImage.Left) / (double)fullImage.Width;  				double pctFullY = (center.Y - fullImage.Top) / (double)fullImage.Height;  				Point dest = new Point((int)(pctFullX * previewImage.Width)' (int)(pctFullY * previewImage.Height));  				var img = Resources.ResourceManager.GetObject("bittah_marker_" + (w.Number + 1)) as Image;  				if (img != null) {  					// center marker img  					dest.Offset(-img.Width / 2' -img.Height / 2);  					// draw it  					gfx.DrawImage(img' dest);  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,DrawStartMarkersBittah,The following statement contains a magic number: foreach (var w in _wayPoints.Where(w => w.Number < 8)) {  				var t = _tiles.GetTile(w.Tile);  				var center = new Point(t.Dx * Drawable.TileWidth / 2' (t.Dy - t.Z) * Drawable.TileHeight / 2);  				// project to preview dimensions  				double pctFullX = (center.X - fullImage.Left) / (double)fullImage.Width;  				double pctFullY = (center.Y - fullImage.Top) / (double)fullImage.Height;  				Point dest = new Point((int)(pctFullX * previewImage.Width)' (int)(pctFullY * previewImage.Height));  				var img = Resources.ResourceManager.GetObject("bittah_marker_" + (w.Number + 1)) as Image;  				if (img != null) {  					// center marker img  					dest.Offset(-img.Width / 2' -img.Height / 2);  					// draw it  					gfx.DrawImage(img' dest);  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,DrawStartMarkersBittah,The following statement contains a magic number: foreach (var w in _wayPoints.Where(w => w.Number < 8)) {  				var t = _tiles.GetTile(w.Tile);  				var center = new Point(t.Dx * Drawable.TileWidth / 2' (t.Dy - t.Z) * Drawable.TileHeight / 2);  				// project to preview dimensions  				double pctFullX = (center.X - fullImage.Left) / (double)fullImage.Width;  				double pctFullY = (center.Y - fullImage.Top) / (double)fullImage.Height;  				Point dest = new Point((int)(pctFullX * previewImage.Width)' (int)(pctFullY * previewImage.Height));  				var img = Resources.ResourceManager.GetObject("bittah_marker_" + (w.Number + 1)) as Image;  				if (img != null) {  					// center marker img  					dest.Offset(-img.Width / 2' -img.Height / 2);  					// draw it  					gfx.DrawImage(img' dest);  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,DrawStartMarkersBittah,The following statement contains a magic number: foreach (var w in _wayPoints.Where(w => w.Number < 8)) {  				var t = _tiles.GetTile(w.Tile);  				var center = new Point(t.Dx * Drawable.TileWidth / 2' (t.Dy - t.Z) * Drawable.TileHeight / 2);  				// project to preview dimensions  				double pctFullX = (center.X - fullImage.Left) / (double)fullImage.Width;  				double pctFullY = (center.Y - fullImage.Top) / (double)fullImage.Height;  				Point dest = new Point((int)(pctFullX * previewImage.Width)' (int)(pctFullY * previewImage.Height));  				var img = Resources.ResourceManager.GetObject("bittah_marker_" + (w.Number + 1)) as Image;  				if (img != null) {  					// center marker img  					dest.Offset(-img.Width / 2' -img.Height / 2);  					// draw it  					gfx.DrawImage(img' dest);  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,DrawStartMarkersAro,The following statement contains a magic number: foreach (var w in _wayPoints.Where(w => w.Number < 8)) {  				var center = TileLayer.GetTilePixelCenter(w.Tile);  				// project to preview dimensions  				double pctFullX = (center.X - fullImage.Left) / (double)previewImage.Width;  				double pctFullY = (center.Y - fullImage.Top) / (double)previewImage.Height;  				Point dest = new Point((int)(pctFullX * previewImage.Width)' (int)(pctFullY * previewImage.Height));  				var img = Resources.ResourceManager.GetObject("aro_marker_" + w) as Image;  				// center marker img  				dest.Offset(-img.Width / 2' -img.Height / 2);  				// draw it  				gfx.DrawImage(img' dest);  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,DrawStartMarkersAro,The following statement contains a magic number: foreach (var w in _wayPoints.Where(w => w.Number < 8)) {  				var center = TileLayer.GetTilePixelCenter(w.Tile);  				// project to preview dimensions  				double pctFullX = (center.X - fullImage.Left) / (double)previewImage.Width;  				double pctFullY = (center.Y - fullImage.Top) / (double)previewImage.Height;  				Point dest = new Point((int)(pctFullX * previewImage.Width)' (int)(pctFullY * previewImage.Height));  				var img = Resources.ResourceManager.GetObject("aro_marker_" + w) as Image;  				// center marker img  				dest.Offset(-img.Width / 2' -img.Height / 2);  				// draw it  				gfx.DrawImage(img' dest);  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,DrawStartMarkersAro,The following statement contains a magic number: foreach (var w in _wayPoints.Where(w => w.Number < 8)) {  				var center = TileLayer.GetTilePixelCenter(w.Tile);  				// project to preview dimensions  				double pctFullX = (center.X - fullImage.Left) / (double)previewImage.Width;  				double pctFullY = (center.Y - fullImage.Top) / (double)previewImage.Height;  				Point dest = new Point((int)(pctFullX * previewImage.Width)' (int)(pctFullY * previewImage.Height));  				var img = Resources.ResourceManager.GetObject("aro_marker_" + w) as Image;  				// center marker img  				dest.Offset(-img.Width / 2' -img.Height / 2);  				// draw it  				gfx.DrawImage(img' dest);  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,LoadColors,The following statement contains a magic number: foreach (var entry in colorsSection.OrderedEntries) {  				string[] colorComponents = ((string)entry.Value).Split(''');  				var h = new HsvColor(int.Parse(colorComponents[0])'  									int.Parse(colorComponents[1])'  									int.Parse(colorComponents[2]));  				_namedColors[entry.Key] = h.ToRGB();  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,DrawSquaredStartPositions,The following statement contains a magic number: foreach (var entry in _wayPoints) {  				try {  					if (entry.Number >= 8)  						continue;    					MapTile t = _tiles.GetTile(entry.Tile);  					if (t == null) continue;  					int destX = t.Dx * TileWidth / 2;  					int destY = (t.Dy - t.Z) * TileHeight / 2;    					bool vert = FullSize.Height * 2 > FullSize.Width;  					int radius;  					if (vert)  						radius = 10 * FullSize.Height * TileHeight / 2 / 144;  					else  						radius = 10 * FullSize.Width * TileWidth / 2 / 133;    					int h = radius' w = radius;  					for (int drawY = destY - h / 2; drawY < destY + h; drawY++) {  						for (int drawX = destX - w / 2; drawX < destX + w; drawX++) {  							byte* p = (byte*)_drawingSurface.BitmapData.Scan0 + drawY * _drawingSurface.BitmapData.Stride + 3 * drawX;  							*p++ = 0x00;  							*p++ = 0x00;  							*p++ = 0xFF;  						}  					}  				}  				catch (FormatException) {  				}  				catch (IndexOutOfRangeException) {  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,DrawSquaredStartPositions,The following statement contains a magic number: foreach (var entry in _wayPoints) {  				try {  					if (entry.Number >= 8)  						continue;    					MapTile t = _tiles.GetTile(entry.Tile);  					if (t == null) continue;  					int destX = t.Dx * TileWidth / 2;  					int destY = (t.Dy - t.Z) * TileHeight / 2;    					bool vert = FullSize.Height * 2 > FullSize.Width;  					int radius;  					if (vert)  						radius = 10 * FullSize.Height * TileHeight / 2 / 144;  					else  						radius = 10 * FullSize.Width * TileWidth / 2 / 133;    					int h = radius' w = radius;  					for (int drawY = destY - h / 2; drawY < destY + h; drawY++) {  						for (int drawX = destX - w / 2; drawX < destX + w; drawX++) {  							byte* p = (byte*)_drawingSurface.BitmapData.Scan0 + drawY * _drawingSurface.BitmapData.Stride + 3 * drawX;  							*p++ = 0x00;  							*p++ = 0x00;  							*p++ = 0xFF;  						}  					}  				}  				catch (FormatException) {  				}  				catch (IndexOutOfRangeException) {  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,DrawSquaredStartPositions,The following statement contains a magic number: foreach (var entry in _wayPoints) {  				try {  					if (entry.Number >= 8)  						continue;    					MapTile t = _tiles.GetTile(entry.Tile);  					if (t == null) continue;  					int destX = t.Dx * TileWidth / 2;  					int destY = (t.Dy - t.Z) * TileHeight / 2;    					bool vert = FullSize.Height * 2 > FullSize.Width;  					int radius;  					if (vert)  						radius = 10 * FullSize.Height * TileHeight / 2 / 144;  					else  						radius = 10 * FullSize.Width * TileWidth / 2 / 133;    					int h = radius' w = radius;  					for (int drawY = destY - h / 2; drawY < destY + h; drawY++) {  						for (int drawX = destX - w / 2; drawX < destX + w; drawX++) {  							byte* p = (byte*)_drawingSurface.BitmapData.Scan0 + drawY * _drawingSurface.BitmapData.Stride + 3 * drawX;  							*p++ = 0x00;  							*p++ = 0x00;  							*p++ = 0xFF;  						}  					}  				}  				catch (FormatException) {  				}  				catch (IndexOutOfRangeException) {  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,DrawSquaredStartPositions,The following statement contains a magic number: foreach (var entry in _wayPoints) {  				try {  					if (entry.Number >= 8)  						continue;    					MapTile t = _tiles.GetTile(entry.Tile);  					if (t == null) continue;  					int destX = t.Dx * TileWidth / 2;  					int destY = (t.Dy - t.Z) * TileHeight / 2;    					bool vert = FullSize.Height * 2 > FullSize.Width;  					int radius;  					if (vert)  						radius = 10 * FullSize.Height * TileHeight / 2 / 144;  					else  						radius = 10 * FullSize.Width * TileWidth / 2 / 133;    					int h = radius' w = radius;  					for (int drawY = destY - h / 2; drawY < destY + h; drawY++) {  						for (int drawX = destX - w / 2; drawX < destX + w; drawX++) {  							byte* p = (byte*)_drawingSurface.BitmapData.Scan0 + drawY * _drawingSurface.BitmapData.Stride + 3 * drawX;  							*p++ = 0x00;  							*p++ = 0x00;  							*p++ = 0xFF;  						}  					}  				}  				catch (FormatException) {  				}  				catch (IndexOutOfRangeException) {  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,DrawSquaredStartPositions,The following statement contains a magic number: foreach (var entry in _wayPoints) {  				try {  					if (entry.Number >= 8)  						continue;    					MapTile t = _tiles.GetTile(entry.Tile);  					if (t == null) continue;  					int destX = t.Dx * TileWidth / 2;  					int destY = (t.Dy - t.Z) * TileHeight / 2;    					bool vert = FullSize.Height * 2 > FullSize.Width;  					int radius;  					if (vert)  						radius = 10 * FullSize.Height * TileHeight / 2 / 144;  					else  						radius = 10 * FullSize.Width * TileWidth / 2 / 133;    					int h = radius' w = radius;  					for (int drawY = destY - h / 2; drawY < destY + h; drawY++) {  						for (int drawX = destX - w / 2; drawX < destX + w; drawX++) {  							byte* p = (byte*)_drawingSurface.BitmapData.Scan0 + drawY * _drawingSurface.BitmapData.Stride + 3 * drawX;  							*p++ = 0x00;  							*p++ = 0x00;  							*p++ = 0xFF;  						}  					}  				}  				catch (FormatException) {  				}  				catch (IndexOutOfRangeException) {  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,DrawSquaredStartPositions,The following statement contains a magic number: foreach (var entry in _wayPoints) {  				try {  					if (entry.Number >= 8)  						continue;    					MapTile t = _tiles.GetTile(entry.Tile);  					if (t == null) continue;  					int destX = t.Dx * TileWidth / 2;  					int destY = (t.Dy - t.Z) * TileHeight / 2;    					bool vert = FullSize.Height * 2 > FullSize.Width;  					int radius;  					if (vert)  						radius = 10 * FullSize.Height * TileHeight / 2 / 144;  					else  						radius = 10 * FullSize.Width * TileWidth / 2 / 133;    					int h = radius' w = radius;  					for (int drawY = destY - h / 2; drawY < destY + h; drawY++) {  						for (int drawX = destX - w / 2; drawX < destX + w; drawX++) {  							byte* p = (byte*)_drawingSurface.BitmapData.Scan0 + drawY * _drawingSurface.BitmapData.Stride + 3 * drawX;  							*p++ = 0x00;  							*p++ = 0x00;  							*p++ = 0xFF;  						}  					}  				}  				catch (FormatException) {  				}  				catch (IndexOutOfRangeException) {  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,DrawSquaredStartPositions,The following statement contains a magic number: foreach (var entry in _wayPoints) {  				try {  					if (entry.Number >= 8)  						continue;    					MapTile t = _tiles.GetTile(entry.Tile);  					if (t == null) continue;  					int destX = t.Dx * TileWidth / 2;  					int destY = (t.Dy - t.Z) * TileHeight / 2;    					bool vert = FullSize.Height * 2 > FullSize.Width;  					int radius;  					if (vert)  						radius = 10 * FullSize.Height * TileHeight / 2 / 144;  					else  						radius = 10 * FullSize.Width * TileWidth / 2 / 133;    					int h = radius' w = radius;  					for (int drawY = destY - h / 2; drawY < destY + h; drawY++) {  						for (int drawX = destX - w / 2; drawX < destX + w; drawX++) {  							byte* p = (byte*)_drawingSurface.BitmapData.Scan0 + drawY * _drawingSurface.BitmapData.Stride + 3 * drawX;  							*p++ = 0x00;  							*p++ = 0x00;  							*p++ = 0xFF;  						}  					}  				}  				catch (FormatException) {  				}  				catch (IndexOutOfRangeException) {  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,DrawSquaredStartPositions,The following statement contains a magic number: foreach (var entry in _wayPoints) {  				try {  					if (entry.Number >= 8)  						continue;    					MapTile t = _tiles.GetTile(entry.Tile);  					if (t == null) continue;  					int destX = t.Dx * TileWidth / 2;  					int destY = (t.Dy - t.Z) * TileHeight / 2;    					bool vert = FullSize.Height * 2 > FullSize.Width;  					int radius;  					if (vert)  						radius = 10 * FullSize.Height * TileHeight / 2 / 144;  					else  						radius = 10 * FullSize.Width * TileWidth / 2 / 133;    					int h = radius' w = radius;  					for (int drawY = destY - h / 2; drawY < destY + h; drawY++) {  						for (int drawX = destX - w / 2; drawX < destX + w; drawX++) {  							byte* p = (byte*)_drawingSurface.BitmapData.Scan0 + drawY * _drawingSurface.BitmapData.Stride + 3 * drawX;  							*p++ = 0x00;  							*p++ = 0x00;  							*p++ = 0xFF;  						}  					}  				}  				catch (FormatException) {  				}  				catch (IndexOutOfRangeException) {  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,DrawSquaredStartPositions,The following statement contains a magic number: foreach (var entry in _wayPoints) {  				try {  					if (entry.Number >= 8)  						continue;    					MapTile t = _tiles.GetTile(entry.Tile);  					if (t == null) continue;  					int destX = t.Dx * TileWidth / 2;  					int destY = (t.Dy - t.Z) * TileHeight / 2;    					bool vert = FullSize.Height * 2 > FullSize.Width;  					int radius;  					if (vert)  						radius = 10 * FullSize.Height * TileHeight / 2 / 144;  					else  						radius = 10 * FullSize.Width * TileWidth / 2 / 133;    					int h = radius' w = radius;  					for (int drawY = destY - h / 2; drawY < destY + h; drawY++) {  						for (int drawX = destX - w / 2; drawX < destX + w; drawX++) {  							byte* p = (byte*)_drawingSurface.BitmapData.Scan0 + drawY * _drawingSurface.BitmapData.Stride + 3 * drawX;  							*p++ = 0x00;  							*p++ = 0x00;  							*p++ = 0xFF;  						}  					}  				}  				catch (FormatException) {  				}  				catch (IndexOutOfRangeException) {  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,DrawSquaredStartPositions,The following statement contains a magic number: foreach (var entry in _wayPoints) {  				try {  					if (entry.Number >= 8)  						continue;    					MapTile t = _tiles.GetTile(entry.Tile);  					if (t == null) continue;  					int destX = t.Dx * TileWidth / 2;  					int destY = (t.Dy - t.Z) * TileHeight / 2;    					bool vert = FullSize.Height * 2 > FullSize.Width;  					int radius;  					if (vert)  						radius = 10 * FullSize.Height * TileHeight / 2 / 144;  					else  						radius = 10 * FullSize.Width * TileWidth / 2 / 133;    					int h = radius' w = radius;  					for (int drawY = destY - h / 2; drawY < destY + h; drawY++) {  						for (int drawX = destX - w / 2; drawX < destX + w; drawX++) {  							byte* p = (byte*)_drawingSurface.BitmapData.Scan0 + drawY * _drawingSurface.BitmapData.Stride + 3 * drawX;  							*p++ = 0x00;  							*p++ = 0x00;  							*p++ = 0xFF;  						}  					}  				}  				catch (FormatException) {  				}  				catch (IndexOutOfRangeException) {  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,DrawSquaredStartPositions,The following statement contains a magic number: foreach (var entry in _wayPoints) {  				try {  					if (entry.Number >= 8)  						continue;    					MapTile t = _tiles.GetTile(entry.Tile);  					if (t == null) continue;  					int destX = t.Dx * TileWidth / 2;  					int destY = (t.Dy - t.Z) * TileHeight / 2;    					bool vert = FullSize.Height * 2 > FullSize.Width;  					int radius;  					if (vert)  						radius = 10 * FullSize.Height * TileHeight / 2 / 144;  					else  						radius = 10 * FullSize.Width * TileWidth / 2 / 133;    					int h = radius' w = radius;  					for (int drawY = destY - h / 2; drawY < destY + h; drawY++) {  						for (int drawX = destX - w / 2; drawX < destX + w; drawX++) {  							byte* p = (byte*)_drawingSurface.BitmapData.Scan0 + drawY * _drawingSurface.BitmapData.Stride + 3 * drawX;  							*p++ = 0x00;  							*p++ = 0x00;  							*p++ = 0xFF;  						}  					}  				}  				catch (FormatException) {  				}  				catch (IndexOutOfRangeException) {  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,DrawSquaredStartPositions,The following statement contains a magic number: foreach (var entry in _wayPoints) {  				try {  					if (entry.Number >= 8)  						continue;    					MapTile t = _tiles.GetTile(entry.Tile);  					if (t == null) continue;  					int destX = t.Dx * TileWidth / 2;  					int destY = (t.Dy - t.Z) * TileHeight / 2;    					bool vert = FullSize.Height * 2 > FullSize.Width;  					int radius;  					if (vert)  						radius = 10 * FullSize.Height * TileHeight / 2 / 144;  					else  						radius = 10 * FullSize.Width * TileWidth / 2 / 133;    					int h = radius' w = radius;  					for (int drawY = destY - h / 2; drawY < destY + h; drawY++) {  						for (int drawX = destX - w / 2; drawX < destX + w; drawX++) {  							byte* p = (byte*)_drawingSurface.BitmapData.Scan0 + drawY * _drawingSurface.BitmapData.Stride + 3 * drawX;  							*p++ = 0x00;  							*p++ = 0x00;  							*p++ = 0xFF;  						}  					}  				}  				catch (FormatException) {  				}  				catch (IndexOutOfRangeException) {  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,DrawSquaredStartPositions,The following statement contains a magic number: foreach (var entry in _wayPoints) {  				try {  					if (entry.Number >= 8)  						continue;    					MapTile t = _tiles.GetTile(entry.Tile);  					if (t == null) continue;  					int destX = t.Dx * TileWidth / 2;  					int destY = (t.Dy - t.Z) * TileHeight / 2;    					bool vert = FullSize.Height * 2 > FullSize.Width;  					int radius;  					if (vert)  						radius = 10 * FullSize.Height * TileHeight / 2 / 144;  					else  						radius = 10 * FullSize.Width * TileWidth / 2 / 133;    					int h = radius' w = radius;  					for (int drawY = destY - h / 2; drawY < destY + h; drawY++) {  						for (int drawX = destX - w / 2; drawX < destX + w; drawX++) {  							byte* p = (byte*)_drawingSurface.BitmapData.Scan0 + drawY * _drawingSurface.BitmapData.Stride + 3 * drawX;  							*p++ = 0x00;  							*p++ = 0x00;  							*p++ = 0xFF;  						}  					}  				}  				catch (FormatException) {  				}  				catch (IndexOutOfRangeException) {  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,FindCutoffHeight,The following statement contains a magic number: for (y = FullSize.Height - 1; y > FullSize.Height - 10; y--) {  				bool isRowFilled = true;  				for (int x = 1; x < FullSize.Width * 2 - 3; x++) {  					if (_tiles.GridTouched[x' y] == TileLayer.TouchType.Untouched) {  						isRowFilled = false;  						break;  					}  				}  				if (isRowFilled)  					break;  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,FindCutoffHeight,The following statement contains a magic number: for (y = FullSize.Height - 1; y > FullSize.Height - 10; y--) {  				bool isRowFilled = true;  				for (int x = 1; x < FullSize.Width * 2 - 3; x++) {  					if (_tiles.GridTouched[x' y] == TileLayer.TouchType.Untouched) {  						isRowFilled = false;  						break;  					}  				}  				if (isRowFilled)  					break;  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,FindCutoffHeight,The following statement contains a magic number: for (y = FullSize.Height - 1; y > FullSize.Height - 10; y--) {  				bool isRowFilled = true;  				for (int x = 1; x < FullSize.Width * 2 - 3; x++) {  					if (_tiles.GridTouched[x' y] == TileLayer.TouchType.Untouched) {  						isRowFilled = false;  						break;  					}  				}  				if (isRowFilled)  					break;  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GetAutoSizePixels,The following statement contains a magic number: const double delta = 0.15;
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GetFullMapSizePixels,The following statement contains a magic number: int left = TileWidth / 2'  				top = TileHeight / 2;
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GetFullMapSizePixels,The following statement contains a magic number: int left = TileWidth / 2'  				top = TileHeight / 2;
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GetFullMapSizePixels,The following statement contains a magic number: int bottom = cutoff * TileHeight + (1 + (cutoff % 2)) * (TileHeight / 2);
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GetFullMapSizePixels,The following statement contains a magic number: int bottom = cutoff * TileHeight + (1 + (cutoff % 2)) * (TileHeight / 2);
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GetLocalSizePixels,The following statement contains a magic number: int left = Math.Max(LocalSize.Left * TileWidth' 0)'  				top = Math.Max(LocalSize.Top - 3' 0) * TileHeight + TileHeight / 2;
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GetLocalSizePixels,The following statement contains a magic number: int left = Math.Max(LocalSize.Left * TileWidth' 0)'  				top = Math.Max(LocalSize.Top - 3' 0) * TileHeight + TileHeight / 2;
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GetLocalSizePixels,The following statement contains a magic number: int bottom1 = 2 * (LocalSize.Top - 3 + LocalSize.Height + 5);
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GetLocalSizePixels,The following statement contains a magic number: int bottom1 = 2 * (LocalSize.Top - 3 + LocalSize.Height + 5);
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GetLocalSizePixels,The following statement contains a magic number: int bottom1 = 2 * (LocalSize.Top - 3 + LocalSize.Height + 5);
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GetLocalSizePixels,The following statement contains a magic number: int cutoff = FindCutoffHeight() * 2;
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GetLocalSizePixels,The following statement contains a magic number: int bottom2 = (cutoff + 1 + (cutoff % 2));
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GetLocalSizePixels,The following statement contains a magic number: int bottom = Math.Min(bottom1' bottom2) * (TileHeight / 2);
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,MarkOreAndGems,The following statement contains a magic number: foreach (var o in _overlayObjects) {  				if (o == null) continue;  				var ovlType = SpecialOverlays.GetOverlayTibType(o' Engine);  				if (!markerPalettes.ContainsKey(ovlType)) continue;    				double opacityBase = ovlType == OverlayTibType.Ore && Engine == EngineType.RedAlert2 ? 0.3 : 0.15;  				double opacity = Math.Max(0' 12 - o.OverlayValue) / 11.0 * 0.5 + opacityBase;  				o.Tile.Palette = Palette.Merge(o.Tile.Palette' markerPalettes[ovlType]' opacity);  				o.Palette = Palette.Merge(o.Palette' markerPalettes[ovlType]' opacity);  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,MarkOreAndGems,The following statement contains a magic number: foreach (var o in _overlayObjects) {  				if (o == null) continue;  				var ovlType = SpecialOverlays.GetOverlayTibType(o' Engine);  				if (!markerPalettes.ContainsKey(ovlType)) continue;    				double opacityBase = ovlType == OverlayTibType.Ore && Engine == EngineType.RedAlert2 ? 0.3 : 0.15;  				double opacity = Math.Max(0' 12 - o.OverlayValue) / 11.0 * 0.5 + opacityBase;  				o.Tile.Palette = Palette.Merge(o.Tile.Palette' markerPalettes[ovlType]' opacity);  				o.Palette = Palette.Merge(o.Palette' markerPalettes[ovlType]' opacity);  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,MarkOreAndGems,The following statement contains a magic number: foreach (var o in _overlayObjects) {  				if (o == null) continue;  				var ovlType = SpecialOverlays.GetOverlayTibType(o' Engine);  				if (!markerPalettes.ContainsKey(ovlType)) continue;    				double opacityBase = ovlType == OverlayTibType.Ore && Engine == EngineType.RedAlert2 ? 0.3 : 0.15;  				double opacity = Math.Max(0' 12 - o.OverlayValue) / 11.0 * 0.5 + opacityBase;  				o.Tile.Palette = Palette.Merge(o.Tile.Palette' markerPalettes[ovlType]' opacity);  				o.Palette = Palette.Merge(o.Palette' markerPalettes[ovlType]' opacity);  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,MarkOreAndGems,The following statement contains a magic number: foreach (var o in _overlayObjects) {  				if (o == null) continue;  				var ovlType = SpecialOverlays.GetOverlayTibType(o' Engine);  				if (!markerPalettes.ContainsKey(ovlType)) continue;    				double opacityBase = ovlType == OverlayTibType.Ore && Engine == EngineType.RedAlert2 ? 0.3 : 0.15;  				double opacity = Math.Max(0' 12 - o.OverlayValue) / 11.0 * 0.5 + opacityBase;  				o.Tile.Palette = Palette.Merge(o.Tile.Palette' markerPalettes[ovlType]' opacity);  				o.Palette = Palette.Merge(o.Palette' markerPalettes[ovlType]' opacity);  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,MarkOreAndGems,The following statement contains a magic number: foreach (var o in _overlayObjects) {  				if (o == null) continue;  				var ovlType = SpecialOverlays.GetOverlayTibType(o' Engine);  				if (!markerPalettes.ContainsKey(ovlType)) continue;    				double opacityBase = ovlType == OverlayTibType.Ore && Engine == EngineType.RedAlert2 ? 0.3 : 0.15;  				double opacity = Math.Max(0' 12 - o.OverlayValue) / 11.0 * 0.5 + opacityBase;  				o.Tile.Palette = Palette.Merge(o.Tile.Palette' markerPalettes[ovlType]' opacity);  				o.Palette = Palette.Merge(o.Palette' markerPalettes[ovlType]' opacity);  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,RedrawOreAndGems,The following statement contains a magic number: for (int y = 0; y < FullSize.Height; y++) {  				for (int x = FullSize.Width * 2 - 2; x >= 0; x -= 2) {  					if (_tiles[x' y].AllObjects.OfType<OverlayObject>().Any(checkFunc))  						_theater.Draw(_tiles.GetTile(x' y)' _drawingSurface);  				}  				for (int x = FullSize.Width * 2 - 3; x >= 0; x -= 2) {  					if (_tiles[x' y].AllObjects.OfType<OverlayObject>().Any(checkFunc))  						_theater.Draw(_tiles.GetTile(x' y)' _drawingSurface);  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,RedrawOreAndGems,The following statement contains a magic number: for (int y = 0; y < FullSize.Height; y++) {  				for (int x = FullSize.Width * 2 - 2; x >= 0; x -= 2) {  					if (_tiles[x' y].AllObjects.OfType<OverlayObject>().Any(checkFunc))  						_theater.Draw(_tiles.GetTile(x' y)' _drawingSurface);  				}  				for (int x = FullSize.Width * 2 - 3; x >= 0; x -= 2) {  					if (_tiles[x' y].AllObjects.OfType<OverlayObject>().Any(checkFunc))  						_theater.Draw(_tiles.GetTile(x' y)' _drawingSurface);  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,RedrawOreAndGems,The following statement contains a magic number: for (int y = 0; y < FullSize.Height; y++) {  				for (int x = FullSize.Width * 2 - 2; x >= 0; x -= 2) {  					if (_tiles[x' y].AllObjects.OfType<OverlayObject>().Any(checkFunc))  						_theater.Draw(_tiles.GetTile(x' y)' _drawingSurface);  				}  				for (int x = FullSize.Width * 2 - 3; x >= 0; x -= 2) {  					if (_tiles[x' y].AllObjects.OfType<OverlayObject>().Any(checkFunc))  						_theater.Draw(_tiles.GetTile(x' y)' _drawingSurface);  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,RedrawOreAndGems,The following statement contains a magic number: for (int y = 0; y < FullSize.Height; y++) {  				for (int x = FullSize.Width * 2 - 2; x >= 0; x -= 2) {  					if (_tiles[x' y].AllObjects.OfType<OverlayObject>().Any(checkFunc))  						_theater.Draw(_tiles.GetTile(x' y)' _drawingSurface);  				}  				for (int x = FullSize.Width * 2 - 3; x >= 0; x -= 2) {  					if (_tiles[x' y].AllObjects.OfType<OverlayObject>().Any(checkFunc))  						_theater.Draw(_tiles.GetTile(x' y)' _drawingSurface);  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,RedrawOreAndGems,The following statement contains a magic number: for (int y = 0; y < FullSize.Height; y++) {  				for (int x = FullSize.Width * 2 - 2; x >= 0; x -= 2) {  					if (_tiles[x' y].AllObjects.OfType<OverlayObject>().Any(checkFunc))  						_theater.Draw(_tiles.GetTile(x' y)' _drawingSurface);  				}  				for (int x = FullSize.Width * 2 - 3; x >= 0; x -= 2) {  					if (_tiles[x' y].AllObjects.OfType<OverlayObject>().Any(checkFunc))  						_theater.Draw(_tiles.GetTile(x' y)' _drawingSurface);  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,RedrawOreAndGems,The following statement contains a magic number: for (int y = 0; y < FullSize.Height; y++) {  				for (int x = FullSize.Width * 2 - 2; x >= 0; x -= 2) {  					if (_tiles[x' y].AllObjects.OfType<OverlayObject>().Any(checkFunc))  						_theater.Draw(_tiles.GetTile(x' y)' _drawingSurface);  				}  				for (int x = FullSize.Width * 2 - 3; x >= 0; x -= 2) {  					if (_tiles[x' y].AllObjects.OfType<OverlayObject>().Any(checkFunc))  						_theater.Draw(_tiles.GetTile(x' y)' _drawingSurface);  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,RedrawOreAndGems,The following statement contains a magic number: for (int y = 0; y < FullSize.Height; y++) {  				for (int x = FullSize.Width * 2 - 2; x >= 0; x -= 2) {  					if (_tiles[x' y].AllObjects.OfType<OverlayObject>().Any(checkFunc)) {  						List<GameObject> objs = GetObjectsAt(x' y);  						foreach (GameObject o in objs)  							_theater.Draw(o' _drawingSurface);  					}  				}  				for (int x = FullSize.Width * 2 - 3; x >= 0; x -= 2) {  					if (_tiles[x' y].AllObjects.OfType<OverlayObject>().Any(checkFunc)) {  						List<GameObject> objs = GetObjectsAt(x' y);  						foreach (GameObject o in objs)  							_theater.Draw(o' _drawingSurface);  					}  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,RedrawOreAndGems,The following statement contains a magic number: for (int y = 0; y < FullSize.Height; y++) {  				for (int x = FullSize.Width * 2 - 2; x >= 0; x -= 2) {  					if (_tiles[x' y].AllObjects.OfType<OverlayObject>().Any(checkFunc)) {  						List<GameObject> objs = GetObjectsAt(x' y);  						foreach (GameObject o in objs)  							_theater.Draw(o' _drawingSurface);  					}  				}  				for (int x = FullSize.Width * 2 - 3; x >= 0; x -= 2) {  					if (_tiles[x' y].AllObjects.OfType<OverlayObject>().Any(checkFunc)) {  						List<GameObject> objs = GetObjectsAt(x' y);  						foreach (GameObject o in objs)  							_theater.Draw(o' _drawingSurface);  					}  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,RedrawOreAndGems,The following statement contains a magic number: for (int y = 0; y < FullSize.Height; y++) {  				for (int x = FullSize.Width * 2 - 2; x >= 0; x -= 2) {  					if (_tiles[x' y].AllObjects.OfType<OverlayObject>().Any(checkFunc)) {  						List<GameObject> objs = GetObjectsAt(x' y);  						foreach (GameObject o in objs)  							_theater.Draw(o' _drawingSurface);  					}  				}  				for (int x = FullSize.Width * 2 - 3; x >= 0; x -= 2) {  					if (_tiles[x' y].AllObjects.OfType<OverlayObject>().Any(checkFunc)) {  						List<GameObject> objs = GetObjectsAt(x' y);  						foreach (GameObject o in objs)  							_theater.Draw(o' _drawingSurface);  					}  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,RedrawOreAndGems,The following statement contains a magic number: for (int y = 0; y < FullSize.Height; y++) {  				for (int x = FullSize.Width * 2 - 2; x >= 0; x -= 2) {  					if (_tiles[x' y].AllObjects.OfType<OverlayObject>().Any(checkFunc)) {  						List<GameObject> objs = GetObjectsAt(x' y);  						foreach (GameObject o in objs)  							_theater.Draw(o' _drawingSurface);  					}  				}  				for (int x = FullSize.Width * 2 - 3; x >= 0; x -= 2) {  					if (_tiles[x' y].AllObjects.OfType<OverlayObject>().Any(checkFunc)) {  						List<GameObject> objs = GetObjectsAt(x' y);  						foreach (GameObject o in objs)  							_theater.Draw(o' _drawingSurface);  					}  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,RedrawOreAndGems,The following statement contains a magic number: for (int y = 0; y < FullSize.Height; y++) {  				for (int x = FullSize.Width * 2 - 2; x >= 0; x -= 2) {  					if (_tiles[x' y].AllObjects.OfType<OverlayObject>().Any(checkFunc)) {  						List<GameObject> objs = GetObjectsAt(x' y);  						foreach (GameObject o in objs)  							_theater.Draw(o' _drawingSurface);  					}  				}  				for (int x = FullSize.Width * 2 - 3; x >= 0; x -= 2) {  					if (_tiles[x' y].AllObjects.OfType<OverlayObject>().Any(checkFunc)) {  						List<GameObject> objs = GetObjectsAt(x' y);  						foreach (GameObject o in objs)  							_theater.Draw(o' _drawingSurface);  					}  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,RedrawOreAndGems,The following statement contains a magic number: for (int y = 0; y < FullSize.Height; y++) {  				for (int x = FullSize.Width * 2 - 2; x >= 0; x -= 2) {  					if (_tiles[x' y].AllObjects.OfType<OverlayObject>().Any(checkFunc)) {  						List<GameObject> objs = GetObjectsAt(x' y);  						foreach (GameObject o in objs)  							_theater.Draw(o' _drawingSurface);  					}  				}  				for (int x = FullSize.Width * 2 - 3; x >= 0; x -= 2) {  					if (_tiles[x' y].AllObjects.OfType<OverlayObject>().Any(checkFunc)) {  						List<GameObject> objs = GetObjectsAt(x' y);  						foreach (GameObject o in objs)  							_theater.Draw(o' _drawingSurface);  					}  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,Draw,The following statement contains a magic number: for (int i = 0; i < orderedObjs.Count; i++) {  				var obj = orderedObjs[i];  				_theater.Draw(obj' _drawingSurface);  				double pct = 100.0 * i / orderedObjs.Count;  				if (pct > lastReported + 5) {  					Logger.Info("Drawing map... {0}%"' Math.Round(pct' 0));  					lastReported = pct;  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,Draw,The following statement contains a magic number: for (int i = 0; i < orderedObjs.Count; i++) {  				var obj = orderedObjs[i];  				_theater.Draw(obj' _drawingSurface);  				double pct = 100.0 * i / orderedObjs.Count;  				if (pct > lastReported + 5) {  					Logger.Info("Drawing map... {0}%"' Math.Round(pct' 0));  					lastReported = pct;  				}  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GeneratePreviewPack,The following statement contains a magic number: switch (Engine) {  			case EngineType.TiberianSun:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.Firestorm:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.RedAlert2:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.YurisRevenge:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * LocalSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 1.000 : 1.000) * LocalSize.Height);  				break;  			default:  				throw new ArgumentOutOfRangeException();  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GeneratePreviewPack,The following statement contains a magic number: switch (Engine) {  			case EngineType.TiberianSun:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.Firestorm:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.RedAlert2:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.YurisRevenge:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * LocalSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 1.000 : 1.000) * LocalSize.Height);  				break;  			default:  				throw new ArgumentOutOfRangeException();  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GeneratePreviewPack,The following statement contains a magic number: switch (Engine) {  			case EngineType.TiberianSun:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.Firestorm:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.RedAlert2:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.YurisRevenge:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * LocalSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 1.000 : 1.000) * LocalSize.Height);  				break;  			default:  				throw new ArgumentOutOfRangeException();  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GeneratePreviewPack,The following statement contains a magic number: switch (Engine) {  			case EngineType.TiberianSun:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.Firestorm:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.RedAlert2:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.YurisRevenge:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * LocalSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 1.000 : 1.000) * LocalSize.Height);  				break;  			default:  				throw new ArgumentOutOfRangeException();  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GeneratePreviewPack,The following statement contains a magic number: switch (Engine) {  			case EngineType.TiberianSun:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.Firestorm:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.RedAlert2:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.YurisRevenge:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * LocalSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 1.000 : 1.000) * LocalSize.Height);  				break;  			default:  				throw new ArgumentOutOfRangeException();  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GeneratePreviewPack,The following statement contains a magic number: switch (Engine) {  			case EngineType.TiberianSun:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.Firestorm:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.RedAlert2:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.YurisRevenge:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * LocalSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 1.000 : 1.000) * LocalSize.Height);  				break;  			default:  				throw new ArgumentOutOfRangeException();  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GeneratePreviewPack,The following statement contains a magic number: switch (Engine) {  			case EngineType.TiberianSun:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.Firestorm:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.RedAlert2:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.YurisRevenge:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * LocalSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 1.000 : 1.000) * LocalSize.Height);  				break;  			default:  				throw new ArgumentOutOfRangeException();  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GeneratePreviewPack,The following statement contains a magic number: switch (Engine) {  			case EngineType.TiberianSun:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.Firestorm:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.RedAlert2:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.YurisRevenge:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * LocalSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 1.000 : 1.000) * LocalSize.Height);  				break;  			default:  				throw new ArgumentOutOfRangeException();  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GeneratePreviewPack,The following statement contains a magic number: switch (Engine) {  			case EngineType.TiberianSun:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.Firestorm:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.RedAlert2:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.YurisRevenge:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * LocalSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 1.000 : 1.000) * LocalSize.Height);  				break;  			default:  				throw new ArgumentOutOfRangeException();  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GeneratePreviewPack,The following statement contains a magic number: switch (Engine) {  			case EngineType.TiberianSun:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.Firestorm:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.RedAlert2:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.YurisRevenge:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * LocalSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 1.000 : 1.000) * LocalSize.Height);  				break;  			default:  				throw new ArgumentOutOfRangeException();  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GeneratePreviewPack,The following statement contains a magic number: switch (Engine) {  			case EngineType.TiberianSun:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.Firestorm:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.RedAlert2:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * FullSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 0.995 : 1.000) * FullSize.Height);  				break;  			case EngineType.YurisRevenge:  				pw = (int)Math.Ceiling((fixDimensions ? 1.975 : 2.000) * LocalSize.Width);  				ph = (int)Math.Ceiling((fixDimensions ? 1.000 : 1.000) * LocalSize.Height);  				break;  			default:  				throw new ArgumentOutOfRangeException();  			}
Magic Number,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,DebugDrawTile,The following statement contains a magic number: foreach (GameObject o in GetObjectsAt(tile.Dx' tile.Dy / 2))  				_theater.Draw(o' _drawingSurface);
Magic Number,CNCMaps.Engine.Map,LightSource,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\GameObjects.cs,Initialize,The following statement contains a magic number: LightVisibility = lamp.ReadDouble("LightVisibility"' 5000.0);
Magic Number,CNCMaps.Engine.Map,LightSource,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\GameObjects.cs,ApplyLamp,The following statement contains a magic number: const double TOLERANCE = 0.001;
Magic Number,CNCMaps.Engine.Map,LightSource,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\GameObjects.cs,ApplyLamp,The following statement contains a magic number: if ((0 < lamp.LightVisibility) && (distance < lamp.LightVisibility / 256)) {  				double lsEffect = (lamp.LightVisibility - 256 * distance) / lamp.LightVisibility;    				// we don't want to apply lamps to shared palettes' so clone first  				if (obj.Palette.IsShared)  					obj.Palette = obj.Palette.Clone();    				obj.Palette.ApplyLamp(lamp' lsEffect' ambientOnly);  				return true;  			}  			else  				return false;
Magic Number,CNCMaps.Engine.Map,LightSource,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\GameObjects.cs,ApplyLamp,The following statement contains a magic number: if ((0 < lamp.LightVisibility) && (distance < lamp.LightVisibility / 256)) {  				double lsEffect = (lamp.LightVisibility - 256 * distance) / lamp.LightVisibility;    				// we don't want to apply lamps to shared palettes' so clone first  				if (obj.Palette.IsShared)  					obj.Palette = obj.Palette.Clone();    				obj.Palette.ApplyLamp(lamp' lsEffect' ambientOnly);  				return true;  			}  			else  				return false;
Magic Number,CNCMaps.Engine.Map,ObjectSorter,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ObjectSorter.cs,GetOrderedObjects,The following statement contains a magic number: for (int y = 0; y < _map.Height; y++) {  				for (int x = _map.Width*2 - 2; x >= 0; x -= 2)  					ProcessTile(_map[x' y]);  				for (int x = _map.Width*2 - 3; x >= 0; x -= 2)  					ProcessTile(_map[x' y]);  			}
Magic Number,CNCMaps.Engine.Map,ObjectSorter,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ObjectSorter.cs,GetOrderedObjects,The following statement contains a magic number: for (int y = 0; y < _map.Height; y++) {  				for (int x = _map.Width*2 - 2; x >= 0; x -= 2)  					ProcessTile(_map[x' y]);  				for (int x = _map.Width*2 - 3; x >= 0; x -= 2)  					ProcessTile(_map[x' y]);  			}
Magic Number,CNCMaps.Engine.Map,ObjectSorter,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ObjectSorter.cs,GetOrderedObjects,The following statement contains a magic number: for (int y = 0; y < _map.Height; y++) {  				for (int x = _map.Width*2 - 2; x >= 0; x -= 2)  					ProcessTile(_map[x' y]);  				for (int x = _map.Width*2 - 3; x >= 0; x -= 2)  					ProcessTile(_map[x' y]);  			}
Magic Number,CNCMaps.Engine.Map,ObjectSorter,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ObjectSorter.cs,GetOrderedObjects,The following statement contains a magic number: for (int y = 0; y < _map.Height; y++) {  				for (int x = _map.Width*2 - 2; x >= 0; x -= 2)  					ProcessTile(_map[x' y]);  				for (int x = _map.Width*2 - 3; x >= 0; x -= 2)  					ProcessTile(_map[x' y]);  			}
Magic Number,CNCMaps.Engine.Map,ObjectSorter,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ObjectSorter.cs,GetOrderedObjects,The following statement contains a magic number: for (int y = 0; y < _map.Height; y++) {  				for (int x = _map.Width*2 - 2; x >= 0; x -= 2)  					ProcessTile(_map[x' y]);  				for (int x = _map.Width*2 - 3; x >= 0; x -= 2)  					ProcessTile(_map[x' y]);  			}
Magic Number,CNCMaps.Engine.Map,ObjectSorter,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ObjectSorter.cs,GetOrderedObjects,The following statement contains a magic number: for (int y = 0; y < _map.Height; y++) {  				for (int x = _map.Width*2 - 2; x >= 0; x -= 2)  					ProcessTile(_map[x' y]);  				for (int x = _map.Width*2 - 3; x >= 0; x -= 2)  					ProcessTile(_map[x' y]);  			}
Magic Number,CNCMaps.Engine.Map,ObjectSorter,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ObjectSorter.cs,ExamineNeighbourhood,The following statement contains a magic number: for (int y = tileTL.Dy - 3; y <= tileBR.Dy + 3; y++) {  				for (int x = tileTL.Dx - 3; x <= tileBR.Dx + 3; x += 2) {  					if ((x + (y + obj.TopTile.Dy)) < 0 || y < 0) continue;  					var tile2 = _map[x + (y + obj.TopTile.Dy)%2' y/2];  					if (tile2 == null) continue;    					// Debug.WriteLine("neighhourhood tile " + tile2 + " of obj " + obj + " at " + obj.Tile);  					ExamineObjects(obj' tile2);  					foreach (var obj2 in tile2.AllObjects)  						ExamineObjects(obj' obj2);  				}  			}
Magic Number,CNCMaps.Engine.Map,ObjectSorter,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ObjectSorter.cs,ExamineNeighbourhood,The following statement contains a magic number: for (int y = tileTL.Dy - 3; y <= tileBR.Dy + 3; y++) {  				for (int x = tileTL.Dx - 3; x <= tileBR.Dx + 3; x += 2) {  					if ((x + (y + obj.TopTile.Dy)) < 0 || y < 0) continue;  					var tile2 = _map[x + (y + obj.TopTile.Dy)%2' y/2];  					if (tile2 == null) continue;    					// Debug.WriteLine("neighhourhood tile " + tile2 + " of obj " + obj + " at " + obj.Tile);  					ExamineObjects(obj' tile2);  					foreach (var obj2 in tile2.AllObjects)  						ExamineObjects(obj' obj2);  				}  			}
Magic Number,CNCMaps.Engine.Map,ObjectSorter,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ObjectSorter.cs,ExamineNeighbourhood,The following statement contains a magic number: for (int y = tileTL.Dy - 3; y <= tileBR.Dy + 3; y++) {  				for (int x = tileTL.Dx - 3; x <= tileBR.Dx + 3; x += 2) {  					if ((x + (y + obj.TopTile.Dy)) < 0 || y < 0) continue;  					var tile2 = _map[x + (y + obj.TopTile.Dy)%2' y/2];  					if (tile2 == null) continue;    					// Debug.WriteLine("neighhourhood tile " + tile2 + " of obj " + obj + " at " + obj.Tile);  					ExamineObjects(obj' tile2);  					foreach (var obj2 in tile2.AllObjects)  						ExamineObjects(obj' obj2);  				}  			}
Magic Number,CNCMaps.Engine.Map,ObjectSorter,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ObjectSorter.cs,ExamineNeighbourhood,The following statement contains a magic number: for (int y = tileTL.Dy - 3; y <= tileBR.Dy + 3; y++) {  				for (int x = tileTL.Dx - 3; x <= tileBR.Dx + 3; x += 2) {  					if ((x + (y + obj.TopTile.Dy)) < 0 || y < 0) continue;  					var tile2 = _map[x + (y + obj.TopTile.Dy)%2' y/2];  					if (tile2 == null) continue;    					// Debug.WriteLine("neighhourhood tile " + tile2 + " of obj " + obj + " at " + obj.Tile);  					ExamineObjects(obj' tile2);  					foreach (var obj2 in tile2.AllObjects)  						ExamineObjects(obj' obj2);  				}  			}
Magic Number,CNCMaps.Engine.Map,ObjectSorter,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ObjectSorter.cs,ExamineNeighbourhood,The following statement contains a magic number: for (int y = tileTL.Dy - 3; y <= tileBR.Dy + 3; y++) {  				for (int x = tileTL.Dx - 3; x <= tileBR.Dx + 3; x += 2) {  					if ((x + (y + obj.TopTile.Dy)) < 0 || y < 0) continue;  					var tile2 = _map[x + (y + obj.TopTile.Dy)%2' y/2];  					if (tile2 == null) continue;    					// Debug.WriteLine("neighhourhood tile " + tile2 + " of obj " + obj + " at " + obj.Tile);  					ExamineObjects(obj' tile2);  					foreach (var obj2 in tile2.AllObjects)  						ExamineObjects(obj' obj2);  				}  			}
Magic Number,CNCMaps.Engine.Map,ObjectSorter,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ObjectSorter.cs,ExamineNeighbourhood,The following statement contains a magic number: for (int y = tileTL.Dy - 3; y <= tileBR.Dy + 3; y++) {  				for (int x = tileTL.Dx - 3; x <= tileBR.Dx + 3; x += 2) {  					if ((x + (y + obj.TopTile.Dy)) < 0 || y < 0) continue;  					var tile2 = _map[x + (y + obj.TopTile.Dy)%2' y/2];  					if (tile2 == null) continue;    					// Debug.WriteLine("neighhourhood tile " + tile2 + " of obj " + obj + " at " + obj.Tile);  					ExamineObjects(obj' tile2);  					foreach (var obj2 in tile2.AllObjects)  						ExamineObjects(obj' obj2);  				}  			}
Magic Number,CNCMaps.Engine.Map,ObjectSorter,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ObjectSorter.cs,ExamineNeighbourhood,The following statement contains a magic number: for (int y = tileTL.Dy - 3; y <= tileBR.Dy + 3; y++) {  				for (int x = tileTL.Dx - 3; x <= tileBR.Dx + 3; x += 2) {  					if ((x + (y + obj.TopTile.Dy)) < 0 || y < 0) continue;  					var tile2 = _map[x + (y + obj.TopTile.Dy)%2' y/2];  					if (tile2 == null) continue;    					// Debug.WriteLine("neighhourhood tile " + tile2 + " of obj " + obj + " at " + obj.Tile);  					ExamineObjects(obj' tile2);  					foreach (var obj2 in tile2.AllObjects)  						ExamineObjects(obj' obj2);  				}  			}
Magic Number,CNCMaps.Engine.Map,ObjectSorter,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ObjectSorter.cs,GetFrontBlock,The following statement contains a magic number: var priorities = new Dictionary<Type' int> {                  {typeof(MapTile)' 0}'                  {typeof(SmudgeObject)' 1}'                  {typeof(OverlayObject)' 2}'                  {typeof(TerrainObject)' 3}'                  {typeof(StructureObject)' 3}'                  {typeof(AnimationObject)' 3}'                  {typeof(UnitObject)' 3}'                  {typeof(InfantryObject)' 3}'                  {typeof(AircraftObject)' 4}'              };
Magic Number,CNCMaps.Engine.Map,ObjectSorter,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ObjectSorter.cs,GetFrontBlock,The following statement contains a magic number: var priorities = new Dictionary<Type' int> {                  {typeof(MapTile)' 0}'                  {typeof(SmudgeObject)' 1}'                  {typeof(OverlayObject)' 2}'                  {typeof(TerrainObject)' 3}'                  {typeof(StructureObject)' 3}'                  {typeof(AnimationObject)' 3}'                  {typeof(UnitObject)' 3}'                  {typeof(InfantryObject)' 3}'                  {typeof(AircraftObject)' 4}'              };
Magic Number,CNCMaps.Engine.Map,ObjectSorter,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ObjectSorter.cs,GetFrontBlock,The following statement contains a magic number: var priorities = new Dictionary<Type' int> {                  {typeof(MapTile)' 0}'                  {typeof(SmudgeObject)' 1}'                  {typeof(OverlayObject)' 2}'                  {typeof(TerrainObject)' 3}'                  {typeof(StructureObject)' 3}'                  {typeof(AnimationObject)' 3}'                  {typeof(UnitObject)' 3}'                  {typeof(InfantryObject)' 3}'                  {typeof(AircraftObject)' 4}'              };
Magic Number,CNCMaps.Engine.Map,ObjectSorter,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ObjectSorter.cs,GetFrontBlock,The following statement contains a magic number: var priorities = new Dictionary<Type' int> {                  {typeof(MapTile)' 0}'                  {typeof(SmudgeObject)' 1}'                  {typeof(OverlayObject)' 2}'                  {typeof(TerrainObject)' 3}'                  {typeof(StructureObject)' 3}'                  {typeof(AnimationObject)' 3}'                  {typeof(UnitObject)' 3}'                  {typeof(InfantryObject)' 3}'                  {typeof(AircraftObject)' 4}'              };
Magic Number,CNCMaps.Engine.Map,ObjectSorter,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ObjectSorter.cs,GetFrontBlock,The following statement contains a magic number: var priorities = new Dictionary<Type' int> {                  {typeof(MapTile)' 0}'                  {typeof(SmudgeObject)' 1}'                  {typeof(OverlayObject)' 2}'                  {typeof(TerrainObject)' 3}'                  {typeof(StructureObject)' 3}'                  {typeof(AnimationObject)' 3}'                  {typeof(UnitObject)' 3}'                  {typeof(InfantryObject)' 3}'                  {typeof(AircraftObject)' 4}'              };
Magic Number,CNCMaps.Engine.Map,ObjectSorter,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ObjectSorter.cs,GetFrontBlock,The following statement contains a magic number: var priorities = new Dictionary<Type' int> {                  {typeof(MapTile)' 0}'                  {typeof(SmudgeObject)' 1}'                  {typeof(OverlayObject)' 2}'                  {typeof(TerrainObject)' 3}'                  {typeof(StructureObject)' 3}'                  {typeof(AnimationObject)' 3}'                  {typeof(UnitObject)' 3}'                  {typeof(InfantryObject)' 3}'                  {typeof(AircraftObject)' 4}'              };
Magic Number,CNCMaps.Engine.Map,ObjectSorter,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ObjectSorter.cs,GetFrontBlock,The following statement contains a magic number: var priorities = new Dictionary<Type' int> {                  {typeof(MapTile)' 0}'                  {typeof(SmudgeObject)' 1}'                  {typeof(OverlayObject)' 2}'                  {typeof(TerrainObject)' 3}'                  {typeof(StructureObject)' 3}'                  {typeof(AnimationObject)' 3}'                  {typeof(UnitObject)' 3}'                  {typeof(InfantryObject)' 3}'                  {typeof(AircraftObject)' 4}'              };
Magic Number,CNCMaps.Engine.Map,ObjectSorter,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ObjectSorter.cs,GetIsoBoundingBox,The following statement contains a magic number: if (obj is MapTile)  				return new Hexagon {  					xMin = obj.Tile.Rx'  					xMax = obj.Tile.Rx'  					yMin = obj.Tile.Ry'  					yMax = obj.Tile.Ry'  					zMin = obj.Tile.Z'  					zMax = obj.Tile.Z'  				};  			else if (obj is OwnableObject) {  				var oObj = obj as OwnableObject;  				return new Hexagon {  					xMin = obj.TopTile.Rx'  					xMax = obj.BottomTile.Rx'  					yMin = obj.TopTile.Ry'  					yMax = obj.BottomTile.Ry'  					zMin = obj.Tile.Z + (oObj.OnBridge ? 4 : 0)'  					zMax = obj.Tile.Z + (oObj.OnBridge ? 4 : 0)'  				};  			}  			else  				return new Hexagon {  					xMin = obj.TopTile.Rx'  					xMax = obj.BottomTile.Rx'  					yMin = obj.TopTile.Ry'  					yMax = obj.BottomTile.Ry'  					zMin = obj.Tile.Z + obj.Drawable.TileElevation'  					zMax = obj.Tile.Z + obj.Drawable.TileElevation'  				};
Magic Number,CNCMaps.Engine.Map,ObjectSorter,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ObjectSorter.cs,GetIsoBoundingBox,The following statement contains a magic number: if (obj is MapTile)  				return new Hexagon {  					xMin = obj.Tile.Rx'  					xMax = obj.Tile.Rx'  					yMin = obj.Tile.Ry'  					yMax = obj.Tile.Ry'  					zMin = obj.Tile.Z'  					zMax = obj.Tile.Z'  				};  			else if (obj is OwnableObject) {  				var oObj = obj as OwnableObject;  				return new Hexagon {  					xMin = obj.TopTile.Rx'  					xMax = obj.BottomTile.Rx'  					yMin = obj.TopTile.Ry'  					yMax = obj.BottomTile.Ry'  					zMin = obj.Tile.Z + (oObj.OnBridge ? 4 : 0)'  					zMax = obj.Tile.Z + (oObj.OnBridge ? 4 : 0)'  				};  			}  			else  				return new Hexagon {  					xMin = obj.TopTile.Rx'  					xMax = obj.BottomTile.Rx'  					yMin = obj.TopTile.Ry'  					yMax = obj.BottomTile.Ry'  					zMin = obj.Tile.Z + obj.Drawable.TileElevation'  					zMax = obj.Tile.Z + obj.Drawable.TileElevation'  				};
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateOreSpread,The following statement contains a magic number: foreach (OverlayObject o in ovls) {  				// The value consists of the sum of all dx's with a little magic offsets  				// plus the sum of all dy's with also a little magic offset' and also  				// everything is calculated modulo 12  				var type = SpecialOverlays.GetOverlayTibType(o' engine);    				if (type == OverlayTibType.Ore) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdRiparius + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdRiparius + num);  				}    				else if (type == OverlayTibType.Gems) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdCruentus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdCruentus + num);  				}    				else if (type == OverlayTibType.Vinifera) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdVinifera + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdVinifera + num);  				}    				else if (type == OverlayTibType.Aboreus) {  					int x = o.Tile.Dx;  					int y = o.Tile.Dy;  					double yInc = ((((y - 9) / 2) % 12) * (((y - 8) / 2) % 12)) % 12;  					double xInc = ((((x - 13) / 2) % 12) * (((x - 12) / 2) % 12)) % 12;    					// x_inc may be > y_inc so adding a big number outside of cell bounds  					// will surely keep num positive  					var num = (int)(yInc - xInc + 120000);  					num %= 12;    					// replace gems  					if (engine <= EngineType.RedAlert2)  						o.OverlayID = (byte)(SpecialOverlays.Ra2MinIdAboreus + num);  					else  						o.OverlayID = (byte)(SpecialOverlays.TsMinIdAboreus + num);  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateVeinsSpread,The following statement contains a magic number: foreach (var o in ovls) {  				if (IsVeins(o) && !o.Drawable.IsVeinHoleMonster && o.OverlayValue / 3 == 15)  					o.IsGeneratedVeins = true;  			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateVeinsSpread,The following statement contains a magic number: foreach (var o in ovls) {  				if (IsVeins(o) && !o.Drawable.IsVeinHoleMonster && o.OverlayValue / 3 == 15)  					o.IsGeneratedVeins = true;  			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateVeinsSpread,The following statement contains a magic number: foreach (var t in tiles) {  				var o = t.AllObjects.OfType<OverlayObject>().FirstOrDefault();    				int veins = 0' rnd = 0' mul = 1;  				bool amIVeins = IsVeins(o);    				if (amIVeins && !o.Drawable.IsVeinHoleMonster) {  					// see if veins are positioned on ramp  					anyVeins = o;  					var tmpImg = (o.Tile.Drawable as TileDrawable).GetTileImage(o.Tile);  					if (tmpImg != null && tmpImg.RampType != 0) {  						if (tmpImg.RampType == 7) veins = 51;  						else if (tmpImg.RampType == 2) veins = 55;  						else if (tmpImg.RampType == 3) veins = 57;  						else if (tmpImg.RampType == 4) veins = 59;  						else {  							continue;  						}  						rnd = 2;  						mul = 1;  					}  					else {  						var ne = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  						var se = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  						var sw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  						var nw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);    						bool neV = ne != null && ne.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool seV = se != null && se.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool swV = sw != null && sw.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool nwV = nw != null && nw.AllObjects.OfType<OverlayObject>().Any(IsVeins);    						int numNeighbours = CountNeighbouringVeins(ne' se' sw' nw' IsVeins);  						int threshold = numNeighbours != 4 ? 4 : 0;  						var compare = numNeighbours == 4 ? (Func<OverlayObject' bool>)IsFullVeins : IsVeins;  						Func<OverlayObject' bool> thresholdCompare = ov => threshold <= CountNeighbouringVeins(ov.Tile' compare);    						if (neV && ne.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 1;    						if (seV && se.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 2;    						if (swV && sw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 4;    						if (nwV && nw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 8;    						if (veins == 15 && !o.IsGeneratedVeins)  							veins++;    						mul = 3;  						rnd = 3;  					}  				}    				if (veins != 0 || amIVeins) {  					if (o == null) {  						// on the fly veins creation..  						o = new OverlayObject(anyVeins.OverlayID' (byte)Rand.Next(3));  						o.IsGeneratedVeins = true;  						o.Drawable = anyVeins.Drawable;  						o.Palette = anyVeins.Palette;  						o.TopTile = o.BottomTile = o.Tile;  						t.AddObject(o);  					}  					else {  						o.OverlayValue = (byte)(veins * mul + Rand.Next(rnd));  						Debug.WriteLine("Replacing veins with value {0} ({1})"' o.OverlayValue' veins);  					}  				}      			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateVeinsSpread,The following statement contains a magic number: foreach (var t in tiles) {  				var o = t.AllObjects.OfType<OverlayObject>().FirstOrDefault();    				int veins = 0' rnd = 0' mul = 1;  				bool amIVeins = IsVeins(o);    				if (amIVeins && !o.Drawable.IsVeinHoleMonster) {  					// see if veins are positioned on ramp  					anyVeins = o;  					var tmpImg = (o.Tile.Drawable as TileDrawable).GetTileImage(o.Tile);  					if (tmpImg != null && tmpImg.RampType != 0) {  						if (tmpImg.RampType == 7) veins = 51;  						else if (tmpImg.RampType == 2) veins = 55;  						else if (tmpImg.RampType == 3) veins = 57;  						else if (tmpImg.RampType == 4) veins = 59;  						else {  							continue;  						}  						rnd = 2;  						mul = 1;  					}  					else {  						var ne = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  						var se = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  						var sw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  						var nw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);    						bool neV = ne != null && ne.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool seV = se != null && se.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool swV = sw != null && sw.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool nwV = nw != null && nw.AllObjects.OfType<OverlayObject>().Any(IsVeins);    						int numNeighbours = CountNeighbouringVeins(ne' se' sw' nw' IsVeins);  						int threshold = numNeighbours != 4 ? 4 : 0;  						var compare = numNeighbours == 4 ? (Func<OverlayObject' bool>)IsFullVeins : IsVeins;  						Func<OverlayObject' bool> thresholdCompare = ov => threshold <= CountNeighbouringVeins(ov.Tile' compare);    						if (neV && ne.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 1;    						if (seV && se.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 2;    						if (swV && sw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 4;    						if (nwV && nw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 8;    						if (veins == 15 && !o.IsGeneratedVeins)  							veins++;    						mul = 3;  						rnd = 3;  					}  				}    				if (veins != 0 || amIVeins) {  					if (o == null) {  						// on the fly veins creation..  						o = new OverlayObject(anyVeins.OverlayID' (byte)Rand.Next(3));  						o.IsGeneratedVeins = true;  						o.Drawable = anyVeins.Drawable;  						o.Palette = anyVeins.Palette;  						o.TopTile = o.BottomTile = o.Tile;  						t.AddObject(o);  					}  					else {  						o.OverlayValue = (byte)(veins * mul + Rand.Next(rnd));  						Debug.WriteLine("Replacing veins with value {0} ({1})"' o.OverlayValue' veins);  					}  				}      			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateVeinsSpread,The following statement contains a magic number: foreach (var t in tiles) {  				var o = t.AllObjects.OfType<OverlayObject>().FirstOrDefault();    				int veins = 0' rnd = 0' mul = 1;  				bool amIVeins = IsVeins(o);    				if (amIVeins && !o.Drawable.IsVeinHoleMonster) {  					// see if veins are positioned on ramp  					anyVeins = o;  					var tmpImg = (o.Tile.Drawable as TileDrawable).GetTileImage(o.Tile);  					if (tmpImg != null && tmpImg.RampType != 0) {  						if (tmpImg.RampType == 7) veins = 51;  						else if (tmpImg.RampType == 2) veins = 55;  						else if (tmpImg.RampType == 3) veins = 57;  						else if (tmpImg.RampType == 4) veins = 59;  						else {  							continue;  						}  						rnd = 2;  						mul = 1;  					}  					else {  						var ne = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  						var se = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  						var sw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  						var nw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);    						bool neV = ne != null && ne.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool seV = se != null && se.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool swV = sw != null && sw.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool nwV = nw != null && nw.AllObjects.OfType<OverlayObject>().Any(IsVeins);    						int numNeighbours = CountNeighbouringVeins(ne' se' sw' nw' IsVeins);  						int threshold = numNeighbours != 4 ? 4 : 0;  						var compare = numNeighbours == 4 ? (Func<OverlayObject' bool>)IsFullVeins : IsVeins;  						Func<OverlayObject' bool> thresholdCompare = ov => threshold <= CountNeighbouringVeins(ov.Tile' compare);    						if (neV && ne.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 1;    						if (seV && se.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 2;    						if (swV && sw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 4;    						if (nwV && nw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 8;    						if (veins == 15 && !o.IsGeneratedVeins)  							veins++;    						mul = 3;  						rnd = 3;  					}  				}    				if (veins != 0 || amIVeins) {  					if (o == null) {  						// on the fly veins creation..  						o = new OverlayObject(anyVeins.OverlayID' (byte)Rand.Next(3));  						o.IsGeneratedVeins = true;  						o.Drawable = anyVeins.Drawable;  						o.Palette = anyVeins.Palette;  						o.TopTile = o.BottomTile = o.Tile;  						t.AddObject(o);  					}  					else {  						o.OverlayValue = (byte)(veins * mul + Rand.Next(rnd));  						Debug.WriteLine("Replacing veins with value {0} ({1})"' o.OverlayValue' veins);  					}  				}      			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateVeinsSpread,The following statement contains a magic number: foreach (var t in tiles) {  				var o = t.AllObjects.OfType<OverlayObject>().FirstOrDefault();    				int veins = 0' rnd = 0' mul = 1;  				bool amIVeins = IsVeins(o);    				if (amIVeins && !o.Drawable.IsVeinHoleMonster) {  					// see if veins are positioned on ramp  					anyVeins = o;  					var tmpImg = (o.Tile.Drawable as TileDrawable).GetTileImage(o.Tile);  					if (tmpImg != null && tmpImg.RampType != 0) {  						if (tmpImg.RampType == 7) veins = 51;  						else if (tmpImg.RampType == 2) veins = 55;  						else if (tmpImg.RampType == 3) veins = 57;  						else if (tmpImg.RampType == 4) veins = 59;  						else {  							continue;  						}  						rnd = 2;  						mul = 1;  					}  					else {  						var ne = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  						var se = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  						var sw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  						var nw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);    						bool neV = ne != null && ne.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool seV = se != null && se.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool swV = sw != null && sw.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool nwV = nw != null && nw.AllObjects.OfType<OverlayObject>().Any(IsVeins);    						int numNeighbours = CountNeighbouringVeins(ne' se' sw' nw' IsVeins);  						int threshold = numNeighbours != 4 ? 4 : 0;  						var compare = numNeighbours == 4 ? (Func<OverlayObject' bool>)IsFullVeins : IsVeins;  						Func<OverlayObject' bool> thresholdCompare = ov => threshold <= CountNeighbouringVeins(ov.Tile' compare);    						if (neV && ne.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 1;    						if (seV && se.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 2;    						if (swV && sw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 4;    						if (nwV && nw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 8;    						if (veins == 15 && !o.IsGeneratedVeins)  							veins++;    						mul = 3;  						rnd = 3;  					}  				}    				if (veins != 0 || amIVeins) {  					if (o == null) {  						// on the fly veins creation..  						o = new OverlayObject(anyVeins.OverlayID' (byte)Rand.Next(3));  						o.IsGeneratedVeins = true;  						o.Drawable = anyVeins.Drawable;  						o.Palette = anyVeins.Palette;  						o.TopTile = o.BottomTile = o.Tile;  						t.AddObject(o);  					}  					else {  						o.OverlayValue = (byte)(veins * mul + Rand.Next(rnd));  						Debug.WriteLine("Replacing veins with value {0} ({1})"' o.OverlayValue' veins);  					}  				}      			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateVeinsSpread,The following statement contains a magic number: foreach (var t in tiles) {  				var o = t.AllObjects.OfType<OverlayObject>().FirstOrDefault();    				int veins = 0' rnd = 0' mul = 1;  				bool amIVeins = IsVeins(o);    				if (amIVeins && !o.Drawable.IsVeinHoleMonster) {  					// see if veins are positioned on ramp  					anyVeins = o;  					var tmpImg = (o.Tile.Drawable as TileDrawable).GetTileImage(o.Tile);  					if (tmpImg != null && tmpImg.RampType != 0) {  						if (tmpImg.RampType == 7) veins = 51;  						else if (tmpImg.RampType == 2) veins = 55;  						else if (tmpImg.RampType == 3) veins = 57;  						else if (tmpImg.RampType == 4) veins = 59;  						else {  							continue;  						}  						rnd = 2;  						mul = 1;  					}  					else {  						var ne = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  						var se = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  						var sw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  						var nw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);    						bool neV = ne != null && ne.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool seV = se != null && se.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool swV = sw != null && sw.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool nwV = nw != null && nw.AllObjects.OfType<OverlayObject>().Any(IsVeins);    						int numNeighbours = CountNeighbouringVeins(ne' se' sw' nw' IsVeins);  						int threshold = numNeighbours != 4 ? 4 : 0;  						var compare = numNeighbours == 4 ? (Func<OverlayObject' bool>)IsFullVeins : IsVeins;  						Func<OverlayObject' bool> thresholdCompare = ov => threshold <= CountNeighbouringVeins(ov.Tile' compare);    						if (neV && ne.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 1;    						if (seV && se.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 2;    						if (swV && sw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 4;    						if (nwV && nw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 8;    						if (veins == 15 && !o.IsGeneratedVeins)  							veins++;    						mul = 3;  						rnd = 3;  					}  				}    				if (veins != 0 || amIVeins) {  					if (o == null) {  						// on the fly veins creation..  						o = new OverlayObject(anyVeins.OverlayID' (byte)Rand.Next(3));  						o.IsGeneratedVeins = true;  						o.Drawable = anyVeins.Drawable;  						o.Palette = anyVeins.Palette;  						o.TopTile = o.BottomTile = o.Tile;  						t.AddObject(o);  					}  					else {  						o.OverlayValue = (byte)(veins * mul + Rand.Next(rnd));  						Debug.WriteLine("Replacing veins with value {0} ({1})"' o.OverlayValue' veins);  					}  				}      			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateVeinsSpread,The following statement contains a magic number: foreach (var t in tiles) {  				var o = t.AllObjects.OfType<OverlayObject>().FirstOrDefault();    				int veins = 0' rnd = 0' mul = 1;  				bool amIVeins = IsVeins(o);    				if (amIVeins && !o.Drawable.IsVeinHoleMonster) {  					// see if veins are positioned on ramp  					anyVeins = o;  					var tmpImg = (o.Tile.Drawable as TileDrawable).GetTileImage(o.Tile);  					if (tmpImg != null && tmpImg.RampType != 0) {  						if (tmpImg.RampType == 7) veins = 51;  						else if (tmpImg.RampType == 2) veins = 55;  						else if (tmpImg.RampType == 3) veins = 57;  						else if (tmpImg.RampType == 4) veins = 59;  						else {  							continue;  						}  						rnd = 2;  						mul = 1;  					}  					else {  						var ne = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  						var se = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  						var sw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  						var nw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);    						bool neV = ne != null && ne.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool seV = se != null && se.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool swV = sw != null && sw.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool nwV = nw != null && nw.AllObjects.OfType<OverlayObject>().Any(IsVeins);    						int numNeighbours = CountNeighbouringVeins(ne' se' sw' nw' IsVeins);  						int threshold = numNeighbours != 4 ? 4 : 0;  						var compare = numNeighbours == 4 ? (Func<OverlayObject' bool>)IsFullVeins : IsVeins;  						Func<OverlayObject' bool> thresholdCompare = ov => threshold <= CountNeighbouringVeins(ov.Tile' compare);    						if (neV && ne.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 1;    						if (seV && se.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 2;    						if (swV && sw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 4;    						if (nwV && nw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 8;    						if (veins == 15 && !o.IsGeneratedVeins)  							veins++;    						mul = 3;  						rnd = 3;  					}  				}    				if (veins != 0 || amIVeins) {  					if (o == null) {  						// on the fly veins creation..  						o = new OverlayObject(anyVeins.OverlayID' (byte)Rand.Next(3));  						o.IsGeneratedVeins = true;  						o.Drawable = anyVeins.Drawable;  						o.Palette = anyVeins.Palette;  						o.TopTile = o.BottomTile = o.Tile;  						t.AddObject(o);  					}  					else {  						o.OverlayValue = (byte)(veins * mul + Rand.Next(rnd));  						Debug.WriteLine("Replacing veins with value {0} ({1})"' o.OverlayValue' veins);  					}  				}      			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateVeinsSpread,The following statement contains a magic number: foreach (var t in tiles) {  				var o = t.AllObjects.OfType<OverlayObject>().FirstOrDefault();    				int veins = 0' rnd = 0' mul = 1;  				bool amIVeins = IsVeins(o);    				if (amIVeins && !o.Drawable.IsVeinHoleMonster) {  					// see if veins are positioned on ramp  					anyVeins = o;  					var tmpImg = (o.Tile.Drawable as TileDrawable).GetTileImage(o.Tile);  					if (tmpImg != null && tmpImg.RampType != 0) {  						if (tmpImg.RampType == 7) veins = 51;  						else if (tmpImg.RampType == 2) veins = 55;  						else if (tmpImg.RampType == 3) veins = 57;  						else if (tmpImg.RampType == 4) veins = 59;  						else {  							continue;  						}  						rnd = 2;  						mul = 1;  					}  					else {  						var ne = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  						var se = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  						var sw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  						var nw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);    						bool neV = ne != null && ne.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool seV = se != null && se.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool swV = sw != null && sw.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool nwV = nw != null && nw.AllObjects.OfType<OverlayObject>().Any(IsVeins);    						int numNeighbours = CountNeighbouringVeins(ne' se' sw' nw' IsVeins);  						int threshold = numNeighbours != 4 ? 4 : 0;  						var compare = numNeighbours == 4 ? (Func<OverlayObject' bool>)IsFullVeins : IsVeins;  						Func<OverlayObject' bool> thresholdCompare = ov => threshold <= CountNeighbouringVeins(ov.Tile' compare);    						if (neV && ne.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 1;    						if (seV && se.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 2;    						if (swV && sw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 4;    						if (nwV && nw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 8;    						if (veins == 15 && !o.IsGeneratedVeins)  							veins++;    						mul = 3;  						rnd = 3;  					}  				}    				if (veins != 0 || amIVeins) {  					if (o == null) {  						// on the fly veins creation..  						o = new OverlayObject(anyVeins.OverlayID' (byte)Rand.Next(3));  						o.IsGeneratedVeins = true;  						o.Drawable = anyVeins.Drawable;  						o.Palette = anyVeins.Palette;  						o.TopTile = o.BottomTile = o.Tile;  						t.AddObject(o);  					}  					else {  						o.OverlayValue = (byte)(veins * mul + Rand.Next(rnd));  						Debug.WriteLine("Replacing veins with value {0} ({1})"' o.OverlayValue' veins);  					}  				}      			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateVeinsSpread,The following statement contains a magic number: foreach (var t in tiles) {  				var o = t.AllObjects.OfType<OverlayObject>().FirstOrDefault();    				int veins = 0' rnd = 0' mul = 1;  				bool amIVeins = IsVeins(o);    				if (amIVeins && !o.Drawable.IsVeinHoleMonster) {  					// see if veins are positioned on ramp  					anyVeins = o;  					var tmpImg = (o.Tile.Drawable as TileDrawable).GetTileImage(o.Tile);  					if (tmpImg != null && tmpImg.RampType != 0) {  						if (tmpImg.RampType == 7) veins = 51;  						else if (tmpImg.RampType == 2) veins = 55;  						else if (tmpImg.RampType == 3) veins = 57;  						else if (tmpImg.RampType == 4) veins = 59;  						else {  							continue;  						}  						rnd = 2;  						mul = 1;  					}  					else {  						var ne = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  						var se = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  						var sw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  						var nw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);    						bool neV = ne != null && ne.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool seV = se != null && se.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool swV = sw != null && sw.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool nwV = nw != null && nw.AllObjects.OfType<OverlayObject>().Any(IsVeins);    						int numNeighbours = CountNeighbouringVeins(ne' se' sw' nw' IsVeins);  						int threshold = numNeighbours != 4 ? 4 : 0;  						var compare = numNeighbours == 4 ? (Func<OverlayObject' bool>)IsFullVeins : IsVeins;  						Func<OverlayObject' bool> thresholdCompare = ov => threshold <= CountNeighbouringVeins(ov.Tile' compare);    						if (neV && ne.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 1;    						if (seV && se.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 2;    						if (swV && sw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 4;    						if (nwV && nw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 8;    						if (veins == 15 && !o.IsGeneratedVeins)  							veins++;    						mul = 3;  						rnd = 3;  					}  				}    				if (veins != 0 || amIVeins) {  					if (o == null) {  						// on the fly veins creation..  						o = new OverlayObject(anyVeins.OverlayID' (byte)Rand.Next(3));  						o.IsGeneratedVeins = true;  						o.Drawable = anyVeins.Drawable;  						o.Palette = anyVeins.Palette;  						o.TopTile = o.BottomTile = o.Tile;  						t.AddObject(o);  					}  					else {  						o.OverlayValue = (byte)(veins * mul + Rand.Next(rnd));  						Debug.WriteLine("Replacing veins with value {0} ({1})"' o.OverlayValue' veins);  					}  				}      			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateVeinsSpread,The following statement contains a magic number: foreach (var t in tiles) {  				var o = t.AllObjects.OfType<OverlayObject>().FirstOrDefault();    				int veins = 0' rnd = 0' mul = 1;  				bool amIVeins = IsVeins(o);    				if (amIVeins && !o.Drawable.IsVeinHoleMonster) {  					// see if veins are positioned on ramp  					anyVeins = o;  					var tmpImg = (o.Tile.Drawable as TileDrawable).GetTileImage(o.Tile);  					if (tmpImg != null && tmpImg.RampType != 0) {  						if (tmpImg.RampType == 7) veins = 51;  						else if (tmpImg.RampType == 2) veins = 55;  						else if (tmpImg.RampType == 3) veins = 57;  						else if (tmpImg.RampType == 4) veins = 59;  						else {  							continue;  						}  						rnd = 2;  						mul = 1;  					}  					else {  						var ne = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  						var se = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  						var sw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  						var nw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);    						bool neV = ne != null && ne.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool seV = se != null && se.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool swV = sw != null && sw.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool nwV = nw != null && nw.AllObjects.OfType<OverlayObject>().Any(IsVeins);    						int numNeighbours = CountNeighbouringVeins(ne' se' sw' nw' IsVeins);  						int threshold = numNeighbours != 4 ? 4 : 0;  						var compare = numNeighbours == 4 ? (Func<OverlayObject' bool>)IsFullVeins : IsVeins;  						Func<OverlayObject' bool> thresholdCompare = ov => threshold <= CountNeighbouringVeins(ov.Tile' compare);    						if (neV && ne.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 1;    						if (seV && se.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 2;    						if (swV && sw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 4;    						if (nwV && nw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 8;    						if (veins == 15 && !o.IsGeneratedVeins)  							veins++;    						mul = 3;  						rnd = 3;  					}  				}    				if (veins != 0 || amIVeins) {  					if (o == null) {  						// on the fly veins creation..  						o = new OverlayObject(anyVeins.OverlayID' (byte)Rand.Next(3));  						o.IsGeneratedVeins = true;  						o.Drawable = anyVeins.Drawable;  						o.Palette = anyVeins.Palette;  						o.TopTile = o.BottomTile = o.Tile;  						t.AddObject(o);  					}  					else {  						o.OverlayValue = (byte)(veins * mul + Rand.Next(rnd));  						Debug.WriteLine("Replacing veins with value {0} ({1})"' o.OverlayValue' veins);  					}  				}      			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateVeinsSpread,The following statement contains a magic number: foreach (var t in tiles) {  				var o = t.AllObjects.OfType<OverlayObject>().FirstOrDefault();    				int veins = 0' rnd = 0' mul = 1;  				bool amIVeins = IsVeins(o);    				if (amIVeins && !o.Drawable.IsVeinHoleMonster) {  					// see if veins are positioned on ramp  					anyVeins = o;  					var tmpImg = (o.Tile.Drawable as TileDrawable).GetTileImage(o.Tile);  					if (tmpImg != null && tmpImg.RampType != 0) {  						if (tmpImg.RampType == 7) veins = 51;  						else if (tmpImg.RampType == 2) veins = 55;  						else if (tmpImg.RampType == 3) veins = 57;  						else if (tmpImg.RampType == 4) veins = 59;  						else {  							continue;  						}  						rnd = 2;  						mul = 1;  					}  					else {  						var ne = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  						var se = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  						var sw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  						var nw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);    						bool neV = ne != null && ne.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool seV = se != null && se.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool swV = sw != null && sw.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool nwV = nw != null && nw.AllObjects.OfType<OverlayObject>().Any(IsVeins);    						int numNeighbours = CountNeighbouringVeins(ne' se' sw' nw' IsVeins);  						int threshold = numNeighbours != 4 ? 4 : 0;  						var compare = numNeighbours == 4 ? (Func<OverlayObject' bool>)IsFullVeins : IsVeins;  						Func<OverlayObject' bool> thresholdCompare = ov => threshold <= CountNeighbouringVeins(ov.Tile' compare);    						if (neV && ne.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 1;    						if (seV && se.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 2;    						if (swV && sw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 4;    						if (nwV && nw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 8;    						if (veins == 15 && !o.IsGeneratedVeins)  							veins++;    						mul = 3;  						rnd = 3;  					}  				}    				if (veins != 0 || amIVeins) {  					if (o == null) {  						// on the fly veins creation..  						o = new OverlayObject(anyVeins.OverlayID' (byte)Rand.Next(3));  						o.IsGeneratedVeins = true;  						o.Drawable = anyVeins.Drawable;  						o.Palette = anyVeins.Palette;  						o.TopTile = o.BottomTile = o.Tile;  						t.AddObject(o);  					}  					else {  						o.OverlayValue = (byte)(veins * mul + Rand.Next(rnd));  						Debug.WriteLine("Replacing veins with value {0} ({1})"' o.OverlayValue' veins);  					}  				}      			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateVeinsSpread,The following statement contains a magic number: foreach (var t in tiles) {  				var o = t.AllObjects.OfType<OverlayObject>().FirstOrDefault();    				int veins = 0' rnd = 0' mul = 1;  				bool amIVeins = IsVeins(o);    				if (amIVeins && !o.Drawable.IsVeinHoleMonster) {  					// see if veins are positioned on ramp  					anyVeins = o;  					var tmpImg = (o.Tile.Drawable as TileDrawable).GetTileImage(o.Tile);  					if (tmpImg != null && tmpImg.RampType != 0) {  						if (tmpImg.RampType == 7) veins = 51;  						else if (tmpImg.RampType == 2) veins = 55;  						else if (tmpImg.RampType == 3) veins = 57;  						else if (tmpImg.RampType == 4) veins = 59;  						else {  							continue;  						}  						rnd = 2;  						mul = 1;  					}  					else {  						var ne = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  						var se = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  						var sw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  						var nw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);    						bool neV = ne != null && ne.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool seV = se != null && se.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool swV = sw != null && sw.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool nwV = nw != null && nw.AllObjects.OfType<OverlayObject>().Any(IsVeins);    						int numNeighbours = CountNeighbouringVeins(ne' se' sw' nw' IsVeins);  						int threshold = numNeighbours != 4 ? 4 : 0;  						var compare = numNeighbours == 4 ? (Func<OverlayObject' bool>)IsFullVeins : IsVeins;  						Func<OverlayObject' bool> thresholdCompare = ov => threshold <= CountNeighbouringVeins(ov.Tile' compare);    						if (neV && ne.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 1;    						if (seV && se.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 2;    						if (swV && sw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 4;    						if (nwV && nw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 8;    						if (veins == 15 && !o.IsGeneratedVeins)  							veins++;    						mul = 3;  						rnd = 3;  					}  				}    				if (veins != 0 || amIVeins) {  					if (o == null) {  						// on the fly veins creation..  						o = new OverlayObject(anyVeins.OverlayID' (byte)Rand.Next(3));  						o.IsGeneratedVeins = true;  						o.Drawable = anyVeins.Drawable;  						o.Palette = anyVeins.Palette;  						o.TopTile = o.BottomTile = o.Tile;  						t.AddObject(o);  					}  					else {  						o.OverlayValue = (byte)(veins * mul + Rand.Next(rnd));  						Debug.WriteLine("Replacing veins with value {0} ({1})"' o.OverlayValue' veins);  					}  				}      			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateVeinsSpread,The following statement contains a magic number: foreach (var t in tiles) {  				var o = t.AllObjects.OfType<OverlayObject>().FirstOrDefault();    				int veins = 0' rnd = 0' mul = 1;  				bool amIVeins = IsVeins(o);    				if (amIVeins && !o.Drawable.IsVeinHoleMonster) {  					// see if veins are positioned on ramp  					anyVeins = o;  					var tmpImg = (o.Tile.Drawable as TileDrawable).GetTileImage(o.Tile);  					if (tmpImg != null && tmpImg.RampType != 0) {  						if (tmpImg.RampType == 7) veins = 51;  						else if (tmpImg.RampType == 2) veins = 55;  						else if (tmpImg.RampType == 3) veins = 57;  						else if (tmpImg.RampType == 4) veins = 59;  						else {  							continue;  						}  						rnd = 2;  						mul = 1;  					}  					else {  						var ne = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  						var se = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  						var sw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  						var nw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);    						bool neV = ne != null && ne.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool seV = se != null && se.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool swV = sw != null && sw.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool nwV = nw != null && nw.AllObjects.OfType<OverlayObject>().Any(IsVeins);    						int numNeighbours = CountNeighbouringVeins(ne' se' sw' nw' IsVeins);  						int threshold = numNeighbours != 4 ? 4 : 0;  						var compare = numNeighbours == 4 ? (Func<OverlayObject' bool>)IsFullVeins : IsVeins;  						Func<OverlayObject' bool> thresholdCompare = ov => threshold <= CountNeighbouringVeins(ov.Tile' compare);    						if (neV && ne.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 1;    						if (seV && se.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 2;    						if (swV && sw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 4;    						if (nwV && nw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 8;    						if (veins == 15 && !o.IsGeneratedVeins)  							veins++;    						mul = 3;  						rnd = 3;  					}  				}    				if (veins != 0 || amIVeins) {  					if (o == null) {  						// on the fly veins creation..  						o = new OverlayObject(anyVeins.OverlayID' (byte)Rand.Next(3));  						o.IsGeneratedVeins = true;  						o.Drawable = anyVeins.Drawable;  						o.Palette = anyVeins.Palette;  						o.TopTile = o.BottomTile = o.Tile;  						t.AddObject(o);  					}  					else {  						o.OverlayValue = (byte)(veins * mul + Rand.Next(rnd));  						Debug.WriteLine("Replacing veins with value {0} ({1})"' o.OverlayValue' veins);  					}  				}      			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateVeinsSpread,The following statement contains a magic number: foreach (var t in tiles) {  				var o = t.AllObjects.OfType<OverlayObject>().FirstOrDefault();    				int veins = 0' rnd = 0' mul = 1;  				bool amIVeins = IsVeins(o);    				if (amIVeins && !o.Drawable.IsVeinHoleMonster) {  					// see if veins are positioned on ramp  					anyVeins = o;  					var tmpImg = (o.Tile.Drawable as TileDrawable).GetTileImage(o.Tile);  					if (tmpImg != null && tmpImg.RampType != 0) {  						if (tmpImg.RampType == 7) veins = 51;  						else if (tmpImg.RampType == 2) veins = 55;  						else if (tmpImg.RampType == 3) veins = 57;  						else if (tmpImg.RampType == 4) veins = 59;  						else {  							continue;  						}  						rnd = 2;  						mul = 1;  					}  					else {  						var ne = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  						var se = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  						var sw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  						var nw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);    						bool neV = ne != null && ne.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool seV = se != null && se.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool swV = sw != null && sw.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool nwV = nw != null && nw.AllObjects.OfType<OverlayObject>().Any(IsVeins);    						int numNeighbours = CountNeighbouringVeins(ne' se' sw' nw' IsVeins);  						int threshold = numNeighbours != 4 ? 4 : 0;  						var compare = numNeighbours == 4 ? (Func<OverlayObject' bool>)IsFullVeins : IsVeins;  						Func<OverlayObject' bool> thresholdCompare = ov => threshold <= CountNeighbouringVeins(ov.Tile' compare);    						if (neV && ne.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 1;    						if (seV && se.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 2;    						if (swV && sw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 4;    						if (nwV && nw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 8;    						if (veins == 15 && !o.IsGeneratedVeins)  							veins++;    						mul = 3;  						rnd = 3;  					}  				}    				if (veins != 0 || amIVeins) {  					if (o == null) {  						// on the fly veins creation..  						o = new OverlayObject(anyVeins.OverlayID' (byte)Rand.Next(3));  						o.IsGeneratedVeins = true;  						o.Drawable = anyVeins.Drawable;  						o.Palette = anyVeins.Palette;  						o.TopTile = o.BottomTile = o.Tile;  						t.AddObject(o);  					}  					else {  						o.OverlayValue = (byte)(veins * mul + Rand.Next(rnd));  						Debug.WriteLine("Replacing veins with value {0} ({1})"' o.OverlayValue' veins);  					}  				}      			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateVeinsSpread,The following statement contains a magic number: foreach (var t in tiles) {  				var o = t.AllObjects.OfType<OverlayObject>().FirstOrDefault();    				int veins = 0' rnd = 0' mul = 1;  				bool amIVeins = IsVeins(o);    				if (amIVeins && !o.Drawable.IsVeinHoleMonster) {  					// see if veins are positioned on ramp  					anyVeins = o;  					var tmpImg = (o.Tile.Drawable as TileDrawable).GetTileImage(o.Tile);  					if (tmpImg != null && tmpImg.RampType != 0) {  						if (tmpImg.RampType == 7) veins = 51;  						else if (tmpImg.RampType == 2) veins = 55;  						else if (tmpImg.RampType == 3) veins = 57;  						else if (tmpImg.RampType == 4) veins = 59;  						else {  							continue;  						}  						rnd = 2;  						mul = 1;  					}  					else {  						var ne = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  						var se = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  						var sw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  						var nw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);    						bool neV = ne != null && ne.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool seV = se != null && se.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool swV = sw != null && sw.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool nwV = nw != null && nw.AllObjects.OfType<OverlayObject>().Any(IsVeins);    						int numNeighbours = CountNeighbouringVeins(ne' se' sw' nw' IsVeins);  						int threshold = numNeighbours != 4 ? 4 : 0;  						var compare = numNeighbours == 4 ? (Func<OverlayObject' bool>)IsFullVeins : IsVeins;  						Func<OverlayObject' bool> thresholdCompare = ov => threshold <= CountNeighbouringVeins(ov.Tile' compare);    						if (neV && ne.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 1;    						if (seV && se.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 2;    						if (swV && sw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 4;    						if (nwV && nw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 8;    						if (veins == 15 && !o.IsGeneratedVeins)  							veins++;    						mul = 3;  						rnd = 3;  					}  				}    				if (veins != 0 || amIVeins) {  					if (o == null) {  						// on the fly veins creation..  						o = new OverlayObject(anyVeins.OverlayID' (byte)Rand.Next(3));  						o.IsGeneratedVeins = true;  						o.Drawable = anyVeins.Drawable;  						o.Palette = anyVeins.Palette;  						o.TopTile = o.BottomTile = o.Tile;  						t.AddObject(o);  					}  					else {  						o.OverlayValue = (byte)(veins * mul + Rand.Next(rnd));  						Debug.WriteLine("Replacing veins with value {0} ({1})"' o.OverlayValue' veins);  					}  				}      			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateVeinsSpread,The following statement contains a magic number: foreach (var t in tiles) {  				var o = t.AllObjects.OfType<OverlayObject>().FirstOrDefault();    				int veins = 0' rnd = 0' mul = 1;  				bool amIVeins = IsVeins(o);    				if (amIVeins && !o.Drawable.IsVeinHoleMonster) {  					// see if veins are positioned on ramp  					anyVeins = o;  					var tmpImg = (o.Tile.Drawable as TileDrawable).GetTileImage(o.Tile);  					if (tmpImg != null && tmpImg.RampType != 0) {  						if (tmpImg.RampType == 7) veins = 51;  						else if (tmpImg.RampType == 2) veins = 55;  						else if (tmpImg.RampType == 3) veins = 57;  						else if (tmpImg.RampType == 4) veins = 59;  						else {  							continue;  						}  						rnd = 2;  						mul = 1;  					}  					else {  						var ne = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  						var se = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  						var sw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  						var nw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);    						bool neV = ne != null && ne.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool seV = se != null && se.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool swV = sw != null && sw.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool nwV = nw != null && nw.AllObjects.OfType<OverlayObject>().Any(IsVeins);    						int numNeighbours = CountNeighbouringVeins(ne' se' sw' nw' IsVeins);  						int threshold = numNeighbours != 4 ? 4 : 0;  						var compare = numNeighbours == 4 ? (Func<OverlayObject' bool>)IsFullVeins : IsVeins;  						Func<OverlayObject' bool> thresholdCompare = ov => threshold <= CountNeighbouringVeins(ov.Tile' compare);    						if (neV && ne.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 1;    						if (seV && se.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 2;    						if (swV && sw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 4;    						if (nwV && nw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 8;    						if (veins == 15 && !o.IsGeneratedVeins)  							veins++;    						mul = 3;  						rnd = 3;  					}  				}    				if (veins != 0 || amIVeins) {  					if (o == null) {  						// on the fly veins creation..  						o = new OverlayObject(anyVeins.OverlayID' (byte)Rand.Next(3));  						o.IsGeneratedVeins = true;  						o.Drawable = anyVeins.Drawable;  						o.Palette = anyVeins.Palette;  						o.TopTile = o.BottomTile = o.Tile;  						t.AddObject(o);  					}  					else {  						o.OverlayValue = (byte)(veins * mul + Rand.Next(rnd));  						Debug.WriteLine("Replacing veins with value {0} ({1})"' o.OverlayValue' veins);  					}  				}      			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateVeinsSpread,The following statement contains a magic number: foreach (var t in tiles) {  				var o = t.AllObjects.OfType<OverlayObject>().FirstOrDefault();    				int veins = 0' rnd = 0' mul = 1;  				bool amIVeins = IsVeins(o);    				if (amIVeins && !o.Drawable.IsVeinHoleMonster) {  					// see if veins are positioned on ramp  					anyVeins = o;  					var tmpImg = (o.Tile.Drawable as TileDrawable).GetTileImage(o.Tile);  					if (tmpImg != null && tmpImg.RampType != 0) {  						if (tmpImg.RampType == 7) veins = 51;  						else if (tmpImg.RampType == 2) veins = 55;  						else if (tmpImg.RampType == 3) veins = 57;  						else if (tmpImg.RampType == 4) veins = 59;  						else {  							continue;  						}  						rnd = 2;  						mul = 1;  					}  					else {  						var ne = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  						var se = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  						var sw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  						var nw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);    						bool neV = ne != null && ne.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool seV = se != null && se.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool swV = sw != null && sw.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool nwV = nw != null && nw.AllObjects.OfType<OverlayObject>().Any(IsVeins);    						int numNeighbours = CountNeighbouringVeins(ne' se' sw' nw' IsVeins);  						int threshold = numNeighbours != 4 ? 4 : 0;  						var compare = numNeighbours == 4 ? (Func<OverlayObject' bool>)IsFullVeins : IsVeins;  						Func<OverlayObject' bool> thresholdCompare = ov => threshold <= CountNeighbouringVeins(ov.Tile' compare);    						if (neV && ne.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 1;    						if (seV && se.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 2;    						if (swV && sw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 4;    						if (nwV && nw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 8;    						if (veins == 15 && !o.IsGeneratedVeins)  							veins++;    						mul = 3;  						rnd = 3;  					}  				}    				if (veins != 0 || amIVeins) {  					if (o == null) {  						// on the fly veins creation..  						o = new OverlayObject(anyVeins.OverlayID' (byte)Rand.Next(3));  						o.IsGeneratedVeins = true;  						o.Drawable = anyVeins.Drawable;  						o.Palette = anyVeins.Palette;  						o.TopTile = o.BottomTile = o.Tile;  						t.AddObject(o);  					}  					else {  						o.OverlayValue = (byte)(veins * mul + Rand.Next(rnd));  						Debug.WriteLine("Replacing veins with value {0} ({1})"' o.OverlayValue' veins);  					}  				}      			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateVeinsSpread,The following statement contains a magic number: foreach (var t in tiles) {  				var o = t.AllObjects.OfType<OverlayObject>().FirstOrDefault();    				int veins = 0' rnd = 0' mul = 1;  				bool amIVeins = IsVeins(o);    				if (amIVeins && !o.Drawable.IsVeinHoleMonster) {  					// see if veins are positioned on ramp  					anyVeins = o;  					var tmpImg = (o.Tile.Drawable as TileDrawable).GetTileImage(o.Tile);  					if (tmpImg != null && tmpImg.RampType != 0) {  						if (tmpImg.RampType == 7) veins = 51;  						else if (tmpImg.RampType == 2) veins = 55;  						else if (tmpImg.RampType == 3) veins = 57;  						else if (tmpImg.RampType == 4) veins = 59;  						else {  							continue;  						}  						rnd = 2;  						mul = 1;  					}  					else {  						var ne = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  						var se = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  						var sw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  						var nw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);    						bool neV = ne != null && ne.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool seV = se != null && se.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool swV = sw != null && sw.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool nwV = nw != null && nw.AllObjects.OfType<OverlayObject>().Any(IsVeins);    						int numNeighbours = CountNeighbouringVeins(ne' se' sw' nw' IsVeins);  						int threshold = numNeighbours != 4 ? 4 : 0;  						var compare = numNeighbours == 4 ? (Func<OverlayObject' bool>)IsFullVeins : IsVeins;  						Func<OverlayObject' bool> thresholdCompare = ov => threshold <= CountNeighbouringVeins(ov.Tile' compare);    						if (neV && ne.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 1;    						if (seV && se.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 2;    						if (swV && sw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 4;    						if (nwV && nw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 8;    						if (veins == 15 && !o.IsGeneratedVeins)  							veins++;    						mul = 3;  						rnd = 3;  					}  				}    				if (veins != 0 || amIVeins) {  					if (o == null) {  						// on the fly veins creation..  						o = new OverlayObject(anyVeins.OverlayID' (byte)Rand.Next(3));  						o.IsGeneratedVeins = true;  						o.Drawable = anyVeins.Drawable;  						o.Palette = anyVeins.Palette;  						o.TopTile = o.BottomTile = o.Tile;  						t.AddObject(o);  					}  					else {  						o.OverlayValue = (byte)(veins * mul + Rand.Next(rnd));  						Debug.WriteLine("Replacing veins with value {0} ({1})"' o.OverlayValue' veins);  					}  				}      			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateVeinsSpread,The following statement contains a magic number: foreach (var t in tiles) {  				var o = t.AllObjects.OfType<OverlayObject>().FirstOrDefault();    				int veins = 0' rnd = 0' mul = 1;  				bool amIVeins = IsVeins(o);    				if (amIVeins && !o.Drawable.IsVeinHoleMonster) {  					// see if veins are positioned on ramp  					anyVeins = o;  					var tmpImg = (o.Tile.Drawable as TileDrawable).GetTileImage(o.Tile);  					if (tmpImg != null && tmpImg.RampType != 0) {  						if (tmpImg.RampType == 7) veins = 51;  						else if (tmpImg.RampType == 2) veins = 55;  						else if (tmpImg.RampType == 3) veins = 57;  						else if (tmpImg.RampType == 4) veins = 59;  						else {  							continue;  						}  						rnd = 2;  						mul = 1;  					}  					else {  						var ne = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  						var se = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  						var sw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  						var nw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);    						bool neV = ne != null && ne.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool seV = se != null && se.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool swV = sw != null && sw.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool nwV = nw != null && nw.AllObjects.OfType<OverlayObject>().Any(IsVeins);    						int numNeighbours = CountNeighbouringVeins(ne' se' sw' nw' IsVeins);  						int threshold = numNeighbours != 4 ? 4 : 0;  						var compare = numNeighbours == 4 ? (Func<OverlayObject' bool>)IsFullVeins : IsVeins;  						Func<OverlayObject' bool> thresholdCompare = ov => threshold <= CountNeighbouringVeins(ov.Tile' compare);    						if (neV && ne.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 1;    						if (seV && se.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 2;    						if (swV && sw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 4;    						if (nwV && nw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 8;    						if (veins == 15 && !o.IsGeneratedVeins)  							veins++;    						mul = 3;  						rnd = 3;  					}  				}    				if (veins != 0 || amIVeins) {  					if (o == null) {  						// on the fly veins creation..  						o = new OverlayObject(anyVeins.OverlayID' (byte)Rand.Next(3));  						o.IsGeneratedVeins = true;  						o.Drawable = anyVeins.Drawable;  						o.Palette = anyVeins.Palette;  						o.TopTile = o.BottomTile = o.Tile;  						t.AddObject(o);  					}  					else {  						o.OverlayValue = (byte)(veins * mul + Rand.Next(rnd));  						Debug.WriteLine("Replacing veins with value {0} ({1})"' o.OverlayValue' veins);  					}  				}      			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,RecalculateVeinsSpread,The following statement contains a magic number: foreach (var t in tiles) {  				var o = t.AllObjects.OfType<OverlayObject>().FirstOrDefault();    				int veins = 0' rnd = 0' mul = 1;  				bool amIVeins = IsVeins(o);    				if (amIVeins && !o.Drawable.IsVeinHoleMonster) {  					// see if veins are positioned on ramp  					anyVeins = o;  					var tmpImg = (o.Tile.Drawable as TileDrawable).GetTileImage(o.Tile);  					if (tmpImg != null && tmpImg.RampType != 0) {  						if (tmpImg.RampType == 7) veins = 51;  						else if (tmpImg.RampType == 2) veins = 55;  						else if (tmpImg.RampType == 3) veins = 57;  						else if (tmpImg.RampType == 4) veins = 59;  						else {  							continue;  						}  						rnd = 2;  						mul = 1;  					}  					else {  						var ne = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  						var se = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  						var sw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  						var nw = t.Layer.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);    						bool neV = ne != null && ne.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool seV = se != null && se.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool swV = sw != null && sw.AllObjects.OfType<OverlayObject>().Any(IsVeins);  						bool nwV = nw != null && nw.AllObjects.OfType<OverlayObject>().Any(IsVeins);    						int numNeighbours = CountNeighbouringVeins(ne' se' sw' nw' IsVeins);  						int threshold = numNeighbours != 4 ? 4 : 0;  						var compare = numNeighbours == 4 ? (Func<OverlayObject' bool>)IsFullVeins : IsVeins;  						Func<OverlayObject' bool> thresholdCompare = ov => threshold <= CountNeighbouringVeins(ov.Tile' compare);    						if (neV && ne.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 1;    						if (seV && se.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 2;    						if (swV && sw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 4;    						if (nwV && nw.AllObjects.OfType<OverlayObject>().Any(thresholdCompare))  							veins += 8;    						if (veins == 15 && !o.IsGeneratedVeins)  							veins++;    						mul = 3;  						rnd = 3;  					}  				}    				if (veins != 0 || amIVeins) {  					if (o == null) {  						// on the fly veins creation..  						o = new OverlayObject(anyVeins.OverlayID' (byte)Rand.Next(3));  						o.IsGeneratedVeins = true;  						o.Drawable = anyVeins.Drawable;  						o.Palette = anyVeins.Palette;  						o.TopTile = o.BottomTile = o.Tile;  						t.AddObject(o);  					}  					else {  						o.OverlayValue = (byte)(veins * mul + Rand.Next(rnd));  						Debug.WriteLine("Replacing veins with value {0} ({1})"' o.OverlayValue' veins);  					}  				}      			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,IsFullVeins,The following statement contains a magic number: return o != null && !o.IsGeneratedVeins && o.Drawable.IsVeins && (o.Drawable.IsVeinHoleMonster || o.OverlayValue / 3 == 16);
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,IsFullVeins,The following statement contains a magic number: return o != null && !o.IsGeneratedVeins && o.Drawable.IsVeins && (o.Drawable.IsVeinHoleMonster || o.OverlayValue / 3 == 16);
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,FixTiles,The following statement contains a magic number: foreach (MapTile t in tiles) {  				// If this tile is a LAT tile' we might have to connect it  				if (collection.IsLAT(t.SetNum)) {  					// Which tile to use from CLAT tileset  					byte transitionTile = 0;  					MapTile tileTopRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  					MapTile tileBottomRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  					MapTile tileBottomLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  					MapTile tileTopLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);      					// Find out setnums of adjacent cells  					if (tileTopRight != null && collection.ConnectTiles(t.SetNum' tileTopRight.SetNum))  						transitionTile += 1;    					if (tileBottomRight != null && collection.ConnectTiles(t.SetNum' tileBottomRight.SetNum))  						transitionTile += 2;    					if (tileBottomLeft != null && collection.ConnectTiles(t.SetNum' tileBottomLeft.SetNum))  						transitionTile += 4;    					if (tileTopLeft != null && collection.ConnectTiles(t.SetNum' tileTopLeft.SetNum))  						transitionTile += 8;    					if (transitionTile > 0) {  						// Find Tileset that contains the connecting pieces  						short clatSet = collection.GetCLATSet(t.SetNum);  						// Do not change this setnum' as then we could recognize it as  						// a different tileset for later tiles around this one.  						// (T->SetNum = clatSet;)  						t.TileNum = collection.GetTileNumFromSet(clatSet' transitionTile);  						t.Drawable = collection.GetDrawable(t);  					}  				}    				// apply ramp fixup  				else if (t.SetNum == collection.RampBase) {  					var ti = t.GetTileImage();  					if (ti.RampType < 1 || 4 < ti.TerrainType) continue;    					int fixup = -1;  					MapTile tileTopRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  					MapTile tileBottomRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  					MapTile tileBottomLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  					MapTile tileTopLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);      					switch (ti.RampType) {  						case 1:  							// northwest facing  							if (tileTopLeft != null && tileTopLeft.GetTileImage().RampType == 0)  								fixup++;  							if (tileBottomRight != null && tileBottomRight.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 2: // northeast facing  							if (tileTopRight != null && tileTopRight.GetTileImage().RampType == 0)  								fixup++;  							if (tileBottomLeft != null && tileBottomLeft.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 3: // southeast facing  							if (tileBottomRight != null && tileBottomRight.GetTileImage().RampType == 0)  								fixup++;  							if (tileTopLeft != null && tileTopLeft.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 4: // southwest facing  							if (tileBottomLeft != null && tileBottomLeft.GetTileImage().RampType == 0)  								fixup++;  							if (tileTopRight != null && tileTopRight.GetTileImage().RampType == 0)  								fixup += 2;  							break;  					}    					if (fixup != -1) {  						t.TileNum = collection.GetTileNumFromSet(collection.RampSmooth' (byte)((ti.RampType - 1) * 3 + fixup));  						// update drawable too  						t.Drawable = collection.GetDrawable(t);  					}  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,FixTiles,The following statement contains a magic number: foreach (MapTile t in tiles) {  				// If this tile is a LAT tile' we might have to connect it  				if (collection.IsLAT(t.SetNum)) {  					// Which tile to use from CLAT tileset  					byte transitionTile = 0;  					MapTile tileTopRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  					MapTile tileBottomRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  					MapTile tileBottomLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  					MapTile tileTopLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);      					// Find out setnums of adjacent cells  					if (tileTopRight != null && collection.ConnectTiles(t.SetNum' tileTopRight.SetNum))  						transitionTile += 1;    					if (tileBottomRight != null && collection.ConnectTiles(t.SetNum' tileBottomRight.SetNum))  						transitionTile += 2;    					if (tileBottomLeft != null && collection.ConnectTiles(t.SetNum' tileBottomLeft.SetNum))  						transitionTile += 4;    					if (tileTopLeft != null && collection.ConnectTiles(t.SetNum' tileTopLeft.SetNum))  						transitionTile += 8;    					if (transitionTile > 0) {  						// Find Tileset that contains the connecting pieces  						short clatSet = collection.GetCLATSet(t.SetNum);  						// Do not change this setnum' as then we could recognize it as  						// a different tileset for later tiles around this one.  						// (T->SetNum = clatSet;)  						t.TileNum = collection.GetTileNumFromSet(clatSet' transitionTile);  						t.Drawable = collection.GetDrawable(t);  					}  				}    				// apply ramp fixup  				else if (t.SetNum == collection.RampBase) {  					var ti = t.GetTileImage();  					if (ti.RampType < 1 || 4 < ti.TerrainType) continue;    					int fixup = -1;  					MapTile tileTopRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  					MapTile tileBottomRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  					MapTile tileBottomLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  					MapTile tileTopLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);      					switch (ti.RampType) {  						case 1:  							// northwest facing  							if (tileTopLeft != null && tileTopLeft.GetTileImage().RampType == 0)  								fixup++;  							if (tileBottomRight != null && tileBottomRight.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 2: // northeast facing  							if (tileTopRight != null && tileTopRight.GetTileImage().RampType == 0)  								fixup++;  							if (tileBottomLeft != null && tileBottomLeft.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 3: // southeast facing  							if (tileBottomRight != null && tileBottomRight.GetTileImage().RampType == 0)  								fixup++;  							if (tileTopLeft != null && tileTopLeft.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 4: // southwest facing  							if (tileBottomLeft != null && tileBottomLeft.GetTileImage().RampType == 0)  								fixup++;  							if (tileTopRight != null && tileTopRight.GetTileImage().RampType == 0)  								fixup += 2;  							break;  					}    					if (fixup != -1) {  						t.TileNum = collection.GetTileNumFromSet(collection.RampSmooth' (byte)((ti.RampType - 1) * 3 + fixup));  						// update drawable too  						t.Drawable = collection.GetDrawable(t);  					}  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,FixTiles,The following statement contains a magic number: foreach (MapTile t in tiles) {  				// If this tile is a LAT tile' we might have to connect it  				if (collection.IsLAT(t.SetNum)) {  					// Which tile to use from CLAT tileset  					byte transitionTile = 0;  					MapTile tileTopRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  					MapTile tileBottomRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  					MapTile tileBottomLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  					MapTile tileTopLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);      					// Find out setnums of adjacent cells  					if (tileTopRight != null && collection.ConnectTiles(t.SetNum' tileTopRight.SetNum))  						transitionTile += 1;    					if (tileBottomRight != null && collection.ConnectTiles(t.SetNum' tileBottomRight.SetNum))  						transitionTile += 2;    					if (tileBottomLeft != null && collection.ConnectTiles(t.SetNum' tileBottomLeft.SetNum))  						transitionTile += 4;    					if (tileTopLeft != null && collection.ConnectTiles(t.SetNum' tileTopLeft.SetNum))  						transitionTile += 8;    					if (transitionTile > 0) {  						// Find Tileset that contains the connecting pieces  						short clatSet = collection.GetCLATSet(t.SetNum);  						// Do not change this setnum' as then we could recognize it as  						// a different tileset for later tiles around this one.  						// (T->SetNum = clatSet;)  						t.TileNum = collection.GetTileNumFromSet(clatSet' transitionTile);  						t.Drawable = collection.GetDrawable(t);  					}  				}    				// apply ramp fixup  				else if (t.SetNum == collection.RampBase) {  					var ti = t.GetTileImage();  					if (ti.RampType < 1 || 4 < ti.TerrainType) continue;    					int fixup = -1;  					MapTile tileTopRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  					MapTile tileBottomRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  					MapTile tileBottomLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  					MapTile tileTopLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);      					switch (ti.RampType) {  						case 1:  							// northwest facing  							if (tileTopLeft != null && tileTopLeft.GetTileImage().RampType == 0)  								fixup++;  							if (tileBottomRight != null && tileBottomRight.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 2: // northeast facing  							if (tileTopRight != null && tileTopRight.GetTileImage().RampType == 0)  								fixup++;  							if (tileBottomLeft != null && tileBottomLeft.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 3: // southeast facing  							if (tileBottomRight != null && tileBottomRight.GetTileImage().RampType == 0)  								fixup++;  							if (tileTopLeft != null && tileTopLeft.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 4: // southwest facing  							if (tileBottomLeft != null && tileBottomLeft.GetTileImage().RampType == 0)  								fixup++;  							if (tileTopRight != null && tileTopRight.GetTileImage().RampType == 0)  								fixup += 2;  							break;  					}    					if (fixup != -1) {  						t.TileNum = collection.GetTileNumFromSet(collection.RampSmooth' (byte)((ti.RampType - 1) * 3 + fixup));  						// update drawable too  						t.Drawable = collection.GetDrawable(t);  					}  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,FixTiles,The following statement contains a magic number: foreach (MapTile t in tiles) {  				// If this tile is a LAT tile' we might have to connect it  				if (collection.IsLAT(t.SetNum)) {  					// Which tile to use from CLAT tileset  					byte transitionTile = 0;  					MapTile tileTopRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  					MapTile tileBottomRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  					MapTile tileBottomLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  					MapTile tileTopLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);      					// Find out setnums of adjacent cells  					if (tileTopRight != null && collection.ConnectTiles(t.SetNum' tileTopRight.SetNum))  						transitionTile += 1;    					if (tileBottomRight != null && collection.ConnectTiles(t.SetNum' tileBottomRight.SetNum))  						transitionTile += 2;    					if (tileBottomLeft != null && collection.ConnectTiles(t.SetNum' tileBottomLeft.SetNum))  						transitionTile += 4;    					if (tileTopLeft != null && collection.ConnectTiles(t.SetNum' tileTopLeft.SetNum))  						transitionTile += 8;    					if (transitionTile > 0) {  						// Find Tileset that contains the connecting pieces  						short clatSet = collection.GetCLATSet(t.SetNum);  						// Do not change this setnum' as then we could recognize it as  						// a different tileset for later tiles around this one.  						// (T->SetNum = clatSet;)  						t.TileNum = collection.GetTileNumFromSet(clatSet' transitionTile);  						t.Drawable = collection.GetDrawable(t);  					}  				}    				// apply ramp fixup  				else if (t.SetNum == collection.RampBase) {  					var ti = t.GetTileImage();  					if (ti.RampType < 1 || 4 < ti.TerrainType) continue;    					int fixup = -1;  					MapTile tileTopRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  					MapTile tileBottomRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  					MapTile tileBottomLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  					MapTile tileTopLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);      					switch (ti.RampType) {  						case 1:  							// northwest facing  							if (tileTopLeft != null && tileTopLeft.GetTileImage().RampType == 0)  								fixup++;  							if (tileBottomRight != null && tileBottomRight.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 2: // northeast facing  							if (tileTopRight != null && tileTopRight.GetTileImage().RampType == 0)  								fixup++;  							if (tileBottomLeft != null && tileBottomLeft.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 3: // southeast facing  							if (tileBottomRight != null && tileBottomRight.GetTileImage().RampType == 0)  								fixup++;  							if (tileTopLeft != null && tileTopLeft.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 4: // southwest facing  							if (tileBottomLeft != null && tileBottomLeft.GetTileImage().RampType == 0)  								fixup++;  							if (tileTopRight != null && tileTopRight.GetTileImage().RampType == 0)  								fixup += 2;  							break;  					}    					if (fixup != -1) {  						t.TileNum = collection.GetTileNumFromSet(collection.RampSmooth' (byte)((ti.RampType - 1) * 3 + fixup));  						// update drawable too  						t.Drawable = collection.GetDrawable(t);  					}  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,FixTiles,The following statement contains a magic number: foreach (MapTile t in tiles) {  				// If this tile is a LAT tile' we might have to connect it  				if (collection.IsLAT(t.SetNum)) {  					// Which tile to use from CLAT tileset  					byte transitionTile = 0;  					MapTile tileTopRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  					MapTile tileBottomRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  					MapTile tileBottomLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  					MapTile tileTopLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);      					// Find out setnums of adjacent cells  					if (tileTopRight != null && collection.ConnectTiles(t.SetNum' tileTopRight.SetNum))  						transitionTile += 1;    					if (tileBottomRight != null && collection.ConnectTiles(t.SetNum' tileBottomRight.SetNum))  						transitionTile += 2;    					if (tileBottomLeft != null && collection.ConnectTiles(t.SetNum' tileBottomLeft.SetNum))  						transitionTile += 4;    					if (tileTopLeft != null && collection.ConnectTiles(t.SetNum' tileTopLeft.SetNum))  						transitionTile += 8;    					if (transitionTile > 0) {  						// Find Tileset that contains the connecting pieces  						short clatSet = collection.GetCLATSet(t.SetNum);  						// Do not change this setnum' as then we could recognize it as  						// a different tileset for later tiles around this one.  						// (T->SetNum = clatSet;)  						t.TileNum = collection.GetTileNumFromSet(clatSet' transitionTile);  						t.Drawable = collection.GetDrawable(t);  					}  				}    				// apply ramp fixup  				else if (t.SetNum == collection.RampBase) {  					var ti = t.GetTileImage();  					if (ti.RampType < 1 || 4 < ti.TerrainType) continue;    					int fixup = -1;  					MapTile tileTopRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  					MapTile tileBottomRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  					MapTile tileBottomLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  					MapTile tileTopLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);      					switch (ti.RampType) {  						case 1:  							// northwest facing  							if (tileTopLeft != null && tileTopLeft.GetTileImage().RampType == 0)  								fixup++;  							if (tileBottomRight != null && tileBottomRight.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 2: // northeast facing  							if (tileTopRight != null && tileTopRight.GetTileImage().RampType == 0)  								fixup++;  							if (tileBottomLeft != null && tileBottomLeft.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 3: // southeast facing  							if (tileBottomRight != null && tileBottomRight.GetTileImage().RampType == 0)  								fixup++;  							if (tileTopLeft != null && tileTopLeft.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 4: // southwest facing  							if (tileBottomLeft != null && tileBottomLeft.GetTileImage().RampType == 0)  								fixup++;  							if (tileTopRight != null && tileTopRight.GetTileImage().RampType == 0)  								fixup += 2;  							break;  					}    					if (fixup != -1) {  						t.TileNum = collection.GetTileNumFromSet(collection.RampSmooth' (byte)((ti.RampType - 1) * 3 + fixup));  						// update drawable too  						t.Drawable = collection.GetDrawable(t);  					}  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,FixTiles,The following statement contains a magic number: foreach (MapTile t in tiles) {  				// If this tile is a LAT tile' we might have to connect it  				if (collection.IsLAT(t.SetNum)) {  					// Which tile to use from CLAT tileset  					byte transitionTile = 0;  					MapTile tileTopRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  					MapTile tileBottomRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  					MapTile tileBottomLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  					MapTile tileTopLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);      					// Find out setnums of adjacent cells  					if (tileTopRight != null && collection.ConnectTiles(t.SetNum' tileTopRight.SetNum))  						transitionTile += 1;    					if (tileBottomRight != null && collection.ConnectTiles(t.SetNum' tileBottomRight.SetNum))  						transitionTile += 2;    					if (tileBottomLeft != null && collection.ConnectTiles(t.SetNum' tileBottomLeft.SetNum))  						transitionTile += 4;    					if (tileTopLeft != null && collection.ConnectTiles(t.SetNum' tileTopLeft.SetNum))  						transitionTile += 8;    					if (transitionTile > 0) {  						// Find Tileset that contains the connecting pieces  						short clatSet = collection.GetCLATSet(t.SetNum);  						// Do not change this setnum' as then we could recognize it as  						// a different tileset for later tiles around this one.  						// (T->SetNum = clatSet;)  						t.TileNum = collection.GetTileNumFromSet(clatSet' transitionTile);  						t.Drawable = collection.GetDrawable(t);  					}  				}    				// apply ramp fixup  				else if (t.SetNum == collection.RampBase) {  					var ti = t.GetTileImage();  					if (ti.RampType < 1 || 4 < ti.TerrainType) continue;    					int fixup = -1;  					MapTile tileTopRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  					MapTile tileBottomRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  					MapTile tileBottomLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  					MapTile tileTopLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);      					switch (ti.RampType) {  						case 1:  							// northwest facing  							if (tileTopLeft != null && tileTopLeft.GetTileImage().RampType == 0)  								fixup++;  							if (tileBottomRight != null && tileBottomRight.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 2: // northeast facing  							if (tileTopRight != null && tileTopRight.GetTileImage().RampType == 0)  								fixup++;  							if (tileBottomLeft != null && tileBottomLeft.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 3: // southeast facing  							if (tileBottomRight != null && tileBottomRight.GetTileImage().RampType == 0)  								fixup++;  							if (tileTopLeft != null && tileTopLeft.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 4: // southwest facing  							if (tileBottomLeft != null && tileBottomLeft.GetTileImage().RampType == 0)  								fixup++;  							if (tileTopRight != null && tileTopRight.GetTileImage().RampType == 0)  								fixup += 2;  							break;  					}    					if (fixup != -1) {  						t.TileNum = collection.GetTileNumFromSet(collection.RampSmooth' (byte)((ti.RampType - 1) * 3 + fixup));  						// update drawable too  						t.Drawable = collection.GetDrawable(t);  					}  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,FixTiles,The following statement contains a magic number: foreach (MapTile t in tiles) {  				// If this tile is a LAT tile' we might have to connect it  				if (collection.IsLAT(t.SetNum)) {  					// Which tile to use from CLAT tileset  					byte transitionTile = 0;  					MapTile tileTopRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  					MapTile tileBottomRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  					MapTile tileBottomLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  					MapTile tileTopLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);      					// Find out setnums of adjacent cells  					if (tileTopRight != null && collection.ConnectTiles(t.SetNum' tileTopRight.SetNum))  						transitionTile += 1;    					if (tileBottomRight != null && collection.ConnectTiles(t.SetNum' tileBottomRight.SetNum))  						transitionTile += 2;    					if (tileBottomLeft != null && collection.ConnectTiles(t.SetNum' tileBottomLeft.SetNum))  						transitionTile += 4;    					if (tileTopLeft != null && collection.ConnectTiles(t.SetNum' tileTopLeft.SetNum))  						transitionTile += 8;    					if (transitionTile > 0) {  						// Find Tileset that contains the connecting pieces  						short clatSet = collection.GetCLATSet(t.SetNum);  						// Do not change this setnum' as then we could recognize it as  						// a different tileset for later tiles around this one.  						// (T->SetNum = clatSet;)  						t.TileNum = collection.GetTileNumFromSet(clatSet' transitionTile);  						t.Drawable = collection.GetDrawable(t);  					}  				}    				// apply ramp fixup  				else if (t.SetNum == collection.RampBase) {  					var ti = t.GetTileImage();  					if (ti.RampType < 1 || 4 < ti.TerrainType) continue;    					int fixup = -1;  					MapTile tileTopRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  					MapTile tileBottomRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  					MapTile tileBottomLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  					MapTile tileTopLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);      					switch (ti.RampType) {  						case 1:  							// northwest facing  							if (tileTopLeft != null && tileTopLeft.GetTileImage().RampType == 0)  								fixup++;  							if (tileBottomRight != null && tileBottomRight.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 2: // northeast facing  							if (tileTopRight != null && tileTopRight.GetTileImage().RampType == 0)  								fixup++;  							if (tileBottomLeft != null && tileBottomLeft.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 3: // southeast facing  							if (tileBottomRight != null && tileBottomRight.GetTileImage().RampType == 0)  								fixup++;  							if (tileTopLeft != null && tileTopLeft.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 4: // southwest facing  							if (tileBottomLeft != null && tileBottomLeft.GetTileImage().RampType == 0)  								fixup++;  							if (tileTopRight != null && tileTopRight.GetTileImage().RampType == 0)  								fixup += 2;  							break;  					}    					if (fixup != -1) {  						t.TileNum = collection.GetTileNumFromSet(collection.RampSmooth' (byte)((ti.RampType - 1) * 3 + fixup));  						// update drawable too  						t.Drawable = collection.GetDrawable(t);  					}  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,FixTiles,The following statement contains a magic number: foreach (MapTile t in tiles) {  				// If this tile is a LAT tile' we might have to connect it  				if (collection.IsLAT(t.SetNum)) {  					// Which tile to use from CLAT tileset  					byte transitionTile = 0;  					MapTile tileTopRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  					MapTile tileBottomRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  					MapTile tileBottomLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  					MapTile tileTopLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);      					// Find out setnums of adjacent cells  					if (tileTopRight != null && collection.ConnectTiles(t.SetNum' tileTopRight.SetNum))  						transitionTile += 1;    					if (tileBottomRight != null && collection.ConnectTiles(t.SetNum' tileBottomRight.SetNum))  						transitionTile += 2;    					if (tileBottomLeft != null && collection.ConnectTiles(t.SetNum' tileBottomLeft.SetNum))  						transitionTile += 4;    					if (tileTopLeft != null && collection.ConnectTiles(t.SetNum' tileTopLeft.SetNum))  						transitionTile += 8;    					if (transitionTile > 0) {  						// Find Tileset that contains the connecting pieces  						short clatSet = collection.GetCLATSet(t.SetNum);  						// Do not change this setnum' as then we could recognize it as  						// a different tileset for later tiles around this one.  						// (T->SetNum = clatSet;)  						t.TileNum = collection.GetTileNumFromSet(clatSet' transitionTile);  						t.Drawable = collection.GetDrawable(t);  					}  				}    				// apply ramp fixup  				else if (t.SetNum == collection.RampBase) {  					var ti = t.GetTileImage();  					if (ti.RampType < 1 || 4 < ti.TerrainType) continue;    					int fixup = -1;  					MapTile tileTopRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  					MapTile tileBottomRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  					MapTile tileBottomLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  					MapTile tileTopLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);      					switch (ti.RampType) {  						case 1:  							// northwest facing  							if (tileTopLeft != null && tileTopLeft.GetTileImage().RampType == 0)  								fixup++;  							if (tileBottomRight != null && tileBottomRight.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 2: // northeast facing  							if (tileTopRight != null && tileTopRight.GetTileImage().RampType == 0)  								fixup++;  							if (tileBottomLeft != null && tileBottomLeft.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 3: // southeast facing  							if (tileBottomRight != null && tileBottomRight.GetTileImage().RampType == 0)  								fixup++;  							if (tileTopLeft != null && tileTopLeft.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 4: // southwest facing  							if (tileBottomLeft != null && tileBottomLeft.GetTileImage().RampType == 0)  								fixup++;  							if (tileTopRight != null && tileTopRight.GetTileImage().RampType == 0)  								fixup += 2;  							break;  					}    					if (fixup != -1) {  						t.TileNum = collection.GetTileNumFromSet(collection.RampSmooth' (byte)((ti.RampType - 1) * 3 + fixup));  						// update drawable too  						t.Drawable = collection.GetDrawable(t);  					}  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,FixTiles,The following statement contains a magic number: foreach (MapTile t in tiles) {  				// If this tile is a LAT tile' we might have to connect it  				if (collection.IsLAT(t.SetNum)) {  					// Which tile to use from CLAT tileset  					byte transitionTile = 0;  					MapTile tileTopRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  					MapTile tileBottomRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  					MapTile tileBottomLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  					MapTile tileTopLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);      					// Find out setnums of adjacent cells  					if (tileTopRight != null && collection.ConnectTiles(t.SetNum' tileTopRight.SetNum))  						transitionTile += 1;    					if (tileBottomRight != null && collection.ConnectTiles(t.SetNum' tileBottomRight.SetNum))  						transitionTile += 2;    					if (tileBottomLeft != null && collection.ConnectTiles(t.SetNum' tileBottomLeft.SetNum))  						transitionTile += 4;    					if (tileTopLeft != null && collection.ConnectTiles(t.SetNum' tileTopLeft.SetNum))  						transitionTile += 8;    					if (transitionTile > 0) {  						// Find Tileset that contains the connecting pieces  						short clatSet = collection.GetCLATSet(t.SetNum);  						// Do not change this setnum' as then we could recognize it as  						// a different tileset for later tiles around this one.  						// (T->SetNum = clatSet;)  						t.TileNum = collection.GetTileNumFromSet(clatSet' transitionTile);  						t.Drawable = collection.GetDrawable(t);  					}  				}    				// apply ramp fixup  				else if (t.SetNum == collection.RampBase) {  					var ti = t.GetTileImage();  					if (ti.RampType < 1 || 4 < ti.TerrainType) continue;    					int fixup = -1;  					MapTile tileTopRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  					MapTile tileBottomRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  					MapTile tileBottomLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  					MapTile tileTopLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);      					switch (ti.RampType) {  						case 1:  							// northwest facing  							if (tileTopLeft != null && tileTopLeft.GetTileImage().RampType == 0)  								fixup++;  							if (tileBottomRight != null && tileBottomRight.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 2: // northeast facing  							if (tileTopRight != null && tileTopRight.GetTileImage().RampType == 0)  								fixup++;  							if (tileBottomLeft != null && tileBottomLeft.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 3: // southeast facing  							if (tileBottomRight != null && tileBottomRight.GetTileImage().RampType == 0)  								fixup++;  							if (tileTopLeft != null && tileTopLeft.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 4: // southwest facing  							if (tileBottomLeft != null && tileBottomLeft.GetTileImage().RampType == 0)  								fixup++;  							if (tileTopRight != null && tileTopRight.GetTileImage().RampType == 0)  								fixup += 2;  							break;  					}    					if (fixup != -1) {  						t.TileNum = collection.GetTileNumFromSet(collection.RampSmooth' (byte)((ti.RampType - 1) * 3 + fixup));  						// update drawable too  						t.Drawable = collection.GetDrawable(t);  					}  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,FixTiles,The following statement contains a magic number: foreach (MapTile t in tiles) {  				// If this tile is a LAT tile' we might have to connect it  				if (collection.IsLAT(t.SetNum)) {  					// Which tile to use from CLAT tileset  					byte transitionTile = 0;  					MapTile tileTopRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  					MapTile tileBottomRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  					MapTile tileBottomLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  					MapTile tileTopLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);      					// Find out setnums of adjacent cells  					if (tileTopRight != null && collection.ConnectTiles(t.SetNum' tileTopRight.SetNum))  						transitionTile += 1;    					if (tileBottomRight != null && collection.ConnectTiles(t.SetNum' tileBottomRight.SetNum))  						transitionTile += 2;    					if (tileBottomLeft != null && collection.ConnectTiles(t.SetNum' tileBottomLeft.SetNum))  						transitionTile += 4;    					if (tileTopLeft != null && collection.ConnectTiles(t.SetNum' tileTopLeft.SetNum))  						transitionTile += 8;    					if (transitionTile > 0) {  						// Find Tileset that contains the connecting pieces  						short clatSet = collection.GetCLATSet(t.SetNum);  						// Do not change this setnum' as then we could recognize it as  						// a different tileset for later tiles around this one.  						// (T->SetNum = clatSet;)  						t.TileNum = collection.GetTileNumFromSet(clatSet' transitionTile);  						t.Drawable = collection.GetDrawable(t);  					}  				}    				// apply ramp fixup  				else if (t.SetNum == collection.RampBase) {  					var ti = t.GetTileImage();  					if (ti.RampType < 1 || 4 < ti.TerrainType) continue;    					int fixup = -1;  					MapTile tileTopRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  					MapTile tileBottomRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  					MapTile tileBottomLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  					MapTile tileTopLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);      					switch (ti.RampType) {  						case 1:  							// northwest facing  							if (tileTopLeft != null && tileTopLeft.GetTileImage().RampType == 0)  								fixup++;  							if (tileBottomRight != null && tileBottomRight.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 2: // northeast facing  							if (tileTopRight != null && tileTopRight.GetTileImage().RampType == 0)  								fixup++;  							if (tileBottomLeft != null && tileBottomLeft.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 3: // southeast facing  							if (tileBottomRight != null && tileBottomRight.GetTileImage().RampType == 0)  								fixup++;  							if (tileTopLeft != null && tileTopLeft.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 4: // southwest facing  							if (tileBottomLeft != null && tileBottomLeft.GetTileImage().RampType == 0)  								fixup++;  							if (tileTopRight != null && tileTopRight.GetTileImage().RampType == 0)  								fixup += 2;  							break;  					}    					if (fixup != -1) {  						t.TileNum = collection.GetTileNumFromSet(collection.RampSmooth' (byte)((ti.RampType - 1) * 3 + fixup));  						// update drawable too  						t.Drawable = collection.GetDrawable(t);  					}  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,FixTiles,The following statement contains a magic number: foreach (MapTile t in tiles) {  				// If this tile is a LAT tile' we might have to connect it  				if (collection.IsLAT(t.SetNum)) {  					// Which tile to use from CLAT tileset  					byte transitionTile = 0;  					MapTile tileTopRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  					MapTile tileBottomRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  					MapTile tileBottomLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  					MapTile tileTopLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);      					// Find out setnums of adjacent cells  					if (tileTopRight != null && collection.ConnectTiles(t.SetNum' tileTopRight.SetNum))  						transitionTile += 1;    					if (tileBottomRight != null && collection.ConnectTiles(t.SetNum' tileBottomRight.SetNum))  						transitionTile += 2;    					if (tileBottomLeft != null && collection.ConnectTiles(t.SetNum' tileBottomLeft.SetNum))  						transitionTile += 4;    					if (tileTopLeft != null && collection.ConnectTiles(t.SetNum' tileTopLeft.SetNum))  						transitionTile += 8;    					if (transitionTile > 0) {  						// Find Tileset that contains the connecting pieces  						short clatSet = collection.GetCLATSet(t.SetNum);  						// Do not change this setnum' as then we could recognize it as  						// a different tileset for later tiles around this one.  						// (T->SetNum = clatSet;)  						t.TileNum = collection.GetTileNumFromSet(clatSet' transitionTile);  						t.Drawable = collection.GetDrawable(t);  					}  				}    				// apply ramp fixup  				else if (t.SetNum == collection.RampBase) {  					var ti = t.GetTileImage();  					if (ti.RampType < 1 || 4 < ti.TerrainType) continue;    					int fixup = -1;  					MapTile tileTopRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  					MapTile tileBottomRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  					MapTile tileBottomLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  					MapTile tileTopLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);      					switch (ti.RampType) {  						case 1:  							// northwest facing  							if (tileTopLeft != null && tileTopLeft.GetTileImage().RampType == 0)  								fixup++;  							if (tileBottomRight != null && tileBottomRight.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 2: // northeast facing  							if (tileTopRight != null && tileTopRight.GetTileImage().RampType == 0)  								fixup++;  							if (tileBottomLeft != null && tileBottomLeft.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 3: // southeast facing  							if (tileBottomRight != null && tileBottomRight.GetTileImage().RampType == 0)  								fixup++;  							if (tileTopLeft != null && tileTopLeft.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 4: // southwest facing  							if (tileBottomLeft != null && tileBottomLeft.GetTileImage().RampType == 0)  								fixup++;  							if (tileTopRight != null && tileTopRight.GetTileImage().RampType == 0)  								fixup += 2;  							break;  					}    					if (fixup != -1) {  						t.TileNum = collection.GetTileNumFromSet(collection.RampSmooth' (byte)((ti.RampType - 1) * 3 + fixup));  						// update drawable too  						t.Drawable = collection.GetDrawable(t);  					}  				}    			}
Magic Number,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,FixTiles,The following statement contains a magic number: foreach (MapTile t in tiles) {  				// If this tile is a LAT tile' we might have to connect it  				if (collection.IsLAT(t.SetNum)) {  					// Which tile to use from CLAT tileset  					byte transitionTile = 0;  					MapTile tileTopRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  					MapTile tileBottomRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  					MapTile tileBottomLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  					MapTile tileTopLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);      					// Find out setnums of adjacent cells  					if (tileTopRight != null && collection.ConnectTiles(t.SetNum' tileTopRight.SetNum))  						transitionTile += 1;    					if (tileBottomRight != null && collection.ConnectTiles(t.SetNum' tileBottomRight.SetNum))  						transitionTile += 2;    					if (tileBottomLeft != null && collection.ConnectTiles(t.SetNum' tileBottomLeft.SetNum))  						transitionTile += 4;    					if (tileTopLeft != null && collection.ConnectTiles(t.SetNum' tileTopLeft.SetNum))  						transitionTile += 8;    					if (transitionTile > 0) {  						// Find Tileset that contains the connecting pieces  						short clatSet = collection.GetCLATSet(t.SetNum);  						// Do not change this setnum' as then we could recognize it as  						// a different tileset for later tiles around this one.  						// (T->SetNum = clatSet;)  						t.TileNum = collection.GetTileNumFromSet(clatSet' transitionTile);  						t.Drawable = collection.GetDrawable(t);  					}  				}    				// apply ramp fixup  				else if (t.SetNum == collection.RampBase) {  					var ti = t.GetTileImage();  					if (ti.RampType < 1 || 4 < ti.TerrainType) continue;    					int fixup = -1;  					MapTile tileTopRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopRight);  					MapTile tileBottomRight = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomRight);  					MapTile tileBottomLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.BottomLeft);  					MapTile tileTopLeft = tiles.GetNeighbourTile(t' TileLayer.TileDirection.TopLeft);      					switch (ti.RampType) {  						case 1:  							// northwest facing  							if (tileTopLeft != null && tileTopLeft.GetTileImage().RampType == 0)  								fixup++;  							if (tileBottomRight != null && tileBottomRight.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 2: // northeast facing  							if (tileTopRight != null && tileTopRight.GetTileImage().RampType == 0)  								fixup++;  							if (tileBottomLeft != null && tileBottomLeft.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 3: // southeast facing  							if (tileBottomRight != null && tileBottomRight.GetTileImage().RampType == 0)  								fixup++;  							if (tileTopLeft != null && tileTopLeft.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 4: // southwest facing  							if (tileBottomLeft != null && tileBottomLeft.GetTileImage().RampType == 0)  								fixup++;  							if (tileTopRight != null && tileTopRight.GetTileImage().RampType == 0)  								fixup += 2;  							break;  					}    					if (fixup != -1) {  						t.TileNum = collection.GetTileNumFromSet(collection.RampSmooth' (byte)((ti.RampType - 1) * 3 + fixup));  						// update drawable too  						t.Drawable = collection.GetDrawable(t);  					}  				}    			}
Magic Number,CNCMaps.Engine.Map,ThumbInjector,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ThumbInjector.cs,InjectThumb,The following statement contains a magic number: byte[] image = new byte[preview.Width * preview.Height * 3];
Magic Number,CNCMaps.Engine.Map,ThumbInjector,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ThumbInjector.cs,InjectThumb,The following statement contains a magic number: byte[] image_compressed = Format5.Encode(image' 5);
Magic Number,CNCMaps.Engine.Map,ThumbInjector,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ThumbInjector.cs,InjectThumb,The following statement contains a magic number: for (int i = 0; i < image_base64.Length; i += 70) {  				section.SetValue(rowNum++.ToString(CultureInfo.InvariantCulture)' image_base64.Substring(i' Math.Min(70' image_base64.Length - i)));  			}
Magic Number,CNCMaps.Engine.Map,ThumbInjector,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ThumbInjector.cs,InjectThumb,The following statement contains a magic number: for (int i = 0; i < image_base64.Length; i += 70) {  				section.SetValue(rowNum++.ToString(CultureInfo.InvariantCulture)' image_base64.Substring(i' Math.Min(70' image_base64.Length - i)));  			}
Magic Number,CNCMaps.Engine.Map,ThumbInjector,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ThumbInjector.cs,ExtractThumb,The following statement contains a magic number: var previewSize = new Rectangle(int.Parse(size[0])' int.Parse(size[1])' int.Parse(size[2])' int.Parse(size[3]));
Magic Number,CNCMaps.Engine.Map,ThumbInjector,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ThumbInjector.cs,ExtractThumb,The following statement contains a magic number: var previewSize = new Rectangle(int.Parse(size[0])' int.Parse(size[1])' int.Parse(size[2])' int.Parse(size[3]));
Magic Number,CNCMaps.Engine.Map,ThumbInjector,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ThumbInjector.cs,ExtractThumb,The following statement contains a magic number: byte[] image = new byte[preview.Width * preview.Height * 3];
Magic Number,CNCMaps.Engine.Map,ThumbInjector,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ThumbInjector.cs,ExtractThumb,The following statement contains a magic number: Format5.DecodeInto(image_compressed' image' 5);
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,TileLayer,The following statement contains a magic number: tiles = new MapTile[fullSize.Width * 2 - 1' fullSize.Height];
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,TileLayer,The following statement contains a magic number: GridTouched = new TouchType[fullSize.Width * 2 - 1' fullSize.Height];
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,TileLayer,The following statement contains a magic number: GridTouchedBy = new MapTile[fullSize.Width * 2 - 1' fullSize.Height];
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetTileR,The following statement contains a magic number: if (dx < 0 || dy < 0 || dx >= tiles.GetLength(0) || (dy / 2) >= tiles.GetLength(1)) {  				logger.Trace("Referencing empty tile at (rx'ry)=({0}'{1}); (dx'dy)=({2}'{3})"' rx' ry' dx' dy);  				return null;  			}  			else  				return GetTile(dx' dy / 2);
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetTileR,The following statement contains a magic number: if (dx < 0 || dy < 0 || dx >= tiles.GetLength(0) || (dy / 2) >= tiles.GetLength(1)) {  				logger.Trace("Referencing empty tile at (rx'ry)=({0}'{1}); (dx'dy)=({2}'{3})"' rx' ry' dx' dy);  				return null;  			}  			else  				return GetTile(dx' dy / 2);
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetTilePixelCenter,The following statement contains a magic number: var ret = new Point(t.Dx * Drawable.TileWidth / 2' (t.Dy - t.Z) * Drawable.TileHeight);
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetTilePixelCenter,The following statement contains a magic number: ret.Offset(Drawable.TileWidth / 2' Drawable.TileHeight / 2);
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetTilePixelCenter,The following statement contains a magic number: ret.Offset(Drawable.TileWidth / 2' Drawable.TileHeight / 2);
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetTileScreen,The following statement contains a magic number: int w = Drawable.TileWidth / 2;
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetTileScreen,The following statement contains a magic number: int h = Drawable.TileHeight / 2;
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetTileScreen,The following statement contains a magic number: int rx = (p.X * h + p.Y * w - fx * h - fy * w) / (2 * w * h);
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetTileScreen,The following statement contains a magic number: int ry = (p.X * -h + p.Y * w + fx * h - fy * w) / (2 * w * h);
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetTileScreen,The following statement contains a magic number: if (fixOOB) {  				dx = Math.Min(Width * 2 - 2' Math.Max(0' dx));  				dy = Math.Min(Height * 2 - 2' Math.Max(0' dy));  			}
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetTileScreen,The following statement contains a magic number: if (fixOOB) {  				dx = Math.Min(Width * 2 - 2' Math.Max(0' dx));  				dy = Math.Min(Height * 2 - 2' Math.Max(0' dy));  			}
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetTileScreen,The following statement contains a magic number: if (fixOOB) {  				dx = Math.Min(Width * 2 - 2' Math.Max(0' dx));  				dy = Math.Min(Height * 2 - 2' Math.Max(0' dy));  			}
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetTileScreen,The following statement contains a magic number: if (fixOOB) {  				dx = Math.Min(Width * 2 - 2' Math.Max(0' dx));  				dy = Math.Min(Height * 2 - 2' Math.Max(0' dy));  			}
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetTileScreen,The following statement contains a magic number: var tile_noheight = this[dx' dy / 2];
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetTileScreen,The following statement contains a magic number: if (fixOOB)  				dy = Math.Min(Height * 2 - 2' Math.Max(0' dy));
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetTileScreen,The following statement contains a magic number: if (fixOOB)  				dy = Math.Min(Height * 2 - 2' Math.Max(0' dy));
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetTileScreen,The following statement contains a magic number: return this[dx' dy / 2];
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,testNeighbours,The following statement contains a magic number: testNeighbours(15' 9);
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,testNeighbours,The following statement contains a magic number: testNeighbours(15' 9);
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,testNeighbours,The following statement contains a magic number: testNeighbours(14' 13);
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,testNeighbours,The following statement contains a magic number: testNeighbours(14' 13);
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,testNeighbours,The following statement contains a magic number: Debug.Assert(GetNeighbourTile(x' y' TileDirection.Bottom).Dx == x_ + 0 && GetNeighbourTile(x' y' TileDirection.Bottom).Dy == y_ + 2);
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,testNeighbours,The following statement contains a magic number: Debug.Assert(GetNeighbourTile(x' y' TileDirection.Left).Dx == x_ - 2 && GetNeighbourTile(x' y' TileDirection.Left).Dy == y_ + 0);
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,testNeighbours,The following statement contains a magic number: Debug.Assert(GetNeighbourTile(x' y' TileDirection.Right).Dx == x_ + 2 && GetNeighbourTile(x' y' TileDirection.Right).Dy == y_ + 0);
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,testNeighbours,The following statement contains a magic number: Debug.Assert(GetNeighbourTile(x' y' TileDirection.Top).Dx == x_ + 0 && GetNeighbourTile(x' y' TileDirection.Top).Dy == y_ - 2);
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetNeighbourTile,The following statement contains a magic number: int y = (t.Dy + (t.Dx + 1) % 2) / 2;
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetNeighbourTile,The following statement contains a magic number: int y = (t.Dy + (t.Dx + 1) % 2) / 2;
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetNeighbourTile,The following statement contains a magic number: switch (direction) {  				// in non-diagonal direction we don't need to check odd/evenness of x  				case TileDirection.Bottom:  					if (y >= tiles.GetLength(1)) return null;  					return this[x' y + 1];    				case TileDirection.Top:  					if (y < 2) return null;  					return this[x' y - 1];    				case TileDirection.Left:  					if (x < 2) return null;  					return this[x - 2' y];    				case TileDirection.Right:  					if (x >= tiles.GetLength(0) - 1) return null;  					return this[x + 2' y];  			}
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetNeighbourTile,The following statement contains a magic number: switch (direction) {  				// in non-diagonal direction we don't need to check odd/evenness of x  				case TileDirection.Bottom:  					if (y >= tiles.GetLength(1)) return null;  					return this[x' y + 1];    				case TileDirection.Top:  					if (y < 2) return null;  					return this[x' y - 1];    				case TileDirection.Left:  					if (x < 2) return null;  					return this[x - 2' y];    				case TileDirection.Right:  					if (x >= tiles.GetLength(0) - 1) return null;  					return this[x + 2' y];  			}
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetNeighbourTile,The following statement contains a magic number: switch (direction) {  				// in non-diagonal direction we don't need to check odd/evenness of x  				case TileDirection.Bottom:  					if (y >= tiles.GetLength(1)) return null;  					return this[x' y + 1];    				case TileDirection.Top:  					if (y < 2) return null;  					return this[x' y - 1];    				case TileDirection.Left:  					if (x < 2) return null;  					return this[x - 2' y];    				case TileDirection.Right:  					if (x >= tiles.GetLength(0) - 1) return null;  					return this[x + 2' y];  			}
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetNeighbourTile,The following statement contains a magic number: switch (direction) {  				// in non-diagonal direction we don't need to check odd/evenness of x  				case TileDirection.Bottom:  					if (y >= tiles.GetLength(1)) return null;  					return this[x' y + 1];    				case TileDirection.Top:  					if (y < 2) return null;  					return this[x' y - 1];    				case TileDirection.Left:  					if (x < 2) return null;  					return this[x - 2' y];    				case TileDirection.Right:  					if (x >= tiles.GetLength(0) - 1) return null;  					return this[x + 2' y];  			}
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetNeighbourTile,The following statement contains a magic number: y += x % 2;
Magic Number,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetTile,The following statement contains a magic number: return this[isoTile.Dx' isoTile.Dy / 2];
Magic Number,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,LoadFromRulesFull,The following statement contains a magic number: if (Rules.ReadBool("Wall")) {  				IsWall = true;  				Flat = false;  				IsBuildingPart = true;  				// RA2 walls appear a bit higher  				if (OwnerCollection.Engine >= EngineType.RedAlert2) {  					Props.Offset.Offset(0' 3); // seems walls are located 3 pixels lower  				}  				Props.PaletteType = PaletteType.Unit;  				Props.LightingType = LightingType.Ambient;  				Props.FrameDecider = FrameDeciders.OverlayValueFrameDecider;  			}
Magic Number,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,LoadFromRulesFull,The following statement contains a magic number: if (Rules.ReadBool("IsVeinholeMonster")) {  				Props.Offset.Y = -49; // why is this needed???  				Props.LightingType = LightingType.None;  				Props.PaletteType = PaletteType.Unit;  				IsVeinHoleMonster = true;  			}
Magic Number,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,LoadFromRulesFull,The following statement contains a magic number: if (Rules.ReadString("Land") == "Rock") {  				Props.Offset.Y += TileHeight / 2;  				//mainProps.ZBufferAdjust += Drawable.TileHeight / 2;  			}  			else if (Rules.ReadString("Land") == "Road") {  				Props.Offset.Y += TileHeight / 2;  				// drawable.Foundation = new Size(3' 1); // ensures bridges are drawn a bit lower than where they're stored  			}  			else if (Rules.ReadString("Land") == "Railroad") {  				if (OwnerCollection.Engine <= EngineType.Firestorm)  					Props.Offset.Y = 11;  				else  					Props.Offset.Y = 14;  				Props.LightingType = LightingType.Full;  				Props.PaletteType = PaletteType.Iso;  				// Foundation = new Size(2' 2); // hack to get these later in the drawing order  			}
Magic Number,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,LoadFromRulesFull,The following statement contains a magic number: if (Rules.ReadString("Land") == "Rock") {  				Props.Offset.Y += TileHeight / 2;  				//mainProps.ZBufferAdjust += Drawable.TileHeight / 2;  			}  			else if (Rules.ReadString("Land") == "Road") {  				Props.Offset.Y += TileHeight / 2;  				// drawable.Foundation = new Size(3' 1); // ensures bridges are drawn a bit lower than where they're stored  			}  			else if (Rules.ReadString("Land") == "Railroad") {  				if (OwnerCollection.Engine <= EngineType.Firestorm)  					Props.Offset.Y = 11;  				else  					Props.Offset.Y = 14;  				Props.LightingType = LightingType.Full;  				Props.PaletteType = PaletteType.Iso;  				// Foundation = new Size(2' 2); // hack to get these later in the drawing order  			}
Magic Number,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,LoadFromRulesFull,The following statement contains a magic number: if (Rules.ReadString("Land") == "Rock") {  				Props.Offset.Y += TileHeight / 2;  				//mainProps.ZBufferAdjust += Drawable.TileHeight / 2;  			}  			else if (Rules.ReadString("Land") == "Road") {  				Props.Offset.Y += TileHeight / 2;  				// drawable.Foundation = new Size(3' 1); // ensures bridges are drawn a bit lower than where they're stored  			}  			else if (Rules.ReadString("Land") == "Railroad") {  				if (OwnerCollection.Engine <= EngineType.Firestorm)  					Props.Offset.Y = 11;  				else  					Props.Offset.Y = 14;  				Props.LightingType = LightingType.Full;  				Props.PaletteType = PaletteType.Iso;  				// Foundation = new Size(2' 2); // hack to get these later in the drawing order  			}
Magic Number,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,LoadFromRulesFull,The following statement contains a magic number: if (Rules.ReadString("Land") == "Rock") {  				Props.Offset.Y += TileHeight / 2;  				//mainProps.ZBufferAdjust += Drawable.TileHeight / 2;  			}  			else if (Rules.ReadString("Land") == "Road") {  				Props.Offset.Y += TileHeight / 2;  				// drawable.Foundation = new Size(3' 1); // ensures bridges are drawn a bit lower than where they're stored  			}  			else if (Rules.ReadString("Land") == "Railroad") {  				if (OwnerCollection.Engine <= EngineType.Firestorm)  					Props.Offset.Y = 11;  				else  					Props.Offset.Y = 14;  				Props.LightingType = LightingType.Full;  				Props.PaletteType = PaletteType.Iso;  				// Foundation = new Size(2' 2); // hack to get these later in the drawing order  			}
Magic Number,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,LoadFromRulesFull,The following statement contains a magic number: Facings = 8;
Magic Number,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,DrawBoundingBox,The following statement contains a magic number: verts.Add(new Point(top.Dx * TileWidth / 2' top.Dy * TileHeight / 2));
Magic Number,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,DrawBoundingBox,The following statement contains a magic number: verts.Add(new Point(top.Dx * TileWidth / 2' top.Dy * TileHeight / 2));
Magic Number,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,DrawBoundingBox,The following statement contains a magic number: verts.Add(new Point(left.Dx * TileWidth / 2 - TileWidth / 4' left.Dy * TileHeight / 2 + TileHeight / 4));
Magic Number,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,DrawBoundingBox,The following statement contains a magic number: verts.Add(new Point(left.Dx * TileWidth / 2 - TileWidth / 4' left.Dy * TileHeight / 2 + TileHeight / 4));
Magic Number,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,DrawBoundingBox,The following statement contains a magic number: verts.Add(new Point(left.Dx * TileWidth / 2 - TileWidth / 4' left.Dy * TileHeight / 2 + TileHeight / 4));
Magic Number,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,DrawBoundingBox,The following statement contains a magic number: verts.Add(new Point(left.Dx * TileWidth / 2 - TileWidth / 4' left.Dy * TileHeight / 2 + TileHeight / 4));
Magic Number,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,DrawBoundingBox,The following statement contains a magic number: verts.Add(new Point(bottom.Dx * TileWidth / 2' bottom.Dy * TileHeight / 2 + TileHeight / 2));
Magic Number,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,DrawBoundingBox,The following statement contains a magic number: verts.Add(new Point(bottom.Dx * TileWidth / 2' bottom.Dy * TileHeight / 2 + TileHeight / 2));
Magic Number,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,DrawBoundingBox,The following statement contains a magic number: verts.Add(new Point(bottom.Dx * TileWidth / 2' bottom.Dy * TileHeight / 2 + TileHeight / 2));
Magic Number,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,DrawBoundingBox,The following statement contains a magic number: verts.Add(new Point(right.Dx * TileWidth / 2 + TileHeight / 2' right.Dy * TileHeight / 2 + TileHeight / 4));
Magic Number,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,DrawBoundingBox,The following statement contains a magic number: verts.Add(new Point(right.Dx * TileWidth / 2 + TileHeight / 2' right.Dy * TileHeight / 2 + TileHeight / 4));
Magic Number,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,DrawBoundingBox,The following statement contains a magic number: verts.Add(new Point(right.Dx * TileWidth / 2 + TileHeight / 2' right.Dy * TileHeight / 2 + TileHeight / 4));
Magic Number,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,DrawBoundingBox,The following statement contains a magic number: verts.Add(new Point(right.Dx * TileWidth / 2 + TileHeight / 2' right.Dy * TileHeight / 2 + TileHeight / 4));
Magic Number,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,DrawBoundingBox,The following statement contains a magic number: verts.Add(new Point(top.Dx * TileWidth / 2' top.Dy * TileHeight / 2));
Magic Number,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,DrawBoundingBox,The following statement contains a magic number: verts.Add(new Point(top.Dx * TileWidth / 2' top.Dy * TileHeight / 2));
Magic Number,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,DrawBoundingBox,The following statement contains a magic number: foreach (var p in verts) {  				p.Offset(30' -15);  				verts2.Add(p);  			}
Magic Number,CNCMaps.Engine.Drawables,Drawable,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Drawables\Drawable.cs,DrawBoundingBox,The following statement contains a magic number: foreach (var p in verts) {  				p.Offset(30' -15);  				verts2.Add(p);  			}
Magic Number,CNCMaps.Engine.Rendering,DebugDrawingSurfaceWindow,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\DebugDrawingSurfaceWindow.cs,pictureBox1_MouseMove,The following statement contains a magic number: if (tile == null || !(tile.Drawable is TileDrawable)) {  				sb.Append("No valid tile under mouse");  			}  			else {  				var tileFile = (tile.Drawable as TileDrawable).GetTileFile(tile);  				sb.AppendFormat("   Tile {4}: d({0}'{1}) r({2}'{3})"' tile.Dx' tile.Dy' tile.Rx' tile.Ry' (tileFile?.FileName??"").ToUpper());  				if (tileFile != null) {  					if (tileFile.Images[tile.SubTile].RampType != 0)  						sb.AppendFormat(" ramp {0}"' tileFile.Images[tile.SubTile].RampType);  					if (tileFile.Images[tile.SubTile].TerrainType != 0)  						sb.AppendFormat(" terrain {0}"' tileFile.Images[tile.SubTile].TerrainType);  				}  				var gridTilenoZ = _tiles.GetTileScreen(e.Location' true' true);  				sb.AppendFormat("   Touched: {0}"' _tiles.GridTouched[gridTilenoZ.Dx' gridTilenoZ.Dy / 2]);    				if (_tiles.GridTouchedBy[gridTilenoZ.Dx' gridTilenoZ.Dy / 2] != null)  					sb.AppendFormat(" by {0} "' _tiles.GridTouchedBy[gridTilenoZ.Dx' gridTilenoZ.Dy / 2]);    				sb.AppendFormat("   Z-buf: {0}"' _drawingSurface.GetZBuffer()[rIdx]);  				sb.AppendFormat("   S-buf: {0}"' _drawingSurface.GetShadows()[rIdx]);    				var objs = _map.GetObjectsAt(tile.Dx' tile.Dy / 2);  				if (objs.Any()) {  					sb.Append("   Objects: ");  					foreach (var obj in objs) {  						sb.Append(obj);    						if (obj is OverlayObject) {  							var ovl = (obj as OverlayObject);  							if (ovl.IsGeneratedVeins)  								sb.Append("(gen)");  						}    						sb.Append(" ");  					}  				}  			}
Magic Number,CNCMaps.Engine.Rendering,DebugDrawingSurfaceWindow,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\DebugDrawingSurfaceWindow.cs,pictureBox1_MouseMove,The following statement contains a magic number: if (tile == null || !(tile.Drawable is TileDrawable)) {  				sb.Append("No valid tile under mouse");  			}  			else {  				var tileFile = (tile.Drawable as TileDrawable).GetTileFile(tile);  				sb.AppendFormat("   Tile {4}: d({0}'{1}) r({2}'{3})"' tile.Dx' tile.Dy' tile.Rx' tile.Ry' (tileFile?.FileName??"").ToUpper());  				if (tileFile != null) {  					if (tileFile.Images[tile.SubTile].RampType != 0)  						sb.AppendFormat(" ramp {0}"' tileFile.Images[tile.SubTile].RampType);  					if (tileFile.Images[tile.SubTile].TerrainType != 0)  						sb.AppendFormat(" terrain {0}"' tileFile.Images[tile.SubTile].TerrainType);  				}  				var gridTilenoZ = _tiles.GetTileScreen(e.Location' true' true);  				sb.AppendFormat("   Touched: {0}"' _tiles.GridTouched[gridTilenoZ.Dx' gridTilenoZ.Dy / 2]);    				if (_tiles.GridTouchedBy[gridTilenoZ.Dx' gridTilenoZ.Dy / 2] != null)  					sb.AppendFormat(" by {0} "' _tiles.GridTouchedBy[gridTilenoZ.Dx' gridTilenoZ.Dy / 2]);    				sb.AppendFormat("   Z-buf: {0}"' _drawingSurface.GetZBuffer()[rIdx]);  				sb.AppendFormat("   S-buf: {0}"' _drawingSurface.GetShadows()[rIdx]);    				var objs = _map.GetObjectsAt(tile.Dx' tile.Dy / 2);  				if (objs.Any()) {  					sb.Append("   Objects: ");  					foreach (var obj in objs) {  						sb.Append(obj);    						if (obj is OverlayObject) {  							var ovl = (obj as OverlayObject);  							if (ovl.IsGeneratedVeins)  								sb.Append("(gen)");  						}    						sb.Append(" ");  					}  				}  			}
Magic Number,CNCMaps.Engine.Rendering,DebugDrawingSurfaceWindow,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\DebugDrawingSurfaceWindow.cs,pictureBox1_MouseMove,The following statement contains a magic number: if (tile == null || !(tile.Drawable is TileDrawable)) {  				sb.Append("No valid tile under mouse");  			}  			else {  				var tileFile = (tile.Drawable as TileDrawable).GetTileFile(tile);  				sb.AppendFormat("   Tile {4}: d({0}'{1}) r({2}'{3})"' tile.Dx' tile.Dy' tile.Rx' tile.Ry' (tileFile?.FileName??"").ToUpper());  				if (tileFile != null) {  					if (tileFile.Images[tile.SubTile].RampType != 0)  						sb.AppendFormat(" ramp {0}"' tileFile.Images[tile.SubTile].RampType);  					if (tileFile.Images[tile.SubTile].TerrainType != 0)  						sb.AppendFormat(" terrain {0}"' tileFile.Images[tile.SubTile].TerrainType);  				}  				var gridTilenoZ = _tiles.GetTileScreen(e.Location' true' true);  				sb.AppendFormat("   Touched: {0}"' _tiles.GridTouched[gridTilenoZ.Dx' gridTilenoZ.Dy / 2]);    				if (_tiles.GridTouchedBy[gridTilenoZ.Dx' gridTilenoZ.Dy / 2] != null)  					sb.AppendFormat(" by {0} "' _tiles.GridTouchedBy[gridTilenoZ.Dx' gridTilenoZ.Dy / 2]);    				sb.AppendFormat("   Z-buf: {0}"' _drawingSurface.GetZBuffer()[rIdx]);  				sb.AppendFormat("   S-buf: {0}"' _drawingSurface.GetShadows()[rIdx]);    				var objs = _map.GetObjectsAt(tile.Dx' tile.Dy / 2);  				if (objs.Any()) {  					sb.Append("   Objects: ");  					foreach (var obj in objs) {  						sb.Append(obj);    						if (obj is OverlayObject) {  							var ovl = (obj as OverlayObject);  							if (ovl.IsGeneratedVeins)  								sb.Append("(gen)");  						}    						sb.Append(" ");  					}  				}  			}
Magic Number,CNCMaps.Engine.Rendering,DebugDrawingSurfaceWindow,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\DebugDrawingSurfaceWindow.cs,pictureBox1_MouseMove,The following statement contains a magic number: if (tile == null || !(tile.Drawable is TileDrawable)) {  				sb.Append("No valid tile under mouse");  			}  			else {  				var tileFile = (tile.Drawable as TileDrawable).GetTileFile(tile);  				sb.AppendFormat("   Tile {4}: d({0}'{1}) r({2}'{3})"' tile.Dx' tile.Dy' tile.Rx' tile.Ry' (tileFile?.FileName??"").ToUpper());  				if (tileFile != null) {  					if (tileFile.Images[tile.SubTile].RampType != 0)  						sb.AppendFormat(" ramp {0}"' tileFile.Images[tile.SubTile].RampType);  					if (tileFile.Images[tile.SubTile].TerrainType != 0)  						sb.AppendFormat(" terrain {0}"' tileFile.Images[tile.SubTile].TerrainType);  				}  				var gridTilenoZ = _tiles.GetTileScreen(e.Location' true' true);  				sb.AppendFormat("   Touched: {0}"' _tiles.GridTouched[gridTilenoZ.Dx' gridTilenoZ.Dy / 2]);    				if (_tiles.GridTouchedBy[gridTilenoZ.Dx' gridTilenoZ.Dy / 2] != null)  					sb.AppendFormat(" by {0} "' _tiles.GridTouchedBy[gridTilenoZ.Dx' gridTilenoZ.Dy / 2]);    				sb.AppendFormat("   Z-buf: {0}"' _drawingSurface.GetZBuffer()[rIdx]);  				sb.AppendFormat("   S-buf: {0}"' _drawingSurface.GetShadows()[rIdx]);    				var objs = _map.GetObjectsAt(tile.Dx' tile.Dy / 2);  				if (objs.Any()) {  					sb.Append("   Objects: ");  					foreach (var obj in objs) {  						sb.Append(obj);    						if (obj is OverlayObject) {  							var ovl = (obj as OverlayObject);  							if (ovl.IsGeneratedVeins)  								sb.Append("(gen)");  						}    						sb.Append(" ");  					}  				}  			}
Magic Number,CNCMaps.Engine.Rendering,DebugDrawingSurfaceWindow,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\DebugDrawingSurfaceWindow.cs,InitializeComponent,The following statement contains a magic number: this.pictureBox1.Location = new System.Drawing.Point(21' 30);
Magic Number,CNCMaps.Engine.Rendering,DebugDrawingSurfaceWindow,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\DebugDrawingSurfaceWindow.cs,InitializeComponent,The following statement contains a magic number: this.pictureBox1.Location = new System.Drawing.Point(21' 30);
Magic Number,CNCMaps.Engine.Rendering,DebugDrawingSurfaceWindow,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\DebugDrawingSurfaceWindow.cs,InitializeComponent,The following statement contains a magic number: this.pictureBox1.Size = new System.Drawing.Size(859' 467);
Magic Number,CNCMaps.Engine.Rendering,DebugDrawingSurfaceWindow,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\DebugDrawingSurfaceWindow.cs,InitializeComponent,The following statement contains a magic number: this.pictureBox1.Size = new System.Drawing.Size(859' 467);
Magic Number,CNCMaps.Engine.Rendering,DebugDrawingSurfaceWindow,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\DebugDrawingSurfaceWindow.cs,InitializeComponent,The following statement contains a magic number: this.panel1.Location = new System.Drawing.Point(9' 9);
Magic Number,CNCMaps.Engine.Rendering,DebugDrawingSurfaceWindow,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\DebugDrawingSurfaceWindow.cs,InitializeComponent,The following statement contains a magic number: this.panel1.Location = new System.Drawing.Point(9' 9);
Magic Number,CNCMaps.Engine.Rendering,DebugDrawingSurfaceWindow,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\DebugDrawingSurfaceWindow.cs,InitializeComponent,The following statement contains a magic number: this.panel1.Size = new System.Drawing.Size(930' 545);
Magic Number,CNCMaps.Engine.Rendering,DebugDrawingSurfaceWindow,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\DebugDrawingSurfaceWindow.cs,InitializeComponent,The following statement contains a magic number: this.panel1.Size = new System.Drawing.Size(930' 545);
Magic Number,CNCMaps.Engine.Rendering,DebugDrawingSurfaceWindow,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\DebugDrawingSurfaceWindow.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Location = new System.Drawing.Point(0' 563);
Magic Number,CNCMaps.Engine.Rendering,DebugDrawingSurfaceWindow,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\DebugDrawingSurfaceWindow.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Size = new System.Drawing.Size(948' 22);
Magic Number,CNCMaps.Engine.Rendering,DebugDrawingSurfaceWindow,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\DebugDrawingSurfaceWindow.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Size = new System.Drawing.Size(948' 22);
Magic Number,CNCMaps.Engine.Rendering,DebugDrawingSurfaceWindow,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\DebugDrawingSurfaceWindow.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.TabIndex = 2;
Magic Number,CNCMaps.Engine.Rendering,DebugDrawingSurfaceWindow,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\DebugDrawingSurfaceWindow.cs,InitializeComponent,The following statement contains a magic number: this.toolStripStatusLabel1.Size = new System.Drawing.Size(118' 17);
Magic Number,CNCMaps.Engine.Rendering,DebugDrawingSurfaceWindow,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\DebugDrawingSurfaceWindow.cs,InitializeComponent,The following statement contains a magic number: this.toolStripStatusLabel1.Size = new System.Drawing.Size(118' 17);
Magic Number,CNCMaps.Engine.Rendering,DebugDrawingSurfaceWindow,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\DebugDrawingSurfaceWindow.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(948' 585);
Magic Number,CNCMaps.Engine.Rendering,DebugDrawingSurfaceWindow,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\DebugDrawingSurfaceWindow.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(948' 585);
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Clone,The following statement contains a magic number: p.Colors = new Color[256];
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Recalculate,The following statement contains a magic number: for (int i = 0; i < 256; i++) {                  rmult = _ambientMult * _redMult;                  gmult = _ambientMult * _greenMult;                  bmult = _ambientMult * _blueMult;                  // Starkku: For object palettes colors 240-254 do not get any lighting applied on them.                  if (i >= 240 && i <= 254 && _objectPalette)                   {                      rmult = gmult = bmult = 1.0;                  }  				var r = (byte)Math.Min(255' _origColors[i * 3 + 0] * (rmult) / 63.0 * 255.0);                  var g = (byte)Math.Min(255' _origColors[i * 3 + 1] * (gmult) / 63.0 * 255.0);                  var b = (byte)Math.Min(255' _origColors[i * 3 + 2] * (bmult) / 63.0 * 255.0);  				Colors[i] = Color.FromArgb(r' g' b);  			}
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Recalculate,The following statement contains a magic number: for (int i = 0; i < 256; i++) {                  rmult = _ambientMult * _redMult;                  gmult = _ambientMult * _greenMult;                  bmult = _ambientMult * _blueMult;                  // Starkku: For object palettes colors 240-254 do not get any lighting applied on them.                  if (i >= 240 && i <= 254 && _objectPalette)                   {                      rmult = gmult = bmult = 1.0;                  }  				var r = (byte)Math.Min(255' _origColors[i * 3 + 0] * (rmult) / 63.0 * 255.0);                  var g = (byte)Math.Min(255' _origColors[i * 3 + 1] * (gmult) / 63.0 * 255.0);                  var b = (byte)Math.Min(255' _origColors[i * 3 + 2] * (bmult) / 63.0 * 255.0);  				Colors[i] = Color.FromArgb(r' g' b);  			}
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Recalculate,The following statement contains a magic number: for (int i = 0; i < 256; i++) {                  rmult = _ambientMult * _redMult;                  gmult = _ambientMult * _greenMult;                  bmult = _ambientMult * _blueMult;                  // Starkku: For object palettes colors 240-254 do not get any lighting applied on them.                  if (i >= 240 && i <= 254 && _objectPalette)                   {                      rmult = gmult = bmult = 1.0;                  }  				var r = (byte)Math.Min(255' _origColors[i * 3 + 0] * (rmult) / 63.0 * 255.0);                  var g = (byte)Math.Min(255' _origColors[i * 3 + 1] * (gmult) / 63.0 * 255.0);                  var b = (byte)Math.Min(255' _origColors[i * 3 + 2] * (bmult) / 63.0 * 255.0);  				Colors[i] = Color.FromArgb(r' g' b);  			}
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Recalculate,The following statement contains a magic number: for (int i = 0; i < 256; i++) {                  rmult = _ambientMult * _redMult;                  gmult = _ambientMult * _greenMult;                  bmult = _ambientMult * _blueMult;                  // Starkku: For object palettes colors 240-254 do not get any lighting applied on them.                  if (i >= 240 && i <= 254 && _objectPalette)                   {                      rmult = gmult = bmult = 1.0;                  }  				var r = (byte)Math.Min(255' _origColors[i * 3 + 0] * (rmult) / 63.0 * 255.0);                  var g = (byte)Math.Min(255' _origColors[i * 3 + 1] * (gmult) / 63.0 * 255.0);                  var b = (byte)Math.Min(255' _origColors[i * 3 + 2] * (bmult) / 63.0 * 255.0);  				Colors[i] = Color.FromArgb(r' g' b);  			}
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Recalculate,The following statement contains a magic number: for (int i = 0; i < 256; i++) {                  rmult = _ambientMult * _redMult;                  gmult = _ambientMult * _greenMult;                  bmult = _ambientMult * _blueMult;                  // Starkku: For object palettes colors 240-254 do not get any lighting applied on them.                  if (i >= 240 && i <= 254 && _objectPalette)                   {                      rmult = gmult = bmult = 1.0;                  }  				var r = (byte)Math.Min(255' _origColors[i * 3 + 0] * (rmult) / 63.0 * 255.0);                  var g = (byte)Math.Min(255' _origColors[i * 3 + 1] * (gmult) / 63.0 * 255.0);                  var b = (byte)Math.Min(255' _origColors[i * 3 + 2] * (bmult) / 63.0 * 255.0);  				Colors[i] = Color.FromArgb(r' g' b);  			}
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Recalculate,The following statement contains a magic number: for (int i = 0; i < 256; i++) {                  rmult = _ambientMult * _redMult;                  gmult = _ambientMult * _greenMult;                  bmult = _ambientMult * _blueMult;                  // Starkku: For object palettes colors 240-254 do not get any lighting applied on them.                  if (i >= 240 && i <= 254 && _objectPalette)                   {                      rmult = gmult = bmult = 1.0;                  }  				var r = (byte)Math.Min(255' _origColors[i * 3 + 0] * (rmult) / 63.0 * 255.0);                  var g = (byte)Math.Min(255' _origColors[i * 3 + 1] * (gmult) / 63.0 * 255.0);                  var b = (byte)Math.Min(255' _origColors[i * 3 + 2] * (bmult) / 63.0 * 255.0);  				Colors[i] = Color.FromArgb(r' g' b);  			}
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Recalculate,The following statement contains a magic number: for (int i = 0; i < 256; i++) {                  rmult = _ambientMult * _redMult;                  gmult = _ambientMult * _greenMult;                  bmult = _ambientMult * _blueMult;                  // Starkku: For object palettes colors 240-254 do not get any lighting applied on them.                  if (i >= 240 && i <= 254 && _objectPalette)                   {                      rmult = gmult = bmult = 1.0;                  }  				var r = (byte)Math.Min(255' _origColors[i * 3 + 0] * (rmult) / 63.0 * 255.0);                  var g = (byte)Math.Min(255' _origColors[i * 3 + 1] * (gmult) / 63.0 * 255.0);                  var b = (byte)Math.Min(255' _origColors[i * 3 + 2] * (bmult) / 63.0 * 255.0);  				Colors[i] = Color.FromArgb(r' g' b);  			}
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Recalculate,The following statement contains a magic number: for (int i = 0; i < 256; i++) {                  rmult = _ambientMult * _redMult;                  gmult = _ambientMult * _greenMult;                  bmult = _ambientMult * _blueMult;                  // Starkku: For object palettes colors 240-254 do not get any lighting applied on them.                  if (i >= 240 && i <= 254 && _objectPalette)                   {                      rmult = gmult = bmult = 1.0;                  }  				var r = (byte)Math.Min(255' _origColors[i * 3 + 0] * (rmult) / 63.0 * 255.0);                  var g = (byte)Math.Min(255' _origColors[i * 3 + 1] * (gmult) / 63.0 * 255.0);                  var b = (byte)Math.Min(255' _origColors[i * 3 + 2] * (bmult) / 63.0 * 255.0);  				Colors[i] = Color.FromArgb(r' g' b);  			}
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Recalculate,The following statement contains a magic number: for (int i = 0; i < 256; i++) {                  rmult = _ambientMult * _redMult;                  gmult = _ambientMult * _greenMult;                  bmult = _ambientMult * _blueMult;                  // Starkku: For object palettes colors 240-254 do not get any lighting applied on them.                  if (i >= 240 && i <= 254 && _objectPalette)                   {                      rmult = gmult = bmult = 1.0;                  }  				var r = (byte)Math.Min(255' _origColors[i * 3 + 0] * (rmult) / 63.0 * 255.0);                  var g = (byte)Math.Min(255' _origColors[i * 3 + 1] * (gmult) / 63.0 * 255.0);                  var b = (byte)Math.Min(255' _origColors[i * 3 + 2] * (bmult) / 63.0 * 255.0);  				Colors[i] = Color.FromArgb(r' g' b);  			}
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Recalculate,The following statement contains a magic number: for (int i = 0; i < 256; i++) {                  rmult = _ambientMult * _redMult;                  gmult = _ambientMult * _greenMult;                  bmult = _ambientMult * _blueMult;                  // Starkku: For object palettes colors 240-254 do not get any lighting applied on them.                  if (i >= 240 && i <= 254 && _objectPalette)                   {                      rmult = gmult = bmult = 1.0;                  }  				var r = (byte)Math.Min(255' _origColors[i * 3 + 0] * (rmult) / 63.0 * 255.0);                  var g = (byte)Math.Min(255' _origColors[i * 3 + 1] * (gmult) / 63.0 * 255.0);                  var b = (byte)Math.Min(255' _origColors[i * 3 + 2] * (bmult) / 63.0 * 255.0);  				Colors[i] = Color.FromArgb(r' g' b);  			}
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Recalculate,The following statement contains a magic number: for (int i = 0; i < 256; i++) {                  rmult = _ambientMult * _redMult;                  gmult = _ambientMult * _greenMult;                  bmult = _ambientMult * _blueMult;                  // Starkku: For object palettes colors 240-254 do not get any lighting applied on them.                  if (i >= 240 && i <= 254 && _objectPalette)                   {                      rmult = gmult = bmult = 1.0;                  }  				var r = (byte)Math.Min(255' _origColors[i * 3 + 0] * (rmult) / 63.0 * 255.0);                  var g = (byte)Math.Min(255' _origColors[i * 3 + 1] * (gmult) / 63.0 * 255.0);                  var b = (byte)Math.Min(255' _origColors[i * 3 + 2] * (bmult) / 63.0 * 255.0);  				Colors[i] = Color.FromArgb(r' g' b);  			}
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Recalculate,The following statement contains a magic number: for (int i = 0; i < 256; i++) {                  rmult = _ambientMult * _redMult;                  gmult = _ambientMult * _greenMult;                  bmult = _ambientMult * _blueMult;                  // Starkku: For object palettes colors 240-254 do not get any lighting applied on them.                  if (i >= 240 && i <= 254 && _objectPalette)                   {                      rmult = gmult = bmult = 1.0;                  }  				var r = (byte)Math.Min(255' _origColors[i * 3 + 0] * (rmult) / 63.0 * 255.0);                  var g = (byte)Math.Min(255' _origColors[i * 3 + 1] * (gmult) / 63.0 * 255.0);                  var b = (byte)Math.Min(255' _origColors[i * 3 + 2] * (bmult) / 63.0 * 255.0);  				Colors[i] = Color.FromArgb(r' g' b);  			}
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Recalculate,The following statement contains a magic number: for (int i = 0; i < 256; i++) {                  rmult = _ambientMult * _redMult;                  gmult = _ambientMult * _greenMult;                  bmult = _ambientMult * _blueMult;                  // Starkku: For object palettes colors 240-254 do not get any lighting applied on them.                  if (i >= 240 && i <= 254 && _objectPalette)                   {                      rmult = gmult = bmult = 1.0;                  }  				var r = (byte)Math.Min(255' _origColors[i * 3 + 0] * (rmult) / 63.0 * 255.0);                  var g = (byte)Math.Min(255' _origColors[i * 3 + 1] * (gmult) / 63.0 * 255.0);                  var b = (byte)Math.Min(255' _origColors[i * 3 + 2] * (bmult) / 63.0 * 255.0);  				Colors[i] = Color.FromArgb(r' g' b);  			}
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Recalculate,The following statement contains a magic number: for (int i = 0; i < 256; i++) {                  rmult = _ambientMult * _redMult;                  gmult = _ambientMult * _greenMult;                  bmult = _ambientMult * _blueMult;                  // Starkku: For object palettes colors 240-254 do not get any lighting applied on them.                  if (i >= 240 && i <= 254 && _objectPalette)                   {                      rmult = gmult = bmult = 1.0;                  }  				var r = (byte)Math.Min(255' _origColors[i * 3 + 0] * (rmult) / 63.0 * 255.0);                  var g = (byte)Math.Min(255' _origColors[i * 3 + 1] * (gmult) / 63.0 * 255.0);                  var b = (byte)Math.Min(255' _origColors[i * 3 + 2] * (bmult) / 63.0 * 255.0);  				Colors[i] = Color.FromArgb(r' g' b);  			}
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Recalculate,The following statement contains a magic number: for (int i = 0; i < 256; i++) {                  rmult = _ambientMult * _redMult;                  gmult = _ambientMult * _greenMult;                  bmult = _ambientMult * _blueMult;                  // Starkku: For object palettes colors 240-254 do not get any lighting applied on them.                  if (i >= 240 && i <= 254 && _objectPalette)                   {                      rmult = gmult = bmult = 1.0;                  }  				var r = (byte)Math.Min(255' _origColors[i * 3 + 0] * (rmult) / 63.0 * 255.0);                  var g = (byte)Math.Min(255' _origColors[i * 3 + 1] * (gmult) / 63.0 * 255.0);                  var b = (byte)Math.Min(255' _origColors[i * 3 + 2] * (bmult) / 63.0 * 255.0);  				Colors[i] = Color.FromArgb(r' g' b);  			}
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Recalculate,The following statement contains a magic number: for (int i = 0; i < 256; i++) {                  rmult = _ambientMult * _redMult;                  gmult = _ambientMult * _greenMult;                  bmult = _ambientMult * _blueMult;                  // Starkku: For object palettes colors 240-254 do not get any lighting applied on them.                  if (i >= 240 && i <= 254 && _objectPalette)                   {                      rmult = gmult = bmult = 1.0;                  }  				var r = (byte)Math.Min(255' _origColors[i * 3 + 0] * (rmult) / 63.0 * 255.0);                  var g = (byte)Math.Min(255' _origColors[i * 3 + 1] * (gmult) / 63.0 * 255.0);                  var b = (byte)Math.Min(255' _origColors[i * 3 + 2] * (bmult) / 63.0 * 255.0);  				Colors[i] = Color.FromArgb(r' g' b);  			}
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,MakePalette,The following statement contains a magic number: for (int i = 0; i < 256; i++)  				p.Colors[i] = c;
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Merge,The following statement contains a magic number: for (int i = 0; i < 256; i++)  				p.Colors[i] = Color.FromArgb(  					(int)(A.Colors[i].R * opacity + B.Colors[i].R * (1.0 - opacity))'  					(int)(A.Colors[i].G * opacity + B.Colors[i].G * (1.0 - opacity))'  					(int)(A.Colors[i].B * opacity + B.Colors[i].B * (1.0 - opacity)));
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: double[] mults = { 0xFC >> 2' 0xEC >> 2' 0xDC >> 2' 0xD0 >> 2'  						0xC0 >> 2' 0xB0 >> 2' 0xA4 >> 2' 0x94 >> 2'  						0x84 >> 2' 0x78 >> 2' 0x68 >> 2' 0x58 >> 2'  						0x4C >> 2' 0x3C >> 2' 0x2C >> 2' 0x20 >> 2 };
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: double[] mults = { 0xFC >> 2' 0xEC >> 2' 0xDC >> 2' 0xD0 >> 2'  						0xC0 >> 2' 0xB0 >> 2' 0xA4 >> 2' 0x94 >> 2'  						0x84 >> 2' 0x78 >> 2' 0x68 >> 2' 0x58 >> 2'  						0x4C >> 2' 0x3C >> 2' 0x2C >> 2' 0x20 >> 2 };
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: double[] mults = { 0xFC >> 2' 0xEC >> 2' 0xDC >> 2' 0xD0 >> 2'  						0xC0 >> 2' 0xB0 >> 2' 0xA4 >> 2' 0x94 >> 2'  						0x84 >> 2' 0x78 >> 2' 0x68 >> 2' 0x58 >> 2'  						0x4C >> 2' 0x3C >> 2' 0x2C >> 2' 0x20 >> 2 };
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: double[] mults = { 0xFC >> 2' 0xEC >> 2' 0xDC >> 2' 0xD0 >> 2'  						0xC0 >> 2' 0xB0 >> 2' 0xA4 >> 2' 0x94 >> 2'  						0x84 >> 2' 0x78 >> 2' 0x68 >> 2' 0x58 >> 2'  						0x4C >> 2' 0x3C >> 2' 0x2C >> 2' 0x20 >> 2 };
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: double[] mults = { 0xFC >> 2' 0xEC >> 2' 0xDC >> 2' 0xD0 >> 2'  						0xC0 >> 2' 0xB0 >> 2' 0xA4 >> 2' 0x94 >> 2'  						0x84 >> 2' 0x78 >> 2' 0x68 >> 2' 0x58 >> 2'  						0x4C >> 2' 0x3C >> 2' 0x2C >> 2' 0x20 >> 2 };
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: double[] mults = { 0xFC >> 2' 0xEC >> 2' 0xDC >> 2' 0xD0 >> 2'  						0xC0 >> 2' 0xB0 >> 2' 0xA4 >> 2' 0x94 >> 2'  						0x84 >> 2' 0x78 >> 2' 0x68 >> 2' 0x58 >> 2'  						0x4C >> 2' 0x3C >> 2' 0x2C >> 2' 0x20 >> 2 };
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: double[] mults = { 0xFC >> 2' 0xEC >> 2' 0xDC >> 2' 0xD0 >> 2'  						0xC0 >> 2' 0xB0 >> 2' 0xA4 >> 2' 0x94 >> 2'  						0x84 >> 2' 0x78 >> 2' 0x68 >> 2' 0x58 >> 2'  						0x4C >> 2' 0x3C >> 2' 0x2C >> 2' 0x20 >> 2 };
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: double[] mults = { 0xFC >> 2' 0xEC >> 2' 0xDC >> 2' 0xD0 >> 2'  						0xC0 >> 2' 0xB0 >> 2' 0xA4 >> 2' 0x94 >> 2'  						0x84 >> 2' 0x78 >> 2' 0x68 >> 2' 0x58 >> 2'  						0x4C >> 2' 0x3C >> 2' 0x2C >> 2' 0x20 >> 2 };
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: double[] mults = { 0xFC >> 2' 0xEC >> 2' 0xDC >> 2' 0xD0 >> 2'  						0xC0 >> 2' 0xB0 >> 2' 0xA4 >> 2' 0x94 >> 2'  						0x84 >> 2' 0x78 >> 2' 0x68 >> 2' 0x58 >> 2'  						0x4C >> 2' 0x3C >> 2' 0x2C >> 2' 0x20 >> 2 };
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: double[] mults = { 0xFC >> 2' 0xEC >> 2' 0xDC >> 2' 0xD0 >> 2'  						0xC0 >> 2' 0xB0 >> 2' 0xA4 >> 2' 0x94 >> 2'  						0x84 >> 2' 0x78 >> 2' 0x68 >> 2' 0x58 >> 2'  						0x4C >> 2' 0x3C >> 2' 0x2C >> 2' 0x20 >> 2 };
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: double[] mults = { 0xFC >> 2' 0xEC >> 2' 0xDC >> 2' 0xD0 >> 2'  						0xC0 >> 2' 0xB0 >> 2' 0xA4 >> 2' 0x94 >> 2'  						0x84 >> 2' 0x78 >> 2' 0x68 >> 2' 0x58 >> 2'  						0x4C >> 2' 0x3C >> 2' 0x2C >> 2' 0x20 >> 2 };
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: double[] mults = { 0xFC >> 2' 0xEC >> 2' 0xDC >> 2' 0xD0 >> 2'  						0xC0 >> 2' 0xB0 >> 2' 0xA4 >> 2' 0x94 >> 2'  						0x84 >> 2' 0x78 >> 2' 0x68 >> 2' 0x58 >> 2'  						0x4C >> 2' 0x3C >> 2' 0x2C >> 2' 0x20 >> 2 };
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: double[] mults = { 0xFC >> 2' 0xEC >> 2' 0xDC >> 2' 0xD0 >> 2'  						0xC0 >> 2' 0xB0 >> 2' 0xA4 >> 2' 0x94 >> 2'  						0x84 >> 2' 0x78 >> 2' 0x68 >> 2' 0x58 >> 2'  						0x4C >> 2' 0x3C >> 2' 0x2C >> 2' 0x20 >> 2 };
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: double[] mults = { 0xFC >> 2' 0xEC >> 2' 0xDC >> 2' 0xD0 >> 2'  						0xC0 >> 2' 0xB0 >> 2' 0xA4 >> 2' 0x94 >> 2'  						0x84 >> 2' 0x78 >> 2' 0x68 >> 2' 0x58 >> 2'  						0x4C >> 2' 0x3C >> 2' 0x2C >> 2' 0x20 >> 2 };
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: double[] mults = { 0xFC >> 2' 0xEC >> 2' 0xDC >> 2' 0xD0 >> 2'  						0xC0 >> 2' 0xB0 >> 2' 0xA4 >> 2' 0x94 >> 2'  						0x84 >> 2' 0x78 >> 2' 0x68 >> 2' 0x58 >> 2'  						0x4C >> 2' 0x3C >> 2' 0x2C >> 2' 0x20 >> 2 };
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: double[] mults = { 0xFC >> 2' 0xEC >> 2' 0xDC >> 2' 0xD0 >> 2'  						0xC0 >> 2' 0xB0 >> 2' 0xA4 >> 2' 0x94 >> 2'  						0x84 >> 2' 0x78 >> 2' 0x68 >> 2' 0x58 >> 2'  						0x4C >> 2' 0x3C >> 2' 0x2C >> 2' 0x20 >> 2 };
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: for (int i = 16; i < 32; i++) {  				_origColors[i * 3 + 0] = (byte)(color.R / 255.0 * mults[i - 16]);  				_origColors[i * 3 + 1] = (byte)(color.G / 255.0 * mults[i - 16]);  				_origColors[i * 3 + 2] = (byte)(color.B / 255.0 * mults[i - 16]);  			}
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: for (int i = 16; i < 32; i++) {  				_origColors[i * 3 + 0] = (byte)(color.R / 255.0 * mults[i - 16]);  				_origColors[i * 3 + 1] = (byte)(color.G / 255.0 * mults[i - 16]);  				_origColors[i * 3 + 2] = (byte)(color.B / 255.0 * mults[i - 16]);  			}
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: for (int i = 16; i < 32; i++) {  				_origColors[i * 3 + 0] = (byte)(color.R / 255.0 * mults[i - 16]);  				_origColors[i * 3 + 1] = (byte)(color.G / 255.0 * mults[i - 16]);  				_origColors[i * 3 + 2] = (byte)(color.B / 255.0 * mults[i - 16]);  			}
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: for (int i = 16; i < 32; i++) {  				_origColors[i * 3 + 0] = (byte)(color.R / 255.0 * mults[i - 16]);  				_origColors[i * 3 + 1] = (byte)(color.G / 255.0 * mults[i - 16]);  				_origColors[i * 3 + 2] = (byte)(color.B / 255.0 * mults[i - 16]);  			}
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: for (int i = 16; i < 32; i++) {  				_origColors[i * 3 + 0] = (byte)(color.R / 255.0 * mults[i - 16]);  				_origColors[i * 3 + 1] = (byte)(color.G / 255.0 * mults[i - 16]);  				_origColors[i * 3 + 2] = (byte)(color.B / 255.0 * mults[i - 16]);  			}
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: for (int i = 16; i < 32; i++) {  				_origColors[i * 3 + 0] = (byte)(color.R / 255.0 * mults[i - 16]);  				_origColors[i * 3 + 1] = (byte)(color.G / 255.0 * mults[i - 16]);  				_origColors[i * 3 + 2] = (byte)(color.B / 255.0 * mults[i - 16]);  			}
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: for (int i = 16; i < 32; i++) {  				_origColors[i * 3 + 0] = (byte)(color.R / 255.0 * mults[i - 16]);  				_origColors[i * 3 + 1] = (byte)(color.G / 255.0 * mults[i - 16]);  				_origColors[i * 3 + 2] = (byte)(color.B / 255.0 * mults[i - 16]);  			}
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: for (int i = 16; i < 32; i++) {  				_origColors[i * 3 + 0] = (byte)(color.R / 255.0 * mults[i - 16]);  				_origColors[i * 3 + 1] = (byte)(color.G / 255.0 * mults[i - 16]);  				_origColors[i * 3 + 2] = (byte)(color.B / 255.0 * mults[i - 16]);  			}
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: for (int i = 16; i < 32; i++) {  				_origColors[i * 3 + 0] = (byte)(color.R / 255.0 * mults[i - 16]);  				_origColors[i * 3 + 1] = (byte)(color.G / 255.0 * mults[i - 16]);  				_origColors[i * 3 + 2] = (byte)(color.B / 255.0 * mults[i - 16]);  			}
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: for (int i = 16; i < 32; i++) {  				_origColors[i * 3 + 0] = (byte)(color.R / 255.0 * mults[i - 16]);  				_origColors[i * 3 + 1] = (byte)(color.G / 255.0 * mults[i - 16]);  				_origColors[i * 3 + 2] = (byte)(color.B / 255.0 * mults[i - 16]);  			}
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: for (int i = 16; i < 32; i++) {  				_origColors[i * 3 + 0] = (byte)(color.R / 255.0 * mults[i - 16]);  				_origColors[i * 3 + 1] = (byte)(color.G / 255.0 * mults[i - 16]);  				_origColors[i * 3 + 2] = (byte)(color.B / 255.0 * mults[i - 16]);  			}
Magic Number,CNCMaps.Engine.Rendering,Palette,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\Palette.cs,Remap,The following statement contains a magic number: for (int i = 16; i < 32; i++) {  				_origColors[i * 3 + 0] = (byte)(color.R / 255.0 * mults[i - 16]);  				_origColors[i * 3 + 1] = (byte)(color.G / 255.0 * mults[i - 16]);  				_origColors[i * 3 + 2] = (byte)(color.B / 255.0 * mults[i - 16]);  			}
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,GetBounds,The following statement contains a magic number: var offset = new Point(-shp.Width / 2' -shp.Height / 2);
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,GetBounds,The following statement contains a magic number: var offset = new Point(-shp.Width / 2' -shp.Height / 2);
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,Draw,The following statement contains a magic number: offset.X += obj.Tile.Dx * Drawable.TileWidth / 2 - shp.Width / 2 + img.X;
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,Draw,The following statement contains a magic number: offset.X += obj.Tile.Dx * Drawable.TileWidth / 2 - shp.Width / 2 + img.X;
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,Draw,The following statement contains a magic number: offset.Y += (obj.Tile.Dy - obj.Tile.Z) * Drawable.TileHeight / 2 - shp.Height / 2 + img.Y;
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,Draw,The following statement contains a magic number: offset.Y += (obj.Tile.Dy - obj.Tile.Z) * Drawable.TileHeight / 2 - shp.Height / 2 + img.Y;
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,Draw,The following statement contains a magic number: byte* w = (byte*)ds.BitmapData.Scan0 + offset.X * 3 + stride * offset.Y;
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,Draw,The following statement contains a magic number: transLucency = (transLucency / 25) * 25;
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,Draw,The following statement contains a magic number: transLucency = (transLucency / 25) * 25;
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,Draw,The following statement contains a magic number: short hBufVal = (short)(obj.Tile.Z * Drawable.TileHeight / 2);
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,Draw,The following statement contains a magic number: short zOffset = (short)((obj.BottomTile.Rx + obj.BottomTile.Ry) * Drawable.TileHeight / 2);
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,Draw,The following statement contains a magic number: for (int y = 0; y < img.Height; y++) {  				if (offset.Y + y < 0) {  					w += stride;  					rIdx += img.Width;  					zIdx += ds.Width;  					continue; // out of bounds  				}    				for (int x = 0; x < img.Width; x++) {  					byte paletteValue = imgData[rIdx];    					short zshapeOffset = obj is StructureObject ? (GetBuildingZ(x' y' shp' img' obj)) : (short)0;  					  					if (paletteValue != 0) {  						short zBufVal = zOffset;  						if (dr.Flat)  							zBufVal += (short)(y - img.Height);  						else if (dr.IsBuildingPart) {  							// nonflat building  							zBufVal += zshapeOffset;  						}  						else  							zBufVal += img.Height;    						if (w_low <= w && w < w_high  /*&& zBufVal >= zBuffer[zIdx]*/) {  							if (transLucency != 0) {  								*(w + 0) = (byte)(a * *(w + 0) + b * p.Colors[paletteValue].B);  								*(w + 1) = (byte)(a * *(w + 1) + b * p.Colors[paletteValue].G);  								*(w + 2) = (byte)(a * *(w + 2) + b * p.Colors[paletteValue].R);  							}  							else {  								*(w + 0) = p.Colors[paletteValue].B;  								*(w + 1) = p.Colors[paletteValue].G;  								*(w + 2) = p.Colors[paletteValue].R;    								//var pal = Theater.Active.GetPalettes().UnitPalette.Colors;  								//*(w + 0) = pal[zshapeOffset].R;  								//*(w + 1) = pal[zshapeOffset].G;  								//*(w + 2) = pal[zshapeOffset].B;  							}  							zBuffer[zIdx] = zBufVal;  							heightBuffer[zIdx] = hBufVal;  						}  					}  					//else {  					//	*(w + 0) = 0;  					//	*(w + 1) = 0;  					//	*(w + 2) = 255;  					//}    					// Up to the next pixel  					rIdx++;  					zIdx++;  					w += 3;  				}  				w += stride - 3 * img.Width;  				zIdx += ds.Width - img.Width;  			}
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,Draw,The following statement contains a magic number: for (int y = 0; y < img.Height; y++) {  				if (offset.Y + y < 0) {  					w += stride;  					rIdx += img.Width;  					zIdx += ds.Width;  					continue; // out of bounds  				}    				for (int x = 0; x < img.Width; x++) {  					byte paletteValue = imgData[rIdx];    					short zshapeOffset = obj is StructureObject ? (GetBuildingZ(x' y' shp' img' obj)) : (short)0;  					  					if (paletteValue != 0) {  						short zBufVal = zOffset;  						if (dr.Flat)  							zBufVal += (short)(y - img.Height);  						else if (dr.IsBuildingPart) {  							// nonflat building  							zBufVal += zshapeOffset;  						}  						else  							zBufVal += img.Height;    						if (w_low <= w && w < w_high  /*&& zBufVal >= zBuffer[zIdx]*/) {  							if (transLucency != 0) {  								*(w + 0) = (byte)(a * *(w + 0) + b * p.Colors[paletteValue].B);  								*(w + 1) = (byte)(a * *(w + 1) + b * p.Colors[paletteValue].G);  								*(w + 2) = (byte)(a * *(w + 2) + b * p.Colors[paletteValue].R);  							}  							else {  								*(w + 0) = p.Colors[paletteValue].B;  								*(w + 1) = p.Colors[paletteValue].G;  								*(w + 2) = p.Colors[paletteValue].R;    								//var pal = Theater.Active.GetPalettes().UnitPalette.Colors;  								//*(w + 0) = pal[zshapeOffset].R;  								//*(w + 1) = pal[zshapeOffset].G;  								//*(w + 2) = pal[zshapeOffset].B;  							}  							zBuffer[zIdx] = zBufVal;  							heightBuffer[zIdx] = hBufVal;  						}  					}  					//else {  					//	*(w + 0) = 0;  					//	*(w + 1) = 0;  					//	*(w + 2) = 255;  					//}    					// Up to the next pixel  					rIdx++;  					zIdx++;  					w += 3;  				}  				w += stride - 3 * img.Width;  				zIdx += ds.Width - img.Width;  			}
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,Draw,The following statement contains a magic number: for (int y = 0; y < img.Height; y++) {  				if (offset.Y + y < 0) {  					w += stride;  					rIdx += img.Width;  					zIdx += ds.Width;  					continue; // out of bounds  				}    				for (int x = 0; x < img.Width; x++) {  					byte paletteValue = imgData[rIdx];    					short zshapeOffset = obj is StructureObject ? (GetBuildingZ(x' y' shp' img' obj)) : (short)0;  					  					if (paletteValue != 0) {  						short zBufVal = zOffset;  						if (dr.Flat)  							zBufVal += (short)(y - img.Height);  						else if (dr.IsBuildingPart) {  							// nonflat building  							zBufVal += zshapeOffset;  						}  						else  							zBufVal += img.Height;    						if (w_low <= w && w < w_high  /*&& zBufVal >= zBuffer[zIdx]*/) {  							if (transLucency != 0) {  								*(w + 0) = (byte)(a * *(w + 0) + b * p.Colors[paletteValue].B);  								*(w + 1) = (byte)(a * *(w + 1) + b * p.Colors[paletteValue].G);  								*(w + 2) = (byte)(a * *(w + 2) + b * p.Colors[paletteValue].R);  							}  							else {  								*(w + 0) = p.Colors[paletteValue].B;  								*(w + 1) = p.Colors[paletteValue].G;  								*(w + 2) = p.Colors[paletteValue].R;    								//var pal = Theater.Active.GetPalettes().UnitPalette.Colors;  								//*(w + 0) = pal[zshapeOffset].R;  								//*(w + 1) = pal[zshapeOffset].G;  								//*(w + 2) = pal[zshapeOffset].B;  							}  							zBuffer[zIdx] = zBufVal;  							heightBuffer[zIdx] = hBufVal;  						}  					}  					//else {  					//	*(w + 0) = 0;  					//	*(w + 1) = 0;  					//	*(w + 2) = 255;  					//}    					// Up to the next pixel  					rIdx++;  					zIdx++;  					w += 3;  				}  				w += stride - 3 * img.Width;  				zIdx += ds.Width - img.Width;  			}
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,Draw,The following statement contains a magic number: for (int y = 0; y < img.Height; y++) {  				if (offset.Y + y < 0) {  					w += stride;  					rIdx += img.Width;  					zIdx += ds.Width;  					continue; // out of bounds  				}    				for (int x = 0; x < img.Width; x++) {  					byte paletteValue = imgData[rIdx];    					short zshapeOffset = obj is StructureObject ? (GetBuildingZ(x' y' shp' img' obj)) : (short)0;  					  					if (paletteValue != 0) {  						short zBufVal = zOffset;  						if (dr.Flat)  							zBufVal += (short)(y - img.Height);  						else if (dr.IsBuildingPart) {  							// nonflat building  							zBufVal += zshapeOffset;  						}  						else  							zBufVal += img.Height;    						if (w_low <= w && w < w_high  /*&& zBufVal >= zBuffer[zIdx]*/) {  							if (transLucency != 0) {  								*(w + 0) = (byte)(a * *(w + 0) + b * p.Colors[paletteValue].B);  								*(w + 1) = (byte)(a * *(w + 1) + b * p.Colors[paletteValue].G);  								*(w + 2) = (byte)(a * *(w + 2) + b * p.Colors[paletteValue].R);  							}  							else {  								*(w + 0) = p.Colors[paletteValue].B;  								*(w + 1) = p.Colors[paletteValue].G;  								*(w + 2) = p.Colors[paletteValue].R;    								//var pal = Theater.Active.GetPalettes().UnitPalette.Colors;  								//*(w + 0) = pal[zshapeOffset].R;  								//*(w + 1) = pal[zshapeOffset].G;  								//*(w + 2) = pal[zshapeOffset].B;  							}  							zBuffer[zIdx] = zBufVal;  							heightBuffer[zIdx] = hBufVal;  						}  					}  					//else {  					//	*(w + 0) = 0;  					//	*(w + 1) = 0;  					//	*(w + 2) = 255;  					//}    					// Up to the next pixel  					rIdx++;  					zIdx++;  					w += 3;  				}  				w += stride - 3 * img.Width;  				zIdx += ds.Width - img.Width;  			}
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,Draw,The following statement contains a magic number: for (int y = 0; y < img.Height; y++) {  				if (offset.Y + y < 0) {  					w += stride;  					rIdx += img.Width;  					zIdx += ds.Width;  					continue; // out of bounds  				}    				for (int x = 0; x < img.Width; x++) {  					byte paletteValue = imgData[rIdx];    					short zshapeOffset = obj is StructureObject ? (GetBuildingZ(x' y' shp' img' obj)) : (short)0;  					  					if (paletteValue != 0) {  						short zBufVal = zOffset;  						if (dr.Flat)  							zBufVal += (short)(y - img.Height);  						else if (dr.IsBuildingPart) {  							// nonflat building  							zBufVal += zshapeOffset;  						}  						else  							zBufVal += img.Height;    						if (w_low <= w && w < w_high  /*&& zBufVal >= zBuffer[zIdx]*/) {  							if (transLucency != 0) {  								*(w + 0) = (byte)(a * *(w + 0) + b * p.Colors[paletteValue].B);  								*(w + 1) = (byte)(a * *(w + 1) + b * p.Colors[paletteValue].G);  								*(w + 2) = (byte)(a * *(w + 2) + b * p.Colors[paletteValue].R);  							}  							else {  								*(w + 0) = p.Colors[paletteValue].B;  								*(w + 1) = p.Colors[paletteValue].G;  								*(w + 2) = p.Colors[paletteValue].R;    								//var pal = Theater.Active.GetPalettes().UnitPalette.Colors;  								//*(w + 0) = pal[zshapeOffset].R;  								//*(w + 1) = pal[zshapeOffset].G;  								//*(w + 2) = pal[zshapeOffset].B;  							}  							zBuffer[zIdx] = zBufVal;  							heightBuffer[zIdx] = hBufVal;  						}  					}  					//else {  					//	*(w + 0) = 0;  					//	*(w + 1) = 0;  					//	*(w + 2) = 255;  					//}    					// Up to the next pixel  					rIdx++;  					zIdx++;  					w += 3;  				}  				w += stride - 3 * img.Width;  				zIdx += ds.Width - img.Width;  			}
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawShadow,The following statement contains a magic number: frameIndex += shp.Images.Count / 2;
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawShadow,The following statement contains a magic number: offset.X += obj.Tile.Dx * Drawable.TileWidth / 2 - shp.Width / 2 + img.X;
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawShadow,The following statement contains a magic number: offset.X += obj.Tile.Dx * Drawable.TileWidth / 2 - shp.Width / 2 + img.X;
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawShadow,The following statement contains a magic number: offset.Y += (obj.Tile.Dy - obj.Tile.Z) * Drawable.TileHeight / 2 - shp.Height / 2 + img.Y;
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawShadow,The following statement contains a magic number: offset.Y += (obj.Tile.Dy - obj.Tile.Z) * Drawable.TileHeight / 2 - shp.Height / 2 + img.Y;
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawShadow,The following statement contains a magic number: byte* w = (byte*)ds.BitmapData.Scan0 + offset.X * 3 + stride * offset.Y;
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawShadow,The following statement contains a magic number: short zOffset = (short)((obj.Tile.Rx + obj.Tile.Ry) * Drawable.TileHeight / 2 - shp.Height / 2 + img.Y);
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawShadow,The following statement contains a magic number: short zOffset = (short)((obj.Tile.Rx + obj.Tile.Ry) * Drawable.TileHeight / 2 - shp.Height / 2 + img.Y);
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawShadow,The following statement contains a magic number: int castHeight = obj.Tile.Z * Drawable.TileHeight / 2;
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawShadow,The following statement contains a magic number: if (obj.Drawable != null && !obj.Drawable.Flat) {  				castHeight += shp.Height;  				castHeight += obj.Drawable.TileElevation * Drawable.TileHeight / 2;  			}
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawShadow,The following statement contains a magic number: for (int y = 0; y < img.Height; y++) {  				if (offset.Y + y < 0) {  					w += stride;  					rIdx += img.Width;  					zIdx += ds.Width;  					continue; // out of bounds  				}    				short zBufVal = zOffset;  				if (obj.Drawable.Flat)  					zBufVal += (short)y;  				else  					zBufVal += img.Height;    				for (int x = 0; x < img.Width; x++) {  					if (0 <= offset.X + x && offset.X + x < ds.Width && 0 <= y + offset.Y && y + offset.Y < ds.Height  						&& imgData[rIdx] != 0 && !shadows[zIdx]   						//&& zBufVal >= zBuffer[zIdx]   						&& castHeight >= heightBuffer[zIdx]  						) {  						*(w + 0) /= 2;  						*(w + 1) /= 2;  						*(w + 2) /= 2;  						shadows[zIdx] = true;  					}  					// Up to the next pixel  					rIdx++;  					zIdx++;  					w += 3;  				}  				w += stride - 3 * img.Width;	// ... and if we're no more on the same row'  				zIdx += ds.Width - img.Width;  				// adjust the writing pointer accordingy  			}
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawShadow,The following statement contains a magic number: for (int y = 0; y < img.Height; y++) {  				if (offset.Y + y < 0) {  					w += stride;  					rIdx += img.Width;  					zIdx += ds.Width;  					continue; // out of bounds  				}    				short zBufVal = zOffset;  				if (obj.Drawable.Flat)  					zBufVal += (short)y;  				else  					zBufVal += img.Height;    				for (int x = 0; x < img.Width; x++) {  					if (0 <= offset.X + x && offset.X + x < ds.Width && 0 <= y + offset.Y && y + offset.Y < ds.Height  						&& imgData[rIdx] != 0 && !shadows[zIdx]   						//&& zBufVal >= zBuffer[zIdx]   						&& castHeight >= heightBuffer[zIdx]  						) {  						*(w + 0) /= 2;  						*(w + 1) /= 2;  						*(w + 2) /= 2;  						shadows[zIdx] = true;  					}  					// Up to the next pixel  					rIdx++;  					zIdx++;  					w += 3;  				}  				w += stride - 3 * img.Width;	// ... and if we're no more on the same row'  				zIdx += ds.Width - img.Width;  				// adjust the writing pointer accordingy  			}
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawShadow,The following statement contains a magic number: for (int y = 0; y < img.Height; y++) {  				if (offset.Y + y < 0) {  					w += stride;  					rIdx += img.Width;  					zIdx += ds.Width;  					continue; // out of bounds  				}    				short zBufVal = zOffset;  				if (obj.Drawable.Flat)  					zBufVal += (short)y;  				else  					zBufVal += img.Height;    				for (int x = 0; x < img.Width; x++) {  					if (0 <= offset.X + x && offset.X + x < ds.Width && 0 <= y + offset.Y && y + offset.Y < ds.Height  						&& imgData[rIdx] != 0 && !shadows[zIdx]   						//&& zBufVal >= zBuffer[zIdx]   						&& castHeight >= heightBuffer[zIdx]  						) {  						*(w + 0) /= 2;  						*(w + 1) /= 2;  						*(w + 2) /= 2;  						shadows[zIdx] = true;  					}  					// Up to the next pixel  					rIdx++;  					zIdx++;  					w += 3;  				}  				w += stride - 3 * img.Width;	// ... and if we're no more on the same row'  				zIdx += ds.Width - img.Width;  				// adjust the writing pointer accordingy  			}
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawShadow,The following statement contains a magic number: for (int y = 0; y < img.Height; y++) {  				if (offset.Y + y < 0) {  					w += stride;  					rIdx += img.Width;  					zIdx += ds.Width;  					continue; // out of bounds  				}    				short zBufVal = zOffset;  				if (obj.Drawable.Flat)  					zBufVal += (short)y;  				else  					zBufVal += img.Height;    				for (int x = 0; x < img.Width; x++) {  					if (0 <= offset.X + x && offset.X + x < ds.Width && 0 <= y + offset.Y && y + offset.Y < ds.Height  						&& imgData[rIdx] != 0 && !shadows[zIdx]   						//&& zBufVal >= zBuffer[zIdx]   						&& castHeight >= heightBuffer[zIdx]  						) {  						*(w + 0) /= 2;  						*(w + 1) /= 2;  						*(w + 2) /= 2;  						shadows[zIdx] = true;  					}  					// Up to the next pixel  					rIdx++;  					zIdx++;  					w += 3;  				}  				w += stride - 3 * img.Width;	// ... and if we're no more on the same row'  				zIdx += ds.Width - img.Width;  				// adjust the writing pointer accordingy  			}
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawShadow,The following statement contains a magic number: for (int y = 0; y < img.Height; y++) {  				if (offset.Y + y < 0) {  					w += stride;  					rIdx += img.Width;  					zIdx += ds.Width;  					continue; // out of bounds  				}    				short zBufVal = zOffset;  				if (obj.Drawable.Flat)  					zBufVal += (short)y;  				else  					zBufVal += img.Height;    				for (int x = 0; x < img.Width; x++) {  					if (0 <= offset.X + x && offset.X + x < ds.Width && 0 <= y + offset.Y && y + offset.Y < ds.Height  						&& imgData[rIdx] != 0 && !shadows[zIdx]   						//&& zBufVal >= zBuffer[zIdx]   						&& castHeight >= heightBuffer[zIdx]  						) {  						*(w + 0) /= 2;  						*(w + 1) /= 2;  						*(w + 2) /= 2;  						shadows[zIdx] = true;  					}  					// Up to the next pixel  					rIdx++;  					zIdx++;  					w += 3;  				}  				w += stride - 3 * img.Width;	// ... and if we're no more on the same row'  				zIdx += ds.Width - img.Width;  				// adjust the writing pointer accordingy  			}
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawShadow,The following statement contains a magic number: for (int y = 0; y < img.Height; y++) {  				if (offset.Y + y < 0) {  					w += stride;  					rIdx += img.Width;  					zIdx += ds.Width;  					continue; // out of bounds  				}    				short zBufVal = zOffset;  				if (obj.Drawable.Flat)  					zBufVal += (short)y;  				else  					zBufVal += img.Height;    				for (int x = 0; x < img.Width; x++) {  					if (0 <= offset.X + x && offset.X + x < ds.Width && 0 <= y + offset.Y && y + offset.Y < ds.Height  						&& imgData[rIdx] != 0 && !shadows[zIdx]   						//&& zBufVal >= zBuffer[zIdx]   						&& castHeight >= heightBuffer[zIdx]  						) {  						*(w + 0) /= 2;  						*(w + 1) /= 2;  						*(w + 2) /= 2;  						shadows[zIdx] = true;  					}  					// Up to the next pixel  					rIdx++;  					zIdx++;  					w += 3;  				}  				w += stride - 3 * img.Width;	// ... and if we're no more on the same row'  				zIdx += ds.Width - img.Width;  				// adjust the writing pointer accordingy  			}
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawAlpha,The following statement contains a magic number: offset.X += obj.Tile.Dx * Drawable.TileWidth / 2;
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawAlpha,The following statement contains a magic number: offset.Y += (obj.Tile.Dy - obj.Tile.Z) * Drawable.TileHeight / 2;
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawAlpha,The following statement contains a magic number: int dx = offset.X + Drawable.TileWidth / 2 - shp.Width / 2 + img.X'  				dy = offset.Y - shp.Height / 2 + img.Y;
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawAlpha,The following statement contains a magic number: int dx = offset.X + Drawable.TileWidth / 2 - shp.Width / 2 + img.X'  				dy = offset.Y - shp.Height / 2 + img.Y;
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawAlpha,The following statement contains a magic number: int dx = offset.X + Drawable.TileWidth / 2 - shp.Width / 2 + img.X'  				dy = offset.Y - shp.Height / 2 + img.Y;
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawAlpha,The following statement contains a magic number: byte* w = (byte*)ds.BitmapData.Scan0 + dx * 3 + stride * dy;
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawAlpha,The following statement contains a magic number: short zOffset = (short)((obj.Tile.Rx + obj.Tile.Ry) * Drawable.TileHeight / 2 - shp.Height / 2 + img.Y);
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawAlpha,The following statement contains a magic number: short zOffset = (short)((obj.Tile.Rx + obj.Tile.Ry) * Drawable.TileHeight / 2 - shp.Height / 2 + img.Y);
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawAlpha,The following statement contains a magic number: for (int y = 0; y < img.Height; y++) {  				for (int x = 0; x < img.Width; x++) {  					if (imgData[rIdx] != 0 && w_low <= w && w < w_high) {  						float mult = imgData[rIdx] / 127.0f;  						*(w + 0) = limit(mult' *(w + 0));  						*(w + 1) = limit(mult' *(w + 1));  						*(w + 2) = limit(mult' *(w + 2));  					}  					// Up to the next pixel  					rIdx++;  					w += 3;  				}  				w += stride - 3 * img.Width;	// ... and if we're no more on the same row'  				// adjust the writing pointer accordingy  			}
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawAlpha,The following statement contains a magic number: for (int y = 0; y < img.Height; y++) {  				for (int x = 0; x < img.Width; x++) {  					if (imgData[rIdx] != 0 && w_low <= w && w < w_high) {  						float mult = imgData[rIdx] / 127.0f;  						*(w + 0) = limit(mult' *(w + 0));  						*(w + 1) = limit(mult' *(w + 1));  						*(w + 2) = limit(mult' *(w + 2));  					}  					// Up to the next pixel  					rIdx++;  					w += 3;  				}  				w += stride - 3 * img.Width;	// ... and if we're no more on the same row'  				// adjust the writing pointer accordingy  			}
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawAlpha,The following statement contains a magic number: for (int y = 0; y < img.Height; y++) {  				for (int x = 0; x < img.Width; x++) {  					if (imgData[rIdx] != 0 && w_low <= w && w < w_high) {  						float mult = imgData[rIdx] / 127.0f;  						*(w + 0) = limit(mult' *(w + 0));  						*(w + 1) = limit(mult' *(w + 1));  						*(w + 2) = limit(mult' *(w + 2));  					}  					// Up to the next pixel  					rIdx++;  					w += 3;  				}  				w += stride - 3 * img.Width;	// ... and if we're no more on the same row'  				// adjust the writing pointer accordingy  			}
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,DrawAlpha,The following statement contains a magic number: for (int y = 0; y < img.Height; y++) {  				for (int x = 0; x < img.Width; x++) {  					if (imgData[rIdx] != 0 && w_low <= w && w < w_high) {  						float mult = imgData[rIdx] / 127.0f;  						*(w + 0) = limit(mult' *(w + 0));  						*(w + 1) = limit(mult' *(w + 1));  						*(w + 2) = limit(mult' *(w + 2));  					}  					// Up to the next pixel  					rIdx++;  					w += 3;  				}  				w += stride - 3 * img.Width;	// ... and if we're no more on the same row'  				// adjust the writing pointer accordingy  			}
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,GetBuildingZ,The following statement contains a magic number: x += zImg.Width / 2 - shp.Width / 2 + img.X;
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,GetBuildingZ,The following statement contains a magic number: x += zImg.Width / 2 - shp.Width / 2 + img.X;
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,GetBuildingZ,The following statement contains a magic number: x -= (obj.Drawable.Foundation.Width - obj.Drawable.Foundation.Height) * 30;
Magic Number,CNCMaps.Engine.Rendering,ShpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\ShpRenderer.cs,GetBuildingZ,The following statement contains a magic number: return (short)(-64 + zData[y * zImg.Width + x]);
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,GetBounds,The following statement contains a magic number: int left = tile.Dx * tmp.BlockWidth / 2;
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,GetBounds,The following statement contains a magic number: int top = (tile.Dy - tile.Z) * tmp.BlockHeight / 2;
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: Point offset = new Point(tile.Dx * tmp.BlockWidth / 2' (tile.Dy - tile.Z) * tmp.BlockHeight / 2);
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: Point offset = new Point(tile.Dx * tmp.BlockWidth / 2' (tile.Dy - tile.Z) * tmp.BlockHeight / 2);
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: Point center = offset + new Size(tmp.BlockWidth / 2' tmp.BlockHeight / 2);
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: Point center = offset + new Size(tmp.BlockWidth / 2' tmp.BlockHeight / 2);
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: if (centerGridTile != null) {  				tile.Layer.GridTouched[centerGridTile.Dx' centerGridTile.Dy / 2] |= TileLayer.TouchType.ByNormalData;  				tile.Layer.GridTouchedBy[centerGridTile.Dx' centerGridTile.Dy / 2] = tile;  			}
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: if (centerGridTile != null) {  				tile.Layer.GridTouched[centerGridTile.Dx' centerGridTile.Dy / 2] |= TileLayer.TouchType.ByNormalData;  				tile.Layer.GridTouchedBy[centerGridTile.Dx' centerGridTile.Dy / 2] = tile;  			}
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: int halfCx = tmp.BlockWidth / 2'  				halfCy = tmp.BlockHeight / 2;
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: int halfCx = tmp.BlockWidth / 2'  				halfCy = tmp.BlockHeight / 2;
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: byte* w = (byte*)ds.BitmapData.Scan0 + stride * offset.Y + (offset.X + halfCx - 2) * 3;
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: byte* w = (byte*)ds.BitmapData.Scan0 + stride * offset.Y + (offset.X + halfCx - 2) * 3;
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: int zIdx = offset.Y * ds.Width + offset.X + halfCx - 2;
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: for (; y < halfCy; y++) {  				cx += 4;  				for (ushort c = 0; c < cx; c++) {  					byte paletteValue = img.TileData[rIdx];    					short zBufVal = (short)((tile.Rx + tile.Ry) * tmp.BlockHeight / 2 - (img.ZData != null ? img.ZData[rIdx] : 0));  					if (paletteValue != 0 && w_low <= w && w < w_high && zBufVal >= zBuffer[zIdx]) {  						*(w + 0) = p.Colors[paletteValue].B;  						*(w + 1) = p.Colors[paletteValue].G;  						*(w + 2) = p.Colors[paletteValue].R;  						zBuffer[zIdx] = zBufVal;  						heightBuffer[zIdx] = (short)(tile.Z * Drawable.TileHeight / 2);  					}  					w += 3;  					zIdx++;  					rIdx++;  				}  				w += stride - 3 * (cx + 2);  				zIdx += ds.Width - (cx + 2);  			}
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: for (; y < halfCy; y++) {  				cx += 4;  				for (ushort c = 0; c < cx; c++) {  					byte paletteValue = img.TileData[rIdx];    					short zBufVal = (short)((tile.Rx + tile.Ry) * tmp.BlockHeight / 2 - (img.ZData != null ? img.ZData[rIdx] : 0));  					if (paletteValue != 0 && w_low <= w && w < w_high && zBufVal >= zBuffer[zIdx]) {  						*(w + 0) = p.Colors[paletteValue].B;  						*(w + 1) = p.Colors[paletteValue].G;  						*(w + 2) = p.Colors[paletteValue].R;  						zBuffer[zIdx] = zBufVal;  						heightBuffer[zIdx] = (short)(tile.Z * Drawable.TileHeight / 2);  					}  					w += 3;  					zIdx++;  					rIdx++;  				}  				w += stride - 3 * (cx + 2);  				zIdx += ds.Width - (cx + 2);  			}
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: for (; y < halfCy; y++) {  				cx += 4;  				for (ushort c = 0; c < cx; c++) {  					byte paletteValue = img.TileData[rIdx];    					short zBufVal = (short)((tile.Rx + tile.Ry) * tmp.BlockHeight / 2 - (img.ZData != null ? img.ZData[rIdx] : 0));  					if (paletteValue != 0 && w_low <= w && w < w_high && zBufVal >= zBuffer[zIdx]) {  						*(w + 0) = p.Colors[paletteValue].B;  						*(w + 1) = p.Colors[paletteValue].G;  						*(w + 2) = p.Colors[paletteValue].R;  						zBuffer[zIdx] = zBufVal;  						heightBuffer[zIdx] = (short)(tile.Z * Drawable.TileHeight / 2);  					}  					w += 3;  					zIdx++;  					rIdx++;  				}  				w += stride - 3 * (cx + 2);  				zIdx += ds.Width - (cx + 2);  			}
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: for (; y < halfCy; y++) {  				cx += 4;  				for (ushort c = 0; c < cx; c++) {  					byte paletteValue = img.TileData[rIdx];    					short zBufVal = (short)((tile.Rx + tile.Ry) * tmp.BlockHeight / 2 - (img.ZData != null ? img.ZData[rIdx] : 0));  					if (paletteValue != 0 && w_low <= w && w < w_high && zBufVal >= zBuffer[zIdx]) {  						*(w + 0) = p.Colors[paletteValue].B;  						*(w + 1) = p.Colors[paletteValue].G;  						*(w + 2) = p.Colors[paletteValue].R;  						zBuffer[zIdx] = zBufVal;  						heightBuffer[zIdx] = (short)(tile.Z * Drawable.TileHeight / 2);  					}  					w += 3;  					zIdx++;  					rIdx++;  				}  				w += stride - 3 * (cx + 2);  				zIdx += ds.Width - (cx + 2);  			}
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: for (; y < halfCy; y++) {  				cx += 4;  				for (ushort c = 0; c < cx; c++) {  					byte paletteValue = img.TileData[rIdx];    					short zBufVal = (short)((tile.Rx + tile.Ry) * tmp.BlockHeight / 2 - (img.ZData != null ? img.ZData[rIdx] : 0));  					if (paletteValue != 0 && w_low <= w && w < w_high && zBufVal >= zBuffer[zIdx]) {  						*(w + 0) = p.Colors[paletteValue].B;  						*(w + 1) = p.Colors[paletteValue].G;  						*(w + 2) = p.Colors[paletteValue].R;  						zBuffer[zIdx] = zBufVal;  						heightBuffer[zIdx] = (short)(tile.Z * Drawable.TileHeight / 2);  					}  					w += 3;  					zIdx++;  					rIdx++;  				}  				w += stride - 3 * (cx + 2);  				zIdx += ds.Width - (cx + 2);  			}
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: for (; y < halfCy; y++) {  				cx += 4;  				for (ushort c = 0; c < cx; c++) {  					byte paletteValue = img.TileData[rIdx];    					short zBufVal = (short)((tile.Rx + tile.Ry) * tmp.BlockHeight / 2 - (img.ZData != null ? img.ZData[rIdx] : 0));  					if (paletteValue != 0 && w_low <= w && w < w_high && zBufVal >= zBuffer[zIdx]) {  						*(w + 0) = p.Colors[paletteValue].B;  						*(w + 1) = p.Colors[paletteValue].G;  						*(w + 2) = p.Colors[paletteValue].R;  						zBuffer[zIdx] = zBufVal;  						heightBuffer[zIdx] = (short)(tile.Z * Drawable.TileHeight / 2);  					}  					w += 3;  					zIdx++;  					rIdx++;  				}  				w += stride - 3 * (cx + 2);  				zIdx += ds.Width - (cx + 2);  			}
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: for (; y < halfCy; y++) {  				cx += 4;  				for (ushort c = 0; c < cx; c++) {  					byte paletteValue = img.TileData[rIdx];    					short zBufVal = (short)((tile.Rx + tile.Ry) * tmp.BlockHeight / 2 - (img.ZData != null ? img.ZData[rIdx] : 0));  					if (paletteValue != 0 && w_low <= w && w < w_high && zBufVal >= zBuffer[zIdx]) {  						*(w + 0) = p.Colors[paletteValue].B;  						*(w + 1) = p.Colors[paletteValue].G;  						*(w + 2) = p.Colors[paletteValue].R;  						zBuffer[zIdx] = zBufVal;  						heightBuffer[zIdx] = (short)(tile.Z * Drawable.TileHeight / 2);  					}  					w += 3;  					zIdx++;  					rIdx++;  				}  				w += stride - 3 * (cx + 2);  				zIdx += ds.Width - (cx + 2);  			}
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: for (; y < halfCy; y++) {  				cx += 4;  				for (ushort c = 0; c < cx; c++) {  					byte paletteValue = img.TileData[rIdx];    					short zBufVal = (short)((tile.Rx + tile.Ry) * tmp.BlockHeight / 2 - (img.ZData != null ? img.ZData[rIdx] : 0));  					if (paletteValue != 0 && w_low <= w && w < w_high && zBufVal >= zBuffer[zIdx]) {  						*(w + 0) = p.Colors[paletteValue].B;  						*(w + 1) = p.Colors[paletteValue].G;  						*(w + 2) = p.Colors[paletteValue].R;  						zBuffer[zIdx] = zBufVal;  						heightBuffer[zIdx] = (short)(tile.Z * Drawable.TileHeight / 2);  					}  					w += 3;  					zIdx++;  					rIdx++;  				}  				w += stride - 3 * (cx + 2);  				zIdx += ds.Width - (cx + 2);  			}
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: w += 12;
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: zIdx += 4;
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: for (; y < tmp.BlockHeight; y++) {  				cx -= 4;  				for (ushort c = 0; c < cx; c++) {  					byte paletteValue = img.TileData[rIdx];    					short zBufVal = (short)((tile.Rx + tile.Ry) * tmp.BlockHeight / 2 - (img.ZData != null ? img.ZData[rIdx] : 0));  					if (paletteValue != 0 && w_low <= w && w < w_high && zBufVal >= zBuffer[zIdx]) {  						*(w + 0) = p.Colors[paletteValue].B;  						*(w + 1) = p.Colors[paletteValue].G;  						*(w + 2) = p.Colors[paletteValue].R;  						zBuffer[zIdx] = zBufVal;  						heightBuffer[zIdx] = (short)(tile.Z * Drawable.TileHeight / 2);  					}  					w += 3;  					zIdx++;  					rIdx++;  				}  				w += stride - 3 * (cx - 2);  				zIdx += ds.Width - (cx - 2);  			}
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: for (; y < tmp.BlockHeight; y++) {  				cx -= 4;  				for (ushort c = 0; c < cx; c++) {  					byte paletteValue = img.TileData[rIdx];    					short zBufVal = (short)((tile.Rx + tile.Ry) * tmp.BlockHeight / 2 - (img.ZData != null ? img.ZData[rIdx] : 0));  					if (paletteValue != 0 && w_low <= w && w < w_high && zBufVal >= zBuffer[zIdx]) {  						*(w + 0) = p.Colors[paletteValue].B;  						*(w + 1) = p.Colors[paletteValue].G;  						*(w + 2) = p.Colors[paletteValue].R;  						zBuffer[zIdx] = zBufVal;  						heightBuffer[zIdx] = (short)(tile.Z * Drawable.TileHeight / 2);  					}  					w += 3;  					zIdx++;  					rIdx++;  				}  				w += stride - 3 * (cx - 2);  				zIdx += ds.Width - (cx - 2);  			}
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: for (; y < tmp.BlockHeight; y++) {  				cx -= 4;  				for (ushort c = 0; c < cx; c++) {  					byte paletteValue = img.TileData[rIdx];    					short zBufVal = (short)((tile.Rx + tile.Ry) * tmp.BlockHeight / 2 - (img.ZData != null ? img.ZData[rIdx] : 0));  					if (paletteValue != 0 && w_low <= w && w < w_high && zBufVal >= zBuffer[zIdx]) {  						*(w + 0) = p.Colors[paletteValue].B;  						*(w + 1) = p.Colors[paletteValue].G;  						*(w + 2) = p.Colors[paletteValue].R;  						zBuffer[zIdx] = zBufVal;  						heightBuffer[zIdx] = (short)(tile.Z * Drawable.TileHeight / 2);  					}  					w += 3;  					zIdx++;  					rIdx++;  				}  				w += stride - 3 * (cx - 2);  				zIdx += ds.Width - (cx - 2);  			}
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: for (; y < tmp.BlockHeight; y++) {  				cx -= 4;  				for (ushort c = 0; c < cx; c++) {  					byte paletteValue = img.TileData[rIdx];    					short zBufVal = (short)((tile.Rx + tile.Ry) * tmp.BlockHeight / 2 - (img.ZData != null ? img.ZData[rIdx] : 0));  					if (paletteValue != 0 && w_low <= w && w < w_high && zBufVal >= zBuffer[zIdx]) {  						*(w + 0) = p.Colors[paletteValue].B;  						*(w + 1) = p.Colors[paletteValue].G;  						*(w + 2) = p.Colors[paletteValue].R;  						zBuffer[zIdx] = zBufVal;  						heightBuffer[zIdx] = (short)(tile.Z * Drawable.TileHeight / 2);  					}  					w += 3;  					zIdx++;  					rIdx++;  				}  				w += stride - 3 * (cx - 2);  				zIdx += ds.Width - (cx - 2);  			}
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: for (; y < tmp.BlockHeight; y++) {  				cx -= 4;  				for (ushort c = 0; c < cx; c++) {  					byte paletteValue = img.TileData[rIdx];    					short zBufVal = (short)((tile.Rx + tile.Ry) * tmp.BlockHeight / 2 - (img.ZData != null ? img.ZData[rIdx] : 0));  					if (paletteValue != 0 && w_low <= w && w < w_high && zBufVal >= zBuffer[zIdx]) {  						*(w + 0) = p.Colors[paletteValue].B;  						*(w + 1) = p.Colors[paletteValue].G;  						*(w + 2) = p.Colors[paletteValue].R;  						zBuffer[zIdx] = zBufVal;  						heightBuffer[zIdx] = (short)(tile.Z * Drawable.TileHeight / 2);  					}  					w += 3;  					zIdx++;  					rIdx++;  				}  				w += stride - 3 * (cx - 2);  				zIdx += ds.Width - (cx - 2);  			}
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: for (; y < tmp.BlockHeight; y++) {  				cx -= 4;  				for (ushort c = 0; c < cx; c++) {  					byte paletteValue = img.TileData[rIdx];    					short zBufVal = (short)((tile.Rx + tile.Ry) * tmp.BlockHeight / 2 - (img.ZData != null ? img.ZData[rIdx] : 0));  					if (paletteValue != 0 && w_low <= w && w < w_high && zBufVal >= zBuffer[zIdx]) {  						*(w + 0) = p.Colors[paletteValue].B;  						*(w + 1) = p.Colors[paletteValue].G;  						*(w + 2) = p.Colors[paletteValue].R;  						zBuffer[zIdx] = zBufVal;  						heightBuffer[zIdx] = (short)(tile.Z * Drawable.TileHeight / 2);  					}  					w += 3;  					zIdx++;  					rIdx++;  				}  				w += stride - 3 * (cx - 2);  				zIdx += ds.Width - (cx - 2);  			}
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: for (; y < tmp.BlockHeight; y++) {  				cx -= 4;  				for (ushort c = 0; c < cx; c++) {  					byte paletteValue = img.TileData[rIdx];    					short zBufVal = (short)((tile.Rx + tile.Ry) * tmp.BlockHeight / 2 - (img.ZData != null ? img.ZData[rIdx] : 0));  					if (paletteValue != 0 && w_low <= w && w < w_high && zBufVal >= zBuffer[zIdx]) {  						*(w + 0) = p.Colors[paletteValue].B;  						*(w + 1) = p.Colors[paletteValue].G;  						*(w + 2) = p.Colors[paletteValue].R;  						zBuffer[zIdx] = zBufVal;  						heightBuffer[zIdx] = (short)(tile.Z * Drawable.TileHeight / 2);  					}  					w += 3;  					zIdx++;  					rIdx++;  				}  				w += stride - 3 * (cx - 2);  				zIdx += ds.Width - (cx - 2);  			}
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: for (; y < tmp.BlockHeight; y++) {  				cx -= 4;  				for (ushort c = 0; c < cx; c++) {  					byte paletteValue = img.TileData[rIdx];    					short zBufVal = (short)((tile.Rx + tile.Ry) * tmp.BlockHeight / 2 - (img.ZData != null ? img.ZData[rIdx] : 0));  					if (paletteValue != 0 && w_low <= w && w < w_high && zBufVal >= zBuffer[zIdx]) {  						*(w + 0) = p.Colors[paletteValue].B;  						*(w + 1) = p.Colors[paletteValue].G;  						*(w + 2) = p.Colors[paletteValue].R;  						zBuffer[zIdx] = zBufVal;  						heightBuffer[zIdx] = (short)(tile.Z * Drawable.TileHeight / 2);  					}  					w += 3;  					zIdx++;  					rIdx++;  				}  				w += stride - 3 * (cx - 2);  				zIdx += ds.Width - (cx - 2);  			}
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: w = w_low + stride * offset.Y + 3 * offset.X;
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: for (int by = extraScreenBounds.Top; by < extraScreenBounds.Bottom; by += tmp.BlockHeight / 2) {  				for (int bx = extraScreenBounds.Left; bx < extraScreenBounds.Right; bx += tmp.BlockWidth / 2) {  					var gridTileNoZ = tile.Layer.GetTileScreen(new Point(bx' by)' true' true);  					if (gridTileNoZ != null) {  						Logger.Trace("Tile at ({0}'{1}) has extradata affecting ({2}'{3})"' tile.Dx' tile.Dy' gridTileNoZ.Dx'  							gridTileNoZ.Dy);  						tile.Layer.GridTouched[gridTileNoZ.Dx' gridTileNoZ.Dy / 2] |= TileLayer.TouchType.ByExtraData;  						tile.Layer.GridTouchedBy[gridTileNoZ.Dx' gridTileNoZ.Dy / 2] = tile;  					}  				}  			}
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: for (int by = extraScreenBounds.Top; by < extraScreenBounds.Bottom; by += tmp.BlockHeight / 2) {  				for (int bx = extraScreenBounds.Left; bx < extraScreenBounds.Right; bx += tmp.BlockWidth / 2) {  					var gridTileNoZ = tile.Layer.GetTileScreen(new Point(bx' by)' true' true);  					if (gridTileNoZ != null) {  						Logger.Trace("Tile at ({0}'{1}) has extradata affecting ({2}'{3})"' tile.Dx' tile.Dy' gridTileNoZ.Dx'  							gridTileNoZ.Dy);  						tile.Layer.GridTouched[gridTileNoZ.Dx' gridTileNoZ.Dy / 2] |= TileLayer.TouchType.ByExtraData;  						tile.Layer.GridTouchedBy[gridTileNoZ.Dx' gridTileNoZ.Dy / 2] = tile;  					}  				}  			}
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: for (int by = extraScreenBounds.Top; by < extraScreenBounds.Bottom; by += tmp.BlockHeight / 2) {  				for (int bx = extraScreenBounds.Left; bx < extraScreenBounds.Right; bx += tmp.BlockWidth / 2) {  					var gridTileNoZ = tile.Layer.GetTileScreen(new Point(bx' by)' true' true);  					if (gridTileNoZ != null) {  						Logger.Trace("Tile at ({0}'{1}) has extradata affecting ({2}'{3})"' tile.Dx' tile.Dy' gridTileNoZ.Dx'  							gridTileNoZ.Dy);  						tile.Layer.GridTouched[gridTileNoZ.Dx' gridTileNoZ.Dy / 2] |= TileLayer.TouchType.ByExtraData;  						tile.Layer.GridTouchedBy[gridTileNoZ.Dx' gridTileNoZ.Dy / 2] = tile;  					}  				}  			}
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: for (int by = extraScreenBounds.Top; by < extraScreenBounds.Bottom; by += tmp.BlockHeight / 2) {  				for (int bx = extraScreenBounds.Left; bx < extraScreenBounds.Right; bx += tmp.BlockWidth / 2) {  					var gridTileNoZ = tile.Layer.GetTileScreen(new Point(bx' by)' true' true);  					if (gridTileNoZ != null) {  						Logger.Trace("Tile at ({0}'{1}) has extradata affecting ({2}'{3})"' tile.Dx' tile.Dy' gridTileNoZ.Dx'  							gridTileNoZ.Dy);  						tile.Layer.GridTouched[gridTileNoZ.Dx' gridTileNoZ.Dy / 2] |= TileLayer.TouchType.ByExtraData;  						tile.Layer.GridTouchedBy[gridTileNoZ.Dx' gridTileNoZ.Dy / 2] = tile;  					}  				}  			}
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: for (y = 0; y < img.ExtraHeight; y++) {  				for (x = 0; x < img.ExtraWidth; x++) {  					// Checking per line is required because v needs to be checked every time  					byte paletteValue = img.ExtraData[rIdx];  					short zBufVal = (short)((tile.Rx + tile.Ry) * tmp.BlockHeight / 2 + (img.ExtraZData != null ? img.ExtraZData[rIdx] : 0));    					if (paletteValue != 0 && w_low <= w && w < w_high && zBufVal >= zBuffer[zIdx]) {  						*w++ = p.Colors[paletteValue].B;  						*w++ = p.Colors[paletteValue].G;  						*w++ = p.Colors[paletteValue].R;  						zBuffer[zIdx] = zBufVal;  						heightBuffer[zIdx] = (short)(img.ExtraHeight - y + tile.Z * Drawable.TileHeight / 2);  					}  					else  						w += 3;  					zIdx++;  					rIdx++;  				}  				w += stride - img.ExtraWidth * 3;  				zIdx += ds.Width - img.ExtraWidth;  			}
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: for (y = 0; y < img.ExtraHeight; y++) {  				for (x = 0; x < img.ExtraWidth; x++) {  					// Checking per line is required because v needs to be checked every time  					byte paletteValue = img.ExtraData[rIdx];  					short zBufVal = (short)((tile.Rx + tile.Ry) * tmp.BlockHeight / 2 + (img.ExtraZData != null ? img.ExtraZData[rIdx] : 0));    					if (paletteValue != 0 && w_low <= w && w < w_high && zBufVal >= zBuffer[zIdx]) {  						*w++ = p.Colors[paletteValue].B;  						*w++ = p.Colors[paletteValue].G;  						*w++ = p.Colors[paletteValue].R;  						zBuffer[zIdx] = zBufVal;  						heightBuffer[zIdx] = (short)(img.ExtraHeight - y + tile.Z * Drawable.TileHeight / 2);  					}  					else  						w += 3;  					zIdx++;  					rIdx++;  				}  				w += stride - img.ExtraWidth * 3;  				zIdx += ds.Width - img.ExtraWidth;  			}
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: for (y = 0; y < img.ExtraHeight; y++) {  				for (x = 0; x < img.ExtraWidth; x++) {  					// Checking per line is required because v needs to be checked every time  					byte paletteValue = img.ExtraData[rIdx];  					short zBufVal = (short)((tile.Rx + tile.Ry) * tmp.BlockHeight / 2 + (img.ExtraZData != null ? img.ExtraZData[rIdx] : 0));    					if (paletteValue != 0 && w_low <= w && w < w_high && zBufVal >= zBuffer[zIdx]) {  						*w++ = p.Colors[paletteValue].B;  						*w++ = p.Colors[paletteValue].G;  						*w++ = p.Colors[paletteValue].R;  						zBuffer[zIdx] = zBufVal;  						heightBuffer[zIdx] = (short)(img.ExtraHeight - y + tile.Z * Drawable.TileHeight / 2);  					}  					else  						w += 3;  					zIdx++;  					rIdx++;  				}  				w += stride - img.ExtraWidth * 3;  				zIdx += ds.Width - img.ExtraWidth;  			}
Magic Number,CNCMaps.Engine.Rendering,TmpRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\TmpRenderer.cs,Draw,The following statement contains a magic number: for (y = 0; y < img.ExtraHeight; y++) {  				for (x = 0; x < img.ExtraWidth; x++) {  					// Checking per line is required because v needs to be checked every time  					byte paletteValue = img.ExtraData[rIdx];  					short zBufVal = (short)((tile.Rx + tile.Ry) * tmp.BlockHeight / 2 + (img.ExtraZData != null ? img.ExtraZData[rIdx] : 0));    					if (paletteValue != 0 && w_low <= w && w < w_high && zBufVal >= zBuffer[zIdx]) {  						*w++ = p.Colors[paletteValue].B;  						*w++ = p.Colors[paletteValue].G;  						*w++ = p.Colors[paletteValue].R;  						zBuffer[zIdx] = zBufVal;  						heightBuffer[zIdx] = (short)(img.ExtraHeight - y + tile.Z * Drawable.TileHeight / 2);  					}  					else  						w += 3;  					zIdx++;  					rIdx++;  				}  				w += stride - img.ExtraWidth * 3;  				zIdx += ds.Width - img.ExtraWidth;  			}
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Initialize,The following statement contains a magic number: _surface = new DrawingSurface(400' 400' PixelFormat.Format32bppArgb);
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Initialize,The following statement contains a magic number: _surface = new DrawingSurface(400' 400' PixelFormat.Format32bppArgb);
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,The following statement contains a magic number: var persp = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(30)' _surface.BitmapData.Width / (float)_surface.BitmapData.Height' 1' _surface.BitmapData.Height);
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,The following statement contains a magic number: var lookat = Matrix4.LookAt(0' 0' -10' 0' 0' 0' 0' 1' 0);
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,The following statement contains a magic number: var trans = Matrix4.CreateTranslation(0' 0' 10);
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,The following statement contains a magic number: var world = Matrix4.CreateRotationX(MathHelper.DegreesToRadians(60));
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,The following statement contains a magic number: world = Matrix4.CreateRotationY(MathHelper.DegreesToRadians(180)) * world;
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,The following statement contains a magic number: world = Matrix4.CreateRotationZ(MathHelper.DegreesToRadians(-45)) * world;
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,The following statement contains a magic number: if (obj.Tile.Drawable != null) {  				var img = (obj.Tile.Drawable as TileDrawable).GetTileImage(obj.Tile);  				int ramp = img?.RampType ?? 0;  				if (ramp == 0 || ramp >= 17) {  					tiltPitch = tiltYaw = 0;  				}  				else if (ramp <= 4) {  					// screen-diagonal facings (perpendicular to axes)  					tiltPitch = 25;  					tiltYaw = -90 * ramp;  				}  				else {  					// world-diagonal facings (perpendicular to screen)  					tiltPitch = 25;  					tiltYaw = 225 - 90 * ((ramp - 1) % 4);  				}  				tilt *= Matrix4.CreateRotationX(MathHelper.DegreesToRadians(tiltPitch));  				tilt *= Matrix4.CreateRotationZ(MathHelper.DegreesToRadians(tiltYaw));    				/*// show tilt direction  				GL.Color3(Color.Black);  				GL.Begin(BeginMode.Lines);  				GL.Vertex3(Vector3.Zero);  				var tiltVec = Vector3.UnitZ;  				tiltVec = Vector3.Transform(tiltVec' tilt);  				tiltVec = Vector3.Multiply(tiltVec' 1000f);  				GL.Vertex3(tiltVec);  				GL.End();*/  			}
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,The following statement contains a magic number: if (obj.Tile.Drawable != null) {  				var img = (obj.Tile.Drawable as TileDrawable).GetTileImage(obj.Tile);  				int ramp = img?.RampType ?? 0;  				if (ramp == 0 || ramp >= 17) {  					tiltPitch = tiltYaw = 0;  				}  				else if (ramp <= 4) {  					// screen-diagonal facings (perpendicular to axes)  					tiltPitch = 25;  					tiltYaw = -90 * ramp;  				}  				else {  					// world-diagonal facings (perpendicular to screen)  					tiltPitch = 25;  					tiltYaw = 225 - 90 * ((ramp - 1) % 4);  				}  				tilt *= Matrix4.CreateRotationX(MathHelper.DegreesToRadians(tiltPitch));  				tilt *= Matrix4.CreateRotationZ(MathHelper.DegreesToRadians(tiltYaw));    				/*// show tilt direction  				GL.Color3(Color.Black);  				GL.Begin(BeginMode.Lines);  				GL.Vertex3(Vector3.Zero);  				var tiltVec = Vector3.UnitZ;  				tiltVec = Vector3.Transform(tiltVec' tilt);  				tiltVec = Vector3.Multiply(tiltVec' 1000f);  				GL.Vertex3(tiltVec);  				GL.End();*/  			}
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,The following statement contains a magic number: if (obj.Tile.Drawable != null) {  				var img = (obj.Tile.Drawable as TileDrawable).GetTileImage(obj.Tile);  				int ramp = img?.RampType ?? 0;  				if (ramp == 0 || ramp >= 17) {  					tiltPitch = tiltYaw = 0;  				}  				else if (ramp <= 4) {  					// screen-diagonal facings (perpendicular to axes)  					tiltPitch = 25;  					tiltYaw = -90 * ramp;  				}  				else {  					// world-diagonal facings (perpendicular to screen)  					tiltPitch = 25;  					tiltYaw = 225 - 90 * ((ramp - 1) % 4);  				}  				tilt *= Matrix4.CreateRotationX(MathHelper.DegreesToRadians(tiltPitch));  				tilt *= Matrix4.CreateRotationZ(MathHelper.DegreesToRadians(tiltYaw));    				/*// show tilt direction  				GL.Color3(Color.Black);  				GL.Begin(BeginMode.Lines);  				GL.Vertex3(Vector3.Zero);  				var tiltVec = Vector3.UnitZ;  				tiltVec = Vector3.Transform(tiltVec' tilt);  				tiltVec = Vector3.Multiply(tiltVec' 1000f);  				GL.Vertex3(tiltVec);  				GL.End();*/  			}
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,The following statement contains a magic number: if (obj.Tile.Drawable != null) {  				var img = (obj.Tile.Drawable as TileDrawable).GetTileImage(obj.Tile);  				int ramp = img?.RampType ?? 0;  				if (ramp == 0 || ramp >= 17) {  					tiltPitch = tiltYaw = 0;  				}  				else if (ramp <= 4) {  					// screen-diagonal facings (perpendicular to axes)  					tiltPitch = 25;  					tiltYaw = -90 * ramp;  				}  				else {  					// world-diagonal facings (perpendicular to screen)  					tiltPitch = 25;  					tiltYaw = 225 - 90 * ((ramp - 1) % 4);  				}  				tilt *= Matrix4.CreateRotationX(MathHelper.DegreesToRadians(tiltPitch));  				tilt *= Matrix4.CreateRotationZ(MathHelper.DegreesToRadians(tiltYaw));    				/*// show tilt direction  				GL.Color3(Color.Black);  				GL.Begin(BeginMode.Lines);  				GL.Vertex3(Vector3.Zero);  				var tiltVec = Vector3.UnitZ;  				tiltVec = Vector3.Transform(tiltVec' tilt);  				tiltVec = Vector3.Multiply(tiltVec' 1000f);  				GL.Vertex3(tiltVec);  				GL.End();*/  			}
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,The following statement contains a magic number: if (obj.Tile.Drawable != null) {  				var img = (obj.Tile.Drawable as TileDrawable).GetTileImage(obj.Tile);  				int ramp = img?.RampType ?? 0;  				if (ramp == 0 || ramp >= 17) {  					tiltPitch = tiltYaw = 0;  				}  				else if (ramp <= 4) {  					// screen-diagonal facings (perpendicular to axes)  					tiltPitch = 25;  					tiltYaw = -90 * ramp;  				}  				else {  					// world-diagonal facings (perpendicular to screen)  					tiltPitch = 25;  					tiltYaw = 225 - 90 * ((ramp - 1) % 4);  				}  				tilt *= Matrix4.CreateRotationX(MathHelper.DegreesToRadians(tiltPitch));  				tilt *= Matrix4.CreateRotationZ(MathHelper.DegreesToRadians(tiltYaw));    				/*// show tilt direction  				GL.Color3(Color.Black);  				GL.Begin(BeginMode.Lines);  				GL.Vertex3(Vector3.Zero);  				var tiltVec = Vector3.UnitZ;  				tiltVec = Vector3.Transform(tiltVec' tilt);  				tiltVec = Vector3.Multiply(tiltVec' 1000f);  				GL.Vertex3(tiltVec);  				GL.End();*/  			}
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,The following statement contains a magic number: if (obj.Tile.Drawable != null) {  				var img = (obj.Tile.Drawable as TileDrawable).GetTileImage(obj.Tile);  				int ramp = img?.RampType ?? 0;  				if (ramp == 0 || ramp >= 17) {  					tiltPitch = tiltYaw = 0;  				}  				else if (ramp <= 4) {  					// screen-diagonal facings (perpendicular to axes)  					tiltPitch = 25;  					tiltYaw = -90 * ramp;  				}  				else {  					// world-diagonal facings (perpendicular to screen)  					tiltPitch = 25;  					tiltYaw = 225 - 90 * ((ramp - 1) % 4);  				}  				tilt *= Matrix4.CreateRotationX(MathHelper.DegreesToRadians(tiltPitch));  				tilt *= Matrix4.CreateRotationZ(MathHelper.DegreesToRadians(tiltYaw));    				/*// show tilt direction  				GL.Color3(Color.Black);  				GL.Begin(BeginMode.Lines);  				GL.Vertex3(Vector3.Zero);  				var tiltVec = Vector3.UnitZ;  				tiltVec = Vector3.Transform(tiltVec' tilt);  				tiltVec = Vector3.Multiply(tiltVec' 1000f);  				GL.Vertex3(tiltVec);  				GL.End();*/  			}
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,The following statement contains a magic number: if (obj.Tile.Drawable != null) {  				var img = (obj.Tile.Drawable as TileDrawable).GetTileImage(obj.Tile);  				int ramp = img?.RampType ?? 0;  				if (ramp == 0 || ramp >= 17) {  					tiltPitch = tiltYaw = 0;  				}  				else if (ramp <= 4) {  					// screen-diagonal facings (perpendicular to axes)  					tiltPitch = 25;  					tiltYaw = -90 * ramp;  				}  				else {  					// world-diagonal facings (perpendicular to screen)  					tiltPitch = 25;  					tiltYaw = 225 - 90 * ((ramp - 1) % 4);  				}  				tilt *= Matrix4.CreateRotationX(MathHelper.DegreesToRadians(tiltPitch));  				tilt *= Matrix4.CreateRotationZ(MathHelper.DegreesToRadians(tiltYaw));    				/*// show tilt direction  				GL.Color3(Color.Black);  				GL.Begin(BeginMode.Lines);  				GL.Vertex3(Vector3.Zero);  				var tiltVec = Vector3.UnitZ;  				tiltVec = Vector3.Transform(tiltVec' tilt);  				tiltVec = Vector3.Multiply(tiltVec' 1000f);  				GL.Vertex3(tiltVec);  				GL.End();*/  			}
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,The following statement contains a magic number: if (obj.Tile.Drawable != null) {  				var img = (obj.Tile.Drawable as TileDrawable).GetTileImage(obj.Tile);  				int ramp = img?.RampType ?? 0;  				if (ramp == 0 || ramp >= 17) {  					tiltPitch = tiltYaw = 0;  				}  				else if (ramp <= 4) {  					// screen-diagonal facings (perpendicular to axes)  					tiltPitch = 25;  					tiltYaw = -90 * ramp;  				}  				else {  					// world-diagonal facings (perpendicular to screen)  					tiltPitch = 25;  					tiltYaw = 225 - 90 * ((ramp - 1) % 4);  				}  				tilt *= Matrix4.CreateRotationX(MathHelper.DegreesToRadians(tiltPitch));  				tilt *= Matrix4.CreateRotationZ(MathHelper.DegreesToRadians(tiltYaw));    				/*// show tilt direction  				GL.Color3(Color.Black);  				GL.Begin(BeginMode.Lines);  				GL.Vertex3(Vector3.Zero);  				var tiltVec = Vector3.UnitZ;  				tiltVec = Vector3.Transform(tiltVec' tilt);  				tiltVec = Vector3.Multiply(tiltVec' 1000f);  				GL.Vertex3(tiltVec);  				GL.End();*/  			}
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,The following statement contains a magic number: float objectRotation = 90 - direction / 256f * 360f - tiltYaw;
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,The following statement contains a magic number: float pitch = MathHelper.DegreesToRadians(210);
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,The following statement contains a magic number: float yaw = MathHelper.DegreesToRadians(120);
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,The following statement contains a magic number: foreach (var section in vxl.Sections) {  				GL.PushMatrix();    				var frameRot = hva.LoadGLMatrix(section.Index);  				frameRot.M41 *= section.HVAMultiplier * section.ScaleX;  				frameRot.M42 *= section.HVAMultiplier * section.ScaleY;  				frameRot.M43 *= section.HVAMultiplier * section.ScaleZ;    				var frameTransl = Matrix4.CreateTranslation(section.MinBounds);  				var frame = frameTransl * frameRot;  				GL.MultMatrix(ref frame);    				var shadowScale = Matrix4.Scale(0.5f);  				//var shadowTilt = null;  				var shadowToScreen = frameTransl * shadowScale * frameRot * (@object * world) * trans * lookat;    				// undo world transformations on light direction  				var v = @object*world*frame*shadowTransform;  				  				var lightDirection = (v.Determinant != 0.0) ? ExtractRotationVector(ToOpenGL(Matrix4.Invert(v))) : Vector3.Zero;    				// draw line in direction light comes from  				/*GL.Color3(Color.Red);  				GL.LineWidth(4f);  				GL.Begin(BeginMode.Lines);  				GL.Vertex3(0' 0' 0);  				GL.Vertex3(Vector3.Multiply(lightDirection' 100f));  				GL.End();*/    				GL.Begin(BeginMode.Quads);  				for (uint x = 0; x != section.SizeX; x++) {  					for (uint y = 0; y != section.SizeY; y++) {  						foreach (VxlFile.Voxel vx in section.Spans[x' y].Voxels) {  							Color color = obj.Palette.Colors[vx.ColorIndex];  							Vector3 normal = section.GetNormal(vx.NormalIndex);  							// shader function taken from https://github.com/OpenRA/OpenRA/blob/bleed/cg/vxl.fx  							// thanks to pchote for a LOT of help getting it right  							Vector3 colorMult = Vector3.Add(Ambient' Diffuse * Math.Max(Vector3.Dot(normal' lightDirection)' 0f));  							GL.Color3(  								(byte)Math.Min(255' color.R * colorMult.X)'  								(byte)Math.Min(255' color.G * colorMult.Y)'  								(byte)Math.Min(255' color.B * colorMult.Z));    							Vector3 vxlPos = Vector3.Multiply(new Vector3(x' y' vx.Z)' section.Scale);  							RenderVoxel(vxlPos);    							var shadpos = new Vector3(x' y' 0);  							var screenPos = Vector3.Transform(shadpos' shadowToScreen);  							screenPos = Vector3.Transform(screenPos' persp);  							screenPos.X /= screenPos.Z;  							screenPos.Y /= screenPos.Z;  							screenPos.X = (screenPos.X + 1) * _surface.Width / 2;  							screenPos.Y = (screenPos.Y + 1) * _surface.Height / 2;  							  							if (0 <= screenPos.X && screenPos.X < _surface.Width && 0 <= screenPos.Y && screenPos.Y < _surface.Height)  								shadBuf[(int)screenPos.X + (_surface.Height - 1 - (int)screenPos.Y) * _surface.Width] = true;    							/* draw line in normal direction  							if (r.Next(100) == 4) {  								float m = Math.Max(Vector3.Dot(normal' lightDirection)' 0f);  								GL.Color3(m' m' m);  								GL.LineWidth(1);  								GL.Begin(BeginMode.Lines);  								GL.Vertex3(new Vector3(x' y' vx.Z));  								GL.Vertex3(new Vector3(x' y' vx.Z) + Vector3.Multiply(normal' 100f));  								GL.End();  							}*/    						}  					}  				}  				GL.End();  				GL.PopMatrix();  			}
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,The following statement contains a magic number: foreach (var section in vxl.Sections) {  				GL.PushMatrix();    				var frameRot = hva.LoadGLMatrix(section.Index);  				frameRot.M41 *= section.HVAMultiplier * section.ScaleX;  				frameRot.M42 *= section.HVAMultiplier * section.ScaleY;  				frameRot.M43 *= section.HVAMultiplier * section.ScaleZ;    				var frameTransl = Matrix4.CreateTranslation(section.MinBounds);  				var frame = frameTransl * frameRot;  				GL.MultMatrix(ref frame);    				var shadowScale = Matrix4.Scale(0.5f);  				//var shadowTilt = null;  				var shadowToScreen = frameTransl * shadowScale * frameRot * (@object * world) * trans * lookat;    				// undo world transformations on light direction  				var v = @object*world*frame*shadowTransform;  				  				var lightDirection = (v.Determinant != 0.0) ? ExtractRotationVector(ToOpenGL(Matrix4.Invert(v))) : Vector3.Zero;    				// draw line in direction light comes from  				/*GL.Color3(Color.Red);  				GL.LineWidth(4f);  				GL.Begin(BeginMode.Lines);  				GL.Vertex3(0' 0' 0);  				GL.Vertex3(Vector3.Multiply(lightDirection' 100f));  				GL.End();*/    				GL.Begin(BeginMode.Quads);  				for (uint x = 0; x != section.SizeX; x++) {  					for (uint y = 0; y != section.SizeY; y++) {  						foreach (VxlFile.Voxel vx in section.Spans[x' y].Voxels) {  							Color color = obj.Palette.Colors[vx.ColorIndex];  							Vector3 normal = section.GetNormal(vx.NormalIndex);  							// shader function taken from https://github.com/OpenRA/OpenRA/blob/bleed/cg/vxl.fx  							// thanks to pchote for a LOT of help getting it right  							Vector3 colorMult = Vector3.Add(Ambient' Diffuse * Math.Max(Vector3.Dot(normal' lightDirection)' 0f));  							GL.Color3(  								(byte)Math.Min(255' color.R * colorMult.X)'  								(byte)Math.Min(255' color.G * colorMult.Y)'  								(byte)Math.Min(255' color.B * colorMult.Z));    							Vector3 vxlPos = Vector3.Multiply(new Vector3(x' y' vx.Z)' section.Scale);  							RenderVoxel(vxlPos);    							var shadpos = new Vector3(x' y' 0);  							var screenPos = Vector3.Transform(shadpos' shadowToScreen);  							screenPos = Vector3.Transform(screenPos' persp);  							screenPos.X /= screenPos.Z;  							screenPos.Y /= screenPos.Z;  							screenPos.X = (screenPos.X + 1) * _surface.Width / 2;  							screenPos.Y = (screenPos.Y + 1) * _surface.Height / 2;  							  							if (0 <= screenPos.X && screenPos.X < _surface.Width && 0 <= screenPos.Y && screenPos.Y < _surface.Height)  								shadBuf[(int)screenPos.X + (_surface.Height - 1 - (int)screenPos.Y) * _surface.Width] = true;    							/* draw line in normal direction  							if (r.Next(100) == 4) {  								float m = Math.Max(Vector3.Dot(normal' lightDirection)' 0f);  								GL.Color3(m' m' m);  								GL.LineWidth(1);  								GL.Begin(BeginMode.Lines);  								GL.Vertex3(new Vector3(x' y' vx.Z));  								GL.Vertex3(new Vector3(x' y' vx.Z) + Vector3.Multiply(normal' 100f));  								GL.End();  							}*/    						}  					}  				}  				GL.End();  				GL.PopMatrix();  			}
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,The following statement contains a magic number: foreach (var section in vxl.Sections) {  				GL.PushMatrix();    				var frameRot = hva.LoadGLMatrix(section.Index);  				frameRot.M41 *= section.HVAMultiplier * section.ScaleX;  				frameRot.M42 *= section.HVAMultiplier * section.ScaleY;  				frameRot.M43 *= section.HVAMultiplier * section.ScaleZ;    				var frameTransl = Matrix4.CreateTranslation(section.MinBounds);  				var frame = frameTransl * frameRot;  				GL.MultMatrix(ref frame);    				var shadowScale = Matrix4.Scale(0.5f);  				//var shadowTilt = null;  				var shadowToScreen = frameTransl * shadowScale * frameRot * (@object * world) * trans * lookat;    				// undo world transformations on light direction  				var v = @object*world*frame*shadowTransform;  				  				var lightDirection = (v.Determinant != 0.0) ? ExtractRotationVector(ToOpenGL(Matrix4.Invert(v))) : Vector3.Zero;    				// draw line in direction light comes from  				/*GL.Color3(Color.Red);  				GL.LineWidth(4f);  				GL.Begin(BeginMode.Lines);  				GL.Vertex3(0' 0' 0);  				GL.Vertex3(Vector3.Multiply(lightDirection' 100f));  				GL.End();*/    				GL.Begin(BeginMode.Quads);  				for (uint x = 0; x != section.SizeX; x++) {  					for (uint y = 0; y != section.SizeY; y++) {  						foreach (VxlFile.Voxel vx in section.Spans[x' y].Voxels) {  							Color color = obj.Palette.Colors[vx.ColorIndex];  							Vector3 normal = section.GetNormal(vx.NormalIndex);  							// shader function taken from https://github.com/OpenRA/OpenRA/blob/bleed/cg/vxl.fx  							// thanks to pchote for a LOT of help getting it right  							Vector3 colorMult = Vector3.Add(Ambient' Diffuse * Math.Max(Vector3.Dot(normal' lightDirection)' 0f));  							GL.Color3(  								(byte)Math.Min(255' color.R * colorMult.X)'  								(byte)Math.Min(255' color.G * colorMult.Y)'  								(byte)Math.Min(255' color.B * colorMult.Z));    							Vector3 vxlPos = Vector3.Multiply(new Vector3(x' y' vx.Z)' section.Scale);  							RenderVoxel(vxlPos);    							var shadpos = new Vector3(x' y' 0);  							var screenPos = Vector3.Transform(shadpos' shadowToScreen);  							screenPos = Vector3.Transform(screenPos' persp);  							screenPos.X /= screenPos.Z;  							screenPos.Y /= screenPos.Z;  							screenPos.X = (screenPos.X + 1) * _surface.Width / 2;  							screenPos.Y = (screenPos.Y + 1) * _surface.Height / 2;  							  							if (0 <= screenPos.X && screenPos.X < _surface.Width && 0 <= screenPos.Y && screenPos.Y < _surface.Height)  								shadBuf[(int)screenPos.X + (_surface.Height - 1 - (int)screenPos.Y) * _surface.Width] = true;    							/* draw line in normal direction  							if (r.Next(100) == 4) {  								float m = Math.Max(Vector3.Dot(normal' lightDirection)' 0f);  								GL.Color3(m' m' m);  								GL.LineWidth(1);  								GL.Begin(BeginMode.Lines);  								GL.Vertex3(new Vector3(x' y' vx.Z));  								GL.Vertex3(new Vector3(x' y' vx.Z) + Vector3.Multiply(normal' 100f));  								GL.End();  							}*/    						}  					}  				}  				GL.End();  				GL.PopMatrix();  			}
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,The following statement contains a magic number: foreach (var section in vxl.Sections) {  				GL.PushMatrix();    				var frameRot = hva.LoadGLMatrix(section.Index);  				frameRot.M41 *= section.HVAMultiplier * section.ScaleX;  				frameRot.M42 *= section.HVAMultiplier * section.ScaleY;  				frameRot.M43 *= section.HVAMultiplier * section.ScaleZ;    				var frameTransl = Matrix4.CreateTranslation(section.MinBounds);  				var frame = frameTransl * frameRot;  				GL.MultMatrix(ref frame);    				var shadowScale = Matrix4.Scale(0.5f);  				//var shadowTilt = null;  				var shadowToScreen = frameTransl * shadowScale * frameRot * (@object * world) * trans * lookat;    				// undo world transformations on light direction  				var v = @object*world*frame*shadowTransform;  				  				var lightDirection = (v.Determinant != 0.0) ? ExtractRotationVector(ToOpenGL(Matrix4.Invert(v))) : Vector3.Zero;    				// draw line in direction light comes from  				/*GL.Color3(Color.Red);  				GL.LineWidth(4f);  				GL.Begin(BeginMode.Lines);  				GL.Vertex3(0' 0' 0);  				GL.Vertex3(Vector3.Multiply(lightDirection' 100f));  				GL.End();*/    				GL.Begin(BeginMode.Quads);  				for (uint x = 0; x != section.SizeX; x++) {  					for (uint y = 0; y != section.SizeY; y++) {  						foreach (VxlFile.Voxel vx in section.Spans[x' y].Voxels) {  							Color color = obj.Palette.Colors[vx.ColorIndex];  							Vector3 normal = section.GetNormal(vx.NormalIndex);  							// shader function taken from https://github.com/OpenRA/OpenRA/blob/bleed/cg/vxl.fx  							// thanks to pchote for a LOT of help getting it right  							Vector3 colorMult = Vector3.Add(Ambient' Diffuse * Math.Max(Vector3.Dot(normal' lightDirection)' 0f));  							GL.Color3(  								(byte)Math.Min(255' color.R * colorMult.X)'  								(byte)Math.Min(255' color.G * colorMult.Y)'  								(byte)Math.Min(255' color.B * colorMult.Z));    							Vector3 vxlPos = Vector3.Multiply(new Vector3(x' y' vx.Z)' section.Scale);  							RenderVoxel(vxlPos);    							var shadpos = new Vector3(x' y' 0);  							var screenPos = Vector3.Transform(shadpos' shadowToScreen);  							screenPos = Vector3.Transform(screenPos' persp);  							screenPos.X /= screenPos.Z;  							screenPos.Y /= screenPos.Z;  							screenPos.X = (screenPos.X + 1) * _surface.Width / 2;  							screenPos.Y = (screenPos.Y + 1) * _surface.Height / 2;  							  							if (0 <= screenPos.X && screenPos.X < _surface.Width && 0 <= screenPos.Y && screenPos.Y < _surface.Height)  								shadBuf[(int)screenPos.X + (_surface.Height - 1 - (int)screenPos.Y) * _surface.Width] = true;    							/* draw line in normal direction  							if (r.Next(100) == 4) {  								float m = Math.Max(Vector3.Dot(normal' lightDirection)' 0f);  								GL.Color3(m' m' m);  								GL.LineWidth(1);  								GL.Begin(BeginMode.Lines);  								GL.Vertex3(new Vector3(x' y' vx.Z));  								GL.Vertex3(new Vector3(x' y' vx.Z) + Vector3.Multiply(normal' 100f));  								GL.End();  							}*/    						}  					}  				}  				GL.End();  				GL.PopMatrix();  			}
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,Render,The following statement contains a magic number: foreach (var section in vxl.Sections) {  				GL.PushMatrix();    				var frameRot = hva.LoadGLMatrix(section.Index);  				frameRot.M41 *= section.HVAMultiplier * section.ScaleX;  				frameRot.M42 *= section.HVAMultiplier * section.ScaleY;  				frameRot.M43 *= section.HVAMultiplier * section.ScaleZ;    				var frameTransl = Matrix4.CreateTranslation(section.MinBounds);  				var frame = frameTransl * frameRot;  				GL.MultMatrix(ref frame);    				var shadowScale = Matrix4.Scale(0.5f);  				//var shadowTilt = null;  				var shadowToScreen = frameTransl * shadowScale * frameRot * (@object * world) * trans * lookat;    				// undo world transformations on light direction  				var v = @object*world*frame*shadowTransform;  				  				var lightDirection = (v.Determinant != 0.0) ? ExtractRotationVector(ToOpenGL(Matrix4.Invert(v))) : Vector3.Zero;    				// draw line in direction light comes from  				/*GL.Color3(Color.Red);  				GL.LineWidth(4f);  				GL.Begin(BeginMode.Lines);  				GL.Vertex3(0' 0' 0);  				GL.Vertex3(Vector3.Multiply(lightDirection' 100f));  				GL.End();*/    				GL.Begin(BeginMode.Quads);  				for (uint x = 0; x != section.SizeX; x++) {  					for (uint y = 0; y != section.SizeY; y++) {  						foreach (VxlFile.Voxel vx in section.Spans[x' y].Voxels) {  							Color color = obj.Palette.Colors[vx.ColorIndex];  							Vector3 normal = section.GetNormal(vx.NormalIndex);  							// shader function taken from https://github.com/OpenRA/OpenRA/blob/bleed/cg/vxl.fx  							// thanks to pchote for a LOT of help getting it right  							Vector3 colorMult = Vector3.Add(Ambient' Diffuse * Math.Max(Vector3.Dot(normal' lightDirection)' 0f));  							GL.Color3(  								(byte)Math.Min(255' color.R * colorMult.X)'  								(byte)Math.Min(255' color.G * colorMult.Y)'  								(byte)Math.Min(255' color.B * colorMult.Z));    							Vector3 vxlPos = Vector3.Multiply(new Vector3(x' y' vx.Z)' section.Scale);  							RenderVoxel(vxlPos);    							var shadpos = new Vector3(x' y' 0);  							var screenPos = Vector3.Transform(shadpos' shadowToScreen);  							screenPos = Vector3.Transform(screenPos' persp);  							screenPos.X /= screenPos.Z;  							screenPos.Y /= screenPos.Z;  							screenPos.X = (screenPos.X + 1) * _surface.Width / 2;  							screenPos.Y = (screenPos.Y + 1) * _surface.Height / 2;  							  							if (0 <= screenPos.X && screenPos.X < _surface.Width && 0 <= screenPos.Y && screenPos.Y < _surface.Height)  								shadBuf[(int)screenPos.X + (_surface.Height - 1 - (int)screenPos.Y) * _surface.Width] = true;    							/* draw line in normal direction  							if (r.Next(100) == 4) {  								float m = Math.Max(Vector3.Dot(normal' lightDirection)' 0f);  								GL.Color3(m' m' m);  								GL.LineWidth(1);  								GL.Begin(BeginMode.Lines);  								GL.Vertex3(new Vector3(x' y' vx.Z));  								GL.Vertex3(new Vector3(x' y' vx.Z) + Vector3.Multiply(normal' 100f));  								GL.End();  							}*/    						}  					}  				}  				GL.End();  				GL.PopMatrix();  			}
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,DrawAxes,The following statement contains a magic number: GL.LineWidth(5);
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,DrawAxes,The following statement contains a magic number: GL.Vertex3(-100' 0' 0);
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,DrawAxes,The following statement contains a magic number: GL.Vertex3(100' 0' 0);
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,DrawAxes,The following statement contains a magic number: GL.Vertex3(0' -100' 0);
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,DrawAxes,The following statement contains a magic number: GL.Vertex3(0' 100' 0);
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,DrawAxes,The following statement contains a magic number: GL.Vertex3(0' 0' -100);
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,DrawAxes,The following statement contains a magic number: GL.Vertex3(0' 0' 100);
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,GetBounds,The following statement contains a magic number: var world = Matrix4.CreateRotationX(MathHelper.DegreesToRadians(60));
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,GetBounds,The following statement contains a magic number: var camera = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(30)' 1f' 1' 100);
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,GetBounds,The following statement contains a magic number: var camera = Matrix4.CreatePerspectiveFieldOfView(MathHelper.DegreesToRadians(30)' 1f' 1' 100);
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,GetBounds,The following statement contains a magic number: foreach (var section in vxl.Sections) {  				var frameRot = hva.LoadGLMatrix(section.Index);  				frameRot.M41 *= section.HVAMultiplier * section.ScaleX;  				frameRot.M42 *= section.HVAMultiplier * section.ScaleY;  				frameRot.M43 *= section.HVAMultiplier * section.ScaleZ;    				var minbounds = new Vector3(section.MinBounds);  				if (props.HasShadow)  					minbounds.Z = -100;    				var frameTransl = Matrix4.CreateTranslation(minbounds);  				var frame = frameTransl * frameRot * world;    				// floor rect of the bounding box  				Vector3 floorTopLeft = new Vector3(0' 0' 0);  				Vector3 floorTopRight = new Vector3(section.SpanX' 0' 0);  				Vector3 floorBottomRight = new Vector3(section.SpanX' section.SpanY' 0);  				Vector3 floorBottomLeft = new Vector3(0' section.SpanY' 0);    				// ceil rect of the bounding box  				Vector3 ceilTopLeft = new Vector3(0' 0' section.SpanZ);  				Vector3 ceilTopRight = new Vector3(section.SpanX' 0' section.SpanZ);  				Vector3 ceilBottomRight = new Vector3(section.SpanX' section.SpanY' section.SpanZ);  				Vector3 ceilBottomLeft = new Vector3(0' section.SpanY' section.SpanZ);    				// apply transformations  				floorTopLeft = Vector3.Transform(floorTopLeft' frame);  				floorTopRight = Vector3.Transform(floorTopRight' frame);  				floorBottomRight = Vector3.Transform(floorBottomRight' frame);  				floorBottomLeft = Vector3.Transform(floorBottomLeft' frame);    				ceilTopLeft = Vector3.Transform(ceilTopLeft' frame);  				ceilTopRight = Vector3.Transform(ceilTopRight' frame);  				ceilBottomRight = Vector3.Transform(ceilBottomRight' frame);  				ceilBottomLeft = Vector3.Transform(ceilBottomLeft' frame);    				int FminX = (int)Math.Floor(Math.Min(Math.Min(Math.Min(floorTopLeft.X' floorTopRight.X)' floorBottomRight.X)' floorBottomLeft.X));  				int FmaxX = (int)Math.Ceiling(Math.Max(Math.Max(Math.Max(floorTopLeft.X' floorTopRight.X)' floorBottomRight.X)' floorBottomLeft.X));  				int FminY = (int)Math.Floor(Math.Min(Math.Min(Math.Min(floorTopLeft.Y' floorTopRight.Y)' floorBottomRight.Y)' floorBottomLeft.Y));  				int FmaxY = (int)Math.Ceiling(Math.Max(Math.Max(Math.Max(floorTopLeft.Y' floorTopRight.Y)' floorBottomRight.Y)' floorBottomLeft.Y));    				int TminX = (int)Math.Floor(Math.Min(Math.Min(Math.Min(ceilTopLeft.X' ceilTopRight.X)' ceilBottomRight.X)' ceilBottomLeft.X));  				int TmaxX = (int)Math.Ceiling(Math.Max(Math.Max(Math.Max(ceilTopLeft.X' ceilTopRight.X)' ceilBottomRight.X)' ceilBottomLeft.X));  				int TminY = (int)Math.Floor(Math.Min(Math.Min(Math.Min(ceilTopLeft.Y' ceilTopRight.Y)' ceilBottomRight.Y)' ceilBottomLeft.Y));  				int TmaxY = (int)Math.Ceiling(Math.Max(Math.Max(Math.Max(ceilTopLeft.Y' ceilTopRight.Y)' ceilBottomRight.Y)' ceilBottomLeft.Y));    				int minX = Math.Min(FminX' TminX);  				int maxX = Math.Max(FmaxX' TmaxX);  				int minY = Math.Min(FminY' TminY);  				int maxY = Math.Max(FmaxY' TmaxY);    				ret = Rectangle.Union(ret' Rectangle.FromLTRB(minX' minY' maxX' maxY));  			}
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ExtractRotationVector,The following statement contains a magic number: tVec[0] -= tOrigin[0] * tVec[3] / tOrigin[3];
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ExtractRotationVector,The following statement contains a magic number: tVec[0] -= tOrigin[0] * tVec[3] / tOrigin[3];
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ExtractRotationVector,The following statement contains a magic number: tVec[1] -= tOrigin[1] * tVec[3] / tOrigin[3];
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ExtractRotationVector,The following statement contains a magic number: tVec[1] -= tOrigin[1] * tVec[3] / tOrigin[3];
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ExtractRotationVector,The following statement contains a magic number: tVec[2] -= tOrigin[2] * tVec[3] / tOrigin[3];
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ExtractRotationVector,The following statement contains a magic number: tVec[2] -= tOrigin[2] * tVec[3] / tOrigin[3];
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ExtractRotationVector,The following statement contains a magic number: tVec[2] -= tOrigin[2] * tVec[3] / tOrigin[3];
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ExtractRotationVector,The following statement contains a magic number: tVec[2] -= tOrigin[2] * tVec[3] / tOrigin[3];
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ExtractRotationVector,The following statement contains a magic number: var w = (float)Math.Sqrt(tVec[0] * tVec[0] + tVec[1] * tVec[1] + tVec[2] * tVec[2]);
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ExtractRotationVector,The following statement contains a magic number: var w = (float)Math.Sqrt(tVec[0] * tVec[0] + tVec[1] * tVec[1] + tVec[2] * tVec[2]);
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ExtractRotationVector,The following statement contains a magic number: tVec[2] /= w;
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ExtractRotationVector,The following statement contains a magic number: tVec[3] = 1f;
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ExtractRotationVector,The following statement contains a magic number: return new Vector3(tVec[0]' tVec[1]' tVec[2]);
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ToOpenGL,The following statement contains a magic number: var destination = new float[16];
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ToOpenGL,The following statement contains a magic number: destination[02] = source.Column2.X;
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ToOpenGL,The following statement contains a magic number: destination[03] = source.Column3.X;
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ToOpenGL,The following statement contains a magic number: destination[04] = source.Column0.Y;
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ToOpenGL,The following statement contains a magic number: destination[05] = source.Column1.Y;
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ToOpenGL,The following statement contains a magic number: destination[06] = source.Column2.Y;
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ToOpenGL,The following statement contains a magic number: destination[07] = source.Column3.Y;
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ToOpenGL,The following statement contains a magic number: destination[08] = source.Column0.Z;
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ToOpenGL,The following statement contains a magic number: destination[09] = source.Column1.Z;
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ToOpenGL,The following statement contains a magic number: destination[10] = source.Column2.Z;
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ToOpenGL,The following statement contains a magic number: destination[11] = source.Column3.Z;
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ToOpenGL,The following statement contains a magic number: destination[12] = source.Column0.W;
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ToOpenGL,The following statement contains a magic number: destination[13] = source.Column1.W;
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ToOpenGL,The following statement contains a magic number: destination[14] = source.Column2.W;
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,ToOpenGL,The following statement contains a magic number: destination[15] = source.Column3.W;
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,MatrixVectorMultiply,The following statement contains a magic number: var ret = new float[4];
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,MatrixVectorMultiply,The following statement contains a magic number: for (var j = 0; j < 4; j++) {  				ret[j] = 0;  				for (var k = 0; k < 4; k++)  					ret[j] += mtx[4 * k + j] * vec[k];  			}
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,MatrixVectorMultiply,The following statement contains a magic number: for (var j = 0; j < 4; j++) {  				ret[j] = 0;  				for (var k = 0; k < 4; k++)  					ret[j] += mtx[4 * k + j] * vec[k];  			}
Magic Number,CNCMaps.Engine.Rendering,VxlRenderer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Rendering\VxlRenderer.cs,MatrixVectorMultiply,The following statement contains a magic number: for (var j = 0; j < 4; j++) {  				ret[j] = 0;  				for (var k = 0; k < 4; k++)  					ret[j] += mtx[4 * k + j] * vec[k];  			}
Magic Number,CNCMaps.Engine.Types,AircraftType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\AircraftType.cs,LoadArt,The following statement contains a magic number: SpawnDelay = art.ReadInt("SpawnDelay"' 3);
Magic Number,CNCMaps.Engine.Types,TechnoType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\TechnoType.cs,LoadRules,The following statement contains a magic number: CloakingSpeed = rules.ReadInt("CloakingSpeed"' 7);
Magic Number,CNCMaps.Engine.Types,TechnoType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\TechnoType.cs,LoadRules,The following statement contains a magic number: SlowdownDistance = rules.ReadInt("SlowdownDistance"' 500);
Magic Number,CNCMaps.Engine.Types,TechnoType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\TechnoType.cs,LoadRules,The following statement contains a magic number: PhysicalSize = rules.ReadFloat("PhysicalSize"' 2);
Magic Number,CNCMaps.Engine.Types,TechnoType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\TechnoType.cs,LoadRules,The following statement contains a magic number: BuildLimit = rules.ReadInt("BuildLimit"' 2147483647);
Magic Number,CNCMaps.Engine.Types,TechnoType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\TechnoType.cs,LoadRules,The following statement contains a magic number: LeptonMindControlOffset = rules.ReadInt("LeptonMindControlOffset"' 70);
Magic Number,CNCMaps.Engine.Types,TechnoType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\TechnoType.cs,LoadRules,The following statement contains a magic number: LeadershipRating = rules.ReadInt("LeadershipRating"' 5);
Magic Number,CNCMaps.Engine.Types,TechnoType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\TechnoType.cs,LoadRules,The following statement contains a magic number: MindControlRingOffset = rules.ReadInt("MindControlRingOffset"' 140);
Magic Number,CNCMaps.Engine.Types,TechnoType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\TechnoType.cs,LoadRules,The following statement contains a magic number: TechLevel = rules.ReadInt("TechLevel"' 255);
Magic Number,CNCMaps.Engine.Types,TechnoType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\TechnoType.cs,LoadRules,The following statement contains a magic number: FireAngle = rules.ReadInt("FireAngle"' 8);
Magic Number,CNCMaps.Engine.Types,TechnoType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\TechnoType.cs,LoadRules,The following statement contains a magic number: JumpjetTurnRate = rules.ReadInt("JumpjetTurnRate"' 4);
Magic Number,CNCMaps.Engine.Types,TechnoType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\TechnoType.cs,LoadRules,The following statement contains a magic number: JumpjetSpeed = rules.ReadFloat("JumpjetSpeed"' 14);
Magic Number,CNCMaps.Engine.Types,TechnoType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\TechnoType.cs,LoadRules,The following statement contains a magic number: JumpjetClimb = rules.ReadFloat("JumpjetClimb"' 5);
Magic Number,CNCMaps.Engine.Types,TechnoType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\TechnoType.cs,LoadRules,The following statement contains a magic number: JumpjetCrash = rules.ReadFloat("JumpjetCrash"' 5);
Magic Number,CNCMaps.Engine.Types,TechnoType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\TechnoType.cs,LoadRules,The following statement contains a magic number: JumpjetHeight = rules.ReadInt("JumpjetHeight"' 500);
Magic Number,CNCMaps.Engine.Types,TechnoType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\TechnoType.cs,LoadRules,The following statement contains a magic number: JumpjetAccel = rules.ReadFloat("JumpjetAccel"' 2);
Magic Number,CNCMaps.Engine.Types,TechnoType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\TechnoType.cs,LoadRules,The following statement contains a magic number: JumpjetDeviation = rules.ReadInt("JumpjetDeviation"' 40);
Magic Number,CNCMaps.Engine.Types,TechnoType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\TechnoType.cs,LoadRules,The following statement contains a magic number: TurretTravel = rules.ReadInt("TurretTravel"' 2);
Magic Number,CNCMaps.Engine.Types,TechnoType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\TechnoType.cs,LoadRules,The following statement contains a magic number: BarrelTravel = rules.ReadInt("BarrelTravel"' 2);
Magic Number,CNCMaps.Engine.Types,TechnoType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\TechnoType.cs,LoadRules,The following statement contains a magic number: ZFudgeCliff = rules.ReadInt("ZFudgeCliff"' 10);
Magic Number,CNCMaps.Engine.Types,TechnoType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\TechnoType.cs,LoadRules,The following statement contains a magic number: ZFudgeColumn = rules.ReadInt("ZFudgeColumn"' 5);
Magic Number,CNCMaps.Engine.Types,TechnoType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\TechnoType.cs,LoadRules,The following statement contains a magic number: ZFudgeTunnel = rules.ReadInt("ZFudgeTunnel"' 10);
Magic Number,CNCMaps.Engine.Types,TerrainType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\TerrainType.cs,LoadRules,The following statement contains a magic number: TemperateOccupationBits = rules.ReadInt("TemperateOccupationBits"' 7);
Magic Number,CNCMaps.Engine.Types,TerrainType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\TerrainType.cs,LoadRules,The following statement contains a magic number: SnowOccupationBits = rules.ReadInt("SnowOccupationBits"' 7);
Magic Number,CNCMaps.Engine.Types,VehicleType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\VehicleType.cs,LoadArt,The following statement contains a magic number: WalkFrames = art.ReadInt("WalkFrames"' 12);
Magic Number,CNCMaps.Engine.Types,VehicleType,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\VehicleType.cs,LoadArt,The following statement contains a magic number: Facings = art.ReadInt("Facings"' 8);
Magic Number,CNCMaps.Engine.Types,VoxelAnimation,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Types\VoxelAnimation.cs,LoadRules,The following statement contains a magic number: Duration = rules.ReadInt("Duration"' 30);
Magic Number,CNCMaps.Engine.Utility,HsvColor,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Utility\HsvColor.cs,ToRGB,The following statement contains a magic number: h = (Hue / 255.0 * 360.0) % 360.0;
Magic Number,CNCMaps.Engine.Utility,HsvColor,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Utility\HsvColor.cs,ToRGB,The following statement contains a magic number: h = (Hue / 255.0 * 360.0) % 360.0;
Magic Number,CNCMaps.Engine.Utility,HsvColor,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Utility\HsvColor.cs,ToRGB,The following statement contains a magic number: h = (Hue / 255.0 * 360.0) % 360.0;
Magic Number,CNCMaps.Engine.Utility,HsvColor,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Utility\HsvColor.cs,ToRGB,The following statement contains a magic number: s = Saturation / 255.0;
Magic Number,CNCMaps.Engine.Utility,HsvColor,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Utility\HsvColor.cs,ToRGB,The following statement contains a magic number: v = Value / 255.0;
Magic Number,CNCMaps.Engine.Utility,HsvColor,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Utility\HsvColor.cs,ToRGB,The following statement contains a magic number: if (s == 0) {  				r = v;  				g = v;  				b = v;  			}  			else {  				double p;  				double q;  				double t;    				double fractionalSector;  				int sectorNumber;  				double sectorPos;    				sectorPos = h / 60.0;  				sectorNumber = (int)(Math.Floor(sectorPos));    				fractionalSector = sectorPos - sectorNumber;    				p = v * (1D - s);  				q = v * (1D - (s * fractionalSector));  				t = v * (1D - (s * (1D - fractionalSector)));    				switch (sectorNumber) {  					case 0: r = v; g = t; b = p; break;  					case 1: r = q; g = v; b = p; break;  					case 2: r = p; g = v; b = t; break;  					case 3: r = p; g = q; b = v; break;  					case 4: r = t; g = p; b = v; break;  					case 5: r = v; g = p; b = q; break;  				}  			}
Magic Number,CNCMaps.Engine.Utility,HsvColor,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Utility\HsvColor.cs,ToRGB,The following statement contains a magic number: if (s == 0) {  				r = v;  				g = v;  				b = v;  			}  			else {  				double p;  				double q;  				double t;    				double fractionalSector;  				int sectorNumber;  				double sectorPos;    				sectorPos = h / 60.0;  				sectorNumber = (int)(Math.Floor(sectorPos));    				fractionalSector = sectorPos - sectorNumber;    				p = v * (1D - s);  				q = v * (1D - (s * fractionalSector));  				t = v * (1D - (s * (1D - fractionalSector)));    				switch (sectorNumber) {  					case 0: r = v; g = t; b = p; break;  					case 1: r = q; g = v; b = p; break;  					case 2: r = p; g = v; b = t; break;  					case 3: r = p; g = q; b = v; break;  					case 4: r = t; g = p; b = v; break;  					case 5: r = v; g = p; b = q; break;  				}  			}
Magic Number,CNCMaps.Engine.Utility,HsvColor,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Utility\HsvColor.cs,ToRGB,The following statement contains a magic number: if (s == 0) {  				r = v;  				g = v;  				b = v;  			}  			else {  				double p;  				double q;  				double t;    				double fractionalSector;  				int sectorNumber;  				double sectorPos;    				sectorPos = h / 60.0;  				sectorNumber = (int)(Math.Floor(sectorPos));    				fractionalSector = sectorPos - sectorNumber;    				p = v * (1D - s);  				q = v * (1D - (s * fractionalSector));  				t = v * (1D - (s * (1D - fractionalSector)));    				switch (sectorNumber) {  					case 0: r = v; g = t; b = p; break;  					case 1: r = q; g = v; b = p; break;  					case 2: r = p; g = v; b = t; break;  					case 3: r = p; g = q; b = v; break;  					case 4: r = t; g = p; b = v; break;  					case 5: r = v; g = p; b = q; break;  				}  			}
Magic Number,CNCMaps.Engine.Utility,HsvColor,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Utility\HsvColor.cs,ToRGB,The following statement contains a magic number: if (s == 0) {  				r = v;  				g = v;  				b = v;  			}  			else {  				double p;  				double q;  				double t;    				double fractionalSector;  				int sectorNumber;  				double sectorPos;    				sectorPos = h / 60.0;  				sectorNumber = (int)(Math.Floor(sectorPos));    				fractionalSector = sectorPos - sectorNumber;    				p = v * (1D - s);  				q = v * (1D - (s * fractionalSector));  				t = v * (1D - (s * (1D - fractionalSector)));    				switch (sectorNumber) {  					case 0: r = v; g = t; b = p; break;  					case 1: r = q; g = v; b = p; break;  					case 2: r = p; g = v; b = t; break;  					case 3: r = p; g = q; b = v; break;  					case 4: r = t; g = p; b = v; break;  					case 5: r = v; g = p; b = q; break;  				}  			}
Magic Number,CNCMaps.Engine.Utility,HsvColor,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Utility\HsvColor.cs,ToRGB,The following statement contains a magic number: if (s == 0) {  				r = v;  				g = v;  				b = v;  			}  			else {  				double p;  				double q;  				double t;    				double fractionalSector;  				int sectorNumber;  				double sectorPos;    				sectorPos = h / 60.0;  				sectorNumber = (int)(Math.Floor(sectorPos));    				fractionalSector = sectorPos - sectorNumber;    				p = v * (1D - s);  				q = v * (1D - (s * fractionalSector));  				t = v * (1D - (s * (1D - fractionalSector)));    				switch (sectorNumber) {  					case 0: r = v; g = t; b = p; break;  					case 1: r = q; g = v; b = p; break;  					case 2: r = p; g = v; b = t; break;  					case 3: r = p; g = q; b = v; break;  					case 4: r = t; g = p; b = v; break;  					case 5: r = v; g = p; b = q; break;  				}  			}
Magic Number,CNCMaps.Engine.Utility,HsvColor,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Utility\HsvColor.cs,ToRGB,The following statement contains a magic number: return Color.FromArgb((int)(r * 255.0)' (int)(g * 255.0)' (int)(b * 255.0));
Magic Number,CNCMaps.Engine.Utility,HsvColor,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Utility\HsvColor.cs,ToRGB,The following statement contains a magic number: return Color.FromArgb((int)(r * 255.0)' (int)(g * 255.0)' (int)(b * 255.0));
Magic Number,CNCMaps.Engine.Utility,HsvColor,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Utility\HsvColor.cs,ToRGB,The following statement contains a magic number: return Color.FromArgb((int)(r * 255.0)' (int)(g * 255.0)' (int)(b * 255.0));
Missing Default,CNCMaps.Engine.Game,ObjectCollection,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Game\ObjectCollection.cs,InitDrawableDefaults,The following switch statement is missing a default case: switch (Type) {  				case CollectionType.Building:  				case CollectionType.Overlay:  				case CollectionType.Smudge:  					drawable.Props.Offset.Offset(Drawable.TileWidth / 2' 0);  					break;  				case CollectionType.Terrain:  				case CollectionType.Vehicle:  				case CollectionType.Infantry:  				case CollectionType.Aircraft:  				case CollectionType.Animation:  					drawable.Props.Offset.Offset(Drawable.TileWidth / 2' Drawable.TileHeight / 2);  					break;  			}
Missing Default,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GetSizePixels,The following switch statement is missing a default case: switch (sizeMode) {  			case SizeMode.Local:  				return GetLocalSizePixels();  			case SizeMode.Full:  				return GetFullMapSizePixels();  			case SizeMode.Auto:  				return GetAutoSizePixels();  			}
Missing Default,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GeneratePreviewPack,The following switch statement is missing a default case: switch (previewMarkers) {  			case PreviewMarkersType.None:  				break;  			case PreviewMarkersType.Squared:  				DrawSquaredStartPositions();  				break;  			case PreviewMarkersType.Bittah:  			case PreviewMarkersType.Aro:  				// to be injected later  				break;  			}
Missing Default,CNCMaps.Engine.Map,Map,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Map.cs,GeneratePreviewPack,The following switch statement is missing a default case: switch (previewMarkers) {  					case PreviewMarkersType.None:  					case PreviewMarkersType.Squared:  						break;  					case PreviewMarkersType.Bittah:  						DrawStartMarkersBittah(gfx' srcRect' dstRect);  						break;  					case PreviewMarkersType.Aro:  						DrawStartMarkersAro(gfx' srcRect' dstRect);  						break;  					}
Missing Default,CNCMaps.Engine.Map,ObjectSorter,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\ObjectSorter.cs,GetFrontBlock,The following switch statement is missing a default case: switch (sepAxis) {  				case Axis.X:  					if (hexA.xMin > hexB.xMax) return objA;  					else if (hexB.xMin > hexA.xMax) return objB;  					break;  				case Axis.Y:  					if (hexA.yMin > hexB.yMax) return objA;  					else if (hexB.yMin > hexA.yMax) return objB;  					break;  				case Axis.Z:  					if (hexA.zMin > hexB.zMax) return objA;  					else if (hexB.zMin > hexA.zMax) return objB;  					break;  			}
Missing Default,CNCMaps.Engine.Map,Operations,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\Operations.cs,FixTiles,The following switch statement is missing a default case: switch (ti.RampType) {  						case 1:  							// northwest facing  							if (tileTopLeft != null && tileTopLeft.GetTileImage().RampType == 0)  								fixup++;  							if (tileBottomRight != null && tileBottomRight.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 2: // northeast facing  							if (tileTopRight != null && tileTopRight.GetTileImage().RampType == 0)  								fixup++;  							if (tileBottomLeft != null && tileBottomLeft.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 3: // southeast facing  							if (tileBottomRight != null && tileBottomRight.GetTileImage().RampType == 0)  								fixup++;  							if (tileTopLeft != null && tileTopLeft.GetTileImage().RampType == 0)  								fixup += 2;  							break;    						case 4: // southwest facing  							if (tileBottomLeft != null && tileBottomLeft.GetTileImage().RampType == 0)  								fixup++;  							if (tileTopRight != null && tileTopRight.GetTileImage().RampType == 0)  								fixup += 2;  							break;  					}
Missing Default,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetNeighbourTile,The following switch statement is missing a default case: switch (direction) {  				// in non-diagonal direction we don't need to check odd/evenness of x  				case TileDirection.Bottom:  					if (y >= tiles.GetLength(1)) return null;  					return this[x' y + 1];    				case TileDirection.Top:  					if (y < 2) return null;  					return this[x' y - 1];    				case TileDirection.Left:  					if (x < 2) return null;  					return this[x - 2' y];    				case TileDirection.Right:  					if (x >= tiles.GetLength(0) - 1) return null;  					return this[x + 2' y];  			}
Missing Default,CNCMaps.Engine.Map,TileLayer,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Map\TileLayer.cs,GetNeighbourTile,The following switch statement is missing a default case: switch (direction) {  				case TileDirection.BottomLeft:  					if (x < 1 || y >= tiles.GetLength(1)) return null;  					return this[x - 1' y];    				case TileDirection.BottomRight:  					if (x >= tiles.GetLength(0) || y >= tiles.GetLength(1)) return null;  					return this[x + 1' y];    				case TileDirection.TopLeft:  					if (x < 1 || y < 1) return null;  					return this[x - 1' y - 1];    				case TileDirection.TopRight:  					if (y < 1 || x >= tiles.GetLength(0) - 1) return null;  					return this[x + 1' y - 1];  			}
Missing Default,CNCMaps.Engine.Utility,HsvColor,C:\repos\zzattack_ccmaps-net\CNCMaps.Engine\Utility\HsvColor.cs,ToRGB,The following switch statement is missing a default case: switch (sectorNumber) {  					case 0: r = v; g = t; b = p; break;  					case 1: r = q; g = v; b = p; break;  					case 2: r = p; g = v; b = t; break;  					case 3: r = p; g = q; b = v; break;  					case 4: r = t; g = p; b = v; break;  					case 5: r = v; g = p; b = q; break;  				}
