Implementation smell,Namespace,Class,File,Method,Description
Long Method,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Open,The method has 195 lines of code.
Long Method,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The method has 79 lines of code.
Long Method,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,AddFrame,The method has 88 lines of code.
Long Method,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The method has 97 lines of code.
Long Method,cadencii.media,RateConvertContext,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RateConvertContext.cs,convert,The method has 156 lines of code.
Long Method,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The method has 86 lines of code.
Long Method,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,AddFrame,The method has 196 lines of code.
Long Method,cadencii.media,PipedAviWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PipedAviWriter.cs,AddFrame,The method has 103 lines of code.
Long Method,cadencii.media,MainAVIHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,The method has 88 lines of code.
Long Method,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,RequireAudioCompressOption,The method has 145 lines of code.
Long Method,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,GetF0,The method has 186 lines of code.
Long Method,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The method has 64 lines of code.
Long Method,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The method has 60 lines of code.
Long Method,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The method has 98 lines of code.
Long Method,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,trimSilence,The method has 105 lines of code.
Long Method,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The method has 84 lines of code.
Long Method,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The method has 118 lines of code.
Long Method,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The method has 70 lines of code.
Long Method,cadencii.media,WavePlay,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WavePlay.cs,append_cor,The method has 204 lines of code.
Long Method,cadencii.media,WavePlay,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WavePlay.cs,on_your_mark,The method has 76 lines of code.
Long Method,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The method has 90 lines of code.
Long Method,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The method has 124 lines of code.
Long Method,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The method has 102 lines of code.
Long Method,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The method has 102 lines of code.
Long Method,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,writeHeader,The method has 79 lines of code.
Complex Method,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Open,Cyclomatic complexity of the method is 13
Complex Method,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,AddFrame,Cyclomatic complexity of the method is 11
Complex Method,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,Cyclomatic complexity of the method is 32
Complex Method,cadencii.media,RateConvertContext,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RateConvertContext.cs,convert,Cyclomatic complexity of the method is 28
Complex Method,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,AddFrame,Cyclomatic complexity of the method is 12
Complex Method,cadencii.media,AVIStreamHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,Cyclomatic complexity of the method is 11
Complex Method,cadencii.media,MainAVIHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,Cyclomatic complexity of the method is 15
Complex Method,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,GetF0,Cyclomatic complexity of the method is 15
Complex Method,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,GetVolume,Cyclomatic complexity of the method is 7
Complex Method,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,Cyclomatic complexity of the method is 12
Complex Method,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,setTotalSamples,Cyclomatic complexity of the method is 8
Complex Method,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,Cyclomatic complexity of the method is 16
Complex Method,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,Cyclomatic complexity of the method is 17
Complex Method,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,printToText,Cyclomatic complexity of the method is 9
Complex Method,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,Cyclomatic complexity of the method is 7
Complex Method,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,trimSilence,Cyclomatic complexity of the method is 21
Complex Method,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,Cyclomatic complexity of the method is 9
Complex Method,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,Cyclomatic complexity of the method is 13
Complex Method,cadencii.media,WavePlay,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WavePlay.cs,append_cor,Cyclomatic complexity of the method is 28
Complex Method,cadencii.media,WavePlay,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WavePlay.cs,on_your_mark,Cyclomatic complexity of the method is 12
Complex Method,cadencii.media,WavePlay,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WavePlay.cs,change_block_size,Cyclomatic complexity of the method is 7
Complex Method,cadencii.media,WaveRateConverter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveRateConverter.cs,read,Cyclomatic complexity of the method is 8
Complex Method,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,Cyclomatic complexity of the method is 26
Complex Method,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,Cyclomatic complexity of the method is 21
Complex Method,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,Cyclomatic complexity of the method is 21
Complex Method,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,Cyclomatic complexity of the method is 10
Complex Method,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,Cyclomatic complexity of the method is 8
Complex Method,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,Cyclomatic complexity of the method is 8
Complex Method,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,Cyclomatic complexity of the method is 8
Complex Method,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,Cyclomatic complexity of the method is 9
Complex Method,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,Cyclomatic complexity of the method is 8
Complex Method,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,Cyclomatic complexity of the method is 8
Complex Method,cadencii.media.impl,PlaySound,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PlaySound.cs,SoundWaitForExit,Cyclomatic complexity of the method is 14
Complex Method,cadencii.media.impl,PlaySound,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PlaySound.cs,SoundAppend,Cyclomatic complexity of the method is 12
Long Parameter List,cadencii.media,AviReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviReader.cs,ExportToArray,The method has 5 parameters.
Long Parameter List,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Open,The method has 8 parameters.
Long Parameter List,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Open,The method has 6 parameters.
Long Parameter List,cadencii.media,IAviWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\IAviWriter.cs,Open,The method has 6 parameters.
Long Parameter List,cadencii.media,MediaPlayer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MediaPlayer.cs,mciSendString,The method has 4 parameters.
Long Parameter List,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The method has 5 parameters.
Long Parameter List,cadencii.media,RateConvertContext,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RateConvertContext.cs,convert,The method has 4 parameters.
Long Parameter List,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,Open,The method has 6 parameters.
Long Parameter List,cadencii.media,PipedAviWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PipedAviWriter.cs,Open,The method has 4 parameters.
Long Parameter List,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,mmioFOURCC,The method has 4 parameters.
Long Parameter List,cadencii.media,VCM,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VCM.cs,ICCompressorChoose,The method has 6 parameters.
Long Parameter List,cadencii.media,VCM,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VCM.cs,ICSeqCompressFrame,The method has 5 parameters.
Long Parameter List,cadencii.media,VCM,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VCM.cs,ICSendMessage,The method has 4 parameters.
Long Parameter List,cadencii.media,VFW,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,AVIStreamOpenFromFileW,The method has 6 parameters.
Long Parameter List,cadencii.media,VFW,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,AVIFileOpenW,The method has 4 parameters.
Long Parameter List,cadencii.media,VFW,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,AVIMakeCompressedStream,The method has 4 parameters.
Long Parameter List,cadencii.media,VFW,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,AVIStreamSetFormat,The method has 4 parameters.
Long Parameter List,cadencii.media,VFW,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,AVISaveOptions,The method has 5 parameters.
Long Parameter List,cadencii.media,VFW,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,AVIStreamWrite,The method has 8 parameters.
Long Parameter List,cadencii.media,VFW,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,AVIFileGetStream,The method has 4 parameters.
Long Parameter List,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,Open,The method has 6 parameters.
Long Parameter List,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,AVIStreamOpenFromFileW,The method has 6 parameters.
Long Parameter List,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,AVIFileOpenW,The method has 4 parameters.
Long Parameter List,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,AVIMakeCompressedStream,The method has 4 parameters.
Long Parameter List,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,AVIStreamSetFormat,The method has 4 parameters.
Long Parameter List,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,AVISaveOptions,The method has 5 parameters.
Long Parameter List,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,AVIStreamWrite,The method has 8 parameters.
Long Parameter List,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,mmioFOURCC,The method has 4 parameters.
Long Parameter List,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The method has 4 parameters.
Long Parameter List,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,Wave,The method has 4 parameters.
Long Parameter List,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,copyArray,The method has 5 parameters.
Long Parameter List,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,copyArray,The method has 5 parameters.
Long Parameter List,cadencii.media,WavePlay,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WavePlay.cs,wave_callback,The method has 5 parameters.
Long Parameter List,cadencii.media,WavePlay,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WavePlay.cs,append_cor,The method has 5 parameters.
Long Parameter List,cadencii.media,WavePlay,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WavePlay.cs,append,The method has 4 parameters.
Long Parameter List,cadencii.media,WaveRateConverter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveRateConverter.cs,read,The method has 4 parameters.
Long Parameter List,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The method has 4 parameters.
Long Parameter List,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The method has 4 parameters.
Long Parameter List,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The method has 4 parameters.
Long Parameter List,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,WaveWriter,The method has 4 parameters.
Long Parameter List,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The method has 4 parameters.
Long Parameter List,cadencii.media.impl,PlaySound,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PlaySound.cs,SoundCallback,The method has 5 parameters.
Long Statement,cadencii.media,AviReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviReader.cs,Export,The length of the statement  "	BitmapData dat = result.LockBits (new Rectangle (0' 0' bih.biWidth' bih.biHeight)' ImageLockMode.ReadWrite' PixelFormat.Format24bppRgb); " is 136.
Long Statement,cadencii.media,AviReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviReader.cs,ExportEx,The length of the statement  "	BitmapData dat = bmp.LockBits (new Rectangle (0' 0' bih.biWidth' bih.biHeight)' ImageLockMode.ReadWrite' PixelFormat.Format24bppRgb); " is 133.
Long Statement,cadencii.media,AviReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviReader.cs,Export,The length of the statement  "	BitmapData dat = bmp.LockBits (new Rectangle (0' 0' bih.biWidth' bih.biHeight)' ImageLockMode.WriteOnly' bmp.PixelFormat); " is 122.
Long Statement,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Open,The length of the statement  "		using (Bitmap b = new Bitmap (width' height' m_is_transparent ? PixelFormat.Format32bppArgb : PixelFormat.Format24bppRgb)) { " is 124.
Long Statement,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Open,The length of the statement  "		//(BITMAPINFOHEADER)Marshal.PtrToStructure( Marshal.AllocHGlobal( sizeof( BITMAPINFOHEADER ) )' typeof( BITMAPINFOHEADER ) ); " is 125.
Long Statement,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,AddFrame,The length of the statement  "		bmpDat = bmp.LockBits (new Rectangle (0' 0' bmp.Width' bmp.Height)' ImageLockMode.ReadOnly' PixelFormat.Format32bppArgb); " is 121.
Long Statement,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,AddFrame,The length of the statement  "		bmpDat = bmp.LockBits (new Rectangle (0' 0' (int)bmp.Width' (int)bmp.Height)' ImageLockMode.ReadOnly' PixelFormat.Format24bppRgb); " is 130.
Long Statement,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,AddFrame,The length of the statement  "		m_std_index.AddIndex ((uint)((ulong)m_stream.BaseStream.Position - m_std_index.qwBaseOffset) + 8' (uint)(lineSize * height)); " is 125.
Long Statement,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The length of the statement  "						                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) );" is 168.
Long Statement,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,AddFrame,The length of the statement  "	BitmapData bmpDat = bmp.LockBits (new Rectangle (0' 0' (int)bmp.Width' (int)bmp.Height)' ImageLockMode.ReadOnly' PixelFormat.Format24bppRgb); " is 141.
Long Statement,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,AddFrame,The length of the statement  "	m_std_index.AddIndex ((uint)((ulong)m_stream.BaseStream.Position - m_std_index.qwBaseOffset) + 8' (uint)(lineSize * height)); " is 125.
Long Statement,cadencii.media,PipedAviWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PipedAviWriter.cs,AddFrame,The length of the statement  "                BITMAPINFOHEADER bih = new BITMAPINFOHEADER(); //(BITMAPINFOHEADER)Marshal.PtrToStructure( Marshal.AllocHGlobal( sizeof( BITMAPINFOHEADER ) )' typeof( BITMAPINFOHEADER ) );" is 172.
Long Statement,cadencii.media,PipedAviWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PipedAviWriter.cs,AddFrame,The length of the statement  "	//(BITMAPINFOHEADER)Marshal.PtrToStructure( Marshal.AllocHGlobal( sizeof( BITMAPINFOHEADER ) )' typeof( BITMAPINFOHEADER ) ); " is 125.
Long Statement,cadencii.media,PipedAviWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PipedAviWriter.cs,Open,The length of the statement  "	            m_stream = new NamedPipeServerStream( _PIPE_NAME' PipeDirection.Out' 1' PipeTransmissionMode.Byte' PipeOptions.None' 1' 1 );" is 124.
Long Statement,cadencii.media,COMPVARS,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VCM.cs,ToString,The length of the statement  "	return "{cbSize=" + cbSize + "'dwFlags=" + dwFlags + "'hic=" + hic + "'fccType=" + fccType + "'fccHandler=" + fccHandler + "'lpbiIn=" + ((int)lpbiIn).ToString () + "'lpbiOut=" + ((int)lpbiOut).ToString () + "'lpBitsOut=" + ((int)lpBitsOut).ToString () + "'lpBitsPrev=" + ((int)lpBitsPrev).ToString () + "'lFrame=" + lFrame + "'lKey=" + lKey + "'lDataRate=" + lDataRate + "'lQ=" + lQ + "'lKeyCount=" + lKeyCount + "'lpState=" + ((int)lpState).ToString () + "'cbState=" + cbState + "}"; " is 484.
Long Statement,cadencii.media,AVICOMPRESSOPTIONS,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,ToString,The length of the statement  "	return "fccType=" + fccType + "\n" + "fccHandler=" + fccHandler + "\n" + "dwKeyFrameEvery=" + dwKeyFrameEvery + "\n" + "dwQuality=" + dwQuality + "\n" + "dwBytesPerSecond=" + dwBytesPerSecond + "\n" + "dwFlags=" + dwFlags + "\n" + "lpFormat=" + lpFormat + "\n" + "cbFormat=" + cbFormat + "\n" + "lpParms=" + lpParms + "\n" + "cbParms=" + cbParms + "\n" + "dwInterleaveEvery=" + dwInterleaveEvery; " is 396.
Long Statement,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,Open,The length of the statement  "		BitmapData bmpDat = bmp.LockBits (new Rectangle (0' 0' width' height)' ImageLockMode.ReadOnly' PixelFormat.Format24bppRgb); " is 123.
Long Statement,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,AddFrame,The length of the statement  "	BitmapData bmpDat = bmp.LockBits (new Rectangle (0' 0' (int)m_width' (int)m_height)' ImageLockMode.ReadOnly' PixelFormat.Format24bppRgb); " is 137.
Long Statement,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,RequireVideoCompressOption,The length of the statement  "		BitmapData bmpDat = bmp.LockBits (new Rectangle (0' 0' width' height)' ImageLockMode.ReadOnly' PixelFormat.Format24bppRgb); " is 123.
Long Statement,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The length of the statement  "	hiMant = ((long)(bytes [2] & 0xFF) << 24) | ((long)(bytes [3] & 0xFF) << 16) | ((long)(bytes [4] & 0xFF) << 8) | ((long)(bytes [5] & 0xFF)); " is 140.
Long Statement,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The length of the statement  "	loMant = ((long)(bytes [6] & 0xFF) << 24) | ((long)(bytes [7] & 0xFF) << 16) | ((long)(bytes [8] & 0xFF) << 8) | ((long)(bytes [9] & 0xFF)); " is 140.
Long Statement,cadencii.media,WavePlay,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WavePlay.cs,mix,The length of the statement  "		s_wave_reader [k].read (s_block_size * (processed_count - 1) + (int)s_wave_read_offset_samples' s_block_size' ref s_ptr_another_wave_l [k]' ref s_ptr_another_wave_r [k]); " is 170.
Long Statement,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The length of the statement  "	            sout.println( "WaveReaderopen; m_total_samples=" + m_total_samples + "; total sec=" + (m_total_samples / (double)m_sample_per_sec) );" is 133.
Long Statement,cadencii.media.impl,PlaySound,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PlaySound.cs,SoundAppend,The length of the statement  "			wave [act_buffer_index] [buffer_loc + i] = (uint)win32.MAKELONG ((WORD)(left [appended + i] * 32768.0)' (WORD)(right [appended + i] * 32768.0)); " is 144.
Complex Conditional,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,AddFrame,The conditional expression  "(m_current_chunk == 0 && chunk_size > m_split_sreshold) || (m_current_chunk > 0 && chunk_size > _THRESHOLD)"  is complex.
Complex Conditional,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,AddFrame,The conditional expression  "(m_current_chunk == 0 && chunk_size > m_split_sreshold) || (m_current_chunk > 0 && chunk_size > SRESHOLD)"  is complex.
Complex Conditional,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The conditional expression  "L8 == null || R8 == null || srcWave.L8 == null || srcWave.R8 == null"  is complex.
Complex Conditional,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The conditional expression  "L16 == null || R16 == null || srcWave.L16 == null || srcWave.R16 == null"  is complex.
Complex Conditional,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The conditional expression  "m_channel != WaveChannel.Stereo || m_bit_per_sample != 8 || L8 == null || R8 == null"  is complex.
Complex Conditional,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The conditional expression  "m_channel != WaveChannel.Stereo || m_bit_per_sample != 16 || L16 == null || R16 == null"  is complex.
Complex Conditional,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The conditional expression  "buf [0] != 0x57 || buf [1] != 0x41 || buf [2] != 0x56 || buf [3] != 0x45"  is complex.
Complex Conditional,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The conditional expression  "buf [0] != 0x66 || buf [1] != 0x6d || buf [2] != 0x74 || buf [3] != 0x20"  is complex.
Complex Conditional,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The conditional expression  "buf [0] == 0x52 && buf [1] == 0x49 && buf [2] == 0x46 && buf [3] == 0x46"  is complex.
Complex Conditional,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The conditional expression  "buf [0] == 0x46 && buf [1] == 0x4f && buf [2] == 0x52 && buf [3] == 0x4d"  is complex.
Complex Conditional,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The conditional expression  "buf [0] != 'R' || buf [1] != 'I' || buf [2] != 'F' || buf [3] != 'F'"  is complex.
Complex Conditional,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The conditional expression  "buf [0] != 'W' || buf [1] != 'A' || buf [2] != 'V' || buf [3] != 'E'"  is complex.
Complex Conditional,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The conditional expression  "buf [0] != 'f' || buf [1] != 'm' || buf [2] != 't' || buf [3] != ' '"  is complex.
Complex Conditional,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The conditional expression  "buf [0] != 'd' || buf [1] != 'a' || buf [2] != 't' || buf [3] != 'a'"  is complex.
Empty Catch Block,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,AddFrame,The method has an empty catch block.
Empty Catch Block,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,printToText,The method has an empty catch block.
Empty Catch Block,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,printToText,The method has an empty catch block.
Empty Catch Block,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The method has an empty catch block.
Empty Catch Block,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The method has an empty catch block.
Empty Catch Block,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The method has an empty catch block.
Empty Catch Block,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The method has an empty catch block.
Empty Catch Block,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The method has an empty catch block.
Magic Number,cadencii.media,AviReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviReader.cs,Open,The following statement contains a magic number: bih.biBitCount = 24;  
Magic Number,cadencii.media,AviReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviReader.cs,ExportBitmap,The following statement contains a magic number: bfh.bfSize = (Int32)(55 + bih.biSizeImage);  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Open,The following statement contains a magic number: m_main_header.dwMicroSecPerFrame = (uint)(1.0e6 / fps);  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Open,The following statement contains a magic number: m_main_header.dwFlags = 2064;  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Open,The following statement contains a magic number: if (m_is_first) {  	int stride = 0;  	using (Bitmap b = new Bitmap (width' height' m_is_transparent ? PixelFormat.Format32bppArgb : PixelFormat.Format24bppRgb)) {  		BitmapData bd = b.LockBits (new Rectangle (0' 0' width' height)' ImageLockMode.ReadOnly' b.PixelFormat);  		stride = bd.Stride;  		b.UnlockBits (bd);  	}  	m_is_first = false;  	m_main_header.dwWidth = (uint)width;  	m_main_header.dwHeight = (uint)height;  	m_main_header.dwMaxBytesPerSec = (uint)(stride * height * frameRate);  	m_main_header.dwStreams = 1;  	m_main_header.dwSuggestedBufferSize = (uint)(stride * height);  	m_linesize = stride;  	m_stream_header.fccType = Util.mmioFOURCC ("vids");  	m_stream_header.fccHandler = 0;  	m_stream_header.dwFlags = 0;  	m_stream_header.dwReserved1 = 0;  	m_stream_header.dwInitialFrames = 0;  	m_stream_header.dwScale = m_scale;  	m_stream_header.dwRate = m_rate;  	m_stream_header.dwStart = 0;  	m_stream_header.dwSuggestedBufferSize = m_main_header.dwSuggestedBufferSize;  	m_stream_header.dwQuality = 0;  	m_stream_header.dwSampleSize = 0;  	Util.aviWriteMainHeader (m_main_header' m_stream);  	Util.fwrite ("LIST"' m_stream);  	Util.WriteDWORD (0x874' m_stream);  	Util.fwrite ("strl"' m_stream);  	Util.aviWriteStreamHeader (m_stream_header' m_main_header' m_stream);  	Util.fwrite ("strf"' m_stream);  	BITMAPINFOHEADER bih = new BITMAPINFOHEADER ();  	//(BITMAPINFOHEADER)Marshal.PtrToStructure( Marshal.AllocHGlobal( sizeof( BITMAPINFOHEADER ) )' typeof( BITMAPINFOHEADER ) );  	bih.biSize = (uint)(Marshal.SizeOf (bih));  	bih.biWidth = width;  	bih.biHeight = height;  	bih.biPlanes = 1;  	bih.biBitCount = m_is_transparent ? (short)32 : (short)24;  	bih.biCompression = 0;  	//BI_RGB  	bih.biSizeImage = (uint)(stride * height);  	bih.biXPelsPerMeter = 0;  	bih.biYPelsPerMeter = 0;  	bih.biClrUsed = 0;  	bih.biClrImportant = 0;  	if (m_compressed) {  		m_p_compvar = Marshal.AllocHGlobal (sizeof(COMPVARS));  		m_compvar = (COMPVARS*)m_p_compvar.ToPointer ();  		byte[] buf = new byte[sizeof(COMPVARS)];  		for (int i = 0; i < buf.Length; i++) {  			buf [i] = 0x0;  		}  		Marshal.Copy (buf' 0' m_p_compvar' buf.Length);  		m_compvar->cbSize = sizeof(COMPVARS);  		int ret = VCM.ICCompressorChoose (m_hwnd' 0' IntPtr.Zero' IntPtr.Zero' m_compvar' "Select Video Compressor");  		if (ret == 0) {  			m_opened = false;  			Marshal.FreeHGlobal (m_p_compvar);  			m_stream.Close ();  			return false;  		}  		if (m_compvar->hic != 0) {  			m_p_bitmapinfo_in = Marshal.AllocHGlobal (sizeof(BITMAPINFO));  			m_bitmapinfo_in = (BITMAPINFO*)m_p_bitmapinfo_in.ToPointer ();  			buf = new byte[sizeof(BITMAPINFO)];  			for (int i = 0; i < buf.Length; i++) {  				buf [i] = 0x0;  			}  			Marshal.Copy (buf' 0' m_p_bitmapinfo_in' buf.Length);  			m_bitmapinfo_in->bmiHeader = bih;  			uint dwSize = VCM.ICCompressGetFormatSize (m_compvar->hic' m_bitmapinfo_in);  			#if DEBUG  			                        Console.WriteLine( "m_compvar->hic=" + m_compvar->hic );                         Console.WriteLine( "ICCompressGetFormatSize=" + dwSize ); #endif  			m_p_bitmapinfo_out = Marshal.AllocHGlobal ((int)dwSize);  			m_bitmapinfo_out = (BITMAPINFO*)m_p_bitmapinfo_out.ToPointer ();  			buf = new byte[dwSize];  			for (int i = 0; i < buf.Length; i++) {  				buf [i] = 0x0;  			}  			Marshal.Copy (buf' 0' m_p_bitmapinfo_out' buf.Length);  			VCM.ICCompressGetFormat (m_compvar->hic' m_bitmapinfo_in' m_bitmapinfo_out);  			m_bih_compression = m_bitmapinfo_out->bmiHeader.biCompression;  			#if DEBUG  			                        Console.WriteLine( "AddFrame(Bitmap)" );                         Console.WriteLine( "    biout.biSize=" + m_bitmapinfo_out->bmiHeader.biSize ); #endif  			VCM.ICSeqCompressFrameStart (m_compvar' m_bitmapinfo_in);  			bih = m_bitmapinfo_out->bmiHeader;  			Util.WriteDWORD (bih.biSize' m_stream);  			// infoHeaderのサイズ  			m_bitmapinfo_out->Write (m_stream);  		} else {  			m_compressed = false;  			Util.WriteDWORD (bih.biSize' m_stream);  			// infoHeaderのサイズ  			bih.Write (m_stream);  		}  	} else {  		Util.WriteDWORD (bih.biSize' m_stream);  		// infoHeaderのサイズ  		bih.Write (m_stream);  	}  	m_super_index_position = m_stream.BaseStream.Position;  	Util.fwrite ("indx"' m_stream);  	//fcc  	Util.WriteDWORD (0x7f8' m_stream);  	// cb  	Util.WriteWORD ((byte)0x4' m_stream);  	// wLongsPerEntry  	Util.WriteBYTE (0x0' m_stream);  	// bIndexSubType  	Util.WriteBYTE (Util.AVI_INDEX_OF_INDEXES' m_stream);  	// bIndexType  	Util.WriteDWORD (0x0' m_stream);  	// nEntriesInUse  	Util.fwrite ("00db"' m_stream);  	// dwChunkId  	Util.WriteDWORD (0x0' m_stream);  	Util.WriteDWORD (0x0' m_stream);  	Util.WriteDWORD (0x0' m_stream);  	for (int ii = 1; ii <= 126; ii++) {  		Util.WriteQWORD (0x0' m_stream);  		Util.WriteDWORD (0x0' m_stream);  		Util.WriteDWORD (0x0' m_stream);  	}  	Util.fwrite ("LIST"' m_stream);  	Util.WriteDWORD (0x104' m_stream);  	Util.fwrite ("odml"' m_stream);  	Util.fwrite ("dmlh"' m_stream);  	Util.WriteDWORD (0xf8' m_stream);  	Util.WriteDWORD (0x0' m_stream);  	//ここ後で更新するべき  	for (int ii = 1; ii <= 61; ii++) {  		Util.WriteDWORD (0x0' m_stream);  	}  	Util.fwrite ("JUNK"' m_stream);  	Util.WriteDWORD (0x60c' m_stream);  	Util.WriteDWORD (0' m_stream);  	//"This"が将来登録されたらやばいので  	string msg = "This file was generated by AviWriter@Boare.Lib.Media;VfwBugCompatible=" + VfwBugCompatible;  	const int tlen = 1544;  	int remain = tlen - msg.Length;  	Util.fwrite (msg' m_stream);  	for (int i = 1; i <= remain; i++) {  		m_stream.Write ((byte)0);  	}  	m_junk_length = 0xff4;  	Util.fwrite ("LIST"' m_stream);  	m_movi_position = m_stream.BaseStream.Position;  	Util.WriteDWORD (0' m_stream);  	// call bmpQWordWrite( 0' avi%fp )     !// ******************ココの数字は一番最後に書き換える必要あり2040～2043あとdwTotalFrames（48～51）も  	Util.fwrite ("movi"' m_stream);  	m_next_framedata_position = m_stream.BaseStream.Position;  	m_std_index.SetBaseOffset ((ulong)m_next_framedata_position);  	m_super_index.nEntriesInUse++;  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Open,The following statement contains a magic number: if (m_is_first) {  	int stride = 0;  	using (Bitmap b = new Bitmap (width' height' m_is_transparent ? PixelFormat.Format32bppArgb : PixelFormat.Format24bppRgb)) {  		BitmapData bd = b.LockBits (new Rectangle (0' 0' width' height)' ImageLockMode.ReadOnly' b.PixelFormat);  		stride = bd.Stride;  		b.UnlockBits (bd);  	}  	m_is_first = false;  	m_main_header.dwWidth = (uint)width;  	m_main_header.dwHeight = (uint)height;  	m_main_header.dwMaxBytesPerSec = (uint)(stride * height * frameRate);  	m_main_header.dwStreams = 1;  	m_main_header.dwSuggestedBufferSize = (uint)(stride * height);  	m_linesize = stride;  	m_stream_header.fccType = Util.mmioFOURCC ("vids");  	m_stream_header.fccHandler = 0;  	m_stream_header.dwFlags = 0;  	m_stream_header.dwReserved1 = 0;  	m_stream_header.dwInitialFrames = 0;  	m_stream_header.dwScale = m_scale;  	m_stream_header.dwRate = m_rate;  	m_stream_header.dwStart = 0;  	m_stream_header.dwSuggestedBufferSize = m_main_header.dwSuggestedBufferSize;  	m_stream_header.dwQuality = 0;  	m_stream_header.dwSampleSize = 0;  	Util.aviWriteMainHeader (m_main_header' m_stream);  	Util.fwrite ("LIST"' m_stream);  	Util.WriteDWORD (0x874' m_stream);  	Util.fwrite ("strl"' m_stream);  	Util.aviWriteStreamHeader (m_stream_header' m_main_header' m_stream);  	Util.fwrite ("strf"' m_stream);  	BITMAPINFOHEADER bih = new BITMAPINFOHEADER ();  	//(BITMAPINFOHEADER)Marshal.PtrToStructure( Marshal.AllocHGlobal( sizeof( BITMAPINFOHEADER ) )' typeof( BITMAPINFOHEADER ) );  	bih.biSize = (uint)(Marshal.SizeOf (bih));  	bih.biWidth = width;  	bih.biHeight = height;  	bih.biPlanes = 1;  	bih.biBitCount = m_is_transparent ? (short)32 : (short)24;  	bih.biCompression = 0;  	//BI_RGB  	bih.biSizeImage = (uint)(stride * height);  	bih.biXPelsPerMeter = 0;  	bih.biYPelsPerMeter = 0;  	bih.biClrUsed = 0;  	bih.biClrImportant = 0;  	if (m_compressed) {  		m_p_compvar = Marshal.AllocHGlobal (sizeof(COMPVARS));  		m_compvar = (COMPVARS*)m_p_compvar.ToPointer ();  		byte[] buf = new byte[sizeof(COMPVARS)];  		for (int i = 0; i < buf.Length; i++) {  			buf [i] = 0x0;  		}  		Marshal.Copy (buf' 0' m_p_compvar' buf.Length);  		m_compvar->cbSize = sizeof(COMPVARS);  		int ret = VCM.ICCompressorChoose (m_hwnd' 0' IntPtr.Zero' IntPtr.Zero' m_compvar' "Select Video Compressor");  		if (ret == 0) {  			m_opened = false;  			Marshal.FreeHGlobal (m_p_compvar);  			m_stream.Close ();  			return false;  		}  		if (m_compvar->hic != 0) {  			m_p_bitmapinfo_in = Marshal.AllocHGlobal (sizeof(BITMAPINFO));  			m_bitmapinfo_in = (BITMAPINFO*)m_p_bitmapinfo_in.ToPointer ();  			buf = new byte[sizeof(BITMAPINFO)];  			for (int i = 0; i < buf.Length; i++) {  				buf [i] = 0x0;  			}  			Marshal.Copy (buf' 0' m_p_bitmapinfo_in' buf.Length);  			m_bitmapinfo_in->bmiHeader = bih;  			uint dwSize = VCM.ICCompressGetFormatSize (m_compvar->hic' m_bitmapinfo_in);  			#if DEBUG  			                        Console.WriteLine( "m_compvar->hic=" + m_compvar->hic );                         Console.WriteLine( "ICCompressGetFormatSize=" + dwSize ); #endif  			m_p_bitmapinfo_out = Marshal.AllocHGlobal ((int)dwSize);  			m_bitmapinfo_out = (BITMAPINFO*)m_p_bitmapinfo_out.ToPointer ();  			buf = new byte[dwSize];  			for (int i = 0; i < buf.Length; i++) {  				buf [i] = 0x0;  			}  			Marshal.Copy (buf' 0' m_p_bitmapinfo_out' buf.Length);  			VCM.ICCompressGetFormat (m_compvar->hic' m_bitmapinfo_in' m_bitmapinfo_out);  			m_bih_compression = m_bitmapinfo_out->bmiHeader.biCompression;  			#if DEBUG  			                        Console.WriteLine( "AddFrame(Bitmap)" );                         Console.WriteLine( "    biout.biSize=" + m_bitmapinfo_out->bmiHeader.biSize ); #endif  			VCM.ICSeqCompressFrameStart (m_compvar' m_bitmapinfo_in);  			bih = m_bitmapinfo_out->bmiHeader;  			Util.WriteDWORD (bih.biSize' m_stream);  			// infoHeaderのサイズ  			m_bitmapinfo_out->Write (m_stream);  		} else {  			m_compressed = false;  			Util.WriteDWORD (bih.biSize' m_stream);  			// infoHeaderのサイズ  			bih.Write (m_stream);  		}  	} else {  		Util.WriteDWORD (bih.biSize' m_stream);  		// infoHeaderのサイズ  		bih.Write (m_stream);  	}  	m_super_index_position = m_stream.BaseStream.Position;  	Util.fwrite ("indx"' m_stream);  	//fcc  	Util.WriteDWORD (0x7f8' m_stream);  	// cb  	Util.WriteWORD ((byte)0x4' m_stream);  	// wLongsPerEntry  	Util.WriteBYTE (0x0' m_stream);  	// bIndexSubType  	Util.WriteBYTE (Util.AVI_INDEX_OF_INDEXES' m_stream);  	// bIndexType  	Util.WriteDWORD (0x0' m_stream);  	// nEntriesInUse  	Util.fwrite ("00db"' m_stream);  	// dwChunkId  	Util.WriteDWORD (0x0' m_stream);  	Util.WriteDWORD (0x0' m_stream);  	Util.WriteDWORD (0x0' m_stream);  	for (int ii = 1; ii <= 126; ii++) {  		Util.WriteQWORD (0x0' m_stream);  		Util.WriteDWORD (0x0' m_stream);  		Util.WriteDWORD (0x0' m_stream);  	}  	Util.fwrite ("LIST"' m_stream);  	Util.WriteDWORD (0x104' m_stream);  	Util.fwrite ("odml"' m_stream);  	Util.fwrite ("dmlh"' m_stream);  	Util.WriteDWORD (0xf8' m_stream);  	Util.WriteDWORD (0x0' m_stream);  	//ここ後で更新するべき  	for (int ii = 1; ii <= 61; ii++) {  		Util.WriteDWORD (0x0' m_stream);  	}  	Util.fwrite ("JUNK"' m_stream);  	Util.WriteDWORD (0x60c' m_stream);  	Util.WriteDWORD (0' m_stream);  	//"This"が将来登録されたらやばいので  	string msg = "This file was generated by AviWriter@Boare.Lib.Media;VfwBugCompatible=" + VfwBugCompatible;  	const int tlen = 1544;  	int remain = tlen - msg.Length;  	Util.fwrite (msg' m_stream);  	for (int i = 1; i <= remain; i++) {  		m_stream.Write ((byte)0);  	}  	m_junk_length = 0xff4;  	Util.fwrite ("LIST"' m_stream);  	m_movi_position = m_stream.BaseStream.Position;  	Util.WriteDWORD (0' m_stream);  	// call bmpQWordWrite( 0' avi%fp )     !// ******************ココの数字は一番最後に書き換える必要あり2040～2043あとdwTotalFrames（48～51）も  	Util.fwrite ("movi"' m_stream);  	m_next_framedata_position = m_stream.BaseStream.Position;  	m_std_index.SetBaseOffset ((ulong)m_next_framedata_position);  	m_super_index.nEntriesInUse++;  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Open,The following statement contains a magic number: if (m_is_first) {  	int stride = 0;  	using (Bitmap b = new Bitmap (width' height' m_is_transparent ? PixelFormat.Format32bppArgb : PixelFormat.Format24bppRgb)) {  		BitmapData bd = b.LockBits (new Rectangle (0' 0' width' height)' ImageLockMode.ReadOnly' b.PixelFormat);  		stride = bd.Stride;  		b.UnlockBits (bd);  	}  	m_is_first = false;  	m_main_header.dwWidth = (uint)width;  	m_main_header.dwHeight = (uint)height;  	m_main_header.dwMaxBytesPerSec = (uint)(stride * height * frameRate);  	m_main_header.dwStreams = 1;  	m_main_header.dwSuggestedBufferSize = (uint)(stride * height);  	m_linesize = stride;  	m_stream_header.fccType = Util.mmioFOURCC ("vids");  	m_stream_header.fccHandler = 0;  	m_stream_header.dwFlags = 0;  	m_stream_header.dwReserved1 = 0;  	m_stream_header.dwInitialFrames = 0;  	m_stream_header.dwScale = m_scale;  	m_stream_header.dwRate = m_rate;  	m_stream_header.dwStart = 0;  	m_stream_header.dwSuggestedBufferSize = m_main_header.dwSuggestedBufferSize;  	m_stream_header.dwQuality = 0;  	m_stream_header.dwSampleSize = 0;  	Util.aviWriteMainHeader (m_main_header' m_stream);  	Util.fwrite ("LIST"' m_stream);  	Util.WriteDWORD (0x874' m_stream);  	Util.fwrite ("strl"' m_stream);  	Util.aviWriteStreamHeader (m_stream_header' m_main_header' m_stream);  	Util.fwrite ("strf"' m_stream);  	BITMAPINFOHEADER bih = new BITMAPINFOHEADER ();  	//(BITMAPINFOHEADER)Marshal.PtrToStructure( Marshal.AllocHGlobal( sizeof( BITMAPINFOHEADER ) )' typeof( BITMAPINFOHEADER ) );  	bih.biSize = (uint)(Marshal.SizeOf (bih));  	bih.biWidth = width;  	bih.biHeight = height;  	bih.biPlanes = 1;  	bih.biBitCount = m_is_transparent ? (short)32 : (short)24;  	bih.biCompression = 0;  	//BI_RGB  	bih.biSizeImage = (uint)(stride * height);  	bih.biXPelsPerMeter = 0;  	bih.biYPelsPerMeter = 0;  	bih.biClrUsed = 0;  	bih.biClrImportant = 0;  	if (m_compressed) {  		m_p_compvar = Marshal.AllocHGlobal (sizeof(COMPVARS));  		m_compvar = (COMPVARS*)m_p_compvar.ToPointer ();  		byte[] buf = new byte[sizeof(COMPVARS)];  		for (int i = 0; i < buf.Length; i++) {  			buf [i] = 0x0;  		}  		Marshal.Copy (buf' 0' m_p_compvar' buf.Length);  		m_compvar->cbSize = sizeof(COMPVARS);  		int ret = VCM.ICCompressorChoose (m_hwnd' 0' IntPtr.Zero' IntPtr.Zero' m_compvar' "Select Video Compressor");  		if (ret == 0) {  			m_opened = false;  			Marshal.FreeHGlobal (m_p_compvar);  			m_stream.Close ();  			return false;  		}  		if (m_compvar->hic != 0) {  			m_p_bitmapinfo_in = Marshal.AllocHGlobal (sizeof(BITMAPINFO));  			m_bitmapinfo_in = (BITMAPINFO*)m_p_bitmapinfo_in.ToPointer ();  			buf = new byte[sizeof(BITMAPINFO)];  			for (int i = 0; i < buf.Length; i++) {  				buf [i] = 0x0;  			}  			Marshal.Copy (buf' 0' m_p_bitmapinfo_in' buf.Length);  			m_bitmapinfo_in->bmiHeader = bih;  			uint dwSize = VCM.ICCompressGetFormatSize (m_compvar->hic' m_bitmapinfo_in);  			#if DEBUG  			                        Console.WriteLine( "m_compvar->hic=" + m_compvar->hic );                         Console.WriteLine( "ICCompressGetFormatSize=" + dwSize ); #endif  			m_p_bitmapinfo_out = Marshal.AllocHGlobal ((int)dwSize);  			m_bitmapinfo_out = (BITMAPINFO*)m_p_bitmapinfo_out.ToPointer ();  			buf = new byte[dwSize];  			for (int i = 0; i < buf.Length; i++) {  				buf [i] = 0x0;  			}  			Marshal.Copy (buf' 0' m_p_bitmapinfo_out' buf.Length);  			VCM.ICCompressGetFormat (m_compvar->hic' m_bitmapinfo_in' m_bitmapinfo_out);  			m_bih_compression = m_bitmapinfo_out->bmiHeader.biCompression;  			#if DEBUG  			                        Console.WriteLine( "AddFrame(Bitmap)" );                         Console.WriteLine( "    biout.biSize=" + m_bitmapinfo_out->bmiHeader.biSize ); #endif  			VCM.ICSeqCompressFrameStart (m_compvar' m_bitmapinfo_in);  			bih = m_bitmapinfo_out->bmiHeader;  			Util.WriteDWORD (bih.biSize' m_stream);  			// infoHeaderのサイズ  			m_bitmapinfo_out->Write (m_stream);  		} else {  			m_compressed = false;  			Util.WriteDWORD (bih.biSize' m_stream);  			// infoHeaderのサイズ  			bih.Write (m_stream);  		}  	} else {  		Util.WriteDWORD (bih.biSize' m_stream);  		// infoHeaderのサイズ  		bih.Write (m_stream);  	}  	m_super_index_position = m_stream.BaseStream.Position;  	Util.fwrite ("indx"' m_stream);  	//fcc  	Util.WriteDWORD (0x7f8' m_stream);  	// cb  	Util.WriteWORD ((byte)0x4' m_stream);  	// wLongsPerEntry  	Util.WriteBYTE (0x0' m_stream);  	// bIndexSubType  	Util.WriteBYTE (Util.AVI_INDEX_OF_INDEXES' m_stream);  	// bIndexType  	Util.WriteDWORD (0x0' m_stream);  	// nEntriesInUse  	Util.fwrite ("00db"' m_stream);  	// dwChunkId  	Util.WriteDWORD (0x0' m_stream);  	Util.WriteDWORD (0x0' m_stream);  	Util.WriteDWORD (0x0' m_stream);  	for (int ii = 1; ii <= 126; ii++) {  		Util.WriteQWORD (0x0' m_stream);  		Util.WriteDWORD (0x0' m_stream);  		Util.WriteDWORD (0x0' m_stream);  	}  	Util.fwrite ("LIST"' m_stream);  	Util.WriteDWORD (0x104' m_stream);  	Util.fwrite ("odml"' m_stream);  	Util.fwrite ("dmlh"' m_stream);  	Util.WriteDWORD (0xf8' m_stream);  	Util.WriteDWORD (0x0' m_stream);  	//ここ後で更新するべき  	for (int ii = 1; ii <= 61; ii++) {  		Util.WriteDWORD (0x0' m_stream);  	}  	Util.fwrite ("JUNK"' m_stream);  	Util.WriteDWORD (0x60c' m_stream);  	Util.WriteDWORD (0' m_stream);  	//"This"が将来登録されたらやばいので  	string msg = "This file was generated by AviWriter@Boare.Lib.Media;VfwBugCompatible=" + VfwBugCompatible;  	const int tlen = 1544;  	int remain = tlen - msg.Length;  	Util.fwrite (msg' m_stream);  	for (int i = 1; i <= remain; i++) {  		m_stream.Write ((byte)0);  	}  	m_junk_length = 0xff4;  	Util.fwrite ("LIST"' m_stream);  	m_movi_position = m_stream.BaseStream.Position;  	Util.WriteDWORD (0' m_stream);  	// call bmpQWordWrite( 0' avi%fp )     !// ******************ココの数字は一番最後に書き換える必要あり2040～2043あとdwTotalFrames（48～51）も  	Util.fwrite ("movi"' m_stream);  	m_next_framedata_position = m_stream.BaseStream.Position;  	m_std_index.SetBaseOffset ((ulong)m_next_framedata_position);  	m_super_index.nEntriesInUse++;  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Open,The following statement contains a magic number: if (m_is_first) {  	int stride = 0;  	using (Bitmap b = new Bitmap (width' height' m_is_transparent ? PixelFormat.Format32bppArgb : PixelFormat.Format24bppRgb)) {  		BitmapData bd = b.LockBits (new Rectangle (0' 0' width' height)' ImageLockMode.ReadOnly' b.PixelFormat);  		stride = bd.Stride;  		b.UnlockBits (bd);  	}  	m_is_first = false;  	m_main_header.dwWidth = (uint)width;  	m_main_header.dwHeight = (uint)height;  	m_main_header.dwMaxBytesPerSec = (uint)(stride * height * frameRate);  	m_main_header.dwStreams = 1;  	m_main_header.dwSuggestedBufferSize = (uint)(stride * height);  	m_linesize = stride;  	m_stream_header.fccType = Util.mmioFOURCC ("vids");  	m_stream_header.fccHandler = 0;  	m_stream_header.dwFlags = 0;  	m_stream_header.dwReserved1 = 0;  	m_stream_header.dwInitialFrames = 0;  	m_stream_header.dwScale = m_scale;  	m_stream_header.dwRate = m_rate;  	m_stream_header.dwStart = 0;  	m_stream_header.dwSuggestedBufferSize = m_main_header.dwSuggestedBufferSize;  	m_stream_header.dwQuality = 0;  	m_stream_header.dwSampleSize = 0;  	Util.aviWriteMainHeader (m_main_header' m_stream);  	Util.fwrite ("LIST"' m_stream);  	Util.WriteDWORD (0x874' m_stream);  	Util.fwrite ("strl"' m_stream);  	Util.aviWriteStreamHeader (m_stream_header' m_main_header' m_stream);  	Util.fwrite ("strf"' m_stream);  	BITMAPINFOHEADER bih = new BITMAPINFOHEADER ();  	//(BITMAPINFOHEADER)Marshal.PtrToStructure( Marshal.AllocHGlobal( sizeof( BITMAPINFOHEADER ) )' typeof( BITMAPINFOHEADER ) );  	bih.biSize = (uint)(Marshal.SizeOf (bih));  	bih.biWidth = width;  	bih.biHeight = height;  	bih.biPlanes = 1;  	bih.biBitCount = m_is_transparent ? (short)32 : (short)24;  	bih.biCompression = 0;  	//BI_RGB  	bih.biSizeImage = (uint)(stride * height);  	bih.biXPelsPerMeter = 0;  	bih.biYPelsPerMeter = 0;  	bih.biClrUsed = 0;  	bih.biClrImportant = 0;  	if (m_compressed) {  		m_p_compvar = Marshal.AllocHGlobal (sizeof(COMPVARS));  		m_compvar = (COMPVARS*)m_p_compvar.ToPointer ();  		byte[] buf = new byte[sizeof(COMPVARS)];  		for (int i = 0; i < buf.Length; i++) {  			buf [i] = 0x0;  		}  		Marshal.Copy (buf' 0' m_p_compvar' buf.Length);  		m_compvar->cbSize = sizeof(COMPVARS);  		int ret = VCM.ICCompressorChoose (m_hwnd' 0' IntPtr.Zero' IntPtr.Zero' m_compvar' "Select Video Compressor");  		if (ret == 0) {  			m_opened = false;  			Marshal.FreeHGlobal (m_p_compvar);  			m_stream.Close ();  			return false;  		}  		if (m_compvar->hic != 0) {  			m_p_bitmapinfo_in = Marshal.AllocHGlobal (sizeof(BITMAPINFO));  			m_bitmapinfo_in = (BITMAPINFO*)m_p_bitmapinfo_in.ToPointer ();  			buf = new byte[sizeof(BITMAPINFO)];  			for (int i = 0; i < buf.Length; i++) {  				buf [i] = 0x0;  			}  			Marshal.Copy (buf' 0' m_p_bitmapinfo_in' buf.Length);  			m_bitmapinfo_in->bmiHeader = bih;  			uint dwSize = VCM.ICCompressGetFormatSize (m_compvar->hic' m_bitmapinfo_in);  			#if DEBUG  			                        Console.WriteLine( "m_compvar->hic=" + m_compvar->hic );                         Console.WriteLine( "ICCompressGetFormatSize=" + dwSize ); #endif  			m_p_bitmapinfo_out = Marshal.AllocHGlobal ((int)dwSize);  			m_bitmapinfo_out = (BITMAPINFO*)m_p_bitmapinfo_out.ToPointer ();  			buf = new byte[dwSize];  			for (int i = 0; i < buf.Length; i++) {  				buf [i] = 0x0;  			}  			Marshal.Copy (buf' 0' m_p_bitmapinfo_out' buf.Length);  			VCM.ICCompressGetFormat (m_compvar->hic' m_bitmapinfo_in' m_bitmapinfo_out);  			m_bih_compression = m_bitmapinfo_out->bmiHeader.biCompression;  			#if DEBUG  			                        Console.WriteLine( "AddFrame(Bitmap)" );                         Console.WriteLine( "    biout.biSize=" + m_bitmapinfo_out->bmiHeader.biSize ); #endif  			VCM.ICSeqCompressFrameStart (m_compvar' m_bitmapinfo_in);  			bih = m_bitmapinfo_out->bmiHeader;  			Util.WriteDWORD (bih.biSize' m_stream);  			// infoHeaderのサイズ  			m_bitmapinfo_out->Write (m_stream);  		} else {  			m_compressed = false;  			Util.WriteDWORD (bih.biSize' m_stream);  			// infoHeaderのサイズ  			bih.Write (m_stream);  		}  	} else {  		Util.WriteDWORD (bih.biSize' m_stream);  		// infoHeaderのサイズ  		bih.Write (m_stream);  	}  	m_super_index_position = m_stream.BaseStream.Position;  	Util.fwrite ("indx"' m_stream);  	//fcc  	Util.WriteDWORD (0x7f8' m_stream);  	// cb  	Util.WriteWORD ((byte)0x4' m_stream);  	// wLongsPerEntry  	Util.WriteBYTE (0x0' m_stream);  	// bIndexSubType  	Util.WriteBYTE (Util.AVI_INDEX_OF_INDEXES' m_stream);  	// bIndexType  	Util.WriteDWORD (0x0' m_stream);  	// nEntriesInUse  	Util.fwrite ("00db"' m_stream);  	// dwChunkId  	Util.WriteDWORD (0x0' m_stream);  	Util.WriteDWORD (0x0' m_stream);  	Util.WriteDWORD (0x0' m_stream);  	for (int ii = 1; ii <= 126; ii++) {  		Util.WriteQWORD (0x0' m_stream);  		Util.WriteDWORD (0x0' m_stream);  		Util.WriteDWORD (0x0' m_stream);  	}  	Util.fwrite ("LIST"' m_stream);  	Util.WriteDWORD (0x104' m_stream);  	Util.fwrite ("odml"' m_stream);  	Util.fwrite ("dmlh"' m_stream);  	Util.WriteDWORD (0xf8' m_stream);  	Util.WriteDWORD (0x0' m_stream);  	//ここ後で更新するべき  	for (int ii = 1; ii <= 61; ii++) {  		Util.WriteDWORD (0x0' m_stream);  	}  	Util.fwrite ("JUNK"' m_stream);  	Util.WriteDWORD (0x60c' m_stream);  	Util.WriteDWORD (0' m_stream);  	//"This"が将来登録されたらやばいので  	string msg = "This file was generated by AviWriter@Boare.Lib.Media;VfwBugCompatible=" + VfwBugCompatible;  	const int tlen = 1544;  	int remain = tlen - msg.Length;  	Util.fwrite (msg' m_stream);  	for (int i = 1; i <= remain; i++) {  		m_stream.Write ((byte)0);  	}  	m_junk_length = 0xff4;  	Util.fwrite ("LIST"' m_stream);  	m_movi_position = m_stream.BaseStream.Position;  	Util.WriteDWORD (0' m_stream);  	// call bmpQWordWrite( 0' avi%fp )     !// ******************ココの数字は一番最後に書き換える必要あり2040～2043あとdwTotalFrames（48～51）も  	Util.fwrite ("movi"' m_stream);  	m_next_framedata_position = m_stream.BaseStream.Position;  	m_std_index.SetBaseOffset ((ulong)m_next_framedata_position);  	m_super_index.nEntriesInUse++;  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Open,The following statement contains a magic number: if (m_is_first) {  	int stride = 0;  	using (Bitmap b = new Bitmap (width' height' m_is_transparent ? PixelFormat.Format32bppArgb : PixelFormat.Format24bppRgb)) {  		BitmapData bd = b.LockBits (new Rectangle (0' 0' width' height)' ImageLockMode.ReadOnly' b.PixelFormat);  		stride = bd.Stride;  		b.UnlockBits (bd);  	}  	m_is_first = false;  	m_main_header.dwWidth = (uint)width;  	m_main_header.dwHeight = (uint)height;  	m_main_header.dwMaxBytesPerSec = (uint)(stride * height * frameRate);  	m_main_header.dwStreams = 1;  	m_main_header.dwSuggestedBufferSize = (uint)(stride * height);  	m_linesize = stride;  	m_stream_header.fccType = Util.mmioFOURCC ("vids");  	m_stream_header.fccHandler = 0;  	m_stream_header.dwFlags = 0;  	m_stream_header.dwReserved1 = 0;  	m_stream_header.dwInitialFrames = 0;  	m_stream_header.dwScale = m_scale;  	m_stream_header.dwRate = m_rate;  	m_stream_header.dwStart = 0;  	m_stream_header.dwSuggestedBufferSize = m_main_header.dwSuggestedBufferSize;  	m_stream_header.dwQuality = 0;  	m_stream_header.dwSampleSize = 0;  	Util.aviWriteMainHeader (m_main_header' m_stream);  	Util.fwrite ("LIST"' m_stream);  	Util.WriteDWORD (0x874' m_stream);  	Util.fwrite ("strl"' m_stream);  	Util.aviWriteStreamHeader (m_stream_header' m_main_header' m_stream);  	Util.fwrite ("strf"' m_stream);  	BITMAPINFOHEADER bih = new BITMAPINFOHEADER ();  	//(BITMAPINFOHEADER)Marshal.PtrToStructure( Marshal.AllocHGlobal( sizeof( BITMAPINFOHEADER ) )' typeof( BITMAPINFOHEADER ) );  	bih.biSize = (uint)(Marshal.SizeOf (bih));  	bih.biWidth = width;  	bih.biHeight = height;  	bih.biPlanes = 1;  	bih.biBitCount = m_is_transparent ? (short)32 : (short)24;  	bih.biCompression = 0;  	//BI_RGB  	bih.biSizeImage = (uint)(stride * height);  	bih.biXPelsPerMeter = 0;  	bih.biYPelsPerMeter = 0;  	bih.biClrUsed = 0;  	bih.biClrImportant = 0;  	if (m_compressed) {  		m_p_compvar = Marshal.AllocHGlobal (sizeof(COMPVARS));  		m_compvar = (COMPVARS*)m_p_compvar.ToPointer ();  		byte[] buf = new byte[sizeof(COMPVARS)];  		for (int i = 0; i < buf.Length; i++) {  			buf [i] = 0x0;  		}  		Marshal.Copy (buf' 0' m_p_compvar' buf.Length);  		m_compvar->cbSize = sizeof(COMPVARS);  		int ret = VCM.ICCompressorChoose (m_hwnd' 0' IntPtr.Zero' IntPtr.Zero' m_compvar' "Select Video Compressor");  		if (ret == 0) {  			m_opened = false;  			Marshal.FreeHGlobal (m_p_compvar);  			m_stream.Close ();  			return false;  		}  		if (m_compvar->hic != 0) {  			m_p_bitmapinfo_in = Marshal.AllocHGlobal (sizeof(BITMAPINFO));  			m_bitmapinfo_in = (BITMAPINFO*)m_p_bitmapinfo_in.ToPointer ();  			buf = new byte[sizeof(BITMAPINFO)];  			for (int i = 0; i < buf.Length; i++) {  				buf [i] = 0x0;  			}  			Marshal.Copy (buf' 0' m_p_bitmapinfo_in' buf.Length);  			m_bitmapinfo_in->bmiHeader = bih;  			uint dwSize = VCM.ICCompressGetFormatSize (m_compvar->hic' m_bitmapinfo_in);  			#if DEBUG  			                        Console.WriteLine( "m_compvar->hic=" + m_compvar->hic );                         Console.WriteLine( "ICCompressGetFormatSize=" + dwSize ); #endif  			m_p_bitmapinfo_out = Marshal.AllocHGlobal ((int)dwSize);  			m_bitmapinfo_out = (BITMAPINFO*)m_p_bitmapinfo_out.ToPointer ();  			buf = new byte[dwSize];  			for (int i = 0; i < buf.Length; i++) {  				buf [i] = 0x0;  			}  			Marshal.Copy (buf' 0' m_p_bitmapinfo_out' buf.Length);  			VCM.ICCompressGetFormat (m_compvar->hic' m_bitmapinfo_in' m_bitmapinfo_out);  			m_bih_compression = m_bitmapinfo_out->bmiHeader.biCompression;  			#if DEBUG  			                        Console.WriteLine( "AddFrame(Bitmap)" );                         Console.WriteLine( "    biout.biSize=" + m_bitmapinfo_out->bmiHeader.biSize ); #endif  			VCM.ICSeqCompressFrameStart (m_compvar' m_bitmapinfo_in);  			bih = m_bitmapinfo_out->bmiHeader;  			Util.WriteDWORD (bih.biSize' m_stream);  			// infoHeaderのサイズ  			m_bitmapinfo_out->Write (m_stream);  		} else {  			m_compressed = false;  			Util.WriteDWORD (bih.biSize' m_stream);  			// infoHeaderのサイズ  			bih.Write (m_stream);  		}  	} else {  		Util.WriteDWORD (bih.biSize' m_stream);  		// infoHeaderのサイズ  		bih.Write (m_stream);  	}  	m_super_index_position = m_stream.BaseStream.Position;  	Util.fwrite ("indx"' m_stream);  	//fcc  	Util.WriteDWORD (0x7f8' m_stream);  	// cb  	Util.WriteWORD ((byte)0x4' m_stream);  	// wLongsPerEntry  	Util.WriteBYTE (0x0' m_stream);  	// bIndexSubType  	Util.WriteBYTE (Util.AVI_INDEX_OF_INDEXES' m_stream);  	// bIndexType  	Util.WriteDWORD (0x0' m_stream);  	// nEntriesInUse  	Util.fwrite ("00db"' m_stream);  	// dwChunkId  	Util.WriteDWORD (0x0' m_stream);  	Util.WriteDWORD (0x0' m_stream);  	Util.WriteDWORD (0x0' m_stream);  	for (int ii = 1; ii <= 126; ii++) {  		Util.WriteQWORD (0x0' m_stream);  		Util.WriteDWORD (0x0' m_stream);  		Util.WriteDWORD (0x0' m_stream);  	}  	Util.fwrite ("LIST"' m_stream);  	Util.WriteDWORD (0x104' m_stream);  	Util.fwrite ("odml"' m_stream);  	Util.fwrite ("dmlh"' m_stream);  	Util.WriteDWORD (0xf8' m_stream);  	Util.WriteDWORD (0x0' m_stream);  	//ここ後で更新するべき  	for (int ii = 1; ii <= 61; ii++) {  		Util.WriteDWORD (0x0' m_stream);  	}  	Util.fwrite ("JUNK"' m_stream);  	Util.WriteDWORD (0x60c' m_stream);  	Util.WriteDWORD (0' m_stream);  	//"This"が将来登録されたらやばいので  	string msg = "This file was generated by AviWriter@Boare.Lib.Media;VfwBugCompatible=" + VfwBugCompatible;  	const int tlen = 1544;  	int remain = tlen - msg.Length;  	Util.fwrite (msg' m_stream);  	for (int i = 1; i <= remain; i++) {  		m_stream.Write ((byte)0);  	}  	m_junk_length = 0xff4;  	Util.fwrite ("LIST"' m_stream);  	m_movi_position = m_stream.BaseStream.Position;  	Util.WriteDWORD (0' m_stream);  	// call bmpQWordWrite( 0' avi%fp )     !// ******************ココの数字は一番最後に書き換える必要あり2040～2043あとdwTotalFrames（48～51）も  	Util.fwrite ("movi"' m_stream);  	m_next_framedata_position = m_stream.BaseStream.Position;  	m_std_index.SetBaseOffset ((ulong)m_next_framedata_position);  	m_super_index.nEntriesInUse++;  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Open,The following statement contains a magic number: bih.biBitCount = m_is_transparent ? (short)32 : (short)24;  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Open,The following statement contains a magic number: bih.biBitCount = m_is_transparent ? (short)32 : (short)24;  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Open,The following statement contains a magic number: for (int ii = 1; ii <= 126; ii++) {  	Util.WriteQWORD (0x0' m_stream);  	Util.WriteDWORD (0x0' m_stream);  	Util.WriteDWORD (0x0' m_stream);  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Open,The following statement contains a magic number: for (int ii = 1; ii <= 61; ii++) {  	Util.WriteDWORD (0x0' m_stream);  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' m_stream);  		Util.WriteDWORD (m_main_header.dwSuggestedBufferSize' m_stream);  	}  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	m_stream.Seek (0x30' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	m_stream.Seek (0x8c' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//                (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	uint number = 4;  	number += (uint)(m_this_movi_size + frames * 8);  	number += 8 + (uint)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' m_stream);  		Util.WriteDWORD (m_main_header.dwSuggestedBufferSize' m_stream);  	}  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	m_stream.Seek (0x30' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	m_stream.Seek (0x8c' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//                (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	uint number = 4;  	number += (uint)(m_this_movi_size + frames * 8);  	number += 8 + (uint)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' m_stream);  		Util.WriteDWORD (m_main_header.dwSuggestedBufferSize' m_stream);  	}  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	m_stream.Seek (0x30' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	m_stream.Seek (0x8c' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//                (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	uint number = 4;  	number += (uint)(m_this_movi_size + frames * 8);  	number += 8 + (uint)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' m_stream);  		Util.WriteDWORD (m_main_header.dwSuggestedBufferSize' m_stream);  	}  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	m_stream.Seek (0x30' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	m_stream.Seek (0x8c' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//                (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	uint number = 4;  	number += (uint)(m_this_movi_size + frames * 8);  	number += 8 + (uint)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' m_stream);  		Util.WriteDWORD (m_main_header.dwSuggestedBufferSize' m_stream);  	}  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	m_stream.Seek (0x30' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	m_stream.Seek (0x8c' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//                (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	uint number = 4;  	number += (uint)(m_this_movi_size + frames * 8);  	number += 8 + (uint)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' m_stream);  		Util.WriteDWORD (m_main_header.dwSuggestedBufferSize' m_stream);  	}  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	m_stream.Seek (0x30' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	m_stream.Seek (0x8c' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//                (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	uint number = 4;  	number += (uint)(m_this_movi_size + frames * 8);  	number += 8 + (uint)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' m_stream);  		Util.WriteDWORD (m_main_header.dwSuggestedBufferSize' m_stream);  	}  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	m_stream.Seek (0x30' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	m_stream.Seek (0x8c' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//                (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	uint number = 4;  	number += (uint)(m_this_movi_size + frames * 8);  	number += 8 + (uint)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' m_stream);  		Util.WriteDWORD (m_main_header.dwSuggestedBufferSize' m_stream);  	}  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	m_stream.Seek (0x30' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	m_stream.Seek (0x8c' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//                (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	uint number = 4;  	number += (uint)(m_this_movi_size + frames * 8);  	number += 8 + (uint)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' m_stream);  		Util.WriteDWORD (m_main_header.dwSuggestedBufferSize' m_stream);  	}  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	m_stream.Seek (0x30' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	m_stream.Seek (0x8c' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//                (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	uint number = 4;  	number += (uint)(m_this_movi_size + frames * 8);  	number += 8 + (uint)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' m_stream);  		Util.WriteDWORD (m_main_header.dwSuggestedBufferSize' m_stream);  	}  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	m_stream.Seek (0x30' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	m_stream.Seek (0x8c' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//                (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	uint number = 4;  	number += (uint)(m_this_movi_size + frames * 8);  	number += 8 + (uint)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' m_stream);  		Util.WriteDWORD (m_main_header.dwSuggestedBufferSize' m_stream);  	}  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	m_stream.Seek (0x30' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	m_stream.Seek (0x8c' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//                (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	uint number = 4;  	number += (uint)(m_this_movi_size + frames * 8);  	number += 8 + (uint)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' m_stream);  		Util.WriteDWORD (m_main_header.dwSuggestedBufferSize' m_stream);  	}  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	m_stream.Seek (0x30' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	m_stream.Seek (0x8c' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//                (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	uint number = 4;  	number += (uint)(m_this_movi_size + frames * 8);  	number += 8 + (uint)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' m_stream);  		Util.WriteDWORD (m_main_header.dwSuggestedBufferSize' m_stream);  	}  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	m_stream.Seek (0x30' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	m_stream.Seek (0x8c' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//                (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	uint number = 4;  	number += (uint)(m_this_movi_size + frames * 8);  	number += 8 + (uint)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' m_stream);  		Util.WriteDWORD (m_main_header.dwSuggestedBufferSize' m_stream);  	}  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	m_stream.Seek (0x30' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	m_stream.Seek (0x8c' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//                (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	uint number = 4;  	number += (uint)(m_this_movi_size + frames * 8);  	number += 8 + (uint)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' m_stream);  		Util.WriteDWORD (m_main_header.dwSuggestedBufferSize' m_stream);  	}  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	m_stream.Seek (0x30' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	m_stream.Seek (0x8c' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//                (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	uint number = 4;  	number += (uint)(m_this_movi_size + frames * 8);  	number += 8 + (uint)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' m_stream);  		Util.WriteDWORD (m_main_header.dwSuggestedBufferSize' m_stream);  	}  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	m_stream.Seek (0x30' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	m_stream.Seek (0x8c' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//                (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	uint number = 4;  	number += (uint)(m_this_movi_size + frames * 8);  	number += 8 + (uint)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' m_stream);  		Util.WriteDWORD (m_main_header.dwSuggestedBufferSize' m_stream);  	}  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	m_stream.Seek (0x30' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	m_stream.Seek (0x8c' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//                (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	uint number = 4;  	number += (uint)(m_this_movi_size + frames * 8);  	number += 8 + (uint)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' m_stream);  		Util.WriteDWORD (m_main_header.dwSuggestedBufferSize' m_stream);  	}  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	m_stream.Seek (0x30' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	m_stream.Seek (0x8c' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//                (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	uint number = 4;  	number += (uint)(m_this_movi_size + frames * 8);  	number += 8 + (uint)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' m_stream);  		Util.WriteDWORD (m_main_header.dwSuggestedBufferSize' m_stream);  	}  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	m_stream.Seek (0x30' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	m_stream.Seek (0x8c' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//                (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(m_this_movi_size + 8 * frames);  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	uint number = 4;  	number += (uint)(m_this_movi_size + frames * 8);  	number += 8 + (uint)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: step = m_main_header.dwSuggestedBufferSize + 8;  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: Util.WriteDWORD ((uint)(16 * frames)' m_stream);  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: for (i = 1; i <= frames; i++) {  	Util.fwrite ("00db"' m_stream);  	Util.WriteDWORD (Util.AVIF_HASINDEX' m_stream);  	Util.WriteDWORD ((uint)(4 + (i - 1) * step)' m_stream);  	Util.WriteDWORD (m_main_header.dwSuggestedBufferSize' m_stream);  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: Util.WriteDWORD ((uint)(4 + (i - 1) * step)' m_stream);  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: number = 4;  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: number += (uint)(m_this_movi_size + 8 * frames);  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: number += 4 + 4 + (uint)m_std_index.cb;  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: number += 4 + 4 + (uint)m_std_index.cb;  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: number += 4;  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: number += (uint)(m_this_movi_size + 8 * frames);  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: number += 4 + 4 + (uint)m_std_index.cb;  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: number += 4 + 4 + (uint)m_std_index.cb;  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: number += (uint)(4 + 4 + 16 * frames);  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: number += (uint)(4 + 4 + 16 * frames);  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: number += (uint)(4 + 4 + 16 * frames);  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: number += (uint)(m_this_movi_size + frames * 8);  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: number += 8 + (uint)m_std_index.cb;  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: m_stream.Seek (48' SeekOrigin.Begin);  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,UpdateIndex,The following statement contains a magic number: m_stream.Seek (140' SeekOrigin.Begin);  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: if (m_compressed) {  	m_stream_fcc_handler = m_compvar->fccHandler;  	VCM.ICSeqCompressFrameEnd (m_compvar);  	VCM.ICCompressorFree (m_compvar);  	using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  		fs.Seek (0x70' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_stream_fcc_handler >> 24);  			uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  		fs.Seek (0xbc' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_bih_compression >> 24);  			uint b = (uint)(m_bih_compression - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: if (m_compressed) {  	m_stream_fcc_handler = m_compvar->fccHandler;  	VCM.ICSeqCompressFrameEnd (m_compvar);  	VCM.ICCompressorFree (m_compvar);  	using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  		fs.Seek (0x70' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_stream_fcc_handler >> 24);  			uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  		fs.Seek (0xbc' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_bih_compression >> 24);  			uint b = (uint)(m_bih_compression - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: if (m_compressed) {  	m_stream_fcc_handler = m_compvar->fccHandler;  	VCM.ICSeqCompressFrameEnd (m_compvar);  	VCM.ICCompressorFree (m_compvar);  	using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  		fs.Seek (0x70' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_stream_fcc_handler >> 24);  			uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  		fs.Seek (0xbc' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_bih_compression >> 24);  			uint b = (uint)(m_bih_compression - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: if (m_compressed) {  	m_stream_fcc_handler = m_compvar->fccHandler;  	VCM.ICSeqCompressFrameEnd (m_compvar);  	VCM.ICCompressorFree (m_compvar);  	using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  		fs.Seek (0x70' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_stream_fcc_handler >> 24);  			uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  		fs.Seek (0xbc' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_bih_compression >> 24);  			uint b = (uint)(m_bih_compression - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: if (m_compressed) {  	m_stream_fcc_handler = m_compvar->fccHandler;  	VCM.ICSeqCompressFrameEnd (m_compvar);  	VCM.ICCompressorFree (m_compvar);  	using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  		fs.Seek (0x70' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_stream_fcc_handler >> 24);  			uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  		fs.Seek (0xbc' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_bih_compression >> 24);  			uint b = (uint)(m_bih_compression - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: if (m_compressed) {  	m_stream_fcc_handler = m_compvar->fccHandler;  	VCM.ICSeqCompressFrameEnd (m_compvar);  	VCM.ICCompressorFree (m_compvar);  	using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  		fs.Seek (0x70' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_stream_fcc_handler >> 24);  			uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  		fs.Seek (0xbc' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_bih_compression >> 24);  			uint b = (uint)(m_bih_compression - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: if (m_compressed) {  	m_stream_fcc_handler = m_compvar->fccHandler;  	VCM.ICSeqCompressFrameEnd (m_compvar);  	VCM.ICCompressorFree (m_compvar);  	using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  		fs.Seek (0x70' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_stream_fcc_handler >> 24);  			uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  		fs.Seek (0xbc' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_bih_compression >> 24);  			uint b = (uint)(m_bih_compression - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: if (m_compressed) {  	m_stream_fcc_handler = m_compvar->fccHandler;  	VCM.ICSeqCompressFrameEnd (m_compvar);  	VCM.ICCompressorFree (m_compvar);  	using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  		fs.Seek (0x70' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_stream_fcc_handler >> 24);  			uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  		fs.Seek (0xbc' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_bih_compression >> 24);  			uint b = (uint)(m_bih_compression - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: if (m_compressed) {  	m_stream_fcc_handler = m_compvar->fccHandler;  	VCM.ICSeqCompressFrameEnd (m_compvar);  	VCM.ICCompressorFree (m_compvar);  	using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  		fs.Seek (0x70' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_stream_fcc_handler >> 24);  			uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  		fs.Seek (0xbc' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_bih_compression >> 24);  			uint b = (uint)(m_bih_compression - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: if (m_compressed) {  	m_stream_fcc_handler = m_compvar->fccHandler;  	VCM.ICSeqCompressFrameEnd (m_compvar);  	VCM.ICCompressorFree (m_compvar);  	using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  		fs.Seek (0x70' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_stream_fcc_handler >> 24);  			uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  		fs.Seek (0xbc' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_bih_compression >> 24);  			uint b = (uint)(m_bih_compression - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: if (m_compressed) {  	m_stream_fcc_handler = m_compvar->fccHandler;  	VCM.ICSeqCompressFrameEnd (m_compvar);  	VCM.ICCompressorFree (m_compvar);  	using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  		fs.Seek (0x70' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_stream_fcc_handler >> 24);  			uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  		fs.Seek (0xbc' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_bih_compression >> 24);  			uint b = (uint)(m_bih_compression - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: if (m_compressed) {  	m_stream_fcc_handler = m_compvar->fccHandler;  	VCM.ICSeqCompressFrameEnd (m_compvar);  	VCM.ICCompressorFree (m_compvar);  	using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  		fs.Seek (0x70' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_stream_fcc_handler >> 24);  			uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  		fs.Seek (0xbc' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_bih_compression >> 24);  			uint b = (uint)(m_bih_compression - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: if (m_compressed) {  	m_stream_fcc_handler = m_compvar->fccHandler;  	VCM.ICSeqCompressFrameEnd (m_compvar);  	VCM.ICCompressorFree (m_compvar);  	using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  		fs.Seek (0x70' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_stream_fcc_handler >> 24);  			uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  		fs.Seek (0xbc' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_bih_compression >> 24);  			uint b = (uint)(m_bih_compression - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: if (m_compressed) {  	m_stream_fcc_handler = m_compvar->fccHandler;  	VCM.ICSeqCompressFrameEnd (m_compvar);  	VCM.ICCompressorFree (m_compvar);  	using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  		fs.Seek (0x70' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_stream_fcc_handler >> 24);  			uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  		fs.Seek (0xbc' SeekOrigin.Begin);  		{  			byte ch3 = (byte)(m_bih_compression >> 24);  			uint b = (uint)(m_bih_compression - (ch3 << 24));  			byte ch2 = (byte)(b >> 16);  			b = (uint)(b - (ch2 << 16));  			byte ch1 = (byte)(b >> 8);  			byte ch0 = (byte)(b - (ch1 << 8));  			fs.Write (new byte[] {  				ch0'  				ch1'  				ch2'  				ch3  			}' 0' 4);  		}  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  	fs.Seek (0x70' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_stream_fcc_handler >> 24);  		uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  	fs.Seek (0xbc' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_bih_compression >> 24);  		uint b = (uint)(m_bih_compression - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  	fs.Seek (0x70' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_stream_fcc_handler >> 24);  		uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  	fs.Seek (0xbc' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_bih_compression >> 24);  		uint b = (uint)(m_bih_compression - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  	fs.Seek (0x70' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_stream_fcc_handler >> 24);  		uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  	fs.Seek (0xbc' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_bih_compression >> 24);  		uint b = (uint)(m_bih_compression - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  	fs.Seek (0x70' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_stream_fcc_handler >> 24);  		uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  	fs.Seek (0xbc' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_bih_compression >> 24);  		uint b = (uint)(m_bih_compression - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  	fs.Seek (0x70' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_stream_fcc_handler >> 24);  		uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  	fs.Seek (0xbc' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_bih_compression >> 24);  		uint b = (uint)(m_bih_compression - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  	fs.Seek (0x70' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_stream_fcc_handler >> 24);  		uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  	fs.Seek (0xbc' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_bih_compression >> 24);  		uint b = (uint)(m_bih_compression - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  	fs.Seek (0x70' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_stream_fcc_handler >> 24);  		uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  	fs.Seek (0xbc' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_bih_compression >> 24);  		uint b = (uint)(m_bih_compression - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  	fs.Seek (0x70' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_stream_fcc_handler >> 24);  		uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  	fs.Seek (0xbc' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_bih_compression >> 24);  		uint b = (uint)(m_bih_compression - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  	fs.Seek (0x70' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_stream_fcc_handler >> 24);  		uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  	fs.Seek (0xbc' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_bih_compression >> 24);  		uint b = (uint)(m_bih_compression - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  	fs.Seek (0x70' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_stream_fcc_handler >> 24);  		uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  	fs.Seek (0xbc' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_bih_compression >> 24);  		uint b = (uint)(m_bih_compression - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  	fs.Seek (0x70' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_stream_fcc_handler >> 24);  		uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  	fs.Seek (0xbc' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_bih_compression >> 24);  		uint b = (uint)(m_bih_compression - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  	fs.Seek (0x70' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_stream_fcc_handler >> 24);  		uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  	fs.Seek (0xbc' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_bih_compression >> 24);  		uint b = (uint)(m_bih_compression - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  	fs.Seek (0x70' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_stream_fcc_handler >> 24);  		uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  	fs.Seek (0xbc' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_bih_compression >> 24);  		uint b = (uint)(m_bih_compression - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  	fs.Seek (0x70' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_stream_fcc_handler >> 24);  		uint b = (uint)(m_stream_fcc_handler - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  	fs.Seek (0xbc' SeekOrigin.Begin);  	{  		byte ch3 = (byte)(m_bih_compression >> 24);  		uint b = (uint)(m_bih_compression - (ch3 << 24));  		byte ch2 = (byte)(b >> 16);  		b = (uint)(b - (ch2 << 16));  		byte ch1 = (byte)(b >> 8);  		byte ch0 = (byte)(b - (ch1 << 8));  		fs.Write (new byte[] {  			ch0'  			ch1'  			ch2'  			ch3  		}' 0' 4);  	}  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: b = (uint)(b - (ch2 << 16));  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: fs.Write (new byte[] {  	ch0'  	ch1'  	ch2'  	ch3  }' 0' 4);  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: b = (uint)(b - (ch2 << 16));  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,Close,The following statement contains a magic number: fs.Write (new byte[] {  	ch0'  	ch1'  	ch2'  	ch3  }' 0' 4);  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,AddFrame,The following statement contains a magic number: if ((m_current_chunk == 0 && chunk_size > m_split_sreshold) || (m_current_chunk > 0 && chunk_size > _THRESHOLD)) {  	// AVIXリストへの書き込みに移行  	UpdateIndex ();  	m_stream.BaseStream.Seek (m_avix_position' SeekOrigin.Begin);  	Util.fwrite ("RIFF"' m_stream);  	m_riff_position = m_stream.BaseStream.Position;  	Util.WriteDWORD (0' m_stream);  	Util.fwrite ("AVIX"' m_stream);  	long current = m_stream.BaseStream.Position;  	if ((current + 12) % 0x800 != 0) {  		long additional = (current + 20) % 0x800;  		additional = 0x800 - ((current + 20) % 0x800);  		m_junk_length = (int)additional + 20;  		Util.fwrite ("JUNK"' m_stream);  		Util.WriteDWORD ((uint)additional' m_stream);  		for (long ii = 0; ii < additional; ii++) {  			Util.WriteBYTE ((byte)0' m_stream);  		}  	} else {  		m_junk_length = 0;  	}  	m_junk_length = 0;  	Util.fwrite ("LIST"' m_stream);  	m_movi_position = m_stream.BaseStream.Position;  	Util.WriteDWORD (0' m_stream);  	//後で更新するべき  	Util.fwrite ("movi"' m_stream);  	m_next_framedata_position = m_stream.BaseStream.Position;  	m_std_index.aIndex.Clear ();  	m_std_index.SetBaseOffset ((ulong)m_next_framedata_position);  	m_current_chunk++;  	m_super_index.nEntriesInUse++;  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,AddFrame,The following statement contains a magic number: if ((m_current_chunk == 0 && chunk_size > m_split_sreshold) || (m_current_chunk > 0 && chunk_size > _THRESHOLD)) {  	// AVIXリストへの書き込みに移行  	UpdateIndex ();  	m_stream.BaseStream.Seek (m_avix_position' SeekOrigin.Begin);  	Util.fwrite ("RIFF"' m_stream);  	m_riff_position = m_stream.BaseStream.Position;  	Util.WriteDWORD (0' m_stream);  	Util.fwrite ("AVIX"' m_stream);  	long current = m_stream.BaseStream.Position;  	if ((current + 12) % 0x800 != 0) {  		long additional = (current + 20) % 0x800;  		additional = 0x800 - ((current + 20) % 0x800);  		m_junk_length = (int)additional + 20;  		Util.fwrite ("JUNK"' m_stream);  		Util.WriteDWORD ((uint)additional' m_stream);  		for (long ii = 0; ii < additional; ii++) {  			Util.WriteBYTE ((byte)0' m_stream);  		}  	} else {  		m_junk_length = 0;  	}  	m_junk_length = 0;  	Util.fwrite ("LIST"' m_stream);  	m_movi_position = m_stream.BaseStream.Position;  	Util.WriteDWORD (0' m_stream);  	//後で更新するべき  	Util.fwrite ("movi"' m_stream);  	m_next_framedata_position = m_stream.BaseStream.Position;  	m_std_index.aIndex.Clear ();  	m_std_index.SetBaseOffset ((ulong)m_next_framedata_position);  	m_current_chunk++;  	m_super_index.nEntriesInUse++;  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,AddFrame,The following statement contains a magic number: if ((m_current_chunk == 0 && chunk_size > m_split_sreshold) || (m_current_chunk > 0 && chunk_size > _THRESHOLD)) {  	// AVIXリストへの書き込みに移行  	UpdateIndex ();  	m_stream.BaseStream.Seek (m_avix_position' SeekOrigin.Begin);  	Util.fwrite ("RIFF"' m_stream);  	m_riff_position = m_stream.BaseStream.Position;  	Util.WriteDWORD (0' m_stream);  	Util.fwrite ("AVIX"' m_stream);  	long current = m_stream.BaseStream.Position;  	if ((current + 12) % 0x800 != 0) {  		long additional = (current + 20) % 0x800;  		additional = 0x800 - ((current + 20) % 0x800);  		m_junk_length = (int)additional + 20;  		Util.fwrite ("JUNK"' m_stream);  		Util.WriteDWORD ((uint)additional' m_stream);  		for (long ii = 0; ii < additional; ii++) {  			Util.WriteBYTE ((byte)0' m_stream);  		}  	} else {  		m_junk_length = 0;  	}  	m_junk_length = 0;  	Util.fwrite ("LIST"' m_stream);  	m_movi_position = m_stream.BaseStream.Position;  	Util.WriteDWORD (0' m_stream);  	//後で更新するべき  	Util.fwrite ("movi"' m_stream);  	m_next_framedata_position = m_stream.BaseStream.Position;  	m_std_index.aIndex.Clear ();  	m_std_index.SetBaseOffset ((ulong)m_next_framedata_position);  	m_current_chunk++;  	m_super_index.nEntriesInUse++;  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,AddFrame,The following statement contains a magic number: if ((m_current_chunk == 0 && chunk_size > m_split_sreshold) || (m_current_chunk > 0 && chunk_size > _THRESHOLD)) {  	// AVIXリストへの書き込みに移行  	UpdateIndex ();  	m_stream.BaseStream.Seek (m_avix_position' SeekOrigin.Begin);  	Util.fwrite ("RIFF"' m_stream);  	m_riff_position = m_stream.BaseStream.Position;  	Util.WriteDWORD (0' m_stream);  	Util.fwrite ("AVIX"' m_stream);  	long current = m_stream.BaseStream.Position;  	if ((current + 12) % 0x800 != 0) {  		long additional = (current + 20) % 0x800;  		additional = 0x800 - ((current + 20) % 0x800);  		m_junk_length = (int)additional + 20;  		Util.fwrite ("JUNK"' m_stream);  		Util.WriteDWORD ((uint)additional' m_stream);  		for (long ii = 0; ii < additional; ii++) {  			Util.WriteBYTE ((byte)0' m_stream);  		}  	} else {  		m_junk_length = 0;  	}  	m_junk_length = 0;  	Util.fwrite ("LIST"' m_stream);  	m_movi_position = m_stream.BaseStream.Position;  	Util.WriteDWORD (0' m_stream);  	//後で更新するべき  	Util.fwrite ("movi"' m_stream);  	m_next_framedata_position = m_stream.BaseStream.Position;  	m_std_index.aIndex.Clear ();  	m_std_index.SetBaseOffset ((ulong)m_next_framedata_position);  	m_current_chunk++;  	m_super_index.nEntriesInUse++;  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,AddFrame,The following statement contains a magic number: if ((current + 12) % 0x800 != 0) {  	long additional = (current + 20) % 0x800;  	additional = 0x800 - ((current + 20) % 0x800);  	m_junk_length = (int)additional + 20;  	Util.fwrite ("JUNK"' m_stream);  	Util.WriteDWORD ((uint)additional' m_stream);  	for (long ii = 0; ii < additional; ii++) {  		Util.WriteBYTE ((byte)0' m_stream);  	}  } else {  	m_junk_length = 0;  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,AddFrame,The following statement contains a magic number: if ((current + 12) % 0x800 != 0) {  	long additional = (current + 20) % 0x800;  	additional = 0x800 - ((current + 20) % 0x800);  	m_junk_length = (int)additional + 20;  	Util.fwrite ("JUNK"' m_stream);  	Util.WriteDWORD ((uint)additional' m_stream);  	for (long ii = 0; ii < additional; ii++) {  		Util.WriteBYTE ((byte)0' m_stream);  	}  } else {  	m_junk_length = 0;  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,AddFrame,The following statement contains a magic number: if ((current + 12) % 0x800 != 0) {  	long additional = (current + 20) % 0x800;  	additional = 0x800 - ((current + 20) % 0x800);  	m_junk_length = (int)additional + 20;  	Util.fwrite ("JUNK"' m_stream);  	Util.WriteDWORD ((uint)additional' m_stream);  	for (long ii = 0; ii < additional; ii++) {  		Util.WriteBYTE ((byte)0' m_stream);  	}  } else {  	m_junk_length = 0;  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,AddFrame,The following statement contains a magic number: if ((current + 12) % 0x800 != 0) {  	long additional = (current + 20) % 0x800;  	additional = 0x800 - ((current + 20) % 0x800);  	m_junk_length = (int)additional + 20;  	Util.fwrite ("JUNK"' m_stream);  	Util.WriteDWORD ((uint)additional' m_stream);  	for (long ii = 0; ii < additional; ii++) {  		Util.WriteBYTE ((byte)0' m_stream);  	}  } else {  	m_junk_length = 0;  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,AddFrame,The following statement contains a magic number: additional = 0x800 - ((current + 20) % 0x800);  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,AddFrame,The following statement contains a magic number: m_junk_length = (int)additional + 20;  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,AddFrame,The following statement contains a magic number: if (m_compressed) {  	int is_key_frame = 0;  	int size = bmpDat.Stride * bmpDat.Height;  	try {  		IntPtr dat = VCM.ICSeqCompressFrame (m_compvar' 0' bmpDat.Scan0' &is_key_frame' &size);  		if (!dat.Equals (IntPtr.Zero)) {  			byte[] ndat = new byte[size];  			Marshal.Copy (dat' ndat' 0' size);  			m_std_index.AddIndex ((uint)((ulong)m_stream.BaseStream.Position - m_std_index.qwBaseOffset) + 8' (uint)size);  			Util.fwrite ("00db"' m_stream);  			Util.WriteDWORD ((uint)size' m_stream);  			m_stream.Write (ndat' 0' size);  			m_this_movi_size += size;  		}  	} catch {  	}  } else {  	m_std_index.AddIndex ((uint)((ulong)m_stream.BaseStream.Position - m_std_index.qwBaseOffset) + 8' (uint)(lineSize * height));  	Util.fwrite ("00db"' m_stream);  	int address = bmpDat.Scan0.ToInt32 ();  	byte[] bitmapData = new byte[bmpDat.Stride * bmpDat.Height];  	Marshal.Copy (new IntPtr (address)' bitmapData' 0' bitmapData.Length);  	Util.WriteDWORD (m_main_header.dwSuggestedBufferSize' m_stream);  	m_stream.Write (bitmapData);  	m_this_movi_size += bitmapData.Length;  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,AddFrame,The following statement contains a magic number: if (m_compressed) {  	int is_key_frame = 0;  	int size = bmpDat.Stride * bmpDat.Height;  	try {  		IntPtr dat = VCM.ICSeqCompressFrame (m_compvar' 0' bmpDat.Scan0' &is_key_frame' &size);  		if (!dat.Equals (IntPtr.Zero)) {  			byte[] ndat = new byte[size];  			Marshal.Copy (dat' ndat' 0' size);  			m_std_index.AddIndex ((uint)((ulong)m_stream.BaseStream.Position - m_std_index.qwBaseOffset) + 8' (uint)size);  			Util.fwrite ("00db"' m_stream);  			Util.WriteDWORD ((uint)size' m_stream);  			m_stream.Write (ndat' 0' size);  			m_this_movi_size += size;  		}  	} catch {  	}  } else {  	m_std_index.AddIndex ((uint)((ulong)m_stream.BaseStream.Position - m_std_index.qwBaseOffset) + 8' (uint)(lineSize * height));  	Util.fwrite ("00db"' m_stream);  	int address = bmpDat.Scan0.ToInt32 ();  	byte[] bitmapData = new byte[bmpDat.Stride * bmpDat.Height];  	Marshal.Copy (new IntPtr (address)' bitmapData' 0' bitmapData.Length);  	Util.WriteDWORD (m_main_header.dwSuggestedBufferSize' m_stream);  	m_stream.Write (bitmapData);  	m_this_movi_size += bitmapData.Length;  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,AddFrame,The following statement contains a magic number: try {  	IntPtr dat = VCM.ICSeqCompressFrame (m_compvar' 0' bmpDat.Scan0' &is_key_frame' &size);  	if (!dat.Equals (IntPtr.Zero)) {  		byte[] ndat = new byte[size];  		Marshal.Copy (dat' ndat' 0' size);  		m_std_index.AddIndex ((uint)((ulong)m_stream.BaseStream.Position - m_std_index.qwBaseOffset) + 8' (uint)size);  		Util.fwrite ("00db"' m_stream);  		Util.WriteDWORD ((uint)size' m_stream);  		m_stream.Write (ndat' 0' size);  		m_this_movi_size += size;  	}  } catch {  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,AddFrame,The following statement contains a magic number: if (!dat.Equals (IntPtr.Zero)) {  	byte[] ndat = new byte[size];  	Marshal.Copy (dat' ndat' 0' size);  	m_std_index.AddIndex ((uint)((ulong)m_stream.BaseStream.Position - m_std_index.qwBaseOffset) + 8' (uint)size);  	Util.fwrite ("00db"' m_stream);  	Util.WriteDWORD ((uint)size' m_stream);  	m_stream.Write (ndat' 0' size);  	m_this_movi_size += size;  }  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,AddFrame,The following statement contains a magic number: m_std_index.AddIndex ((uint)((ulong)m_stream.BaseStream.Position - m_std_index.qwBaseOffset) + 8' (uint)size);  
Magic Number,cadencii.media,AviWriterVcm,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVcm.cs,AddFrame,The following statement contains a magic number: m_std_index.AddIndex ((uint)((ulong)m_stream.BaseStream.Position - m_std_index.qwBaseOffset) + 8' (uint)(lineSize * height));  
Magic Number,cadencii.media,MediaPlayer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MediaPlayer.cs,ReLoad,The following statement contains a magic number: if (m_filename != "" && !m_loaded && m_load_failed < 10) {  	if (Load (m_filename)) {  		m_loaded = true;  		if (mute) {  			SetVolume (0);  		} else {  			SetVolume (m_volume);  		}  	}  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: try {  	switch (wMsg) {  	case win32.MM_MIM_OPEN: {  		return;  	}  	case win32.MM_MIM_CLOSE: {  		return;  	}  	case win32.MM_MIM_DATA: {  		int receive = dwParam1;  		double now = PortUtil.getCurrentTime ();  		switch (receive & 0xF0) {  		case 0x80:  		case 0x90:  		case 0xa0:  		case 0xb0:  		case 0xe0: {  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					(byte)(receive & 0xff)'  					(byte)((receive & 0xffff) >> 8)'  					(byte)((receive & ((2 << 24) - 1)) >> 16)  				});  				MidiReceived.Invoke (this' msg);  			}  			break;  		}  		case 0xc0:  		case 0xd0: {  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					(byte)(receive & 0xff)'  					(byte)((receive & 0xffff) >> 8)  				});  				MidiReceived.Invoke (this' msg);  			}  			break;  		}  		case 0xf0: {  			if (mReceiveSystemCommonMessage) {  				byte b0 = (byte)(receive & 0xff);  				byte b1 = (byte)((receive >> 8) & 0xff);  				byte b2 = (byte)((receive >> 16) & 0xff);  				byte b3 = (byte)((receive >> 24) & 0xff);  				if (b0 == 0xf1) {  					// MTC quater frame message  					if (MidiReceived != null) {  						javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  							b0'  							b1'  							b2  						});  						MidiReceived.Invoke (this' msg);  					}  				} else if (b0 == 0xf2) {  					// song position pointer  					#if DEBUG  					                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  				}  			}  			if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  				byte b0 = (byte)(receive & 0xff);  				byte b1 = (byte)((receive >> 8) & 0xff);  				byte b2 = (byte)((receive >> 16) & 0xff);  				byte b3 = (byte)((receive >> 24) & 0xff);  				if (b0 == 0xfa) {  					MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  						b0  					}));  				} else if (b0 == 0xfc) {  					MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  						b0  					}));  				}  			}  			break;  		}  		}  		return;  	}  	case win32.MM_MIM_LONGDATA: {  		return;  	}  	case win32.MM_MIM_ERROR: {  		return;  	}  	case win32.MM_MIM_LONGERROR: {  		return;  	}  	}  } catch (Exception ex) {  	debug.push_log ("MidiInDevice.MidiInProc");  	debug.push_log ("    ex=" + ex);  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: try {  	switch (wMsg) {  	case win32.MM_MIM_OPEN: {  		return;  	}  	case win32.MM_MIM_CLOSE: {  		return;  	}  	case win32.MM_MIM_DATA: {  		int receive = dwParam1;  		double now = PortUtil.getCurrentTime ();  		switch (receive & 0xF0) {  		case 0x80:  		case 0x90:  		case 0xa0:  		case 0xb0:  		case 0xe0: {  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					(byte)(receive & 0xff)'  					(byte)((receive & 0xffff) >> 8)'  					(byte)((receive & ((2 << 24) - 1)) >> 16)  				});  				MidiReceived.Invoke (this' msg);  			}  			break;  		}  		case 0xc0:  		case 0xd0: {  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					(byte)(receive & 0xff)'  					(byte)((receive & 0xffff) >> 8)  				});  				MidiReceived.Invoke (this' msg);  			}  			break;  		}  		case 0xf0: {  			if (mReceiveSystemCommonMessage) {  				byte b0 = (byte)(receive & 0xff);  				byte b1 = (byte)((receive >> 8) & 0xff);  				byte b2 = (byte)((receive >> 16) & 0xff);  				byte b3 = (byte)((receive >> 24) & 0xff);  				if (b0 == 0xf1) {  					// MTC quater frame message  					if (MidiReceived != null) {  						javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  							b0'  							b1'  							b2  						});  						MidiReceived.Invoke (this' msg);  					}  				} else if (b0 == 0xf2) {  					// song position pointer  					#if DEBUG  					                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  				}  			}  			if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  				byte b0 = (byte)(receive & 0xff);  				byte b1 = (byte)((receive >> 8) & 0xff);  				byte b2 = (byte)((receive >> 16) & 0xff);  				byte b3 = (byte)((receive >> 24) & 0xff);  				if (b0 == 0xfa) {  					MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  						b0  					}));  				} else if (b0 == 0xfc) {  					MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  						b0  					}));  				}  			}  			break;  		}  		}  		return;  	}  	case win32.MM_MIM_LONGDATA: {  		return;  	}  	case win32.MM_MIM_ERROR: {  		return;  	}  	case win32.MM_MIM_LONGERROR: {  		return;  	}  	}  } catch (Exception ex) {  	debug.push_log ("MidiInDevice.MidiInProc");  	debug.push_log ("    ex=" + ex);  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: try {  	switch (wMsg) {  	case win32.MM_MIM_OPEN: {  		return;  	}  	case win32.MM_MIM_CLOSE: {  		return;  	}  	case win32.MM_MIM_DATA: {  		int receive = dwParam1;  		double now = PortUtil.getCurrentTime ();  		switch (receive & 0xF0) {  		case 0x80:  		case 0x90:  		case 0xa0:  		case 0xb0:  		case 0xe0: {  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					(byte)(receive & 0xff)'  					(byte)((receive & 0xffff) >> 8)'  					(byte)((receive & ((2 << 24) - 1)) >> 16)  				});  				MidiReceived.Invoke (this' msg);  			}  			break;  		}  		case 0xc0:  		case 0xd0: {  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					(byte)(receive & 0xff)'  					(byte)((receive & 0xffff) >> 8)  				});  				MidiReceived.Invoke (this' msg);  			}  			break;  		}  		case 0xf0: {  			if (mReceiveSystemCommonMessage) {  				byte b0 = (byte)(receive & 0xff);  				byte b1 = (byte)((receive >> 8) & 0xff);  				byte b2 = (byte)((receive >> 16) & 0xff);  				byte b3 = (byte)((receive >> 24) & 0xff);  				if (b0 == 0xf1) {  					// MTC quater frame message  					if (MidiReceived != null) {  						javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  							b0'  							b1'  							b2  						});  						MidiReceived.Invoke (this' msg);  					}  				} else if (b0 == 0xf2) {  					// song position pointer  					#if DEBUG  					                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  				}  			}  			if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  				byte b0 = (byte)(receive & 0xff);  				byte b1 = (byte)((receive >> 8) & 0xff);  				byte b2 = (byte)((receive >> 16) & 0xff);  				byte b3 = (byte)((receive >> 24) & 0xff);  				if (b0 == 0xfa) {  					MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  						b0  					}));  				} else if (b0 == 0xfc) {  					MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  						b0  					}));  				}  			}  			break;  		}  		}  		return;  	}  	case win32.MM_MIM_LONGDATA: {  		return;  	}  	case win32.MM_MIM_ERROR: {  		return;  	}  	case win32.MM_MIM_LONGERROR: {  		return;  	}  	}  } catch (Exception ex) {  	debug.push_log ("MidiInDevice.MidiInProc");  	debug.push_log ("    ex=" + ex);  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: try {  	switch (wMsg) {  	case win32.MM_MIM_OPEN: {  		return;  	}  	case win32.MM_MIM_CLOSE: {  		return;  	}  	case win32.MM_MIM_DATA: {  		int receive = dwParam1;  		double now = PortUtil.getCurrentTime ();  		switch (receive & 0xF0) {  		case 0x80:  		case 0x90:  		case 0xa0:  		case 0xb0:  		case 0xe0: {  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					(byte)(receive & 0xff)'  					(byte)((receive & 0xffff) >> 8)'  					(byte)((receive & ((2 << 24) - 1)) >> 16)  				});  				MidiReceived.Invoke (this' msg);  			}  			break;  		}  		case 0xc0:  		case 0xd0: {  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					(byte)(receive & 0xff)'  					(byte)((receive & 0xffff) >> 8)  				});  				MidiReceived.Invoke (this' msg);  			}  			break;  		}  		case 0xf0: {  			if (mReceiveSystemCommonMessage) {  				byte b0 = (byte)(receive & 0xff);  				byte b1 = (byte)((receive >> 8) & 0xff);  				byte b2 = (byte)((receive >> 16) & 0xff);  				byte b3 = (byte)((receive >> 24) & 0xff);  				if (b0 == 0xf1) {  					// MTC quater frame message  					if (MidiReceived != null) {  						javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  							b0'  							b1'  							b2  						});  						MidiReceived.Invoke (this' msg);  					}  				} else if (b0 == 0xf2) {  					// song position pointer  					#if DEBUG  					                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  				}  			}  			if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  				byte b0 = (byte)(receive & 0xff);  				byte b1 = (byte)((receive >> 8) & 0xff);  				byte b2 = (byte)((receive >> 16) & 0xff);  				byte b3 = (byte)((receive >> 24) & 0xff);  				if (b0 == 0xfa) {  					MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  						b0  					}));  				} else if (b0 == 0xfc) {  					MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  						b0  					}));  				}  			}  			break;  		}  		}  		return;  	}  	case win32.MM_MIM_LONGDATA: {  		return;  	}  	case win32.MM_MIM_ERROR: {  		return;  	}  	case win32.MM_MIM_LONGERROR: {  		return;  	}  	}  } catch (Exception ex) {  	debug.push_log ("MidiInDevice.MidiInProc");  	debug.push_log ("    ex=" + ex);  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: try {  	switch (wMsg) {  	case win32.MM_MIM_OPEN: {  		return;  	}  	case win32.MM_MIM_CLOSE: {  		return;  	}  	case win32.MM_MIM_DATA: {  		int receive = dwParam1;  		double now = PortUtil.getCurrentTime ();  		switch (receive & 0xF0) {  		case 0x80:  		case 0x90:  		case 0xa0:  		case 0xb0:  		case 0xe0: {  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					(byte)(receive & 0xff)'  					(byte)((receive & 0xffff) >> 8)'  					(byte)((receive & ((2 << 24) - 1)) >> 16)  				});  				MidiReceived.Invoke (this' msg);  			}  			break;  		}  		case 0xc0:  		case 0xd0: {  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					(byte)(receive & 0xff)'  					(byte)((receive & 0xffff) >> 8)  				});  				MidiReceived.Invoke (this' msg);  			}  			break;  		}  		case 0xf0: {  			if (mReceiveSystemCommonMessage) {  				byte b0 = (byte)(receive & 0xff);  				byte b1 = (byte)((receive >> 8) & 0xff);  				byte b2 = (byte)((receive >> 16) & 0xff);  				byte b3 = (byte)((receive >> 24) & 0xff);  				if (b0 == 0xf1) {  					// MTC quater frame message  					if (MidiReceived != null) {  						javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  							b0'  							b1'  							b2  						});  						MidiReceived.Invoke (this' msg);  					}  				} else if (b0 == 0xf2) {  					// song position pointer  					#if DEBUG  					                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  				}  			}  			if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  				byte b0 = (byte)(receive & 0xff);  				byte b1 = (byte)((receive >> 8) & 0xff);  				byte b2 = (byte)((receive >> 16) & 0xff);  				byte b3 = (byte)((receive >> 24) & 0xff);  				if (b0 == 0xfa) {  					MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  						b0  					}));  				} else if (b0 == 0xfc) {  					MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  						b0  					}));  				}  			}  			break;  		}  		}  		return;  	}  	case win32.MM_MIM_LONGDATA: {  		return;  	}  	case win32.MM_MIM_ERROR: {  		return;  	}  	case win32.MM_MIM_LONGERROR: {  		return;  	}  	}  } catch (Exception ex) {  	debug.push_log ("MidiInDevice.MidiInProc");  	debug.push_log ("    ex=" + ex);  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: try {  	switch (wMsg) {  	case win32.MM_MIM_OPEN: {  		return;  	}  	case win32.MM_MIM_CLOSE: {  		return;  	}  	case win32.MM_MIM_DATA: {  		int receive = dwParam1;  		double now = PortUtil.getCurrentTime ();  		switch (receive & 0xF0) {  		case 0x80:  		case 0x90:  		case 0xa0:  		case 0xb0:  		case 0xe0: {  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					(byte)(receive & 0xff)'  					(byte)((receive & 0xffff) >> 8)'  					(byte)((receive & ((2 << 24) - 1)) >> 16)  				});  				MidiReceived.Invoke (this' msg);  			}  			break;  		}  		case 0xc0:  		case 0xd0: {  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					(byte)(receive & 0xff)'  					(byte)((receive & 0xffff) >> 8)  				});  				MidiReceived.Invoke (this' msg);  			}  			break;  		}  		case 0xf0: {  			if (mReceiveSystemCommonMessage) {  				byte b0 = (byte)(receive & 0xff);  				byte b1 = (byte)((receive >> 8) & 0xff);  				byte b2 = (byte)((receive >> 16) & 0xff);  				byte b3 = (byte)((receive >> 24) & 0xff);  				if (b0 == 0xf1) {  					// MTC quater frame message  					if (MidiReceived != null) {  						javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  							b0'  							b1'  							b2  						});  						MidiReceived.Invoke (this' msg);  					}  				} else if (b0 == 0xf2) {  					// song position pointer  					#if DEBUG  					                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  				}  			}  			if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  				byte b0 = (byte)(receive & 0xff);  				byte b1 = (byte)((receive >> 8) & 0xff);  				byte b2 = (byte)((receive >> 16) & 0xff);  				byte b3 = (byte)((receive >> 24) & 0xff);  				if (b0 == 0xfa) {  					MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  						b0  					}));  				} else if (b0 == 0xfc) {  					MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  						b0  					}));  				}  			}  			break;  		}  		}  		return;  	}  	case win32.MM_MIM_LONGDATA: {  		return;  	}  	case win32.MM_MIM_ERROR: {  		return;  	}  	case win32.MM_MIM_LONGERROR: {  		return;  	}  	}  } catch (Exception ex) {  	debug.push_log ("MidiInDevice.MidiInProc");  	debug.push_log ("    ex=" + ex);  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: try {  	switch (wMsg) {  	case win32.MM_MIM_OPEN: {  		return;  	}  	case win32.MM_MIM_CLOSE: {  		return;  	}  	case win32.MM_MIM_DATA: {  		int receive = dwParam1;  		double now = PortUtil.getCurrentTime ();  		switch (receive & 0xF0) {  		case 0x80:  		case 0x90:  		case 0xa0:  		case 0xb0:  		case 0xe0: {  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					(byte)(receive & 0xff)'  					(byte)((receive & 0xffff) >> 8)'  					(byte)((receive & ((2 << 24) - 1)) >> 16)  				});  				MidiReceived.Invoke (this' msg);  			}  			break;  		}  		case 0xc0:  		case 0xd0: {  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					(byte)(receive & 0xff)'  					(byte)((receive & 0xffff) >> 8)  				});  				MidiReceived.Invoke (this' msg);  			}  			break;  		}  		case 0xf0: {  			if (mReceiveSystemCommonMessage) {  				byte b0 = (byte)(receive & 0xff);  				byte b1 = (byte)((receive >> 8) & 0xff);  				byte b2 = (byte)((receive >> 16) & 0xff);  				byte b3 = (byte)((receive >> 24) & 0xff);  				if (b0 == 0xf1) {  					// MTC quater frame message  					if (MidiReceived != null) {  						javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  							b0'  							b1'  							b2  						});  						MidiReceived.Invoke (this' msg);  					}  				} else if (b0 == 0xf2) {  					// song position pointer  					#if DEBUG  					                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  				}  			}  			if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  				byte b0 = (byte)(receive & 0xff);  				byte b1 = (byte)((receive >> 8) & 0xff);  				byte b2 = (byte)((receive >> 16) & 0xff);  				byte b3 = (byte)((receive >> 24) & 0xff);  				if (b0 == 0xfa) {  					MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  						b0  					}));  				} else if (b0 == 0xfc) {  					MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  						b0  					}));  				}  			}  			break;  		}  		}  		return;  	}  	case win32.MM_MIM_LONGDATA: {  		return;  	}  	case win32.MM_MIM_ERROR: {  		return;  	}  	case win32.MM_MIM_LONGERROR: {  		return;  	}  	}  } catch (Exception ex) {  	debug.push_log ("MidiInDevice.MidiInProc");  	debug.push_log ("    ex=" + ex);  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: try {  	switch (wMsg) {  	case win32.MM_MIM_OPEN: {  		return;  	}  	case win32.MM_MIM_CLOSE: {  		return;  	}  	case win32.MM_MIM_DATA: {  		int receive = dwParam1;  		double now = PortUtil.getCurrentTime ();  		switch (receive & 0xF0) {  		case 0x80:  		case 0x90:  		case 0xa0:  		case 0xb0:  		case 0xe0: {  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					(byte)(receive & 0xff)'  					(byte)((receive & 0xffff) >> 8)'  					(byte)((receive & ((2 << 24) - 1)) >> 16)  				});  				MidiReceived.Invoke (this' msg);  			}  			break;  		}  		case 0xc0:  		case 0xd0: {  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					(byte)(receive & 0xff)'  					(byte)((receive & 0xffff) >> 8)  				});  				MidiReceived.Invoke (this' msg);  			}  			break;  		}  		case 0xf0: {  			if (mReceiveSystemCommonMessage) {  				byte b0 = (byte)(receive & 0xff);  				byte b1 = (byte)((receive >> 8) & 0xff);  				byte b2 = (byte)((receive >> 16) & 0xff);  				byte b3 = (byte)((receive >> 24) & 0xff);  				if (b0 == 0xf1) {  					// MTC quater frame message  					if (MidiReceived != null) {  						javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  							b0'  							b1'  							b2  						});  						MidiReceived.Invoke (this' msg);  					}  				} else if (b0 == 0xf2) {  					// song position pointer  					#if DEBUG  					                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  				}  			}  			if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  				byte b0 = (byte)(receive & 0xff);  				byte b1 = (byte)((receive >> 8) & 0xff);  				byte b2 = (byte)((receive >> 16) & 0xff);  				byte b3 = (byte)((receive >> 24) & 0xff);  				if (b0 == 0xfa) {  					MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  						b0  					}));  				} else if (b0 == 0xfc) {  					MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  						b0  					}));  				}  			}  			break;  		}  		}  		return;  	}  	case win32.MM_MIM_LONGDATA: {  		return;  	}  	case win32.MM_MIM_ERROR: {  		return;  	}  	case win32.MM_MIM_LONGERROR: {  		return;  	}  	}  } catch (Exception ex) {  	debug.push_log ("MidiInDevice.MidiInProc");  	debug.push_log ("    ex=" + ex);  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: try {  	switch (wMsg) {  	case win32.MM_MIM_OPEN: {  		return;  	}  	case win32.MM_MIM_CLOSE: {  		return;  	}  	case win32.MM_MIM_DATA: {  		int receive = dwParam1;  		double now = PortUtil.getCurrentTime ();  		switch (receive & 0xF0) {  		case 0x80:  		case 0x90:  		case 0xa0:  		case 0xb0:  		case 0xe0: {  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					(byte)(receive & 0xff)'  					(byte)((receive & 0xffff) >> 8)'  					(byte)((receive & ((2 << 24) - 1)) >> 16)  				});  				MidiReceived.Invoke (this' msg);  			}  			break;  		}  		case 0xc0:  		case 0xd0: {  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					(byte)(receive & 0xff)'  					(byte)((receive & 0xffff) >> 8)  				});  				MidiReceived.Invoke (this' msg);  			}  			break;  		}  		case 0xf0: {  			if (mReceiveSystemCommonMessage) {  				byte b0 = (byte)(receive & 0xff);  				byte b1 = (byte)((receive >> 8) & 0xff);  				byte b2 = (byte)((receive >> 16) & 0xff);  				byte b3 = (byte)((receive >> 24) & 0xff);  				if (b0 == 0xf1) {  					// MTC quater frame message  					if (MidiReceived != null) {  						javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  							b0'  							b1'  							b2  						});  						MidiReceived.Invoke (this' msg);  					}  				} else if (b0 == 0xf2) {  					// song position pointer  					#if DEBUG  					                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  				}  			}  			if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  				byte b0 = (byte)(receive & 0xff);  				byte b1 = (byte)((receive >> 8) & 0xff);  				byte b2 = (byte)((receive >> 16) & 0xff);  				byte b3 = (byte)((receive >> 24) & 0xff);  				if (b0 == 0xfa) {  					MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  						b0  					}));  				} else if (b0 == 0xfc) {  					MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  						b0  					}));  				}  			}  			break;  		}  		}  		return;  	}  	case win32.MM_MIM_LONGDATA: {  		return;  	}  	case win32.MM_MIM_ERROR: {  		return;  	}  	case win32.MM_MIM_LONGERROR: {  		return;  	}  	}  } catch (Exception ex) {  	debug.push_log ("MidiInDevice.MidiInProc");  	debug.push_log ("    ex=" + ex);  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: try {  	switch (wMsg) {  	case win32.MM_MIM_OPEN: {  		return;  	}  	case win32.MM_MIM_CLOSE: {  		return;  	}  	case win32.MM_MIM_DATA: {  		int receive = dwParam1;  		double now = PortUtil.getCurrentTime ();  		switch (receive & 0xF0) {  		case 0x80:  		case 0x90:  		case 0xa0:  		case 0xb0:  		case 0xe0: {  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					(byte)(receive & 0xff)'  					(byte)((receive & 0xffff) >> 8)'  					(byte)((receive & ((2 << 24) - 1)) >> 16)  				});  				MidiReceived.Invoke (this' msg);  			}  			break;  		}  		case 0xc0:  		case 0xd0: {  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					(byte)(receive & 0xff)'  					(byte)((receive & 0xffff) >> 8)  				});  				MidiReceived.Invoke (this' msg);  			}  			break;  		}  		case 0xf0: {  			if (mReceiveSystemCommonMessage) {  				byte b0 = (byte)(receive & 0xff);  				byte b1 = (byte)((receive >> 8) & 0xff);  				byte b2 = (byte)((receive >> 16) & 0xff);  				byte b3 = (byte)((receive >> 24) & 0xff);  				if (b0 == 0xf1) {  					// MTC quater frame message  					if (MidiReceived != null) {  						javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  							b0'  							b1'  							b2  						});  						MidiReceived.Invoke (this' msg);  					}  				} else if (b0 == 0xf2) {  					// song position pointer  					#if DEBUG  					                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  				}  			}  			if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  				byte b0 = (byte)(receive & 0xff);  				byte b1 = (byte)((receive >> 8) & 0xff);  				byte b2 = (byte)((receive >> 16) & 0xff);  				byte b3 = (byte)((receive >> 24) & 0xff);  				if (b0 == 0xfa) {  					MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  						b0  					}));  				} else if (b0 == 0xfc) {  					MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  						b0  					}));  				}  			}  			break;  		}  		}  		return;  	}  	case win32.MM_MIM_LONGDATA: {  		return;  	}  	case win32.MM_MIM_ERROR: {  		return;  	}  	case win32.MM_MIM_LONGERROR: {  		return;  	}  	}  } catch (Exception ex) {  	debug.push_log ("MidiInDevice.MidiInProc");  	debug.push_log ("    ex=" + ex);  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: try {  	switch (wMsg) {  	case win32.MM_MIM_OPEN: {  		return;  	}  	case win32.MM_MIM_CLOSE: {  		return;  	}  	case win32.MM_MIM_DATA: {  		int receive = dwParam1;  		double now = PortUtil.getCurrentTime ();  		switch (receive & 0xF0) {  		case 0x80:  		case 0x90:  		case 0xa0:  		case 0xb0:  		case 0xe0: {  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					(byte)(receive & 0xff)'  					(byte)((receive & 0xffff) >> 8)'  					(byte)((receive & ((2 << 24) - 1)) >> 16)  				});  				MidiReceived.Invoke (this' msg);  			}  			break;  		}  		case 0xc0:  		case 0xd0: {  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					(byte)(receive & 0xff)'  					(byte)((receive & 0xffff) >> 8)  				});  				MidiReceived.Invoke (this' msg);  			}  			break;  		}  		case 0xf0: {  			if (mReceiveSystemCommonMessage) {  				byte b0 = (byte)(receive & 0xff);  				byte b1 = (byte)((receive >> 8) & 0xff);  				byte b2 = (byte)((receive >> 16) & 0xff);  				byte b3 = (byte)((receive >> 24) & 0xff);  				if (b0 == 0xf1) {  					// MTC quater frame message  					if (MidiReceived != null) {  						javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  							b0'  							b1'  							b2  						});  						MidiReceived.Invoke (this' msg);  					}  				} else if (b0 == 0xf2) {  					// song position pointer  					#if DEBUG  					                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  				}  			}  			if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  				byte b0 = (byte)(receive & 0xff);  				byte b1 = (byte)((receive >> 8) & 0xff);  				byte b2 = (byte)((receive >> 16) & 0xff);  				byte b3 = (byte)((receive >> 24) & 0xff);  				if (b0 == 0xfa) {  					MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  						b0  					}));  				} else if (b0 == 0xfc) {  					MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  						b0  					}));  				}  			}  			break;  		}  		}  		return;  	}  	case win32.MM_MIM_LONGDATA: {  		return;  	}  	case win32.MM_MIM_ERROR: {  		return;  	}  	case win32.MM_MIM_LONGERROR: {  		return;  	}  	}  } catch (Exception ex) {  	debug.push_log ("MidiInDevice.MidiInProc");  	debug.push_log ("    ex=" + ex);  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: switch (wMsg) {  case win32.MM_MIM_OPEN: {  	return;  }  case win32.MM_MIM_CLOSE: {  	return;  }  case win32.MM_MIM_DATA: {  	int receive = dwParam1;  	double now = PortUtil.getCurrentTime ();  	switch (receive & 0xF0) {  	case 0x80:  	case 0x90:  	case 0xa0:  	case 0xb0:  	case 0xe0: {  		if (MidiReceived != null) {  			javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  				(byte)(receive & 0xff)'  				(byte)((receive & 0xffff) >> 8)'  				(byte)((receive & ((2 << 24) - 1)) >> 16)  			});  			MidiReceived.Invoke (this' msg);  		}  		break;  	}  	case 0xc0:  	case 0xd0: {  		if (MidiReceived != null) {  			javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  				(byte)(receive & 0xff)'  				(byte)((receive & 0xffff) >> 8)  			});  			MidiReceived.Invoke (this' msg);  		}  		break;  	}  	case 0xf0: {  		if (mReceiveSystemCommonMessage) {  			byte b0 = (byte)(receive & 0xff);  			byte b1 = (byte)((receive >> 8) & 0xff);  			byte b2 = (byte)((receive >> 16) & 0xff);  			byte b3 = (byte)((receive >> 24) & 0xff);  			if (b0 == 0xf1) {  				// MTC quater frame message  				if (MidiReceived != null) {  					javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  						b0'  						b1'  						b2  					});  					MidiReceived.Invoke (this' msg);  				}  			} else if (b0 == 0xf2) {  				// song position pointer  				#if DEBUG  				                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  			}  		}  		if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  			byte b0 = (byte)(receive & 0xff);  			byte b1 = (byte)((receive >> 8) & 0xff);  			byte b2 = (byte)((receive >> 16) & 0xff);  			byte b3 = (byte)((receive >> 24) & 0xff);  			if (b0 == 0xfa) {  				MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  					b0  				}));  			} else if (b0 == 0xfc) {  				MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  					b0  				}));  			}  		}  		break;  	}  	}  	return;  }  case win32.MM_MIM_LONGDATA: {  	return;  }  case win32.MM_MIM_ERROR: {  	return;  }  case win32.MM_MIM_LONGERROR: {  	return;  }  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: switch (wMsg) {  case win32.MM_MIM_OPEN: {  	return;  }  case win32.MM_MIM_CLOSE: {  	return;  }  case win32.MM_MIM_DATA: {  	int receive = dwParam1;  	double now = PortUtil.getCurrentTime ();  	switch (receive & 0xF0) {  	case 0x80:  	case 0x90:  	case 0xa0:  	case 0xb0:  	case 0xe0: {  		if (MidiReceived != null) {  			javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  				(byte)(receive & 0xff)'  				(byte)((receive & 0xffff) >> 8)'  				(byte)((receive & ((2 << 24) - 1)) >> 16)  			});  			MidiReceived.Invoke (this' msg);  		}  		break;  	}  	case 0xc0:  	case 0xd0: {  		if (MidiReceived != null) {  			javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  				(byte)(receive & 0xff)'  				(byte)((receive & 0xffff) >> 8)  			});  			MidiReceived.Invoke (this' msg);  		}  		break;  	}  	case 0xf0: {  		if (mReceiveSystemCommonMessage) {  			byte b0 = (byte)(receive & 0xff);  			byte b1 = (byte)((receive >> 8) & 0xff);  			byte b2 = (byte)((receive >> 16) & 0xff);  			byte b3 = (byte)((receive >> 24) & 0xff);  			if (b0 == 0xf1) {  				// MTC quater frame message  				if (MidiReceived != null) {  					javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  						b0'  						b1'  						b2  					});  					MidiReceived.Invoke (this' msg);  				}  			} else if (b0 == 0xf2) {  				// song position pointer  				#if DEBUG  				                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  			}  		}  		if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  			byte b0 = (byte)(receive & 0xff);  			byte b1 = (byte)((receive >> 8) & 0xff);  			byte b2 = (byte)((receive >> 16) & 0xff);  			byte b3 = (byte)((receive >> 24) & 0xff);  			if (b0 == 0xfa) {  				MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  					b0  				}));  			} else if (b0 == 0xfc) {  				MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  					b0  				}));  			}  		}  		break;  	}  	}  	return;  }  case win32.MM_MIM_LONGDATA: {  	return;  }  case win32.MM_MIM_ERROR: {  	return;  }  case win32.MM_MIM_LONGERROR: {  	return;  }  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: switch (wMsg) {  case win32.MM_MIM_OPEN: {  	return;  }  case win32.MM_MIM_CLOSE: {  	return;  }  case win32.MM_MIM_DATA: {  	int receive = dwParam1;  	double now = PortUtil.getCurrentTime ();  	switch (receive & 0xF0) {  	case 0x80:  	case 0x90:  	case 0xa0:  	case 0xb0:  	case 0xe0: {  		if (MidiReceived != null) {  			javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  				(byte)(receive & 0xff)'  				(byte)((receive & 0xffff) >> 8)'  				(byte)((receive & ((2 << 24) - 1)) >> 16)  			});  			MidiReceived.Invoke (this' msg);  		}  		break;  	}  	case 0xc0:  	case 0xd0: {  		if (MidiReceived != null) {  			javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  				(byte)(receive & 0xff)'  				(byte)((receive & 0xffff) >> 8)  			});  			MidiReceived.Invoke (this' msg);  		}  		break;  	}  	case 0xf0: {  		if (mReceiveSystemCommonMessage) {  			byte b0 = (byte)(receive & 0xff);  			byte b1 = (byte)((receive >> 8) & 0xff);  			byte b2 = (byte)((receive >> 16) & 0xff);  			byte b3 = (byte)((receive >> 24) & 0xff);  			if (b0 == 0xf1) {  				// MTC quater frame message  				if (MidiReceived != null) {  					javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  						b0'  						b1'  						b2  					});  					MidiReceived.Invoke (this' msg);  				}  			} else if (b0 == 0xf2) {  				// song position pointer  				#if DEBUG  				                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  			}  		}  		if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  			byte b0 = (byte)(receive & 0xff);  			byte b1 = (byte)((receive >> 8) & 0xff);  			byte b2 = (byte)((receive >> 16) & 0xff);  			byte b3 = (byte)((receive >> 24) & 0xff);  			if (b0 == 0xfa) {  				MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  					b0  				}));  			} else if (b0 == 0xfc) {  				MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  					b0  				}));  			}  		}  		break;  	}  	}  	return;  }  case win32.MM_MIM_LONGDATA: {  	return;  }  case win32.MM_MIM_ERROR: {  	return;  }  case win32.MM_MIM_LONGERROR: {  	return;  }  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: switch (wMsg) {  case win32.MM_MIM_OPEN: {  	return;  }  case win32.MM_MIM_CLOSE: {  	return;  }  case win32.MM_MIM_DATA: {  	int receive = dwParam1;  	double now = PortUtil.getCurrentTime ();  	switch (receive & 0xF0) {  	case 0x80:  	case 0x90:  	case 0xa0:  	case 0xb0:  	case 0xe0: {  		if (MidiReceived != null) {  			javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  				(byte)(receive & 0xff)'  				(byte)((receive & 0xffff) >> 8)'  				(byte)((receive & ((2 << 24) - 1)) >> 16)  			});  			MidiReceived.Invoke (this' msg);  		}  		break;  	}  	case 0xc0:  	case 0xd0: {  		if (MidiReceived != null) {  			javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  				(byte)(receive & 0xff)'  				(byte)((receive & 0xffff) >> 8)  			});  			MidiReceived.Invoke (this' msg);  		}  		break;  	}  	case 0xf0: {  		if (mReceiveSystemCommonMessage) {  			byte b0 = (byte)(receive & 0xff);  			byte b1 = (byte)((receive >> 8) & 0xff);  			byte b2 = (byte)((receive >> 16) & 0xff);  			byte b3 = (byte)((receive >> 24) & 0xff);  			if (b0 == 0xf1) {  				// MTC quater frame message  				if (MidiReceived != null) {  					javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  						b0'  						b1'  						b2  					});  					MidiReceived.Invoke (this' msg);  				}  			} else if (b0 == 0xf2) {  				// song position pointer  				#if DEBUG  				                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  			}  		}  		if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  			byte b0 = (byte)(receive & 0xff);  			byte b1 = (byte)((receive >> 8) & 0xff);  			byte b2 = (byte)((receive >> 16) & 0xff);  			byte b3 = (byte)((receive >> 24) & 0xff);  			if (b0 == 0xfa) {  				MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  					b0  				}));  			} else if (b0 == 0xfc) {  				MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  					b0  				}));  			}  		}  		break;  	}  	}  	return;  }  case win32.MM_MIM_LONGDATA: {  	return;  }  case win32.MM_MIM_ERROR: {  	return;  }  case win32.MM_MIM_LONGERROR: {  	return;  }  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: switch (wMsg) {  case win32.MM_MIM_OPEN: {  	return;  }  case win32.MM_MIM_CLOSE: {  	return;  }  case win32.MM_MIM_DATA: {  	int receive = dwParam1;  	double now = PortUtil.getCurrentTime ();  	switch (receive & 0xF0) {  	case 0x80:  	case 0x90:  	case 0xa0:  	case 0xb0:  	case 0xe0: {  		if (MidiReceived != null) {  			javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  				(byte)(receive & 0xff)'  				(byte)((receive & 0xffff) >> 8)'  				(byte)((receive & ((2 << 24) - 1)) >> 16)  			});  			MidiReceived.Invoke (this' msg);  		}  		break;  	}  	case 0xc0:  	case 0xd0: {  		if (MidiReceived != null) {  			javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  				(byte)(receive & 0xff)'  				(byte)((receive & 0xffff) >> 8)  			});  			MidiReceived.Invoke (this' msg);  		}  		break;  	}  	case 0xf0: {  		if (mReceiveSystemCommonMessage) {  			byte b0 = (byte)(receive & 0xff);  			byte b1 = (byte)((receive >> 8) & 0xff);  			byte b2 = (byte)((receive >> 16) & 0xff);  			byte b3 = (byte)((receive >> 24) & 0xff);  			if (b0 == 0xf1) {  				// MTC quater frame message  				if (MidiReceived != null) {  					javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  						b0'  						b1'  						b2  					});  					MidiReceived.Invoke (this' msg);  				}  			} else if (b0 == 0xf2) {  				// song position pointer  				#if DEBUG  				                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  			}  		}  		if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  			byte b0 = (byte)(receive & 0xff);  			byte b1 = (byte)((receive >> 8) & 0xff);  			byte b2 = (byte)((receive >> 16) & 0xff);  			byte b3 = (byte)((receive >> 24) & 0xff);  			if (b0 == 0xfa) {  				MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  					b0  				}));  			} else if (b0 == 0xfc) {  				MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  					b0  				}));  			}  		}  		break;  	}  	}  	return;  }  case win32.MM_MIM_LONGDATA: {  	return;  }  case win32.MM_MIM_ERROR: {  	return;  }  case win32.MM_MIM_LONGERROR: {  	return;  }  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: switch (wMsg) {  case win32.MM_MIM_OPEN: {  	return;  }  case win32.MM_MIM_CLOSE: {  	return;  }  case win32.MM_MIM_DATA: {  	int receive = dwParam1;  	double now = PortUtil.getCurrentTime ();  	switch (receive & 0xF0) {  	case 0x80:  	case 0x90:  	case 0xa0:  	case 0xb0:  	case 0xe0: {  		if (MidiReceived != null) {  			javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  				(byte)(receive & 0xff)'  				(byte)((receive & 0xffff) >> 8)'  				(byte)((receive & ((2 << 24) - 1)) >> 16)  			});  			MidiReceived.Invoke (this' msg);  		}  		break;  	}  	case 0xc0:  	case 0xd0: {  		if (MidiReceived != null) {  			javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  				(byte)(receive & 0xff)'  				(byte)((receive & 0xffff) >> 8)  			});  			MidiReceived.Invoke (this' msg);  		}  		break;  	}  	case 0xf0: {  		if (mReceiveSystemCommonMessage) {  			byte b0 = (byte)(receive & 0xff);  			byte b1 = (byte)((receive >> 8) & 0xff);  			byte b2 = (byte)((receive >> 16) & 0xff);  			byte b3 = (byte)((receive >> 24) & 0xff);  			if (b0 == 0xf1) {  				// MTC quater frame message  				if (MidiReceived != null) {  					javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  						b0'  						b1'  						b2  					});  					MidiReceived.Invoke (this' msg);  				}  			} else if (b0 == 0xf2) {  				// song position pointer  				#if DEBUG  				                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  			}  		}  		if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  			byte b0 = (byte)(receive & 0xff);  			byte b1 = (byte)((receive >> 8) & 0xff);  			byte b2 = (byte)((receive >> 16) & 0xff);  			byte b3 = (byte)((receive >> 24) & 0xff);  			if (b0 == 0xfa) {  				MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  					b0  				}));  			} else if (b0 == 0xfc) {  				MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  					b0  				}));  			}  		}  		break;  	}  	}  	return;  }  case win32.MM_MIM_LONGDATA: {  	return;  }  case win32.MM_MIM_ERROR: {  	return;  }  case win32.MM_MIM_LONGERROR: {  	return;  }  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: switch (wMsg) {  case win32.MM_MIM_OPEN: {  	return;  }  case win32.MM_MIM_CLOSE: {  	return;  }  case win32.MM_MIM_DATA: {  	int receive = dwParam1;  	double now = PortUtil.getCurrentTime ();  	switch (receive & 0xF0) {  	case 0x80:  	case 0x90:  	case 0xa0:  	case 0xb0:  	case 0xe0: {  		if (MidiReceived != null) {  			javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  				(byte)(receive & 0xff)'  				(byte)((receive & 0xffff) >> 8)'  				(byte)((receive & ((2 << 24) - 1)) >> 16)  			});  			MidiReceived.Invoke (this' msg);  		}  		break;  	}  	case 0xc0:  	case 0xd0: {  		if (MidiReceived != null) {  			javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  				(byte)(receive & 0xff)'  				(byte)((receive & 0xffff) >> 8)  			});  			MidiReceived.Invoke (this' msg);  		}  		break;  	}  	case 0xf0: {  		if (mReceiveSystemCommonMessage) {  			byte b0 = (byte)(receive & 0xff);  			byte b1 = (byte)((receive >> 8) & 0xff);  			byte b2 = (byte)((receive >> 16) & 0xff);  			byte b3 = (byte)((receive >> 24) & 0xff);  			if (b0 == 0xf1) {  				// MTC quater frame message  				if (MidiReceived != null) {  					javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  						b0'  						b1'  						b2  					});  					MidiReceived.Invoke (this' msg);  				}  			} else if (b0 == 0xf2) {  				// song position pointer  				#if DEBUG  				                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  			}  		}  		if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  			byte b0 = (byte)(receive & 0xff);  			byte b1 = (byte)((receive >> 8) & 0xff);  			byte b2 = (byte)((receive >> 16) & 0xff);  			byte b3 = (byte)((receive >> 24) & 0xff);  			if (b0 == 0xfa) {  				MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  					b0  				}));  			} else if (b0 == 0xfc) {  				MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  					b0  				}));  			}  		}  		break;  	}  	}  	return;  }  case win32.MM_MIM_LONGDATA: {  	return;  }  case win32.MM_MIM_ERROR: {  	return;  }  case win32.MM_MIM_LONGERROR: {  	return;  }  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: switch (wMsg) {  case win32.MM_MIM_OPEN: {  	return;  }  case win32.MM_MIM_CLOSE: {  	return;  }  case win32.MM_MIM_DATA: {  	int receive = dwParam1;  	double now = PortUtil.getCurrentTime ();  	switch (receive & 0xF0) {  	case 0x80:  	case 0x90:  	case 0xa0:  	case 0xb0:  	case 0xe0: {  		if (MidiReceived != null) {  			javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  				(byte)(receive & 0xff)'  				(byte)((receive & 0xffff) >> 8)'  				(byte)((receive & ((2 << 24) - 1)) >> 16)  			});  			MidiReceived.Invoke (this' msg);  		}  		break;  	}  	case 0xc0:  	case 0xd0: {  		if (MidiReceived != null) {  			javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  				(byte)(receive & 0xff)'  				(byte)((receive & 0xffff) >> 8)  			});  			MidiReceived.Invoke (this' msg);  		}  		break;  	}  	case 0xf0: {  		if (mReceiveSystemCommonMessage) {  			byte b0 = (byte)(receive & 0xff);  			byte b1 = (byte)((receive >> 8) & 0xff);  			byte b2 = (byte)((receive >> 16) & 0xff);  			byte b3 = (byte)((receive >> 24) & 0xff);  			if (b0 == 0xf1) {  				// MTC quater frame message  				if (MidiReceived != null) {  					javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  						b0'  						b1'  						b2  					});  					MidiReceived.Invoke (this' msg);  				}  			} else if (b0 == 0xf2) {  				// song position pointer  				#if DEBUG  				                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  			}  		}  		if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  			byte b0 = (byte)(receive & 0xff);  			byte b1 = (byte)((receive >> 8) & 0xff);  			byte b2 = (byte)((receive >> 16) & 0xff);  			byte b3 = (byte)((receive >> 24) & 0xff);  			if (b0 == 0xfa) {  				MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  					b0  				}));  			} else if (b0 == 0xfc) {  				MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  					b0  				}));  			}  		}  		break;  	}  	}  	return;  }  case win32.MM_MIM_LONGDATA: {  	return;  }  case win32.MM_MIM_ERROR: {  	return;  }  case win32.MM_MIM_LONGERROR: {  	return;  }  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: switch (wMsg) {  case win32.MM_MIM_OPEN: {  	return;  }  case win32.MM_MIM_CLOSE: {  	return;  }  case win32.MM_MIM_DATA: {  	int receive = dwParam1;  	double now = PortUtil.getCurrentTime ();  	switch (receive & 0xF0) {  	case 0x80:  	case 0x90:  	case 0xa0:  	case 0xb0:  	case 0xe0: {  		if (MidiReceived != null) {  			javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  				(byte)(receive & 0xff)'  				(byte)((receive & 0xffff) >> 8)'  				(byte)((receive & ((2 << 24) - 1)) >> 16)  			});  			MidiReceived.Invoke (this' msg);  		}  		break;  	}  	case 0xc0:  	case 0xd0: {  		if (MidiReceived != null) {  			javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  				(byte)(receive & 0xff)'  				(byte)((receive & 0xffff) >> 8)  			});  			MidiReceived.Invoke (this' msg);  		}  		break;  	}  	case 0xf0: {  		if (mReceiveSystemCommonMessage) {  			byte b0 = (byte)(receive & 0xff);  			byte b1 = (byte)((receive >> 8) & 0xff);  			byte b2 = (byte)((receive >> 16) & 0xff);  			byte b3 = (byte)((receive >> 24) & 0xff);  			if (b0 == 0xf1) {  				// MTC quater frame message  				if (MidiReceived != null) {  					javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  						b0'  						b1'  						b2  					});  					MidiReceived.Invoke (this' msg);  				}  			} else if (b0 == 0xf2) {  				// song position pointer  				#if DEBUG  				                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  			}  		}  		if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  			byte b0 = (byte)(receive & 0xff);  			byte b1 = (byte)((receive >> 8) & 0xff);  			byte b2 = (byte)((receive >> 16) & 0xff);  			byte b3 = (byte)((receive >> 24) & 0xff);  			if (b0 == 0xfa) {  				MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  					b0  				}));  			} else if (b0 == 0xfc) {  				MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  					b0  				}));  			}  		}  		break;  	}  	}  	return;  }  case win32.MM_MIM_LONGDATA: {  	return;  }  case win32.MM_MIM_ERROR: {  	return;  }  case win32.MM_MIM_LONGERROR: {  	return;  }  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: switch (wMsg) {  case win32.MM_MIM_OPEN: {  	return;  }  case win32.MM_MIM_CLOSE: {  	return;  }  case win32.MM_MIM_DATA: {  	int receive = dwParam1;  	double now = PortUtil.getCurrentTime ();  	switch (receive & 0xF0) {  	case 0x80:  	case 0x90:  	case 0xa0:  	case 0xb0:  	case 0xe0: {  		if (MidiReceived != null) {  			javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  				(byte)(receive & 0xff)'  				(byte)((receive & 0xffff) >> 8)'  				(byte)((receive & ((2 << 24) - 1)) >> 16)  			});  			MidiReceived.Invoke (this' msg);  		}  		break;  	}  	case 0xc0:  	case 0xd0: {  		if (MidiReceived != null) {  			javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  				(byte)(receive & 0xff)'  				(byte)((receive & 0xffff) >> 8)  			});  			MidiReceived.Invoke (this' msg);  		}  		break;  	}  	case 0xf0: {  		if (mReceiveSystemCommonMessage) {  			byte b0 = (byte)(receive & 0xff);  			byte b1 = (byte)((receive >> 8) & 0xff);  			byte b2 = (byte)((receive >> 16) & 0xff);  			byte b3 = (byte)((receive >> 24) & 0xff);  			if (b0 == 0xf1) {  				// MTC quater frame message  				if (MidiReceived != null) {  					javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  						b0'  						b1'  						b2  					});  					MidiReceived.Invoke (this' msg);  				}  			} else if (b0 == 0xf2) {  				// song position pointer  				#if DEBUG  				                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  			}  		}  		if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  			byte b0 = (byte)(receive & 0xff);  			byte b1 = (byte)((receive >> 8) & 0xff);  			byte b2 = (byte)((receive >> 16) & 0xff);  			byte b3 = (byte)((receive >> 24) & 0xff);  			if (b0 == 0xfa) {  				MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  					b0  				}));  			} else if (b0 == 0xfc) {  				MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  					b0  				}));  			}  		}  		break;  	}  	}  	return;  }  case win32.MM_MIM_LONGDATA: {  	return;  }  case win32.MM_MIM_ERROR: {  	return;  }  case win32.MM_MIM_LONGERROR: {  	return;  }  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: switch (wMsg) {  case win32.MM_MIM_OPEN: {  	return;  }  case win32.MM_MIM_CLOSE: {  	return;  }  case win32.MM_MIM_DATA: {  	int receive = dwParam1;  	double now = PortUtil.getCurrentTime ();  	switch (receive & 0xF0) {  	case 0x80:  	case 0x90:  	case 0xa0:  	case 0xb0:  	case 0xe0: {  		if (MidiReceived != null) {  			javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  				(byte)(receive & 0xff)'  				(byte)((receive & 0xffff) >> 8)'  				(byte)((receive & ((2 << 24) - 1)) >> 16)  			});  			MidiReceived.Invoke (this' msg);  		}  		break;  	}  	case 0xc0:  	case 0xd0: {  		if (MidiReceived != null) {  			javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  				(byte)(receive & 0xff)'  				(byte)((receive & 0xffff) >> 8)  			});  			MidiReceived.Invoke (this' msg);  		}  		break;  	}  	case 0xf0: {  		if (mReceiveSystemCommonMessage) {  			byte b0 = (byte)(receive & 0xff);  			byte b1 = (byte)((receive >> 8) & 0xff);  			byte b2 = (byte)((receive >> 16) & 0xff);  			byte b3 = (byte)((receive >> 24) & 0xff);  			if (b0 == 0xf1) {  				// MTC quater frame message  				if (MidiReceived != null) {  					javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  						b0'  						b1'  						b2  					});  					MidiReceived.Invoke (this' msg);  				}  			} else if (b0 == 0xf2) {  				// song position pointer  				#if DEBUG  				                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  			}  		}  		if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  			byte b0 = (byte)(receive & 0xff);  			byte b1 = (byte)((receive >> 8) & 0xff);  			byte b2 = (byte)((receive >> 16) & 0xff);  			byte b3 = (byte)((receive >> 24) & 0xff);  			if (b0 == 0xfa) {  				MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  					b0  				}));  			} else if (b0 == 0xfc) {  				MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  					b0  				}));  			}  		}  		break;  	}  	}  	return;  }  case win32.MM_MIM_LONGDATA: {  	return;  }  case win32.MM_MIM_ERROR: {  	return;  }  case win32.MM_MIM_LONGERROR: {  	return;  }  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: switch (receive & 0xF0) {  case 0x80:  case 0x90:  case 0xa0:  case 0xb0:  case 0xe0: {  	if (MidiReceived != null) {  		javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  			(byte)(receive & 0xff)'  			(byte)((receive & 0xffff) >> 8)'  			(byte)((receive & ((2 << 24) - 1)) >> 16)  		});  		MidiReceived.Invoke (this' msg);  	}  	break;  }  case 0xc0:  case 0xd0: {  	if (MidiReceived != null) {  		javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  			(byte)(receive & 0xff)'  			(byte)((receive & 0xffff) >> 8)  		});  		MidiReceived.Invoke (this' msg);  	}  	break;  }  case 0xf0: {  	if (mReceiveSystemCommonMessage) {  		byte b0 = (byte)(receive & 0xff);  		byte b1 = (byte)((receive >> 8) & 0xff);  		byte b2 = (byte)((receive >> 16) & 0xff);  		byte b3 = (byte)((receive >> 24) & 0xff);  		if (b0 == 0xf1) {  			// MTC quater frame message  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					b0'  					b1'  					b2  				});  				MidiReceived.Invoke (this' msg);  			}  		} else if (b0 == 0xf2) {  			// song position pointer  			#if DEBUG  			                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  		}  	}  	if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  		byte b0 = (byte)(receive & 0xff);  		byte b1 = (byte)((receive >> 8) & 0xff);  		byte b2 = (byte)((receive >> 16) & 0xff);  		byte b3 = (byte)((receive >> 24) & 0xff);  		if (b0 == 0xfa) {  			MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  				b0  			}));  		} else if (b0 == 0xfc) {  			MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  				b0  			}));  		}  	}  	break;  }  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: switch (receive & 0xF0) {  case 0x80:  case 0x90:  case 0xa0:  case 0xb0:  case 0xe0: {  	if (MidiReceived != null) {  		javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  			(byte)(receive & 0xff)'  			(byte)((receive & 0xffff) >> 8)'  			(byte)((receive & ((2 << 24) - 1)) >> 16)  		});  		MidiReceived.Invoke (this' msg);  	}  	break;  }  case 0xc0:  case 0xd0: {  	if (MidiReceived != null) {  		javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  			(byte)(receive & 0xff)'  			(byte)((receive & 0xffff) >> 8)  		});  		MidiReceived.Invoke (this' msg);  	}  	break;  }  case 0xf0: {  	if (mReceiveSystemCommonMessage) {  		byte b0 = (byte)(receive & 0xff);  		byte b1 = (byte)((receive >> 8) & 0xff);  		byte b2 = (byte)((receive >> 16) & 0xff);  		byte b3 = (byte)((receive >> 24) & 0xff);  		if (b0 == 0xf1) {  			// MTC quater frame message  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					b0'  					b1'  					b2  				});  				MidiReceived.Invoke (this' msg);  			}  		} else if (b0 == 0xf2) {  			// song position pointer  			#if DEBUG  			                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  		}  	}  	if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  		byte b0 = (byte)(receive & 0xff);  		byte b1 = (byte)((receive >> 8) & 0xff);  		byte b2 = (byte)((receive >> 16) & 0xff);  		byte b3 = (byte)((receive >> 24) & 0xff);  		if (b0 == 0xfa) {  			MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  				b0  			}));  		} else if (b0 == 0xfc) {  			MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  				b0  			}));  		}  	}  	break;  }  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: switch (receive & 0xF0) {  case 0x80:  case 0x90:  case 0xa0:  case 0xb0:  case 0xe0: {  	if (MidiReceived != null) {  		javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  			(byte)(receive & 0xff)'  			(byte)((receive & 0xffff) >> 8)'  			(byte)((receive & ((2 << 24) - 1)) >> 16)  		});  		MidiReceived.Invoke (this' msg);  	}  	break;  }  case 0xc0:  case 0xd0: {  	if (MidiReceived != null) {  		javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  			(byte)(receive & 0xff)'  			(byte)((receive & 0xffff) >> 8)  		});  		MidiReceived.Invoke (this' msg);  	}  	break;  }  case 0xf0: {  	if (mReceiveSystemCommonMessage) {  		byte b0 = (byte)(receive & 0xff);  		byte b1 = (byte)((receive >> 8) & 0xff);  		byte b2 = (byte)((receive >> 16) & 0xff);  		byte b3 = (byte)((receive >> 24) & 0xff);  		if (b0 == 0xf1) {  			// MTC quater frame message  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					b0'  					b1'  					b2  				});  				MidiReceived.Invoke (this' msg);  			}  		} else if (b0 == 0xf2) {  			// song position pointer  			#if DEBUG  			                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  		}  	}  	if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  		byte b0 = (byte)(receive & 0xff);  		byte b1 = (byte)((receive >> 8) & 0xff);  		byte b2 = (byte)((receive >> 16) & 0xff);  		byte b3 = (byte)((receive >> 24) & 0xff);  		if (b0 == 0xfa) {  			MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  				b0  			}));  		} else if (b0 == 0xfc) {  			MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  				b0  			}));  		}  	}  	break;  }  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: switch (receive & 0xF0) {  case 0x80:  case 0x90:  case 0xa0:  case 0xb0:  case 0xe0: {  	if (MidiReceived != null) {  		javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  			(byte)(receive & 0xff)'  			(byte)((receive & 0xffff) >> 8)'  			(byte)((receive & ((2 << 24) - 1)) >> 16)  		});  		MidiReceived.Invoke (this' msg);  	}  	break;  }  case 0xc0:  case 0xd0: {  	if (MidiReceived != null) {  		javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  			(byte)(receive & 0xff)'  			(byte)((receive & 0xffff) >> 8)  		});  		MidiReceived.Invoke (this' msg);  	}  	break;  }  case 0xf0: {  	if (mReceiveSystemCommonMessage) {  		byte b0 = (byte)(receive & 0xff);  		byte b1 = (byte)((receive >> 8) & 0xff);  		byte b2 = (byte)((receive >> 16) & 0xff);  		byte b3 = (byte)((receive >> 24) & 0xff);  		if (b0 == 0xf1) {  			// MTC quater frame message  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					b0'  					b1'  					b2  				});  				MidiReceived.Invoke (this' msg);  			}  		} else if (b0 == 0xf2) {  			// song position pointer  			#if DEBUG  			                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  		}  	}  	if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  		byte b0 = (byte)(receive & 0xff);  		byte b1 = (byte)((receive >> 8) & 0xff);  		byte b2 = (byte)((receive >> 16) & 0xff);  		byte b3 = (byte)((receive >> 24) & 0xff);  		if (b0 == 0xfa) {  			MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  				b0  			}));  		} else if (b0 == 0xfc) {  			MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  				b0  			}));  		}  	}  	break;  }  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: switch (receive & 0xF0) {  case 0x80:  case 0x90:  case 0xa0:  case 0xb0:  case 0xe0: {  	if (MidiReceived != null) {  		javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  			(byte)(receive & 0xff)'  			(byte)((receive & 0xffff) >> 8)'  			(byte)((receive & ((2 << 24) - 1)) >> 16)  		});  		MidiReceived.Invoke (this' msg);  	}  	break;  }  case 0xc0:  case 0xd0: {  	if (MidiReceived != null) {  		javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  			(byte)(receive & 0xff)'  			(byte)((receive & 0xffff) >> 8)  		});  		MidiReceived.Invoke (this' msg);  	}  	break;  }  case 0xf0: {  	if (mReceiveSystemCommonMessage) {  		byte b0 = (byte)(receive & 0xff);  		byte b1 = (byte)((receive >> 8) & 0xff);  		byte b2 = (byte)((receive >> 16) & 0xff);  		byte b3 = (byte)((receive >> 24) & 0xff);  		if (b0 == 0xf1) {  			// MTC quater frame message  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					b0'  					b1'  					b2  				});  				MidiReceived.Invoke (this' msg);  			}  		} else if (b0 == 0xf2) {  			// song position pointer  			#if DEBUG  			                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  		}  	}  	if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  		byte b0 = (byte)(receive & 0xff);  		byte b1 = (byte)((receive >> 8) & 0xff);  		byte b2 = (byte)((receive >> 16) & 0xff);  		byte b3 = (byte)((receive >> 24) & 0xff);  		if (b0 == 0xfa) {  			MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  				b0  			}));  		} else if (b0 == 0xfc) {  			MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  				b0  			}));  		}  	}  	break;  }  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: switch (receive & 0xF0) {  case 0x80:  case 0x90:  case 0xa0:  case 0xb0:  case 0xe0: {  	if (MidiReceived != null) {  		javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  			(byte)(receive & 0xff)'  			(byte)((receive & 0xffff) >> 8)'  			(byte)((receive & ((2 << 24) - 1)) >> 16)  		});  		MidiReceived.Invoke (this' msg);  	}  	break;  }  case 0xc0:  case 0xd0: {  	if (MidiReceived != null) {  		javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  			(byte)(receive & 0xff)'  			(byte)((receive & 0xffff) >> 8)  		});  		MidiReceived.Invoke (this' msg);  	}  	break;  }  case 0xf0: {  	if (mReceiveSystemCommonMessage) {  		byte b0 = (byte)(receive & 0xff);  		byte b1 = (byte)((receive >> 8) & 0xff);  		byte b2 = (byte)((receive >> 16) & 0xff);  		byte b3 = (byte)((receive >> 24) & 0xff);  		if (b0 == 0xf1) {  			// MTC quater frame message  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					b0'  					b1'  					b2  				});  				MidiReceived.Invoke (this' msg);  			}  		} else if (b0 == 0xf2) {  			// song position pointer  			#if DEBUG  			                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  		}  	}  	if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  		byte b0 = (byte)(receive & 0xff);  		byte b1 = (byte)((receive >> 8) & 0xff);  		byte b2 = (byte)((receive >> 16) & 0xff);  		byte b3 = (byte)((receive >> 24) & 0xff);  		if (b0 == 0xfa) {  			MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  				b0  			}));  		} else if (b0 == 0xfc) {  			MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  				b0  			}));  		}  	}  	break;  }  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: switch (receive & 0xF0) {  case 0x80:  case 0x90:  case 0xa0:  case 0xb0:  case 0xe0: {  	if (MidiReceived != null) {  		javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  			(byte)(receive & 0xff)'  			(byte)((receive & 0xffff) >> 8)'  			(byte)((receive & ((2 << 24) - 1)) >> 16)  		});  		MidiReceived.Invoke (this' msg);  	}  	break;  }  case 0xc0:  case 0xd0: {  	if (MidiReceived != null) {  		javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  			(byte)(receive & 0xff)'  			(byte)((receive & 0xffff) >> 8)  		});  		MidiReceived.Invoke (this' msg);  	}  	break;  }  case 0xf0: {  	if (mReceiveSystemCommonMessage) {  		byte b0 = (byte)(receive & 0xff);  		byte b1 = (byte)((receive >> 8) & 0xff);  		byte b2 = (byte)((receive >> 16) & 0xff);  		byte b3 = (byte)((receive >> 24) & 0xff);  		if (b0 == 0xf1) {  			// MTC quater frame message  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					b0'  					b1'  					b2  				});  				MidiReceived.Invoke (this' msg);  			}  		} else if (b0 == 0xf2) {  			// song position pointer  			#if DEBUG  			                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  		}  	}  	if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  		byte b0 = (byte)(receive & 0xff);  		byte b1 = (byte)((receive >> 8) & 0xff);  		byte b2 = (byte)((receive >> 16) & 0xff);  		byte b3 = (byte)((receive >> 24) & 0xff);  		if (b0 == 0xfa) {  			MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  				b0  			}));  		} else if (b0 == 0xfc) {  			MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  				b0  			}));  		}  	}  	break;  }  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: switch (receive & 0xF0) {  case 0x80:  case 0x90:  case 0xa0:  case 0xb0:  case 0xe0: {  	if (MidiReceived != null) {  		javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  			(byte)(receive & 0xff)'  			(byte)((receive & 0xffff) >> 8)'  			(byte)((receive & ((2 << 24) - 1)) >> 16)  		});  		MidiReceived.Invoke (this' msg);  	}  	break;  }  case 0xc0:  case 0xd0: {  	if (MidiReceived != null) {  		javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  			(byte)(receive & 0xff)'  			(byte)((receive & 0xffff) >> 8)  		});  		MidiReceived.Invoke (this' msg);  	}  	break;  }  case 0xf0: {  	if (mReceiveSystemCommonMessage) {  		byte b0 = (byte)(receive & 0xff);  		byte b1 = (byte)((receive >> 8) & 0xff);  		byte b2 = (byte)((receive >> 16) & 0xff);  		byte b3 = (byte)((receive >> 24) & 0xff);  		if (b0 == 0xf1) {  			// MTC quater frame message  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					b0'  					b1'  					b2  				});  				MidiReceived.Invoke (this' msg);  			}  		} else if (b0 == 0xf2) {  			// song position pointer  			#if DEBUG  			                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  		}  	}  	if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  		byte b0 = (byte)(receive & 0xff);  		byte b1 = (byte)((receive >> 8) & 0xff);  		byte b2 = (byte)((receive >> 16) & 0xff);  		byte b3 = (byte)((receive >> 24) & 0xff);  		if (b0 == 0xfa) {  			MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  				b0  			}));  		} else if (b0 == 0xfc) {  			MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  				b0  			}));  		}  	}  	break;  }  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: switch (receive & 0xF0) {  case 0x80:  case 0x90:  case 0xa0:  case 0xb0:  case 0xe0: {  	if (MidiReceived != null) {  		javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  			(byte)(receive & 0xff)'  			(byte)((receive & 0xffff) >> 8)'  			(byte)((receive & ((2 << 24) - 1)) >> 16)  		});  		MidiReceived.Invoke (this' msg);  	}  	break;  }  case 0xc0:  case 0xd0: {  	if (MidiReceived != null) {  		javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  			(byte)(receive & 0xff)'  			(byte)((receive & 0xffff) >> 8)  		});  		MidiReceived.Invoke (this' msg);  	}  	break;  }  case 0xf0: {  	if (mReceiveSystemCommonMessage) {  		byte b0 = (byte)(receive & 0xff);  		byte b1 = (byte)((receive >> 8) & 0xff);  		byte b2 = (byte)((receive >> 16) & 0xff);  		byte b3 = (byte)((receive >> 24) & 0xff);  		if (b0 == 0xf1) {  			// MTC quater frame message  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					b0'  					b1'  					b2  				});  				MidiReceived.Invoke (this' msg);  			}  		} else if (b0 == 0xf2) {  			// song position pointer  			#if DEBUG  			                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  		}  	}  	if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  		byte b0 = (byte)(receive & 0xff);  		byte b1 = (byte)((receive >> 8) & 0xff);  		byte b2 = (byte)((receive >> 16) & 0xff);  		byte b3 = (byte)((receive >> 24) & 0xff);  		if (b0 == 0xfa) {  			MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  				b0  			}));  		} else if (b0 == 0xfc) {  			MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  				b0  			}));  		}  	}  	break;  }  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: switch (receive & 0xF0) {  case 0x80:  case 0x90:  case 0xa0:  case 0xb0:  case 0xe0: {  	if (MidiReceived != null) {  		javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  			(byte)(receive & 0xff)'  			(byte)((receive & 0xffff) >> 8)'  			(byte)((receive & ((2 << 24) - 1)) >> 16)  		});  		MidiReceived.Invoke (this' msg);  	}  	break;  }  case 0xc0:  case 0xd0: {  	if (MidiReceived != null) {  		javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  			(byte)(receive & 0xff)'  			(byte)((receive & 0xffff) >> 8)  		});  		MidiReceived.Invoke (this' msg);  	}  	break;  }  case 0xf0: {  	if (mReceiveSystemCommonMessage) {  		byte b0 = (byte)(receive & 0xff);  		byte b1 = (byte)((receive >> 8) & 0xff);  		byte b2 = (byte)((receive >> 16) & 0xff);  		byte b3 = (byte)((receive >> 24) & 0xff);  		if (b0 == 0xf1) {  			// MTC quater frame message  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					b0'  					b1'  					b2  				});  				MidiReceived.Invoke (this' msg);  			}  		} else if (b0 == 0xf2) {  			// song position pointer  			#if DEBUG  			                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  		}  	}  	if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  		byte b0 = (byte)(receive & 0xff);  		byte b1 = (byte)((receive >> 8) & 0xff);  		byte b2 = (byte)((receive >> 16) & 0xff);  		byte b3 = (byte)((receive >> 24) & 0xff);  		if (b0 == 0xfa) {  			MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  				b0  			}));  		} else if (b0 == 0xfc) {  			MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  				b0  			}));  		}  	}  	break;  }  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: switch (receive & 0xF0) {  case 0x80:  case 0x90:  case 0xa0:  case 0xb0:  case 0xe0: {  	if (MidiReceived != null) {  		javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  			(byte)(receive & 0xff)'  			(byte)((receive & 0xffff) >> 8)'  			(byte)((receive & ((2 << 24) - 1)) >> 16)  		});  		MidiReceived.Invoke (this' msg);  	}  	break;  }  case 0xc0:  case 0xd0: {  	if (MidiReceived != null) {  		javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  			(byte)(receive & 0xff)'  			(byte)((receive & 0xffff) >> 8)  		});  		MidiReceived.Invoke (this' msg);  	}  	break;  }  case 0xf0: {  	if (mReceiveSystemCommonMessage) {  		byte b0 = (byte)(receive & 0xff);  		byte b1 = (byte)((receive >> 8) & 0xff);  		byte b2 = (byte)((receive >> 16) & 0xff);  		byte b3 = (byte)((receive >> 24) & 0xff);  		if (b0 == 0xf1) {  			// MTC quater frame message  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					b0'  					b1'  					b2  				});  				MidiReceived.Invoke (this' msg);  			}  		} else if (b0 == 0xf2) {  			// song position pointer  			#if DEBUG  			                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  		}  	}  	if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  		byte b0 = (byte)(receive & 0xff);  		byte b1 = (byte)((receive >> 8) & 0xff);  		byte b2 = (byte)((receive >> 16) & 0xff);  		byte b3 = (byte)((receive >> 24) & 0xff);  		if (b0 == 0xfa) {  			MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  				b0  			}));  		} else if (b0 == 0xfc) {  			MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  				b0  			}));  		}  	}  	break;  }  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: if (MidiReceived != null) {  	javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  		(byte)(receive & 0xff)'  		(byte)((receive & 0xffff) >> 8)'  		(byte)((receive & ((2 << 24) - 1)) >> 16)  	});  	MidiReceived.Invoke (this' msg);  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: if (MidiReceived != null) {  	javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  		(byte)(receive & 0xff)'  		(byte)((receive & 0xffff) >> 8)'  		(byte)((receive & ((2 << 24) - 1)) >> 16)  	});  	MidiReceived.Invoke (this' msg);  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: if (MidiReceived != null) {  	javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  		(byte)(receive & 0xff)'  		(byte)((receive & 0xffff) >> 8)'  		(byte)((receive & ((2 << 24) - 1)) >> 16)  	});  	MidiReceived.Invoke (this' msg);  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: if (MidiReceived != null) {  	javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  		(byte)(receive & 0xff)'  		(byte)((receive & 0xffff) >> 8)'  		(byte)((receive & ((2 << 24) - 1)) >> 16)  	});  	MidiReceived.Invoke (this' msg);  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: if (MidiReceived != null) {  	javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  		(byte)(receive & 0xff)'  		(byte)((receive & 0xffff) >> 8)  	});  	MidiReceived.Invoke (this' msg);  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: if (mReceiveSystemCommonMessage) {  	byte b0 = (byte)(receive & 0xff);  	byte b1 = (byte)((receive >> 8) & 0xff);  	byte b2 = (byte)((receive >> 16) & 0xff);  	byte b3 = (byte)((receive >> 24) & 0xff);  	if (b0 == 0xf1) {  		// MTC quater frame message  		if (MidiReceived != null) {  			javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  				b0'  				b1'  				b2  			});  			MidiReceived.Invoke (this' msg);  		}  	} else if (b0 == 0xf2) {  		// song position pointer  		#if DEBUG  		                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  	}  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: if (mReceiveSystemCommonMessage) {  	byte b0 = (byte)(receive & 0xff);  	byte b1 = (byte)((receive >> 8) & 0xff);  	byte b2 = (byte)((receive >> 16) & 0xff);  	byte b3 = (byte)((receive >> 24) & 0xff);  	if (b0 == 0xf1) {  		// MTC quater frame message  		if (MidiReceived != null) {  			javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  				b0'  				b1'  				b2  			});  			MidiReceived.Invoke (this' msg);  		}  	} else if (b0 == 0xf2) {  		// song position pointer  		#if DEBUG  		                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  	}  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: if (mReceiveSystemCommonMessage) {  	byte b0 = (byte)(receive & 0xff);  	byte b1 = (byte)((receive >> 8) & 0xff);  	byte b2 = (byte)((receive >> 16) & 0xff);  	byte b3 = (byte)((receive >> 24) & 0xff);  	if (b0 == 0xf1) {  		// MTC quater frame message  		if (MidiReceived != null) {  			javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  				b0'  				b1'  				b2  			});  			MidiReceived.Invoke (this' msg);  		}  	} else if (b0 == 0xf2) {  		// song position pointer  		#if DEBUG  		                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  	}  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  	byte b0 = (byte)(receive & 0xff);  	byte b1 = (byte)((receive >> 8) & 0xff);  	byte b2 = (byte)((receive >> 16) & 0xff);  	byte b3 = (byte)((receive >> 24) & 0xff);  	if (b0 == 0xfa) {  		MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  			b0  		}));  	} else if (b0 == 0xfc) {  		MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  			b0  		}));  	}  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  	byte b0 = (byte)(receive & 0xff);  	byte b1 = (byte)((receive >> 8) & 0xff);  	byte b2 = (byte)((receive >> 16) & 0xff);  	byte b3 = (byte)((receive >> 24) & 0xff);  	if (b0 == 0xfa) {  		MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  			b0  		}));  	} else if (b0 == 0xfc) {  		MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  			b0  		}));  	}  }  
Magic Number,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following statement contains a magic number: if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  	byte b0 = (byte)(receive & 0xff);  	byte b1 = (byte)((receive >> 8) & 0xff);  	byte b2 = (byte)((receive >> 16) & 0xff);  	byte b3 = (byte)((receive >> 24) & 0xff);  	if (b0 == 0xfa) {  		MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  			b0  		}));  	} else if (b0 == 0xfc) {  		MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  			b0  		}));  	}  }  
Magic Number,cadencii.media,MidiOutDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiOutDevice.cs,SendData,The following statement contains a magic number: if (0 < data.Length && data.Length <= 4) {  	SendShort (data);  } else {  	SendLong (data);  }  
Magic Number,cadencii.media,MidiOutDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiOutDevice.cs,SendShort,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	message |= ((uint)data [i]) << (i * 8);  }  
Magic Number,cadencii.media,MidiOutDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiOutDevice.cs,SendShort,The following statement contains a magic number: message |= ((uint)data [i]) << (i * 8);  
Magic Number,cadencii.media,RateConvertContext,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RateConvertContext.cs,convert,The following statement contains a magic number: if (context.aRate == context.bRate) {  	if (context.mStatus == Status.NORMAL) {  		context.a = context.aCount;  		context.aStart = context.aCount;  		context.aEnd = context.aCount + length;  	}  	int i = 0;  	int offset = (int)(context.a - context.aStart);  	for (; context.a < context.aEnd; context.a++) {  		context.bufferLeft [i] = left [i + offset];  		context.bufferRight [i] = right [i + offset];  		i++;  		if (i >= BUFLEN) {  			context.length = BUFLEN;  			context.mStatus = Status.CONTINUE;  			return true;  		}  	}  	context.length = i;  	context.aCount += length;  	context.bCount += length;  	context.mStatus = Status.COMPLETE;  	return true;  } else {  	if (context.mStatus == Status.NORMAL) {  		// 送られてきたデータで、aStartからaEndまでのデータを作成できる  		context.aStart = context.aEnd + 1;  		context.aEnd = calculateNextEnd (context' length);  		//  		context.a = context.aStart;  	}  	int i = 0;  	for (; context.a <= context.aEnd; context.a++) {  		double x = context.a * context.invARate;  		long bRequired = (long)(x * context.bRate);  		double x0 = bRequired * context.invBRate;  		double x1 = (bRequired + 1) * context.invBRate;  		int indx0 = (int)(bRequired - context.bCount);  		int indx1 = indx0 + 1;  		// 左チャンネル  		double y0 = 0.0;  		if (0 <= indx0) {  			if (indx0 < length) {  				y0 = left [indx0];  			}  		} else {  			int j = (int)(bRequired - context.bBufBase);  			if (0 <= j && j < context.bBufLeft.Length) {  				y0 = context.bBufLeft [j];  			}  		}  		double y1 = 0.0;  		if (indx1 >= 0) {  			if (indx1 < length) {  				y1 = left [indx1];  			}  		} else {  			int j = (int)(bRequired + 1 - context.bBufBase);  			if (0 <= j && j < context.bBufLeft.Length) {  				y1 = context.bBufLeft [j];  			}  		}  		double s = (y1 - y0) / (x1 - x0);  		double y = y0 + s * (x - x0);  		context.bufferLeft [i] = y;  		// 右チャンネル  		if (indx0 >= 0) {  			if (indx0 < length) {  				y0 = right [indx0];  			}  		} else {  			int j = (int)(bRequired - context.bBufBase);  			if (0 <= j && j < context.bBufRight.Length) {  				y0 = context.bBufRight [j];  			}  		}  		if (indx1 >= 0) {  			if (indx1 < length) {  				y1 = right [indx1];  			}  		} else {  			int j = (int)(bRequired + 1 - context.bBufBase);  			if (0 <= j && j < context.bBufRight.Length) {  				y1 = context.bBufRight [j];  			}  		}  		s = (y1 - y0) / (x1 - x0);  		y = y0 + s * (x - x0);  		context.bufferRight [i] = y;  		// 事後処理  		i++;  		if (i >= BUFLEN) {  			// バッファがいっぱいだったら送信  			context.length = BUFLEN;  			context.mStatus = Status.CONTINUE;  			context.a++;  			return true;  		}  	}  	// 未送信のバッファがあれば送信  	context.length = i;  	// 次回に繰り越すデータを確保  	// 次に送られてくるデータはbCount + length + 1から  	long aNext = (long)((context.bCount + length + 1) * context.invBRate * context.aRate) + 1;  	//long aNext = (long)((context.bCount + length + 1) * context.invBRate * context.aRate);  	if (context.aEnd + 1 < aNext) {  		context.bBufBase = (long)((context.aEnd + 1) * context.invARate * context.bRate) - 2;  		// aEnd + 1番目のデータを作成するのに必要なデータ点のインデクス  		int num = (int)(context.bCount + length - context.bBufBase);  		if (num > 0) {  			if (context.bBufLeft == null) {  				context.bBufLeft = new double[num];  			} else if (context.bBufLeft.Length < num) {  				#if JAVA  				#if JAVA_1_5  				#                            context.bBufLeft = new double[num]; #else  				#                            context.bBufLeft = Arrays.copyOf( context.bBufLeft' num ); #endif  				#else  				Array.Resize (ref context.bBufLeft' num);  				#endif  			}  			if (context.bBufRight == null) {  				context.bBufRight = new double[num];  			} else if (context.bBufRight.Length < num) {  				#if JAVA  				#if JAVA_1_5  				#                            context.bBufRight = new double[num]; #else  				#                            context.bBufRight = Arrays.copyOf( context.bBufRight' num ); #endif  				#else  				Array.Resize (ref context.bBufRight' num);  				#endif  			}  			for (int j = 0; j < num; j++) {  				int indx = (int)(context.bBufBase + j - context.bCount);  				context.bBufLeft [j] = left [indx];  				context.bBufRight [j] = right [indx];  			}  		}  	}  	context.bCount += length;  	context.aCount = context.aEnd;  	context.mStatus = Status.COMPLETE;  	return true;  }  
Magic Number,cadencii.media,RateConvertContext,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RateConvertContext.cs,convert,The following statement contains a magic number: if (context.aEnd + 1 < aNext) {  	context.bBufBase = (long)((context.aEnd + 1) * context.invARate * context.bRate) - 2;  	// aEnd + 1番目のデータを作成するのに必要なデータ点のインデクス  	int num = (int)(context.bCount + length - context.bBufBase);  	if (num > 0) {  		if (context.bBufLeft == null) {  			context.bBufLeft = new double[num];  		} else if (context.bBufLeft.Length < num) {  			#if JAVA  			#if JAVA_1_5  			#                            context.bBufLeft = new double[num]; #else  			#                            context.bBufLeft = Arrays.copyOf( context.bBufLeft' num ); #endif  			#else  			Array.Resize (ref context.bBufLeft' num);  			#endif  		}  		if (context.bBufRight == null) {  			context.bBufRight = new double[num];  		} else if (context.bBufRight.Length < num) {  			#if JAVA  			#if JAVA_1_5  			#                            context.bBufRight = new double[num]; #else  			#                            context.bBufRight = Arrays.copyOf( context.bBufRight' num ); #endif  			#else  			Array.Resize (ref context.bBufRight' num);  			#endif  		}  		for (int j = 0; j < num; j++) {  			int indx = (int)(context.bBufBase + j - context.bCount);  			context.bBufLeft [j] = left [indx];  			context.bBufRight [j] = right [indx];  		}  	}  }  
Magic Number,cadencii.media,RateConvertContext,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RateConvertContext.cs,convert,The following statement contains a magic number: context.bBufBase = (long)((context.aEnd + 1) * context.invARate * context.bRate) - 2;  
Magic Number,cadencii.media,AVISTDINDEX,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,AVISTDINDEX,The following statement contains a magic number: wLongsPerEntry = 2;  
Magic Number,cadencii.media,AVISUPERINDEX,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,AVISUPERINDEX,The following statement contains a magic number: this.wLongsPerEntry = 4;  
Magic Number,cadencii.media,AVISUPERINDEX,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,AVISUPERINDEX,The following statement contains a magic number: for (int i = 0; i < 126; i++) {  	this.aIndex.Add (entry);  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,Open,The following statement contains a magic number: this.m_main_header.dwMicroSecPerFrame = (uint)(1.0e6 / fps);  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,Open,The following statement contains a magic number: this.m_main_header.dwFlags = 2064;  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = this.m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' this.m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' this.m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' this.m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' this.m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' this.m_stream);  		Util.WriteDWORD (this.m_main_header.dwSuggestedBufferSize' this.m_stream);  	}  	//    end do  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	//number += 4 + 4 + 16 * frames;//idx1のサイズ  	//avi_writeIsolate( this.fp' number' 2040 );  // LIST****movi の ****部分  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	int number = 4;  	number += (int)(frames * (m_linesize * m_main_header.dwHeight + 8));  	number += 8 + (int)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = this.m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' this.m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' this.m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' this.m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' this.m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' this.m_stream);  		Util.WriteDWORD (this.m_main_header.dwSuggestedBufferSize' this.m_stream);  	}  	//    end do  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	//number += 4 + 4 + 16 * frames;//idx1のサイズ  	//avi_writeIsolate( this.fp' number' 2040 );  // LIST****movi の ****部分  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	int number = 4;  	number += (int)(frames * (m_linesize * m_main_header.dwHeight + 8));  	number += 8 + (int)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = this.m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' this.m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' this.m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' this.m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' this.m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' this.m_stream);  		Util.WriteDWORD (this.m_main_header.dwSuggestedBufferSize' this.m_stream);  	}  	//    end do  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	//number += 4 + 4 + 16 * frames;//idx1のサイズ  	//avi_writeIsolate( this.fp' number' 2040 );  // LIST****movi の ****部分  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	int number = 4;  	number += (int)(frames * (m_linesize * m_main_header.dwHeight + 8));  	number += 8 + (int)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = this.m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' this.m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' this.m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' this.m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' this.m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' this.m_stream);  		Util.WriteDWORD (this.m_main_header.dwSuggestedBufferSize' this.m_stream);  	}  	//    end do  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	//number += 4 + 4 + 16 * frames;//idx1のサイズ  	//avi_writeIsolate( this.fp' number' 2040 );  // LIST****movi の ****部分  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	int number = 4;  	number += (int)(frames * (m_linesize * m_main_header.dwHeight + 8));  	number += 8 + (int)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = this.m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' this.m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' this.m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' this.m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' this.m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' this.m_stream);  		Util.WriteDWORD (this.m_main_header.dwSuggestedBufferSize' this.m_stream);  	}  	//    end do  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	//number += 4 + 4 + 16 * frames;//idx1のサイズ  	//avi_writeIsolate( this.fp' number' 2040 );  // LIST****movi の ****部分  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	int number = 4;  	number += (int)(frames * (m_linesize * m_main_header.dwHeight + 8));  	number += 8 + (int)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = this.m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' this.m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' this.m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' this.m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' this.m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' this.m_stream);  		Util.WriteDWORD (this.m_main_header.dwSuggestedBufferSize' this.m_stream);  	}  	//    end do  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	//number += 4 + 4 + 16 * frames;//idx1のサイズ  	//avi_writeIsolate( this.fp' number' 2040 );  // LIST****movi の ****部分  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	int number = 4;  	number += (int)(frames * (m_linesize * m_main_header.dwHeight + 8));  	number += 8 + (int)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = this.m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' this.m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' this.m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' this.m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' this.m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' this.m_stream);  		Util.WriteDWORD (this.m_main_header.dwSuggestedBufferSize' this.m_stream);  	}  	//    end do  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	//number += 4 + 4 + 16 * frames;//idx1のサイズ  	//avi_writeIsolate( this.fp' number' 2040 );  // LIST****movi の ****部分  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	int number = 4;  	number += (int)(frames * (m_linesize * m_main_header.dwHeight + 8));  	number += 8 + (int)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = this.m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' this.m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' this.m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' this.m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' this.m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' this.m_stream);  		Util.WriteDWORD (this.m_main_header.dwSuggestedBufferSize' this.m_stream);  	}  	//    end do  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	//number += 4 + 4 + 16 * frames;//idx1のサイズ  	//avi_writeIsolate( this.fp' number' 2040 );  // LIST****movi の ****部分  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	int number = 4;  	number += (int)(frames * (m_linesize * m_main_header.dwHeight + 8));  	number += 8 + (int)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = this.m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' this.m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' this.m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' this.m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' this.m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' this.m_stream);  		Util.WriteDWORD (this.m_main_header.dwSuggestedBufferSize' this.m_stream);  	}  	//    end do  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	//number += 4 + 4 + 16 * frames;//idx1のサイズ  	//avi_writeIsolate( this.fp' number' 2040 );  // LIST****movi の ****部分  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	int number = 4;  	number += (int)(frames * (m_linesize * m_main_header.dwHeight + 8));  	number += 8 + (int)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = this.m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' this.m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' this.m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' this.m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' this.m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' this.m_stream);  		Util.WriteDWORD (this.m_main_header.dwSuggestedBufferSize' this.m_stream);  	}  	//    end do  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	//number += 4 + 4 + 16 * frames;//idx1のサイズ  	//avi_writeIsolate( this.fp' number' 2040 );  // LIST****movi の ****部分  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	int number = 4;  	number += (int)(frames * (m_linesize * m_main_header.dwHeight + 8));  	number += 8 + (int)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = this.m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' this.m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' this.m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' this.m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' this.m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' this.m_stream);  		Util.WriteDWORD (this.m_main_header.dwSuggestedBufferSize' this.m_stream);  	}  	//    end do  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	//number += 4 + 4 + 16 * frames;//idx1のサイズ  	//avi_writeIsolate( this.fp' number' 2040 );  // LIST****movi の ****部分  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	int number = 4;  	number += (int)(frames * (m_linesize * m_main_header.dwHeight + 8));  	number += 8 + (int)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = this.m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' this.m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' this.m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' this.m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' this.m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' this.m_stream);  		Util.WriteDWORD (this.m_main_header.dwSuggestedBufferSize' this.m_stream);  	}  	//    end do  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	//number += 4 + 4 + 16 * frames;//idx1のサイズ  	//avi_writeIsolate( this.fp' number' 2040 );  // LIST****movi の ****部分  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	int number = 4;  	number += (int)(frames * (m_linesize * m_main_header.dwHeight + 8));  	number += 8 + (int)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = this.m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' this.m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' this.m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' this.m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' this.m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' this.m_stream);  		Util.WriteDWORD (this.m_main_header.dwSuggestedBufferSize' this.m_stream);  	}  	//    end do  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	//number += 4 + 4 + 16 * frames;//idx1のサイズ  	//avi_writeIsolate( this.fp' number' 2040 );  // LIST****movi の ****部分  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	int number = 4;  	number += (int)(frames * (m_linesize * m_main_header.dwHeight + 8));  	number += 8 + (int)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = this.m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' this.m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' this.m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' this.m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' this.m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' this.m_stream);  		Util.WriteDWORD (this.m_main_header.dwSuggestedBufferSize' this.m_stream);  	}  	//    end do  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	//number += 4 + 4 + 16 * frames;//idx1のサイズ  	//avi_writeIsolate( this.fp' number' 2040 );  // LIST****movi の ****部分  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	int number = 4;  	number += (int)(frames * (m_linesize * m_main_header.dwHeight + 8));  	number += 8 + (int)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = this.m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' this.m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' this.m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' this.m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' this.m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' this.m_stream);  		Util.WriteDWORD (this.m_main_header.dwSuggestedBufferSize' this.m_stream);  	}  	//    end do  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	//number += 4 + 4 + 16 * frames;//idx1のサイズ  	//avi_writeIsolate( this.fp' number' 2040 );  // LIST****movi の ****部分  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	int number = 4;  	number += (int)(frames * (m_linesize * m_main_header.dwHeight + 8));  	number += 8 + (int)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = this.m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' this.m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' this.m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' this.m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' this.m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' this.m_stream);  		Util.WriteDWORD (this.m_main_header.dwSuggestedBufferSize' this.m_stream);  	}  	//    end do  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	//number += 4 + 4 + 16 * frames;//idx1のサイズ  	//avi_writeIsolate( this.fp' number' 2040 );  // LIST****movi の ****部分  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	int number = 4;  	number += (int)(frames * (m_linesize * m_main_header.dwHeight + 8));  	number += 8 + (int)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = this.m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' this.m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' this.m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' this.m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' this.m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' this.m_stream);  		Util.WriteDWORD (this.m_main_header.dwSuggestedBufferSize' this.m_stream);  	}  	//    end do  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	//number += 4 + 4 + 16 * frames;//idx1のサイズ  	//avi_writeIsolate( this.fp' number' 2040 );  // LIST****movi の ****部分  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	int number = 4;  	number += (int)(frames * (m_linesize * m_main_header.dwHeight + 8));  	number += 8 + (int)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = this.m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' this.m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' this.m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' this.m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' this.m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' this.m_stream);  		Util.WriteDWORD (this.m_main_header.dwSuggestedBufferSize' this.m_stream);  	}  	//    end do  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	//number += 4 + 4 + 16 * frames;//idx1のサイズ  	//avi_writeIsolate( this.fp' number' 2040 );  // LIST****movi の ****部分  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	int number = 4;  	number += (int)(frames * (m_linesize * m_main_header.dwHeight + 8));  	number += 8 + (int)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = this.m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' this.m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' this.m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' this.m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' this.m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' this.m_stream);  		Util.WriteDWORD (this.m_main_header.dwSuggestedBufferSize' this.m_stream);  	}  	//    end do  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	//number += 4 + 4 + 16 * frames;//idx1のサイズ  	//avi_writeIsolate( this.fp' number' 2040 );  // LIST****movi の ****部分  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	int number = 4;  	number += (int)(frames * (m_linesize * m_main_header.dwHeight + 8));  	number += 8 + (int)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = this.m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' this.m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' this.m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' this.m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' this.m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' this.m_stream);  		Util.WriteDWORD (this.m_main_header.dwSuggestedBufferSize' this.m_stream);  	}  	//    end do  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	//number += 4 + 4 + 16 * frames;//idx1のサイズ  	//avi_writeIsolate( this.fp' number' 2040 );  // LIST****movi の ****部分  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	int number = 4;  	number += (int)(frames * (m_linesize * m_main_header.dwHeight + 8));  	number += 8 + (int)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: if (m_current_chunk == 0) {  	uint i' step' number;  	step = this.m_main_header.dwSuggestedBufferSize + 8;  	Util.fwrite ("idx1"' this.m_stream);  	Util.WriteDWORD ((uint)(16 * frames)' this.m_stream);  	for (i = 1; i <= frames; i++) {  		Util.fwrite ("00db"' this.m_stream);  		Util.WriteDWORD (Util.AVIF_HASINDEX' this.m_stream);  		Util.WriteDWORD ((uint)(4 + (i - 1) * step)' this.m_stream);  		Util.WriteDWORD (this.m_main_header.dwSuggestedBufferSize' this.m_stream);  	}  	//    end do  	m_avix_position = m_stream.BaseStream.Position;  	number = (uint)frames;  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//odml dlmhのdwTotalFrames  	m_stream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)frames' m_stream);  	// LIST****moviの****の数値を計算  	number = 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//フレーム数*(フレームのサイズ+"00db"+00dbチャンクのサイズ)  	number += 4 + 4 + (uint)m_std_index.cb;  	//ix00のサイズ  	//number += 4 + 4 + 16 * frames;//idx1のサイズ  	//avi_writeIsolate( this.fp' number' 2040 );  // LIST****movi の ****部分  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	//number = 4096 + (this.mainHeader.dwSuggestedBufferSize + 24) * this.noOfFrame;  	//avi_writeIsolate( this.fp' number' 4 );     // RIFF****AVI  の ****部分  	number = (uint)m_junk_length/* 0xff4*/;  	//JUNKの終わりまでのサイズ。これは固定  	number += 4;  	//"movi"  	number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  	//00db...の合計サイズ  	number += 4 + 4 + (uint)m_std_index.cb;  	number += (uint)(4 + 4 + 16 * frames);  	//idx1のサイズ  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD (number' m_stream);  	UpdateIndexOfIndex ();  } else {  	// LIST****moviの****を更新  	int number = 4;  	number += (int)(frames * (m_linesize * m_main_header.dwHeight + 8));  	number += 8 + (int)m_std_index.cb;  	m_stream.BaseStream.Seek (m_movi_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)number' m_stream);  	// odml dlmhのdwTotalFrames  	uint frames2 = 0;  	for (int j = 0; j <= m_current_chunk; j++) {  		frames2 += (uint)m_super_index.aIndex [j].dwDuration;  	}  	m_stream.BaseStream.Seek (0x8e8' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 48 );    // AVIMainHeader.dwTotalFrames  	m_stream.Seek (48' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//avi_writeIsolate( this.fp' number' 140 );   // AVIStreamHeader.dwLength  	m_stream.Seek (140' SeekOrigin.Begin);  	Util.WriteDWORD (frames2' m_stream);  	//RIFF****AVIXの****を更新  	long num2 = m_junk_length + number;  	m_stream.BaseStream.Seek (m_riff_position' SeekOrigin.Begin);  	Util.WriteDWORD ((uint)num2' m_stream);  	UpdateIndexOfIndex ();  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: step = this.m_main_header.dwSuggestedBufferSize + 8;  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: Util.WriteDWORD ((uint)(16 * frames)' this.m_stream);  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: for (i = 1; i <= frames; i++) {  	Util.fwrite ("00db"' this.m_stream);  	Util.WriteDWORD (Util.AVIF_HASINDEX' this.m_stream);  	Util.WriteDWORD ((uint)(4 + (i - 1) * step)' this.m_stream);  	Util.WriteDWORD (this.m_main_header.dwSuggestedBufferSize' this.m_stream);  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: Util.WriteDWORD ((uint)(4 + (i - 1) * step)' this.m_stream);  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: m_stream.Seek (48' SeekOrigin.Begin);  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: m_stream.Seek (140' SeekOrigin.Begin);  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: number = 4;  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: number += 4 + 4 + (uint)m_std_index.cb;  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: number += 4 + 4 + (uint)m_std_index.cb;  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: number += 4;  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: number += (uint)(frames * (m_linesize * m_main_header.dwHeight + 8));  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: number += 4 + 4 + (uint)m_std_index.cb;  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: number += 4 + 4 + (uint)m_std_index.cb;  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: number += (uint)(4 + 4 + 16 * frames);  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: number += (uint)(4 + 4 + 16 * frames);  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: number += (uint)(4 + 4 + 16 * frames);  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: number += (int)(frames * (m_linesize * m_main_header.dwHeight + 8));  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: number += 8 + (int)m_std_index.cb;  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: m_stream.Seek (48' SeekOrigin.Begin);  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,UpdateIndex,The following statement contains a magic number: m_stream.Seek (140' SeekOrigin.Begin);  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,AddFrame,The following statement contains a magic number: if (m_is_first) {  	//then  	m_is_first = false;  	this.m_main_header.dwWidth = (uint)m_width;  	this.m_main_header.dwHeight = (uint)m_height;  	this.m_main_header.dwMaxBytesPerSec = (uint)(bmpDat.Stride * bmpDat.Height * this.frameRate);  	// bmp%infoHeader%SizeImage * avi%frameRate  	this.m_main_header.dwStreams = 1;  	this.m_main_header.dwSuggestedBufferSize = (uint)(bmpDat.Stride * bmpDat.Height);  	// bmp.infoHeader%SizeImage  	m_linesize = bmpDat.Stride;  	this.m_stream_header.fccType = Util.mmioFOURCC ("vids");  	this.m_stream_header.fccHandler = 0;  	this.m_stream_header.dwFlags = 0;  	this.m_stream_header.dwReserved1 = 0;  	this.m_stream_header.dwInitialFrames = 0;  	this.m_stream_header.dwScale = m_scale;  	this.m_stream_header.dwRate = m_rate;  	this.m_stream_header.dwStart = 0;  	this.m_stream_header.dwSuggestedBufferSize = this.m_main_header.dwSuggestedBufferSize;  	this.m_stream_header.dwQuality = 0;  	this.m_stream_header.dwSampleSize = 0;  	Util.aviWriteMainHeader (m_main_header' m_stream);  	Util.fwrite ("LIST"' this.m_stream);  	// i = fwrite( 'LIST'' 1' 4' avi%fp )  	Util.WriteDWORD (0x874' this.m_stream);  	// call bmpQWordWrite( 130' avi%fp )  	Util.fwrite ("strl"' this.m_stream);  	// i = fwrite( 'strl'' 1' 4' avi%fp )  	Util.aviWriteStreamHeader (m_stream_header' m_main_header' m_stream);  	// avi )  	Util.fwrite ("strf"' this.m_stream);  	// i = fwrite( 'strf'' 1' 4' avi%fp )  	Util.WriteDWORD (0x28' this.m_stream);  	//call bmpQWordWrite( 40' avi%fp )    !// infoHeaderのサイズ  	BITMAPINFOHEADER bih = new BITMAPINFOHEADER ();  	bih.biSize = (uint)(Marshal.SizeOf (bih));  	bih.biWidth = bmpDat.Width;  	bih.biHeight = bmpDat.Height;  	bih.biPlanes = 1;  	bih.biBitCount = 24;  	bih.biCompression = 0;  	//BI_RGB  	bih.biSizeImage = (uint)(bmpDat.Stride * bmpDat.Height);  	bih.biXPelsPerMeter = 0;  	bih.biYPelsPerMeter = 0;  	bih.biClrUsed = 0;  	bih.biClrImportant = 0;  	bih.Write (m_stream);  	/*fwrite( "strn"' this.fp );                 WriteDWORD( 6' this.fp );                 fwrite( "VIDEO"' this.fp );                 WriteBYTE( 0' this.fp );*/Util.fwrite ("indx"' this.m_stream);  	//fcc  	Util.WriteDWORD (0x7f8' this.m_stream);  	// cb  	Util.WriteWORD ((byte)0x4' this.m_stream);  	// wLongsPerEntry  	Util.WriteBYTE (0x0' this.m_stream);  	// bIndexSubType  	Util.WriteBYTE (Util.AVI_INDEX_OF_INDEXES' this.m_stream);  	// bIndexType  	Util.WriteDWORD (0x0' this.m_stream);  	// nEntriesInUse  	Util.fwrite ("00db"' this.m_stream);  	// dwChunkId  	Util.WriteDWORD (0x0' this.m_stream);  	Util.WriteDWORD (0x0' this.m_stream);  	Util.WriteDWORD (0x0' this.m_stream);  	for (int ii = 1; ii <= 126; ii++) {  		Util.WriteQWORD (0x0' this.m_stream);  		Util.WriteDWORD (0x0' this.m_stream);  		Util.WriteDWORD (0x0' this.m_stream);  	}  	Util.fwrite ("LIST"' this.m_stream);  	Util.WriteDWORD (0x104' m_stream);  	Util.fwrite ("odml"' this.m_stream);  	Util.fwrite ("dmlh"' m_stream);  	Util.WriteDWORD (0xf8' m_stream);  	Util.WriteDWORD (0x0' m_stream);  	//ここ後で更新するべき  	for (int ii = 1; ii <= 61; ii++) {  		Util.WriteDWORD (0x0' m_stream);  	}  	Util.fwrite ("JUNK"' this.m_stream);  	// i = fwrite( 'JUNK'' 1' 4' avi%fp )  	Util.WriteDWORD (0x60c' m_stream);  	Util.WriteDWORD (0' m_stream);  	//"This"が将来登録されたらやばいので  	Util.fwrite ("This file was generated by RawAvi@LipSync"' this.m_stream);  	//WriteDWORD( 1503' this.fp );// call bmpQWordWrite( 1802' avi%fp )  	for (i = 1; i <= 1503; i++) {  		//do i = 1' 1802  		this.m_stream.Write ((byte)0);  		// call fputc( 0' avi%fp )  	}  	//end do  	m_junk_length = 0xff4;  	Util.fwrite ("LIST"' this.m_stream);  	//      i = fwrite( 'LIST'' 1' 4' avi%fp )  	m_movi_position = m_stream.BaseStream.Position;  	Util.WriteDWORD (0' this.m_stream);  	// call bmpQWordWrite( 0' avi%fp )     !// ******************ココの数字は一番最後に書き換える必要あり2040～2043あとdwTotalFrames（48～51）も  	Util.fwrite ("movi"' this.m_stream);  	// i = fwrite( 'movi'' 1' 4' avi%fp )  	m_next_framedata_position = m_stream.BaseStream.Position;  	m_std_index.SetBaseOffset ((ulong)m_next_framedata_position);  	m_super_index.nEntriesInUse++;  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,AddFrame,The following statement contains a magic number: if (m_is_first) {  	//then  	m_is_first = false;  	this.m_main_header.dwWidth = (uint)m_width;  	this.m_main_header.dwHeight = (uint)m_height;  	this.m_main_header.dwMaxBytesPerSec = (uint)(bmpDat.Stride * bmpDat.Height * this.frameRate);  	// bmp%infoHeader%SizeImage * avi%frameRate  	this.m_main_header.dwStreams = 1;  	this.m_main_header.dwSuggestedBufferSize = (uint)(bmpDat.Stride * bmpDat.Height);  	// bmp.infoHeader%SizeImage  	m_linesize = bmpDat.Stride;  	this.m_stream_header.fccType = Util.mmioFOURCC ("vids");  	this.m_stream_header.fccHandler = 0;  	this.m_stream_header.dwFlags = 0;  	this.m_stream_header.dwReserved1 = 0;  	this.m_stream_header.dwInitialFrames = 0;  	this.m_stream_header.dwScale = m_scale;  	this.m_stream_header.dwRate = m_rate;  	this.m_stream_header.dwStart = 0;  	this.m_stream_header.dwSuggestedBufferSize = this.m_main_header.dwSuggestedBufferSize;  	this.m_stream_header.dwQuality = 0;  	this.m_stream_header.dwSampleSize = 0;  	Util.aviWriteMainHeader (m_main_header' m_stream);  	Util.fwrite ("LIST"' this.m_stream);  	// i = fwrite( 'LIST'' 1' 4' avi%fp )  	Util.WriteDWORD (0x874' this.m_stream);  	// call bmpQWordWrite( 130' avi%fp )  	Util.fwrite ("strl"' this.m_stream);  	// i = fwrite( 'strl'' 1' 4' avi%fp )  	Util.aviWriteStreamHeader (m_stream_header' m_main_header' m_stream);  	// avi )  	Util.fwrite ("strf"' this.m_stream);  	// i = fwrite( 'strf'' 1' 4' avi%fp )  	Util.WriteDWORD (0x28' this.m_stream);  	//call bmpQWordWrite( 40' avi%fp )    !// infoHeaderのサイズ  	BITMAPINFOHEADER bih = new BITMAPINFOHEADER ();  	bih.biSize = (uint)(Marshal.SizeOf (bih));  	bih.biWidth = bmpDat.Width;  	bih.biHeight = bmpDat.Height;  	bih.biPlanes = 1;  	bih.biBitCount = 24;  	bih.biCompression = 0;  	//BI_RGB  	bih.biSizeImage = (uint)(bmpDat.Stride * bmpDat.Height);  	bih.biXPelsPerMeter = 0;  	bih.biYPelsPerMeter = 0;  	bih.biClrUsed = 0;  	bih.biClrImportant = 0;  	bih.Write (m_stream);  	/*fwrite( "strn"' this.fp );                 WriteDWORD( 6' this.fp );                 fwrite( "VIDEO"' this.fp );                 WriteBYTE( 0' this.fp );*/Util.fwrite ("indx"' this.m_stream);  	//fcc  	Util.WriteDWORD (0x7f8' this.m_stream);  	// cb  	Util.WriteWORD ((byte)0x4' this.m_stream);  	// wLongsPerEntry  	Util.WriteBYTE (0x0' this.m_stream);  	// bIndexSubType  	Util.WriteBYTE (Util.AVI_INDEX_OF_INDEXES' this.m_stream);  	// bIndexType  	Util.WriteDWORD (0x0' this.m_stream);  	// nEntriesInUse  	Util.fwrite ("00db"' this.m_stream);  	// dwChunkId  	Util.WriteDWORD (0x0' this.m_stream);  	Util.WriteDWORD (0x0' this.m_stream);  	Util.WriteDWORD (0x0' this.m_stream);  	for (int ii = 1; ii <= 126; ii++) {  		Util.WriteQWORD (0x0' this.m_stream);  		Util.WriteDWORD (0x0' this.m_stream);  		Util.WriteDWORD (0x0' this.m_stream);  	}  	Util.fwrite ("LIST"' this.m_stream);  	Util.WriteDWORD (0x104' m_stream);  	Util.fwrite ("odml"' this.m_stream);  	Util.fwrite ("dmlh"' m_stream);  	Util.WriteDWORD (0xf8' m_stream);  	Util.WriteDWORD (0x0' m_stream);  	//ここ後で更新するべき  	for (int ii = 1; ii <= 61; ii++) {  		Util.WriteDWORD (0x0' m_stream);  	}  	Util.fwrite ("JUNK"' this.m_stream);  	// i = fwrite( 'JUNK'' 1' 4' avi%fp )  	Util.WriteDWORD (0x60c' m_stream);  	Util.WriteDWORD (0' m_stream);  	//"This"が将来登録されたらやばいので  	Util.fwrite ("This file was generated by RawAvi@LipSync"' this.m_stream);  	//WriteDWORD( 1503' this.fp );// call bmpQWordWrite( 1802' avi%fp )  	for (i = 1; i <= 1503; i++) {  		//do i = 1' 1802  		this.m_stream.Write ((byte)0);  		// call fputc( 0' avi%fp )  	}  	//end do  	m_junk_length = 0xff4;  	Util.fwrite ("LIST"' this.m_stream);  	//      i = fwrite( 'LIST'' 1' 4' avi%fp )  	m_movi_position = m_stream.BaseStream.Position;  	Util.WriteDWORD (0' this.m_stream);  	// call bmpQWordWrite( 0' avi%fp )     !// ******************ココの数字は一番最後に書き換える必要あり2040～2043あとdwTotalFrames（48～51）も  	Util.fwrite ("movi"' this.m_stream);  	// i = fwrite( 'movi'' 1' 4' avi%fp )  	m_next_framedata_position = m_stream.BaseStream.Position;  	m_std_index.SetBaseOffset ((ulong)m_next_framedata_position);  	m_super_index.nEntriesInUse++;  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,AddFrame,The following statement contains a magic number: if (m_is_first) {  	//then  	m_is_first = false;  	this.m_main_header.dwWidth = (uint)m_width;  	this.m_main_header.dwHeight = (uint)m_height;  	this.m_main_header.dwMaxBytesPerSec = (uint)(bmpDat.Stride * bmpDat.Height * this.frameRate);  	// bmp%infoHeader%SizeImage * avi%frameRate  	this.m_main_header.dwStreams = 1;  	this.m_main_header.dwSuggestedBufferSize = (uint)(bmpDat.Stride * bmpDat.Height);  	// bmp.infoHeader%SizeImage  	m_linesize = bmpDat.Stride;  	this.m_stream_header.fccType = Util.mmioFOURCC ("vids");  	this.m_stream_header.fccHandler = 0;  	this.m_stream_header.dwFlags = 0;  	this.m_stream_header.dwReserved1 = 0;  	this.m_stream_header.dwInitialFrames = 0;  	this.m_stream_header.dwScale = m_scale;  	this.m_stream_header.dwRate = m_rate;  	this.m_stream_header.dwStart = 0;  	this.m_stream_header.dwSuggestedBufferSize = this.m_main_header.dwSuggestedBufferSize;  	this.m_stream_header.dwQuality = 0;  	this.m_stream_header.dwSampleSize = 0;  	Util.aviWriteMainHeader (m_main_header' m_stream);  	Util.fwrite ("LIST"' this.m_stream);  	// i = fwrite( 'LIST'' 1' 4' avi%fp )  	Util.WriteDWORD (0x874' this.m_stream);  	// call bmpQWordWrite( 130' avi%fp )  	Util.fwrite ("strl"' this.m_stream);  	// i = fwrite( 'strl'' 1' 4' avi%fp )  	Util.aviWriteStreamHeader (m_stream_header' m_main_header' m_stream);  	// avi )  	Util.fwrite ("strf"' this.m_stream);  	// i = fwrite( 'strf'' 1' 4' avi%fp )  	Util.WriteDWORD (0x28' this.m_stream);  	//call bmpQWordWrite( 40' avi%fp )    !// infoHeaderのサイズ  	BITMAPINFOHEADER bih = new BITMAPINFOHEADER ();  	bih.biSize = (uint)(Marshal.SizeOf (bih));  	bih.biWidth = bmpDat.Width;  	bih.biHeight = bmpDat.Height;  	bih.biPlanes = 1;  	bih.biBitCount = 24;  	bih.biCompression = 0;  	//BI_RGB  	bih.biSizeImage = (uint)(bmpDat.Stride * bmpDat.Height);  	bih.biXPelsPerMeter = 0;  	bih.biYPelsPerMeter = 0;  	bih.biClrUsed = 0;  	bih.biClrImportant = 0;  	bih.Write (m_stream);  	/*fwrite( "strn"' this.fp );                 WriteDWORD( 6' this.fp );                 fwrite( "VIDEO"' this.fp );                 WriteBYTE( 0' this.fp );*/Util.fwrite ("indx"' this.m_stream);  	//fcc  	Util.WriteDWORD (0x7f8' this.m_stream);  	// cb  	Util.WriteWORD ((byte)0x4' this.m_stream);  	// wLongsPerEntry  	Util.WriteBYTE (0x0' this.m_stream);  	// bIndexSubType  	Util.WriteBYTE (Util.AVI_INDEX_OF_INDEXES' this.m_stream);  	// bIndexType  	Util.WriteDWORD (0x0' this.m_stream);  	// nEntriesInUse  	Util.fwrite ("00db"' this.m_stream);  	// dwChunkId  	Util.WriteDWORD (0x0' this.m_stream);  	Util.WriteDWORD (0x0' this.m_stream);  	Util.WriteDWORD (0x0' this.m_stream);  	for (int ii = 1; ii <= 126; ii++) {  		Util.WriteQWORD (0x0' this.m_stream);  		Util.WriteDWORD (0x0' this.m_stream);  		Util.WriteDWORD (0x0' this.m_stream);  	}  	Util.fwrite ("LIST"' this.m_stream);  	Util.WriteDWORD (0x104' m_stream);  	Util.fwrite ("odml"' this.m_stream);  	Util.fwrite ("dmlh"' m_stream);  	Util.WriteDWORD (0xf8' m_stream);  	Util.WriteDWORD (0x0' m_stream);  	//ここ後で更新するべき  	for (int ii = 1; ii <= 61; ii++) {  		Util.WriteDWORD (0x0' m_stream);  	}  	Util.fwrite ("JUNK"' this.m_stream);  	// i = fwrite( 'JUNK'' 1' 4' avi%fp )  	Util.WriteDWORD (0x60c' m_stream);  	Util.WriteDWORD (0' m_stream);  	//"This"が将来登録されたらやばいので  	Util.fwrite ("This file was generated by RawAvi@LipSync"' this.m_stream);  	//WriteDWORD( 1503' this.fp );// call bmpQWordWrite( 1802' avi%fp )  	for (i = 1; i <= 1503; i++) {  		//do i = 1' 1802  		this.m_stream.Write ((byte)0);  		// call fputc( 0' avi%fp )  	}  	//end do  	m_junk_length = 0xff4;  	Util.fwrite ("LIST"' this.m_stream);  	//      i = fwrite( 'LIST'' 1' 4' avi%fp )  	m_movi_position = m_stream.BaseStream.Position;  	Util.WriteDWORD (0' this.m_stream);  	// call bmpQWordWrite( 0' avi%fp )     !// ******************ココの数字は一番最後に書き換える必要あり2040～2043あとdwTotalFrames（48～51）も  	Util.fwrite ("movi"' this.m_stream);  	// i = fwrite( 'movi'' 1' 4' avi%fp )  	m_next_framedata_position = m_stream.BaseStream.Position;  	m_std_index.SetBaseOffset ((ulong)m_next_framedata_position);  	m_super_index.nEntriesInUse++;  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,AddFrame,The following statement contains a magic number: if (m_is_first) {  	//then  	m_is_first = false;  	this.m_main_header.dwWidth = (uint)m_width;  	this.m_main_header.dwHeight = (uint)m_height;  	this.m_main_header.dwMaxBytesPerSec = (uint)(bmpDat.Stride * bmpDat.Height * this.frameRate);  	// bmp%infoHeader%SizeImage * avi%frameRate  	this.m_main_header.dwStreams = 1;  	this.m_main_header.dwSuggestedBufferSize = (uint)(bmpDat.Stride * bmpDat.Height);  	// bmp.infoHeader%SizeImage  	m_linesize = bmpDat.Stride;  	this.m_stream_header.fccType = Util.mmioFOURCC ("vids");  	this.m_stream_header.fccHandler = 0;  	this.m_stream_header.dwFlags = 0;  	this.m_stream_header.dwReserved1 = 0;  	this.m_stream_header.dwInitialFrames = 0;  	this.m_stream_header.dwScale = m_scale;  	this.m_stream_header.dwRate = m_rate;  	this.m_stream_header.dwStart = 0;  	this.m_stream_header.dwSuggestedBufferSize = this.m_main_header.dwSuggestedBufferSize;  	this.m_stream_header.dwQuality = 0;  	this.m_stream_header.dwSampleSize = 0;  	Util.aviWriteMainHeader (m_main_header' m_stream);  	Util.fwrite ("LIST"' this.m_stream);  	// i = fwrite( 'LIST'' 1' 4' avi%fp )  	Util.WriteDWORD (0x874' this.m_stream);  	// call bmpQWordWrite( 130' avi%fp )  	Util.fwrite ("strl"' this.m_stream);  	// i = fwrite( 'strl'' 1' 4' avi%fp )  	Util.aviWriteStreamHeader (m_stream_header' m_main_header' m_stream);  	// avi )  	Util.fwrite ("strf"' this.m_stream);  	// i = fwrite( 'strf'' 1' 4' avi%fp )  	Util.WriteDWORD (0x28' this.m_stream);  	//call bmpQWordWrite( 40' avi%fp )    !// infoHeaderのサイズ  	BITMAPINFOHEADER bih = new BITMAPINFOHEADER ();  	bih.biSize = (uint)(Marshal.SizeOf (bih));  	bih.biWidth = bmpDat.Width;  	bih.biHeight = bmpDat.Height;  	bih.biPlanes = 1;  	bih.biBitCount = 24;  	bih.biCompression = 0;  	//BI_RGB  	bih.biSizeImage = (uint)(bmpDat.Stride * bmpDat.Height);  	bih.biXPelsPerMeter = 0;  	bih.biYPelsPerMeter = 0;  	bih.biClrUsed = 0;  	bih.biClrImportant = 0;  	bih.Write (m_stream);  	/*fwrite( "strn"' this.fp );                 WriteDWORD( 6' this.fp );                 fwrite( "VIDEO"' this.fp );                 WriteBYTE( 0' this.fp );*/Util.fwrite ("indx"' this.m_stream);  	//fcc  	Util.WriteDWORD (0x7f8' this.m_stream);  	// cb  	Util.WriteWORD ((byte)0x4' this.m_stream);  	// wLongsPerEntry  	Util.WriteBYTE (0x0' this.m_stream);  	// bIndexSubType  	Util.WriteBYTE (Util.AVI_INDEX_OF_INDEXES' this.m_stream);  	// bIndexType  	Util.WriteDWORD (0x0' this.m_stream);  	// nEntriesInUse  	Util.fwrite ("00db"' this.m_stream);  	// dwChunkId  	Util.WriteDWORD (0x0' this.m_stream);  	Util.WriteDWORD (0x0' this.m_stream);  	Util.WriteDWORD (0x0' this.m_stream);  	for (int ii = 1; ii <= 126; ii++) {  		Util.WriteQWORD (0x0' this.m_stream);  		Util.WriteDWORD (0x0' this.m_stream);  		Util.WriteDWORD (0x0' this.m_stream);  	}  	Util.fwrite ("LIST"' this.m_stream);  	Util.WriteDWORD (0x104' m_stream);  	Util.fwrite ("odml"' this.m_stream);  	Util.fwrite ("dmlh"' m_stream);  	Util.WriteDWORD (0xf8' m_stream);  	Util.WriteDWORD (0x0' m_stream);  	//ここ後で更新するべき  	for (int ii = 1; ii <= 61; ii++) {  		Util.WriteDWORD (0x0' m_stream);  	}  	Util.fwrite ("JUNK"' this.m_stream);  	// i = fwrite( 'JUNK'' 1' 4' avi%fp )  	Util.WriteDWORD (0x60c' m_stream);  	Util.WriteDWORD (0' m_stream);  	//"This"が将来登録されたらやばいので  	Util.fwrite ("This file was generated by RawAvi@LipSync"' this.m_stream);  	//WriteDWORD( 1503' this.fp );// call bmpQWordWrite( 1802' avi%fp )  	for (i = 1; i <= 1503; i++) {  		//do i = 1' 1802  		this.m_stream.Write ((byte)0);  		// call fputc( 0' avi%fp )  	}  	//end do  	m_junk_length = 0xff4;  	Util.fwrite ("LIST"' this.m_stream);  	//      i = fwrite( 'LIST'' 1' 4' avi%fp )  	m_movi_position = m_stream.BaseStream.Position;  	Util.WriteDWORD (0' this.m_stream);  	// call bmpQWordWrite( 0' avi%fp )     !// ******************ココの数字は一番最後に書き換える必要あり2040～2043あとdwTotalFrames（48～51）も  	Util.fwrite ("movi"' this.m_stream);  	// i = fwrite( 'movi'' 1' 4' avi%fp )  	m_next_framedata_position = m_stream.BaseStream.Position;  	m_std_index.SetBaseOffset ((ulong)m_next_framedata_position);  	m_super_index.nEntriesInUse++;  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,AddFrame,The following statement contains a magic number: bih.biBitCount = 24;  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,AddFrame,The following statement contains a magic number: for (int ii = 1; ii <= 126; ii++) {  	Util.WriteQWORD (0x0' this.m_stream);  	Util.WriteDWORD (0x0' this.m_stream);  	Util.WriteDWORD (0x0' this.m_stream);  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,AddFrame,The following statement contains a magic number: for (int ii = 1; ii <= 61; ii++) {  	Util.WriteDWORD (0x0' m_stream);  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,AddFrame,The following statement contains a magic number: for (i = 1; i <= 1503; i++) {  	//do i = 1' 1802  	this.m_stream.Write ((byte)0);  	// call fputc( 0' avi%fp )  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,AddFrame,The following statement contains a magic number: if ((m_current_chunk == 0 && chunk_size > m_split_sreshold) || (m_current_chunk > 0 && chunk_size > SRESHOLD)) {  	// AVIXリストへの書き込みに移行  	UpdateIndex ();  	m_stream.BaseStream.Seek (m_avix_position' SeekOrigin.Begin);  	Util.fwrite ("RIFF"' m_stream);  	m_riff_position = m_stream.BaseStream.Position;  	#if DEBUG  	//                fp.Flush(); //                MessageBox.Show( "m_riff_position=" + m_riff_position ); #endif  	Util.WriteDWORD (0' m_stream);  	Util.fwrite ("AVIX"' m_stream);  	long current = m_stream.BaseStream.Position;  	if ((current + 12) % 0x800 != 0) {  		long additional = (current + 20) % 0x800;  		additional = 0x800 - ((current + 20) % 0x800);  		m_junk_length = (int)additional + 20;  		Util.fwrite ("JUNK"' m_stream);  		Util.WriteDWORD ((uint)additional' m_stream);  		for (long ii = 0; ii < additional; ii++) {  			Util.WriteBYTE ((byte)0' m_stream);  		}  	} else {  		m_junk_length = 0;  	}  	m_junk_length = 0;  	Util.fwrite ("LIST"' m_stream);  	m_movi_position = m_stream.BaseStream.Position;  	Util.WriteDWORD (0' m_stream);  	//後で更新するべき  	Util.fwrite ("movi"' m_stream);  	m_next_framedata_position = m_stream.BaseStream.Position;  	m_std_index.aIndex.Clear ();  	m_std_index.SetBaseOffset ((ulong)m_next_framedata_position);  	m_current_chunk++;  	m_super_index.nEntriesInUse++;  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,AddFrame,The following statement contains a magic number: if ((m_current_chunk == 0 && chunk_size > m_split_sreshold) || (m_current_chunk > 0 && chunk_size > SRESHOLD)) {  	// AVIXリストへの書き込みに移行  	UpdateIndex ();  	m_stream.BaseStream.Seek (m_avix_position' SeekOrigin.Begin);  	Util.fwrite ("RIFF"' m_stream);  	m_riff_position = m_stream.BaseStream.Position;  	#if DEBUG  	//                fp.Flush(); //                MessageBox.Show( "m_riff_position=" + m_riff_position ); #endif  	Util.WriteDWORD (0' m_stream);  	Util.fwrite ("AVIX"' m_stream);  	long current = m_stream.BaseStream.Position;  	if ((current + 12) % 0x800 != 0) {  		long additional = (current + 20) % 0x800;  		additional = 0x800 - ((current + 20) % 0x800);  		m_junk_length = (int)additional + 20;  		Util.fwrite ("JUNK"' m_stream);  		Util.WriteDWORD ((uint)additional' m_stream);  		for (long ii = 0; ii < additional; ii++) {  			Util.WriteBYTE ((byte)0' m_stream);  		}  	} else {  		m_junk_length = 0;  	}  	m_junk_length = 0;  	Util.fwrite ("LIST"' m_stream);  	m_movi_position = m_stream.BaseStream.Position;  	Util.WriteDWORD (0' m_stream);  	//後で更新するべき  	Util.fwrite ("movi"' m_stream);  	m_next_framedata_position = m_stream.BaseStream.Position;  	m_std_index.aIndex.Clear ();  	m_std_index.SetBaseOffset ((ulong)m_next_framedata_position);  	m_current_chunk++;  	m_super_index.nEntriesInUse++;  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,AddFrame,The following statement contains a magic number: if ((m_current_chunk == 0 && chunk_size > m_split_sreshold) || (m_current_chunk > 0 && chunk_size > SRESHOLD)) {  	// AVIXリストへの書き込みに移行  	UpdateIndex ();  	m_stream.BaseStream.Seek (m_avix_position' SeekOrigin.Begin);  	Util.fwrite ("RIFF"' m_stream);  	m_riff_position = m_stream.BaseStream.Position;  	#if DEBUG  	//                fp.Flush(); //                MessageBox.Show( "m_riff_position=" + m_riff_position ); #endif  	Util.WriteDWORD (0' m_stream);  	Util.fwrite ("AVIX"' m_stream);  	long current = m_stream.BaseStream.Position;  	if ((current + 12) % 0x800 != 0) {  		long additional = (current + 20) % 0x800;  		additional = 0x800 - ((current + 20) % 0x800);  		m_junk_length = (int)additional + 20;  		Util.fwrite ("JUNK"' m_stream);  		Util.WriteDWORD ((uint)additional' m_stream);  		for (long ii = 0; ii < additional; ii++) {  			Util.WriteBYTE ((byte)0' m_stream);  		}  	} else {  		m_junk_length = 0;  	}  	m_junk_length = 0;  	Util.fwrite ("LIST"' m_stream);  	m_movi_position = m_stream.BaseStream.Position;  	Util.WriteDWORD (0' m_stream);  	//後で更新するべき  	Util.fwrite ("movi"' m_stream);  	m_next_framedata_position = m_stream.BaseStream.Position;  	m_std_index.aIndex.Clear ();  	m_std_index.SetBaseOffset ((ulong)m_next_framedata_position);  	m_current_chunk++;  	m_super_index.nEntriesInUse++;  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,AddFrame,The following statement contains a magic number: if ((m_current_chunk == 0 && chunk_size > m_split_sreshold) || (m_current_chunk > 0 && chunk_size > SRESHOLD)) {  	// AVIXリストへの書き込みに移行  	UpdateIndex ();  	m_stream.BaseStream.Seek (m_avix_position' SeekOrigin.Begin);  	Util.fwrite ("RIFF"' m_stream);  	m_riff_position = m_stream.BaseStream.Position;  	#if DEBUG  	//                fp.Flush(); //                MessageBox.Show( "m_riff_position=" + m_riff_position ); #endif  	Util.WriteDWORD (0' m_stream);  	Util.fwrite ("AVIX"' m_stream);  	long current = m_stream.BaseStream.Position;  	if ((current + 12) % 0x800 != 0) {  		long additional = (current + 20) % 0x800;  		additional = 0x800 - ((current + 20) % 0x800);  		m_junk_length = (int)additional + 20;  		Util.fwrite ("JUNK"' m_stream);  		Util.WriteDWORD ((uint)additional' m_stream);  		for (long ii = 0; ii < additional; ii++) {  			Util.WriteBYTE ((byte)0' m_stream);  		}  	} else {  		m_junk_length = 0;  	}  	m_junk_length = 0;  	Util.fwrite ("LIST"' m_stream);  	m_movi_position = m_stream.BaseStream.Position;  	Util.WriteDWORD (0' m_stream);  	//後で更新するべき  	Util.fwrite ("movi"' m_stream);  	m_next_framedata_position = m_stream.BaseStream.Position;  	m_std_index.aIndex.Clear ();  	m_std_index.SetBaseOffset ((ulong)m_next_framedata_position);  	m_current_chunk++;  	m_super_index.nEntriesInUse++;  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,AddFrame,The following statement contains a magic number: if ((current + 12) % 0x800 != 0) {  	long additional = (current + 20) % 0x800;  	additional = 0x800 - ((current + 20) % 0x800);  	m_junk_length = (int)additional + 20;  	Util.fwrite ("JUNK"' m_stream);  	Util.WriteDWORD ((uint)additional' m_stream);  	for (long ii = 0; ii < additional; ii++) {  		Util.WriteBYTE ((byte)0' m_stream);  	}  } else {  	m_junk_length = 0;  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,AddFrame,The following statement contains a magic number: if ((current + 12) % 0x800 != 0) {  	long additional = (current + 20) % 0x800;  	additional = 0x800 - ((current + 20) % 0x800);  	m_junk_length = (int)additional + 20;  	Util.fwrite ("JUNK"' m_stream);  	Util.WriteDWORD ((uint)additional' m_stream);  	for (long ii = 0; ii < additional; ii++) {  		Util.WriteBYTE ((byte)0' m_stream);  	}  } else {  	m_junk_length = 0;  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,AddFrame,The following statement contains a magic number: if ((current + 12) % 0x800 != 0) {  	long additional = (current + 20) % 0x800;  	additional = 0x800 - ((current + 20) % 0x800);  	m_junk_length = (int)additional + 20;  	Util.fwrite ("JUNK"' m_stream);  	Util.WriteDWORD ((uint)additional' m_stream);  	for (long ii = 0; ii < additional; ii++) {  		Util.WriteBYTE ((byte)0' m_stream);  	}  } else {  	m_junk_length = 0;  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,AddFrame,The following statement contains a magic number: if ((current + 12) % 0x800 != 0) {  	long additional = (current + 20) % 0x800;  	additional = 0x800 - ((current + 20) % 0x800);  	m_junk_length = (int)additional + 20;  	Util.fwrite ("JUNK"' m_stream);  	Util.WriteDWORD ((uint)additional' m_stream);  	for (long ii = 0; ii < additional; ii++) {  		Util.WriteBYTE ((byte)0' m_stream);  	}  } else {  	m_junk_length = 0;  }  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,AddFrame,The following statement contains a magic number: additional = 0x800 - ((current + 20) % 0x800);  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,AddFrame,The following statement contains a magic number: m_junk_length = (int)additional + 20;  
Magic Number,cadencii.media,RawAvi2Writer,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\RawAvi2Writer.cs,AddFrame,The following statement contains a magic number: m_std_index.AddIndex ((uint)((ulong)m_stream.BaseStream.Position - m_std_index.qwBaseOffset) + 8' (uint)(lineSize * height));  
Magic Number,cadencii.media,PipedAviWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PipedAviWriter.cs,AddFrame,The following statement contains a magic number: bih.biBitCount = m_pix_fmt == PixelFormat.Format24bppRgb ? (short)24 : (short)32;  
Magic Number,cadencii.media,PipedAviWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PipedAviWriter.cs,AddFrame,The following statement contains a magic number: bih.biBitCount = m_pix_fmt == PixelFormat.Format24bppRgb ? (short)24 : (short)32;  
Magic Number,cadencii.media,PipedAviWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PipedAviWriter.cs,WriteFourCC,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	b [i] = (byte)value [i];  }  
Magic Number,cadencii.media,PipedAviWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PipedAviWriter.cs,WriteFourCC,The following statement contains a magic number: m_stream.Write (b' 0' 4);  
Magic Number,cadencii.media,PipedAviWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PipedAviWriter.cs,Write4Byte,The following statement contains a magic number: m_stream.Write (b' 0' 4);  
Magic Number,cadencii.media,PipedAviWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PipedAviWriter.cs,Open,The following statement contains a magic number: m_main_avi_header.dwMicroSecPerFrame = (uint)(1.0e6 * (double)scale / (double)rate);  
Magic Number,cadencii.media,PipedAviWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PipedAviWriter.cs,Open,The following statement contains a magic number: m_main_avi_header.dwFlags = 2064;  
Magic Number,cadencii.media,PipedAviWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PipedAviWriter.cs,FFmpegEnc,The following statement contains a magic number: Thread.Sleep (1000);  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,aviWriteStreamHeader,The following statement contains a magic number: Util.WriteDWORD (56' stream);  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,aviWriteMainHeader,The following statement contains a magic number: Util.WriteDWORD (56' stream);  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,WriteWORD,The following statement contains a magic number: k1 = (byte)(number >> 8);  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,WriteWORD,The following statement contains a magic number: k2 = (byte)(number - (k1 << 8));  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,WriteDWORD,The following statement contains a magic number: k1 = (byte)(number >> 24);  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,WriteDWORD,The following statement contains a magic number: number -= (uint)(k1 << 24);  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,WriteDWORD,The following statement contains a magic number: k2 = (byte)(number >> 16);  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,WriteDWORD,The following statement contains a magic number: number -= (uint)(k2 << 16);  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,WriteDWORD,The following statement contains a magic number: k3 = (byte)(number >> 8);  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,WriteDWORD,The following statement contains a magic number: k4 = (byte)(number - (k3 << 8));  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,WriteQWORD,The following statement contains a magic number: k1 = (byte)(number >> 56);  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,WriteQWORD,The following statement contains a magic number: number -= (ulong)k1 << 56;  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,WriteQWORD,The following statement contains a magic number: k2 = (byte)(number >> 48);  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,WriteQWORD,The following statement contains a magic number: number -= (ulong)k2 << 48;  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,WriteQWORD,The following statement contains a magic number: k3 = (byte)(number >> 40);  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,WriteQWORD,The following statement contains a magic number: number -= (ulong)k3 << 40;  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,WriteQWORD,The following statement contains a magic number: k4 = (byte)(number >> 32);  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,WriteQWORD,The following statement contains a magic number: number -= (ulong)k4 << 32;  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,WriteQWORD,The following statement contains a magic number: k5 = (byte)(number >> 24);  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,WriteQWORD,The following statement contains a magic number: number -= (ulong)k5 << 24;  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,WriteQWORD,The following statement contains a magic number: k6 = (byte)(number >> 16);  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,WriteQWORD,The following statement contains a magic number: number -= (ulong)k6 << 16;  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,WriteQWORD,The following statement contains a magic number: k7 = (byte)(number >> 8);  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,WriteQWORD,The following statement contains a magic number: k8 = (byte)(number - (ulong)(k7 << 8));  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,mmioFOURCC,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (i < fcc.Length) {  		str [i] = fcc [i];  	} else {  		str [i] = ' ';  	}  }  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,mmioFOURCC,The following statement contains a magic number: return mmioFOURCC (str [0]' str [1]' str [2]' str [3]);  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,mmioFOURCC,The following statement contains a magic number: return mmioFOURCC (str [0]' str [1]' str [2]' str [3]);  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,mmioFOURCC,The following statement contains a magic number: return (uint)((byte)(ch0) | ((byte)(ch1) << 8) | ((byte)(ch2) << 16) | ((byte)(ch3) << 24));  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,mmioFOURCC,The following statement contains a magic number: return (uint)((byte)(ch0) | ((byte)(ch1) << 8) | ((byte)(ch2) << 16) | ((byte)(ch3) << 24));  
Magic Number,cadencii.media,Util,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Util.cs,mmioFOURCC,The following statement contains a magic number: return (uint)((byte)(ch0) | ((byte)(ch1) << 8) | ((byte)(ch2) << 16) | ((byte)(ch3) << 24));  
Magic Number,cadencii.media,AVIStreamHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,The following statement contains a magic number: s.Write (b' 0' 4);  
Magic Number,cadencii.media,AVIStreamHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,The following statement contains a magic number: s.Write (b' 0' 4);  
Magic Number,cadencii.media,AVIStreamHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,The following statement contains a magic number: s.Write (b' 0' 4);  
Magic Number,cadencii.media,AVIStreamHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,The following statement contains a magic number: s.Write (b' 0' 4);  
Magic Number,cadencii.media,AVIStreamHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,The following statement contains a magic number: s.Write (b' 0' 4);  
Magic Number,cadencii.media,AVIStreamHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,The following statement contains a magic number: s.Write (b' 0' 4);  
Magic Number,cadencii.media,AVIStreamHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,The following statement contains a magic number: s.Write (b' 0' 4);  
Magic Number,cadencii.media,AVIStreamHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,The following statement contains a magic number: s.Write (b' 0' 4);  
Magic Number,cadencii.media,AVIStreamHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,The following statement contains a magic number: s.Write (b' 0' 4);  
Magic Number,cadencii.media,AVIStreamHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,The following statement contains a magic number: s.Write (b' 0' 4);  
Magic Number,cadencii.media,AVIStreamHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,The following statement contains a magic number: s.Write (b' 0' 4);  
Magic Number,cadencii.media,AVIStreamHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,The following statement contains a magic number: s.Write (b' 0' 4);  
Magic Number,cadencii.media,MainAVIHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,The following statement contains a magic number: s.Write (b' 0' 4);  
Magic Number,cadencii.media,MainAVIHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,The following statement contains a magic number: s.Write (b' 0' 4);  
Magic Number,cadencii.media,MainAVIHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,The following statement contains a magic number: s.Write (b' 0' 4);  
Magic Number,cadencii.media,MainAVIHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,The following statement contains a magic number: s.Write (b' 0' 4);  
Magic Number,cadencii.media,MainAVIHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,The following statement contains a magic number: s.Write (b' 0' 4);  
Magic Number,cadencii.media,MainAVIHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,The following statement contains a magic number: s.Write (b' 0' 4);  
Magic Number,cadencii.media,MainAVIHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,The following statement contains a magic number: s.Write (b' 0' 4);  
Magic Number,cadencii.media,MainAVIHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,The following statement contains a magic number: s.Write (b' 0' 4);  
Magic Number,cadencii.media,MainAVIHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,The following statement contains a magic number: s.Write (b' 0' 4);  
Magic Number,cadencii.media,MainAVIHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,The following statement contains a magic number: s.Write (b' 0' 4);  
Magic Number,cadencii.media,MainAVIHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,The following statement contains a magic number: s.Write (b' 0' 4);  
Magic Number,cadencii.media,MainAVIHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,The following statement contains a magic number: s.Write (b' 0' 4);  
Magic Number,cadencii.media,MainAVIHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,The following statement contains a magic number: s.Write (b' 0' 4);  
Magic Number,cadencii.media,MainAVIHeader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\VFW.cs,Write,The following statement contains a magic number: s.Write (b' 0' 4);  
Magic Number,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,RequireVideoCompressOption,The following statement contains a magic number: temp.m_scale = 1000;  
Magic Number,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,RequireVideoCompressOption,The following statement contains a magic number: temp.m_rate = 30 * temp.m_scale;  
Magic Number,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,Close,The following statement contains a magic number: using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  	fs.Seek (0x70' SeekOrigin.Begin);  	byte ch3 = (byte)(m_strh_fcc >> 24);  	uint b = (uint)(m_strh_fcc - (ch3 << 24));  	byte ch2 = (byte)(b >> 16);  	b = (uint)(b - (ch2 << 16));  	byte ch1 = (byte)(b >> 8);  	byte ch0 = (byte)(b - (ch1 << 8));  	fs.Write (new byte[] {  		ch0'  		ch1'  		ch2'  		ch3  	}' 0' 4);  }  
Magic Number,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,Close,The following statement contains a magic number: using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  	fs.Seek (0x70' SeekOrigin.Begin);  	byte ch3 = (byte)(m_strh_fcc >> 24);  	uint b = (uint)(m_strh_fcc - (ch3 << 24));  	byte ch2 = (byte)(b >> 16);  	b = (uint)(b - (ch2 << 16));  	byte ch1 = (byte)(b >> 8);  	byte ch0 = (byte)(b - (ch1 << 8));  	fs.Write (new byte[] {  		ch0'  		ch1'  		ch2'  		ch3  	}' 0' 4);  }  
Magic Number,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,Close,The following statement contains a magic number: using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  	fs.Seek (0x70' SeekOrigin.Begin);  	byte ch3 = (byte)(m_strh_fcc >> 24);  	uint b = (uint)(m_strh_fcc - (ch3 << 24));  	byte ch2 = (byte)(b >> 16);  	b = (uint)(b - (ch2 << 16));  	byte ch1 = (byte)(b >> 8);  	byte ch0 = (byte)(b - (ch1 << 8));  	fs.Write (new byte[] {  		ch0'  		ch1'  		ch2'  		ch3  	}' 0' 4);  }  
Magic Number,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,Close,The following statement contains a magic number: using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  	fs.Seek (0x70' SeekOrigin.Begin);  	byte ch3 = (byte)(m_strh_fcc >> 24);  	uint b = (uint)(m_strh_fcc - (ch3 << 24));  	byte ch2 = (byte)(b >> 16);  	b = (uint)(b - (ch2 << 16));  	byte ch1 = (byte)(b >> 8);  	byte ch0 = (byte)(b - (ch1 << 8));  	fs.Write (new byte[] {  		ch0'  		ch1'  		ch2'  		ch3  	}' 0' 4);  }  
Magic Number,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,Close,The following statement contains a magic number: using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  	fs.Seek (0x70' SeekOrigin.Begin);  	byte ch3 = (byte)(m_strh_fcc >> 24);  	uint b = (uint)(m_strh_fcc - (ch3 << 24));  	byte ch2 = (byte)(b >> 16);  	b = (uint)(b - (ch2 << 16));  	byte ch1 = (byte)(b >> 8);  	byte ch0 = (byte)(b - (ch1 << 8));  	fs.Write (new byte[] {  		ch0'  		ch1'  		ch2'  		ch3  	}' 0' 4);  }  
Magic Number,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,Close,The following statement contains a magic number: using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  	fs.Seek (0x70' SeekOrigin.Begin);  	byte ch3 = (byte)(m_strh_fcc >> 24);  	uint b = (uint)(m_strh_fcc - (ch3 << 24));  	byte ch2 = (byte)(b >> 16);  	b = (uint)(b - (ch2 << 16));  	byte ch1 = (byte)(b >> 8);  	byte ch0 = (byte)(b - (ch1 << 8));  	fs.Write (new byte[] {  		ch0'  		ch1'  		ch2'  		ch3  	}' 0' 4);  }  
Magic Number,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,Close,The following statement contains a magic number: using (FileStream fs = new FileStream (m_file' FileMode.Open)) {  	fs.Seek (0x70' SeekOrigin.Begin);  	byte ch3 = (byte)(m_strh_fcc >> 24);  	uint b = (uint)(m_strh_fcc - (ch3 << 24));  	byte ch2 = (byte)(b >> 16);  	b = (uint)(b - (ch2 << 16));  	byte ch1 = (byte)(b >> 8);  	byte ch0 = (byte)(b - (ch1 << 8));  	fs.Write (new byte[] {  		ch0'  		ch1'  		ch2'  		ch3  	}' 0' 4);  }  
Magic Number,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,Close,The following statement contains a magic number: b = (uint)(b - (ch2 << 16));  
Magic Number,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,Close,The following statement contains a magic number: fs.Write (new byte[] {  	ch0'  	ch1'  	ch2'  	ch3  }' 0' 4);  
Magic Number,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,CalcScaleAndRate,The following statement contains a magic number: scale = 100;  
Magic Number,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,pow10,The following statement contains a magic number: for (int i = 1; i <= x; i++) {  	result = result * 10;  }  
Magic Number,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,pow10,The following statement contains a magic number: result = result * 10;  
Magic Number,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,SetOptions,The following statement contains a magic number: bi.bmiHeader.biSize = 40;  
Magic Number,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,SetOptions,The following statement contains a magic number: bi.bmiHeader.biBitCount = 24;  
Magic Number,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,mmioFOURCC,The following statement contains a magic number: return ((Int32)(byte)(ch0) | ((byte)(ch1) << 8) | ((byte)(ch2) << 16) | ((byte)(ch3) << 24));  
Magic Number,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,mmioFOURCC,The following statement contains a magic number: return ((Int32)(byte)(ch0) | ((byte)(ch1) << 8) | ((byte)(ch2) << 16) | ((byte)(ch3) << 24));  
Magic Number,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,mmioFOURCC,The following statement contains a magic number: return ((Int32)(byte)(ch0) | ((byte)(ch1) << 8) | ((byte)(ch2) << 16) | ((byte)(ch3) << 24));  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,GetF0,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	int count = 0;  	double sum = 0.0;  	for (int j = i - ma_width_sample; j < i + 2 * ma_width_sample; j++) {  		if (0 <= j && j < length) {  			sum += formanto [j];  			count++;  		}  	}  	ma [i] = sum / (double)count;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,GetF0,The following statement contains a magic number: for (int j = i - ma_width_sample; j < i + 2 * ma_width_sample; j++) {  	if (0 <= j && j < length) {  		sum += formanto [j];  		count++;  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,GetF0,The following statement contains a magic number: if (index > 0) {  	List<double> peaks = new List<double> ();  	double peak_distance_tolerance = index * hz_from_index / 5.0;  	//最小の周波数の5分の1  	double last_peak_pos = index * hz_from_index;  	peaks.Add (last_peak_pos);  	for (int i = 1; i < peak_positions.Count; i++) {  		if (peak_positions [i] - last_peak_pos > peak_distance_tolerance) {  			peaks.Add (peak_positions [i]);  			last_peak_pos = peak_positions [i];  		}  	}  	#if DEBUG  	                if ( s_test ) {                     BufferedWriter sw = null;                     try {                         sw = new BufferedWriter( new FileWriter( "peaks.txt" ) );                         for ( int i = 0; i < peaks.Count; i++ ) {                             sw.write( peaks[i] + "" );                             sw.newLine();                         }                     } catch ( Exception ex ) {                     } finally {                         if ( sw != null ) {                             try {                                 sw.close();                             } catch ( Exception ex2 ) {                             }                         }                     }                 } #endif  	double min_peak_distance = index * hz_from_index * 2.0 / 3.0;  	/*for ( int i = 1; i < peaks.Count; i++ ) {                     min_peak_distance = Math.Min( min_peak_distance' peaks[i] - peaks[i - 1] );                 }*/  	#if DEBUG  	                sout.println( "WaveGetF0; min_peak_distance=" + min_peak_distance );                 if ( s_test ) {                     BufferedWriter sw = null;                     try {                         sw = new BufferedWriter( new FileWriter( "evaluation.txt" ) );                         for ( int i = (int)min_peak_distance; i < (int)(4 * min_peak_distance); i++ ) {                             sw.write( i + "\t" + GetFormantoGetEvaluationValue( peaks' i ) );                             sw.newLine();                         }                     } catch ( Exception ex ) {                     } finally {                         if ( sw != null ) {                             try {                                 sw.close();                             } catch ( Exception ex2 ) {                             }                         }                     }                 } #endif  	int smallest = (int)min_peak_distance;  	double min_eval = GetFormantoGetEvaluationValue (peaks' smallest);  	for (int i = (int)min_peak_distance; i < (int)(4 * min_peak_distance); i++) {  		double eval = GetFormantoGetEvaluationValue (peaks' i);  		if (min_eval > eval) {  			min_eval = eval;  			smallest = i;  		}  	}  	return smallest;  } else {  	return 0;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,GetF0,The following statement contains a magic number: if (index > 0) {  	List<double> peaks = new List<double> ();  	double peak_distance_tolerance = index * hz_from_index / 5.0;  	//最小の周波数の5分の1  	double last_peak_pos = index * hz_from_index;  	peaks.Add (last_peak_pos);  	for (int i = 1; i < peak_positions.Count; i++) {  		if (peak_positions [i] - last_peak_pos > peak_distance_tolerance) {  			peaks.Add (peak_positions [i]);  			last_peak_pos = peak_positions [i];  		}  	}  	#if DEBUG  	                if ( s_test ) {                     BufferedWriter sw = null;                     try {                         sw = new BufferedWriter( new FileWriter( "peaks.txt" ) );                         for ( int i = 0; i < peaks.Count; i++ ) {                             sw.write( peaks[i] + "" );                             sw.newLine();                         }                     } catch ( Exception ex ) {                     } finally {                         if ( sw != null ) {                             try {                                 sw.close();                             } catch ( Exception ex2 ) {                             }                         }                     }                 } #endif  	double min_peak_distance = index * hz_from_index * 2.0 / 3.0;  	/*for ( int i = 1; i < peaks.Count; i++ ) {                     min_peak_distance = Math.Min( min_peak_distance' peaks[i] - peaks[i - 1] );                 }*/  	#if DEBUG  	                sout.println( "WaveGetF0; min_peak_distance=" + min_peak_distance );                 if ( s_test ) {                     BufferedWriter sw = null;                     try {                         sw = new BufferedWriter( new FileWriter( "evaluation.txt" ) );                         for ( int i = (int)min_peak_distance; i < (int)(4 * min_peak_distance); i++ ) {                             sw.write( i + "\t" + GetFormantoGetEvaluationValue( peaks' i ) );                             sw.newLine();                         }                     } catch ( Exception ex ) {                     } finally {                         if ( sw != null ) {                             try {                                 sw.close();                             } catch ( Exception ex2 ) {                             }                         }                     }                 } #endif  	int smallest = (int)min_peak_distance;  	double min_eval = GetFormantoGetEvaluationValue (peaks' smallest);  	for (int i = (int)min_peak_distance; i < (int)(4 * min_peak_distance); i++) {  		double eval = GetFormantoGetEvaluationValue (peaks' i);  		if (min_eval > eval) {  			min_eval = eval;  			smallest = i;  		}  	}  	return smallest;  } else {  	return 0;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,GetF0,The following statement contains a magic number: if (index > 0) {  	List<double> peaks = new List<double> ();  	double peak_distance_tolerance = index * hz_from_index / 5.0;  	//最小の周波数の5分の1  	double last_peak_pos = index * hz_from_index;  	peaks.Add (last_peak_pos);  	for (int i = 1; i < peak_positions.Count; i++) {  		if (peak_positions [i] - last_peak_pos > peak_distance_tolerance) {  			peaks.Add (peak_positions [i]);  			last_peak_pos = peak_positions [i];  		}  	}  	#if DEBUG  	                if ( s_test ) {                     BufferedWriter sw = null;                     try {                         sw = new BufferedWriter( new FileWriter( "peaks.txt" ) );                         for ( int i = 0; i < peaks.Count; i++ ) {                             sw.write( peaks[i] + "" );                             sw.newLine();                         }                     } catch ( Exception ex ) {                     } finally {                         if ( sw != null ) {                             try {                                 sw.close();                             } catch ( Exception ex2 ) {                             }                         }                     }                 } #endif  	double min_peak_distance = index * hz_from_index * 2.0 / 3.0;  	/*for ( int i = 1; i < peaks.Count; i++ ) {                     min_peak_distance = Math.Min( min_peak_distance' peaks[i] - peaks[i - 1] );                 }*/  	#if DEBUG  	                sout.println( "WaveGetF0; min_peak_distance=" + min_peak_distance );                 if ( s_test ) {                     BufferedWriter sw = null;                     try {                         sw = new BufferedWriter( new FileWriter( "evaluation.txt" ) );                         for ( int i = (int)min_peak_distance; i < (int)(4 * min_peak_distance); i++ ) {                             sw.write( i + "\t" + GetFormantoGetEvaluationValue( peaks' i ) );                             sw.newLine();                         }                     } catch ( Exception ex ) {                     } finally {                         if ( sw != null ) {                             try {                                 sw.close();                             } catch ( Exception ex2 ) {                             }                         }                     }                 } #endif  	int smallest = (int)min_peak_distance;  	double min_eval = GetFormantoGetEvaluationValue (peaks' smallest);  	for (int i = (int)min_peak_distance; i < (int)(4 * min_peak_distance); i++) {  		double eval = GetFormantoGetEvaluationValue (peaks' i);  		if (min_eval > eval) {  			min_eval = eval;  			smallest = i;  		}  	}  	return smallest;  } else {  	return 0;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,GetF0,The following statement contains a magic number: if (index > 0) {  	List<double> peaks = new List<double> ();  	double peak_distance_tolerance = index * hz_from_index / 5.0;  	//最小の周波数の5分の1  	double last_peak_pos = index * hz_from_index;  	peaks.Add (last_peak_pos);  	for (int i = 1; i < peak_positions.Count; i++) {  		if (peak_positions [i] - last_peak_pos > peak_distance_tolerance) {  			peaks.Add (peak_positions [i]);  			last_peak_pos = peak_positions [i];  		}  	}  	#if DEBUG  	                if ( s_test ) {                     BufferedWriter sw = null;                     try {                         sw = new BufferedWriter( new FileWriter( "peaks.txt" ) );                         for ( int i = 0; i < peaks.Count; i++ ) {                             sw.write( peaks[i] + "" );                             sw.newLine();                         }                     } catch ( Exception ex ) {                     } finally {                         if ( sw != null ) {                             try {                                 sw.close();                             } catch ( Exception ex2 ) {                             }                         }                     }                 } #endif  	double min_peak_distance = index * hz_from_index * 2.0 / 3.0;  	/*for ( int i = 1; i < peaks.Count; i++ ) {                     min_peak_distance = Math.Min( min_peak_distance' peaks[i] - peaks[i - 1] );                 }*/  	#if DEBUG  	                sout.println( "WaveGetF0; min_peak_distance=" + min_peak_distance );                 if ( s_test ) {                     BufferedWriter sw = null;                     try {                         sw = new BufferedWriter( new FileWriter( "evaluation.txt" ) );                         for ( int i = (int)min_peak_distance; i < (int)(4 * min_peak_distance); i++ ) {                             sw.write( i + "\t" + GetFormantoGetEvaluationValue( peaks' i ) );                             sw.newLine();                         }                     } catch ( Exception ex ) {                     } finally {                         if ( sw != null ) {                             try {                                 sw.close();                             } catch ( Exception ex2 ) {                             }                         }                     }                 } #endif  	int smallest = (int)min_peak_distance;  	double min_eval = GetFormantoGetEvaluationValue (peaks' smallest);  	for (int i = (int)min_peak_distance; i < (int)(4 * min_peak_distance); i++) {  		double eval = GetFormantoGetEvaluationValue (peaks' i);  		if (min_eval > eval) {  			min_eval = eval;  			smallest = i;  		}  	}  	return smallest;  } else {  	return 0;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,GetF0,The following statement contains a magic number: for (int i = (int)min_peak_distance; i < (int)(4 * min_peak_distance); i++) {  	double eval = GetFormantoGetEvaluationValue (peaks' i);  	if (min_eval > eval) {  		min_eval = eval;  		smallest = i;  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,GetFormantoGetEvaluationValue,The following statement contains a magic number: for (int i = 0; i < peaks.Count; i++) {  	int n_i = (int)(peaks [i] / t + 0.5);  	double dt_i = peaks [i] - n_i * t;  	ret += Math.Abs (dt_i);  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,GetVolume,The following statement contains a magic number: getNormalizedWave (start_sample - window_size / 2' conv);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,GetVolume,The following statement contains a magic number: getNormalizedWave (start_sample - window_size / 2' conv);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = (L8 [i] - 64.0) / 64.0;  		}  	} else {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = L16 [i] / 32768.0;  		}  	}  } else {  	if (m_bit_per_sample == 8) {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = ((L8 [i] + R8 [i]) * 0.5 - 64.0) / 64.0;  		}  	} else {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = (L16 [i] + R16 [i]) * 0.5 / 32768.0;  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = (L8 [i] - 64.0) / 64.0;  		}  	} else {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = L16 [i] / 32768.0;  		}  	}  } else {  	if (m_bit_per_sample == 8) {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = ((L8 [i] + R8 [i]) * 0.5 - 64.0) / 64.0;  		}  	} else {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = (L16 [i] + R16 [i]) * 0.5 / 32768.0;  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = (L8 [i] - 64.0) / 64.0;  		}  	} else {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = L16 [i] / 32768.0;  		}  	}  } else {  	if (m_bit_per_sample == 8) {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = ((L8 [i] + R8 [i]) * 0.5 - 64.0) / 64.0;  		}  	} else {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = (L16 [i] + R16 [i]) * 0.5 / 32768.0;  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = (L8 [i] - 64.0) / 64.0;  		}  	} else {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = L16 [i] / 32768.0;  		}  	}  } else {  	if (m_bit_per_sample == 8) {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = ((L8 [i] + R8 [i]) * 0.5 - 64.0) / 64.0;  		}  	} else {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = (L16 [i] + R16 [i]) * 0.5 / 32768.0;  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = (L8 [i] - 64.0) / 64.0;  		}  	} else {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = L16 [i] / 32768.0;  		}  	}  } else {  	if (m_bit_per_sample == 8) {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = ((L8 [i] + R8 [i]) * 0.5 - 64.0) / 64.0;  		}  	} else {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = (L16 [i] + R16 [i]) * 0.5 / 32768.0;  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = (L8 [i] - 64.0) / 64.0;  		}  	} else {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = L16 [i] / 32768.0;  		}  	}  } else {  	if (m_bit_per_sample == 8) {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = ((L8 [i] + R8 [i]) * 0.5 - 64.0) / 64.0;  		}  	} else {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = (L16 [i] + R16 [i]) * 0.5 / 32768.0;  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = (L8 [i] - 64.0) / 64.0;  		}  	} else {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = L16 [i] / 32768.0;  		}  	}  } else {  	if (m_bit_per_sample == 8) {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = ((L8 [i] + R8 [i]) * 0.5 - 64.0) / 64.0;  		}  	} else {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = (L16 [i] + R16 [i]) * 0.5 / 32768.0;  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = (L8 [i] - 64.0) / 64.0;  		}  	} else {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = L16 [i] / 32768.0;  		}  	}  } else {  	if (m_bit_per_sample == 8) {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = ((L8 [i] + R8 [i]) * 0.5 - 64.0) / 64.0;  		}  	} else {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = (L16 [i] + R16 [i]) * 0.5 / 32768.0;  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = (L8 [i] - 64.0) / 64.0;  		}  	} else {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = L16 [i] / 32768.0;  		}  	}  } else {  	if (m_bit_per_sample == 8) {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = ((L8 [i] + R8 [i]) * 0.5 - 64.0) / 64.0;  		}  	} else {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = (L16 [i] + R16 [i]) * 0.5 / 32768.0;  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = (L8 [i] - 64.0) / 64.0;  		}  	} else {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = L16 [i] / 32768.0;  		}  	}  } else {  	if (m_bit_per_sample == 8) {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = ((L8 [i] + R8 [i]) * 0.5 - 64.0) / 64.0;  		}  	} else {  		for (int i = cp_start; i < cp_end; i++) {  			conv [i - start_index] = (L16 [i] + R16 [i]) * 0.5 / 32768.0;  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	for (int i = cp_start; i < cp_end; i++) {  		conv [i - start_index] = (L8 [i] - 64.0) / 64.0;  	}  } else {  	for (int i = cp_start; i < cp_end; i++) {  		conv [i - start_index] = L16 [i] / 32768.0;  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	for (int i = cp_start; i < cp_end; i++) {  		conv [i - start_index] = (L8 [i] - 64.0) / 64.0;  	}  } else {  	for (int i = cp_start; i < cp_end; i++) {  		conv [i - start_index] = L16 [i] / 32768.0;  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	for (int i = cp_start; i < cp_end; i++) {  		conv [i - start_index] = (L8 [i] - 64.0) / 64.0;  	}  } else {  	for (int i = cp_start; i < cp_end; i++) {  		conv [i - start_index] = L16 [i] / 32768.0;  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	for (int i = cp_start; i < cp_end; i++) {  		conv [i - start_index] = (L8 [i] - 64.0) / 64.0;  	}  } else {  	for (int i = cp_start; i < cp_end; i++) {  		conv [i - start_index] = L16 [i] / 32768.0;  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: for (int i = cp_start; i < cp_end; i++) {  	conv [i - start_index] = (L8 [i] - 64.0) / 64.0;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: for (int i = cp_start; i < cp_end; i++) {  	conv [i - start_index] = (L8 [i] - 64.0) / 64.0;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: conv [i - start_index] = (L8 [i] - 64.0) / 64.0;  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: conv [i - start_index] = (L8 [i] - 64.0) / 64.0;  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: for (int i = cp_start; i < cp_end; i++) {  	conv [i - start_index] = L16 [i] / 32768.0;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: conv [i - start_index] = L16 [i] / 32768.0;  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	for (int i = cp_start; i < cp_end; i++) {  		conv [i - start_index] = ((L8 [i] + R8 [i]) * 0.5 - 64.0) / 64.0;  	}  } else {  	for (int i = cp_start; i < cp_end; i++) {  		conv [i - start_index] = (L16 [i] + R16 [i]) * 0.5 / 32768.0;  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	for (int i = cp_start; i < cp_end; i++) {  		conv [i - start_index] = ((L8 [i] + R8 [i]) * 0.5 - 64.0) / 64.0;  	}  } else {  	for (int i = cp_start; i < cp_end; i++) {  		conv [i - start_index] = (L16 [i] + R16 [i]) * 0.5 / 32768.0;  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	for (int i = cp_start; i < cp_end; i++) {  		conv [i - start_index] = ((L8 [i] + R8 [i]) * 0.5 - 64.0) / 64.0;  	}  } else {  	for (int i = cp_start; i < cp_end; i++) {  		conv [i - start_index] = (L16 [i] + R16 [i]) * 0.5 / 32768.0;  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	for (int i = cp_start; i < cp_end; i++) {  		conv [i - start_index] = ((L8 [i] + R8 [i]) * 0.5 - 64.0) / 64.0;  	}  } else {  	for (int i = cp_start; i < cp_end; i++) {  		conv [i - start_index] = (L16 [i] + R16 [i]) * 0.5 / 32768.0;  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	for (int i = cp_start; i < cp_end; i++) {  		conv [i - start_index] = ((L8 [i] + R8 [i]) * 0.5 - 64.0) / 64.0;  	}  } else {  	for (int i = cp_start; i < cp_end; i++) {  		conv [i - start_index] = (L16 [i] + R16 [i]) * 0.5 / 32768.0;  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	for (int i = cp_start; i < cp_end; i++) {  		conv [i - start_index] = ((L8 [i] + R8 [i]) * 0.5 - 64.0) / 64.0;  	}  } else {  	for (int i = cp_start; i < cp_end; i++) {  		conv [i - start_index] = (L16 [i] + R16 [i]) * 0.5 / 32768.0;  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: for (int i = cp_start; i < cp_end; i++) {  	conv [i - start_index] = ((L8 [i] + R8 [i]) * 0.5 - 64.0) / 64.0;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: for (int i = cp_start; i < cp_end; i++) {  	conv [i - start_index] = ((L8 [i] + R8 [i]) * 0.5 - 64.0) / 64.0;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: for (int i = cp_start; i < cp_end; i++) {  	conv [i - start_index] = ((L8 [i] + R8 [i]) * 0.5 - 64.0) / 64.0;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: conv [i - start_index] = ((L8 [i] + R8 [i]) * 0.5 - 64.0) / 64.0;  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: conv [i - start_index] = ((L8 [i] + R8 [i]) * 0.5 - 64.0) / 64.0;  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: conv [i - start_index] = ((L8 [i] + R8 [i]) * 0.5 - 64.0) / 64.0;  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: for (int i = cp_start; i < cp_end; i++) {  	conv [i - start_index] = (L16 [i] + R16 [i]) * 0.5 / 32768.0;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: for (int i = cp_start; i < cp_end; i++) {  	conv [i - start_index] = (L16 [i] + R16 [i]) * 0.5 / 32768.0;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: conv [i - start_index] = (L16 [i] + R16 [i]) * 0.5 / 32768.0;  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getNormalizedWave,The following statement contains a magic number: conv [i - start_index] = (L16 [i] + R16 [i]) * 0.5 / 32768.0;  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,set,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral || channel == Channel.Left) {  	if (m_bit_per_sample == 8) {  		L8 [index] = (byte)value;  	} else {  		L16 [index] = (short)value;  	}  } else {  	if (m_bit_per_sample == 8) {  		R8 [index] = (byte)value;  	} else {  		R16 [index] = (short)value;  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,set,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral || channel == Channel.Left) {  	if (m_bit_per_sample == 8) {  		L8 [index] = (byte)value;  	} else {  		L16 [index] = (short)value;  	}  } else {  	if (m_bit_per_sample == 8) {  		R8 [index] = (byte)value;  	} else {  		R16 [index] = (short)value;  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,set,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	L8 [index] = (byte)value;  } else {  	L16 [index] = (short)value;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,set,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	R8 [index] = (byte)value;  } else {  	R16 [index] = (short)value;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,get,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral || channel == Channel.Left) {  	if (m_bit_per_sample == 8) {  		return L8 [index];  	} else {  		return L16 [index];  	}  } else {  	if (m_bit_per_sample == 8) {  		return R8 [index];  	} else {  		return R16 [index];  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,get,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral || channel == Channel.Left) {  	if (m_bit_per_sample == 8) {  		return L8 [index];  	} else {  		return L16 [index];  	}  } else {  	if (m_bit_per_sample == 8) {  		return R8 [index];  	} else {  		return R16 [index];  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,get,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	return L8 [index];  } else {  	return L16 [index];  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,get,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	return R8 [index];  } else {  	return R16 [index];  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		return (L8 [index] - 64.0) / 64.0;  	} else {  		return L16 [index] / 32768.0;  	}  } else {  	if (m_bit_per_sample == 8) {  		return ((L8 [index] + R8 [index]) * 0.5 - 64.0) / 64.0;  	} else {  		return (L16 [index] + R16 [index]) * 0.5 / 32768.0;  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		return (L8 [index] - 64.0) / 64.0;  	} else {  		return L16 [index] / 32768.0;  	}  } else {  	if (m_bit_per_sample == 8) {  		return ((L8 [index] + R8 [index]) * 0.5 - 64.0) / 64.0;  	} else {  		return (L16 [index] + R16 [index]) * 0.5 / 32768.0;  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		return (L8 [index] - 64.0) / 64.0;  	} else {  		return L16 [index] / 32768.0;  	}  } else {  	if (m_bit_per_sample == 8) {  		return ((L8 [index] + R8 [index]) * 0.5 - 64.0) / 64.0;  	} else {  		return (L16 [index] + R16 [index]) * 0.5 / 32768.0;  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		return (L8 [index] - 64.0) / 64.0;  	} else {  		return L16 [index] / 32768.0;  	}  } else {  	if (m_bit_per_sample == 8) {  		return ((L8 [index] + R8 [index]) * 0.5 - 64.0) / 64.0;  	} else {  		return (L16 [index] + R16 [index]) * 0.5 / 32768.0;  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		return (L8 [index] - 64.0) / 64.0;  	} else {  		return L16 [index] / 32768.0;  	}  } else {  	if (m_bit_per_sample == 8) {  		return ((L8 [index] + R8 [index]) * 0.5 - 64.0) / 64.0;  	} else {  		return (L16 [index] + R16 [index]) * 0.5 / 32768.0;  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		return (L8 [index] - 64.0) / 64.0;  	} else {  		return L16 [index] / 32768.0;  	}  } else {  	if (m_bit_per_sample == 8) {  		return ((L8 [index] + R8 [index]) * 0.5 - 64.0) / 64.0;  	} else {  		return (L16 [index] + R16 [index]) * 0.5 / 32768.0;  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		return (L8 [index] - 64.0) / 64.0;  	} else {  		return L16 [index] / 32768.0;  	}  } else {  	if (m_bit_per_sample == 8) {  		return ((L8 [index] + R8 [index]) * 0.5 - 64.0) / 64.0;  	} else {  		return (L16 [index] + R16 [index]) * 0.5 / 32768.0;  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		return (L8 [index] - 64.0) / 64.0;  	} else {  		return L16 [index] / 32768.0;  	}  } else {  	if (m_bit_per_sample == 8) {  		return ((L8 [index] + R8 [index]) * 0.5 - 64.0) / 64.0;  	} else {  		return (L16 [index] + R16 [index]) * 0.5 / 32768.0;  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		return (L8 [index] - 64.0) / 64.0;  	} else {  		return L16 [index] / 32768.0;  	}  } else {  	if (m_bit_per_sample == 8) {  		return ((L8 [index] + R8 [index]) * 0.5 - 64.0) / 64.0;  	} else {  		return (L16 [index] + R16 [index]) * 0.5 / 32768.0;  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		return (L8 [index] - 64.0) / 64.0;  	} else {  		return L16 [index] / 32768.0;  	}  } else {  	if (m_bit_per_sample == 8) {  		return ((L8 [index] + R8 [index]) * 0.5 - 64.0) / 64.0;  	} else {  		return (L16 [index] + R16 [index]) * 0.5 / 32768.0;  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	return (L8 [index] - 64.0) / 64.0;  } else {  	return L16 [index] / 32768.0;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	return (L8 [index] - 64.0) / 64.0;  } else {  	return L16 [index] / 32768.0;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	return (L8 [index] - 64.0) / 64.0;  } else {  	return L16 [index] / 32768.0;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	return (L8 [index] - 64.0) / 64.0;  } else {  	return L16 [index] / 32768.0;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: return (L8 [index] - 64.0) / 64.0;  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: return (L8 [index] - 64.0) / 64.0;  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: return L16 [index] / 32768.0;  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	return ((L8 [index] + R8 [index]) * 0.5 - 64.0) / 64.0;  } else {  	return (L16 [index] + R16 [index]) * 0.5 / 32768.0;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	return ((L8 [index] + R8 [index]) * 0.5 - 64.0) / 64.0;  } else {  	return (L16 [index] + R16 [index]) * 0.5 / 32768.0;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	return ((L8 [index] + R8 [index]) * 0.5 - 64.0) / 64.0;  } else {  	return (L16 [index] + R16 [index]) * 0.5 / 32768.0;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	return ((L8 [index] + R8 [index]) * 0.5 - 64.0) / 64.0;  } else {  	return (L16 [index] + R16 [index]) * 0.5 / 32768.0;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	return ((L8 [index] + R8 [index]) * 0.5 - 64.0) / 64.0;  } else {  	return (L16 [index] + R16 [index]) * 0.5 / 32768.0;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	return ((L8 [index] + R8 [index]) * 0.5 - 64.0) / 64.0;  } else {  	return (L16 [index] + R16 [index]) * 0.5 / 32768.0;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: return ((L8 [index] + R8 [index]) * 0.5 - 64.0) / 64.0;  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: return ((L8 [index] + R8 [index]) * 0.5 - 64.0) / 64.0;  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: return ((L8 [index] + R8 [index]) * 0.5 - 64.0) / 64.0;  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: return (L16 [index] + R16 [index]) * 0.5 / 32768.0;  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,getDouble,The following statement contains a magic number: return (L16 [index] + R16 [index]) * 0.5 / 32768.0;  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,setTotalSamples,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		if (L8 == null) {  			L8 = new byte[(int)m_total_samples];  		} else {  			L8 = resizeArray (L8' (int)m_total_samples);  		}  	} else {  		if (L16 == null) {  			L16 = new short[(int)m_total_samples];  		} else {  			L16 = resizeArray (L16' (int)m_total_samples);  		}  	}  } else {  	if (m_bit_per_sample == 8) {  		if (L8 == null) {  			L8 = new byte[(int)m_total_samples];  			R8 = new byte[(int)m_total_samples];  		} else {  			L8 = resizeArray (L8' (int)m_total_samples);  			R8 = resizeArray (R8' (int)m_total_samples);  		}  	} else {  		if (L16 == null) {  			L16 = new short[(int)m_total_samples];  			R16 = new short[(int)m_total_samples];  		} else {  			L16 = resizeArray (L16' (int)m_total_samples);  			R16 = resizeArray (R16' (int)m_total_samples);  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,setTotalSamples,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		if (L8 == null) {  			L8 = new byte[(int)m_total_samples];  		} else {  			L8 = resizeArray (L8' (int)m_total_samples);  		}  	} else {  		if (L16 == null) {  			L16 = new short[(int)m_total_samples];  		} else {  			L16 = resizeArray (L16' (int)m_total_samples);  		}  	}  } else {  	if (m_bit_per_sample == 8) {  		if (L8 == null) {  			L8 = new byte[(int)m_total_samples];  			R8 = new byte[(int)m_total_samples];  		} else {  			L8 = resizeArray (L8' (int)m_total_samples);  			R8 = resizeArray (R8' (int)m_total_samples);  		}  	} else {  		if (L16 == null) {  			L16 = new short[(int)m_total_samples];  			R16 = new short[(int)m_total_samples];  		} else {  			L16 = resizeArray (L16' (int)m_total_samples);  			R16 = resizeArray (R16' (int)m_total_samples);  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,setTotalSamples,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (L8 == null) {  		L8 = new byte[(int)m_total_samples];  	} else {  		L8 = resizeArray (L8' (int)m_total_samples);  	}  } else {  	if (L16 == null) {  		L16 = new short[(int)m_total_samples];  	} else {  		L16 = resizeArray (L16' (int)m_total_samples);  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,setTotalSamples,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (L8 == null) {  		L8 = new byte[(int)m_total_samples];  		R8 = new byte[(int)m_total_samples];  	} else {  		L8 = resizeArray (L8' (int)m_total_samples);  		R8 = resizeArray (R8' (int)m_total_samples);  	}  } else {  	if (L16 == null) {  		L16 = new short[(int)m_total_samples];  		R16 = new short[(int)m_total_samples];  	} else {  		L16 = resizeArray (L16' (int)m_total_samples);  		R16 = resizeArray (R16' (int)m_total_samples);  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		if (L8 == null || srcWave.L8 == null) {  			return;  		}  	} else {  		if (L16 == null || srcWave.L16 == null) {  			return;  		}  	}  } else {  	if (m_bit_per_sample == 8) {  		if (L8 == null || R8 == null || srcWave.L8 == null || srcWave.R8 == null) {  			return;  		}  	} else {  		if (L16 == null || R16 == null || srcWave.L16 == null || srcWave.R16 == null) {  			return;  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		if (L8 == null || srcWave.L8 == null) {  			return;  		}  	} else {  		if (L16 == null || srcWave.L16 == null) {  			return;  		}  	}  } else {  	if (m_bit_per_sample == 8) {  		if (L8 == null || R8 == null || srcWave.L8 == null || srcWave.R8 == null) {  			return;  		}  	} else {  		if (L16 == null || R16 == null || srcWave.L16 == null || srcWave.R16 == null) {  			return;  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (L8 == null || srcWave.L8 == null) {  		return;  	}  } else {  	if (L16 == null || srcWave.L16 == null) {  		return;  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (L8 == null || R8 == null || srcWave.L8 == null || srcWave.R8 == null) {  		return;  	}  } else {  	if (L16 == null || R16 == null || srcWave.L16 == null || srcWave.R16 == null) {  		return;  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_total_samples < new_last_index) {  	if (m_channel == WaveChannel.Monoral) {  		if (m_bit_per_sample == 8) {  			L8 = resizeArray (L8' (int)new_last_index);  		} else {  			L16 = resizeArray (L16' (int)new_last_index);  		}  	} else {  		if (m_bit_per_sample == 8) {  			L8 = resizeArray (L8' (int)new_last_index);  			R8 = resizeArray (R8' (int)new_last_index);  		} else {  			L16 = resizeArray (L16' (int)new_last_index);  			R16 = resizeArray (R16' (int)new_last_index);  		}  	}  	m_total_samples = new_last_index;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_total_samples < new_last_index) {  	if (m_channel == WaveChannel.Monoral) {  		if (m_bit_per_sample == 8) {  			L8 = resizeArray (L8' (int)new_last_index);  		} else {  			L16 = resizeArray (L16' (int)new_last_index);  		}  	} else {  		if (m_bit_per_sample == 8) {  			L8 = resizeArray (L8' (int)new_last_index);  			R8 = resizeArray (R8' (int)new_last_index);  		} else {  			L16 = resizeArray (L16' (int)new_last_index);  			R16 = resizeArray (R16' (int)new_last_index);  		}  	}  	m_total_samples = new_last_index;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		L8 = resizeArray (L8' (int)new_last_index);  	} else {  		L16 = resizeArray (L16' (int)new_last_index);  	}  } else {  	if (m_bit_per_sample == 8) {  		L8 = resizeArray (L8' (int)new_last_index);  		R8 = resizeArray (R8' (int)new_last_index);  	} else {  		L16 = resizeArray (L16' (int)new_last_index);  		R16 = resizeArray (R16' (int)new_last_index);  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		L8 = resizeArray (L8' (int)new_last_index);  	} else {  		L16 = resizeArray (L16' (int)new_last_index);  	}  } else {  	if (m_bit_per_sample == 8) {  		L8 = resizeArray (L8' (int)new_last_index);  		R8 = resizeArray (R8' (int)new_last_index);  	} else {  		L16 = resizeArray (L16' (int)new_last_index);  		R16 = resizeArray (R16' (int)new_last_index);  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	L8 = resizeArray (L8' (int)new_last_index);  } else {  	L16 = resizeArray (L16' (int)new_last_index);  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	L8 = resizeArray (L8' (int)new_last_index);  	R8 = resizeArray (R8' (int)new_last_index);  } else {  	L16 = resizeArray (L16' (int)new_last_index);  	R16 = resizeArray (R16' (int)new_last_index);  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		copyArray (srcWave.L8' srcStart' L8' destStart' count);  	} else {  		copyArray (srcWave.L16' srcStart' L16' destStart' count);  	}  } else {  	if (m_bit_per_sample == 8) {  		copyArray (srcWave.L8' srcStart' L8' destStart' count);  		copyArray (srcWave.R8' srcStart' R8' destStart' count);  	} else {  		copyArray (srcWave.L16' srcStart' L16' destStart' count);  		copyArray (srcWave.R16' srcStart' R16' destStart' count);  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		copyArray (srcWave.L8' srcStart' L8' destStart' count);  	} else {  		copyArray (srcWave.L16' srcStart' L16' destStart' count);  	}  } else {  	if (m_bit_per_sample == 8) {  		copyArray (srcWave.L8' srcStart' L8' destStart' count);  		copyArray (srcWave.R8' srcStart' R8' destStart' count);  	} else {  		copyArray (srcWave.L16' srcStart' L16' destStart' count);  		copyArray (srcWave.R16' srcStart' R16' destStart' count);  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	copyArray (srcWave.L8' srcStart' L8' destStart' count);  } else {  	copyArray (srcWave.L16' srcStart' L16' destStart' count);  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	copyArray (srcWave.L8' srcStart' L8' destStart' count);  	copyArray (srcWave.R8' srcStart' R8' destStart' count);  } else {  	copyArray (srcWave.L16' srcStart' L16' destStart' count);  	copyArray (srcWave.R16' srcStart' R16' destStart' count);  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_channel != WaveChannel.Monoral || m_bit_per_sample != 8 || L8 == null) {  	return;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_channel != WaveChannel.Monoral || m_bit_per_sample != 16 || L16 == null) {  	return;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_channel != WaveChannel.Stereo || m_bit_per_sample != 8 || L8 == null || R8 == null) {  	return;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_channel != WaveChannel.Stereo || m_bit_per_sample != 16 || L16 == null || R16 == null) {  	return;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_total_samples < new_last_index) {  	if (m_channel == WaveChannel.Monoral) {  		if (m_bit_per_sample == 8) {  			if (L8 == null) {  				return;  			}  			L8 = resizeArray (L8' (int)new_last_index);  		} else {  			if (L16 == null) {  				return;  			}  			L16 = resizeArray (L16' (int)new_last_index);  		}  	} else {  		if (m_bit_per_sample == 8) {  			if (L8 == null || R8 == null) {  				return;  			}  			L8 = resizeArray (L8' (int)new_last_index);  			R8 = resizeArray (R8' (int)new_last_index);  		} else {  			if (L16 == null || R16 == null) {  				return;  			}  			L16 = resizeArray (L16' (int)new_last_index);  			R16 = resizeArray (R16' (int)new_last_index);  		}  	}  	m_total_samples = new_last_index;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_total_samples < new_last_index) {  	if (m_channel == WaveChannel.Monoral) {  		if (m_bit_per_sample == 8) {  			if (L8 == null) {  				return;  			}  			L8 = resizeArray (L8' (int)new_last_index);  		} else {  			if (L16 == null) {  				return;  			}  			L16 = resizeArray (L16' (int)new_last_index);  		}  	} else {  		if (m_bit_per_sample == 8) {  			if (L8 == null || R8 == null) {  				return;  			}  			L8 = resizeArray (L8' (int)new_last_index);  			R8 = resizeArray (R8' (int)new_last_index);  		} else {  			if (L16 == null || R16 == null) {  				return;  			}  			L16 = resizeArray (L16' (int)new_last_index);  			R16 = resizeArray (R16' (int)new_last_index);  		}  	}  	m_total_samples = new_last_index;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		if (L8 == null) {  			return;  		}  		L8 = resizeArray (L8' (int)new_last_index);  	} else {  		if (L16 == null) {  			return;  		}  		L16 = resizeArray (L16' (int)new_last_index);  	}  } else {  	if (m_bit_per_sample == 8) {  		if (L8 == null || R8 == null) {  			return;  		}  		L8 = resizeArray (L8' (int)new_last_index);  		R8 = resizeArray (R8' (int)new_last_index);  	} else {  		if (L16 == null || R16 == null) {  			return;  		}  		L16 = resizeArray (L16' (int)new_last_index);  		R16 = resizeArray (R16' (int)new_last_index);  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		if (L8 == null) {  			return;  		}  		L8 = resizeArray (L8' (int)new_last_index);  	} else {  		if (L16 == null) {  			return;  		}  		L16 = resizeArray (L16' (int)new_last_index);  	}  } else {  	if (m_bit_per_sample == 8) {  		if (L8 == null || R8 == null) {  			return;  		}  		L8 = resizeArray (L8' (int)new_last_index);  		R8 = resizeArray (R8' (int)new_last_index);  	} else {  		if (L16 == null || R16 == null) {  			return;  		}  		L16 = resizeArray (L16' (int)new_last_index);  		R16 = resizeArray (R16' (int)new_last_index);  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (L8 == null) {  		return;  	}  	L8 = resizeArray (L8' (int)new_last_index);  } else {  	if (L16 == null) {  		return;  	}  	L16 = resizeArray (L16' (int)new_last_index);  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (L8 == null || R8 == null) {  		return;  	}  	L8 = resizeArray (L8' (int)new_last_index);  	R8 = resizeArray (R8' (int)new_last_index);  } else {  	if (L16 == null || R16 == null) {  		return;  	}  	L16 = resizeArray (L16' (int)new_last_index);  	R16 = resizeArray (R16' (int)new_last_index);  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	float[] mono = new float[left.Length];  	for (int i = 0; i < left.Length; i++) {  		mono [i] = (left [i] + right [i]) / 2f;  	}  	if (m_bit_per_sample == 8) {  		for (int i = 0; i < mono.Length; i++) {  			L8 [i + start_index] = (byte)((mono [i] + 1.0f) / 2f * 255f);  		}  	} else {  		for (int i = 0; i < mono.Length; i++) {  			L16 [i + start_index] = (short)(mono [i] * 32768f);  		}  	}  } else {  	if (m_bit_per_sample == 8) {  		for (int i = 0; i < left.Length; i++) {  			L8 [i + start_index] = (byte)((left [i] + 1.0f) / 2f * 255f);  			R8 [i + start_index] = (byte)((right [i] + 1.0f) / 2f * 255f);  		}  	} else {  		for (int i = 0; i < left.Length; i++) {  			L16 [i + start_index] = (short)(left [i] * 32768f);  			R16 [i + start_index] = (short)(right [i] * 32768f);  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	float[] mono = new float[left.Length];  	for (int i = 0; i < left.Length; i++) {  		mono [i] = (left [i] + right [i]) / 2f;  	}  	if (m_bit_per_sample == 8) {  		for (int i = 0; i < mono.Length; i++) {  			L8 [i + start_index] = (byte)((mono [i] + 1.0f) / 2f * 255f);  		}  	} else {  		for (int i = 0; i < mono.Length; i++) {  			L16 [i + start_index] = (short)(mono [i] * 32768f);  		}  	}  } else {  	if (m_bit_per_sample == 8) {  		for (int i = 0; i < left.Length; i++) {  			L8 [i + start_index] = (byte)((left [i] + 1.0f) / 2f * 255f);  			R8 [i + start_index] = (byte)((right [i] + 1.0f) / 2f * 255f);  		}  	} else {  		for (int i = 0; i < left.Length; i++) {  			L16 [i + start_index] = (short)(left [i] * 32768f);  			R16 [i + start_index] = (short)(right [i] * 32768f);  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	for (int i = 0; i < mono.Length; i++) {  		L8 [i + start_index] = (byte)((mono [i] + 1.0f) / 2f * 255f);  	}  } else {  	for (int i = 0; i < mono.Length; i++) {  		L16 [i + start_index] = (short)(mono [i] * 32768f);  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,replace,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	for (int i = 0; i < left.Length; i++) {  		L8 [i + start_index] = (byte)((left [i] + 1.0f) / 2f * 255f);  		R8 [i + start_index] = (byte)((right [i] + 1.0f) / 2f * 255f);  	}  } else {  	for (int i = 0; i < left.Length; i++) {  		L16 [i + start_index] = (short)(left [i] * 32768f);  		R16 [i + start_index] = (short)(right [i] * 32768f);  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,printToText,The following statement contains a magic number: try {  	sw = new BufferedWriter (new FileWriter (path));  	if (m_channel == WaveChannel.Monoral) {  		if (m_bit_per_sample == 8) {  			for (int i = 0; i < m_total_samples; i++) {  				sw.write (L8 [i] + "");  				sw.newLine ();  			}  		} else {  			for (int i = 0; i < m_total_samples; i++) {  				sw.write (L16 [i] + "");  				sw.newLine ();  			}  		}  	} else {  		if (m_bit_per_sample == 8) {  			for (int i = 0; i < m_total_samples; i++) {  				sw.write (L8 [i] + "\t" + R8 [i]);  				sw.newLine ();  			}  		} else {  			for (int i = 0; i < m_total_samples; i++) {  				sw.write (L16 [i] + "\t" + R16 [i]);  				sw.newLine ();  			}  		}  	}  } catch (Exception ex) {  } finally {  	if (sw != null) {  		try {  			sw.close ();  		} catch (Exception ex2) {  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,printToText,The following statement contains a magic number: try {  	sw = new BufferedWriter (new FileWriter (path));  	if (m_channel == WaveChannel.Monoral) {  		if (m_bit_per_sample == 8) {  			for (int i = 0; i < m_total_samples; i++) {  				sw.write (L8 [i] + "");  				sw.newLine ();  			}  		} else {  			for (int i = 0; i < m_total_samples; i++) {  				sw.write (L16 [i] + "");  				sw.newLine ();  			}  		}  	} else {  		if (m_bit_per_sample == 8) {  			for (int i = 0; i < m_total_samples; i++) {  				sw.write (L8 [i] + "\t" + R8 [i]);  				sw.newLine ();  			}  		} else {  			for (int i = 0; i < m_total_samples; i++) {  				sw.write (L16 [i] + "\t" + R16 [i]);  				sw.newLine ();  			}  		}  	}  } catch (Exception ex) {  } finally {  	if (sw != null) {  		try {  			sw.close ();  		} catch (Exception ex2) {  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,printToText,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		for (int i = 0; i < m_total_samples; i++) {  			sw.write (L8 [i] + "");  			sw.newLine ();  		}  	} else {  		for (int i = 0; i < m_total_samples; i++) {  			sw.write (L16 [i] + "");  			sw.newLine ();  		}  	}  } else {  	if (m_bit_per_sample == 8) {  		for (int i = 0; i < m_total_samples; i++) {  			sw.write (L8 [i] + "\t" + R8 [i]);  			sw.newLine ();  		}  	} else {  		for (int i = 0; i < m_total_samples; i++) {  			sw.write (L16 [i] + "\t" + R16 [i]);  			sw.newLine ();  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,printToText,The following statement contains a magic number: if (m_channel == WaveChannel.Monoral) {  	if (m_bit_per_sample == 8) {  		for (int i = 0; i < m_total_samples; i++) {  			sw.write (L8 [i] + "");  			sw.newLine ();  		}  	} else {  		for (int i = 0; i < m_total_samples; i++) {  			sw.write (L16 [i] + "");  			sw.newLine ();  		}  	}  } else {  	if (m_bit_per_sample == 8) {  		for (int i = 0; i < m_total_samples; i++) {  			sw.write (L8 [i] + "\t" + R8 [i]);  			sw.newLine ();  		}  	} else {  		for (int i = 0; i < m_total_samples; i++) {  			sw.write (L16 [i] + "\t" + R16 [i]);  			sw.newLine ();  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,printToText,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	for (int i = 0; i < m_total_samples; i++) {  		sw.write (L8 [i] + "");  		sw.newLine ();  	}  } else {  	for (int i = 0; i < m_total_samples; i++) {  		sw.write (L16 [i] + "");  		sw.newLine ();  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,printToText,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	for (int i = 0; i < m_total_samples; i++) {  		sw.write (L8 [i] + "\t" + R8 [i]);  		sw.newLine ();  	}  } else {  	for (int i = 0; i < m_total_samples; i++) {  		sw.write (L16 [i] + "\t" + R16 [i]);  		sw.newLine ();  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,convertTo8Bit,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	return;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,convertTo8Bit,The following statement contains a magic number: for (int i = 0; i < L16.Length; i++) {  	double new_val = (L16 [i] + 32768.0) / 65535.0 * 255.0;  	L8 [i] = (byte)new_val;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,convertTo8Bit,The following statement contains a magic number: for (int i = 0; i < L16.Length; i++) {  	double new_val = (L16 [i] + 32768.0) / 65535.0 * 255.0;  	L8 [i] = (byte)new_val;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,convertTo8Bit,The following statement contains a magic number: for (int i = 0; i < L16.Length; i++) {  	double new_val = (L16 [i] + 32768.0) / 65535.0 * 255.0;  	L8 [i] = (byte)new_val;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,convertTo8Bit,The following statement contains a magic number: if (m_channel == WaveChannel.Stereo) {  	R8 = new byte[R16.Length];  	for (int i = 0; i < R16.Length; i++) {  		double new_val = (R16 [i] + 32768.0) / 65535.0 * 255.0;  		R8 [i] = (byte)new_val;  	}  	R16 = null;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,convertTo8Bit,The following statement contains a magic number: if (m_channel == WaveChannel.Stereo) {  	R8 = new byte[R16.Length];  	for (int i = 0; i < R16.Length; i++) {  		double new_val = (R16 [i] + 32768.0) / 65535.0 * 255.0;  		R8 [i] = (byte)new_val;  	}  	R16 = null;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,convertTo8Bit,The following statement contains a magic number: if (m_channel == WaveChannel.Stereo) {  	R8 = new byte[R16.Length];  	for (int i = 0; i < R16.Length; i++) {  		double new_val = (R16 [i] + 32768.0) / 65535.0 * 255.0;  		R8 [i] = (byte)new_val;  	}  	R16 = null;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,convertTo8Bit,The following statement contains a magic number: for (int i = 0; i < R16.Length; i++) {  	double new_val = (R16 [i] + 32768.0) / 65535.0 * 255.0;  	R8 [i] = (byte)new_val;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,convertTo8Bit,The following statement contains a magic number: for (int i = 0; i < R16.Length; i++) {  	double new_val = (R16 [i] + 32768.0) / 65535.0 * 255.0;  	R8 [i] = (byte)new_val;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,convertTo8Bit,The following statement contains a magic number: for (int i = 0; i < R16.Length; i++) {  	double new_val = (R16 [i] + 32768.0) / 65535.0 * 255.0;  	R8 [i] = (byte)new_val;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,convertTo8Bit,The following statement contains a magic number: m_bit_per_sample = 8;  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: try {  	fs = new RandomAccessFile (file' "rw");  	// RIFF  	fs.write (0x52);  	fs.write (0x49);  	fs.write (0x46);  	fs.write (0x46);  	// ファイルサイズ - 8最後に記入  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	// WAVE  	fs.write (0x57);  	fs.write (0x41);  	fs.write (0x56);  	fs.write (0x45);  	// fmt   	fs.write (0x66);  	fs.write (0x6d);  	fs.write (0x74);  	fs.write (0x20);  	// fmt チャンクのサイズ  	fs.write (0x12);  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	// format ID  	fs.write (0x01);  	fs.write (0x00);  	// チャンネル数  	if (m_channel == WaveChannel.Monoral) {  		fs.write (0x01);  		fs.write (0x00);  	} else {  		fs.write (0x02);  		fs.write (0x00);  	}  	// サンプリングレート  	byte[] buf = PortUtil.getbytes_uint32_le (m_sample_rate);  	writeByteArray (fs' buf' 4);  	// データ速度  	int ichannel = (m_channel == WaveChannel.Monoral) ? 1 : 2;  	int block_size = (int)(m_bit_per_sample / 8 * ichannel);  	long data_rate = m_sample_rate * block_size;  	buf = PortUtil.getbytes_uint32_le (data_rate);  	writeByteArray (fs' buf' 4);  	// ブロックサイズ  	buf = PortUtil.getbytes_uint16_le (block_size);  	writeByteArray (fs' buf' 2);  	// サンプルあたりのビット数  	buf = PortUtil.getbytes_uint16_le (m_bit_per_sample);  	writeByteArray (fs' buf' 2);  	// 拡張部分  	fs.write (0x00);  	fs.write (0x00);  	// data  	fs.write (0x64);  	fs.write (0x61);  	fs.write (0x74);  	fs.write (0x61);  	// size of data chunk  	long size = block_size * m_total_samples;  	buf = PortUtil.getbytes_uint32_le (size);  	writeByteArray (fs' buf' 4);  	// 波形データ  	for (int i = 0; i < m_total_samples; i++) {  		if (m_bit_per_sample == 8) {  			fs.write (L8 [i]);  			if (m_channel == WaveChannel.Stereo) {  				fs.write (R8 [i]);  			}  		} else {  			buf = PortUtil.getbytes_int16_le (L16 [i]);  			writeByteArray (fs' buf' 2);  			if (m_channel == WaveChannel.Stereo) {  				buf = PortUtil.getbytes_int16_le (R16 [i]);  				writeByteArray (fs' buf' 2);  			}  		}  	}  	// 最後にWAVEチャンクのサイズ  	long position = fs.getFilePointer ();  	fs.seek (4);  	buf = PortUtil.getbytes_uint32_le (position - 8);  	writeByteArray (fs' buf' 4);  } catch (Exception ex) {  } finally {  	if (fs != null) {  		try {  			fs.close ();  		} catch (Exception ex2) {  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: try {  	fs = new RandomAccessFile (file' "rw");  	// RIFF  	fs.write (0x52);  	fs.write (0x49);  	fs.write (0x46);  	fs.write (0x46);  	// ファイルサイズ - 8最後に記入  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	// WAVE  	fs.write (0x57);  	fs.write (0x41);  	fs.write (0x56);  	fs.write (0x45);  	// fmt   	fs.write (0x66);  	fs.write (0x6d);  	fs.write (0x74);  	fs.write (0x20);  	// fmt チャンクのサイズ  	fs.write (0x12);  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	// format ID  	fs.write (0x01);  	fs.write (0x00);  	// チャンネル数  	if (m_channel == WaveChannel.Monoral) {  		fs.write (0x01);  		fs.write (0x00);  	} else {  		fs.write (0x02);  		fs.write (0x00);  	}  	// サンプリングレート  	byte[] buf = PortUtil.getbytes_uint32_le (m_sample_rate);  	writeByteArray (fs' buf' 4);  	// データ速度  	int ichannel = (m_channel == WaveChannel.Monoral) ? 1 : 2;  	int block_size = (int)(m_bit_per_sample / 8 * ichannel);  	long data_rate = m_sample_rate * block_size;  	buf = PortUtil.getbytes_uint32_le (data_rate);  	writeByteArray (fs' buf' 4);  	// ブロックサイズ  	buf = PortUtil.getbytes_uint16_le (block_size);  	writeByteArray (fs' buf' 2);  	// サンプルあたりのビット数  	buf = PortUtil.getbytes_uint16_le (m_bit_per_sample);  	writeByteArray (fs' buf' 2);  	// 拡張部分  	fs.write (0x00);  	fs.write (0x00);  	// data  	fs.write (0x64);  	fs.write (0x61);  	fs.write (0x74);  	fs.write (0x61);  	// size of data chunk  	long size = block_size * m_total_samples;  	buf = PortUtil.getbytes_uint32_le (size);  	writeByteArray (fs' buf' 4);  	// 波形データ  	for (int i = 0; i < m_total_samples; i++) {  		if (m_bit_per_sample == 8) {  			fs.write (L8 [i]);  			if (m_channel == WaveChannel.Stereo) {  				fs.write (R8 [i]);  			}  		} else {  			buf = PortUtil.getbytes_int16_le (L16 [i]);  			writeByteArray (fs' buf' 2);  			if (m_channel == WaveChannel.Stereo) {  				buf = PortUtil.getbytes_int16_le (R16 [i]);  				writeByteArray (fs' buf' 2);  			}  		}  	}  	// 最後にWAVEチャンクのサイズ  	long position = fs.getFilePointer ();  	fs.seek (4);  	buf = PortUtil.getbytes_uint32_le (position - 8);  	writeByteArray (fs' buf' 4);  } catch (Exception ex) {  } finally {  	if (fs != null) {  		try {  			fs.close ();  		} catch (Exception ex2) {  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: try {  	fs = new RandomAccessFile (file' "rw");  	// RIFF  	fs.write (0x52);  	fs.write (0x49);  	fs.write (0x46);  	fs.write (0x46);  	// ファイルサイズ - 8最後に記入  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	// WAVE  	fs.write (0x57);  	fs.write (0x41);  	fs.write (0x56);  	fs.write (0x45);  	// fmt   	fs.write (0x66);  	fs.write (0x6d);  	fs.write (0x74);  	fs.write (0x20);  	// fmt チャンクのサイズ  	fs.write (0x12);  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	// format ID  	fs.write (0x01);  	fs.write (0x00);  	// チャンネル数  	if (m_channel == WaveChannel.Monoral) {  		fs.write (0x01);  		fs.write (0x00);  	} else {  		fs.write (0x02);  		fs.write (0x00);  	}  	// サンプリングレート  	byte[] buf = PortUtil.getbytes_uint32_le (m_sample_rate);  	writeByteArray (fs' buf' 4);  	// データ速度  	int ichannel = (m_channel == WaveChannel.Monoral) ? 1 : 2;  	int block_size = (int)(m_bit_per_sample / 8 * ichannel);  	long data_rate = m_sample_rate * block_size;  	buf = PortUtil.getbytes_uint32_le (data_rate);  	writeByteArray (fs' buf' 4);  	// ブロックサイズ  	buf = PortUtil.getbytes_uint16_le (block_size);  	writeByteArray (fs' buf' 2);  	// サンプルあたりのビット数  	buf = PortUtil.getbytes_uint16_le (m_bit_per_sample);  	writeByteArray (fs' buf' 2);  	// 拡張部分  	fs.write (0x00);  	fs.write (0x00);  	// data  	fs.write (0x64);  	fs.write (0x61);  	fs.write (0x74);  	fs.write (0x61);  	// size of data chunk  	long size = block_size * m_total_samples;  	buf = PortUtil.getbytes_uint32_le (size);  	writeByteArray (fs' buf' 4);  	// 波形データ  	for (int i = 0; i < m_total_samples; i++) {  		if (m_bit_per_sample == 8) {  			fs.write (L8 [i]);  			if (m_channel == WaveChannel.Stereo) {  				fs.write (R8 [i]);  			}  		} else {  			buf = PortUtil.getbytes_int16_le (L16 [i]);  			writeByteArray (fs' buf' 2);  			if (m_channel == WaveChannel.Stereo) {  				buf = PortUtil.getbytes_int16_le (R16 [i]);  				writeByteArray (fs' buf' 2);  			}  		}  	}  	// 最後にWAVEチャンクのサイズ  	long position = fs.getFilePointer ();  	fs.seek (4);  	buf = PortUtil.getbytes_uint32_le (position - 8);  	writeByteArray (fs' buf' 4);  } catch (Exception ex) {  } finally {  	if (fs != null) {  		try {  			fs.close ();  		} catch (Exception ex2) {  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: try {  	fs = new RandomAccessFile (file' "rw");  	// RIFF  	fs.write (0x52);  	fs.write (0x49);  	fs.write (0x46);  	fs.write (0x46);  	// ファイルサイズ - 8最後に記入  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	// WAVE  	fs.write (0x57);  	fs.write (0x41);  	fs.write (0x56);  	fs.write (0x45);  	// fmt   	fs.write (0x66);  	fs.write (0x6d);  	fs.write (0x74);  	fs.write (0x20);  	// fmt チャンクのサイズ  	fs.write (0x12);  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	// format ID  	fs.write (0x01);  	fs.write (0x00);  	// チャンネル数  	if (m_channel == WaveChannel.Monoral) {  		fs.write (0x01);  		fs.write (0x00);  	} else {  		fs.write (0x02);  		fs.write (0x00);  	}  	// サンプリングレート  	byte[] buf = PortUtil.getbytes_uint32_le (m_sample_rate);  	writeByteArray (fs' buf' 4);  	// データ速度  	int ichannel = (m_channel == WaveChannel.Monoral) ? 1 : 2;  	int block_size = (int)(m_bit_per_sample / 8 * ichannel);  	long data_rate = m_sample_rate * block_size;  	buf = PortUtil.getbytes_uint32_le (data_rate);  	writeByteArray (fs' buf' 4);  	// ブロックサイズ  	buf = PortUtil.getbytes_uint16_le (block_size);  	writeByteArray (fs' buf' 2);  	// サンプルあたりのビット数  	buf = PortUtil.getbytes_uint16_le (m_bit_per_sample);  	writeByteArray (fs' buf' 2);  	// 拡張部分  	fs.write (0x00);  	fs.write (0x00);  	// data  	fs.write (0x64);  	fs.write (0x61);  	fs.write (0x74);  	fs.write (0x61);  	// size of data chunk  	long size = block_size * m_total_samples;  	buf = PortUtil.getbytes_uint32_le (size);  	writeByteArray (fs' buf' 4);  	// 波形データ  	for (int i = 0; i < m_total_samples; i++) {  		if (m_bit_per_sample == 8) {  			fs.write (L8 [i]);  			if (m_channel == WaveChannel.Stereo) {  				fs.write (R8 [i]);  			}  		} else {  			buf = PortUtil.getbytes_int16_le (L16 [i]);  			writeByteArray (fs' buf' 2);  			if (m_channel == WaveChannel.Stereo) {  				buf = PortUtil.getbytes_int16_le (R16 [i]);  				writeByteArray (fs' buf' 2);  			}  		}  	}  	// 最後にWAVEチャンクのサイズ  	long position = fs.getFilePointer ();  	fs.seek (4);  	buf = PortUtil.getbytes_uint32_le (position - 8);  	writeByteArray (fs' buf' 4);  } catch (Exception ex) {  } finally {  	if (fs != null) {  		try {  			fs.close ();  		} catch (Exception ex2) {  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: try {  	fs = new RandomAccessFile (file' "rw");  	// RIFF  	fs.write (0x52);  	fs.write (0x49);  	fs.write (0x46);  	fs.write (0x46);  	// ファイルサイズ - 8最後に記入  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	// WAVE  	fs.write (0x57);  	fs.write (0x41);  	fs.write (0x56);  	fs.write (0x45);  	// fmt   	fs.write (0x66);  	fs.write (0x6d);  	fs.write (0x74);  	fs.write (0x20);  	// fmt チャンクのサイズ  	fs.write (0x12);  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	// format ID  	fs.write (0x01);  	fs.write (0x00);  	// チャンネル数  	if (m_channel == WaveChannel.Monoral) {  		fs.write (0x01);  		fs.write (0x00);  	} else {  		fs.write (0x02);  		fs.write (0x00);  	}  	// サンプリングレート  	byte[] buf = PortUtil.getbytes_uint32_le (m_sample_rate);  	writeByteArray (fs' buf' 4);  	// データ速度  	int ichannel = (m_channel == WaveChannel.Monoral) ? 1 : 2;  	int block_size = (int)(m_bit_per_sample / 8 * ichannel);  	long data_rate = m_sample_rate * block_size;  	buf = PortUtil.getbytes_uint32_le (data_rate);  	writeByteArray (fs' buf' 4);  	// ブロックサイズ  	buf = PortUtil.getbytes_uint16_le (block_size);  	writeByteArray (fs' buf' 2);  	// サンプルあたりのビット数  	buf = PortUtil.getbytes_uint16_le (m_bit_per_sample);  	writeByteArray (fs' buf' 2);  	// 拡張部分  	fs.write (0x00);  	fs.write (0x00);  	// data  	fs.write (0x64);  	fs.write (0x61);  	fs.write (0x74);  	fs.write (0x61);  	// size of data chunk  	long size = block_size * m_total_samples;  	buf = PortUtil.getbytes_uint32_le (size);  	writeByteArray (fs' buf' 4);  	// 波形データ  	for (int i = 0; i < m_total_samples; i++) {  		if (m_bit_per_sample == 8) {  			fs.write (L8 [i]);  			if (m_channel == WaveChannel.Stereo) {  				fs.write (R8 [i]);  			}  		} else {  			buf = PortUtil.getbytes_int16_le (L16 [i]);  			writeByteArray (fs' buf' 2);  			if (m_channel == WaveChannel.Stereo) {  				buf = PortUtil.getbytes_int16_le (R16 [i]);  				writeByteArray (fs' buf' 2);  			}  		}  	}  	// 最後にWAVEチャンクのサイズ  	long position = fs.getFilePointer ();  	fs.seek (4);  	buf = PortUtil.getbytes_uint32_le (position - 8);  	writeByteArray (fs' buf' 4);  } catch (Exception ex) {  } finally {  	if (fs != null) {  		try {  			fs.close ();  		} catch (Exception ex2) {  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: try {  	fs = new RandomAccessFile (file' "rw");  	// RIFF  	fs.write (0x52);  	fs.write (0x49);  	fs.write (0x46);  	fs.write (0x46);  	// ファイルサイズ - 8最後に記入  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	// WAVE  	fs.write (0x57);  	fs.write (0x41);  	fs.write (0x56);  	fs.write (0x45);  	// fmt   	fs.write (0x66);  	fs.write (0x6d);  	fs.write (0x74);  	fs.write (0x20);  	// fmt チャンクのサイズ  	fs.write (0x12);  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	// format ID  	fs.write (0x01);  	fs.write (0x00);  	// チャンネル数  	if (m_channel == WaveChannel.Monoral) {  		fs.write (0x01);  		fs.write (0x00);  	} else {  		fs.write (0x02);  		fs.write (0x00);  	}  	// サンプリングレート  	byte[] buf = PortUtil.getbytes_uint32_le (m_sample_rate);  	writeByteArray (fs' buf' 4);  	// データ速度  	int ichannel = (m_channel == WaveChannel.Monoral) ? 1 : 2;  	int block_size = (int)(m_bit_per_sample / 8 * ichannel);  	long data_rate = m_sample_rate * block_size;  	buf = PortUtil.getbytes_uint32_le (data_rate);  	writeByteArray (fs' buf' 4);  	// ブロックサイズ  	buf = PortUtil.getbytes_uint16_le (block_size);  	writeByteArray (fs' buf' 2);  	// サンプルあたりのビット数  	buf = PortUtil.getbytes_uint16_le (m_bit_per_sample);  	writeByteArray (fs' buf' 2);  	// 拡張部分  	fs.write (0x00);  	fs.write (0x00);  	// data  	fs.write (0x64);  	fs.write (0x61);  	fs.write (0x74);  	fs.write (0x61);  	// size of data chunk  	long size = block_size * m_total_samples;  	buf = PortUtil.getbytes_uint32_le (size);  	writeByteArray (fs' buf' 4);  	// 波形データ  	for (int i = 0; i < m_total_samples; i++) {  		if (m_bit_per_sample == 8) {  			fs.write (L8 [i]);  			if (m_channel == WaveChannel.Stereo) {  				fs.write (R8 [i]);  			}  		} else {  			buf = PortUtil.getbytes_int16_le (L16 [i]);  			writeByteArray (fs' buf' 2);  			if (m_channel == WaveChannel.Stereo) {  				buf = PortUtil.getbytes_int16_le (R16 [i]);  				writeByteArray (fs' buf' 2);  			}  		}  	}  	// 最後にWAVEチャンクのサイズ  	long position = fs.getFilePointer ();  	fs.seek (4);  	buf = PortUtil.getbytes_uint32_le (position - 8);  	writeByteArray (fs' buf' 4);  } catch (Exception ex) {  } finally {  	if (fs != null) {  		try {  			fs.close ();  		} catch (Exception ex2) {  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: try {  	fs = new RandomAccessFile (file' "rw");  	// RIFF  	fs.write (0x52);  	fs.write (0x49);  	fs.write (0x46);  	fs.write (0x46);  	// ファイルサイズ - 8最後に記入  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	// WAVE  	fs.write (0x57);  	fs.write (0x41);  	fs.write (0x56);  	fs.write (0x45);  	// fmt   	fs.write (0x66);  	fs.write (0x6d);  	fs.write (0x74);  	fs.write (0x20);  	// fmt チャンクのサイズ  	fs.write (0x12);  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	// format ID  	fs.write (0x01);  	fs.write (0x00);  	// チャンネル数  	if (m_channel == WaveChannel.Monoral) {  		fs.write (0x01);  		fs.write (0x00);  	} else {  		fs.write (0x02);  		fs.write (0x00);  	}  	// サンプリングレート  	byte[] buf = PortUtil.getbytes_uint32_le (m_sample_rate);  	writeByteArray (fs' buf' 4);  	// データ速度  	int ichannel = (m_channel == WaveChannel.Monoral) ? 1 : 2;  	int block_size = (int)(m_bit_per_sample / 8 * ichannel);  	long data_rate = m_sample_rate * block_size;  	buf = PortUtil.getbytes_uint32_le (data_rate);  	writeByteArray (fs' buf' 4);  	// ブロックサイズ  	buf = PortUtil.getbytes_uint16_le (block_size);  	writeByteArray (fs' buf' 2);  	// サンプルあたりのビット数  	buf = PortUtil.getbytes_uint16_le (m_bit_per_sample);  	writeByteArray (fs' buf' 2);  	// 拡張部分  	fs.write (0x00);  	fs.write (0x00);  	// data  	fs.write (0x64);  	fs.write (0x61);  	fs.write (0x74);  	fs.write (0x61);  	// size of data chunk  	long size = block_size * m_total_samples;  	buf = PortUtil.getbytes_uint32_le (size);  	writeByteArray (fs' buf' 4);  	// 波形データ  	for (int i = 0; i < m_total_samples; i++) {  		if (m_bit_per_sample == 8) {  			fs.write (L8 [i]);  			if (m_channel == WaveChannel.Stereo) {  				fs.write (R8 [i]);  			}  		} else {  			buf = PortUtil.getbytes_int16_le (L16 [i]);  			writeByteArray (fs' buf' 2);  			if (m_channel == WaveChannel.Stereo) {  				buf = PortUtil.getbytes_int16_le (R16 [i]);  				writeByteArray (fs' buf' 2);  			}  		}  	}  	// 最後にWAVEチャンクのサイズ  	long position = fs.getFilePointer ();  	fs.seek (4);  	buf = PortUtil.getbytes_uint32_le (position - 8);  	writeByteArray (fs' buf' 4);  } catch (Exception ex) {  } finally {  	if (fs != null) {  		try {  			fs.close ();  		} catch (Exception ex2) {  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: try {  	fs = new RandomAccessFile (file' "rw");  	// RIFF  	fs.write (0x52);  	fs.write (0x49);  	fs.write (0x46);  	fs.write (0x46);  	// ファイルサイズ - 8最後に記入  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	// WAVE  	fs.write (0x57);  	fs.write (0x41);  	fs.write (0x56);  	fs.write (0x45);  	// fmt   	fs.write (0x66);  	fs.write (0x6d);  	fs.write (0x74);  	fs.write (0x20);  	// fmt チャンクのサイズ  	fs.write (0x12);  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	// format ID  	fs.write (0x01);  	fs.write (0x00);  	// チャンネル数  	if (m_channel == WaveChannel.Monoral) {  		fs.write (0x01);  		fs.write (0x00);  	} else {  		fs.write (0x02);  		fs.write (0x00);  	}  	// サンプリングレート  	byte[] buf = PortUtil.getbytes_uint32_le (m_sample_rate);  	writeByteArray (fs' buf' 4);  	// データ速度  	int ichannel = (m_channel == WaveChannel.Monoral) ? 1 : 2;  	int block_size = (int)(m_bit_per_sample / 8 * ichannel);  	long data_rate = m_sample_rate * block_size;  	buf = PortUtil.getbytes_uint32_le (data_rate);  	writeByteArray (fs' buf' 4);  	// ブロックサイズ  	buf = PortUtil.getbytes_uint16_le (block_size);  	writeByteArray (fs' buf' 2);  	// サンプルあたりのビット数  	buf = PortUtil.getbytes_uint16_le (m_bit_per_sample);  	writeByteArray (fs' buf' 2);  	// 拡張部分  	fs.write (0x00);  	fs.write (0x00);  	// data  	fs.write (0x64);  	fs.write (0x61);  	fs.write (0x74);  	fs.write (0x61);  	// size of data chunk  	long size = block_size * m_total_samples;  	buf = PortUtil.getbytes_uint32_le (size);  	writeByteArray (fs' buf' 4);  	// 波形データ  	for (int i = 0; i < m_total_samples; i++) {  		if (m_bit_per_sample == 8) {  			fs.write (L8 [i]);  			if (m_channel == WaveChannel.Stereo) {  				fs.write (R8 [i]);  			}  		} else {  			buf = PortUtil.getbytes_int16_le (L16 [i]);  			writeByteArray (fs' buf' 2);  			if (m_channel == WaveChannel.Stereo) {  				buf = PortUtil.getbytes_int16_le (R16 [i]);  				writeByteArray (fs' buf' 2);  			}  		}  	}  	// 最後にWAVEチャンクのサイズ  	long position = fs.getFilePointer ();  	fs.seek (4);  	buf = PortUtil.getbytes_uint32_le (position - 8);  	writeByteArray (fs' buf' 4);  } catch (Exception ex) {  } finally {  	if (fs != null) {  		try {  			fs.close ();  		} catch (Exception ex2) {  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: try {  	fs = new RandomAccessFile (file' "rw");  	// RIFF  	fs.write (0x52);  	fs.write (0x49);  	fs.write (0x46);  	fs.write (0x46);  	// ファイルサイズ - 8最後に記入  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	// WAVE  	fs.write (0x57);  	fs.write (0x41);  	fs.write (0x56);  	fs.write (0x45);  	// fmt   	fs.write (0x66);  	fs.write (0x6d);  	fs.write (0x74);  	fs.write (0x20);  	// fmt チャンクのサイズ  	fs.write (0x12);  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	// format ID  	fs.write (0x01);  	fs.write (0x00);  	// チャンネル数  	if (m_channel == WaveChannel.Monoral) {  		fs.write (0x01);  		fs.write (0x00);  	} else {  		fs.write (0x02);  		fs.write (0x00);  	}  	// サンプリングレート  	byte[] buf = PortUtil.getbytes_uint32_le (m_sample_rate);  	writeByteArray (fs' buf' 4);  	// データ速度  	int ichannel = (m_channel == WaveChannel.Monoral) ? 1 : 2;  	int block_size = (int)(m_bit_per_sample / 8 * ichannel);  	long data_rate = m_sample_rate * block_size;  	buf = PortUtil.getbytes_uint32_le (data_rate);  	writeByteArray (fs' buf' 4);  	// ブロックサイズ  	buf = PortUtil.getbytes_uint16_le (block_size);  	writeByteArray (fs' buf' 2);  	// サンプルあたりのビット数  	buf = PortUtil.getbytes_uint16_le (m_bit_per_sample);  	writeByteArray (fs' buf' 2);  	// 拡張部分  	fs.write (0x00);  	fs.write (0x00);  	// data  	fs.write (0x64);  	fs.write (0x61);  	fs.write (0x74);  	fs.write (0x61);  	// size of data chunk  	long size = block_size * m_total_samples;  	buf = PortUtil.getbytes_uint32_le (size);  	writeByteArray (fs' buf' 4);  	// 波形データ  	for (int i = 0; i < m_total_samples; i++) {  		if (m_bit_per_sample == 8) {  			fs.write (L8 [i]);  			if (m_channel == WaveChannel.Stereo) {  				fs.write (R8 [i]);  			}  		} else {  			buf = PortUtil.getbytes_int16_le (L16 [i]);  			writeByteArray (fs' buf' 2);  			if (m_channel == WaveChannel.Stereo) {  				buf = PortUtil.getbytes_int16_le (R16 [i]);  				writeByteArray (fs' buf' 2);  			}  		}  	}  	// 最後にWAVEチャンクのサイズ  	long position = fs.getFilePointer ();  	fs.seek (4);  	buf = PortUtil.getbytes_uint32_le (position - 8);  	writeByteArray (fs' buf' 4);  } catch (Exception ex) {  } finally {  	if (fs != null) {  		try {  			fs.close ();  		} catch (Exception ex2) {  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: try {  	fs = new RandomAccessFile (file' "rw");  	// RIFF  	fs.write (0x52);  	fs.write (0x49);  	fs.write (0x46);  	fs.write (0x46);  	// ファイルサイズ - 8最後に記入  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	// WAVE  	fs.write (0x57);  	fs.write (0x41);  	fs.write (0x56);  	fs.write (0x45);  	// fmt   	fs.write (0x66);  	fs.write (0x6d);  	fs.write (0x74);  	fs.write (0x20);  	// fmt チャンクのサイズ  	fs.write (0x12);  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	// format ID  	fs.write (0x01);  	fs.write (0x00);  	// チャンネル数  	if (m_channel == WaveChannel.Monoral) {  		fs.write (0x01);  		fs.write (0x00);  	} else {  		fs.write (0x02);  		fs.write (0x00);  	}  	// サンプリングレート  	byte[] buf = PortUtil.getbytes_uint32_le (m_sample_rate);  	writeByteArray (fs' buf' 4);  	// データ速度  	int ichannel = (m_channel == WaveChannel.Monoral) ? 1 : 2;  	int block_size = (int)(m_bit_per_sample / 8 * ichannel);  	long data_rate = m_sample_rate * block_size;  	buf = PortUtil.getbytes_uint32_le (data_rate);  	writeByteArray (fs' buf' 4);  	// ブロックサイズ  	buf = PortUtil.getbytes_uint16_le (block_size);  	writeByteArray (fs' buf' 2);  	// サンプルあたりのビット数  	buf = PortUtil.getbytes_uint16_le (m_bit_per_sample);  	writeByteArray (fs' buf' 2);  	// 拡張部分  	fs.write (0x00);  	fs.write (0x00);  	// data  	fs.write (0x64);  	fs.write (0x61);  	fs.write (0x74);  	fs.write (0x61);  	// size of data chunk  	long size = block_size * m_total_samples;  	buf = PortUtil.getbytes_uint32_le (size);  	writeByteArray (fs' buf' 4);  	// 波形データ  	for (int i = 0; i < m_total_samples; i++) {  		if (m_bit_per_sample == 8) {  			fs.write (L8 [i]);  			if (m_channel == WaveChannel.Stereo) {  				fs.write (R8 [i]);  			}  		} else {  			buf = PortUtil.getbytes_int16_le (L16 [i]);  			writeByteArray (fs' buf' 2);  			if (m_channel == WaveChannel.Stereo) {  				buf = PortUtil.getbytes_int16_le (R16 [i]);  				writeByteArray (fs' buf' 2);  			}  		}  	}  	// 最後にWAVEチャンクのサイズ  	long position = fs.getFilePointer ();  	fs.seek (4);  	buf = PortUtil.getbytes_uint32_le (position - 8);  	writeByteArray (fs' buf' 4);  } catch (Exception ex) {  } finally {  	if (fs != null) {  		try {  			fs.close ();  		} catch (Exception ex2) {  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: try {  	fs = new RandomAccessFile (file' "rw");  	// RIFF  	fs.write (0x52);  	fs.write (0x49);  	fs.write (0x46);  	fs.write (0x46);  	// ファイルサイズ - 8最後に記入  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	// WAVE  	fs.write (0x57);  	fs.write (0x41);  	fs.write (0x56);  	fs.write (0x45);  	// fmt   	fs.write (0x66);  	fs.write (0x6d);  	fs.write (0x74);  	fs.write (0x20);  	// fmt チャンクのサイズ  	fs.write (0x12);  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	// format ID  	fs.write (0x01);  	fs.write (0x00);  	// チャンネル数  	if (m_channel == WaveChannel.Monoral) {  		fs.write (0x01);  		fs.write (0x00);  	} else {  		fs.write (0x02);  		fs.write (0x00);  	}  	// サンプリングレート  	byte[] buf = PortUtil.getbytes_uint32_le (m_sample_rate);  	writeByteArray (fs' buf' 4);  	// データ速度  	int ichannel = (m_channel == WaveChannel.Monoral) ? 1 : 2;  	int block_size = (int)(m_bit_per_sample / 8 * ichannel);  	long data_rate = m_sample_rate * block_size;  	buf = PortUtil.getbytes_uint32_le (data_rate);  	writeByteArray (fs' buf' 4);  	// ブロックサイズ  	buf = PortUtil.getbytes_uint16_le (block_size);  	writeByteArray (fs' buf' 2);  	// サンプルあたりのビット数  	buf = PortUtil.getbytes_uint16_le (m_bit_per_sample);  	writeByteArray (fs' buf' 2);  	// 拡張部分  	fs.write (0x00);  	fs.write (0x00);  	// data  	fs.write (0x64);  	fs.write (0x61);  	fs.write (0x74);  	fs.write (0x61);  	// size of data chunk  	long size = block_size * m_total_samples;  	buf = PortUtil.getbytes_uint32_le (size);  	writeByteArray (fs' buf' 4);  	// 波形データ  	for (int i = 0; i < m_total_samples; i++) {  		if (m_bit_per_sample == 8) {  			fs.write (L8 [i]);  			if (m_channel == WaveChannel.Stereo) {  				fs.write (R8 [i]);  			}  		} else {  			buf = PortUtil.getbytes_int16_le (L16 [i]);  			writeByteArray (fs' buf' 2);  			if (m_channel == WaveChannel.Stereo) {  				buf = PortUtil.getbytes_int16_le (R16 [i]);  				writeByteArray (fs' buf' 2);  			}  		}  	}  	// 最後にWAVEチャンクのサイズ  	long position = fs.getFilePointer ();  	fs.seek (4);  	buf = PortUtil.getbytes_uint32_le (position - 8);  	writeByteArray (fs' buf' 4);  } catch (Exception ex) {  } finally {  	if (fs != null) {  		try {  			fs.close ();  		} catch (Exception ex2) {  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: try {  	fs = new RandomAccessFile (file' "rw");  	// RIFF  	fs.write (0x52);  	fs.write (0x49);  	fs.write (0x46);  	fs.write (0x46);  	// ファイルサイズ - 8最後に記入  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	// WAVE  	fs.write (0x57);  	fs.write (0x41);  	fs.write (0x56);  	fs.write (0x45);  	// fmt   	fs.write (0x66);  	fs.write (0x6d);  	fs.write (0x74);  	fs.write (0x20);  	// fmt チャンクのサイズ  	fs.write (0x12);  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	// format ID  	fs.write (0x01);  	fs.write (0x00);  	// チャンネル数  	if (m_channel == WaveChannel.Monoral) {  		fs.write (0x01);  		fs.write (0x00);  	} else {  		fs.write (0x02);  		fs.write (0x00);  	}  	// サンプリングレート  	byte[] buf = PortUtil.getbytes_uint32_le (m_sample_rate);  	writeByteArray (fs' buf' 4);  	// データ速度  	int ichannel = (m_channel == WaveChannel.Monoral) ? 1 : 2;  	int block_size = (int)(m_bit_per_sample / 8 * ichannel);  	long data_rate = m_sample_rate * block_size;  	buf = PortUtil.getbytes_uint32_le (data_rate);  	writeByteArray (fs' buf' 4);  	// ブロックサイズ  	buf = PortUtil.getbytes_uint16_le (block_size);  	writeByteArray (fs' buf' 2);  	// サンプルあたりのビット数  	buf = PortUtil.getbytes_uint16_le (m_bit_per_sample);  	writeByteArray (fs' buf' 2);  	// 拡張部分  	fs.write (0x00);  	fs.write (0x00);  	// data  	fs.write (0x64);  	fs.write (0x61);  	fs.write (0x74);  	fs.write (0x61);  	// size of data chunk  	long size = block_size * m_total_samples;  	buf = PortUtil.getbytes_uint32_le (size);  	writeByteArray (fs' buf' 4);  	// 波形データ  	for (int i = 0; i < m_total_samples; i++) {  		if (m_bit_per_sample == 8) {  			fs.write (L8 [i]);  			if (m_channel == WaveChannel.Stereo) {  				fs.write (R8 [i]);  			}  		} else {  			buf = PortUtil.getbytes_int16_le (L16 [i]);  			writeByteArray (fs' buf' 2);  			if (m_channel == WaveChannel.Stereo) {  				buf = PortUtil.getbytes_int16_le (R16 [i]);  				writeByteArray (fs' buf' 2);  			}  		}  	}  	// 最後にWAVEチャンクのサイズ  	long position = fs.getFilePointer ();  	fs.seek (4);  	buf = PortUtil.getbytes_uint32_le (position - 8);  	writeByteArray (fs' buf' 4);  } catch (Exception ex) {  } finally {  	if (fs != null) {  		try {  			fs.close ();  		} catch (Exception ex2) {  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: try {  	fs = new RandomAccessFile (file' "rw");  	// RIFF  	fs.write (0x52);  	fs.write (0x49);  	fs.write (0x46);  	fs.write (0x46);  	// ファイルサイズ - 8最後に記入  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	// WAVE  	fs.write (0x57);  	fs.write (0x41);  	fs.write (0x56);  	fs.write (0x45);  	// fmt   	fs.write (0x66);  	fs.write (0x6d);  	fs.write (0x74);  	fs.write (0x20);  	// fmt チャンクのサイズ  	fs.write (0x12);  	fs.write (0x00);  	fs.write (0x00);  	fs.write (0x00);  	// format ID  	fs.write (0x01);  	fs.write (0x00);  	// チャンネル数  	if (m_channel == WaveChannel.Monoral) {  		fs.write (0x01);  		fs.write (0x00);  	} else {  		fs.write (0x02);  		fs.write (0x00);  	}  	// サンプリングレート  	byte[] buf = PortUtil.getbytes_uint32_le (m_sample_rate);  	writeByteArray (fs' buf' 4);  	// データ速度  	int ichannel = (m_channel == WaveChannel.Monoral) ? 1 : 2;  	int block_size = (int)(m_bit_per_sample / 8 * ichannel);  	long data_rate = m_sample_rate * block_size;  	buf = PortUtil.getbytes_uint32_le (data_rate);  	writeByteArray (fs' buf' 4);  	// ブロックサイズ  	buf = PortUtil.getbytes_uint16_le (block_size);  	writeByteArray (fs' buf' 2);  	// サンプルあたりのビット数  	buf = PortUtil.getbytes_uint16_le (m_bit_per_sample);  	writeByteArray (fs' buf' 2);  	// 拡張部分  	fs.write (0x00);  	fs.write (0x00);  	// data  	fs.write (0x64);  	fs.write (0x61);  	fs.write (0x74);  	fs.write (0x61);  	// size of data chunk  	long size = block_size * m_total_samples;  	buf = PortUtil.getbytes_uint32_le (size);  	writeByteArray (fs' buf' 4);  	// 波形データ  	for (int i = 0; i < m_total_samples; i++) {  		if (m_bit_per_sample == 8) {  			fs.write (L8 [i]);  			if (m_channel == WaveChannel.Stereo) {  				fs.write (R8 [i]);  			}  		} else {  			buf = PortUtil.getbytes_int16_le (L16 [i]);  			writeByteArray (fs' buf' 2);  			if (m_channel == WaveChannel.Stereo) {  				buf = PortUtil.getbytes_int16_le (R16 [i]);  				writeByteArray (fs' buf' 2);  			}  		}  	}  	// 最後にWAVEチャンクのサイズ  	long position = fs.getFilePointer ();  	fs.seek (4);  	buf = PortUtil.getbytes_uint32_le (position - 8);  	writeByteArray (fs' buf' 4);  } catch (Exception ex) {  } finally {  	if (fs != null) {  		try {  			fs.close ();  		} catch (Exception ex2) {  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: writeByteArray (fs' buf' 4);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: writeByteArray (fs' buf' 4);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: writeByteArray (fs' buf' 2);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: writeByteArray (fs' buf' 2);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: writeByteArray (fs' buf' 4);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: for (int i = 0; i < m_total_samples; i++) {  	if (m_bit_per_sample == 8) {  		fs.write (L8 [i]);  		if (m_channel == WaveChannel.Stereo) {  			fs.write (R8 [i]);  		}  	} else {  		buf = PortUtil.getbytes_int16_le (L16 [i]);  		writeByteArray (fs' buf' 2);  		if (m_channel == WaveChannel.Stereo) {  			buf = PortUtil.getbytes_int16_le (R16 [i]);  			writeByteArray (fs' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: for (int i = 0; i < m_total_samples; i++) {  	if (m_bit_per_sample == 8) {  		fs.write (L8 [i]);  		if (m_channel == WaveChannel.Stereo) {  			fs.write (R8 [i]);  		}  	} else {  		buf = PortUtil.getbytes_int16_le (L16 [i]);  		writeByteArray (fs' buf' 2);  		if (m_channel == WaveChannel.Stereo) {  			buf = PortUtil.getbytes_int16_le (R16 [i]);  			writeByteArray (fs' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: for (int i = 0; i < m_total_samples; i++) {  	if (m_bit_per_sample == 8) {  		fs.write (L8 [i]);  		if (m_channel == WaveChannel.Stereo) {  			fs.write (R8 [i]);  		}  	} else {  		buf = PortUtil.getbytes_int16_le (L16 [i]);  		writeByteArray (fs' buf' 2);  		if (m_channel == WaveChannel.Stereo) {  			buf = PortUtil.getbytes_int16_le (R16 [i]);  			writeByteArray (fs' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	fs.write (L8 [i]);  	if (m_channel == WaveChannel.Stereo) {  		fs.write (R8 [i]);  	}  } else {  	buf = PortUtil.getbytes_int16_le (L16 [i]);  	writeByteArray (fs' buf' 2);  	if (m_channel == WaveChannel.Stereo) {  		buf = PortUtil.getbytes_int16_le (R16 [i]);  		writeByteArray (fs' buf' 2);  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	fs.write (L8 [i]);  	if (m_channel == WaveChannel.Stereo) {  		fs.write (R8 [i]);  	}  } else {  	buf = PortUtil.getbytes_int16_le (L16 [i]);  	writeByteArray (fs' buf' 2);  	if (m_channel == WaveChannel.Stereo) {  		buf = PortUtil.getbytes_int16_le (R16 [i]);  		writeByteArray (fs' buf' 2);  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	fs.write (L8 [i]);  	if (m_channel == WaveChannel.Stereo) {  		fs.write (R8 [i]);  	}  } else {  	buf = PortUtil.getbytes_int16_le (L16 [i]);  	writeByteArray (fs' buf' 2);  	if (m_channel == WaveChannel.Stereo) {  		buf = PortUtil.getbytes_int16_le (R16 [i]);  		writeByteArray (fs' buf' 2);  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: writeByteArray (fs' buf' 2);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: if (m_channel == WaveChannel.Stereo) {  	buf = PortUtil.getbytes_int16_le (R16 [i]);  	writeByteArray (fs' buf' 2);  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: writeByteArray (fs' buf' 2);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: fs.seek (4);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: buf = PortUtil.getbytes_uint32_le (position - 8);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,write,The following statement contains a magic number: writeByteArray (fs' buf' 4);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,monoralize,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	for (int i = 0; i < L8.Length; i++) {  		L8 [i] = (byte)((L8 [i] + R8 [i]) / 2);  	}  	R8 = null;  	m_channel = WaveChannel.Monoral;  } else {  	for (int i = 0; i < L16.Length; i++) {  		L16 [i] = (short)((L16 [i] + R16 [i]) / 2);  	}  	R16 = null;  	m_channel = WaveChannel.Monoral;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,monoralize,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	for (int i = 0; i < L8.Length; i++) {  		L8 [i] = (byte)((L8 [i] + R8 [i]) / 2);  	}  	R8 = null;  	m_channel = WaveChannel.Monoral;  } else {  	for (int i = 0; i < L16.Length; i++) {  		L16 [i] = (short)((L16 [i] + R16 [i]) / 2);  	}  	R16 = null;  	m_channel = WaveChannel.Monoral;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,monoralize,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	for (int i = 0; i < L8.Length; i++) {  		L8 [i] = (byte)((L8 [i] + R8 [i]) / 2);  	}  	R8 = null;  	m_channel = WaveChannel.Monoral;  } else {  	for (int i = 0; i < L16.Length; i++) {  		L16 [i] = (short)((L16 [i] + R16 [i]) / 2);  	}  	R16 = null;  	m_channel = WaveChannel.Monoral;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,monoralize,The following statement contains a magic number: for (int i = 0; i < L8.Length; i++) {  	L8 [i] = (byte)((L8 [i] + R8 [i]) / 2);  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,monoralize,The following statement contains a magic number: L8 [i] = (byte)((L8 [i] + R8 [i]) / 2);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,monoralize,The following statement contains a magic number: for (int i = 0; i < L16.Length; i++) {  	L16 [i] = (short)((L16 [i] + R16 [i]) / 2);  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,monoralize,The following statement contains a magic number: L16 [i] = (short)((L16 [i] + R16 [i]) / 2);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,trimSilence,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == WaveChannel.Monoral) {  		int non_silence_begin = 1;  		for (int i = 1; i < L8.Length; i++) {  			if (L8 [i] != 0x80) {  				non_silence_begin = i;  				break;  			}  		}  		int non_silence_end = L8.Length - 1;  		for (int i = L8.Length - 1; i >= 0; i--) {  			if (L8 [i] != 0x80) {  				non_silence_end = i;  				break;  			}  		}  		int count = non_silence_end - non_silence_begin + 1;  		R8 = new byte[count];  		copyArray (L8' non_silence_begin' R8' 0' count);  		L8 = null;  		L8 = new byte[count];  		copyArray (R8' 0' L8' 0' count);  		R8 = null;  	} else {  		int non_silence_begin = 1;  		for (int i = 1; i < L8.Length; i++) {  			if (L8 [i] != 0x80 || R8 [i] != 0x80) {  				non_silence_begin = i;  				break;  			}  		}  		int non_silence_end = L8.Length - 1;  		for (int i = L8.Length - 1; i >= 0; i--) {  			if (L8 [i] != 0x80 || R8 [i] != 0x80) {  				non_silence_end = i;  				break;  			}  		}  		int count = non_silence_end - non_silence_begin + 1;  		byte[] buf = new byte[count];  		copyArray (L8' non_silence_begin' buf' 0' count);  		L8 = null;  		L8 = new byte[count];  		copyArray (buf' 0' L8' 0' count);  		copyArray (R8' non_silence_begin' buf' 0' count);  		R8 = null;  		R8 = new byte[count];  		copyArray (buf' 0' R8' 0' count);  		buf = null;  	}  } else {  	if (m_channel == WaveChannel.Monoral) {  		int non_silence_begin = 1;  		for (int i = 1; i < L16.Length; i++) {  			if (L16 [i] != 0) {  				non_silence_begin = i;  				break;  			}  		}  		int non_silence_end = L16.Length - 1;  		for (int i = L16.Length - 1; i >= 0; i--) {  			if (L16 [i] != 0) {  				non_silence_end = i;  				break;  			}  		}  		int count = non_silence_end - non_silence_begin + 1;  		R16 = new short[count];  		copyArray (L16' non_silence_begin' R16' 0' count);  		L16 = resizeArray (L16' count);  		copyArray (R16' 0' L16' 0' count);  		R16 = null;  	} else {  		int non_silence_begin = 1;  		for (int i = 1; i < L16.Length; i++) {  			if (L16 [i] != 0 || R16 [i] != 0) {  				non_silence_begin = i;  				break;  			}  		}  		int non_silence_end = L16.Length - 1;  		for (int i = L16.Length - 1; i >= 0; i--) {  			if (L16 [i] != 0 || R16 [i] != 0) {  				non_silence_end = i;  				break;  			}  		}  		int count = non_silence_end - non_silence_begin + 1;  		short[] buf = new short[count];  		copyArray (L16' non_silence_begin' buf' 0' count);  		L16 = resizeArray (L16' count);  		copyArray (buf' 0' L16' 0' count);  		copyArray (R16' non_silence_begin' buf' 0' count);  		R16 = resizeArray (R16' count);  		copyArray (buf' 0' R16' 0' count);  		buf = null;  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,trimSilence,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	m_total_samples = (long)L8.Length;  } else {  	m_total_samples = (long)L16.Length;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,Wave,The following statement contains a magic number: m_bit_per_sample = 16;  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,Wave,The following statement contains a magic number: m_sample_rate = 44100;  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,Wave,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	L8 = new byte[(int)m_total_samples];  	if (m_channel == WaveChannel.Stereo) {  		R8 = new byte[(int)m_total_samples];  	}  } else if (m_bit_per_sample == 16) {  	L16 = new short[(int)m_total_samples];  	if (m_channel == WaveChannel.Stereo) {  		R16 = new short[(int)m_total_samples];  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,Wave,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	L8 = new byte[(int)m_total_samples];  	if (m_channel == WaveChannel.Stereo) {  		R8 = new byte[(int)m_total_samples];  	}  } else if (m_bit_per_sample == 16) {  	L16 = new short[(int)m_total_samples];  	if (m_channel == WaveChannel.Stereo) {  		R16 = new short[(int)m_total_samples];  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,Wave,The following statement contains a magic number: if (m_bit_per_sample == 16) {  	L16 = new short[(int)m_total_samples];  	if (m_channel == WaveChannel.Stereo) {  		R16 = new short[(int)m_total_samples];  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 16 && m_channel == WaveChannel.Stereo) {  	L16 = resizeArray (L16' (int)(m_total_samples + length));  	R16 = resizeArray (R16' (int)(m_total_samples + length));  	m_total_samples += (long)length;  	for (int i = old_length; i < m_total_samples; i++) {  		L16 [i] = (short)(L [i - old_length] * 32768f);  		R16 [i] = (short)(R [i - old_length] * 32768f);  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	long chunk_size_form = PortUtil.make_uint32_be (buf);  	fs.read (buf' 0' 4);  	// AIFF  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("AIFF")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be AIFF" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("COMM")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be COMM" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM chunk size  	long chunk_size_comm = PortUtil.make_uint32_be (buf);  	long chunk_loc_comm = fs.getFilePointer ();  	fs.read (buf' 0' 2);  	// number of channel  	int num_channel = PortUtil.make_uint16_be (buf);  	if (num_channel == 1) {  		m_channel = WaveChannel.Monoral;  	} else {  		m_channel = WaveChannel.Stereo;  	}  	fs.read (buf' 0' 4);  	// number of samples  	m_total_samples = PortUtil.make_uint32_be (buf);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_total_samples=" + m_total_samples ); #endif  	fs.read (buf' 0' 2);  	// block size  	m_bit_per_sample = PortUtil.make_uint16_be (buf);  	byte[] buf10 = new byte[10];  	fs.read (buf10' 0' 10);  	// sample rate  	m_sample_rate = (long)make_double_from_extended (buf10);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_sample_rate=" + m_sample_rate ); #endif  	fs.seek (chunk_loc_comm + (long)chunk_size_comm);  	fs.read (buf' 0' 4);  	// SSND  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("SSND")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be SSND" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// SSND chunk size  	long chunk_size_ssnd = PortUtil.make_uint32_be (buf);  } catch (Exception ex) {  	return false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	long chunk_size_form = PortUtil.make_uint32_be (buf);  	fs.read (buf' 0' 4);  	// AIFF  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("AIFF")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be AIFF" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("COMM")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be COMM" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM chunk size  	long chunk_size_comm = PortUtil.make_uint32_be (buf);  	long chunk_loc_comm = fs.getFilePointer ();  	fs.read (buf' 0' 2);  	// number of channel  	int num_channel = PortUtil.make_uint16_be (buf);  	if (num_channel == 1) {  		m_channel = WaveChannel.Monoral;  	} else {  		m_channel = WaveChannel.Stereo;  	}  	fs.read (buf' 0' 4);  	// number of samples  	m_total_samples = PortUtil.make_uint32_be (buf);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_total_samples=" + m_total_samples ); #endif  	fs.read (buf' 0' 2);  	// block size  	m_bit_per_sample = PortUtil.make_uint16_be (buf);  	byte[] buf10 = new byte[10];  	fs.read (buf10' 0' 10);  	// sample rate  	m_sample_rate = (long)make_double_from_extended (buf10);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_sample_rate=" + m_sample_rate ); #endif  	fs.seek (chunk_loc_comm + (long)chunk_size_comm);  	fs.read (buf' 0' 4);  	// SSND  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("SSND")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be SSND" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// SSND chunk size  	long chunk_size_ssnd = PortUtil.make_uint32_be (buf);  } catch (Exception ex) {  	return false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	long chunk_size_form = PortUtil.make_uint32_be (buf);  	fs.read (buf' 0' 4);  	// AIFF  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("AIFF")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be AIFF" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("COMM")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be COMM" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM chunk size  	long chunk_size_comm = PortUtil.make_uint32_be (buf);  	long chunk_loc_comm = fs.getFilePointer ();  	fs.read (buf' 0' 2);  	// number of channel  	int num_channel = PortUtil.make_uint16_be (buf);  	if (num_channel == 1) {  		m_channel = WaveChannel.Monoral;  	} else {  		m_channel = WaveChannel.Stereo;  	}  	fs.read (buf' 0' 4);  	// number of samples  	m_total_samples = PortUtil.make_uint32_be (buf);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_total_samples=" + m_total_samples ); #endif  	fs.read (buf' 0' 2);  	// block size  	m_bit_per_sample = PortUtil.make_uint16_be (buf);  	byte[] buf10 = new byte[10];  	fs.read (buf10' 0' 10);  	// sample rate  	m_sample_rate = (long)make_double_from_extended (buf10);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_sample_rate=" + m_sample_rate ); #endif  	fs.seek (chunk_loc_comm + (long)chunk_size_comm);  	fs.read (buf' 0' 4);  	// SSND  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("SSND")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be SSND" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// SSND chunk size  	long chunk_size_ssnd = PortUtil.make_uint32_be (buf);  } catch (Exception ex) {  	return false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	long chunk_size_form = PortUtil.make_uint32_be (buf);  	fs.read (buf' 0' 4);  	// AIFF  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("AIFF")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be AIFF" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("COMM")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be COMM" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM chunk size  	long chunk_size_comm = PortUtil.make_uint32_be (buf);  	long chunk_loc_comm = fs.getFilePointer ();  	fs.read (buf' 0' 2);  	// number of channel  	int num_channel = PortUtil.make_uint16_be (buf);  	if (num_channel == 1) {  		m_channel = WaveChannel.Monoral;  	} else {  		m_channel = WaveChannel.Stereo;  	}  	fs.read (buf' 0' 4);  	// number of samples  	m_total_samples = PortUtil.make_uint32_be (buf);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_total_samples=" + m_total_samples ); #endif  	fs.read (buf' 0' 2);  	// block size  	m_bit_per_sample = PortUtil.make_uint16_be (buf);  	byte[] buf10 = new byte[10];  	fs.read (buf10' 0' 10);  	// sample rate  	m_sample_rate = (long)make_double_from_extended (buf10);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_sample_rate=" + m_sample_rate ); #endif  	fs.seek (chunk_loc_comm + (long)chunk_size_comm);  	fs.read (buf' 0' 4);  	// SSND  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("SSND")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be SSND" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// SSND chunk size  	long chunk_size_ssnd = PortUtil.make_uint32_be (buf);  } catch (Exception ex) {  	return false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	long chunk_size_form = PortUtil.make_uint32_be (buf);  	fs.read (buf' 0' 4);  	// AIFF  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("AIFF")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be AIFF" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("COMM")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be COMM" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM chunk size  	long chunk_size_comm = PortUtil.make_uint32_be (buf);  	long chunk_loc_comm = fs.getFilePointer ();  	fs.read (buf' 0' 2);  	// number of channel  	int num_channel = PortUtil.make_uint16_be (buf);  	if (num_channel == 1) {  		m_channel = WaveChannel.Monoral;  	} else {  		m_channel = WaveChannel.Stereo;  	}  	fs.read (buf' 0' 4);  	// number of samples  	m_total_samples = PortUtil.make_uint32_be (buf);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_total_samples=" + m_total_samples ); #endif  	fs.read (buf' 0' 2);  	// block size  	m_bit_per_sample = PortUtil.make_uint16_be (buf);  	byte[] buf10 = new byte[10];  	fs.read (buf10' 0' 10);  	// sample rate  	m_sample_rate = (long)make_double_from_extended (buf10);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_sample_rate=" + m_sample_rate ); #endif  	fs.seek (chunk_loc_comm + (long)chunk_size_comm);  	fs.read (buf' 0' 4);  	// SSND  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("SSND")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be SSND" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// SSND chunk size  	long chunk_size_ssnd = PortUtil.make_uint32_be (buf);  } catch (Exception ex) {  	return false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	long chunk_size_form = PortUtil.make_uint32_be (buf);  	fs.read (buf' 0' 4);  	// AIFF  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("AIFF")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be AIFF" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("COMM")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be COMM" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM chunk size  	long chunk_size_comm = PortUtil.make_uint32_be (buf);  	long chunk_loc_comm = fs.getFilePointer ();  	fs.read (buf' 0' 2);  	// number of channel  	int num_channel = PortUtil.make_uint16_be (buf);  	if (num_channel == 1) {  		m_channel = WaveChannel.Monoral;  	} else {  		m_channel = WaveChannel.Stereo;  	}  	fs.read (buf' 0' 4);  	// number of samples  	m_total_samples = PortUtil.make_uint32_be (buf);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_total_samples=" + m_total_samples ); #endif  	fs.read (buf' 0' 2);  	// block size  	m_bit_per_sample = PortUtil.make_uint16_be (buf);  	byte[] buf10 = new byte[10];  	fs.read (buf10' 0' 10);  	// sample rate  	m_sample_rate = (long)make_double_from_extended (buf10);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_sample_rate=" + m_sample_rate ); #endif  	fs.seek (chunk_loc_comm + (long)chunk_size_comm);  	fs.read (buf' 0' 4);  	// SSND  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("SSND")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be SSND" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// SSND chunk size  	long chunk_size_ssnd = PortUtil.make_uint32_be (buf);  } catch (Exception ex) {  	return false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	long chunk_size_form = PortUtil.make_uint32_be (buf);  	fs.read (buf' 0' 4);  	// AIFF  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("AIFF")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be AIFF" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("COMM")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be COMM" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM chunk size  	long chunk_size_comm = PortUtil.make_uint32_be (buf);  	long chunk_loc_comm = fs.getFilePointer ();  	fs.read (buf' 0' 2);  	// number of channel  	int num_channel = PortUtil.make_uint16_be (buf);  	if (num_channel == 1) {  		m_channel = WaveChannel.Monoral;  	} else {  		m_channel = WaveChannel.Stereo;  	}  	fs.read (buf' 0' 4);  	// number of samples  	m_total_samples = PortUtil.make_uint32_be (buf);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_total_samples=" + m_total_samples ); #endif  	fs.read (buf' 0' 2);  	// block size  	m_bit_per_sample = PortUtil.make_uint16_be (buf);  	byte[] buf10 = new byte[10];  	fs.read (buf10' 0' 10);  	// sample rate  	m_sample_rate = (long)make_double_from_extended (buf10);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_sample_rate=" + m_sample_rate ); #endif  	fs.seek (chunk_loc_comm + (long)chunk_size_comm);  	fs.read (buf' 0' 4);  	// SSND  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("SSND")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be SSND" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// SSND chunk size  	long chunk_size_ssnd = PortUtil.make_uint32_be (buf);  } catch (Exception ex) {  	return false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	long chunk_size_form = PortUtil.make_uint32_be (buf);  	fs.read (buf' 0' 4);  	// AIFF  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("AIFF")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be AIFF" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("COMM")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be COMM" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM chunk size  	long chunk_size_comm = PortUtil.make_uint32_be (buf);  	long chunk_loc_comm = fs.getFilePointer ();  	fs.read (buf' 0' 2);  	// number of channel  	int num_channel = PortUtil.make_uint16_be (buf);  	if (num_channel == 1) {  		m_channel = WaveChannel.Monoral;  	} else {  		m_channel = WaveChannel.Stereo;  	}  	fs.read (buf' 0' 4);  	// number of samples  	m_total_samples = PortUtil.make_uint32_be (buf);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_total_samples=" + m_total_samples ); #endif  	fs.read (buf' 0' 2);  	// block size  	m_bit_per_sample = PortUtil.make_uint16_be (buf);  	byte[] buf10 = new byte[10];  	fs.read (buf10' 0' 10);  	// sample rate  	m_sample_rate = (long)make_double_from_extended (buf10);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_sample_rate=" + m_sample_rate ); #endif  	fs.seek (chunk_loc_comm + (long)chunk_size_comm);  	fs.read (buf' 0' 4);  	// SSND  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("SSND")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be SSND" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// SSND chunk size  	long chunk_size_ssnd = PortUtil.make_uint32_be (buf);  } catch (Exception ex) {  	return false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	long chunk_size_form = PortUtil.make_uint32_be (buf);  	fs.read (buf' 0' 4);  	// AIFF  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("AIFF")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be AIFF" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("COMM")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be COMM" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM chunk size  	long chunk_size_comm = PortUtil.make_uint32_be (buf);  	long chunk_loc_comm = fs.getFilePointer ();  	fs.read (buf' 0' 2);  	// number of channel  	int num_channel = PortUtil.make_uint16_be (buf);  	if (num_channel == 1) {  		m_channel = WaveChannel.Monoral;  	} else {  		m_channel = WaveChannel.Stereo;  	}  	fs.read (buf' 0' 4);  	// number of samples  	m_total_samples = PortUtil.make_uint32_be (buf);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_total_samples=" + m_total_samples ); #endif  	fs.read (buf' 0' 2);  	// block size  	m_bit_per_sample = PortUtil.make_uint16_be (buf);  	byte[] buf10 = new byte[10];  	fs.read (buf10' 0' 10);  	// sample rate  	m_sample_rate = (long)make_double_from_extended (buf10);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_sample_rate=" + m_sample_rate ); #endif  	fs.seek (chunk_loc_comm + (long)chunk_size_comm);  	fs.read (buf' 0' 4);  	// SSND  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("SSND")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be SSND" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// SSND chunk size  	long chunk_size_ssnd = PortUtil.make_uint32_be (buf);  } catch (Exception ex) {  	return false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	long chunk_size_form = PortUtil.make_uint32_be (buf);  	fs.read (buf' 0' 4);  	// AIFF  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("AIFF")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be AIFF" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("COMM")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be COMM" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM chunk size  	long chunk_size_comm = PortUtil.make_uint32_be (buf);  	long chunk_loc_comm = fs.getFilePointer ();  	fs.read (buf' 0' 2);  	// number of channel  	int num_channel = PortUtil.make_uint16_be (buf);  	if (num_channel == 1) {  		m_channel = WaveChannel.Monoral;  	} else {  		m_channel = WaveChannel.Stereo;  	}  	fs.read (buf' 0' 4);  	// number of samples  	m_total_samples = PortUtil.make_uint32_be (buf);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_total_samples=" + m_total_samples ); #endif  	fs.read (buf' 0' 2);  	// block size  	m_bit_per_sample = PortUtil.make_uint16_be (buf);  	byte[] buf10 = new byte[10];  	fs.read (buf10' 0' 10);  	// sample rate  	m_sample_rate = (long)make_double_from_extended (buf10);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_sample_rate=" + m_sample_rate ); #endif  	fs.seek (chunk_loc_comm + (long)chunk_size_comm);  	fs.read (buf' 0' 4);  	// SSND  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("SSND")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be SSND" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// SSND chunk size  	long chunk_size_ssnd = PortUtil.make_uint32_be (buf);  } catch (Exception ex) {  	return false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	long chunk_size_form = PortUtil.make_uint32_be (buf);  	fs.read (buf' 0' 4);  	// AIFF  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("AIFF")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be AIFF" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("COMM")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be COMM" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM chunk size  	long chunk_size_comm = PortUtil.make_uint32_be (buf);  	long chunk_loc_comm = fs.getFilePointer ();  	fs.read (buf' 0' 2);  	// number of channel  	int num_channel = PortUtil.make_uint16_be (buf);  	if (num_channel == 1) {  		m_channel = WaveChannel.Monoral;  	} else {  		m_channel = WaveChannel.Stereo;  	}  	fs.read (buf' 0' 4);  	// number of samples  	m_total_samples = PortUtil.make_uint32_be (buf);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_total_samples=" + m_total_samples ); #endif  	fs.read (buf' 0' 2);  	// block size  	m_bit_per_sample = PortUtil.make_uint16_be (buf);  	byte[] buf10 = new byte[10];  	fs.read (buf10' 0' 10);  	// sample rate  	m_sample_rate = (long)make_double_from_extended (buf10);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_sample_rate=" + m_sample_rate ); #endif  	fs.seek (chunk_loc_comm + (long)chunk_size_comm);  	fs.read (buf' 0' 4);  	// SSND  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("SSND")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be SSND" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// SSND chunk size  	long chunk_size_ssnd = PortUtil.make_uint32_be (buf);  } catch (Exception ex) {  	return false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	long chunk_size_form = PortUtil.make_uint32_be (buf);  	fs.read (buf' 0' 4);  	// AIFF  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("AIFF")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be AIFF" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("COMM")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be COMM" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM chunk size  	long chunk_size_comm = PortUtil.make_uint32_be (buf);  	long chunk_loc_comm = fs.getFilePointer ();  	fs.read (buf' 0' 2);  	// number of channel  	int num_channel = PortUtil.make_uint16_be (buf);  	if (num_channel == 1) {  		m_channel = WaveChannel.Monoral;  	} else {  		m_channel = WaveChannel.Stereo;  	}  	fs.read (buf' 0' 4);  	// number of samples  	m_total_samples = PortUtil.make_uint32_be (buf);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_total_samples=" + m_total_samples ); #endif  	fs.read (buf' 0' 2);  	// block size  	m_bit_per_sample = PortUtil.make_uint16_be (buf);  	byte[] buf10 = new byte[10];  	fs.read (buf10' 0' 10);  	// sample rate  	m_sample_rate = (long)make_double_from_extended (buf10);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_sample_rate=" + m_sample_rate ); #endif  	fs.seek (chunk_loc_comm + (long)chunk_size_comm);  	fs.read (buf' 0' 4);  	// SSND  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("SSND")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be SSND" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// SSND chunk size  	long chunk_size_ssnd = PortUtil.make_uint32_be (buf);  } catch (Exception ex) {  	return false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	long chunk_size_form = PortUtil.make_uint32_be (buf);  	fs.read (buf' 0' 4);  	// AIFF  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("AIFF")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be AIFF" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("COMM")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be COMM" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM chunk size  	long chunk_size_comm = PortUtil.make_uint32_be (buf);  	long chunk_loc_comm = fs.getFilePointer ();  	fs.read (buf' 0' 2);  	// number of channel  	int num_channel = PortUtil.make_uint16_be (buf);  	if (num_channel == 1) {  		m_channel = WaveChannel.Monoral;  	} else {  		m_channel = WaveChannel.Stereo;  	}  	fs.read (buf' 0' 4);  	// number of samples  	m_total_samples = PortUtil.make_uint32_be (buf);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_total_samples=" + m_total_samples ); #endif  	fs.read (buf' 0' 2);  	// block size  	m_bit_per_sample = PortUtil.make_uint16_be (buf);  	byte[] buf10 = new byte[10];  	fs.read (buf10' 0' 10);  	// sample rate  	m_sample_rate = (long)make_double_from_extended (buf10);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_sample_rate=" + m_sample_rate ); #endif  	fs.seek (chunk_loc_comm + (long)chunk_size_comm);  	fs.read (buf' 0' 4);  	// SSND  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("SSND")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be SSND" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// SSND chunk size  	long chunk_size_ssnd = PortUtil.make_uint32_be (buf);  } catch (Exception ex) {  	return false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	long chunk_size_form = PortUtil.make_uint32_be (buf);  	fs.read (buf' 0' 4);  	// AIFF  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("AIFF")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be AIFF" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("COMM")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be COMM" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM chunk size  	long chunk_size_comm = PortUtil.make_uint32_be (buf);  	long chunk_loc_comm = fs.getFilePointer ();  	fs.read (buf' 0' 2);  	// number of channel  	int num_channel = PortUtil.make_uint16_be (buf);  	if (num_channel == 1) {  		m_channel = WaveChannel.Monoral;  	} else {  		m_channel = WaveChannel.Stereo;  	}  	fs.read (buf' 0' 4);  	// number of samples  	m_total_samples = PortUtil.make_uint32_be (buf);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_total_samples=" + m_total_samples ); #endif  	fs.read (buf' 0' 2);  	// block size  	m_bit_per_sample = PortUtil.make_uint16_be (buf);  	byte[] buf10 = new byte[10];  	fs.read (buf10' 0' 10);  	// sample rate  	m_sample_rate = (long)make_double_from_extended (buf10);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_sample_rate=" + m_sample_rate ); #endif  	fs.seek (chunk_loc_comm + (long)chunk_size_comm);  	fs.read (buf' 0' 4);  	// SSND  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("SSND")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be SSND" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// SSND chunk size  	long chunk_size_ssnd = PortUtil.make_uint32_be (buf);  } catch (Exception ex) {  	return false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	long chunk_size_form = PortUtil.make_uint32_be (buf);  	fs.read (buf' 0' 4);  	// AIFF  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("AIFF")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be AIFF" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("COMM")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be COMM" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM chunk size  	long chunk_size_comm = PortUtil.make_uint32_be (buf);  	long chunk_loc_comm = fs.getFilePointer ();  	fs.read (buf' 0' 2);  	// number of channel  	int num_channel = PortUtil.make_uint16_be (buf);  	if (num_channel == 1) {  		m_channel = WaveChannel.Monoral;  	} else {  		m_channel = WaveChannel.Stereo;  	}  	fs.read (buf' 0' 4);  	// number of samples  	m_total_samples = PortUtil.make_uint32_be (buf);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_total_samples=" + m_total_samples ); #endif  	fs.read (buf' 0' 2);  	// block size  	m_bit_per_sample = PortUtil.make_uint16_be (buf);  	byte[] buf10 = new byte[10];  	fs.read (buf10' 0' 10);  	// sample rate  	m_sample_rate = (long)make_double_from_extended (buf10);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_sample_rate=" + m_sample_rate ); #endif  	fs.seek (chunk_loc_comm + (long)chunk_size_comm);  	fs.read (buf' 0' 4);  	// SSND  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("SSND")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be SSND" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// SSND chunk size  	long chunk_size_ssnd = PortUtil.make_uint32_be (buf);  } catch (Exception ex) {  	return false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	long chunk_size_form = PortUtil.make_uint32_be (buf);  	fs.read (buf' 0' 4);  	// AIFF  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("AIFF")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be AIFF" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("COMM")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be COMM" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM chunk size  	long chunk_size_comm = PortUtil.make_uint32_be (buf);  	long chunk_loc_comm = fs.getFilePointer ();  	fs.read (buf' 0' 2);  	// number of channel  	int num_channel = PortUtil.make_uint16_be (buf);  	if (num_channel == 1) {  		m_channel = WaveChannel.Monoral;  	} else {  		m_channel = WaveChannel.Stereo;  	}  	fs.read (buf' 0' 4);  	// number of samples  	m_total_samples = PortUtil.make_uint32_be (buf);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_total_samples=" + m_total_samples ); #endif  	fs.read (buf' 0' 2);  	// block size  	m_bit_per_sample = PortUtil.make_uint16_be (buf);  	byte[] buf10 = new byte[10];  	fs.read (buf10' 0' 10);  	// sample rate  	m_sample_rate = (long)make_double_from_extended (buf10);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_sample_rate=" + m_sample_rate ); #endif  	fs.seek (chunk_loc_comm + (long)chunk_size_comm);  	fs.read (buf' 0' 4);  	// SSND  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("SSND")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be SSND" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// SSND chunk size  	long chunk_size_ssnd = PortUtil.make_uint32_be (buf);  } catch (Exception ex) {  	return false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	long chunk_size_form = PortUtil.make_uint32_be (buf);  	fs.read (buf' 0' 4);  	// AIFF  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("AIFF")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be AIFF" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("COMM")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be COMM" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM chunk size  	long chunk_size_comm = PortUtil.make_uint32_be (buf);  	long chunk_loc_comm = fs.getFilePointer ();  	fs.read (buf' 0' 2);  	// number of channel  	int num_channel = PortUtil.make_uint16_be (buf);  	if (num_channel == 1) {  		m_channel = WaveChannel.Monoral;  	} else {  		m_channel = WaveChannel.Stereo;  	}  	fs.read (buf' 0' 4);  	// number of samples  	m_total_samples = PortUtil.make_uint32_be (buf);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_total_samples=" + m_total_samples ); #endif  	fs.read (buf' 0' 2);  	// block size  	m_bit_per_sample = PortUtil.make_uint16_be (buf);  	byte[] buf10 = new byte[10];  	fs.read (buf10' 0' 10);  	// sample rate  	m_sample_rate = (long)make_double_from_extended (buf10);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_sample_rate=" + m_sample_rate ); #endif  	fs.seek (chunk_loc_comm + (long)chunk_size_comm);  	fs.read (buf' 0' 4);  	// SSND  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("SSND")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be SSND" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// SSND chunk size  	long chunk_size_ssnd = PortUtil.make_uint32_be (buf);  } catch (Exception ex) {  	return false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	long chunk_size_form = PortUtil.make_uint32_be (buf);  	fs.read (buf' 0' 4);  	// AIFF  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("AIFF")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be AIFF" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("COMM")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be COMM" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// COMM chunk size  	long chunk_size_comm = PortUtil.make_uint32_be (buf);  	long chunk_loc_comm = fs.getFilePointer ();  	fs.read (buf' 0' 2);  	// number of channel  	int num_channel = PortUtil.make_uint16_be (buf);  	if (num_channel == 1) {  		m_channel = WaveChannel.Monoral;  	} else {  		m_channel = WaveChannel.Stereo;  	}  	fs.read (buf' 0' 4);  	// number of samples  	m_total_samples = PortUtil.make_uint32_be (buf);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_total_samples=" + m_total_samples ); #endif  	fs.read (buf' 0' 2);  	// block size  	m_bit_per_sample = PortUtil.make_uint16_be (buf);  	byte[] buf10 = new byte[10];  	fs.read (buf10' 0' 10);  	// sample rate  	m_sample_rate = (long)make_double_from_extended (buf10);  	#if DEBUG  	                sout.println( "WaveparseAiffHeader; m_sample_rate=" + m_sample_rate ); #endif  	fs.seek (chunk_loc_comm + (long)chunk_size_comm);  	fs.read (buf' 0' 4);  	// SSND  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	if (!tag.Equals ("SSND")) {  		#if DEBUG  		                    serr.println( "WaveparseAiffHeader; error; tag=" + tag + " and must be SSND" ); #endif  		return false;  	}  	fs.read (buf' 0' 4);  	// SSND chunk size  	long chunk_size_ssnd = PortUtil.make_uint32_be (buf);  } catch (Exception ex) {  	return false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: fs.read (buf' 0' 4);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: fs.read (buf' 0' 4);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: fs.read (buf' 0' 4);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: tag = new String (new char[] {  	(char)buf [0]'  	(char)buf [1]'  	(char)buf [2]'  	(char)buf [3]  });  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: tag = new String (new char[] {  	(char)buf [0]'  	(char)buf [1]'  	(char)buf [2]'  	(char)buf [3]  });  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: fs.read (buf' 0' 4);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: fs.read (buf' 0' 2);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: fs.read (buf' 0' 4);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: fs.read (buf' 0' 2);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: fs.read (buf10' 0' 10);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: fs.read (buf' 0' 4);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: tag = new String (new char[] {  	(char)buf [0]'  	(char)buf [1]'  	(char)buf [2]'  	(char)buf [3]  });  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: tag = new String (new char[] {  	(char)buf [0]'  	(char)buf [1]'  	(char)buf [2]'  	(char)buf [3]  });  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseAiffHeader,The following statement contains a magic number: fs.read (buf' 0' 4);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: hiMant = ((long)(bytes [2] & 0xFF) << 24) | ((long)(bytes [3] & 0xFF) << 16) | ((long)(bytes [4] & 0xFF) << 8) | ((long)(bytes [5] & 0xFF));  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: hiMant = ((long)(bytes [2] & 0xFF) << 24) | ((long)(bytes [3] & 0xFF) << 16) | ((long)(bytes [4] & 0xFF) << 8) | ((long)(bytes [5] & 0xFF));  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: hiMant = ((long)(bytes [2] & 0xFF) << 24) | ((long)(bytes [3] & 0xFF) << 16) | ((long)(bytes [4] & 0xFF) << 8) | ((long)(bytes [5] & 0xFF));  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: hiMant = ((long)(bytes [2] & 0xFF) << 24) | ((long)(bytes [3] & 0xFF) << 16) | ((long)(bytes [4] & 0xFF) << 8) | ((long)(bytes [5] & 0xFF));  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: hiMant = ((long)(bytes [2] & 0xFF) << 24) | ((long)(bytes [3] & 0xFF) << 16) | ((long)(bytes [4] & 0xFF) << 8) | ((long)(bytes [5] & 0xFF));  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: hiMant = ((long)(bytes [2] & 0xFF) << 24) | ((long)(bytes [3] & 0xFF) << 16) | ((long)(bytes [4] & 0xFF) << 8) | ((long)(bytes [5] & 0xFF));  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: hiMant = ((long)(bytes [2] & 0xFF) << 24) | ((long)(bytes [3] & 0xFF) << 16) | ((long)(bytes [4] & 0xFF) << 8) | ((long)(bytes [5] & 0xFF));  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: loMant = ((long)(bytes [6] & 0xFF) << 24) | ((long)(bytes [7] & 0xFF) << 16) | ((long)(bytes [8] & 0xFF) << 8) | ((long)(bytes [9] & 0xFF));  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: loMant = ((long)(bytes [6] & 0xFF) << 24) | ((long)(bytes [7] & 0xFF) << 16) | ((long)(bytes [8] & 0xFF) << 8) | ((long)(bytes [9] & 0xFF));  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: loMant = ((long)(bytes [6] & 0xFF) << 24) | ((long)(bytes [7] & 0xFF) << 16) | ((long)(bytes [8] & 0xFF) << 8) | ((long)(bytes [9] & 0xFF));  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: loMant = ((long)(bytes [6] & 0xFF) << 24) | ((long)(bytes [7] & 0xFF) << 16) | ((long)(bytes [8] & 0xFF) << 8) | ((long)(bytes [9] & 0xFF));  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: loMant = ((long)(bytes [6] & 0xFF) << 24) | ((long)(bytes [7] & 0xFF) << 16) | ((long)(bytes [8] & 0xFF) << 8) | ((long)(bytes [9] & 0xFF));  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: loMant = ((long)(bytes [6] & 0xFF) << 24) | ((long)(bytes [7] & 0xFF) << 16) | ((long)(bytes [8] & 0xFF) << 8) | ((long)(bytes [9] & 0xFF));  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: loMant = ((long)(bytes [6] & 0xFF) << 24) | ((long)(bytes [7] & 0xFF) << 16) | ((long)(bytes [8] & 0xFF) << 8) | ((long)(bytes [9] & 0xFF));  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: if (expon == 0 && hiMant == 0 && loMant == 0) {  	f = 0;  } else {  	if (expon == 0x7FFF) {  		f = double.MaxValue;  	} else {  		expon -= 16383;  		//f = ldexp( double_from_uint( hiMant )' expon -= 31 );  		f = Math.Pow (2.0' expon - 31) * double_from_uint (hiMant);  		//f += ldexp( double_from_uint( loMant )' expon -= 32 );  		f += Math.Pow (2.0' expon - 32) * double_from_uint (loMant);  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: if (expon == 0 && hiMant == 0 && loMant == 0) {  	f = 0;  } else {  	if (expon == 0x7FFF) {  		f = double.MaxValue;  	} else {  		expon -= 16383;  		//f = ldexp( double_from_uint( hiMant )' expon -= 31 );  		f = Math.Pow (2.0' expon - 31) * double_from_uint (hiMant);  		//f += ldexp( double_from_uint( loMant )' expon -= 32 );  		f += Math.Pow (2.0' expon - 32) * double_from_uint (loMant);  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: if (expon == 0 && hiMant == 0 && loMant == 0) {  	f = 0;  } else {  	if (expon == 0x7FFF) {  		f = double.MaxValue;  	} else {  		expon -= 16383;  		//f = ldexp( double_from_uint( hiMant )' expon -= 31 );  		f = Math.Pow (2.0' expon - 31) * double_from_uint (hiMant);  		//f += ldexp( double_from_uint( loMant )' expon -= 32 );  		f += Math.Pow (2.0' expon - 32) * double_from_uint (loMant);  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: if (expon == 0 && hiMant == 0 && loMant == 0) {  	f = 0;  } else {  	if (expon == 0x7FFF) {  		f = double.MaxValue;  	} else {  		expon -= 16383;  		//f = ldexp( double_from_uint( hiMant )' expon -= 31 );  		f = Math.Pow (2.0' expon - 31) * double_from_uint (hiMant);  		//f += ldexp( double_from_uint( loMant )' expon -= 32 );  		f += Math.Pow (2.0' expon - 32) * double_from_uint (loMant);  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: if (expon == 0 && hiMant == 0 && loMant == 0) {  	f = 0;  } else {  	if (expon == 0x7FFF) {  		f = double.MaxValue;  	} else {  		expon -= 16383;  		//f = ldexp( double_from_uint( hiMant )' expon -= 31 );  		f = Math.Pow (2.0' expon - 31) * double_from_uint (hiMant);  		//f += ldexp( double_from_uint( loMant )' expon -= 32 );  		f += Math.Pow (2.0' expon - 32) * double_from_uint (loMant);  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: if (expon == 0x7FFF) {  	f = double.MaxValue;  } else {  	expon -= 16383;  	//f = ldexp( double_from_uint( hiMant )' expon -= 31 );  	f = Math.Pow (2.0' expon - 31) * double_from_uint (hiMant);  	//f += ldexp( double_from_uint( loMant )' expon -= 32 );  	f += Math.Pow (2.0' expon - 32) * double_from_uint (loMant);  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: if (expon == 0x7FFF) {  	f = double.MaxValue;  } else {  	expon -= 16383;  	//f = ldexp( double_from_uint( hiMant )' expon -= 31 );  	f = Math.Pow (2.0' expon - 31) * double_from_uint (hiMant);  	//f += ldexp( double_from_uint( loMant )' expon -= 32 );  	f += Math.Pow (2.0' expon - 32) * double_from_uint (loMant);  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: if (expon == 0x7FFF) {  	f = double.MaxValue;  } else {  	expon -= 16383;  	//f = ldexp( double_from_uint( hiMant )' expon -= 31 );  	f = Math.Pow (2.0' expon - 31) * double_from_uint (hiMant);  	//f += ldexp( double_from_uint( loMant )' expon -= 32 );  	f += Math.Pow (2.0' expon - 32) * double_from_uint (loMant);  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: if (expon == 0x7FFF) {  	f = double.MaxValue;  } else {  	expon -= 16383;  	//f = ldexp( double_from_uint( hiMant )' expon -= 31 );  	f = Math.Pow (2.0' expon - 31) * double_from_uint (hiMant);  	//f += ldexp( double_from_uint( loMant )' expon -= 32 );  	f += Math.Pow (2.0' expon - 32) * double_from_uint (loMant);  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: if (expon == 0x7FFF) {  	f = double.MaxValue;  } else {  	expon -= 16383;  	//f = ldexp( double_from_uint( hiMant )' expon -= 31 );  	f = Math.Pow (2.0' expon - 31) * double_from_uint (hiMant);  	//f += ldexp( double_from_uint( loMant )' expon -= 32 );  	f += Math.Pow (2.0' expon - 32) * double_from_uint (loMant);  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: expon -= 16383;  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: f = Math.Pow (2.0' expon - 31) * double_from_uint (hiMant);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: f = Math.Pow (2.0' expon - 31) * double_from_uint (hiMant);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: f += Math.Pow (2.0' expon - 32) * double_from_uint (loMant);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,make_double_from_extended,The following statement contains a magic number: f += Math.Pow (2.0' expon - 32) * double_from_uint (loMant);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,double_from_uint,The following statement contains a magic number: return (((double)((int)(u - 2147483647 - 1))) + 2147483648.0);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,double_from_uint,The following statement contains a magic number: return (((double)((int)(u - 2147483647 - 1))) + 2147483648.0);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	// detect size of RIFF chunk  	fs.read (buf' 0' 4);  	long riff_chunk_size = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; riff_chunk_size=" + riff_chunk_size ); #endif  	// check wave header  	fs.seek (8);  	fs.read (buf' 0' 4);  	if (buf [0] != 0x57 || buf [1] != 0x41 || buf [2] != 0x56 || buf [3] != 0x45) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid wave header" ); #endif  		fs.close ();  		return false;  	}  	// check fmt chunk header  	fs.read (buf' 0' 4);  	if (buf [0] != 0x66 || buf [1] != 0x6d || buf [2] != 0x74 || buf [3] != 0x20) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid fmt header" ); #endif  		fs.close ();  		return false;  	}  	// detect size of fmt chunk  	long fmt_chunk_bytes;  	fs.read (buf' 0' 4);  	fmt_chunk_bytes = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; fmt_chunk_bytes=" + fmt_chunk_bytes ); #endif  	// get format ID  	fs.read (buf' 0' 2);  	int format_id = PortUtil.make_uint16_le (buf);  	if (format_id != 1) {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; format_id=" + format_id ); #endif  	// get the number of channel(s)  	fs.read (buf' 0' 2);  	int num_channels = PortUtil.make_uint16_le (buf);  	if (num_channels == 1) {  		m_channel = WaveChannel.Monoral;  	} else if (num_channels == 2) {  		m_channel = WaveChannel.Stereo;  	} else {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; num_channels=" + num_channels ); #endif  	// get sampling rate  	fs.read (buf' 0' 4);  	m_sample_rate = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_sample_rate=" + m_sample_rate ); #endif  	// get bit per sample  	fs.seek (0x22);  	fs.read (buf' 0' 2);  	m_bit_per_sample = PortUtil.make_uint16_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_bit_per_sample=" + m_bit_per_sample ); #endif  	if (m_bit_per_sample != 0x08 && m_bit_per_sample != 0x10) {  		fs.close ();  		return false;  	}  	// move to the end of fmt chunk  	fs.seek (0x14 + fmt_chunk_bytes);  	// move to the top of data chunk  	fs.read (buf' 0' 4);  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	while (!tag.Equals ("data")) {  		fs.read (buf' 0' 4);  		long size = PortUtil.make_uint32_le (buf);  		fs.seek (fs.getFilePointer () + size);  		fs.read (buf' 0' 4);  		tag = new String (new char[] {  			(char)buf [0]'  			(char)buf [1]'  			(char)buf [2]'  			(char)buf [3]  		});  		#if DEBUG  		                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	}  	// get size of data chunk  	fs.read (buf' 0' 4);  	long data_chunk_bytes = PortUtil.make_uint32_le (buf);  	m_total_samples = (long)(data_chunk_bytes / (num_channels * m_bit_per_sample / 8));  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_total_samples=" + m_total_samples ); #endif  } catch (Exception ex) {  	#if DEBUG  	                serr.println( "WaveparseWaveHeader; ex=" + ex ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	// detect size of RIFF chunk  	fs.read (buf' 0' 4);  	long riff_chunk_size = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; riff_chunk_size=" + riff_chunk_size ); #endif  	// check wave header  	fs.seek (8);  	fs.read (buf' 0' 4);  	if (buf [0] != 0x57 || buf [1] != 0x41 || buf [2] != 0x56 || buf [3] != 0x45) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid wave header" ); #endif  		fs.close ();  		return false;  	}  	// check fmt chunk header  	fs.read (buf' 0' 4);  	if (buf [0] != 0x66 || buf [1] != 0x6d || buf [2] != 0x74 || buf [3] != 0x20) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid fmt header" ); #endif  		fs.close ();  		return false;  	}  	// detect size of fmt chunk  	long fmt_chunk_bytes;  	fs.read (buf' 0' 4);  	fmt_chunk_bytes = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; fmt_chunk_bytes=" + fmt_chunk_bytes ); #endif  	// get format ID  	fs.read (buf' 0' 2);  	int format_id = PortUtil.make_uint16_le (buf);  	if (format_id != 1) {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; format_id=" + format_id ); #endif  	// get the number of channel(s)  	fs.read (buf' 0' 2);  	int num_channels = PortUtil.make_uint16_le (buf);  	if (num_channels == 1) {  		m_channel = WaveChannel.Monoral;  	} else if (num_channels == 2) {  		m_channel = WaveChannel.Stereo;  	} else {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; num_channels=" + num_channels ); #endif  	// get sampling rate  	fs.read (buf' 0' 4);  	m_sample_rate = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_sample_rate=" + m_sample_rate ); #endif  	// get bit per sample  	fs.seek (0x22);  	fs.read (buf' 0' 2);  	m_bit_per_sample = PortUtil.make_uint16_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_bit_per_sample=" + m_bit_per_sample ); #endif  	if (m_bit_per_sample != 0x08 && m_bit_per_sample != 0x10) {  		fs.close ();  		return false;  	}  	// move to the end of fmt chunk  	fs.seek (0x14 + fmt_chunk_bytes);  	// move to the top of data chunk  	fs.read (buf' 0' 4);  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	while (!tag.Equals ("data")) {  		fs.read (buf' 0' 4);  		long size = PortUtil.make_uint32_le (buf);  		fs.seek (fs.getFilePointer () + size);  		fs.read (buf' 0' 4);  		tag = new String (new char[] {  			(char)buf [0]'  			(char)buf [1]'  			(char)buf [2]'  			(char)buf [3]  		});  		#if DEBUG  		                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	}  	// get size of data chunk  	fs.read (buf' 0' 4);  	long data_chunk_bytes = PortUtil.make_uint32_le (buf);  	m_total_samples = (long)(data_chunk_bytes / (num_channels * m_bit_per_sample / 8));  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_total_samples=" + m_total_samples ); #endif  } catch (Exception ex) {  	#if DEBUG  	                serr.println( "WaveparseWaveHeader; ex=" + ex ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	// detect size of RIFF chunk  	fs.read (buf' 0' 4);  	long riff_chunk_size = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; riff_chunk_size=" + riff_chunk_size ); #endif  	// check wave header  	fs.seek (8);  	fs.read (buf' 0' 4);  	if (buf [0] != 0x57 || buf [1] != 0x41 || buf [2] != 0x56 || buf [3] != 0x45) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid wave header" ); #endif  		fs.close ();  		return false;  	}  	// check fmt chunk header  	fs.read (buf' 0' 4);  	if (buf [0] != 0x66 || buf [1] != 0x6d || buf [2] != 0x74 || buf [3] != 0x20) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid fmt header" ); #endif  		fs.close ();  		return false;  	}  	// detect size of fmt chunk  	long fmt_chunk_bytes;  	fs.read (buf' 0' 4);  	fmt_chunk_bytes = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; fmt_chunk_bytes=" + fmt_chunk_bytes ); #endif  	// get format ID  	fs.read (buf' 0' 2);  	int format_id = PortUtil.make_uint16_le (buf);  	if (format_id != 1) {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; format_id=" + format_id ); #endif  	// get the number of channel(s)  	fs.read (buf' 0' 2);  	int num_channels = PortUtil.make_uint16_le (buf);  	if (num_channels == 1) {  		m_channel = WaveChannel.Monoral;  	} else if (num_channels == 2) {  		m_channel = WaveChannel.Stereo;  	} else {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; num_channels=" + num_channels ); #endif  	// get sampling rate  	fs.read (buf' 0' 4);  	m_sample_rate = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_sample_rate=" + m_sample_rate ); #endif  	// get bit per sample  	fs.seek (0x22);  	fs.read (buf' 0' 2);  	m_bit_per_sample = PortUtil.make_uint16_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_bit_per_sample=" + m_bit_per_sample ); #endif  	if (m_bit_per_sample != 0x08 && m_bit_per_sample != 0x10) {  		fs.close ();  		return false;  	}  	// move to the end of fmt chunk  	fs.seek (0x14 + fmt_chunk_bytes);  	// move to the top of data chunk  	fs.read (buf' 0' 4);  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	while (!tag.Equals ("data")) {  		fs.read (buf' 0' 4);  		long size = PortUtil.make_uint32_le (buf);  		fs.seek (fs.getFilePointer () + size);  		fs.read (buf' 0' 4);  		tag = new String (new char[] {  			(char)buf [0]'  			(char)buf [1]'  			(char)buf [2]'  			(char)buf [3]  		});  		#if DEBUG  		                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	}  	// get size of data chunk  	fs.read (buf' 0' 4);  	long data_chunk_bytes = PortUtil.make_uint32_le (buf);  	m_total_samples = (long)(data_chunk_bytes / (num_channels * m_bit_per_sample / 8));  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_total_samples=" + m_total_samples ); #endif  } catch (Exception ex) {  	#if DEBUG  	                serr.println( "WaveparseWaveHeader; ex=" + ex ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	// detect size of RIFF chunk  	fs.read (buf' 0' 4);  	long riff_chunk_size = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; riff_chunk_size=" + riff_chunk_size ); #endif  	// check wave header  	fs.seek (8);  	fs.read (buf' 0' 4);  	if (buf [0] != 0x57 || buf [1] != 0x41 || buf [2] != 0x56 || buf [3] != 0x45) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid wave header" ); #endif  		fs.close ();  		return false;  	}  	// check fmt chunk header  	fs.read (buf' 0' 4);  	if (buf [0] != 0x66 || buf [1] != 0x6d || buf [2] != 0x74 || buf [3] != 0x20) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid fmt header" ); #endif  		fs.close ();  		return false;  	}  	// detect size of fmt chunk  	long fmt_chunk_bytes;  	fs.read (buf' 0' 4);  	fmt_chunk_bytes = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; fmt_chunk_bytes=" + fmt_chunk_bytes ); #endif  	// get format ID  	fs.read (buf' 0' 2);  	int format_id = PortUtil.make_uint16_le (buf);  	if (format_id != 1) {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; format_id=" + format_id ); #endif  	// get the number of channel(s)  	fs.read (buf' 0' 2);  	int num_channels = PortUtil.make_uint16_le (buf);  	if (num_channels == 1) {  		m_channel = WaveChannel.Monoral;  	} else if (num_channels == 2) {  		m_channel = WaveChannel.Stereo;  	} else {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; num_channels=" + num_channels ); #endif  	// get sampling rate  	fs.read (buf' 0' 4);  	m_sample_rate = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_sample_rate=" + m_sample_rate ); #endif  	// get bit per sample  	fs.seek (0x22);  	fs.read (buf' 0' 2);  	m_bit_per_sample = PortUtil.make_uint16_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_bit_per_sample=" + m_bit_per_sample ); #endif  	if (m_bit_per_sample != 0x08 && m_bit_per_sample != 0x10) {  		fs.close ();  		return false;  	}  	// move to the end of fmt chunk  	fs.seek (0x14 + fmt_chunk_bytes);  	// move to the top of data chunk  	fs.read (buf' 0' 4);  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	while (!tag.Equals ("data")) {  		fs.read (buf' 0' 4);  		long size = PortUtil.make_uint32_le (buf);  		fs.seek (fs.getFilePointer () + size);  		fs.read (buf' 0' 4);  		tag = new String (new char[] {  			(char)buf [0]'  			(char)buf [1]'  			(char)buf [2]'  			(char)buf [3]  		});  		#if DEBUG  		                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	}  	// get size of data chunk  	fs.read (buf' 0' 4);  	long data_chunk_bytes = PortUtil.make_uint32_le (buf);  	m_total_samples = (long)(data_chunk_bytes / (num_channels * m_bit_per_sample / 8));  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_total_samples=" + m_total_samples ); #endif  } catch (Exception ex) {  	#if DEBUG  	                serr.println( "WaveparseWaveHeader; ex=" + ex ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	// detect size of RIFF chunk  	fs.read (buf' 0' 4);  	long riff_chunk_size = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; riff_chunk_size=" + riff_chunk_size ); #endif  	// check wave header  	fs.seek (8);  	fs.read (buf' 0' 4);  	if (buf [0] != 0x57 || buf [1] != 0x41 || buf [2] != 0x56 || buf [3] != 0x45) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid wave header" ); #endif  		fs.close ();  		return false;  	}  	// check fmt chunk header  	fs.read (buf' 0' 4);  	if (buf [0] != 0x66 || buf [1] != 0x6d || buf [2] != 0x74 || buf [3] != 0x20) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid fmt header" ); #endif  		fs.close ();  		return false;  	}  	// detect size of fmt chunk  	long fmt_chunk_bytes;  	fs.read (buf' 0' 4);  	fmt_chunk_bytes = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; fmt_chunk_bytes=" + fmt_chunk_bytes ); #endif  	// get format ID  	fs.read (buf' 0' 2);  	int format_id = PortUtil.make_uint16_le (buf);  	if (format_id != 1) {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; format_id=" + format_id ); #endif  	// get the number of channel(s)  	fs.read (buf' 0' 2);  	int num_channels = PortUtil.make_uint16_le (buf);  	if (num_channels == 1) {  		m_channel = WaveChannel.Monoral;  	} else if (num_channels == 2) {  		m_channel = WaveChannel.Stereo;  	} else {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; num_channels=" + num_channels ); #endif  	// get sampling rate  	fs.read (buf' 0' 4);  	m_sample_rate = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_sample_rate=" + m_sample_rate ); #endif  	// get bit per sample  	fs.seek (0x22);  	fs.read (buf' 0' 2);  	m_bit_per_sample = PortUtil.make_uint16_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_bit_per_sample=" + m_bit_per_sample ); #endif  	if (m_bit_per_sample != 0x08 && m_bit_per_sample != 0x10) {  		fs.close ();  		return false;  	}  	// move to the end of fmt chunk  	fs.seek (0x14 + fmt_chunk_bytes);  	// move to the top of data chunk  	fs.read (buf' 0' 4);  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	while (!tag.Equals ("data")) {  		fs.read (buf' 0' 4);  		long size = PortUtil.make_uint32_le (buf);  		fs.seek (fs.getFilePointer () + size);  		fs.read (buf' 0' 4);  		tag = new String (new char[] {  			(char)buf [0]'  			(char)buf [1]'  			(char)buf [2]'  			(char)buf [3]  		});  		#if DEBUG  		                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	}  	// get size of data chunk  	fs.read (buf' 0' 4);  	long data_chunk_bytes = PortUtil.make_uint32_le (buf);  	m_total_samples = (long)(data_chunk_bytes / (num_channels * m_bit_per_sample / 8));  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_total_samples=" + m_total_samples ); #endif  } catch (Exception ex) {  	#if DEBUG  	                serr.println( "WaveparseWaveHeader; ex=" + ex ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	// detect size of RIFF chunk  	fs.read (buf' 0' 4);  	long riff_chunk_size = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; riff_chunk_size=" + riff_chunk_size ); #endif  	// check wave header  	fs.seek (8);  	fs.read (buf' 0' 4);  	if (buf [0] != 0x57 || buf [1] != 0x41 || buf [2] != 0x56 || buf [3] != 0x45) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid wave header" ); #endif  		fs.close ();  		return false;  	}  	// check fmt chunk header  	fs.read (buf' 0' 4);  	if (buf [0] != 0x66 || buf [1] != 0x6d || buf [2] != 0x74 || buf [3] != 0x20) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid fmt header" ); #endif  		fs.close ();  		return false;  	}  	// detect size of fmt chunk  	long fmt_chunk_bytes;  	fs.read (buf' 0' 4);  	fmt_chunk_bytes = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; fmt_chunk_bytes=" + fmt_chunk_bytes ); #endif  	// get format ID  	fs.read (buf' 0' 2);  	int format_id = PortUtil.make_uint16_le (buf);  	if (format_id != 1) {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; format_id=" + format_id ); #endif  	// get the number of channel(s)  	fs.read (buf' 0' 2);  	int num_channels = PortUtil.make_uint16_le (buf);  	if (num_channels == 1) {  		m_channel = WaveChannel.Monoral;  	} else if (num_channels == 2) {  		m_channel = WaveChannel.Stereo;  	} else {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; num_channels=" + num_channels ); #endif  	// get sampling rate  	fs.read (buf' 0' 4);  	m_sample_rate = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_sample_rate=" + m_sample_rate ); #endif  	// get bit per sample  	fs.seek (0x22);  	fs.read (buf' 0' 2);  	m_bit_per_sample = PortUtil.make_uint16_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_bit_per_sample=" + m_bit_per_sample ); #endif  	if (m_bit_per_sample != 0x08 && m_bit_per_sample != 0x10) {  		fs.close ();  		return false;  	}  	// move to the end of fmt chunk  	fs.seek (0x14 + fmt_chunk_bytes);  	// move to the top of data chunk  	fs.read (buf' 0' 4);  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	while (!tag.Equals ("data")) {  		fs.read (buf' 0' 4);  		long size = PortUtil.make_uint32_le (buf);  		fs.seek (fs.getFilePointer () + size);  		fs.read (buf' 0' 4);  		tag = new String (new char[] {  			(char)buf [0]'  			(char)buf [1]'  			(char)buf [2]'  			(char)buf [3]  		});  		#if DEBUG  		                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	}  	// get size of data chunk  	fs.read (buf' 0' 4);  	long data_chunk_bytes = PortUtil.make_uint32_le (buf);  	m_total_samples = (long)(data_chunk_bytes / (num_channels * m_bit_per_sample / 8));  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_total_samples=" + m_total_samples ); #endif  } catch (Exception ex) {  	#if DEBUG  	                serr.println( "WaveparseWaveHeader; ex=" + ex ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	// detect size of RIFF chunk  	fs.read (buf' 0' 4);  	long riff_chunk_size = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; riff_chunk_size=" + riff_chunk_size ); #endif  	// check wave header  	fs.seek (8);  	fs.read (buf' 0' 4);  	if (buf [0] != 0x57 || buf [1] != 0x41 || buf [2] != 0x56 || buf [3] != 0x45) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid wave header" ); #endif  		fs.close ();  		return false;  	}  	// check fmt chunk header  	fs.read (buf' 0' 4);  	if (buf [0] != 0x66 || buf [1] != 0x6d || buf [2] != 0x74 || buf [3] != 0x20) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid fmt header" ); #endif  		fs.close ();  		return false;  	}  	// detect size of fmt chunk  	long fmt_chunk_bytes;  	fs.read (buf' 0' 4);  	fmt_chunk_bytes = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; fmt_chunk_bytes=" + fmt_chunk_bytes ); #endif  	// get format ID  	fs.read (buf' 0' 2);  	int format_id = PortUtil.make_uint16_le (buf);  	if (format_id != 1) {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; format_id=" + format_id ); #endif  	// get the number of channel(s)  	fs.read (buf' 0' 2);  	int num_channels = PortUtil.make_uint16_le (buf);  	if (num_channels == 1) {  		m_channel = WaveChannel.Monoral;  	} else if (num_channels == 2) {  		m_channel = WaveChannel.Stereo;  	} else {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; num_channels=" + num_channels ); #endif  	// get sampling rate  	fs.read (buf' 0' 4);  	m_sample_rate = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_sample_rate=" + m_sample_rate ); #endif  	// get bit per sample  	fs.seek (0x22);  	fs.read (buf' 0' 2);  	m_bit_per_sample = PortUtil.make_uint16_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_bit_per_sample=" + m_bit_per_sample ); #endif  	if (m_bit_per_sample != 0x08 && m_bit_per_sample != 0x10) {  		fs.close ();  		return false;  	}  	// move to the end of fmt chunk  	fs.seek (0x14 + fmt_chunk_bytes);  	// move to the top of data chunk  	fs.read (buf' 0' 4);  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	while (!tag.Equals ("data")) {  		fs.read (buf' 0' 4);  		long size = PortUtil.make_uint32_le (buf);  		fs.seek (fs.getFilePointer () + size);  		fs.read (buf' 0' 4);  		tag = new String (new char[] {  			(char)buf [0]'  			(char)buf [1]'  			(char)buf [2]'  			(char)buf [3]  		});  		#if DEBUG  		                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	}  	// get size of data chunk  	fs.read (buf' 0' 4);  	long data_chunk_bytes = PortUtil.make_uint32_le (buf);  	m_total_samples = (long)(data_chunk_bytes / (num_channels * m_bit_per_sample / 8));  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_total_samples=" + m_total_samples ); #endif  } catch (Exception ex) {  	#if DEBUG  	                serr.println( "WaveparseWaveHeader; ex=" + ex ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	// detect size of RIFF chunk  	fs.read (buf' 0' 4);  	long riff_chunk_size = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; riff_chunk_size=" + riff_chunk_size ); #endif  	// check wave header  	fs.seek (8);  	fs.read (buf' 0' 4);  	if (buf [0] != 0x57 || buf [1] != 0x41 || buf [2] != 0x56 || buf [3] != 0x45) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid wave header" ); #endif  		fs.close ();  		return false;  	}  	// check fmt chunk header  	fs.read (buf' 0' 4);  	if (buf [0] != 0x66 || buf [1] != 0x6d || buf [2] != 0x74 || buf [3] != 0x20) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid fmt header" ); #endif  		fs.close ();  		return false;  	}  	// detect size of fmt chunk  	long fmt_chunk_bytes;  	fs.read (buf' 0' 4);  	fmt_chunk_bytes = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; fmt_chunk_bytes=" + fmt_chunk_bytes ); #endif  	// get format ID  	fs.read (buf' 0' 2);  	int format_id = PortUtil.make_uint16_le (buf);  	if (format_id != 1) {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; format_id=" + format_id ); #endif  	// get the number of channel(s)  	fs.read (buf' 0' 2);  	int num_channels = PortUtil.make_uint16_le (buf);  	if (num_channels == 1) {  		m_channel = WaveChannel.Monoral;  	} else if (num_channels == 2) {  		m_channel = WaveChannel.Stereo;  	} else {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; num_channels=" + num_channels ); #endif  	// get sampling rate  	fs.read (buf' 0' 4);  	m_sample_rate = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_sample_rate=" + m_sample_rate ); #endif  	// get bit per sample  	fs.seek (0x22);  	fs.read (buf' 0' 2);  	m_bit_per_sample = PortUtil.make_uint16_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_bit_per_sample=" + m_bit_per_sample ); #endif  	if (m_bit_per_sample != 0x08 && m_bit_per_sample != 0x10) {  		fs.close ();  		return false;  	}  	// move to the end of fmt chunk  	fs.seek (0x14 + fmt_chunk_bytes);  	// move to the top of data chunk  	fs.read (buf' 0' 4);  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	while (!tag.Equals ("data")) {  		fs.read (buf' 0' 4);  		long size = PortUtil.make_uint32_le (buf);  		fs.seek (fs.getFilePointer () + size);  		fs.read (buf' 0' 4);  		tag = new String (new char[] {  			(char)buf [0]'  			(char)buf [1]'  			(char)buf [2]'  			(char)buf [3]  		});  		#if DEBUG  		                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	}  	// get size of data chunk  	fs.read (buf' 0' 4);  	long data_chunk_bytes = PortUtil.make_uint32_le (buf);  	m_total_samples = (long)(data_chunk_bytes / (num_channels * m_bit_per_sample / 8));  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_total_samples=" + m_total_samples ); #endif  } catch (Exception ex) {  	#if DEBUG  	                serr.println( "WaveparseWaveHeader; ex=" + ex ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	// detect size of RIFF chunk  	fs.read (buf' 0' 4);  	long riff_chunk_size = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; riff_chunk_size=" + riff_chunk_size ); #endif  	// check wave header  	fs.seek (8);  	fs.read (buf' 0' 4);  	if (buf [0] != 0x57 || buf [1] != 0x41 || buf [2] != 0x56 || buf [3] != 0x45) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid wave header" ); #endif  		fs.close ();  		return false;  	}  	// check fmt chunk header  	fs.read (buf' 0' 4);  	if (buf [0] != 0x66 || buf [1] != 0x6d || buf [2] != 0x74 || buf [3] != 0x20) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid fmt header" ); #endif  		fs.close ();  		return false;  	}  	// detect size of fmt chunk  	long fmt_chunk_bytes;  	fs.read (buf' 0' 4);  	fmt_chunk_bytes = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; fmt_chunk_bytes=" + fmt_chunk_bytes ); #endif  	// get format ID  	fs.read (buf' 0' 2);  	int format_id = PortUtil.make_uint16_le (buf);  	if (format_id != 1) {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; format_id=" + format_id ); #endif  	// get the number of channel(s)  	fs.read (buf' 0' 2);  	int num_channels = PortUtil.make_uint16_le (buf);  	if (num_channels == 1) {  		m_channel = WaveChannel.Monoral;  	} else if (num_channels == 2) {  		m_channel = WaveChannel.Stereo;  	} else {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; num_channels=" + num_channels ); #endif  	// get sampling rate  	fs.read (buf' 0' 4);  	m_sample_rate = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_sample_rate=" + m_sample_rate ); #endif  	// get bit per sample  	fs.seek (0x22);  	fs.read (buf' 0' 2);  	m_bit_per_sample = PortUtil.make_uint16_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_bit_per_sample=" + m_bit_per_sample ); #endif  	if (m_bit_per_sample != 0x08 && m_bit_per_sample != 0x10) {  		fs.close ();  		return false;  	}  	// move to the end of fmt chunk  	fs.seek (0x14 + fmt_chunk_bytes);  	// move to the top of data chunk  	fs.read (buf' 0' 4);  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	while (!tag.Equals ("data")) {  		fs.read (buf' 0' 4);  		long size = PortUtil.make_uint32_le (buf);  		fs.seek (fs.getFilePointer () + size);  		fs.read (buf' 0' 4);  		tag = new String (new char[] {  			(char)buf [0]'  			(char)buf [1]'  			(char)buf [2]'  			(char)buf [3]  		});  		#if DEBUG  		                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	}  	// get size of data chunk  	fs.read (buf' 0' 4);  	long data_chunk_bytes = PortUtil.make_uint32_le (buf);  	m_total_samples = (long)(data_chunk_bytes / (num_channels * m_bit_per_sample / 8));  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_total_samples=" + m_total_samples ); #endif  } catch (Exception ex) {  	#if DEBUG  	                serr.println( "WaveparseWaveHeader; ex=" + ex ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	// detect size of RIFF chunk  	fs.read (buf' 0' 4);  	long riff_chunk_size = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; riff_chunk_size=" + riff_chunk_size ); #endif  	// check wave header  	fs.seek (8);  	fs.read (buf' 0' 4);  	if (buf [0] != 0x57 || buf [1] != 0x41 || buf [2] != 0x56 || buf [3] != 0x45) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid wave header" ); #endif  		fs.close ();  		return false;  	}  	// check fmt chunk header  	fs.read (buf' 0' 4);  	if (buf [0] != 0x66 || buf [1] != 0x6d || buf [2] != 0x74 || buf [3] != 0x20) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid fmt header" ); #endif  		fs.close ();  		return false;  	}  	// detect size of fmt chunk  	long fmt_chunk_bytes;  	fs.read (buf' 0' 4);  	fmt_chunk_bytes = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; fmt_chunk_bytes=" + fmt_chunk_bytes ); #endif  	// get format ID  	fs.read (buf' 0' 2);  	int format_id = PortUtil.make_uint16_le (buf);  	if (format_id != 1) {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; format_id=" + format_id ); #endif  	// get the number of channel(s)  	fs.read (buf' 0' 2);  	int num_channels = PortUtil.make_uint16_le (buf);  	if (num_channels == 1) {  		m_channel = WaveChannel.Monoral;  	} else if (num_channels == 2) {  		m_channel = WaveChannel.Stereo;  	} else {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; num_channels=" + num_channels ); #endif  	// get sampling rate  	fs.read (buf' 0' 4);  	m_sample_rate = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_sample_rate=" + m_sample_rate ); #endif  	// get bit per sample  	fs.seek (0x22);  	fs.read (buf' 0' 2);  	m_bit_per_sample = PortUtil.make_uint16_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_bit_per_sample=" + m_bit_per_sample ); #endif  	if (m_bit_per_sample != 0x08 && m_bit_per_sample != 0x10) {  		fs.close ();  		return false;  	}  	// move to the end of fmt chunk  	fs.seek (0x14 + fmt_chunk_bytes);  	// move to the top of data chunk  	fs.read (buf' 0' 4);  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	while (!tag.Equals ("data")) {  		fs.read (buf' 0' 4);  		long size = PortUtil.make_uint32_le (buf);  		fs.seek (fs.getFilePointer () + size);  		fs.read (buf' 0' 4);  		tag = new String (new char[] {  			(char)buf [0]'  			(char)buf [1]'  			(char)buf [2]'  			(char)buf [3]  		});  		#if DEBUG  		                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	}  	// get size of data chunk  	fs.read (buf' 0' 4);  	long data_chunk_bytes = PortUtil.make_uint32_le (buf);  	m_total_samples = (long)(data_chunk_bytes / (num_channels * m_bit_per_sample / 8));  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_total_samples=" + m_total_samples ); #endif  } catch (Exception ex) {  	#if DEBUG  	                serr.println( "WaveparseWaveHeader; ex=" + ex ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	// detect size of RIFF chunk  	fs.read (buf' 0' 4);  	long riff_chunk_size = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; riff_chunk_size=" + riff_chunk_size ); #endif  	// check wave header  	fs.seek (8);  	fs.read (buf' 0' 4);  	if (buf [0] != 0x57 || buf [1] != 0x41 || buf [2] != 0x56 || buf [3] != 0x45) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid wave header" ); #endif  		fs.close ();  		return false;  	}  	// check fmt chunk header  	fs.read (buf' 0' 4);  	if (buf [0] != 0x66 || buf [1] != 0x6d || buf [2] != 0x74 || buf [3] != 0x20) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid fmt header" ); #endif  		fs.close ();  		return false;  	}  	// detect size of fmt chunk  	long fmt_chunk_bytes;  	fs.read (buf' 0' 4);  	fmt_chunk_bytes = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; fmt_chunk_bytes=" + fmt_chunk_bytes ); #endif  	// get format ID  	fs.read (buf' 0' 2);  	int format_id = PortUtil.make_uint16_le (buf);  	if (format_id != 1) {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; format_id=" + format_id ); #endif  	// get the number of channel(s)  	fs.read (buf' 0' 2);  	int num_channels = PortUtil.make_uint16_le (buf);  	if (num_channels == 1) {  		m_channel = WaveChannel.Monoral;  	} else if (num_channels == 2) {  		m_channel = WaveChannel.Stereo;  	} else {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; num_channels=" + num_channels ); #endif  	// get sampling rate  	fs.read (buf' 0' 4);  	m_sample_rate = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_sample_rate=" + m_sample_rate ); #endif  	// get bit per sample  	fs.seek (0x22);  	fs.read (buf' 0' 2);  	m_bit_per_sample = PortUtil.make_uint16_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_bit_per_sample=" + m_bit_per_sample ); #endif  	if (m_bit_per_sample != 0x08 && m_bit_per_sample != 0x10) {  		fs.close ();  		return false;  	}  	// move to the end of fmt chunk  	fs.seek (0x14 + fmt_chunk_bytes);  	// move to the top of data chunk  	fs.read (buf' 0' 4);  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	while (!tag.Equals ("data")) {  		fs.read (buf' 0' 4);  		long size = PortUtil.make_uint32_le (buf);  		fs.seek (fs.getFilePointer () + size);  		fs.read (buf' 0' 4);  		tag = new String (new char[] {  			(char)buf [0]'  			(char)buf [1]'  			(char)buf [2]'  			(char)buf [3]  		});  		#if DEBUG  		                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	}  	// get size of data chunk  	fs.read (buf' 0' 4);  	long data_chunk_bytes = PortUtil.make_uint32_le (buf);  	m_total_samples = (long)(data_chunk_bytes / (num_channels * m_bit_per_sample / 8));  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_total_samples=" + m_total_samples ); #endif  } catch (Exception ex) {  	#if DEBUG  	                serr.println( "WaveparseWaveHeader; ex=" + ex ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	// detect size of RIFF chunk  	fs.read (buf' 0' 4);  	long riff_chunk_size = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; riff_chunk_size=" + riff_chunk_size ); #endif  	// check wave header  	fs.seek (8);  	fs.read (buf' 0' 4);  	if (buf [0] != 0x57 || buf [1] != 0x41 || buf [2] != 0x56 || buf [3] != 0x45) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid wave header" ); #endif  		fs.close ();  		return false;  	}  	// check fmt chunk header  	fs.read (buf' 0' 4);  	if (buf [0] != 0x66 || buf [1] != 0x6d || buf [2] != 0x74 || buf [3] != 0x20) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid fmt header" ); #endif  		fs.close ();  		return false;  	}  	// detect size of fmt chunk  	long fmt_chunk_bytes;  	fs.read (buf' 0' 4);  	fmt_chunk_bytes = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; fmt_chunk_bytes=" + fmt_chunk_bytes ); #endif  	// get format ID  	fs.read (buf' 0' 2);  	int format_id = PortUtil.make_uint16_le (buf);  	if (format_id != 1) {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; format_id=" + format_id ); #endif  	// get the number of channel(s)  	fs.read (buf' 0' 2);  	int num_channels = PortUtil.make_uint16_le (buf);  	if (num_channels == 1) {  		m_channel = WaveChannel.Monoral;  	} else if (num_channels == 2) {  		m_channel = WaveChannel.Stereo;  	} else {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; num_channels=" + num_channels ); #endif  	// get sampling rate  	fs.read (buf' 0' 4);  	m_sample_rate = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_sample_rate=" + m_sample_rate ); #endif  	// get bit per sample  	fs.seek (0x22);  	fs.read (buf' 0' 2);  	m_bit_per_sample = PortUtil.make_uint16_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_bit_per_sample=" + m_bit_per_sample ); #endif  	if (m_bit_per_sample != 0x08 && m_bit_per_sample != 0x10) {  		fs.close ();  		return false;  	}  	// move to the end of fmt chunk  	fs.seek (0x14 + fmt_chunk_bytes);  	// move to the top of data chunk  	fs.read (buf' 0' 4);  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	while (!tag.Equals ("data")) {  		fs.read (buf' 0' 4);  		long size = PortUtil.make_uint32_le (buf);  		fs.seek (fs.getFilePointer () + size);  		fs.read (buf' 0' 4);  		tag = new String (new char[] {  			(char)buf [0]'  			(char)buf [1]'  			(char)buf [2]'  			(char)buf [3]  		});  		#if DEBUG  		                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	}  	// get size of data chunk  	fs.read (buf' 0' 4);  	long data_chunk_bytes = PortUtil.make_uint32_le (buf);  	m_total_samples = (long)(data_chunk_bytes / (num_channels * m_bit_per_sample / 8));  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_total_samples=" + m_total_samples ); #endif  } catch (Exception ex) {  	#if DEBUG  	                serr.println( "WaveparseWaveHeader; ex=" + ex ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	// detect size of RIFF chunk  	fs.read (buf' 0' 4);  	long riff_chunk_size = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; riff_chunk_size=" + riff_chunk_size ); #endif  	// check wave header  	fs.seek (8);  	fs.read (buf' 0' 4);  	if (buf [0] != 0x57 || buf [1] != 0x41 || buf [2] != 0x56 || buf [3] != 0x45) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid wave header" ); #endif  		fs.close ();  		return false;  	}  	// check fmt chunk header  	fs.read (buf' 0' 4);  	if (buf [0] != 0x66 || buf [1] != 0x6d || buf [2] != 0x74 || buf [3] != 0x20) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid fmt header" ); #endif  		fs.close ();  		return false;  	}  	// detect size of fmt chunk  	long fmt_chunk_bytes;  	fs.read (buf' 0' 4);  	fmt_chunk_bytes = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; fmt_chunk_bytes=" + fmt_chunk_bytes ); #endif  	// get format ID  	fs.read (buf' 0' 2);  	int format_id = PortUtil.make_uint16_le (buf);  	if (format_id != 1) {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; format_id=" + format_id ); #endif  	// get the number of channel(s)  	fs.read (buf' 0' 2);  	int num_channels = PortUtil.make_uint16_le (buf);  	if (num_channels == 1) {  		m_channel = WaveChannel.Monoral;  	} else if (num_channels == 2) {  		m_channel = WaveChannel.Stereo;  	} else {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; num_channels=" + num_channels ); #endif  	// get sampling rate  	fs.read (buf' 0' 4);  	m_sample_rate = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_sample_rate=" + m_sample_rate ); #endif  	// get bit per sample  	fs.seek (0x22);  	fs.read (buf' 0' 2);  	m_bit_per_sample = PortUtil.make_uint16_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_bit_per_sample=" + m_bit_per_sample ); #endif  	if (m_bit_per_sample != 0x08 && m_bit_per_sample != 0x10) {  		fs.close ();  		return false;  	}  	// move to the end of fmt chunk  	fs.seek (0x14 + fmt_chunk_bytes);  	// move to the top of data chunk  	fs.read (buf' 0' 4);  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	while (!tag.Equals ("data")) {  		fs.read (buf' 0' 4);  		long size = PortUtil.make_uint32_le (buf);  		fs.seek (fs.getFilePointer () + size);  		fs.read (buf' 0' 4);  		tag = new String (new char[] {  			(char)buf [0]'  			(char)buf [1]'  			(char)buf [2]'  			(char)buf [3]  		});  		#if DEBUG  		                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	}  	// get size of data chunk  	fs.read (buf' 0' 4);  	long data_chunk_bytes = PortUtil.make_uint32_le (buf);  	m_total_samples = (long)(data_chunk_bytes / (num_channels * m_bit_per_sample / 8));  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_total_samples=" + m_total_samples ); #endif  } catch (Exception ex) {  	#if DEBUG  	                serr.println( "WaveparseWaveHeader; ex=" + ex ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	// detect size of RIFF chunk  	fs.read (buf' 0' 4);  	long riff_chunk_size = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; riff_chunk_size=" + riff_chunk_size ); #endif  	// check wave header  	fs.seek (8);  	fs.read (buf' 0' 4);  	if (buf [0] != 0x57 || buf [1] != 0x41 || buf [2] != 0x56 || buf [3] != 0x45) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid wave header" ); #endif  		fs.close ();  		return false;  	}  	// check fmt chunk header  	fs.read (buf' 0' 4);  	if (buf [0] != 0x66 || buf [1] != 0x6d || buf [2] != 0x74 || buf [3] != 0x20) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid fmt header" ); #endif  		fs.close ();  		return false;  	}  	// detect size of fmt chunk  	long fmt_chunk_bytes;  	fs.read (buf' 0' 4);  	fmt_chunk_bytes = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; fmt_chunk_bytes=" + fmt_chunk_bytes ); #endif  	// get format ID  	fs.read (buf' 0' 2);  	int format_id = PortUtil.make_uint16_le (buf);  	if (format_id != 1) {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; format_id=" + format_id ); #endif  	// get the number of channel(s)  	fs.read (buf' 0' 2);  	int num_channels = PortUtil.make_uint16_le (buf);  	if (num_channels == 1) {  		m_channel = WaveChannel.Monoral;  	} else if (num_channels == 2) {  		m_channel = WaveChannel.Stereo;  	} else {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; num_channels=" + num_channels ); #endif  	// get sampling rate  	fs.read (buf' 0' 4);  	m_sample_rate = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_sample_rate=" + m_sample_rate ); #endif  	// get bit per sample  	fs.seek (0x22);  	fs.read (buf' 0' 2);  	m_bit_per_sample = PortUtil.make_uint16_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_bit_per_sample=" + m_bit_per_sample ); #endif  	if (m_bit_per_sample != 0x08 && m_bit_per_sample != 0x10) {  		fs.close ();  		return false;  	}  	// move to the end of fmt chunk  	fs.seek (0x14 + fmt_chunk_bytes);  	// move to the top of data chunk  	fs.read (buf' 0' 4);  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	while (!tag.Equals ("data")) {  		fs.read (buf' 0' 4);  		long size = PortUtil.make_uint32_le (buf);  		fs.seek (fs.getFilePointer () + size);  		fs.read (buf' 0' 4);  		tag = new String (new char[] {  			(char)buf [0]'  			(char)buf [1]'  			(char)buf [2]'  			(char)buf [3]  		});  		#if DEBUG  		                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	}  	// get size of data chunk  	fs.read (buf' 0' 4);  	long data_chunk_bytes = PortUtil.make_uint32_le (buf);  	m_total_samples = (long)(data_chunk_bytes / (num_channels * m_bit_per_sample / 8));  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_total_samples=" + m_total_samples ); #endif  } catch (Exception ex) {  	#if DEBUG  	                serr.println( "WaveparseWaveHeader; ex=" + ex ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	// detect size of RIFF chunk  	fs.read (buf' 0' 4);  	long riff_chunk_size = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; riff_chunk_size=" + riff_chunk_size ); #endif  	// check wave header  	fs.seek (8);  	fs.read (buf' 0' 4);  	if (buf [0] != 0x57 || buf [1] != 0x41 || buf [2] != 0x56 || buf [3] != 0x45) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid wave header" ); #endif  		fs.close ();  		return false;  	}  	// check fmt chunk header  	fs.read (buf' 0' 4);  	if (buf [0] != 0x66 || buf [1] != 0x6d || buf [2] != 0x74 || buf [3] != 0x20) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid fmt header" ); #endif  		fs.close ();  		return false;  	}  	// detect size of fmt chunk  	long fmt_chunk_bytes;  	fs.read (buf' 0' 4);  	fmt_chunk_bytes = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; fmt_chunk_bytes=" + fmt_chunk_bytes ); #endif  	// get format ID  	fs.read (buf' 0' 2);  	int format_id = PortUtil.make_uint16_le (buf);  	if (format_id != 1) {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; format_id=" + format_id ); #endif  	// get the number of channel(s)  	fs.read (buf' 0' 2);  	int num_channels = PortUtil.make_uint16_le (buf);  	if (num_channels == 1) {  		m_channel = WaveChannel.Monoral;  	} else if (num_channels == 2) {  		m_channel = WaveChannel.Stereo;  	} else {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; num_channels=" + num_channels ); #endif  	// get sampling rate  	fs.read (buf' 0' 4);  	m_sample_rate = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_sample_rate=" + m_sample_rate ); #endif  	// get bit per sample  	fs.seek (0x22);  	fs.read (buf' 0' 2);  	m_bit_per_sample = PortUtil.make_uint16_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_bit_per_sample=" + m_bit_per_sample ); #endif  	if (m_bit_per_sample != 0x08 && m_bit_per_sample != 0x10) {  		fs.close ();  		return false;  	}  	// move to the end of fmt chunk  	fs.seek (0x14 + fmt_chunk_bytes);  	// move to the top of data chunk  	fs.read (buf' 0' 4);  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	while (!tag.Equals ("data")) {  		fs.read (buf' 0' 4);  		long size = PortUtil.make_uint32_le (buf);  		fs.seek (fs.getFilePointer () + size);  		fs.read (buf' 0' 4);  		tag = new String (new char[] {  			(char)buf [0]'  			(char)buf [1]'  			(char)buf [2]'  			(char)buf [3]  		});  		#if DEBUG  		                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	}  	// get size of data chunk  	fs.read (buf' 0' 4);  	long data_chunk_bytes = PortUtil.make_uint32_le (buf);  	m_total_samples = (long)(data_chunk_bytes / (num_channels * m_bit_per_sample / 8));  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_total_samples=" + m_total_samples ); #endif  } catch (Exception ex) {  	#if DEBUG  	                serr.println( "WaveparseWaveHeader; ex=" + ex ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	// detect size of RIFF chunk  	fs.read (buf' 0' 4);  	long riff_chunk_size = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; riff_chunk_size=" + riff_chunk_size ); #endif  	// check wave header  	fs.seek (8);  	fs.read (buf' 0' 4);  	if (buf [0] != 0x57 || buf [1] != 0x41 || buf [2] != 0x56 || buf [3] != 0x45) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid wave header" ); #endif  		fs.close ();  		return false;  	}  	// check fmt chunk header  	fs.read (buf' 0' 4);  	if (buf [0] != 0x66 || buf [1] != 0x6d || buf [2] != 0x74 || buf [3] != 0x20) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid fmt header" ); #endif  		fs.close ();  		return false;  	}  	// detect size of fmt chunk  	long fmt_chunk_bytes;  	fs.read (buf' 0' 4);  	fmt_chunk_bytes = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; fmt_chunk_bytes=" + fmt_chunk_bytes ); #endif  	// get format ID  	fs.read (buf' 0' 2);  	int format_id = PortUtil.make_uint16_le (buf);  	if (format_id != 1) {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; format_id=" + format_id ); #endif  	// get the number of channel(s)  	fs.read (buf' 0' 2);  	int num_channels = PortUtil.make_uint16_le (buf);  	if (num_channels == 1) {  		m_channel = WaveChannel.Monoral;  	} else if (num_channels == 2) {  		m_channel = WaveChannel.Stereo;  	} else {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; num_channels=" + num_channels ); #endif  	// get sampling rate  	fs.read (buf' 0' 4);  	m_sample_rate = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_sample_rate=" + m_sample_rate ); #endif  	// get bit per sample  	fs.seek (0x22);  	fs.read (buf' 0' 2);  	m_bit_per_sample = PortUtil.make_uint16_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_bit_per_sample=" + m_bit_per_sample ); #endif  	if (m_bit_per_sample != 0x08 && m_bit_per_sample != 0x10) {  		fs.close ();  		return false;  	}  	// move to the end of fmt chunk  	fs.seek (0x14 + fmt_chunk_bytes);  	// move to the top of data chunk  	fs.read (buf' 0' 4);  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	while (!tag.Equals ("data")) {  		fs.read (buf' 0' 4);  		long size = PortUtil.make_uint32_le (buf);  		fs.seek (fs.getFilePointer () + size);  		fs.read (buf' 0' 4);  		tag = new String (new char[] {  			(char)buf [0]'  			(char)buf [1]'  			(char)buf [2]'  			(char)buf [3]  		});  		#if DEBUG  		                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	}  	// get size of data chunk  	fs.read (buf' 0' 4);  	long data_chunk_bytes = PortUtil.make_uint32_le (buf);  	m_total_samples = (long)(data_chunk_bytes / (num_channels * m_bit_per_sample / 8));  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_total_samples=" + m_total_samples ); #endif  } catch (Exception ex) {  	#if DEBUG  	                serr.println( "WaveparseWaveHeader; ex=" + ex ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	// detect size of RIFF chunk  	fs.read (buf' 0' 4);  	long riff_chunk_size = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; riff_chunk_size=" + riff_chunk_size ); #endif  	// check wave header  	fs.seek (8);  	fs.read (buf' 0' 4);  	if (buf [0] != 0x57 || buf [1] != 0x41 || buf [2] != 0x56 || buf [3] != 0x45) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid wave header" ); #endif  		fs.close ();  		return false;  	}  	// check fmt chunk header  	fs.read (buf' 0' 4);  	if (buf [0] != 0x66 || buf [1] != 0x6d || buf [2] != 0x74 || buf [3] != 0x20) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid fmt header" ); #endif  		fs.close ();  		return false;  	}  	// detect size of fmt chunk  	long fmt_chunk_bytes;  	fs.read (buf' 0' 4);  	fmt_chunk_bytes = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; fmt_chunk_bytes=" + fmt_chunk_bytes ); #endif  	// get format ID  	fs.read (buf' 0' 2);  	int format_id = PortUtil.make_uint16_le (buf);  	if (format_id != 1) {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; format_id=" + format_id ); #endif  	// get the number of channel(s)  	fs.read (buf' 0' 2);  	int num_channels = PortUtil.make_uint16_le (buf);  	if (num_channels == 1) {  		m_channel = WaveChannel.Monoral;  	} else if (num_channels == 2) {  		m_channel = WaveChannel.Stereo;  	} else {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; num_channels=" + num_channels ); #endif  	// get sampling rate  	fs.read (buf' 0' 4);  	m_sample_rate = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_sample_rate=" + m_sample_rate ); #endif  	// get bit per sample  	fs.seek (0x22);  	fs.read (buf' 0' 2);  	m_bit_per_sample = PortUtil.make_uint16_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_bit_per_sample=" + m_bit_per_sample ); #endif  	if (m_bit_per_sample != 0x08 && m_bit_per_sample != 0x10) {  		fs.close ();  		return false;  	}  	// move to the end of fmt chunk  	fs.seek (0x14 + fmt_chunk_bytes);  	// move to the top of data chunk  	fs.read (buf' 0' 4);  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	while (!tag.Equals ("data")) {  		fs.read (buf' 0' 4);  		long size = PortUtil.make_uint32_le (buf);  		fs.seek (fs.getFilePointer () + size);  		fs.read (buf' 0' 4);  		tag = new String (new char[] {  			(char)buf [0]'  			(char)buf [1]'  			(char)buf [2]'  			(char)buf [3]  		});  		#if DEBUG  		                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	}  	// get size of data chunk  	fs.read (buf' 0' 4);  	long data_chunk_bytes = PortUtil.make_uint32_le (buf);  	m_total_samples = (long)(data_chunk_bytes / (num_channels * m_bit_per_sample / 8));  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_total_samples=" + m_total_samples ); #endif  } catch (Exception ex) {  	#if DEBUG  	                serr.println( "WaveparseWaveHeader; ex=" + ex ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	// detect size of RIFF chunk  	fs.read (buf' 0' 4);  	long riff_chunk_size = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; riff_chunk_size=" + riff_chunk_size ); #endif  	// check wave header  	fs.seek (8);  	fs.read (buf' 0' 4);  	if (buf [0] != 0x57 || buf [1] != 0x41 || buf [2] != 0x56 || buf [3] != 0x45) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid wave header" ); #endif  		fs.close ();  		return false;  	}  	// check fmt chunk header  	fs.read (buf' 0' 4);  	if (buf [0] != 0x66 || buf [1] != 0x6d || buf [2] != 0x74 || buf [3] != 0x20) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid fmt header" ); #endif  		fs.close ();  		return false;  	}  	// detect size of fmt chunk  	long fmt_chunk_bytes;  	fs.read (buf' 0' 4);  	fmt_chunk_bytes = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; fmt_chunk_bytes=" + fmt_chunk_bytes ); #endif  	// get format ID  	fs.read (buf' 0' 2);  	int format_id = PortUtil.make_uint16_le (buf);  	if (format_id != 1) {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; format_id=" + format_id ); #endif  	// get the number of channel(s)  	fs.read (buf' 0' 2);  	int num_channels = PortUtil.make_uint16_le (buf);  	if (num_channels == 1) {  		m_channel = WaveChannel.Monoral;  	} else if (num_channels == 2) {  		m_channel = WaveChannel.Stereo;  	} else {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; num_channels=" + num_channels ); #endif  	// get sampling rate  	fs.read (buf' 0' 4);  	m_sample_rate = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_sample_rate=" + m_sample_rate ); #endif  	// get bit per sample  	fs.seek (0x22);  	fs.read (buf' 0' 2);  	m_bit_per_sample = PortUtil.make_uint16_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_bit_per_sample=" + m_bit_per_sample ); #endif  	if (m_bit_per_sample != 0x08 && m_bit_per_sample != 0x10) {  		fs.close ();  		return false;  	}  	// move to the end of fmt chunk  	fs.seek (0x14 + fmt_chunk_bytes);  	// move to the top of data chunk  	fs.read (buf' 0' 4);  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	while (!tag.Equals ("data")) {  		fs.read (buf' 0' 4);  		long size = PortUtil.make_uint32_le (buf);  		fs.seek (fs.getFilePointer () + size);  		fs.read (buf' 0' 4);  		tag = new String (new char[] {  			(char)buf [0]'  			(char)buf [1]'  			(char)buf [2]'  			(char)buf [3]  		});  		#if DEBUG  		                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	}  	// get size of data chunk  	fs.read (buf' 0' 4);  	long data_chunk_bytes = PortUtil.make_uint32_le (buf);  	m_total_samples = (long)(data_chunk_bytes / (num_channels * m_bit_per_sample / 8));  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_total_samples=" + m_total_samples ); #endif  } catch (Exception ex) {  	#if DEBUG  	                serr.println( "WaveparseWaveHeader; ex=" + ex ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	// detect size of RIFF chunk  	fs.read (buf' 0' 4);  	long riff_chunk_size = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; riff_chunk_size=" + riff_chunk_size ); #endif  	// check wave header  	fs.seek (8);  	fs.read (buf' 0' 4);  	if (buf [0] != 0x57 || buf [1] != 0x41 || buf [2] != 0x56 || buf [3] != 0x45) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid wave header" ); #endif  		fs.close ();  		return false;  	}  	// check fmt chunk header  	fs.read (buf' 0' 4);  	if (buf [0] != 0x66 || buf [1] != 0x6d || buf [2] != 0x74 || buf [3] != 0x20) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid fmt header" ); #endif  		fs.close ();  		return false;  	}  	// detect size of fmt chunk  	long fmt_chunk_bytes;  	fs.read (buf' 0' 4);  	fmt_chunk_bytes = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; fmt_chunk_bytes=" + fmt_chunk_bytes ); #endif  	// get format ID  	fs.read (buf' 0' 2);  	int format_id = PortUtil.make_uint16_le (buf);  	if (format_id != 1) {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; format_id=" + format_id ); #endif  	// get the number of channel(s)  	fs.read (buf' 0' 2);  	int num_channels = PortUtil.make_uint16_le (buf);  	if (num_channels == 1) {  		m_channel = WaveChannel.Monoral;  	} else if (num_channels == 2) {  		m_channel = WaveChannel.Stereo;  	} else {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; num_channels=" + num_channels ); #endif  	// get sampling rate  	fs.read (buf' 0' 4);  	m_sample_rate = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_sample_rate=" + m_sample_rate ); #endif  	// get bit per sample  	fs.seek (0x22);  	fs.read (buf' 0' 2);  	m_bit_per_sample = PortUtil.make_uint16_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_bit_per_sample=" + m_bit_per_sample ); #endif  	if (m_bit_per_sample != 0x08 && m_bit_per_sample != 0x10) {  		fs.close ();  		return false;  	}  	// move to the end of fmt chunk  	fs.seek (0x14 + fmt_chunk_bytes);  	// move to the top of data chunk  	fs.read (buf' 0' 4);  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	while (!tag.Equals ("data")) {  		fs.read (buf' 0' 4);  		long size = PortUtil.make_uint32_le (buf);  		fs.seek (fs.getFilePointer () + size);  		fs.read (buf' 0' 4);  		tag = new String (new char[] {  			(char)buf [0]'  			(char)buf [1]'  			(char)buf [2]'  			(char)buf [3]  		});  		#if DEBUG  		                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	}  	// get size of data chunk  	fs.read (buf' 0' 4);  	long data_chunk_bytes = PortUtil.make_uint32_le (buf);  	m_total_samples = (long)(data_chunk_bytes / (num_channels * m_bit_per_sample / 8));  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_total_samples=" + m_total_samples ); #endif  } catch (Exception ex) {  	#if DEBUG  	                serr.println( "WaveparseWaveHeader; ex=" + ex ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	// detect size of RIFF chunk  	fs.read (buf' 0' 4);  	long riff_chunk_size = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; riff_chunk_size=" + riff_chunk_size ); #endif  	// check wave header  	fs.seek (8);  	fs.read (buf' 0' 4);  	if (buf [0] != 0x57 || buf [1] != 0x41 || buf [2] != 0x56 || buf [3] != 0x45) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid wave header" ); #endif  		fs.close ();  		return false;  	}  	// check fmt chunk header  	fs.read (buf' 0' 4);  	if (buf [0] != 0x66 || buf [1] != 0x6d || buf [2] != 0x74 || buf [3] != 0x20) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid fmt header" ); #endif  		fs.close ();  		return false;  	}  	// detect size of fmt chunk  	long fmt_chunk_bytes;  	fs.read (buf' 0' 4);  	fmt_chunk_bytes = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; fmt_chunk_bytes=" + fmt_chunk_bytes ); #endif  	// get format ID  	fs.read (buf' 0' 2);  	int format_id = PortUtil.make_uint16_le (buf);  	if (format_id != 1) {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; format_id=" + format_id ); #endif  	// get the number of channel(s)  	fs.read (buf' 0' 2);  	int num_channels = PortUtil.make_uint16_le (buf);  	if (num_channels == 1) {  		m_channel = WaveChannel.Monoral;  	} else if (num_channels == 2) {  		m_channel = WaveChannel.Stereo;  	} else {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; num_channels=" + num_channels ); #endif  	// get sampling rate  	fs.read (buf' 0' 4);  	m_sample_rate = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_sample_rate=" + m_sample_rate ); #endif  	// get bit per sample  	fs.seek (0x22);  	fs.read (buf' 0' 2);  	m_bit_per_sample = PortUtil.make_uint16_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_bit_per_sample=" + m_bit_per_sample ); #endif  	if (m_bit_per_sample != 0x08 && m_bit_per_sample != 0x10) {  		fs.close ();  		return false;  	}  	// move to the end of fmt chunk  	fs.seek (0x14 + fmt_chunk_bytes);  	// move to the top of data chunk  	fs.read (buf' 0' 4);  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	while (!tag.Equals ("data")) {  		fs.read (buf' 0' 4);  		long size = PortUtil.make_uint32_le (buf);  		fs.seek (fs.getFilePointer () + size);  		fs.read (buf' 0' 4);  		tag = new String (new char[] {  			(char)buf [0]'  			(char)buf [1]'  			(char)buf [2]'  			(char)buf [3]  		});  		#if DEBUG  		                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	}  	// get size of data chunk  	fs.read (buf' 0' 4);  	long data_chunk_bytes = PortUtil.make_uint32_le (buf);  	m_total_samples = (long)(data_chunk_bytes / (num_channels * m_bit_per_sample / 8));  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_total_samples=" + m_total_samples ); #endif  } catch (Exception ex) {  	#if DEBUG  	                serr.println( "WaveparseWaveHeader; ex=" + ex ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	// detect size of RIFF chunk  	fs.read (buf' 0' 4);  	long riff_chunk_size = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; riff_chunk_size=" + riff_chunk_size ); #endif  	// check wave header  	fs.seek (8);  	fs.read (buf' 0' 4);  	if (buf [0] != 0x57 || buf [1] != 0x41 || buf [2] != 0x56 || buf [3] != 0x45) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid wave header" ); #endif  		fs.close ();  		return false;  	}  	// check fmt chunk header  	fs.read (buf' 0' 4);  	if (buf [0] != 0x66 || buf [1] != 0x6d || buf [2] != 0x74 || buf [3] != 0x20) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid fmt header" ); #endif  		fs.close ();  		return false;  	}  	// detect size of fmt chunk  	long fmt_chunk_bytes;  	fs.read (buf' 0' 4);  	fmt_chunk_bytes = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; fmt_chunk_bytes=" + fmt_chunk_bytes ); #endif  	// get format ID  	fs.read (buf' 0' 2);  	int format_id = PortUtil.make_uint16_le (buf);  	if (format_id != 1) {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; format_id=" + format_id ); #endif  	// get the number of channel(s)  	fs.read (buf' 0' 2);  	int num_channels = PortUtil.make_uint16_le (buf);  	if (num_channels == 1) {  		m_channel = WaveChannel.Monoral;  	} else if (num_channels == 2) {  		m_channel = WaveChannel.Stereo;  	} else {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; num_channels=" + num_channels ); #endif  	// get sampling rate  	fs.read (buf' 0' 4);  	m_sample_rate = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_sample_rate=" + m_sample_rate ); #endif  	// get bit per sample  	fs.seek (0x22);  	fs.read (buf' 0' 2);  	m_bit_per_sample = PortUtil.make_uint16_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_bit_per_sample=" + m_bit_per_sample ); #endif  	if (m_bit_per_sample != 0x08 && m_bit_per_sample != 0x10) {  		fs.close ();  		return false;  	}  	// move to the end of fmt chunk  	fs.seek (0x14 + fmt_chunk_bytes);  	// move to the top of data chunk  	fs.read (buf' 0' 4);  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	while (!tag.Equals ("data")) {  		fs.read (buf' 0' 4);  		long size = PortUtil.make_uint32_le (buf);  		fs.seek (fs.getFilePointer () + size);  		fs.read (buf' 0' 4);  		tag = new String (new char[] {  			(char)buf [0]'  			(char)buf [1]'  			(char)buf [2]'  			(char)buf [3]  		});  		#if DEBUG  		                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	}  	// get size of data chunk  	fs.read (buf' 0' 4);  	long data_chunk_bytes = PortUtil.make_uint32_le (buf);  	m_total_samples = (long)(data_chunk_bytes / (num_channels * m_bit_per_sample / 8));  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_total_samples=" + m_total_samples ); #endif  } catch (Exception ex) {  	#if DEBUG  	                serr.println( "WaveparseWaveHeader; ex=" + ex ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	// detect size of RIFF chunk  	fs.read (buf' 0' 4);  	long riff_chunk_size = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; riff_chunk_size=" + riff_chunk_size ); #endif  	// check wave header  	fs.seek (8);  	fs.read (buf' 0' 4);  	if (buf [0] != 0x57 || buf [1] != 0x41 || buf [2] != 0x56 || buf [3] != 0x45) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid wave header" ); #endif  		fs.close ();  		return false;  	}  	// check fmt chunk header  	fs.read (buf' 0' 4);  	if (buf [0] != 0x66 || buf [1] != 0x6d || buf [2] != 0x74 || buf [3] != 0x20) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid fmt header" ); #endif  		fs.close ();  		return false;  	}  	// detect size of fmt chunk  	long fmt_chunk_bytes;  	fs.read (buf' 0' 4);  	fmt_chunk_bytes = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; fmt_chunk_bytes=" + fmt_chunk_bytes ); #endif  	// get format ID  	fs.read (buf' 0' 2);  	int format_id = PortUtil.make_uint16_le (buf);  	if (format_id != 1) {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; format_id=" + format_id ); #endif  	// get the number of channel(s)  	fs.read (buf' 0' 2);  	int num_channels = PortUtil.make_uint16_le (buf);  	if (num_channels == 1) {  		m_channel = WaveChannel.Monoral;  	} else if (num_channels == 2) {  		m_channel = WaveChannel.Stereo;  	} else {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; num_channels=" + num_channels ); #endif  	// get sampling rate  	fs.read (buf' 0' 4);  	m_sample_rate = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_sample_rate=" + m_sample_rate ); #endif  	// get bit per sample  	fs.seek (0x22);  	fs.read (buf' 0' 2);  	m_bit_per_sample = PortUtil.make_uint16_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_bit_per_sample=" + m_bit_per_sample ); #endif  	if (m_bit_per_sample != 0x08 && m_bit_per_sample != 0x10) {  		fs.close ();  		return false;  	}  	// move to the end of fmt chunk  	fs.seek (0x14 + fmt_chunk_bytes);  	// move to the top of data chunk  	fs.read (buf' 0' 4);  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	while (!tag.Equals ("data")) {  		fs.read (buf' 0' 4);  		long size = PortUtil.make_uint32_le (buf);  		fs.seek (fs.getFilePointer () + size);  		fs.read (buf' 0' 4);  		tag = new String (new char[] {  			(char)buf [0]'  			(char)buf [1]'  			(char)buf [2]'  			(char)buf [3]  		});  		#if DEBUG  		                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	}  	// get size of data chunk  	fs.read (buf' 0' 4);  	long data_chunk_bytes = PortUtil.make_uint32_le (buf);  	m_total_samples = (long)(data_chunk_bytes / (num_channels * m_bit_per_sample / 8));  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_total_samples=" + m_total_samples ); #endif  } catch (Exception ex) {  	#if DEBUG  	                serr.println( "WaveparseWaveHeader; ex=" + ex ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	// detect size of RIFF chunk  	fs.read (buf' 0' 4);  	long riff_chunk_size = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; riff_chunk_size=" + riff_chunk_size ); #endif  	// check wave header  	fs.seek (8);  	fs.read (buf' 0' 4);  	if (buf [0] != 0x57 || buf [1] != 0x41 || buf [2] != 0x56 || buf [3] != 0x45) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid wave header" ); #endif  		fs.close ();  		return false;  	}  	// check fmt chunk header  	fs.read (buf' 0' 4);  	if (buf [0] != 0x66 || buf [1] != 0x6d || buf [2] != 0x74 || buf [3] != 0x20) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid fmt header" ); #endif  		fs.close ();  		return false;  	}  	// detect size of fmt chunk  	long fmt_chunk_bytes;  	fs.read (buf' 0' 4);  	fmt_chunk_bytes = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; fmt_chunk_bytes=" + fmt_chunk_bytes ); #endif  	// get format ID  	fs.read (buf' 0' 2);  	int format_id = PortUtil.make_uint16_le (buf);  	if (format_id != 1) {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; format_id=" + format_id ); #endif  	// get the number of channel(s)  	fs.read (buf' 0' 2);  	int num_channels = PortUtil.make_uint16_le (buf);  	if (num_channels == 1) {  		m_channel = WaveChannel.Monoral;  	} else if (num_channels == 2) {  		m_channel = WaveChannel.Stereo;  	} else {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; num_channels=" + num_channels ); #endif  	// get sampling rate  	fs.read (buf' 0' 4);  	m_sample_rate = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_sample_rate=" + m_sample_rate ); #endif  	// get bit per sample  	fs.seek (0x22);  	fs.read (buf' 0' 2);  	m_bit_per_sample = PortUtil.make_uint16_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_bit_per_sample=" + m_bit_per_sample ); #endif  	if (m_bit_per_sample != 0x08 && m_bit_per_sample != 0x10) {  		fs.close ();  		return false;  	}  	// move to the end of fmt chunk  	fs.seek (0x14 + fmt_chunk_bytes);  	// move to the top of data chunk  	fs.read (buf' 0' 4);  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	while (!tag.Equals ("data")) {  		fs.read (buf' 0' 4);  		long size = PortUtil.make_uint32_le (buf);  		fs.seek (fs.getFilePointer () + size);  		fs.read (buf' 0' 4);  		tag = new String (new char[] {  			(char)buf [0]'  			(char)buf [1]'  			(char)buf [2]'  			(char)buf [3]  		});  		#if DEBUG  		                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	}  	// get size of data chunk  	fs.read (buf' 0' 4);  	long data_chunk_bytes = PortUtil.make_uint32_le (buf);  	m_total_samples = (long)(data_chunk_bytes / (num_channels * m_bit_per_sample / 8));  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_total_samples=" + m_total_samples ); #endif  } catch (Exception ex) {  	#if DEBUG  	                serr.println( "WaveparseWaveHeader; ex=" + ex ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: try {  	byte[] buf = new byte[4];  	// detect size of RIFF chunk  	fs.read (buf' 0' 4);  	long riff_chunk_size = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; riff_chunk_size=" + riff_chunk_size ); #endif  	// check wave header  	fs.seek (8);  	fs.read (buf' 0' 4);  	if (buf [0] != 0x57 || buf [1] != 0x41 || buf [2] != 0x56 || buf [3] != 0x45) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid wave header" ); #endif  		fs.close ();  		return false;  	}  	// check fmt chunk header  	fs.read (buf' 0' 4);  	if (buf [0] != 0x66 || buf [1] != 0x6d || buf [2] != 0x74 || buf [3] != 0x20) {  		#if DEBUG  		                    serr.println( "WaveparseWaveHeader; invalid fmt header" ); #endif  		fs.close ();  		return false;  	}  	// detect size of fmt chunk  	long fmt_chunk_bytes;  	fs.read (buf' 0' 4);  	fmt_chunk_bytes = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; fmt_chunk_bytes=" + fmt_chunk_bytes ); #endif  	// get format ID  	fs.read (buf' 0' 2);  	int format_id = PortUtil.make_uint16_le (buf);  	if (format_id != 1) {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; format_id=" + format_id ); #endif  	// get the number of channel(s)  	fs.read (buf' 0' 2);  	int num_channels = PortUtil.make_uint16_le (buf);  	if (num_channels == 1) {  		m_channel = WaveChannel.Monoral;  	} else if (num_channels == 2) {  		m_channel = WaveChannel.Stereo;  	} else {  		fs.close ();  		return false;  	}  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; num_channels=" + num_channels ); #endif  	// get sampling rate  	fs.read (buf' 0' 4);  	m_sample_rate = PortUtil.make_uint32_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_sample_rate=" + m_sample_rate ); #endif  	// get bit per sample  	fs.seek (0x22);  	fs.read (buf' 0' 2);  	m_bit_per_sample = PortUtil.make_uint16_le (buf);  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_bit_per_sample=" + m_bit_per_sample ); #endif  	if (m_bit_per_sample != 0x08 && m_bit_per_sample != 0x10) {  		fs.close ();  		return false;  	}  	// move to the end of fmt chunk  	fs.seek (0x14 + fmt_chunk_bytes);  	// move to the top of data chunk  	fs.read (buf' 0' 4);  	String tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	while (!tag.Equals ("data")) {  		fs.read (buf' 0' 4);  		long size = PortUtil.make_uint32_le (buf);  		fs.seek (fs.getFilePointer () + size);  		fs.read (buf' 0' 4);  		tag = new String (new char[] {  			(char)buf [0]'  			(char)buf [1]'  			(char)buf [2]'  			(char)buf [3]  		});  		#if DEBUG  		                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  	}  	// get size of data chunk  	fs.read (buf' 0' 4);  	long data_chunk_bytes = PortUtil.make_uint32_le (buf);  	m_total_samples = (long)(data_chunk_bytes / (num_channels * m_bit_per_sample / 8));  	#if DEBUG  	                sout.println( "WaveparseWaveHeader; m_total_samples=" + m_total_samples ); #endif  } catch (Exception ex) {  	#if DEBUG  	                serr.println( "WaveparseWaveHeader; ex=" + ex ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: fs.read (buf' 0' 4);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: fs.seek (8);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: fs.read (buf' 0' 4);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: if (buf [0] != 0x57 || buf [1] != 0x41 || buf [2] != 0x56 || buf [3] != 0x45) {  	#if DEBUG  	                    serr.println( "WaveparseWaveHeader; invalid wave header" ); #endif  	fs.close ();  	return false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: if (buf [0] != 0x57 || buf [1] != 0x41 || buf [2] != 0x56 || buf [3] != 0x45) {  	#if DEBUG  	                    serr.println( "WaveparseWaveHeader; invalid wave header" ); #endif  	fs.close ();  	return false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: fs.read (buf' 0' 4);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: if (buf [0] != 0x66 || buf [1] != 0x6d || buf [2] != 0x74 || buf [3] != 0x20) {  	#if DEBUG  	                    serr.println( "WaveparseWaveHeader; invalid fmt header" ); #endif  	fs.close ();  	return false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: if (buf [0] != 0x66 || buf [1] != 0x6d || buf [2] != 0x74 || buf [3] != 0x20) {  	#if DEBUG  	                    serr.println( "WaveparseWaveHeader; invalid fmt header" ); #endif  	fs.close ();  	return false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: fs.read (buf' 0' 4);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: fs.read (buf' 0' 2);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: fs.read (buf' 0' 2);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: if (num_channels == 1) {  	m_channel = WaveChannel.Monoral;  } else if (num_channels == 2) {  	m_channel = WaveChannel.Stereo;  } else {  	fs.close ();  	return false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: if (num_channels == 2) {  	m_channel = WaveChannel.Stereo;  } else {  	fs.close ();  	return false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: fs.read (buf' 0' 4);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: fs.read (buf' 0' 2);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: fs.read (buf' 0' 4);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: while (!tag.Equals ("data")) {  	fs.read (buf' 0' 4);  	long size = PortUtil.make_uint32_le (buf);  	fs.seek (fs.getFilePointer () + size);  	fs.read (buf' 0' 4);  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: while (!tag.Equals ("data")) {  	fs.read (buf' 0' 4);  	long size = PortUtil.make_uint32_le (buf);  	fs.seek (fs.getFilePointer () + size);  	fs.read (buf' 0' 4);  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: while (!tag.Equals ("data")) {  	fs.read (buf' 0' 4);  	long size = PortUtil.make_uint32_le (buf);  	fs.seek (fs.getFilePointer () + size);  	fs.read (buf' 0' 4);  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: while (!tag.Equals ("data")) {  	fs.read (buf' 0' 4);  	long size = PortUtil.make_uint32_le (buf);  	fs.seek (fs.getFilePointer () + size);  	fs.read (buf' 0' 4);  	tag = new String (new char[] {  		(char)buf [0]'  		(char)buf [1]'  		(char)buf [2]'  		(char)buf [3]  	});  	#if DEBUG  	                    sout.println( "WaveparseWaveHeader; tag=" + tag ); #endif  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: fs.read (buf' 0' 4);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: fs.read (buf' 0' 4);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: tag = new String (new char[] {  	(char)buf [0]'  	(char)buf [1]'  	(char)buf [2]'  	(char)buf [3]  });  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: tag = new String (new char[] {  	(char)buf [0]'  	(char)buf [1]'  	(char)buf [2]'  	(char)buf [3]  });  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: fs.read (buf' 0' 4);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,parseWaveHeader,The following statement contains a magic number: m_total_samples = (long)(data_chunk_bytes / (num_channels * m_bit_per_sample / 8));  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: try {  	fs = new RandomAccessFile (path' "r");  	// check RIFF header  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	boolean change_byte_order = false;  	if (buf [0] == 0x52 && buf [1] == 0x49 && buf [2] == 0x46 && buf [3] == 0x46) {  		ret = parseWaveHeader (fs);  	} else if (buf [0] == 0x46 && buf [1] == 0x4f && buf [2] == 0x52 && buf [3] == 0x4d) {  		ret = parseAiffHeader (fs);  		change_byte_order = true;  	} else {  		ret = false;  	}  	// prepare data  	if (m_bit_per_sample == 8) {  		L8 = new byte[(int)m_total_samples];  		if (m_channel == WaveChannel.Stereo) {  			R8 = new byte[(int)m_total_samples];  		}  	} else {  		L16 = new short[(int)m_total_samples];  		if (m_channel == WaveChannel.Stereo) {  			R16 = new short[(int)m_total_samples];  		}  	}  	// read data  	// TODO: big endianのときの読込み。  	byte[] buf2 = new byte[2];  	for (int i = 0; i < m_total_samples; i++) {  		if (m_bit_per_sample == 8) {  			fs.read (buf' 0' 1);  			L8 [i] = buf [0];  			if (m_channel == WaveChannel.Stereo) {  				fs.read (buf' 0' 1);  				R8 [i] = buf [0];  			}  		} else {  			fs.read (buf2' 0' 2);  			if (change_byte_order) {  				byte b = buf2 [0];  				buf2 [0] = buf2 [1];  				buf2 [1] = b;  			}  			L16 [i] = PortUtil.make_int16_le (buf2);  			if (m_channel == WaveChannel.Stereo) {  				fs.read (buf2' 0' 2);  				if (change_byte_order) {  					byte b = buf2 [0];  					buf2 [0] = buf2 [1];  					buf2 [1] = b;  				}  				R16 [i] = PortUtil.make_int16_le (buf2);  			}  		}  	}  } catch (Exception ex) {  } finally {  	if (fs != null) {  		try {  			fs.close ();  		} catch (Exception ex2) {  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: try {  	fs = new RandomAccessFile (path' "r");  	// check RIFF header  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	boolean change_byte_order = false;  	if (buf [0] == 0x52 && buf [1] == 0x49 && buf [2] == 0x46 && buf [3] == 0x46) {  		ret = parseWaveHeader (fs);  	} else if (buf [0] == 0x46 && buf [1] == 0x4f && buf [2] == 0x52 && buf [3] == 0x4d) {  		ret = parseAiffHeader (fs);  		change_byte_order = true;  	} else {  		ret = false;  	}  	// prepare data  	if (m_bit_per_sample == 8) {  		L8 = new byte[(int)m_total_samples];  		if (m_channel == WaveChannel.Stereo) {  			R8 = new byte[(int)m_total_samples];  		}  	} else {  		L16 = new short[(int)m_total_samples];  		if (m_channel == WaveChannel.Stereo) {  			R16 = new short[(int)m_total_samples];  		}  	}  	// read data  	// TODO: big endianのときの読込み。  	byte[] buf2 = new byte[2];  	for (int i = 0; i < m_total_samples; i++) {  		if (m_bit_per_sample == 8) {  			fs.read (buf' 0' 1);  			L8 [i] = buf [0];  			if (m_channel == WaveChannel.Stereo) {  				fs.read (buf' 0' 1);  				R8 [i] = buf [0];  			}  		} else {  			fs.read (buf2' 0' 2);  			if (change_byte_order) {  				byte b = buf2 [0];  				buf2 [0] = buf2 [1];  				buf2 [1] = b;  			}  			L16 [i] = PortUtil.make_int16_le (buf2);  			if (m_channel == WaveChannel.Stereo) {  				fs.read (buf2' 0' 2);  				if (change_byte_order) {  					byte b = buf2 [0];  					buf2 [0] = buf2 [1];  					buf2 [1] = b;  				}  				R16 [i] = PortUtil.make_int16_le (buf2);  			}  		}  	}  } catch (Exception ex) {  } finally {  	if (fs != null) {  		try {  			fs.close ();  		} catch (Exception ex2) {  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: try {  	fs = new RandomAccessFile (path' "r");  	// check RIFF header  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	boolean change_byte_order = false;  	if (buf [0] == 0x52 && buf [1] == 0x49 && buf [2] == 0x46 && buf [3] == 0x46) {  		ret = parseWaveHeader (fs);  	} else if (buf [0] == 0x46 && buf [1] == 0x4f && buf [2] == 0x52 && buf [3] == 0x4d) {  		ret = parseAiffHeader (fs);  		change_byte_order = true;  	} else {  		ret = false;  	}  	// prepare data  	if (m_bit_per_sample == 8) {  		L8 = new byte[(int)m_total_samples];  		if (m_channel == WaveChannel.Stereo) {  			R8 = new byte[(int)m_total_samples];  		}  	} else {  		L16 = new short[(int)m_total_samples];  		if (m_channel == WaveChannel.Stereo) {  			R16 = new short[(int)m_total_samples];  		}  	}  	// read data  	// TODO: big endianのときの読込み。  	byte[] buf2 = new byte[2];  	for (int i = 0; i < m_total_samples; i++) {  		if (m_bit_per_sample == 8) {  			fs.read (buf' 0' 1);  			L8 [i] = buf [0];  			if (m_channel == WaveChannel.Stereo) {  				fs.read (buf' 0' 1);  				R8 [i] = buf [0];  			}  		} else {  			fs.read (buf2' 0' 2);  			if (change_byte_order) {  				byte b = buf2 [0];  				buf2 [0] = buf2 [1];  				buf2 [1] = b;  			}  			L16 [i] = PortUtil.make_int16_le (buf2);  			if (m_channel == WaveChannel.Stereo) {  				fs.read (buf2' 0' 2);  				if (change_byte_order) {  					byte b = buf2 [0];  					buf2 [0] = buf2 [1];  					buf2 [1] = b;  				}  				R16 [i] = PortUtil.make_int16_le (buf2);  			}  		}  	}  } catch (Exception ex) {  } finally {  	if (fs != null) {  		try {  			fs.close ();  		} catch (Exception ex2) {  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: try {  	fs = new RandomAccessFile (path' "r");  	// check RIFF header  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	boolean change_byte_order = false;  	if (buf [0] == 0x52 && buf [1] == 0x49 && buf [2] == 0x46 && buf [3] == 0x46) {  		ret = parseWaveHeader (fs);  	} else if (buf [0] == 0x46 && buf [1] == 0x4f && buf [2] == 0x52 && buf [3] == 0x4d) {  		ret = parseAiffHeader (fs);  		change_byte_order = true;  	} else {  		ret = false;  	}  	// prepare data  	if (m_bit_per_sample == 8) {  		L8 = new byte[(int)m_total_samples];  		if (m_channel == WaveChannel.Stereo) {  			R8 = new byte[(int)m_total_samples];  		}  	} else {  		L16 = new short[(int)m_total_samples];  		if (m_channel == WaveChannel.Stereo) {  			R16 = new short[(int)m_total_samples];  		}  	}  	// read data  	// TODO: big endianのときの読込み。  	byte[] buf2 = new byte[2];  	for (int i = 0; i < m_total_samples; i++) {  		if (m_bit_per_sample == 8) {  			fs.read (buf' 0' 1);  			L8 [i] = buf [0];  			if (m_channel == WaveChannel.Stereo) {  				fs.read (buf' 0' 1);  				R8 [i] = buf [0];  			}  		} else {  			fs.read (buf2' 0' 2);  			if (change_byte_order) {  				byte b = buf2 [0];  				buf2 [0] = buf2 [1];  				buf2 [1] = b;  			}  			L16 [i] = PortUtil.make_int16_le (buf2);  			if (m_channel == WaveChannel.Stereo) {  				fs.read (buf2' 0' 2);  				if (change_byte_order) {  					byte b = buf2 [0];  					buf2 [0] = buf2 [1];  					buf2 [1] = b;  				}  				R16 [i] = PortUtil.make_int16_le (buf2);  			}  		}  	}  } catch (Exception ex) {  } finally {  	if (fs != null) {  		try {  			fs.close ();  		} catch (Exception ex2) {  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: try {  	fs = new RandomAccessFile (path' "r");  	// check RIFF header  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	boolean change_byte_order = false;  	if (buf [0] == 0x52 && buf [1] == 0x49 && buf [2] == 0x46 && buf [3] == 0x46) {  		ret = parseWaveHeader (fs);  	} else if (buf [0] == 0x46 && buf [1] == 0x4f && buf [2] == 0x52 && buf [3] == 0x4d) {  		ret = parseAiffHeader (fs);  		change_byte_order = true;  	} else {  		ret = false;  	}  	// prepare data  	if (m_bit_per_sample == 8) {  		L8 = new byte[(int)m_total_samples];  		if (m_channel == WaveChannel.Stereo) {  			R8 = new byte[(int)m_total_samples];  		}  	} else {  		L16 = new short[(int)m_total_samples];  		if (m_channel == WaveChannel.Stereo) {  			R16 = new short[(int)m_total_samples];  		}  	}  	// read data  	// TODO: big endianのときの読込み。  	byte[] buf2 = new byte[2];  	for (int i = 0; i < m_total_samples; i++) {  		if (m_bit_per_sample == 8) {  			fs.read (buf' 0' 1);  			L8 [i] = buf [0];  			if (m_channel == WaveChannel.Stereo) {  				fs.read (buf' 0' 1);  				R8 [i] = buf [0];  			}  		} else {  			fs.read (buf2' 0' 2);  			if (change_byte_order) {  				byte b = buf2 [0];  				buf2 [0] = buf2 [1];  				buf2 [1] = b;  			}  			L16 [i] = PortUtil.make_int16_le (buf2);  			if (m_channel == WaveChannel.Stereo) {  				fs.read (buf2' 0' 2);  				if (change_byte_order) {  					byte b = buf2 [0];  					buf2 [0] = buf2 [1];  					buf2 [1] = b;  				}  				R16 [i] = PortUtil.make_int16_le (buf2);  			}  		}  	}  } catch (Exception ex) {  } finally {  	if (fs != null) {  		try {  			fs.close ();  		} catch (Exception ex2) {  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: try {  	fs = new RandomAccessFile (path' "r");  	// check RIFF header  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	boolean change_byte_order = false;  	if (buf [0] == 0x52 && buf [1] == 0x49 && buf [2] == 0x46 && buf [3] == 0x46) {  		ret = parseWaveHeader (fs);  	} else if (buf [0] == 0x46 && buf [1] == 0x4f && buf [2] == 0x52 && buf [3] == 0x4d) {  		ret = parseAiffHeader (fs);  		change_byte_order = true;  	} else {  		ret = false;  	}  	// prepare data  	if (m_bit_per_sample == 8) {  		L8 = new byte[(int)m_total_samples];  		if (m_channel == WaveChannel.Stereo) {  			R8 = new byte[(int)m_total_samples];  		}  	} else {  		L16 = new short[(int)m_total_samples];  		if (m_channel == WaveChannel.Stereo) {  			R16 = new short[(int)m_total_samples];  		}  	}  	// read data  	// TODO: big endianのときの読込み。  	byte[] buf2 = new byte[2];  	for (int i = 0; i < m_total_samples; i++) {  		if (m_bit_per_sample == 8) {  			fs.read (buf' 0' 1);  			L8 [i] = buf [0];  			if (m_channel == WaveChannel.Stereo) {  				fs.read (buf' 0' 1);  				R8 [i] = buf [0];  			}  		} else {  			fs.read (buf2' 0' 2);  			if (change_byte_order) {  				byte b = buf2 [0];  				buf2 [0] = buf2 [1];  				buf2 [1] = b;  			}  			L16 [i] = PortUtil.make_int16_le (buf2);  			if (m_channel == WaveChannel.Stereo) {  				fs.read (buf2' 0' 2);  				if (change_byte_order) {  					byte b = buf2 [0];  					buf2 [0] = buf2 [1];  					buf2 [1] = b;  				}  				R16 [i] = PortUtil.make_int16_le (buf2);  			}  		}  	}  } catch (Exception ex) {  } finally {  	if (fs != null) {  		try {  			fs.close ();  		} catch (Exception ex2) {  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: try {  	fs = new RandomAccessFile (path' "r");  	// check RIFF header  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	boolean change_byte_order = false;  	if (buf [0] == 0x52 && buf [1] == 0x49 && buf [2] == 0x46 && buf [3] == 0x46) {  		ret = parseWaveHeader (fs);  	} else if (buf [0] == 0x46 && buf [1] == 0x4f && buf [2] == 0x52 && buf [3] == 0x4d) {  		ret = parseAiffHeader (fs);  		change_byte_order = true;  	} else {  		ret = false;  	}  	// prepare data  	if (m_bit_per_sample == 8) {  		L8 = new byte[(int)m_total_samples];  		if (m_channel == WaveChannel.Stereo) {  			R8 = new byte[(int)m_total_samples];  		}  	} else {  		L16 = new short[(int)m_total_samples];  		if (m_channel == WaveChannel.Stereo) {  			R16 = new short[(int)m_total_samples];  		}  	}  	// read data  	// TODO: big endianのときの読込み。  	byte[] buf2 = new byte[2];  	for (int i = 0; i < m_total_samples; i++) {  		if (m_bit_per_sample == 8) {  			fs.read (buf' 0' 1);  			L8 [i] = buf [0];  			if (m_channel == WaveChannel.Stereo) {  				fs.read (buf' 0' 1);  				R8 [i] = buf [0];  			}  		} else {  			fs.read (buf2' 0' 2);  			if (change_byte_order) {  				byte b = buf2 [0];  				buf2 [0] = buf2 [1];  				buf2 [1] = b;  			}  			L16 [i] = PortUtil.make_int16_le (buf2);  			if (m_channel == WaveChannel.Stereo) {  				fs.read (buf2' 0' 2);  				if (change_byte_order) {  					byte b = buf2 [0];  					buf2 [0] = buf2 [1];  					buf2 [1] = b;  				}  				R16 [i] = PortUtil.make_int16_le (buf2);  			}  		}  	}  } catch (Exception ex) {  } finally {  	if (fs != null) {  		try {  			fs.close ();  		} catch (Exception ex2) {  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: try {  	fs = new RandomAccessFile (path' "r");  	// check RIFF header  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	boolean change_byte_order = false;  	if (buf [0] == 0x52 && buf [1] == 0x49 && buf [2] == 0x46 && buf [3] == 0x46) {  		ret = parseWaveHeader (fs);  	} else if (buf [0] == 0x46 && buf [1] == 0x4f && buf [2] == 0x52 && buf [3] == 0x4d) {  		ret = parseAiffHeader (fs);  		change_byte_order = true;  	} else {  		ret = false;  	}  	// prepare data  	if (m_bit_per_sample == 8) {  		L8 = new byte[(int)m_total_samples];  		if (m_channel == WaveChannel.Stereo) {  			R8 = new byte[(int)m_total_samples];  		}  	} else {  		L16 = new short[(int)m_total_samples];  		if (m_channel == WaveChannel.Stereo) {  			R16 = new short[(int)m_total_samples];  		}  	}  	// read data  	// TODO: big endianのときの読込み。  	byte[] buf2 = new byte[2];  	for (int i = 0; i < m_total_samples; i++) {  		if (m_bit_per_sample == 8) {  			fs.read (buf' 0' 1);  			L8 [i] = buf [0];  			if (m_channel == WaveChannel.Stereo) {  				fs.read (buf' 0' 1);  				R8 [i] = buf [0];  			}  		} else {  			fs.read (buf2' 0' 2);  			if (change_byte_order) {  				byte b = buf2 [0];  				buf2 [0] = buf2 [1];  				buf2 [1] = b;  			}  			L16 [i] = PortUtil.make_int16_le (buf2);  			if (m_channel == WaveChannel.Stereo) {  				fs.read (buf2' 0' 2);  				if (change_byte_order) {  					byte b = buf2 [0];  					buf2 [0] = buf2 [1];  					buf2 [1] = b;  				}  				R16 [i] = PortUtil.make_int16_le (buf2);  			}  		}  	}  } catch (Exception ex) {  } finally {  	if (fs != null) {  		try {  			fs.close ();  		} catch (Exception ex2) {  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: try {  	fs = new RandomAccessFile (path' "r");  	// check RIFF header  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	boolean change_byte_order = false;  	if (buf [0] == 0x52 && buf [1] == 0x49 && buf [2] == 0x46 && buf [3] == 0x46) {  		ret = parseWaveHeader (fs);  	} else if (buf [0] == 0x46 && buf [1] == 0x4f && buf [2] == 0x52 && buf [3] == 0x4d) {  		ret = parseAiffHeader (fs);  		change_byte_order = true;  	} else {  		ret = false;  	}  	// prepare data  	if (m_bit_per_sample == 8) {  		L8 = new byte[(int)m_total_samples];  		if (m_channel == WaveChannel.Stereo) {  			R8 = new byte[(int)m_total_samples];  		}  	} else {  		L16 = new short[(int)m_total_samples];  		if (m_channel == WaveChannel.Stereo) {  			R16 = new short[(int)m_total_samples];  		}  	}  	// read data  	// TODO: big endianのときの読込み。  	byte[] buf2 = new byte[2];  	for (int i = 0; i < m_total_samples; i++) {  		if (m_bit_per_sample == 8) {  			fs.read (buf' 0' 1);  			L8 [i] = buf [0];  			if (m_channel == WaveChannel.Stereo) {  				fs.read (buf' 0' 1);  				R8 [i] = buf [0];  			}  		} else {  			fs.read (buf2' 0' 2);  			if (change_byte_order) {  				byte b = buf2 [0];  				buf2 [0] = buf2 [1];  				buf2 [1] = b;  			}  			L16 [i] = PortUtil.make_int16_le (buf2);  			if (m_channel == WaveChannel.Stereo) {  				fs.read (buf2' 0' 2);  				if (change_byte_order) {  					byte b = buf2 [0];  					buf2 [0] = buf2 [1];  					buf2 [1] = b;  				}  				R16 [i] = PortUtil.make_int16_le (buf2);  			}  		}  	}  } catch (Exception ex) {  } finally {  	if (fs != null) {  		try {  			fs.close ();  		} catch (Exception ex2) {  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: try {  	fs = new RandomAccessFile (path' "r");  	// check RIFF header  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	boolean change_byte_order = false;  	if (buf [0] == 0x52 && buf [1] == 0x49 && buf [2] == 0x46 && buf [3] == 0x46) {  		ret = parseWaveHeader (fs);  	} else if (buf [0] == 0x46 && buf [1] == 0x4f && buf [2] == 0x52 && buf [3] == 0x4d) {  		ret = parseAiffHeader (fs);  		change_byte_order = true;  	} else {  		ret = false;  	}  	// prepare data  	if (m_bit_per_sample == 8) {  		L8 = new byte[(int)m_total_samples];  		if (m_channel == WaveChannel.Stereo) {  			R8 = new byte[(int)m_total_samples];  		}  	} else {  		L16 = new short[(int)m_total_samples];  		if (m_channel == WaveChannel.Stereo) {  			R16 = new short[(int)m_total_samples];  		}  	}  	// read data  	// TODO: big endianのときの読込み。  	byte[] buf2 = new byte[2];  	for (int i = 0; i < m_total_samples; i++) {  		if (m_bit_per_sample == 8) {  			fs.read (buf' 0' 1);  			L8 [i] = buf [0];  			if (m_channel == WaveChannel.Stereo) {  				fs.read (buf' 0' 1);  				R8 [i] = buf [0];  			}  		} else {  			fs.read (buf2' 0' 2);  			if (change_byte_order) {  				byte b = buf2 [0];  				buf2 [0] = buf2 [1];  				buf2 [1] = b;  			}  			L16 [i] = PortUtil.make_int16_le (buf2);  			if (m_channel == WaveChannel.Stereo) {  				fs.read (buf2' 0' 2);  				if (change_byte_order) {  					byte b = buf2 [0];  					buf2 [0] = buf2 [1];  					buf2 [1] = b;  				}  				R16 [i] = PortUtil.make_int16_le (buf2);  			}  		}  	}  } catch (Exception ex) {  } finally {  	if (fs != null) {  		try {  			fs.close ();  		} catch (Exception ex2) {  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: try {  	fs = new RandomAccessFile (path' "r");  	// check RIFF header  	byte[] buf = new byte[4];  	fs.read (buf' 0' 4);  	boolean change_byte_order = false;  	if (buf [0] == 0x52 && buf [1] == 0x49 && buf [2] == 0x46 && buf [3] == 0x46) {  		ret = parseWaveHeader (fs);  	} else if (buf [0] == 0x46 && buf [1] == 0x4f && buf [2] == 0x52 && buf [3] == 0x4d) {  		ret = parseAiffHeader (fs);  		change_byte_order = true;  	} else {  		ret = false;  	}  	// prepare data  	if (m_bit_per_sample == 8) {  		L8 = new byte[(int)m_total_samples];  		if (m_channel == WaveChannel.Stereo) {  			R8 = new byte[(int)m_total_samples];  		}  	} else {  		L16 = new short[(int)m_total_samples];  		if (m_channel == WaveChannel.Stereo) {  			R16 = new short[(int)m_total_samples];  		}  	}  	// read data  	// TODO: big endianのときの読込み。  	byte[] buf2 = new byte[2];  	for (int i = 0; i < m_total_samples; i++) {  		if (m_bit_per_sample == 8) {  			fs.read (buf' 0' 1);  			L8 [i] = buf [0];  			if (m_channel == WaveChannel.Stereo) {  				fs.read (buf' 0' 1);  				R8 [i] = buf [0];  			}  		} else {  			fs.read (buf2' 0' 2);  			if (change_byte_order) {  				byte b = buf2 [0];  				buf2 [0] = buf2 [1];  				buf2 [1] = b;  			}  			L16 [i] = PortUtil.make_int16_le (buf2);  			if (m_channel == WaveChannel.Stereo) {  				fs.read (buf2' 0' 2);  				if (change_byte_order) {  					byte b = buf2 [0];  					buf2 [0] = buf2 [1];  					buf2 [1] = b;  				}  				R16 [i] = PortUtil.make_int16_le (buf2);  			}  		}  	}  } catch (Exception ex) {  } finally {  	if (fs != null) {  		try {  			fs.close ();  		} catch (Exception ex2) {  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: fs.read (buf' 0' 4);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: if (buf [0] == 0x52 && buf [1] == 0x49 && buf [2] == 0x46 && buf [3] == 0x46) {  	ret = parseWaveHeader (fs);  } else if (buf [0] == 0x46 && buf [1] == 0x4f && buf [2] == 0x52 && buf [3] == 0x4d) {  	ret = parseAiffHeader (fs);  	change_byte_order = true;  } else {  	ret = false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: if (buf [0] == 0x52 && buf [1] == 0x49 && buf [2] == 0x46 && buf [3] == 0x46) {  	ret = parseWaveHeader (fs);  } else if (buf [0] == 0x46 && buf [1] == 0x4f && buf [2] == 0x52 && buf [3] == 0x4d) {  	ret = parseAiffHeader (fs);  	change_byte_order = true;  } else {  	ret = false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: if (buf [0] == 0x52 && buf [1] == 0x49 && buf [2] == 0x46 && buf [3] == 0x46) {  	ret = parseWaveHeader (fs);  } else if (buf [0] == 0x46 && buf [1] == 0x4f && buf [2] == 0x52 && buf [3] == 0x4d) {  	ret = parseAiffHeader (fs);  	change_byte_order = true;  } else {  	ret = false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: if (buf [0] == 0x52 && buf [1] == 0x49 && buf [2] == 0x46 && buf [3] == 0x46) {  	ret = parseWaveHeader (fs);  } else if (buf [0] == 0x46 && buf [1] == 0x4f && buf [2] == 0x52 && buf [3] == 0x4d) {  	ret = parseAiffHeader (fs);  	change_byte_order = true;  } else {  	ret = false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: if (buf [0] == 0x46 && buf [1] == 0x4f && buf [2] == 0x52 && buf [3] == 0x4d) {  	ret = parseAiffHeader (fs);  	change_byte_order = true;  } else {  	ret = false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: if (buf [0] == 0x46 && buf [1] == 0x4f && buf [2] == 0x52 && buf [3] == 0x4d) {  	ret = parseAiffHeader (fs);  	change_byte_order = true;  } else {  	ret = false;  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	L8 = new byte[(int)m_total_samples];  	if (m_channel == WaveChannel.Stereo) {  		R8 = new byte[(int)m_total_samples];  	}  } else {  	L16 = new short[(int)m_total_samples];  	if (m_channel == WaveChannel.Stereo) {  		R16 = new short[(int)m_total_samples];  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: for (int i = 0; i < m_total_samples; i++) {  	if (m_bit_per_sample == 8) {  		fs.read (buf' 0' 1);  		L8 [i] = buf [0];  		if (m_channel == WaveChannel.Stereo) {  			fs.read (buf' 0' 1);  			R8 [i] = buf [0];  		}  	} else {  		fs.read (buf2' 0' 2);  		if (change_byte_order) {  			byte b = buf2 [0];  			buf2 [0] = buf2 [1];  			buf2 [1] = b;  		}  		L16 [i] = PortUtil.make_int16_le (buf2);  		if (m_channel == WaveChannel.Stereo) {  			fs.read (buf2' 0' 2);  			if (change_byte_order) {  				byte b = buf2 [0];  				buf2 [0] = buf2 [1];  				buf2 [1] = b;  			}  			R16 [i] = PortUtil.make_int16_le (buf2);  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: for (int i = 0; i < m_total_samples; i++) {  	if (m_bit_per_sample == 8) {  		fs.read (buf' 0' 1);  		L8 [i] = buf [0];  		if (m_channel == WaveChannel.Stereo) {  			fs.read (buf' 0' 1);  			R8 [i] = buf [0];  		}  	} else {  		fs.read (buf2' 0' 2);  		if (change_byte_order) {  			byte b = buf2 [0];  			buf2 [0] = buf2 [1];  			buf2 [1] = b;  		}  		L16 [i] = PortUtil.make_int16_le (buf2);  		if (m_channel == WaveChannel.Stereo) {  			fs.read (buf2' 0' 2);  			if (change_byte_order) {  				byte b = buf2 [0];  				buf2 [0] = buf2 [1];  				buf2 [1] = b;  			}  			R16 [i] = PortUtil.make_int16_le (buf2);  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: for (int i = 0; i < m_total_samples; i++) {  	if (m_bit_per_sample == 8) {  		fs.read (buf' 0' 1);  		L8 [i] = buf [0];  		if (m_channel == WaveChannel.Stereo) {  			fs.read (buf' 0' 1);  			R8 [i] = buf [0];  		}  	} else {  		fs.read (buf2' 0' 2);  		if (change_byte_order) {  			byte b = buf2 [0];  			buf2 [0] = buf2 [1];  			buf2 [1] = b;  		}  		L16 [i] = PortUtil.make_int16_le (buf2);  		if (m_channel == WaveChannel.Stereo) {  			fs.read (buf2' 0' 2);  			if (change_byte_order) {  				byte b = buf2 [0];  				buf2 [0] = buf2 [1];  				buf2 [1] = b;  			}  			R16 [i] = PortUtil.make_int16_le (buf2);  		}  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	fs.read (buf' 0' 1);  	L8 [i] = buf [0];  	if (m_channel == WaveChannel.Stereo) {  		fs.read (buf' 0' 1);  		R8 [i] = buf [0];  	}  } else {  	fs.read (buf2' 0' 2);  	if (change_byte_order) {  		byte b = buf2 [0];  		buf2 [0] = buf2 [1];  		buf2 [1] = b;  	}  	L16 [i] = PortUtil.make_int16_le (buf2);  	if (m_channel == WaveChannel.Stereo) {  		fs.read (buf2' 0' 2);  		if (change_byte_order) {  			byte b = buf2 [0];  			buf2 [0] = buf2 [1];  			buf2 [1] = b;  		}  		R16 [i] = PortUtil.make_int16_le (buf2);  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	fs.read (buf' 0' 1);  	L8 [i] = buf [0];  	if (m_channel == WaveChannel.Stereo) {  		fs.read (buf' 0' 1);  		R8 [i] = buf [0];  	}  } else {  	fs.read (buf2' 0' 2);  	if (change_byte_order) {  		byte b = buf2 [0];  		buf2 [0] = buf2 [1];  		buf2 [1] = b;  	}  	L16 [i] = PortUtil.make_int16_le (buf2);  	if (m_channel == WaveChannel.Stereo) {  		fs.read (buf2' 0' 2);  		if (change_byte_order) {  			byte b = buf2 [0];  			buf2 [0] = buf2 [1];  			buf2 [1] = b;  		}  		R16 [i] = PortUtil.make_int16_le (buf2);  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	fs.read (buf' 0' 1);  	L8 [i] = buf [0];  	if (m_channel == WaveChannel.Stereo) {  		fs.read (buf' 0' 1);  		R8 [i] = buf [0];  	}  } else {  	fs.read (buf2' 0' 2);  	if (change_byte_order) {  		byte b = buf2 [0];  		buf2 [0] = buf2 [1];  		buf2 [1] = b;  	}  	L16 [i] = PortUtil.make_int16_le (buf2);  	if (m_channel == WaveChannel.Stereo) {  		fs.read (buf2' 0' 2);  		if (change_byte_order) {  			byte b = buf2 [0];  			buf2 [0] = buf2 [1];  			buf2 [1] = b;  		}  		R16 [i] = PortUtil.make_int16_le (buf2);  	}  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: fs.read (buf2' 0' 2);  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: if (m_channel == WaveChannel.Stereo) {  	fs.read (buf2' 0' 2);  	if (change_byte_order) {  		byte b = buf2 [0];  		buf2 [0] = buf2 [1];  		buf2 [1] = b;  	}  	R16 [i] = PortUtil.make_int16_le (buf2);  }  
Magic Number,cadencii.media,Wave,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\Wave.cs,read,The following statement contains a magic number: fs.read (buf2' 0' 2);  
Magic Number,cadencii.media,WavePlay,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WavePlay.cs,append_cor,The following statement contains a magic number: ptr_data = Marshal.AllocHGlobal (sizeof(float*) * 2);  
Magic Number,cadencii.media,WavePlay,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WavePlay.cs,util_get_errmsg,The following statement contains a magic number: win32.mciGetErrorStringA (msg' ret' 260);  
Magic Number,cadencii.media,WavePlay,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WavePlay.cs,WavePlay,The following statement contains a magic number: s_wave_formatx.nChannels = 2;  
Magic Number,cadencii.media,WavePlay,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WavePlay.cs,WavePlay,The following statement contains a magic number: s_wave_formatx.wBitsPerSample = 16;  
Magic Number,cadencii.media,WavePlay,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WavePlay.cs,WavePlay,The following statement contains a magic number: s_wave_formatx.nBlockAlign = (ushort)(s_wave_formatx.nChannels * s_wave_formatx.wBitsPerSample / 8);  
Magic Number,cadencii.media,WavePlay,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WavePlay.cs,MAKELONG,The following statement contains a magic number: return (uint)(a & 0xffff) | (uint)((b & 0xffff) << 16);  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The following statement contains a magic number: m_stream.read (buf' 0' 4);  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The following statement contains a magic number: if (buf [0] != 'R' || buf [1] != 'I' || buf [2] != 'F' || buf [3] != 'F') {  	m_stream.close ();  	#if DEBUG  	                serr.println( "WaveReaderopen; header error(RIFF)" ); #endif  	return false;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The following statement contains a magic number: if (buf [0] != 'R' || buf [1] != 'I' || buf [2] != 'F' || buf [3] != 'F') {  	m_stream.close ();  	#if DEBUG  	                serr.println( "WaveReaderopen; header error(RIFF)" ); #endif  	return false;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The following statement contains a magic number: m_stream.read (buf' 0' 4);  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The following statement contains a magic number: m_stream.read (buf' 0' 4);  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The following statement contains a magic number: if (buf [0] != 'W' || buf [1] != 'A' || buf [2] != 'V' || buf [3] != 'E') {  	m_stream.close ();  	#if DEBUG  	                serr.println( "WaveReaderopen; header error(WAVE)" ); #endif  	return false;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The following statement contains a magic number: if (buf [0] != 'W' || buf [1] != 'A' || buf [2] != 'V' || buf [3] != 'E') {  	m_stream.close ();  	#if DEBUG  	                serr.println( "WaveReaderopen; header error(WAVE)" ); #endif  	return false;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The following statement contains a magic number: m_stream.read (buf' 0' 4);  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The following statement contains a magic number: if (buf [0] != 'f' || buf [1] != 'm' || buf [2] != 't' || buf [3] != ' ') {  	m_stream.close ();  	#if DEBUG  	                serr.println( "WaveReaderopen; header error(fmt )" ); #endif  	return false;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The following statement contains a magic number: if (buf [0] != 'f' || buf [1] != 'm' || buf [2] != 't' || buf [3] != ' ') {  	m_stream.close ();  	#if DEBUG  	                serr.println( "WaveReaderopen; header error(fmt )" ); #endif  	return false;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The following statement contains a magic number: m_stream.read (buf' 0' 4);  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The following statement contains a magic number: m_stream.read (buf' 0' 2);  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The following statement contains a magic number: m_stream.read (buf' 0' 2);  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The following statement contains a magic number: m_channel = buf [1] << 8 | buf [0];  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The following statement contains a magic number: m_stream.read (buf' 0' 4);  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The following statement contains a magic number: m_stream.read (buf' 0' 4);  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The following statement contains a magic number: m_stream.read (buf' 0' 2);  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The following statement contains a magic number: m_stream.read (buf' 0' 2);  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The following statement contains a magic number: m_byte_per_sample = bit_per_sample / 8;  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The following statement contains a magic number: m_stream.read (buf' 0' 4);  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The following statement contains a magic number: if (buf [0] != 'd' || buf [1] != 'a' || buf [2] != 't' || buf [3] != 'a') {  	m_stream.close ();  	#if DEBUG  	                serr.println( "WaveReaderopen; header error (data)" ); #endif  	return false;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The following statement contains a magic number: if (buf [0] != 'd' || buf [1] != 'a' || buf [2] != 't' || buf [3] != 'a') {  	m_stream.close ();  	#if DEBUG  	                serr.println( "WaveReaderopen; header error (data)" ); #endif  	return false;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,open,The following statement contains a magic number: m_stream.read (buf' 0' 4);  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		double coeff_left = m_amplify_left / 32768.0;  		double coeff_right = m_amplify_right / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 64.0;  		double coeff_right = m_amplify_right / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		double coeff_left = m_amplify_left / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		double coeff_left = m_amplify_left / 32768.0;  		double coeff_right = m_amplify_right / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 64.0;  		double coeff_right = m_amplify_right / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		double coeff_left = m_amplify_left / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		double coeff_left = m_amplify_left / 32768.0;  		double coeff_right = m_amplify_right / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 64.0;  		double coeff_right = m_amplify_right / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		double coeff_left = m_amplify_left / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		double coeff_left = m_amplify_left / 32768.0;  		double coeff_right = m_amplify_right / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 64.0;  		double coeff_right = m_amplify_right / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		double coeff_left = m_amplify_left / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		double coeff_left = m_amplify_left / 32768.0;  		double coeff_right = m_amplify_right / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 64.0;  		double coeff_right = m_amplify_right / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		double coeff_left = m_amplify_left / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		double coeff_left = m_amplify_left / 32768.0;  		double coeff_right = m_amplify_right / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 64.0;  		double coeff_right = m_amplify_right / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		double coeff_left = m_amplify_left / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		double coeff_left = m_amplify_left / 32768.0;  		double coeff_right = m_amplify_right / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 64.0;  		double coeff_right = m_amplify_right / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		double coeff_left = m_amplify_left / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		double coeff_left = m_amplify_left / 32768.0;  		double coeff_right = m_amplify_right / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 64.0;  		double coeff_right = m_amplify_right / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		double coeff_left = m_amplify_left / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		double coeff_left = m_amplify_left / 32768.0;  		double coeff_right = m_amplify_right / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 64.0;  		double coeff_right = m_amplify_right / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		double coeff_left = m_amplify_left / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		double coeff_left = m_amplify_left / 32768.0;  		double coeff_right = m_amplify_right / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 64.0;  		double coeff_right = m_amplify_right / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		double coeff_left = m_amplify_left / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		double coeff_left = m_amplify_left / 32768.0;  		double coeff_right = m_amplify_right / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 64.0;  		double coeff_right = m_amplify_right / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		double coeff_left = m_amplify_left / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		double coeff_left = m_amplify_left / 32768.0;  		double coeff_right = m_amplify_right / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 64.0;  		double coeff_right = m_amplify_right / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		double coeff_left = m_amplify_left / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		double coeff_left = m_amplify_left / 32768.0;  		double coeff_right = m_amplify_right / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 64.0;  		double coeff_right = m_amplify_right / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		double coeff_left = m_amplify_left / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		double coeff_left = m_amplify_left / 32768.0;  		double coeff_right = m_amplify_right / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 64.0;  		double coeff_right = m_amplify_right / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		double coeff_left = m_amplify_left / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		double coeff_left = m_amplify_left / 32768.0;  		double coeff_right = m_amplify_right / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 64.0;  		double coeff_right = m_amplify_right / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		double coeff_left = m_amplify_left / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		double coeff_left = m_amplify_left / 32768.0;  		double coeff_right = m_amplify_right / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 64.0;  		double coeff_right = m_amplify_right / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		double coeff_left = m_amplify_left / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		double coeff_left = m_amplify_left / 32768.0;  		double coeff_right = m_amplify_right / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 64.0;  		double coeff_right = m_amplify_right / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		double coeff_left = m_amplify_left / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		double coeff_left = m_amplify_left / 32768.0;  		double coeff_right = m_amplify_right / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 64.0;  		double coeff_right = m_amplify_right / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		double coeff_left = m_amplify_left / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		double coeff_left = m_amplify_left / 32768.0;  		double coeff_right = m_amplify_right / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 32768.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		double coeff_left = m_amplify_left / 64.0;  		double coeff_right = m_amplify_right / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		double coeff_left = m_amplify_left / 64.0;  		for (int i = i_start; i <= i_end; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[4];  	double coeff_left = m_amplify_left / 32768.0;  	double coeff_right = m_amplify_right / 32768.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 4);  		if (ret < 4) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		short r = PortUtil.make_int16_le (buf' 2);  		left [i] = l * coeff_left;  		right [i] = r * coeff_right;  	}  } else {  	byte[] buf = new byte[2];  	double coeff_left = m_amplify_left / 32768.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		left [i] = l * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[4];  	double coeff_left = m_amplify_left / 32768.0;  	double coeff_right = m_amplify_right / 32768.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 4);  		if (ret < 4) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		short r = PortUtil.make_int16_le (buf' 2);  		left [i] = l * coeff_left;  		right [i] = r * coeff_right;  	}  } else {  	byte[] buf = new byte[2];  	double coeff_left = m_amplify_left / 32768.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		left [i] = l * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[4];  	double coeff_left = m_amplify_left / 32768.0;  	double coeff_right = m_amplify_right / 32768.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 4);  		if (ret < 4) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		short r = PortUtil.make_int16_le (buf' 2);  		left [i] = l * coeff_left;  		right [i] = r * coeff_right;  	}  } else {  	byte[] buf = new byte[2];  	double coeff_left = m_amplify_left / 32768.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		left [i] = l * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[4];  	double coeff_left = m_amplify_left / 32768.0;  	double coeff_right = m_amplify_right / 32768.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 4);  		if (ret < 4) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		short r = PortUtil.make_int16_le (buf' 2);  		left [i] = l * coeff_left;  		right [i] = r * coeff_right;  	}  } else {  	byte[] buf = new byte[2];  	double coeff_left = m_amplify_left / 32768.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		left [i] = l * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[4];  	double coeff_left = m_amplify_left / 32768.0;  	double coeff_right = m_amplify_right / 32768.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 4);  		if (ret < 4) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		short r = PortUtil.make_int16_le (buf' 2);  		left [i] = l * coeff_left;  		right [i] = r * coeff_right;  	}  } else {  	byte[] buf = new byte[2];  	double coeff_left = m_amplify_left / 32768.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		left [i] = l * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[4];  	double coeff_left = m_amplify_left / 32768.0;  	double coeff_right = m_amplify_right / 32768.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 4);  		if (ret < 4) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		short r = PortUtil.make_int16_le (buf' 2);  		left [i] = l * coeff_left;  		right [i] = r * coeff_right;  	}  } else {  	byte[] buf = new byte[2];  	double coeff_left = m_amplify_left / 32768.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		left [i] = l * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[4];  	double coeff_left = m_amplify_left / 32768.0;  	double coeff_right = m_amplify_right / 32768.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 4);  		if (ret < 4) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		short r = PortUtil.make_int16_le (buf' 2);  		left [i] = l * coeff_left;  		right [i] = r * coeff_right;  	}  } else {  	byte[] buf = new byte[2];  	double coeff_left = m_amplify_left / 32768.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		left [i] = l * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[4];  	double coeff_left = m_amplify_left / 32768.0;  	double coeff_right = m_amplify_right / 32768.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 4);  		if (ret < 4) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		short r = PortUtil.make_int16_le (buf' 2);  		left [i] = l * coeff_left;  		right [i] = r * coeff_right;  	}  } else {  	byte[] buf = new byte[2];  	double coeff_left = m_amplify_left / 32768.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		left [i] = l * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[4];  	double coeff_left = m_amplify_left / 32768.0;  	double coeff_right = m_amplify_right / 32768.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 4);  		if (ret < 4) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		short r = PortUtil.make_int16_le (buf' 2);  		left [i] = l * coeff_left;  		right [i] = r * coeff_right;  	}  } else {  	byte[] buf = new byte[2];  	double coeff_left = m_amplify_left / 32768.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		left [i] = l * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[4];  	double coeff_left = m_amplify_left / 32768.0;  	double coeff_right = m_amplify_right / 32768.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 4);  		if (ret < 4) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		short r = PortUtil.make_int16_le (buf' 2);  		left [i] = l * coeff_left;  		right [i] = r * coeff_right;  	}  } else {  	byte[] buf = new byte[2];  	double coeff_left = m_amplify_left / 32768.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		left [i] = l * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[4];  	double coeff_left = m_amplify_left / 32768.0;  	double coeff_right = m_amplify_right / 32768.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 4);  		if (ret < 4) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		short r = PortUtil.make_int16_le (buf' 2);  		left [i] = l * coeff_left;  		right [i] = r * coeff_right;  	}  } else {  	byte[] buf = new byte[2];  	double coeff_left = m_amplify_left / 32768.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		left [i] = l * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: for (int i = i_start; i <= i_end; i++) {  	int ret = m_stream.read (buf' 0' 4);  	if (ret < 4) {  		for (int j = i; j < length; j++) {  			left [j] = 0.0f;  			right [j] = 0.0f;  		}  		break;  	}  	short l = PortUtil.make_int16_le (buf' 0);  	short r = PortUtil.make_int16_le (buf' 2);  	left [i] = l * coeff_left;  	right [i] = r * coeff_right;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: for (int i = i_start; i <= i_end; i++) {  	int ret = m_stream.read (buf' 0' 4);  	if (ret < 4) {  		for (int j = i; j < length; j++) {  			left [j] = 0.0f;  			right [j] = 0.0f;  		}  		break;  	}  	short l = PortUtil.make_int16_le (buf' 0);  	short r = PortUtil.make_int16_le (buf' 2);  	left [i] = l * coeff_left;  	right [i] = r * coeff_right;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: for (int i = i_start; i <= i_end; i++) {  	int ret = m_stream.read (buf' 0' 4);  	if (ret < 4) {  		for (int j = i; j < length; j++) {  			left [j] = 0.0f;  			right [j] = 0.0f;  		}  		break;  	}  	short l = PortUtil.make_int16_le (buf' 0);  	short r = PortUtil.make_int16_le (buf' 2);  	left [i] = l * coeff_left;  	right [i] = r * coeff_right;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (ret < 4) {  	for (int j = i; j < length; j++) {  		left [j] = 0.0f;  		right [j] = 0.0f;  	}  	break;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: for (int i = i_start; i <= i_end; i++) {  	int ret = m_stream.read (buf' 0' 2);  	if (ret < 2) {  		for (int j = i; j < length; j++) {  			left [j] = 0.0f;  			right [j] = 0.0f;  		}  		break;  	}  	short l = PortUtil.make_int16_le (buf' 0);  	left [i] = l * coeff_left;  	right [i] = left [i];  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: for (int i = i_start; i <= i_end; i++) {  	int ret = m_stream.read (buf' 0' 2);  	if (ret < 2) {  		for (int j = i; j < length; j++) {  			left [j] = 0.0f;  			right [j] = 0.0f;  		}  		break;  	}  	short l = PortUtil.make_int16_le (buf' 0);  	left [i] = l * coeff_left;  	right [i] = left [i];  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (ret < 2) {  	for (int j = i; j < length; j++) {  		left [j] = 0.0f;  		right [j] = 0.0f;  	}  	break;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[2];  	double coeff_left = m_amplify_left / 64.0;  	double coeff_right = m_amplify_right / 64.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  	}  } else {  	byte[] buf = new byte[1];  	double coeff_left = m_amplify_left / 64.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 1);  		if (ret < 1) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[2];  	double coeff_left = m_amplify_left / 64.0;  	double coeff_right = m_amplify_right / 64.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  	}  } else {  	byte[] buf = new byte[1];  	double coeff_left = m_amplify_left / 64.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 1);  		if (ret < 1) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[2];  	double coeff_left = m_amplify_left / 64.0;  	double coeff_right = m_amplify_right / 64.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  	}  } else {  	byte[] buf = new byte[1];  	double coeff_left = m_amplify_left / 64.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 1);  		if (ret < 1) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[2];  	double coeff_left = m_amplify_left / 64.0;  	double coeff_right = m_amplify_right / 64.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  	}  } else {  	byte[] buf = new byte[1];  	double coeff_left = m_amplify_left / 64.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 1);  		if (ret < 1) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[2];  	double coeff_left = m_amplify_left / 64.0;  	double coeff_right = m_amplify_right / 64.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  	}  } else {  	byte[] buf = new byte[1];  	double coeff_left = m_amplify_left / 64.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 1);  		if (ret < 1) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[2];  	double coeff_left = m_amplify_left / 64.0;  	double coeff_right = m_amplify_right / 64.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  	}  } else {  	byte[] buf = new byte[1];  	double coeff_left = m_amplify_left / 64.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 1);  		if (ret < 1) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[2];  	double coeff_left = m_amplify_left / 64.0;  	double coeff_right = m_amplify_right / 64.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  	}  } else {  	byte[] buf = new byte[1];  	double coeff_left = m_amplify_left / 64.0;  	for (int i = i_start; i <= i_end; i++) {  		int ret = m_stream.read (buf' 0' 1);  		if (ret < 1) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: for (int i = i_start; i <= i_end; i++) {  	int ret = m_stream.read (buf' 0' 2);  	if (ret < 2) {  		for (int j = i; j < length; j++) {  			left [j] = 0.0f;  			right [j] = 0.0f;  		}  		break;  	}  	left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  	right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: for (int i = i_start; i <= i_end; i++) {  	int ret = m_stream.read (buf' 0' 2);  	if (ret < 2) {  		for (int j = i; j < length; j++) {  			left [j] = 0.0f;  			right [j] = 0.0f;  		}  		break;  	}  	left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  	right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (ret < 2) {  	for (int j = i; j < length; j++) {  		left [j] = 0.0f;  		right [j] = 0.0f;  	}  	break;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		float coeff_right = (float)(m_amplify_right / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left.value [i] = l * coeff_left;  			right.value [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left.value [i] = l * coeff_left;  			right.value [i] = left.value [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		float coeff_right = (float)(m_amplify_right / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right.value [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right.value [i] = left.value [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		float coeff_right = (float)(m_amplify_right / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left.value [i] = l * coeff_left;  			right.value [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left.value [i] = l * coeff_left;  			right.value [i] = left.value [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		float coeff_right = (float)(m_amplify_right / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right.value [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right.value [i] = left.value [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		float coeff_right = (float)(m_amplify_right / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left.value [i] = l * coeff_left;  			right.value [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left.value [i] = l * coeff_left;  			right.value [i] = left.value [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		float coeff_right = (float)(m_amplify_right / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right.value [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right.value [i] = left.value [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		float coeff_right = (float)(m_amplify_right / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left.value [i] = l * coeff_left;  			right.value [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left.value [i] = l * coeff_left;  			right.value [i] = left.value [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		float coeff_right = (float)(m_amplify_right / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right.value [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right.value [i] = left.value [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		float coeff_right = (float)(m_amplify_right / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left.value [i] = l * coeff_left;  			right.value [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left.value [i] = l * coeff_left;  			right.value [i] = left.value [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		float coeff_right = (float)(m_amplify_right / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right.value [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right.value [i] = left.value [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		float coeff_right = (float)(m_amplify_right / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left.value [i] = l * coeff_left;  			right.value [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left.value [i] = l * coeff_left;  			right.value [i] = left.value [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		float coeff_right = (float)(m_amplify_right / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right.value [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right.value [i] = left.value [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		float coeff_right = (float)(m_amplify_right / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left.value [i] = l * coeff_left;  			right.value [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left.value [i] = l * coeff_left;  			right.value [i] = left.value [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		float coeff_right = (float)(m_amplify_right / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right.value [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right.value [i] = left.value [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		float coeff_right = (float)(m_amplify_right / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left.value [i] = l * coeff_left;  			right.value [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left.value [i] = l * coeff_left;  			right.value [i] = left.value [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		float coeff_right = (float)(m_amplify_right / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right.value [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right.value [i] = left.value [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		float coeff_right = (float)(m_amplify_right / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left.value [i] = l * coeff_left;  			right.value [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left.value [i] = l * coeff_left;  			right.value [i] = left.value [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		float coeff_right = (float)(m_amplify_right / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right.value [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right.value [i] = left.value [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		float coeff_right = (float)(m_amplify_right / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left.value [i] = l * coeff_left;  			right.value [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left.value [i] = l * coeff_left;  			right.value [i] = left.value [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		float coeff_right = (float)(m_amplify_right / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right.value [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right.value [i] = left.value [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		float coeff_right = (float)(m_amplify_right / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left.value [i] = l * coeff_left;  			right.value [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left.value [i] = l * coeff_left;  			right.value [i] = left.value [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		float coeff_right = (float)(m_amplify_right / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right.value [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right.value [i] = left.value [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		float coeff_right = (float)(m_amplify_right / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left.value [i] = l * coeff_left;  			right.value [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left.value [i] = l * coeff_left;  			right.value [i] = left.value [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		float coeff_right = (float)(m_amplify_right / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right.value [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right.value [i] = left.value [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		float coeff_right = (float)(m_amplify_right / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left.value [i] = l * coeff_left;  			right.value [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left.value [i] = l * coeff_left;  			right.value [i] = left.value [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		float coeff_right = (float)(m_amplify_right / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right.value [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left.value [j] = 0.0f;  					right.value [j] = 0.0f;  				}  				break;  			}  			left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right.value [i] = left.value [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[4];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	float coeff_right = (float)(m_amplify_right / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 4);  		if (ret < 4) {  			for (int j = i; j < length; j++) {  				left.value [j] = 0.0f;  				right.value [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		short r = PortUtil.make_int16_le (buf' 2);  		left.value [i] = l * coeff_left;  		right.value [i] = r * coeff_right;  	}  } else {  	byte[] buf = new byte[2];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left.value [j] = 0.0f;  				right.value [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		left.value [i] = l * coeff_left;  		right.value [i] = left.value [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[4];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	float coeff_right = (float)(m_amplify_right / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 4);  		if (ret < 4) {  			for (int j = i; j < length; j++) {  				left.value [j] = 0.0f;  				right.value [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		short r = PortUtil.make_int16_le (buf' 2);  		left.value [i] = l * coeff_left;  		right.value [i] = r * coeff_right;  	}  } else {  	byte[] buf = new byte[2];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left.value [j] = 0.0f;  				right.value [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		left.value [i] = l * coeff_left;  		right.value [i] = left.value [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[4];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	float coeff_right = (float)(m_amplify_right / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 4);  		if (ret < 4) {  			for (int j = i; j < length; j++) {  				left.value [j] = 0.0f;  				right.value [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		short r = PortUtil.make_int16_le (buf' 2);  		left.value [i] = l * coeff_left;  		right.value [i] = r * coeff_right;  	}  } else {  	byte[] buf = new byte[2];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left.value [j] = 0.0f;  				right.value [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		left.value [i] = l * coeff_left;  		right.value [i] = left.value [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[4];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	float coeff_right = (float)(m_amplify_right / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 4);  		if (ret < 4) {  			for (int j = i; j < length; j++) {  				left.value [j] = 0.0f;  				right.value [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		short r = PortUtil.make_int16_le (buf' 2);  		left.value [i] = l * coeff_left;  		right.value [i] = r * coeff_right;  	}  } else {  	byte[] buf = new byte[2];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left.value [j] = 0.0f;  				right.value [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		left.value [i] = l * coeff_left;  		right.value [i] = left.value [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[4];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	float coeff_right = (float)(m_amplify_right / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 4);  		if (ret < 4) {  			for (int j = i; j < length; j++) {  				left.value [j] = 0.0f;  				right.value [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		short r = PortUtil.make_int16_le (buf' 2);  		left.value [i] = l * coeff_left;  		right.value [i] = r * coeff_right;  	}  } else {  	byte[] buf = new byte[2];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left.value [j] = 0.0f;  				right.value [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		left.value [i] = l * coeff_left;  		right.value [i] = left.value [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[4];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	float coeff_right = (float)(m_amplify_right / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 4);  		if (ret < 4) {  			for (int j = i; j < length; j++) {  				left.value [j] = 0.0f;  				right.value [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		short r = PortUtil.make_int16_le (buf' 2);  		left.value [i] = l * coeff_left;  		right.value [i] = r * coeff_right;  	}  } else {  	byte[] buf = new byte[2];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left.value [j] = 0.0f;  				right.value [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		left.value [i] = l * coeff_left;  		right.value [i] = left.value [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[4];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	float coeff_right = (float)(m_amplify_right / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 4);  		if (ret < 4) {  			for (int j = i; j < length; j++) {  				left.value [j] = 0.0f;  				right.value [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		short r = PortUtil.make_int16_le (buf' 2);  		left.value [i] = l * coeff_left;  		right.value [i] = r * coeff_right;  	}  } else {  	byte[] buf = new byte[2];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left.value [j] = 0.0f;  				right.value [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		left.value [i] = l * coeff_left;  		right.value [i] = left.value [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[4];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	float coeff_right = (float)(m_amplify_right / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 4);  		if (ret < 4) {  			for (int j = i; j < length; j++) {  				left.value [j] = 0.0f;  				right.value [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		short r = PortUtil.make_int16_le (buf' 2);  		left.value [i] = l * coeff_left;  		right.value [i] = r * coeff_right;  	}  } else {  	byte[] buf = new byte[2];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left.value [j] = 0.0f;  				right.value [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		left.value [i] = l * coeff_left;  		right.value [i] = left.value [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	int ret = m_stream.read (buf' 0' 4);  	if (ret < 4) {  		for (int j = i; j < length; j++) {  			left.value [j] = 0.0f;  			right.value [j] = 0.0f;  		}  		break;  	}  	short l = PortUtil.make_int16_le (buf' 0);  	short r = PortUtil.make_int16_le (buf' 2);  	left.value [i] = l * coeff_left;  	right.value [i] = r * coeff_right;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	int ret = m_stream.read (buf' 0' 4);  	if (ret < 4) {  		for (int j = i; j < length; j++) {  			left.value [j] = 0.0f;  			right.value [j] = 0.0f;  		}  		break;  	}  	short l = PortUtil.make_int16_le (buf' 0);  	short r = PortUtil.make_int16_le (buf' 2);  	left.value [i] = l * coeff_left;  	right.value [i] = r * coeff_right;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	int ret = m_stream.read (buf' 0' 4);  	if (ret < 4) {  		for (int j = i; j < length; j++) {  			left.value [j] = 0.0f;  			right.value [j] = 0.0f;  		}  		break;  	}  	short l = PortUtil.make_int16_le (buf' 0);  	short r = PortUtil.make_int16_le (buf' 2);  	left.value [i] = l * coeff_left;  	right.value [i] = r * coeff_right;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (ret < 4) {  	for (int j = i; j < length; j++) {  		left.value [j] = 0.0f;  		right.value [j] = 0.0f;  	}  	break;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	int ret = m_stream.read (buf' 0' 2);  	if (ret < 2) {  		for (int j = i; j < length; j++) {  			left.value [j] = 0.0f;  			right.value [j] = 0.0f;  		}  		break;  	}  	short l = PortUtil.make_int16_le (buf' 0);  	left.value [i] = l * coeff_left;  	right.value [i] = left.value [i];  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	int ret = m_stream.read (buf' 0' 2);  	if (ret < 2) {  		for (int j = i; j < length; j++) {  			left.value [j] = 0.0f;  			right.value [j] = 0.0f;  		}  		break;  	}  	short l = PortUtil.make_int16_le (buf' 0);  	left.value [i] = l * coeff_left;  	right.value [i] = left.value [i];  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (ret < 2) {  	for (int j = i; j < length; j++) {  		left.value [j] = 0.0f;  		right.value [j] = 0.0f;  	}  	break;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[2];  	float coeff_left = (float)(m_amplify_left / 64.0f);  	float coeff_right = (float)(m_amplify_right / 64.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left.value [j] = 0.0f;  				right.value [j] = 0.0f;  			}  			break;  		}  		left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right.value [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  	}  } else {  	byte[] buf = new byte[1];  	float coeff_left = (float)(m_amplify_left / 64.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 1);  		if (ret < 1) {  			for (int j = i; j < length; j++) {  				left.value [j] = 0.0f;  				right.value [j] = 0.0f;  			}  			break;  		}  		left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right.value [i] = left.value [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[2];  	float coeff_left = (float)(m_amplify_left / 64.0f);  	float coeff_right = (float)(m_amplify_right / 64.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left.value [j] = 0.0f;  				right.value [j] = 0.0f;  			}  			break;  		}  		left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right.value [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  	}  } else {  	byte[] buf = new byte[1];  	float coeff_left = (float)(m_amplify_left / 64.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 1);  		if (ret < 1) {  			for (int j = i; j < length; j++) {  				left.value [j] = 0.0f;  				right.value [j] = 0.0f;  			}  			break;  		}  		left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right.value [i] = left.value [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[2];  	float coeff_left = (float)(m_amplify_left / 64.0f);  	float coeff_right = (float)(m_amplify_right / 64.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left.value [j] = 0.0f;  				right.value [j] = 0.0f;  			}  			break;  		}  		left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right.value [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  	}  } else {  	byte[] buf = new byte[1];  	float coeff_left = (float)(m_amplify_left / 64.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 1);  		if (ret < 1) {  			for (int j = i; j < length; j++) {  				left.value [j] = 0.0f;  				right.value [j] = 0.0f;  			}  			break;  		}  		left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right.value [i] = left.value [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[2];  	float coeff_left = (float)(m_amplify_left / 64.0f);  	float coeff_right = (float)(m_amplify_right / 64.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left.value [j] = 0.0f;  				right.value [j] = 0.0f;  			}  			break;  		}  		left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right.value [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  	}  } else {  	byte[] buf = new byte[1];  	float coeff_left = (float)(m_amplify_left / 64.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 1);  		if (ret < 1) {  			for (int j = i; j < length; j++) {  				left.value [j] = 0.0f;  				right.value [j] = 0.0f;  			}  			break;  		}  		left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right.value [i] = left.value [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	int ret = m_stream.read (buf' 0' 2);  	if (ret < 2) {  		for (int j = i; j < length; j++) {  			left.value [j] = 0.0f;  			right.value [j] = 0.0f;  		}  		break;  	}  	left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  	right.value [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	int ret = m_stream.read (buf' 0' 2);  	if (ret < 2) {  		for (int j = i; j < length; j++) {  			left.value [j] = 0.0f;  			right.value [j] = 0.0f;  		}  		break;  	}  	left.value [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  	right.value [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (ret < 2) {  	for (int j = i; j < length; j++) {  		left.value [j] = 0.0f;  		right.value [j] = 0.0f;  	}  	break;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		float coeff_right = (float)(m_amplify_right / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		float coeff_right = (float)(m_amplify_right / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		float coeff_right = (float)(m_amplify_right / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		float coeff_right = (float)(m_amplify_right / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		float coeff_right = (float)(m_amplify_right / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		float coeff_right = (float)(m_amplify_right / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		float coeff_right = (float)(m_amplify_right / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		float coeff_right = (float)(m_amplify_right / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		float coeff_right = (float)(m_amplify_right / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		float coeff_right = (float)(m_amplify_right / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		float coeff_right = (float)(m_amplify_right / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		float coeff_right = (float)(m_amplify_right / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		float coeff_right = (float)(m_amplify_right / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		float coeff_right = (float)(m_amplify_right / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		float coeff_right = (float)(m_amplify_right / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		float coeff_right = (float)(m_amplify_right / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		float coeff_right = (float)(m_amplify_right / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		float coeff_right = (float)(m_amplify_right / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		float coeff_right = (float)(m_amplify_right / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		float coeff_right = (float)(m_amplify_right / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		float coeff_right = (float)(m_amplify_right / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		float coeff_right = (float)(m_amplify_right / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		float coeff_right = (float)(m_amplify_right / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		float coeff_right = (float)(m_amplify_right / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_byte_per_sample == 2) {  	if (m_channel == 2) {  		byte[] buf = new byte[4];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		float coeff_right = (float)(m_amplify_right / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 4);  			if (ret < 4) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			short r = PortUtil.make_int16_le (buf' 2);  			left [i] = l * coeff_left;  			right [i] = r * coeff_right;  		}  	} else {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 32768.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			short l = PortUtil.make_int16_le (buf' 0);  			left [i] = l * coeff_left;  			right [i] = left [i];  		}  	}  } else {  	if (m_channel == 2) {  		byte[] buf = new byte[2];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		float coeff_right = (float)(m_amplify_right / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 2);  			if (ret < 2) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  		}  	} else {  		byte[] buf = new byte[1];  		float coeff_left = (float)(m_amplify_left / 64.0f);  		for (int i = 0; i < length; i++) {  			int ret = m_stream.read (buf' 0' 1);  			if (ret < 1) {  				for (int j = i; j < length; j++) {  					left [j] = 0.0f;  					right [j] = 0.0f;  				}  				break;  			}  			left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  			right [i] = left [i];  		}  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[4];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	float coeff_right = (float)(m_amplify_right / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 4);  		if (ret < 4) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		short r = PortUtil.make_int16_le (buf' 2);  		left [i] = l * coeff_left;  		right [i] = r * coeff_right;  	}  } else {  	byte[] buf = new byte[2];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		left [i] = l * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[4];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	float coeff_right = (float)(m_amplify_right / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 4);  		if (ret < 4) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		short r = PortUtil.make_int16_le (buf' 2);  		left [i] = l * coeff_left;  		right [i] = r * coeff_right;  	}  } else {  	byte[] buf = new byte[2];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		left [i] = l * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[4];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	float coeff_right = (float)(m_amplify_right / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 4);  		if (ret < 4) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		short r = PortUtil.make_int16_le (buf' 2);  		left [i] = l * coeff_left;  		right [i] = r * coeff_right;  	}  } else {  	byte[] buf = new byte[2];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		left [i] = l * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[4];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	float coeff_right = (float)(m_amplify_right / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 4);  		if (ret < 4) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		short r = PortUtil.make_int16_le (buf' 2);  		left [i] = l * coeff_left;  		right [i] = r * coeff_right;  	}  } else {  	byte[] buf = new byte[2];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		left [i] = l * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[4];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	float coeff_right = (float)(m_amplify_right / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 4);  		if (ret < 4) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		short r = PortUtil.make_int16_le (buf' 2);  		left [i] = l * coeff_left;  		right [i] = r * coeff_right;  	}  } else {  	byte[] buf = new byte[2];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		left [i] = l * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[4];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	float coeff_right = (float)(m_amplify_right / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 4);  		if (ret < 4) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		short r = PortUtil.make_int16_le (buf' 2);  		left [i] = l * coeff_left;  		right [i] = r * coeff_right;  	}  } else {  	byte[] buf = new byte[2];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		left [i] = l * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[4];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	float coeff_right = (float)(m_amplify_right / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 4);  		if (ret < 4) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		short r = PortUtil.make_int16_le (buf' 2);  		left [i] = l * coeff_left;  		right [i] = r * coeff_right;  	}  } else {  	byte[] buf = new byte[2];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		left [i] = l * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[4];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	float coeff_right = (float)(m_amplify_right / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 4);  		if (ret < 4) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		short r = PortUtil.make_int16_le (buf' 2);  		left [i] = l * coeff_left;  		right [i] = r * coeff_right;  	}  } else {  	byte[] buf = new byte[2];  	float coeff_left = (float)(m_amplify_left / 32768.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		short l = PortUtil.make_int16_le (buf' 0);  		left [i] = l * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	int ret = m_stream.read (buf' 0' 4);  	if (ret < 4) {  		for (int j = i; j < length; j++) {  			left [j] = 0.0f;  			right [j] = 0.0f;  		}  		break;  	}  	short l = PortUtil.make_int16_le (buf' 0);  	short r = PortUtil.make_int16_le (buf' 2);  	left [i] = l * coeff_left;  	right [i] = r * coeff_right;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	int ret = m_stream.read (buf' 0' 4);  	if (ret < 4) {  		for (int j = i; j < length; j++) {  			left [j] = 0.0f;  			right [j] = 0.0f;  		}  		break;  	}  	short l = PortUtil.make_int16_le (buf' 0);  	short r = PortUtil.make_int16_le (buf' 2);  	left [i] = l * coeff_left;  	right [i] = r * coeff_right;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	int ret = m_stream.read (buf' 0' 4);  	if (ret < 4) {  		for (int j = i; j < length; j++) {  			left [j] = 0.0f;  			right [j] = 0.0f;  		}  		break;  	}  	short l = PortUtil.make_int16_le (buf' 0);  	short r = PortUtil.make_int16_le (buf' 2);  	left [i] = l * coeff_left;  	right [i] = r * coeff_right;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (ret < 4) {  	for (int j = i; j < length; j++) {  		left [j] = 0.0f;  		right [j] = 0.0f;  	}  	break;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	int ret = m_stream.read (buf' 0' 2);  	if (ret < 2) {  		for (int j = i; j < length; j++) {  			left [j] = 0.0f;  			right [j] = 0.0f;  		}  		break;  	}  	short l = PortUtil.make_int16_le (buf' 0);  	left [i] = l * coeff_left;  	right [i] = left [i];  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	int ret = m_stream.read (buf' 0' 2);  	if (ret < 2) {  		for (int j = i; j < length; j++) {  			left [j] = 0.0f;  			right [j] = 0.0f;  		}  		break;  	}  	short l = PortUtil.make_int16_le (buf' 0);  	left [i] = l * coeff_left;  	right [i] = left [i];  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (ret < 2) {  	for (int j = i; j < length; j++) {  		left [j] = 0.0f;  		right [j] = 0.0f;  	}  	break;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[2];  	float coeff_left = (float)(m_amplify_left / 64.0f);  	float coeff_right = (float)(m_amplify_right / 64.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  	}  } else {  	byte[] buf = new byte[1];  	float coeff_left = (float)(m_amplify_left / 64.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 1);  		if (ret < 1) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[2];  	float coeff_left = (float)(m_amplify_left / 64.0f);  	float coeff_right = (float)(m_amplify_right / 64.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  	}  } else {  	byte[] buf = new byte[1];  	float coeff_left = (float)(m_amplify_left / 64.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 1);  		if (ret < 1) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[2];  	float coeff_left = (float)(m_amplify_left / 64.0f);  	float coeff_right = (float)(m_amplify_right / 64.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  	}  } else {  	byte[] buf = new byte[1];  	float coeff_left = (float)(m_amplify_left / 64.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 1);  		if (ret < 1) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (m_channel == 2) {  	byte[] buf = new byte[2];  	float coeff_left = (float)(m_amplify_left / 64.0f);  	float coeff_right = (float)(m_amplify_right / 64.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 2);  		if (ret < 2) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  	}  } else {  	byte[] buf = new byte[1];  	float coeff_left = (float)(m_amplify_left / 64.0f);  	for (int i = 0; i < length; i++) {  		int ret = m_stream.read (buf' 0' 1);  		if (ret < 1) {  			for (int j = i; j < length; j++) {  				left [j] = 0.0f;  				right [j] = 0.0f;  			}  			break;  		}  		left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  		right [i] = left [i];  	}  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	int ret = m_stream.read (buf' 0' 2);  	if (ret < 2) {  		for (int j = i; j < length; j++) {  			left [j] = 0.0f;  			right [j] = 0.0f;  		}  		break;  	}  	left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  	right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	int ret = m_stream.read (buf' 0' 2);  	if (ret < 2) {  		for (int j = i; j < length; j++) {  			left [j] = 0.0f;  			right [j] = 0.0f;  		}  		break;  	}  	left [i] = ((0xff & buf [0]) - 64.0f) * coeff_left;  	right [i] = ((0xff & buf [1]) - 64.0f) * coeff_right;  }  
Magic Number,cadencii.media,WaveReader,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveReader.cs,read,The following statement contains a magic number: if (ret < 2) {  	for (int j = i; j < length; j++) {  		left [j] = 0.0f;  		right [j] = 0.0f;  	}  	break;  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,WaveWriter,The following statement contains a magic number: m_total_samples = (m_stream.length () - m_pos_data_chunk) / m_channel / (m_bit_per_sample / 8);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: if (streamLen < posFile) {  	// ファイルの長さが足りていない場合、とりあえず0で埋める。  	m_stream.seek (streamLen - 1);  	long remain = posFile - streamLen;  	int buflen = 1024;  	byte[] data = new byte[buflen];  	while (remain > 0) {  		int delta = remain > buflen ? buflen : (int)remain;  		m_stream.write (data' 0' delta);  		remain -= delta;  	}  	m_total_samples = pos;  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  		}  	} else {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  			m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  		}  	} else {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  			m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  		}  	} else {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  			m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  		}  	} else {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  			m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  		}  	} else {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  			m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  		}  	} else {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  			m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  		}  	} else {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  			m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  		}  	} else {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  			m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  		}  	} else {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  			m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  		}  	} else {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  			m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  		}  	} else {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  			m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < length; i++) {  		m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  	}  } else {  	for (int i = 0; i < length; i++) {  		m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  		m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < length; i++) {  		m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  	}  } else {  	for (int i = 0; i < length; i++) {  		m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  		m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < length; i++) {  		m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  	}  } else {  	for (int i = 0; i < length; i++) {  		m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  		m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < length; i++) {  		m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  	}  } else {  	for (int i = 0; i < length; i++) {  		m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  		m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  	m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  	m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < length; i++) {  		buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < length; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  		buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < length; i++) {  		buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < length; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  		buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < length; i++) {  		buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < length; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  		buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < length; i++) {  		buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < length; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  		buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < length; i++) {  		buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < length; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  		buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < length; i++) {  		buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < length; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  		buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: writeByteArray (m_stream' buf' 2);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  	writeByteArray (m_stream' buf' 2);  	buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  	writeByteArray (m_stream' buf' 2);  	buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  	writeByteArray (m_stream' buf' 2);  	buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  	writeByteArray (m_stream' buf' 2);  	buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: writeByteArray (m_stream' buf' 2);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,replace,The following statement contains a magic number: writeByteArray (m_stream' buf' 2);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,writeHeader,The following statement contains a magic number: writeByteArray (m_stream' buf' 4);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,writeHeader,The following statement contains a magic number: writeByteArray (m_stream' buf' 4);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,writeHeader,The following statement contains a magic number: writeByteArray (m_stream' buf' 2);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,writeHeader,The following statement contains a magic number: writeByteArray (m_stream' buf' 2);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,writeHeader,The following statement contains a magic number: writeByteArray (m_stream' buf' 4);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,close,The following statement contains a magic number: try {  	// 最後にWAVEチャンクのサイズ  	int position = (int)m_stream.getFilePointer ();  	m_stream.seek (4);  	byte[] buf = PortUtil.getbytes_uint32_le (position - 8);  	writeByteArray (m_stream' buf' 4);  	// size of data chunk  	int block_size = (int)(m_bit_per_sample / 8 * (int)m_channel);  	long size = block_size * m_total_samples;  	m_stream.seek (42);  	buf = PortUtil.getbytes_uint32_le (size);  	writeByteArray (m_stream' buf' 4);  	m_stream.close ();  } catch (Exception ex) {  	serr.println ("WaveWriter#close; ex=" + ex);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,close,The following statement contains a magic number: try {  	// 最後にWAVEチャンクのサイズ  	int position = (int)m_stream.getFilePointer ();  	m_stream.seek (4);  	byte[] buf = PortUtil.getbytes_uint32_le (position - 8);  	writeByteArray (m_stream' buf' 4);  	// size of data chunk  	int block_size = (int)(m_bit_per_sample / 8 * (int)m_channel);  	long size = block_size * m_total_samples;  	m_stream.seek (42);  	buf = PortUtil.getbytes_uint32_le (size);  	writeByteArray (m_stream' buf' 4);  	m_stream.close ();  } catch (Exception ex) {  	serr.println ("WaveWriter#close; ex=" + ex);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,close,The following statement contains a magic number: try {  	// 最後にWAVEチャンクのサイズ  	int position = (int)m_stream.getFilePointer ();  	m_stream.seek (4);  	byte[] buf = PortUtil.getbytes_uint32_le (position - 8);  	writeByteArray (m_stream' buf' 4);  	// size of data chunk  	int block_size = (int)(m_bit_per_sample / 8 * (int)m_channel);  	long size = block_size * m_total_samples;  	m_stream.seek (42);  	buf = PortUtil.getbytes_uint32_le (size);  	writeByteArray (m_stream' buf' 4);  	m_stream.close ();  } catch (Exception ex) {  	serr.println ("WaveWriter#close; ex=" + ex);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,close,The following statement contains a magic number: try {  	// 最後にWAVEチャンクのサイズ  	int position = (int)m_stream.getFilePointer ();  	m_stream.seek (4);  	byte[] buf = PortUtil.getbytes_uint32_le (position - 8);  	writeByteArray (m_stream' buf' 4);  	// size of data chunk  	int block_size = (int)(m_bit_per_sample / 8 * (int)m_channel);  	long size = block_size * m_total_samples;  	m_stream.seek (42);  	buf = PortUtil.getbytes_uint32_le (size);  	writeByteArray (m_stream' buf' 4);  	m_stream.close ();  } catch (Exception ex) {  	serr.println ("WaveWriter#close; ex=" + ex);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,close,The following statement contains a magic number: try {  	// 最後にWAVEチャンクのサイズ  	int position = (int)m_stream.getFilePointer ();  	m_stream.seek (4);  	byte[] buf = PortUtil.getbytes_uint32_le (position - 8);  	writeByteArray (m_stream' buf' 4);  	// size of data chunk  	int block_size = (int)(m_bit_per_sample / 8 * (int)m_channel);  	long size = block_size * m_total_samples;  	m_stream.seek (42);  	buf = PortUtil.getbytes_uint32_le (size);  	writeByteArray (m_stream' buf' 4);  	m_stream.close ();  } catch (Exception ex) {  	serr.println ("WaveWriter#close; ex=" + ex);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,close,The following statement contains a magic number: try {  	// 最後にWAVEチャンクのサイズ  	int position = (int)m_stream.getFilePointer ();  	m_stream.seek (4);  	byte[] buf = PortUtil.getbytes_uint32_le (position - 8);  	writeByteArray (m_stream' buf' 4);  	// size of data chunk  	int block_size = (int)(m_bit_per_sample / 8 * (int)m_channel);  	long size = block_size * m_total_samples;  	m_stream.seek (42);  	buf = PortUtil.getbytes_uint32_le (size);  	writeByteArray (m_stream' buf' 4);  	m_stream.close ();  } catch (Exception ex) {  	serr.println ("WaveWriter#close; ex=" + ex);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,close,The following statement contains a magic number: m_stream.seek (4);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,close,The following statement contains a magic number: writeByteArray (m_stream' buf' 4);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,close,The following statement contains a magic number: m_stream.seek (42);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,close,The following statement contains a magic number: writeByteArray (m_stream' buf' 4);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0f) * 127.5f));  		}  	} else {  		for (int i = 0; i < total; i++) {  			int b = (int)((L [i] + 1.0f) * 127.5f);  			m_stream.writeByte (b);  			m_stream.writeByte (b);  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768f));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768f));  			writeByteArray (m_stream' buf' 2);  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0f) * 127.5f));  		}  	} else {  		for (int i = 0; i < total; i++) {  			int b = (int)((L [i] + 1.0f) * 127.5f);  			m_stream.writeByte (b);  			m_stream.writeByte (b);  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768f));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768f));  			writeByteArray (m_stream' buf' 2);  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0f) * 127.5f));  		}  	} else {  		for (int i = 0; i < total; i++) {  			int b = (int)((L [i] + 1.0f) * 127.5f);  			m_stream.writeByte (b);  			m_stream.writeByte (b);  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768f));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768f));  			writeByteArray (m_stream' buf' 2);  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0f) * 127.5f));  		}  	} else {  		for (int i = 0; i < total; i++) {  			int b = (int)((L [i] + 1.0f) * 127.5f);  			m_stream.writeByte (b);  			m_stream.writeByte (b);  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768f));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768f));  			writeByteArray (m_stream' buf' 2);  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768f));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768f));  		writeByteArray (m_stream' buf' 2);  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768f));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768f));  		writeByteArray (m_stream' buf' 2);  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768f));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768f));  		writeByteArray (m_stream' buf' 2);  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < total; i++) {  	buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768f));  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: writeByteArray (m_stream' buf' 2);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < total; i++) {  	buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768f));  	writeByteArray (m_stream' buf' 2);  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < total; i++) {  	buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768f));  	writeByteArray (m_stream' buf' 2);  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: writeByteArray (m_stream' buf' 2);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: writeByteArray (m_stream' buf' 2);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  		}  	} else {  		for (int i = 0; i < total; i++) {  			int b = (int)((L [i] + 1.0) * 127.5);  			m_stream.writeByte (b);  			m_stream.writeByte (b);  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  		}  	} else {  		for (int i = 0; i < total; i++) {  			int b = (int)((L [i] + 1.0) * 127.5);  			m_stream.writeByte (b);  			m_stream.writeByte (b);  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  		}  	} else {  		for (int i = 0; i < total; i++) {  			int b = (int)((L [i] + 1.0) * 127.5);  			m_stream.writeByte (b);  			m_stream.writeByte (b);  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  		}  	} else {  		for (int i = 0; i < total; i++) {  			int b = (int)((L [i] + 1.0) * 127.5);  			m_stream.writeByte (b);  			m_stream.writeByte (b);  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  		}  	} else {  		for (int i = 0; i < total; i++) {  			int b = (int)((L [i] + 1.0) * 127.5);  			m_stream.writeByte (b);  			m_stream.writeByte (b);  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  		}  	} else {  		for (int i = 0; i < total; i++) {  			int b = (int)((L [i] + 1.0) * 127.5);  			m_stream.writeByte (b);  			m_stream.writeByte (b);  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  		}  	} else {  		for (int i = 0; i < total; i++) {  			int b = (int)((L [i] + 1.0) * 127.5);  			m_stream.writeByte (b);  			m_stream.writeByte (b);  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  		}  	} else {  		for (int i = 0; i < total; i++) {  			int b = (int)((L [i] + 1.0) * 127.5);  			m_stream.writeByte (b);  			m_stream.writeByte (b);  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < total; i++) {  		m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  	}  } else {  	for (int i = 0; i < total; i++) {  		int b = (int)((L [i] + 1.0) * 127.5);  		m_stream.writeByte (b);  		m_stream.writeByte (b);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < total; i++) {  		m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  	}  } else {  	for (int i = 0; i < total; i++) {  		int b = (int)((L [i] + 1.0) * 127.5);  		m_stream.writeByte (b);  		m_stream.writeByte (b);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < total; i++) {  	m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < total; i++) {  	int b = (int)((L [i] + 1.0) * 127.5);  	m_stream.writeByte (b);  	m_stream.writeByte (b);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < total; i++) {  	buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < total; i++) {  	buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: writeByteArray (m_stream' buf' 2);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < total; i++) {  	buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  	writeByteArray (m_stream' buf' 2);  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < total; i++) {  	buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  	writeByteArray (m_stream' buf' 2);  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < total; i++) {  	buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  	writeByteArray (m_stream' buf' 2);  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: writeByteArray (m_stream' buf' 2);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: writeByteArray (m_stream' buf' 2);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((byte)((L [i] + R [i] + 2.0f) * 63.75f));  		}  	} else {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((byte)((L [i] + 1.0f) * 127.5f));  			m_stream.writeByte ((byte)((R [i] + 1.0f) * 127.5f));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384f));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768f));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768f));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((byte)((L [i] + R [i] + 2.0f) * 63.75f));  		}  	} else {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((byte)((L [i] + 1.0f) * 127.5f));  			m_stream.writeByte ((byte)((R [i] + 1.0f) * 127.5f));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384f));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768f));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768f));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((byte)((L [i] + R [i] + 2.0f) * 63.75f));  		}  	} else {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((byte)((L [i] + 1.0f) * 127.5f));  			m_stream.writeByte ((byte)((R [i] + 1.0f) * 127.5f));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384f));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768f));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768f));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((byte)((L [i] + R [i] + 2.0f) * 63.75f));  		}  	} else {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((byte)((L [i] + 1.0f) * 127.5f));  			m_stream.writeByte ((byte)((R [i] + 1.0f) * 127.5f));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384f));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768f));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768f));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384f));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768f));  		writeByteArray (m_stream' buf' 2);  		buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768f));  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384f));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768f));  		writeByteArray (m_stream' buf' 2);  		buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768f));  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384f));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768f));  		writeByteArray (m_stream' buf' 2);  		buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768f));  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < total; i++) {  	buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384f));  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: writeByteArray (m_stream' buf' 2);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < total; i++) {  	buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768f));  	writeByteArray (m_stream' buf' 2);  	buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768f));  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < total; i++) {  	buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768f));  	writeByteArray (m_stream' buf' 2);  	buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768f));  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: writeByteArray (m_stream' buf' 2);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: writeByteArray (m_stream' buf' 2);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: try {  	if (m_bit_per_sample == 8) {  		if (m_channel == 1) {  			for (int i = 0; i < length; i++) {  				m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  			}  		} else {  			for (int i = 0; i < length; i++) {  				m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  				m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  			}  		}  	} else {  		byte[] buf;  		if (m_channel == 1) {  			for (int i = 0; i < length; i++) {  				buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  				writeByteArray (m_stream' buf' 2);  			}  		} else {  			for (int i = 0; i < length; i++) {  				buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  				writeByteArray (m_stream' buf' 2);  				buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  				writeByteArray (m_stream' buf' 2);  			}  		}  	}  	m_total_samples += (int)length;  } catch (Exception ex) {  	serr.println ("WaveWriter#append(double[]'double[]'int); ex=" + ex);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: try {  	if (m_bit_per_sample == 8) {  		if (m_channel == 1) {  			for (int i = 0; i < length; i++) {  				m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  			}  		} else {  			for (int i = 0; i < length; i++) {  				m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  				m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  			}  		}  	} else {  		byte[] buf;  		if (m_channel == 1) {  			for (int i = 0; i < length; i++) {  				buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  				writeByteArray (m_stream' buf' 2);  			}  		} else {  			for (int i = 0; i < length; i++) {  				buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  				writeByteArray (m_stream' buf' 2);  				buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  				writeByteArray (m_stream' buf' 2);  			}  		}  	}  	m_total_samples += (int)length;  } catch (Exception ex) {  	serr.println ("WaveWriter#append(double[]'double[]'int); ex=" + ex);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: try {  	if (m_bit_per_sample == 8) {  		if (m_channel == 1) {  			for (int i = 0; i < length; i++) {  				m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  			}  		} else {  			for (int i = 0; i < length; i++) {  				m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  				m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  			}  		}  	} else {  		byte[] buf;  		if (m_channel == 1) {  			for (int i = 0; i < length; i++) {  				buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  				writeByteArray (m_stream' buf' 2);  			}  		} else {  			for (int i = 0; i < length; i++) {  				buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  				writeByteArray (m_stream' buf' 2);  				buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  				writeByteArray (m_stream' buf' 2);  			}  		}  	}  	m_total_samples += (int)length;  } catch (Exception ex) {  	serr.println ("WaveWriter#append(double[]'double[]'int); ex=" + ex);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: try {  	if (m_bit_per_sample == 8) {  		if (m_channel == 1) {  			for (int i = 0; i < length; i++) {  				m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  			}  		} else {  			for (int i = 0; i < length; i++) {  				m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  				m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  			}  		}  	} else {  		byte[] buf;  		if (m_channel == 1) {  			for (int i = 0; i < length; i++) {  				buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  				writeByteArray (m_stream' buf' 2);  			}  		} else {  			for (int i = 0; i < length; i++) {  				buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  				writeByteArray (m_stream' buf' 2);  				buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  				writeByteArray (m_stream' buf' 2);  			}  		}  	}  	m_total_samples += (int)length;  } catch (Exception ex) {  	serr.println ("WaveWriter#append(double[]'double[]'int); ex=" + ex);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: try {  	if (m_bit_per_sample == 8) {  		if (m_channel == 1) {  			for (int i = 0; i < length; i++) {  				m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  			}  		} else {  			for (int i = 0; i < length; i++) {  				m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  				m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  			}  		}  	} else {  		byte[] buf;  		if (m_channel == 1) {  			for (int i = 0; i < length; i++) {  				buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  				writeByteArray (m_stream' buf' 2);  			}  		} else {  			for (int i = 0; i < length; i++) {  				buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  				writeByteArray (m_stream' buf' 2);  				buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  				writeByteArray (m_stream' buf' 2);  			}  		}  	}  	m_total_samples += (int)length;  } catch (Exception ex) {  	serr.println ("WaveWriter#append(double[]'double[]'int); ex=" + ex);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: try {  	if (m_bit_per_sample == 8) {  		if (m_channel == 1) {  			for (int i = 0; i < length; i++) {  				m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  			}  		} else {  			for (int i = 0; i < length; i++) {  				m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  				m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  			}  		}  	} else {  		byte[] buf;  		if (m_channel == 1) {  			for (int i = 0; i < length; i++) {  				buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  				writeByteArray (m_stream' buf' 2);  			}  		} else {  			for (int i = 0; i < length; i++) {  				buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  				writeByteArray (m_stream' buf' 2);  				buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  				writeByteArray (m_stream' buf' 2);  			}  		}  	}  	m_total_samples += (int)length;  } catch (Exception ex) {  	serr.println ("WaveWriter#append(double[]'double[]'int); ex=" + ex);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: try {  	if (m_bit_per_sample == 8) {  		if (m_channel == 1) {  			for (int i = 0; i < length; i++) {  				m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  			}  		} else {  			for (int i = 0; i < length; i++) {  				m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  				m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  			}  		}  	} else {  		byte[] buf;  		if (m_channel == 1) {  			for (int i = 0; i < length; i++) {  				buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  				writeByteArray (m_stream' buf' 2);  			}  		} else {  			for (int i = 0; i < length; i++) {  				buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  				writeByteArray (m_stream' buf' 2);  				buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  				writeByteArray (m_stream' buf' 2);  			}  		}  	}  	m_total_samples += (int)length;  } catch (Exception ex) {  	serr.println ("WaveWriter#append(double[]'double[]'int); ex=" + ex);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: try {  	if (m_bit_per_sample == 8) {  		if (m_channel == 1) {  			for (int i = 0; i < length; i++) {  				m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  			}  		} else {  			for (int i = 0; i < length; i++) {  				m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  				m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  			}  		}  	} else {  		byte[] buf;  		if (m_channel == 1) {  			for (int i = 0; i < length; i++) {  				buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  				writeByteArray (m_stream' buf' 2);  			}  		} else {  			for (int i = 0; i < length; i++) {  				buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  				writeByteArray (m_stream' buf' 2);  				buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  				writeByteArray (m_stream' buf' 2);  			}  		}  	}  	m_total_samples += (int)length;  } catch (Exception ex) {  	serr.println ("WaveWriter#append(double[]'double[]'int); ex=" + ex);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: try {  	if (m_bit_per_sample == 8) {  		if (m_channel == 1) {  			for (int i = 0; i < length; i++) {  				m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  			}  		} else {  			for (int i = 0; i < length; i++) {  				m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  				m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  			}  		}  	} else {  		byte[] buf;  		if (m_channel == 1) {  			for (int i = 0; i < length; i++) {  				buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  				writeByteArray (m_stream' buf' 2);  			}  		} else {  			for (int i = 0; i < length; i++) {  				buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  				writeByteArray (m_stream' buf' 2);  				buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  				writeByteArray (m_stream' buf' 2);  			}  		}  	}  	m_total_samples += (int)length;  } catch (Exception ex) {  	serr.println ("WaveWriter#append(double[]'double[]'int); ex=" + ex);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: try {  	if (m_bit_per_sample == 8) {  		if (m_channel == 1) {  			for (int i = 0; i < length; i++) {  				m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  			}  		} else {  			for (int i = 0; i < length; i++) {  				m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  				m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  			}  		}  	} else {  		byte[] buf;  		if (m_channel == 1) {  			for (int i = 0; i < length; i++) {  				buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  				writeByteArray (m_stream' buf' 2);  			}  		} else {  			for (int i = 0; i < length; i++) {  				buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  				writeByteArray (m_stream' buf' 2);  				buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  				writeByteArray (m_stream' buf' 2);  			}  		}  	}  	m_total_samples += (int)length;  } catch (Exception ex) {  	serr.println ("WaveWriter#append(double[]'double[]'int); ex=" + ex);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: try {  	if (m_bit_per_sample == 8) {  		if (m_channel == 1) {  			for (int i = 0; i < length; i++) {  				m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  			}  		} else {  			for (int i = 0; i < length; i++) {  				m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  				m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  			}  		}  	} else {  		byte[] buf;  		if (m_channel == 1) {  			for (int i = 0; i < length; i++) {  				buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  				writeByteArray (m_stream' buf' 2);  			}  		} else {  			for (int i = 0; i < length; i++) {  				buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  				writeByteArray (m_stream' buf' 2);  				buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  				writeByteArray (m_stream' buf' 2);  			}  		}  	}  	m_total_samples += (int)length;  } catch (Exception ex) {  	serr.println ("WaveWriter#append(double[]'double[]'int); ex=" + ex);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  		}  	} else {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  			m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  		}  	} else {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  			m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  		}  	} else {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  			m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  		}  	} else {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  			m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  		}  	} else {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  			m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  		}  	} else {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  			m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  		}  	} else {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  			m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  		}  	} else {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  			m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  		}  	} else {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  			m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  		}  	} else {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  			m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  		}  	} else {  		for (int i = 0; i < length; i++) {  			m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  			m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < length; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < length; i++) {  		m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  	}  } else {  	for (int i = 0; i < length; i++) {  		m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  		m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < length; i++) {  		m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  	}  } else {  	for (int i = 0; i < length; i++) {  		m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  		m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < length; i++) {  		m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  	}  } else {  	for (int i = 0; i < length; i++) {  		m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  		m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < length; i++) {  		m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  	}  } else {  	for (int i = 0; i < length; i++) {  		m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  		m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: m_stream.writeByte ((int)((L [i] + R [i] + 2.0) * 63.75));  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  	m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  	m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: m_stream.writeByte ((int)((L [i] + 1.0) * 127.5));  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: m_stream.writeByte ((int)((R [i] + 1.0) * 127.5));  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < length; i++) {  		buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < length; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  		buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < length; i++) {  		buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < length; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  		buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < length; i++) {  		buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < length; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  		buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < length; i++) {  		buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < length; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  		buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < length; i++) {  		buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < length; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  		buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < length; i++) {  		buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < length; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  		buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 16384.0));  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: writeByteArray (m_stream' buf' 2);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  	writeByteArray (m_stream' buf' 2);  	buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  	writeByteArray (m_stream' buf' 2);  	buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  	writeByteArray (m_stream' buf' 2);  	buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  	writeByteArray (m_stream' buf' 2);  	buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: buf = PortUtil.getbytes_int16_le ((short)(L [i] * 32768.0));  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: writeByteArray (m_stream' buf' 2);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: buf = PortUtil.getbytes_int16_le ((short)(R [i] * 32768.0));  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: writeByteArray (m_stream' buf' 2);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte (0xff & ((L [i] + R [i]) / 2));  		}  	} else {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte (0xff & L [i]);  			m_stream.writeByte (0xff & R [i]);  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 128.5f - 32768f));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 257f - 32768f));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 257f - 32768f));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte (0xff & ((L [i] + R [i]) / 2));  		}  	} else {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte (0xff & L [i]);  			m_stream.writeByte (0xff & R [i]);  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 128.5f - 32768f));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 257f - 32768f));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 257f - 32768f));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte (0xff & ((L [i] + R [i]) / 2));  		}  	} else {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte (0xff & L [i]);  			m_stream.writeByte (0xff & R [i]);  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 128.5f - 32768f));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 257f - 32768f));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 257f - 32768f));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte (0xff & ((L [i] + R [i]) / 2));  		}  	} else {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte (0xff & L [i]);  			m_stream.writeByte (0xff & R [i]);  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 128.5f - 32768f));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 257f - 32768f));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 257f - 32768f));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte (0xff & ((L [i] + R [i]) / 2));  		}  	} else {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte (0xff & L [i]);  			m_stream.writeByte (0xff & R [i]);  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 128.5f - 32768f));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)(L [i] * 257f - 32768f));  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le ((short)(R [i] * 257f - 32768f));  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < total; i++) {  		m_stream.writeByte (0xff & ((L [i] + R [i]) / 2));  	}  } else {  	for (int i = 0; i < total; i++) {  		m_stream.writeByte (0xff & L [i]);  		m_stream.writeByte (0xff & R [i]);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < total; i++) {  	m_stream.writeByte (0xff & ((L [i] + R [i]) / 2));  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: m_stream.writeByte (0xff & ((L [i] + R [i]) / 2));  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 128.5f - 32768f));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 257f - 32768f));  		writeByteArray (m_stream' buf' 2);  		buf = PortUtil.getbytes_int16_le ((short)(R [i] * 257f - 32768f));  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 128.5f - 32768f));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 257f - 32768f));  		writeByteArray (m_stream' buf' 2);  		buf = PortUtil.getbytes_int16_le ((short)(R [i] * 257f - 32768f));  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 128.5f - 32768f));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)(L [i] * 257f - 32768f));  		writeByteArray (m_stream' buf' 2);  		buf = PortUtil.getbytes_int16_le ((short)(R [i] * 257f - 32768f));  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < total; i++) {  	buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) * 128.5f - 32768f));  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: writeByteArray (m_stream' buf' 2);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < total; i++) {  	buf = PortUtil.getbytes_int16_le ((short)(L [i] * 257f - 32768f));  	writeByteArray (m_stream' buf' 2);  	buf = PortUtil.getbytes_int16_le ((short)(R [i] * 257f - 32768f));  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < total; i++) {  	buf = PortUtil.getbytes_int16_le ((short)(L [i] * 257f - 32768f));  	writeByteArray (m_stream' buf' 2);  	buf = PortUtil.getbytes_int16_le ((short)(R [i] * 257f - 32768f));  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: writeByteArray (m_stream' buf' 2);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: writeByteArray (m_stream' buf' 2);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((int)(((L [i] + R [i]) / 2f + 32768f) / 255f));  		}  	} else {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((int)((L [i] + 32768f) / 255f));  			m_stream.writeByte ((int)((R [i] + 32768f) / 255f));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) / 2));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le (L [i]);  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le (R [i]);  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((int)(((L [i] + R [i]) / 2f + 32768f) / 255f));  		}  	} else {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((int)((L [i] + 32768f) / 255f));  			m_stream.writeByte ((int)((R [i] + 32768f) / 255f));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) / 2));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le (L [i]);  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le (R [i]);  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((int)(((L [i] + R [i]) / 2f + 32768f) / 255f));  		}  	} else {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((int)((L [i] + 32768f) / 255f));  			m_stream.writeByte ((int)((R [i] + 32768f) / 255f));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) / 2));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le (L [i]);  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le (R [i]);  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((int)(((L [i] + R [i]) / 2f + 32768f) / 255f));  		}  	} else {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((int)((L [i] + 32768f) / 255f));  			m_stream.writeByte ((int)((R [i] + 32768f) / 255f));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) / 2));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le (L [i]);  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le (R [i]);  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_bit_per_sample == 8) {  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((int)(((L [i] + R [i]) / 2f + 32768f) / 255f));  		}  	} else {  		for (int i = 0; i < total; i++) {  			m_stream.writeByte ((int)((L [i] + 32768f) / 255f));  			m_stream.writeByte ((int)((R [i] + 32768f) / 255f));  		}  	}  } else {  	byte[] buf;  	if (m_channel == 1) {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) / 2));  			writeByteArray (m_stream' buf' 2);  		}  	} else {  		for (int i = 0; i < total; i++) {  			buf = PortUtil.getbytes_int16_le (L [i]);  			writeByteArray (m_stream' buf' 2);  			buf = PortUtil.getbytes_int16_le (R [i]);  			writeByteArray (m_stream' buf' 2);  		}  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) / 2));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le (L [i]);  		writeByteArray (m_stream' buf' 2);  		buf = PortUtil.getbytes_int16_le (R [i]);  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) / 2));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le (L [i]);  		writeByteArray (m_stream' buf' 2);  		buf = PortUtil.getbytes_int16_le (R [i]);  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) / 2));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le (L [i]);  		writeByteArray (m_stream' buf' 2);  		buf = PortUtil.getbytes_int16_le (R [i]);  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: if (m_channel == 1) {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) / 2));  		writeByteArray (m_stream' buf' 2);  	}  } else {  	for (int i = 0; i < total; i++) {  		buf = PortUtil.getbytes_int16_le (L [i]);  		writeByteArray (m_stream' buf' 2);  		buf = PortUtil.getbytes_int16_le (R [i]);  		writeByteArray (m_stream' buf' 2);  	}  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < total; i++) {  	buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) / 2));  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < total; i++) {  	buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) / 2));  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: buf = PortUtil.getbytes_int16_le ((short)((L [i] + R [i]) / 2));  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: writeByteArray (m_stream' buf' 2);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < total; i++) {  	buf = PortUtil.getbytes_int16_le (L [i]);  	writeByteArray (m_stream' buf' 2);  	buf = PortUtil.getbytes_int16_le (R [i]);  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: for (int i = 0; i < total; i++) {  	buf = PortUtil.getbytes_int16_le (L [i]);  	writeByteArray (m_stream' buf' 2);  	buf = PortUtil.getbytes_int16_le (R [i]);  	writeByteArray (m_stream' buf' 2);  }  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: writeByteArray (m_stream' buf' 2);  
Magic Number,cadencii.media,WaveWriter,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\WaveWriter.cs,append,The following statement contains a magic number: writeByteArray (m_stream' buf' 2);  
Magic Number,cadencii.media.impl,PlaySound,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PlaySound.cs,SoundGetPosition,The following statement contains a magic number: switch (mmt.wType) {  case win32.TIME_MS:  	return mmt.ms * 0.001;  case win32.TIME_SAMPLES:  	return (double)mmt.sample / (double)wave_format.nSamplesPerSec;  case win32.TIME_BYTES:  	return (double)mmt.cb / (double)wave_format.nAvgBytesPerSec;  default:  	return -1.0;  }  
Magic Number,cadencii.media.impl,PlaySound,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PlaySound.cs,SoundGetPosition,The following statement contains a magic number: return mmt.ms * 0.001;  
Magic Number,cadencii.media.impl,PlaySound,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PlaySound.cs,SoundAppend,The following statement contains a magic number: while (appended < length) {  	// このループ内では、バッファに1個づつデータを転送する  	// バッファが使用中の場合、使用終了となるのを待ち受ける  	int act_buffer_index = buffer_index % NUM_BUF;  	while (!wave_done [act_buffer_index] && !abort_required) {  		System.Threading.Thread.Sleep (0);  	}  	int t_length = block_size_used - buffer_loc;  	// 転送するデータの個数  	if (t_length > length - appended) {  		t_length = length - appended;  	}  	for (int i = 0; i < t_length && !abort_required; i++) {  		wave [act_buffer_index] [buffer_loc + i] = (uint)win32.MAKELONG ((WORD)(left [appended + i] * 32768.0)' (WORD)(right [appended + i] * 32768.0));  	}  	appended += t_length;  	buffer_loc += t_length;  	if (buffer_loc == block_size_used) {  		// バッファがいっぱいになったようだ  		buffer_index++;  		buffer_loc = 0;  		if (buffer_index >= NUM_BUF) {  			// 最初のNUM_BUF個のバッファは、すべてのバッファに転送が終わるまで  			// waveOutWriteしないようにしているので、ここでwaveOutWriteする。  			if (buffer_index == NUM_BUF) {  				for (int i = 0; i < NUM_BUF; i++) {  					if (abort_required)  						break;  					wave_done [i] = false;  					win32.waveOutWrite (wave_out' ref wave_header [i]' (uint)sizeof(WAVEHDR));  				}  			} else {  				wave_done [act_buffer_index] = false;  				if (!abort_required) {  					win32.waveOutWrite (wave_out' ref wave_header [act_buffer_index]' (uint)sizeof(WAVEHDR));  				}  			}  		}  	}  }  
Magic Number,cadencii.media.impl,PlaySound,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PlaySound.cs,SoundAppend,The following statement contains a magic number: while (appended < length) {  	// このループ内では、バッファに1個づつデータを転送する  	// バッファが使用中の場合、使用終了となるのを待ち受ける  	int act_buffer_index = buffer_index % NUM_BUF;  	while (!wave_done [act_buffer_index] && !abort_required) {  		System.Threading.Thread.Sleep (0);  	}  	int t_length = block_size_used - buffer_loc;  	// 転送するデータの個数  	if (t_length > length - appended) {  		t_length = length - appended;  	}  	for (int i = 0; i < t_length && !abort_required; i++) {  		wave [act_buffer_index] [buffer_loc + i] = (uint)win32.MAKELONG ((WORD)(left [appended + i] * 32768.0)' (WORD)(right [appended + i] * 32768.0));  	}  	appended += t_length;  	buffer_loc += t_length;  	if (buffer_loc == block_size_used) {  		// バッファがいっぱいになったようだ  		buffer_index++;  		buffer_loc = 0;  		if (buffer_index >= NUM_BUF) {  			// 最初のNUM_BUF個のバッファは、すべてのバッファに転送が終わるまで  			// waveOutWriteしないようにしているので、ここでwaveOutWriteする。  			if (buffer_index == NUM_BUF) {  				for (int i = 0; i < NUM_BUF; i++) {  					if (abort_required)  						break;  					wave_done [i] = false;  					win32.waveOutWrite (wave_out' ref wave_header [i]' (uint)sizeof(WAVEHDR));  				}  			} else {  				wave_done [act_buffer_index] = false;  				if (!abort_required) {  					win32.waveOutWrite (wave_out' ref wave_header [act_buffer_index]' (uint)sizeof(WAVEHDR));  				}  			}  		}  	}  }  
Magic Number,cadencii.media.impl,PlaySound,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PlaySound.cs,SoundAppend,The following statement contains a magic number: for (int i = 0; i < t_length && !abort_required; i++) {  	wave [act_buffer_index] [buffer_loc + i] = (uint)win32.MAKELONG ((WORD)(left [appended + i] * 32768.0)' (WORD)(right [appended + i] * 32768.0));  }  
Magic Number,cadencii.media.impl,PlaySound,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PlaySound.cs,SoundAppend,The following statement contains a magic number: for (int i = 0; i < t_length && !abort_required; i++) {  	wave [act_buffer_index] [buffer_loc + i] = (uint)win32.MAKELONG ((WORD)(left [appended + i] * 32768.0)' (WORD)(right [appended + i] * 32768.0));  }  
Magic Number,cadencii.media.impl,PlaySound,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PlaySound.cs,SoundAppend,The following statement contains a magic number: wave [act_buffer_index] [buffer_loc + i] = (uint)win32.MAKELONG ((WORD)(left [appended + i] * 32768.0)' (WORD)(right [appended + i] * 32768.0));  
Magic Number,cadencii.media.impl,PlaySound,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PlaySound.cs,SoundAppend,The following statement contains a magic number: wave [act_buffer_index] [buffer_loc + i] = (uint)win32.MAKELONG ((WORD)(left [appended + i] * 32768.0)' (WORD)(right [appended + i] * 32768.0));  
Magic Number,cadencii.media.impl,PlaySound,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PlaySound.cs,SoundPrepare,The following statement contains a magic number: wave_format.nChannels = 2;  
Magic Number,cadencii.media.impl,PlaySound,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PlaySound.cs,SoundPrepare,The following statement contains a magic number: wave_format.wBitsPerSample = 16;  
Magic Number,cadencii.media.impl,PlaySound,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\PlaySound.cs,SoundPrepare,The following statement contains a magic number: wave_format.nBlockAlign = (ushort)(wave_format.nChannels * wave_format.wBitsPerSample / 8);  
Duplicate Code,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,RequireAudioCompressOption,The method contains a code clone-set at the following line numbers (starting from the method definition): ((48' 67)' (49' 68)' (50' 69)' (51' 70)' (52' 71)' (53' 72)' (54' 73)' (55' 74)' (56' 75)' (57' 76)' (58' 77)' (59' 78)' (60' 79)' (61' 80)' (62' 81)' (63' 82)' (64' 83)' (65' 84)' (66' 85)' (67' 86)' (68' 87)' (69' 88)' (70' 89)' (71' 90)' (72' 91)' (73' 92)' (74' 93)' (75' 94)' (76' 95)' (77' 96)' (78' 97)' (79' 98)' (80' 99)' (81' 100)' (82' 101)' (83' 102)' (84' 103)' (85' 104)' (86' 105))
Duplicate Code,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,RequireAudioCompressOption,The method contains a code clone-set at the following line numbers (starting from the method definition): ((48' 104)' (49' 105))
Duplicate Code,cadencii.media,AviWriterVfw,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\AviWriterVfw.cs,RequireAudioCompressOption,The method contains a code clone-set at the following line numbers (starting from the method definition): ((48' 67)' (50' 69)' (51' 70)' (52' 71)' (53' 72)' (54' 73)' (55' 74)' (56' 75)' (57' 76)' (58' 77)' (59' 78)' (60' 79)' (61' 80)' (62' 81)' (63' 82)' (64' 83)' (65' 84)' (66' 85)' (67' 86)' (68' 87)' (69' 88)' (70' 89)' (71' 90)' (72' 91)' (73' 92)' (74' 93)' (75' 94)' (76' 95)' (77' 96)' (78' 97)' (79' 98)' (80' 99)' (81' 100)' (82' 101)' (83' 102)' (84' 103)' (85' 104)' (86' 105))
Missing Default,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following switch statement is missing a default case: switch (wMsg) {  case win32.MM_MIM_OPEN: {  	return;  }  case win32.MM_MIM_CLOSE: {  	return;  }  case win32.MM_MIM_DATA: {  	int receive = dwParam1;  	double now = PortUtil.getCurrentTime ();  	switch (receive & 0xF0) {  	case 0x80:  	case 0x90:  	case 0xa0:  	case 0xb0:  	case 0xe0: {  		if (MidiReceived != null) {  			javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  				(byte)(receive & 0xff)'  				(byte)((receive & 0xffff) >> 8)'  				(byte)((receive & ((2 << 24) - 1)) >> 16)  			});  			MidiReceived.Invoke (this' msg);  		}  		break;  	}  	case 0xc0:  	case 0xd0: {  		if (MidiReceived != null) {  			javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  				(byte)(receive & 0xff)'  				(byte)((receive & 0xffff) >> 8)  			});  			MidiReceived.Invoke (this' msg);  		}  		break;  	}  	case 0xf0: {  		if (mReceiveSystemCommonMessage) {  			byte b0 = (byte)(receive & 0xff);  			byte b1 = (byte)((receive >> 8) & 0xff);  			byte b2 = (byte)((receive >> 16) & 0xff);  			byte b3 = (byte)((receive >> 24) & 0xff);  			if (b0 == 0xf1) {  				// MTC quater frame message  				if (MidiReceived != null) {  					javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  						b0'  						b1'  						b2  					});  					MidiReceived.Invoke (this' msg);  				}  			} else if (b0 == 0xf2) {  				// song position pointer  				#if DEBUG  				                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  			}  		}  		if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  			byte b0 = (byte)(receive & 0xff);  			byte b1 = (byte)((receive >> 8) & 0xff);  			byte b2 = (byte)((receive >> 16) & 0xff);  			byte b3 = (byte)((receive >> 24) & 0xff);  			if (b0 == 0xfa) {  				MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  					b0  				}));  			} else if (b0 == 0xfc) {  				MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  					b0  				}));  			}  		}  		break;  	}  	}  	return;  }  case win32.MM_MIM_LONGDATA: {  	return;  }  case win32.MM_MIM_ERROR: {  	return;  }  case win32.MM_MIM_LONGERROR: {  	return;  }  }  
Missing Default,cadencii.media,MidiInDevice,D:\newReposJune17\cadencii_cadencii\src\cadencii.media\MidiInDevice.cs,MidiInProc,The following switch statement is missing a default case: switch (receive & 0xF0) {  case 0x80:  case 0x90:  case 0xa0:  case 0xb0:  case 0xe0: {  	if (MidiReceived != null) {  		javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  			(byte)(receive & 0xff)'  			(byte)((receive & 0xffff) >> 8)'  			(byte)((receive & ((2 << 24) - 1)) >> 16)  		});  		MidiReceived.Invoke (this' msg);  	}  	break;  }  case 0xc0:  case 0xd0: {  	if (MidiReceived != null) {  		javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  			(byte)(receive & 0xff)'  			(byte)((receive & 0xffff) >> 8)  		});  		MidiReceived.Invoke (this' msg);  	}  	break;  }  case 0xf0: {  	if (mReceiveSystemCommonMessage) {  		byte b0 = (byte)(receive & 0xff);  		byte b1 = (byte)((receive >> 8) & 0xff);  		byte b2 = (byte)((receive >> 16) & 0xff);  		byte b3 = (byte)((receive >> 24) & 0xff);  		if (b0 == 0xf1) {  			// MTC quater frame message  			if (MidiReceived != null) {  				javax.sound.midi.MidiMessage msg = new cadencii.javax.sound.midi.MidiMessage (new byte[] {  					b0'  					b1'  					b2  				});  				MidiReceived.Invoke (this' msg);  			}  		} else if (b0 == 0xf2) {  			// song position pointer  			#if DEBUG  			                                        sout.println( "MidiInDeviceMidiInProc; 0xf2; b0=" + PortUtil.toHexString( b0' 2 ) + "; b1=" + PortUtil.toHexString( b1' 2 ) + "; b2=" + PortUtil.toHexString( b2' 2 ) ); #endif  		}  	}  	if (mReceiveSystemRealtimeMessage && MidiReceived != null) {  		byte b0 = (byte)(receive & 0xff);  		byte b1 = (byte)((receive >> 8) & 0xff);  		byte b2 = (byte)((receive >> 16) & 0xff);  		byte b3 = (byte)((receive >> 24) & 0xff);  		if (b0 == 0xfa) {  			MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  				b0  			}));  		} else if (b0 == 0xfc) {  			MidiReceived.Invoke (this' new javax.sound.midi.MidiMessage (new byte[] {  				b0  			}));  		}  	}  	break;  }  }  
