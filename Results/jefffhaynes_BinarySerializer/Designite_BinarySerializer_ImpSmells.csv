Implementation smell,Namespace,Class,File,Method,Description
Long Method,BinarySerialization.Graph.TypeGraph,TypeNode,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Graph\TypeGraph\TypeNode.cs,TypeNode,The method has 178 lines of code.
Long Method,BinarySerialization.Graph.ValueGraph,ValueValueNode,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Graph\ValueGraph\ValueValueNode.cs,Serialize,The method has 130 lines of code.
Long Method,BinarySerialization.Graph.ValueGraph,ValueValueNode,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Graph\ValueGraph\ValueValueNode.cs,SerializeAsync,The method has 123 lines of code.
Complex Method,BinarySerialization.Graph.TypeGraph,ContainerTypeNode,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Graph\TypeGraph\ContainerTypeNode.cs,GetNodeType,Cyclomatic complexity of the method is 8
Complex Method,BinarySerialization.Graph.TypeGraph,TypeNode,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Graph\TypeGraph\TypeNode.cs,TypeNode,Cyclomatic complexity of the method is 22
Complex Method,BinarySerialization.Graph.ValueGraph,ObjectValueNode,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Graph\ValueGraph\ObjectValueNode.cs,GetValue,Cyclomatic complexity of the method is 8
Complex Method,BinarySerialization.Graph.ValueGraph,ValueNode,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Graph\ValueGraph\ValueNode.cs,SubtypeBindingCallback,Cyclomatic complexity of the method is 8
Complex Method,BinarySerialization.Graph.ValueGraph,ValueNode,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Graph\ValueGraph\ValueNode.cs,ItemSubtypeBindingCallback,Cyclomatic complexity of the method is 8
Long Parameter List,BinarySerialization,BinarySerializationContext,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\BinarySerializationContext.cs,BinarySerializationContext,The method has 5 parameters. Parameters: value' parentValue' parentType' parentContext' memberInfo
Long Parameter List,BinarySerialization,BindingInfo,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\BindingInfo.cs,BindingInfo,The method has 5 parameters. Parameters: path' bindingMode' relativeSourceMode' converterType' converterParameter
Long Parameter List,BinarySerialization,EventShuttle,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\EventShuttle.cs,OnMemberSerialized,The method has 6 parameters. Parameters: sender' name' value' context' offset' localOffset
Long Parameter List,BinarySerialization,EventShuttle,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\EventShuttle.cs,OnMemberDeserialized,The method has 6 parameters. Parameters: sender' name' value' context' offset' localOffset
Long Parameter List,BinarySerialization,EventShuttle,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\EventShuttle.cs,OnMemberSerializing,The method has 5 parameters. Parameters: sender' name' context' offset' localOffset
Long Parameter List,BinarySerialization,EventShuttle,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\EventShuttle.cs,OnMemberDeserializing,The method has 5 parameters. Parameters: sender' name' context' offset' localOffset
Long Parameter List,BinarySerialization,MemberSerializedEventArgs,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\MemberSerializedEventArgs.cs,MemberSerializedEventArgs,The method has 5 parameters. Parameters: memberName' value' context' offset' localOffset
Long Parameter List,BinarySerialization.Graph.ValueGraph,ObjectValueNode,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Graph\ValueGraph\ObjectValueNode.cs,SetValueType,The method has 6 parameters. Parameters: bindings' bindingTarget' attributes' subtypeFactoryBinding' subtypeFactory' defaultAttribute
Long Parameter List,BinarySerialization.Graph.ValueGraph,PrimitiveCollectionValueNode,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Graph\ValueGraph\PrimitiveCollectionValueNode.cs,PrimitiveCollectionSerializeOverride,The method has 6 parameters. Parameters: stream' boundValue' childSerializer' childSerializedType' itemLength' itemCount
Long Parameter List,BinarySerialization.Graph.ValueGraph,PrimitiveCollectionValueNode,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Graph\ValueGraph\PrimitiveCollectionValueNode.cs,PrimitiveCollectionSerializeOverrideAsync,The method has 7 parameters. Parameters: stream' boundValue' childSerializer' childSerializedType' itemLength' itemCount' cancellationToken
Long Parameter List,BinarySerialization.Graph.ValueGraph,PrimitiveListValueNode,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Graph\ValueGraph\PrimitiveListValueNode.cs,PrimitiveCollectionSerializeOverride,The method has 6 parameters. Parameters: stream' boundValue' childSerializer' childSerializedType' itemLength' itemCount
Long Parameter List,BinarySerialization.Graph.ValueGraph,PrimitiveListValueNode,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Graph\ValueGraph\PrimitiveListValueNode.cs,PrimitiveCollectionSerializeOverrideAsync,The method has 7 parameters. Parameters: stream' boundValue' childSerializer' childSerializedType' itemLength' itemCount' cancellationToken
Long Parameter List,BinarySerialization.Graph.ValueGraph,PrimitveArrayValueNode,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Graph\ValueGraph\PrimitveArrayValueNode.cs,PrimitiveCollectionSerializeOverride,The method has 6 parameters. Parameters: stream' boundValue' childSerializer' childSerializedType' itemLength' itemCount
Long Parameter List,BinarySerialization.Graph.ValueGraph,PrimitveArrayValueNode,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Graph\ValueGraph\PrimitveArrayValueNode.cs,PrimitiveCollectionSerializeOverrideAsync,The method has 7 parameters. Parameters: stream' boundValue' childSerializer' childSerializedType' itemLength' itemCount' cancellationToken
Long Parameter List,BinarySerialization.Graph.ValueGraph,ValueValueNode,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Graph\ValueGraph\ValueValueNode.cs,SerializeAsync,The method has 5 parameters. Parameters: stream' value' serializedType' length' cancellationToken
Long Parameter List,BinarySerialization.Graph.ValueGraph,ValueValueNode,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Graph\ValueGraph\ValueValueNode.cs,SerializeAsync,The method has 5 parameters. Parameters: writer' value' serializedType' length' cancellationToken
Long Statement,BinarySerialization.Graph.TypeGraph,TypeNode,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Graph\TypeGraph\TypeNode.cs,GetBindings,The length of the statement  "                    "Subtypes must be unique for two-way subtype bindings.  Set BindingMode to OneWay to disable updates to the binding source during serialization."); " is 147.
Complex Conditional,BinarySerialization.Graph.TypeGraph,EnumTypeNode,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Graph\TypeGraph\EnumTypeNode.cs,InitializeEnumValues,The conditional expression  "enumAttributes.Any(enumAttribute => enumAttribute.Value != null) ||                  serializedType == SerializedType.TerminatedString ||                  serializedType == SerializedType.SizedString ||                  serializedType == SerializedType.LengthPrefixedString"  is complex.
Complex Conditional,BinarySerialization.Graph.ValueGraph,ObjectValueNode,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Graph\ValueGraph\ObjectValueNode.cs,IsCustomNode,The conditional expression  "_valueType != null &&                  (TypeNode.SubtypeBindings != null || parent.ItemSubtypeBindings != null ||                   TypeNode.SubtypeFactoryBinding != null || parent.ItemSubtypeFactoryBinding != null)"  is complex.
Complex Conditional,BinarySerialization.Graph.ValueGraph,ObjectValueNode,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Graph\ValueGraph\ObjectValueNode.cs,ResolveValueType,The conditional expression  "_valueType == null &&                  (parent.ItemSubtypeBindings != null || parent.ItemSubtypeFactoryBinding != null ||                   parent.ItemSubtypeDefaultAttribute != null)"  is complex.
Complex Conditional,BinarySerialization.Graph.ValueGraph,ValueValueNode,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Graph\ValueGraph\ValueValueNode.cs,GetValue,The conditional expression  "serializedType == SerializedType.Int2 || serializedType == SerializedType.UInt2 ||                  serializedType == SerializedType.Int4 || serializedType == SerializedType.UInt4 ||                  serializedType == SerializedType.Int8 || serializedType == SerializedType.UInt8 ||                  serializedType == SerializedType.Float4 || serializedType == SerializedType.Float8"  is complex.
Magic Number,BinarySerialization,Bytes,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Bytes.cs,Reverse,The following statement contains a magic number: return (ushort) (((value & 0xFF00) >> 8) |                               ((value & 0x00FF) << 8));
Magic Number,BinarySerialization,Bytes,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Bytes.cs,Reverse,The following statement contains a magic number: return (ushort) (((value & 0xFF00) >> 8) |                               ((value & 0x00FF) << 8));
Magic Number,BinarySerialization,Bytes,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Bytes.cs,Reverse,The following statement contains a magic number: return                  ((value & 0xff000000) >> 24) |                  ((value & 0x00ff0000) >> 8) |                  ((value & 0x0000ff00) << 8) |                  ((value & 0x000000ff) << 24);
Magic Number,BinarySerialization,Bytes,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Bytes.cs,Reverse,The following statement contains a magic number: return                  ((value & 0xff000000) >> 24) |                  ((value & 0x00ff0000) >> 8) |                  ((value & 0x0000ff00) << 8) |                  ((value & 0x000000ff) << 24);
Magic Number,BinarySerialization,Bytes,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Bytes.cs,Reverse,The following statement contains a magic number: return                  ((value & 0xff000000) >> 24) |                  ((value & 0x00ff0000) >> 8) |                  ((value & 0x0000ff00) << 8) |                  ((value & 0x000000ff) << 24);
Magic Number,BinarySerialization,Bytes,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Bytes.cs,Reverse,The following statement contains a magic number: return                  ((value & 0xff000000) >> 24) |                  ((value & 0x00ff0000) >> 8) |                  ((value & 0x0000ff00) << 8) |                  ((value & 0x000000ff) << 24);
Magic Number,BinarySerialization,Bytes,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Bytes.cs,Reverse,The following statement contains a magic number: return                  ((value & 0xFF00000000000000) >> 56) |                  ((value & 0x00FF000000000000) >> 40) |                  ((value & 0x0000FF0000000000) >> 24) |                  ((value & 0x000000FF00000000) >> 8) |                  ((value & 0x00000000FF000000) << 8) |                  ((value & 0x0000000000FF0000) << 24) |                  ((value & 0x000000000000FF00) << 40) |                  ((value & 0x00000000000000FF) << 56);
Magic Number,BinarySerialization,Bytes,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Bytes.cs,Reverse,The following statement contains a magic number: return                  ((value & 0xFF00000000000000) >> 56) |                  ((value & 0x00FF000000000000) >> 40) |                  ((value & 0x0000FF0000000000) >> 24) |                  ((value & 0x000000FF00000000) >> 8) |                  ((value & 0x00000000FF000000) << 8) |                  ((value & 0x0000000000FF0000) << 24) |                  ((value & 0x000000000000FF00) << 40) |                  ((value & 0x00000000000000FF) << 56);
Magic Number,BinarySerialization,Bytes,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Bytes.cs,Reverse,The following statement contains a magic number: return                  ((value & 0xFF00000000000000) >> 56) |                  ((value & 0x00FF000000000000) >> 40) |                  ((value & 0x0000FF0000000000) >> 24) |                  ((value & 0x000000FF00000000) >> 8) |                  ((value & 0x00000000FF000000) << 8) |                  ((value & 0x0000000000FF0000) << 24) |                  ((value & 0x000000000000FF00) << 40) |                  ((value & 0x00000000000000FF) << 56);
Magic Number,BinarySerialization,Bytes,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Bytes.cs,Reverse,The following statement contains a magic number: return                  ((value & 0xFF00000000000000) >> 56) |                  ((value & 0x00FF000000000000) >> 40) |                  ((value & 0x0000FF0000000000) >> 24) |                  ((value & 0x000000FF00000000) >> 8) |                  ((value & 0x00000000FF000000) << 8) |                  ((value & 0x0000000000FF0000) << 24) |                  ((value & 0x000000000000FF00) << 40) |                  ((value & 0x00000000000000FF) << 56);
Magic Number,BinarySerialization,Bytes,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Bytes.cs,Reverse,The following statement contains a magic number: return                  ((value & 0xFF00000000000000) >> 56) |                  ((value & 0x00FF000000000000) >> 40) |                  ((value & 0x0000FF0000000000) >> 24) |                  ((value & 0x000000FF00000000) >> 8) |                  ((value & 0x00000000FF000000) << 8) |                  ((value & 0x0000000000FF0000) << 24) |                  ((value & 0x000000000000FF00) << 40) |                  ((value & 0x00000000000000FF) << 56);
Magic Number,BinarySerialization,Bytes,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Bytes.cs,Reverse,The following statement contains a magic number: return                  ((value & 0xFF00000000000000) >> 56) |                  ((value & 0x00FF000000000000) >> 40) |                  ((value & 0x0000FF0000000000) >> 24) |                  ((value & 0x000000FF00000000) >> 8) |                  ((value & 0x00000000FF000000) << 8) |                  ((value & 0x0000000000FF0000) << 24) |                  ((value & 0x000000000000FF00) << 40) |                  ((value & 0x00000000000000FF) << 56);
Magic Number,BinarySerialization,Bytes,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Bytes.cs,Reverse,The following statement contains a magic number: return                  ((value & 0xFF00000000000000) >> 56) |                  ((value & 0x00FF000000000000) >> 40) |                  ((value & 0x0000FF0000000000) >> 24) |                  ((value & 0x000000FF00000000) >> 8) |                  ((value & 0x00000000FF000000) << 8) |                  ((value & 0x0000000000FF0000) << 24) |                  ((value & 0x000000000000FF00) << 40) |                  ((value & 0x00000000000000FF) << 56);
Magic Number,BinarySerialization,Bytes,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Bytes.cs,Reverse,The following statement contains a magic number: return                  ((value & 0xFF00000000000000) >> 56) |                  ((value & 0x00FF000000000000) >> 40) |                  ((value & 0x0000FF0000000000) >> 24) |                  ((value & 0x000000FF00000000) >> 8) |                  ((value & 0x00000000FF000000) << 8) |                  ((value & 0x0000000000FF0000) << 24) |                  ((value & 0x000000000000FF00) << 40) |                  ((value & 0x00000000000000FF) << 56);
Magic Number,BinarySerialization,Crc<T>,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Crc.cs,Compute,The following statement contains a magic number: for (var i = offset; i < count; ++i)              {                  var b = buffer[i];                    if (IsDataReflected)                  {                      b = (byte) Reflect(b' 8);                  }                    var data = (byte) (b ^ (remainder >> (Width - 8)));                    remainder = ToUInt32(_table[data]) ^ (remainder << 8);              }
Magic Number,BinarySerialization,Crc<T>,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Crc.cs,Compute,The following statement contains a magic number: for (var i = offset; i < count; ++i)              {                  var b = buffer[i];                    if (IsDataReflected)                  {                      b = (byte) Reflect(b' 8);                  }                    var data = (byte) (b ^ (remainder >> (Width - 8)));                    remainder = ToUInt32(_table[data]) ^ (remainder << 8);              }
Magic Number,BinarySerialization,Crc<T>,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Crc.cs,Compute,The following statement contains a magic number: for (var i = offset; i < count; ++i)              {                  var b = buffer[i];                    if (IsDataReflected)                  {                      b = (byte) Reflect(b' 8);                  }                    var data = (byte) (b ^ (remainder >> (Width - 8)));                    remainder = ToUInt32(_table[data]) ^ (remainder << 8);              }
Magic Number,BinarySerialization,Crc<T>,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Crc.cs,BuildTable,The following statement contains a magic number: var table = new T[256];
Magic Number,BinarySerialization,Crc<T>,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Crc.cs,BuildTable,The following statement contains a magic number: var padWidth = Width - 8;
Magic Number,BinarySerialization,Crc<T>,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Crc.cs,BuildTable,The following statement contains a magic number: for (uint dividend = 0; dividend < 256; ++dividend)              {                  // Start with the dividend followed by zeros.                  var remainder = dividend << padWidth;                                    // Perform modulo-2 division' a bit at a time.                  for (byte bit = 8; bit > 0; --bit)                  {                      // Try to divide the current data bit.                      if ((remainder & topBit) != 0)                      {                          remainder = (remainder << 1) ^ poly;                      }                      else                      {                          remainder = remainder << 1;                      }                  }                    // Store the result into the table.                  table[dividend] = FromUInt32(remainder);              }
Magic Number,BinarySerialization,Crc<T>,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Crc.cs,BuildTable,The following statement contains a magic number: for (uint dividend = 0; dividend < 256; ++dividend)              {                  // Start with the dividend followed by zeros.                  var remainder = dividend << padWidth;                                    // Perform modulo-2 division' a bit at a time.                  for (byte bit = 8; bit > 0; --bit)                  {                      // Try to divide the current data bit.                      if ((remainder & topBit) != 0)                      {                          remainder = (remainder << 1) ^ poly;                      }                      else                      {                          remainder = remainder << 1;                      }                  }                    // Store the result into the table.                  table[dividend] = FromUInt32(remainder);              }
Magic Number,BinarySerialization,FieldChecksumAttribute,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\FieldChecksumAttribute.cs,GetFinalValue,The following statement contains a magic number: switch (Mode)              {                  case ChecksumMode.TwosComplement:                      return (byte) (0x100 - checksum);                  case ChecksumMode.Modulo256:                      return (byte) (checksum % 256);                  case ChecksumMode.Xor:                      return checksum;                  default:                      throw new ArgumentException();              }
Missing Default,BinarySerialization,BoundedStream,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\BoundedStream.cs,Seek,The following switch statement is missing a default case: switch (origin)              {                  case SeekOrigin.Current:                      Position += offset;                      break;                  case SeekOrigin.Begin:                      Position = offset;                      break;                  case SeekOrigin.End:                      Position = Length + offset;                      break;              }
Missing Default,BinarySerialization,NullStream,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\NullStream.cs,Seek,The following switch statement is missing a default case: switch (origin)              {                  case SeekOrigin.Begin:                      Position = offset;                      break;                  case SeekOrigin.Current:                      Position += offset;                      break;                  case SeekOrigin.End:                      Position = Length - offset;                      break;              }
Missing Default,BinarySerialization,Streamlet,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Streamlet.cs,Seek,The following switch statement is missing a default case: switch (origin)              {                  case SeekOrigin.Current:                      Position += offset;                      break;                  case SeekOrigin.Begin:                      Position = offset;                      break;                  case SeekOrigin.End:                      Position = Length + offset;                      break;              }
Missing Default,BinarySerialization.Graph,Binding,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Graph\Binding.cs,GetRelativeSource,The following switch statement is missing a default case: switch (RelativeSourceMode)              {                  case RelativeSourceMode.Self:                      source = target.Parent;                      break;                  case RelativeSourceMode.FindAncestor:                  case RelativeSourceMode.SerializationContext:                      source = FindAncestor(target);                      break;              }
Missing Default,BinarySerialization.Graph.TypeGraph,TypeNode,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Graph\TypeGraph\TypeNode.cs,GetBindingLevel,The following switch statement is missing a default case: switch (binding.RelativeSourceMode)              {                  case RelativeSourceMode.Self:                      level = 1;                      break;                  case RelativeSourceMode.FindAncestor:                  case RelativeSourceMode.SerializationContext:                      level = FindAncestorLevel(binding);                      break;              }
Missing Default,BinarySerialization.Graph.ValueGraph,CollectionValueNode,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Graph\ValueGraph\CollectionValueNode.cs,ProcessLastItem,The following switch statement is missing a default case: switch (TypeNode.ItemSerializeUntilAttribute.LastItemMode)              {                  case LastItemMode.Include:                      streamResetter.CancelReset();                      Children.Add(child);                      break;                  case LastItemMode.Discard:                      streamResetter.CancelReset();                      break;                  case LastItemMode.Defer:                      // stream will reset                      break;              }
Missing Default,BinarySerialization.Graph.ValueGraph,ValueValueNode,C:\repos\jefffhaynes_BinarySerializer\BinarySerializer\Graph\ValueGraph\ValueValueNode.cs,GetValue,The following switch statement is missing a default case: switch (serializedType)                  {                      case SerializedType.Int2:                          return Bytes.Reverse(Convert.ToInt16(value));                      case SerializedType.UInt2:                          var value2 = Bytes.Reverse(Convert.ToUInt16(value));                            // handle special case of char                          return ConvertToFieldType(value2);                      case SerializedType.Int4:                          return Bytes.Reverse(Convert.ToInt32(value));                      case SerializedType.UInt4:                          return Bytes.Reverse(Convert.ToUInt32(value));                      case SerializedType.Int8:                          return Bytes.Reverse(Convert.ToInt64(value));                      case SerializedType.UInt8:                          return Bytes.Reverse(Convert.ToUInt64(value));                      case SerializedType.Float4:                          return Bytes.Reverse(Convert.ToSingle(value));                      case SerializedType.Float8:                          return Bytes.Reverse(Convert.ToDouble(value));                  }
