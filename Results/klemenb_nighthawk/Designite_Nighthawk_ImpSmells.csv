Implementation smell,Namespace,Class,File,Method,Description
Long Method,Nighthawk,ARPTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\ARPTools.cs,WorkerRouter,The method has 67 lines of code.
Long Method,Nighthawk,NDTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\NDTools.cs,WorkerRouter,The method has 60 lines of code.
Long Method,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,GetInterfaces,The method has 84 lines of code.
Long Method,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,device_OnPacketArrival,The method has 65 lines of code.
Long Method,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The method has 129 lines of code.
Long Method,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,SnifferSearch,The method has 65 lines of code.
Long Method,Nighthawk,SSLStrip,D:\newReposJune17\klemenb_nighthawk\Nighthawk\SSLStrip.cs,ProcessPacket,The method has 79 lines of code.
Long Method,Nighthawk,HttpHeader,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HttpHeader,The method has 62 lines of code.
Complex Method,Nighthawk,ARPTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\ARPTools.cs,WorkerRouter,Cyclomatic complexity of the method is 16
Complex Method,Nighthawk,NDTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\NDTools.cs,WorkerRouter,Cyclomatic complexity of the method is 13
Complex Method,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,GetInterfaces,Cyclomatic complexity of the method is 15
Complex Method,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,device_OnPacketArrival,Cyclomatic complexity of the method is 15
Complex Method,Nighthawk,Scanner,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Scanner.cs,WorkerARP,Cyclomatic complexity of the method is 7
Complex Method,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,Cyclomatic complexity of the method is 26
Complex Method,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,SnifferSearch,Cyclomatic complexity of the method is 15
Complex Method,Nighthawk,SSLStrip,D:\newReposJune17\klemenb_nighthawk\Nighthawk\SSLStrip.cs,ProcessPacket,Cyclomatic complexity of the method is 12
Complex Method,Nighthawk,HttpPacket,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HttpPacket,Cyclomatic complexity of the method is 8
Complex Method,Nighthawk,HttpHeader,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HttpHeader,Cyclomatic complexity of the method is 18
Complex Method,Nighthawk,MainWindow,D:\newReposJune17\klemenb_nighthawk\Nighthawk\MainWindow.xaml.cs,BScanNetwork_Click,Cyclomatic complexity of the method is 7
Complex Method,Nighthawk,MainWindow,D:\newReposJune17\klemenb_nighthawk\Nighthawk\MainWindow.xaml.cs,MenuItemSaveSniffer_Click,Cyclomatic complexity of the method is 7
Long Parameter List,Nighthawk,ARPTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\ARPTools.cs,StaticARP,The method has 4 parameters.
Long Parameter List,Nighthawk,ARPTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\ARPTools.cs,GenerateARPReply,The method has 4 parameters.
Long Parameter List,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,sniffer_OnSnifferResult,The method has 5 parameters.
Long Parameter List,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,scanner_OnResponse,The method has 5 parameters.
Long Parameter List,Nighthawk,Network,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Network.cs,GetPseudoHeader,The method has 4 parameters.
Long Parameter List,Nighthawk,Scanner,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Scanner.cs,Response,The method has 5 parameters.
Long Parameter List,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Result,The method has 5 parameters.
Long Statement,Nighthawk,ARPTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\ARPTools.cs,StaticARP,The length of the statement  "			p.StartInfo.Arguments = "/k netsh interface ip delete neighbors \"" + WinName + "\" " + IP + " && netsh interface ip add neighbors \"" + WinName + "\" " + IP + " " + macString + " && exit"; " is 189.
Long Statement,Nighthawk,ARPTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\ARPTools.cs,GenerateARPReply,The length of the statement  "	var arpPacket = new ARPPacket (ARPOperation.Response' targetMAC' IPAddress.Parse (targetIP)' sourceMAC' IPAddress.Parse (senderIP)); " is 132.
Long Statement,Nighthawk,ARPTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\ARPTools.cs,WorkerRouter,The length of the statement  "		// size of packets - needed for send queue (set some starting value - it seems the length is not set correctly during threadQueue packet copying) " is 145.
Long Statement,Nighthawk,NDTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\NDTools.cs,GenerateRouterAdvertisement,The length of the statement  "	var bytes = Network.HexToByte ("333300000001" + deviceInfo.PMAC.ToString () + "86dd6e00000000703aff" + ipv6 + "ff02000000000000000000000000000186002fe7ff080800000000000000040005010000000005dc030440c0111111110404040400000000" + Network.IPv6ToFullHex (prefix) + "0101" + deviceInfo.PMAC.ToString () + "1803000800001111000000000000000000000000000000001903000001010101ff0200000000000000000000000000fb"); " is 399.
Long Statement,Nighthawk,NDTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\NDTools.cs,GenerateNDAdvertisement,The length of the statement  "	var bytes = Network.HexToByte (IPv6toMACTargets [gatewayIPv6] + deviceInfo.PMAC.ToString () + "86dd6000000000203aff" + Network.IPv6ToFullHex (sourceIP) + Network.IPv6ToFullHex (gatewayIPv6) + "880067f760000000" + Network.IPv6ToFullHex (sourceIP) + "0201" + deviceInfo.PMAC.ToString ()); " is 286.
Long Statement,Nighthawk,NDTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\NDTools.cs,WorkerRouter,The length of the statement  "		// size of packets - needed for send queue (set some starting value - it seems the length is not set correctly during threadQueue packet copying) " is 145.
Long Statement,Nighthawk,NDTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\NDTools.cs,WorkerRouter,The length of the statement  "				if ((sourceIP.Contains (prefix.Replace ("::"' ":")) && destinationIP.Contains (prefix.Replace ("::"' ":"))) || (sourceIP.Contains ("fe80::") || destinationIP.Contains ("fe80::"))) " is 179.
Long Statement,Nighthawk,NDTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\NDTools.cs,WorkerRouter,The length of the statement  "				// check for IPv6 - MAC entry existance (check only addresses from this network) and add it if necessary (we need this because scanner cannot pick up IPv6 addresses of all the targets) " is 184.
Long Statement,Nighthawk,NDTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\NDTools.cs,WorkerRouter,The length of the statement  "				if (sourceIP.Contains (prefix.Replace ("::"' ":")) && !IPv6toMACTargets.ContainsKey (sourceIP) && !sourceIP.Contains ("fe80::")) { " is 130.
Long Statement,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,GetInterfaces,The length of the statement  "			devices.Add (description + " (IPv4: " + address + "/" + Network.MaskToCIDR (subnet) + (address6 != string.Empty ? "' IPv6: " + address6 + "' " + linkLocal : "") + ")"); " is 168.
Long Statement,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,GetInterfaces,The length of the statement  "			devices.Add (description + " (IPv4: none" + (address6 != string.Empty ? "' IPv6: " + address6 + "' " + linkLocal : "") + ")"); " is 126.
Long Statement,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,GetInterfaces,The length of the statement  "						DeviceInfoList.Last ().GatewayIP = iface.GetIPProperties ().GatewayAddresses.Where (a => a.Address.AddressFamily == AddressFamily.InterNetwork).First ().Address.ToString (); " is 173.
Long Statement,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,device_OnPacketArrival,The length of the statement  "			if (tcp.DestinationPort == 80 || tcp.DestinationPort == 21 || tcp.DestinationPort == 143 || tcp.DestinationPort == 110 || tcp.DestinationPort == 25) { " is 150.
Long Statement,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,sniffer_OnSnifferResult,The length of the statement  "		if (Window.SnifferResultList.Count == 0 || (Window.SnifferResultList.Last ().CompareString () != result.CompareString ())) { " is 124.
Long Statement,Nighthawk,Network,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Network.cs,MaskToCIDR,The length of the statement  "	uint subnet = 16777216 * Convert.ToUInt32 (ipParts [0]) + 65536 * Convert.ToUInt32 (ipParts [1]) + 256 * Convert.ToUInt32 (ipParts [2]) + Convert.ToUInt32 (ipParts [3]); " is 169.
Long Statement,Nighthawk,Scanner,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Scanner.cs,GenerateIpv6Ping,The length of the statement  "	var ipv6Packet = new IPv6Packet (IPAddress.Parse ((deviceInfo.IPv6 != string.Empty ? deviceInfo.IPv6 : deviceInfo.LinkLocal))' IPAddress.Parse ("ff02::1")); " is 156.
Long Statement,Nighthawk,Scanner,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Scanner.cs,GenerateIpv6Ping,The length of the statement  "	var pseudo = Network.GetPseudoHeader (ipv6Packet.SourceAddress' ipv6Packet.DestinationAddress' icmpv6Packet.Bytes.Length' 58); " is 126.
Long Statement,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The length of the statement  "					var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ())); " is 148.
Long Statement,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The length of the statement  "						var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0)); " is 126.
Long Statement,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The length of the statement  "					var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ())); " is 149.
Long Statement,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,SnifferSearch,The length of the statement  "			if (fieldNamesUser.Where (s => param [0].Contains (s)).Count () > 0 && user == string.Empty && !excludedFieldNamesUsername.Contains (param [0])) { " is 146.
Long Statement,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,SnifferSearch,The length of the statement  "			if (fieldNamesPassword.Where (s => param [0].Contains (s)).Count () > 0 && password == string.Empty && !excludedFieldNamesPassword.Contains (param [0])) { " is 154.
Long Statement,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,SnifferSearch,The length of the statement  "			Result ((packet.Header.Host != string.Empty ? packet.Header.Host : "/")' Uri.UnescapeDataString (user)' Uri.UnescapeDataString (password)' "GET method"' SnifferResultType.HTML); " is 177.
Long Statement,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,SnifferSearch,The length of the statement  "			if (fieldNamesUser.Where (s => param [0].Contains (s)).Count () > 0 && user == string.Empty && !excludedFieldNamesUsername.Contains (param [0])) { " is 146.
Long Statement,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,SnifferSearch,The length of the statement  "			if (fieldNamesPassword.Where (s => param [0].Contains (s)).Count () > 0 && password == string.Empty && !excludedFieldNamesPassword.Contains (param [0])) { " is 154.
Long Statement,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,SnifferSearch,The length of the statement  "				var posts = postRequests.Where (r => (r.SourceAddress.ToString () == sourceIP.ToString () && r.DestinationAddress.ToString () == destIP.ToString ())); " is 150.
Long Statement,Nighthawk,SSLStrip,D:\newReposJune17\klemenb_nighthawk\Nighthawk\SSLStrip.cs,ProcessPacket,The length of the statement  "			if (!(data.Contains ("<form") || data.Contains ("<input") || data.Contains ("<a ") || data.Contains ("</a>") || data.Contains ("</div>") || data.Contains ("<meta") || data.Contains ("javascript"))) " is 197.
Long Statement,Nighthawk,MainWindow,D:\newReposJune17\klemenb_nighthawk\Nighthawk\MainWindow.xaml.cs,Window_Loaded,The length of the statement  "		RCTSnifferUpdated.Margin = new Thickness (122' RCTSnifferUpdated.Margin.Top' RCTSnifferUpdated.Margin.Right' RCTSnifferUpdated.Margin.Bottom); " is 142.
Long Statement,Nighthawk,MainWindow,D:\newReposJune17\klemenb_nighthawk\Nighthawk\MainWindow.xaml.cs,BScanNetwork_Click,The length of the statement  "		MessageBox.Show ("Invalid interface! Please select another one from the list."' "Nighthawk - network scan"' MessageBoxButton.OK' MessageBoxImage.Exclamation); " is 158.
Long Statement,Nighthawk,MainWindow,D:\newReposJune17\klemenb_nighthawk\Nighthawk\MainWindow.xaml.cs,BScanNetwork_Click,The length of the statement  "			MessageBox.Show ("Please stop ARP spoofing before running another scan."' "Nighthawk - network scan"' MessageBoxButton.OK' MessageBoxImage.Exclamation); " is 152.
Long Statement,Nighthawk,MainWindow,D:\newReposJune17\klemenb_nighthawk\Nighthawk\MainWindow.xaml.cs,BScanNetwork_Click,The length of the statement  "			MessageBox.Show ("Please stop ND spoofing before running another scan."' "Nighthawk - network scan"' MessageBoxButton.OK' MessageBoxImage.Exclamation); " is 151.
Long Statement,Nighthawk,MainWindow,D:\newReposJune17\klemenb_nighthawk\Nighthawk\MainWindow.xaml.cs,BScanNetwork_Click,The length of the statement  "			MessageBox.Show ("Please stop SSL stripping before running another scan."' "Nighthawk - network scan"' MessageBoxButton.OK' MessageBoxImage.Exclamation); " is 153.
Long Statement,Nighthawk,MainWindow,D:\newReposJune17\klemenb_nighthawk\Nighthawk\MainWindow.xaml.cs,BStartARP_Click,The length of the statement  "			Nighthawk.ARPTools.StartSpoofing (GetTargets (LArpTargets1List)' GetTarget (LArpTargets2List)' CHBlockPPTP.IsChecked != null ? (bool)CHBlockPPTP.IsChecked : false); " is 164.
Long Statement,Nighthawk,MainWindow,D:\newReposJune17\klemenb_nighthawk\Nighthawk\MainWindow.xaml.cs,BStartARP_Click,The length of the statement  "			MessageBox.Show ("Please select desired targets."' "Nighthawk - ARP spoofing"' MessageBoxButton.OK' MessageBoxImage.Exclamation); " is 129.
Long Statement,Nighthawk,MainWindow,D:\newReposJune17\klemenb_nighthawk\Nighthawk\MainWindow.xaml.cs,BStartND_Click,The length of the statement  "		if (Network.PrefixValid (TBPrefix.Text) && Nighthawk.DeviceInfo.GatewayIPv6 != string.Empty && targetList.Find (t => t.IPv6List.Contains (Nighthawk.DeviceInfo.GatewayIPv6)) != null) { " is 183.
Long Statement,Nighthawk,MainWindow,D:\newReposJune17\klemenb_nighthawk\Nighthawk\MainWindow.xaml.cs,BStartND_Click,The length of the statement  "				MessageBox.Show ("There was a problem detecting IPv6/MAC address of the gateway."' "Nighthawk - ND spoofing"' MessageBoxButton.OK' MessageBoxImage.Exclamation); " is 160.
Long Statement,Nighthawk,MainWindow,D:\newReposJune17\klemenb_nighthawk\Nighthawk\MainWindow.xaml.cs,BStartSSLstrip_Click,The length of the statement  "			MessageBox.Show ("SSL stripping requires active ARP or ND spoofing to function properly."' "Nighthawk - SSL stripping"' MessageBoxButton.OK' MessageBoxImage.Exclamation); " is 170.
Long Statement,Nighthawk,MainWindow,D:\newReposJune17\klemenb_nighthawk\Nighthawk\MainWindow.xaml.cs,BInterfaceRefresh_Click,The length of the statement  "	if (!Nighthawk.Started || (Nighthawk.Started && !Nighthawk.Scanner.Started && !Nighthawk.ARPTools.SpoofingStarted && !Nighthawk.Sniffer.Started && !Nighthawk.SSLStrip.Started)) { " is 178.
Long Statement,Nighthawk,MainWindow,D:\newReposJune17\klemenb_nighthawk\Nighthawk\MainWindow.xaml.cs,BInterfaceRefresh_Click,The length of the statement  "		MessageBox.Show ("Please stop any active tools or wait for an active scan to complete."' "Nighthawk - interfaces"' MessageBoxButton.OK' MessageBoxImage.Exclamation); " is 165.
Long Statement,Nighthawk,MainWindow,D:\newReposJune17\klemenb_nighthawk\Nighthawk\MainWindow.xaml.cs,StartQuickAttack,The length of the statement  "	if (Nighthawk.DeviceInfo.IPv6 != string.Empty && Nighthawk.DeviceInfo.GatewayIPv6 != string.Empty && !Nighthawk.DeviceInfo.IPv6.Contains ("fe80::")) " is 148.
Long Statement,Nighthawk,MainWindow,D:\newReposJune17\klemenb_nighthawk\Nighthawk\MainWindow.xaml.cs,MenuItemSaveNetwork_Click,The length of the statement  "				MessageBox.Show ("Unable to save file. Please try again with a different location or filename."' "Nighthawk - file error"' MessageBoxButton.OK' MessageBoxImage.Error); " is 167.
Long Statement,Nighthawk,MainWindow,D:\newReposJune17\klemenb_nighthawk\Nighthawk\MainWindow.xaml.cs,MenuItemSaveSniffer_Click,The length of the statement  "			fileData.AppendLine (type + ";" + item.Time.ToString ("dd-MM-yyyy HH:mm:ss") + ";" + item.URL + ";" + item.Username + ";" + item.Password + ";" + item.Aditional); " is 162.
Long Statement,Nighthawk,MainWindow,D:\newReposJune17\klemenb_nighthawk\Nighthawk\MainWindow.xaml.cs,MenuItemSaveSniffer_Click,The length of the statement  "				MessageBox.Show ("Unable to save file. Please try again with a different location or filename."' "Nighthawk - file error"' MessageBoxButton.OK' MessageBoxImage.Error); " is 167.
Long Statement,Nighthawk,MainWindow,D:\newReposJune17\klemenb_nighthawk\Nighthawk\MainWindow.xaml.cs,MenuItemExit_Click,The length of the statement  "	if (MessageBox.Show ("Are you sure you want to exit the application?"' "Nighthawk"' MessageBoxButton.YesNo' MessageBoxImage.Information) == MessageBoxResult.Yes) { " is 163.
Complex Conditional,Nighthawk,NDTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\NDTools.cs,WorkerRouter,The conditional expression  "(sourceIP.Contains (prefix.Replace ("::"' ":")) && destinationIP.Contains (prefix.Replace ("::"' ":"))) || (sourceIP.Contains ("fe80::") || destinationIP.Contains ("fe80::"))"  is complex.
Complex Conditional,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,device_OnPacketArrival,The conditional expression  "tcp.DestinationPort == 80 || tcp.DestinationPort == 21 || tcp.DestinationPort == 143 || tcp.DestinationPort == 110 || tcp.DestinationPort == 25"  is complex.
Complex Conditional,Nighthawk,SSLStrip,D:\newReposJune17\klemenb_nighthawk\Nighthawk\SSLStrip.cs,ProcessPacket,The conditional expression  "!(data.Contains ("<form") || data.Contains ("<input") || data.Contains ("<a ") || data.Contains ("</a>") || data.Contains ("</div>") || data.Contains ("<meta") || data.Contains ("javascript"))"  is complex.
Complex Conditional,Nighthawk,MainWindow,D:\newReposJune17\klemenb_nighthawk\Nighthawk\MainWindow.xaml.cs,BInterfaceRefresh_Click,The conditional expression  "!Nighthawk.Started || (Nighthawk.Started && !Nighthawk.Scanner.Started && !Nighthawk.ARPTools.SpoofingStarted && !Nighthawk.Sniffer.Started && !Nighthawk.SSLStrip.Started)"  is complex.
Empty Catch Block,Nighthawk,Scanner,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Scanner.cs,WorkerResolver,The method has an empty catch block.
Empty Catch Block,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,SnifferSearch,The method has an empty catch block.
Magic Number,Nighthawk,ARPTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\ARPTools.cs,StaticARP,The following statement contains a magic number: if (system.Version.Major > 5) {  	if (operation == StaticARPOperation.Add)  		p.StartInfo.Arguments = "/k netsh interface ip delete neighbors \"" + WinName + "\" " + IP + " && netsh interface ip add neighbors \"" + WinName + "\" " + IP + " " + macString + " && exit";  	else  		p.StartInfo.Arguments = "/k netsh interface ip delete neighbors \"" + WinName + "\" " + IP + " && exit";  	p.Start ();  	p.WaitForExit ();  	p.Dispose ();  	return true;  }  
Magic Number,Nighthawk,ARPTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\ARPTools.cs,WorkerSender,The following statement contains a magic number: while (SpoofingStarted) {  	sendQueue.Transmit (device' SendQueueTransmitModes.Normal);  	Thread.Sleep (2500);  }  
Magic Number,Nighthawk,ARPTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\ARPTools.cs,WorkerSender,The following statement contains a magic number: Thread.Sleep (2500);  
Magic Number,Nighthawk,ARPTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\ARPTools.cs,WorkerRouter,The following statement contains a magic number: while (SpoofingStarted) {  	// size of packets - needed for send queue (set some starting value - it seems the length is not set correctly during threadQueue packet copying)  	int bufferSize = 2048;  	// copy packets to thread's packet storage (threadRoutingQueue)  	lock (PacketQueueRouting) {  		foreach (Packet packet in PacketQueueRouting) {  			threadQueueRouting.Add (packet);  			bufferSize += packet.Bytes.Length;  		}  		PacketQueueRouting.Clear ();  	}  	if (threadQueueRouting.Count > 0) {  		var sendQueue = new SendQueue (bufferSize);  		// loop through packets and change MAC addresses  		foreach (Packet packet in threadQueueRouting) {  			if (packet == null)  				continue;  			var ethernetPacket = (packet as EthernetPacket);  			if (ethernetPacket == null)  				continue;  			var ip = (packet is IpPacket ? (IpPacket)packet : IpPacket.GetEncapsulated (packet));  			// discard invalid packets  			if (ip is IPv4Packet && (((IPv4Packet)ip).Checksum == 0 || !((IPv4Packet)ip).ValidIPChecksum))  				continue;  			var sourceIP = ip.SourceAddress.ToString ();  			var destinationIP = ip.DestinationAddress.ToString ();  			var sourceMAC = ethernetPacket.SourceHwAddress.ToString ();  			var destinationMAC = ethernetPacket.DestinationHwAddress.ToString ();  			if (destinationMAC == sourceMAC)  				continue;  			// block PPTP if necessary (exclude local computer)  			if (blockPPTP && sourceIP != deviceInfo.IP && destinationIP != deviceInfo.IP) {  				// block GRE  				if (ip.Protocol == IPProtocolType.GRE)  					continue;  				// check for port 1723 and block it  				if (ip.Protocol == IPProtocolType.TCP) {  					var tcp = TcpPacket.GetEncapsulated (packet);  					if (tcp != null && (tcp.SourcePort == 1723 || tcp.DestinationPort == 1723))  						continue;  				}  			}  			// incoming packets - change destination MAC back to target's MAC  			if (IPtoMACTargets1.ContainsKey (destinationIP) && (destinationMAC != IPtoMACTargets1 [destinationIP].ToString ())) {  				ethernetPacket.SourceHwAddress = physicalAddress;  				ethernetPacket.DestinationHwAddress = IPtoMACTargets1 [destinationIP];  				if (ethernetPacket.Bytes != null)  					sendQueue.Add (packet.Bytes);  			}  			// outgoing packets - change destination MAC to gateway's MAC  			if (IPtoMACTargets1.ContainsKey (sourceIP) && (destinationMAC != SpoofingTarget2.PMAC.ToString ())) {  				ethernetPacket.SourceHwAddress = physicalAddress;  				ethernetPacket.DestinationHwAddress = SpoofingTarget2.PMAC;  				if (ethernetPacket.Bytes != null)  					sendQueue.Add (packet.Bytes);  			}  		}  		sendQueue.Transmit (device' SendQueueTransmitModes.Normal);  		sendQueue.Dispose ();  		threadQueueRouting.Clear ();  	} else {  		Thread.Sleep (1);  	}  }  
Magic Number,Nighthawk,ARPTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\ARPTools.cs,WorkerRouter,The following statement contains a magic number: while (SpoofingStarted) {  	// size of packets - needed for send queue (set some starting value - it seems the length is not set correctly during threadQueue packet copying)  	int bufferSize = 2048;  	// copy packets to thread's packet storage (threadRoutingQueue)  	lock (PacketQueueRouting) {  		foreach (Packet packet in PacketQueueRouting) {  			threadQueueRouting.Add (packet);  			bufferSize += packet.Bytes.Length;  		}  		PacketQueueRouting.Clear ();  	}  	if (threadQueueRouting.Count > 0) {  		var sendQueue = new SendQueue (bufferSize);  		// loop through packets and change MAC addresses  		foreach (Packet packet in threadQueueRouting) {  			if (packet == null)  				continue;  			var ethernetPacket = (packet as EthernetPacket);  			if (ethernetPacket == null)  				continue;  			var ip = (packet is IpPacket ? (IpPacket)packet : IpPacket.GetEncapsulated (packet));  			// discard invalid packets  			if (ip is IPv4Packet && (((IPv4Packet)ip).Checksum == 0 || !((IPv4Packet)ip).ValidIPChecksum))  				continue;  			var sourceIP = ip.SourceAddress.ToString ();  			var destinationIP = ip.DestinationAddress.ToString ();  			var sourceMAC = ethernetPacket.SourceHwAddress.ToString ();  			var destinationMAC = ethernetPacket.DestinationHwAddress.ToString ();  			if (destinationMAC == sourceMAC)  				continue;  			// block PPTP if necessary (exclude local computer)  			if (blockPPTP && sourceIP != deviceInfo.IP && destinationIP != deviceInfo.IP) {  				// block GRE  				if (ip.Protocol == IPProtocolType.GRE)  					continue;  				// check for port 1723 and block it  				if (ip.Protocol == IPProtocolType.TCP) {  					var tcp = TcpPacket.GetEncapsulated (packet);  					if (tcp != null && (tcp.SourcePort == 1723 || tcp.DestinationPort == 1723))  						continue;  				}  			}  			// incoming packets - change destination MAC back to target's MAC  			if (IPtoMACTargets1.ContainsKey (destinationIP) && (destinationMAC != IPtoMACTargets1 [destinationIP].ToString ())) {  				ethernetPacket.SourceHwAddress = physicalAddress;  				ethernetPacket.DestinationHwAddress = IPtoMACTargets1 [destinationIP];  				if (ethernetPacket.Bytes != null)  					sendQueue.Add (packet.Bytes);  			}  			// outgoing packets - change destination MAC to gateway's MAC  			if (IPtoMACTargets1.ContainsKey (sourceIP) && (destinationMAC != SpoofingTarget2.PMAC.ToString ())) {  				ethernetPacket.SourceHwAddress = physicalAddress;  				ethernetPacket.DestinationHwAddress = SpoofingTarget2.PMAC;  				if (ethernetPacket.Bytes != null)  					sendQueue.Add (packet.Bytes);  			}  		}  		sendQueue.Transmit (device' SendQueueTransmitModes.Normal);  		sendQueue.Dispose ();  		threadQueueRouting.Clear ();  	} else {  		Thread.Sleep (1);  	}  }  
Magic Number,Nighthawk,ARPTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\ARPTools.cs,WorkerRouter,The following statement contains a magic number: while (SpoofingStarted) {  	// size of packets - needed for send queue (set some starting value - it seems the length is not set correctly during threadQueue packet copying)  	int bufferSize = 2048;  	// copy packets to thread's packet storage (threadRoutingQueue)  	lock (PacketQueueRouting) {  		foreach (Packet packet in PacketQueueRouting) {  			threadQueueRouting.Add (packet);  			bufferSize += packet.Bytes.Length;  		}  		PacketQueueRouting.Clear ();  	}  	if (threadQueueRouting.Count > 0) {  		var sendQueue = new SendQueue (bufferSize);  		// loop through packets and change MAC addresses  		foreach (Packet packet in threadQueueRouting) {  			if (packet == null)  				continue;  			var ethernetPacket = (packet as EthernetPacket);  			if (ethernetPacket == null)  				continue;  			var ip = (packet is IpPacket ? (IpPacket)packet : IpPacket.GetEncapsulated (packet));  			// discard invalid packets  			if (ip is IPv4Packet && (((IPv4Packet)ip).Checksum == 0 || !((IPv4Packet)ip).ValidIPChecksum))  				continue;  			var sourceIP = ip.SourceAddress.ToString ();  			var destinationIP = ip.DestinationAddress.ToString ();  			var sourceMAC = ethernetPacket.SourceHwAddress.ToString ();  			var destinationMAC = ethernetPacket.DestinationHwAddress.ToString ();  			if (destinationMAC == sourceMAC)  				continue;  			// block PPTP if necessary (exclude local computer)  			if (blockPPTP && sourceIP != deviceInfo.IP && destinationIP != deviceInfo.IP) {  				// block GRE  				if (ip.Protocol == IPProtocolType.GRE)  					continue;  				// check for port 1723 and block it  				if (ip.Protocol == IPProtocolType.TCP) {  					var tcp = TcpPacket.GetEncapsulated (packet);  					if (tcp != null && (tcp.SourcePort == 1723 || tcp.DestinationPort == 1723))  						continue;  				}  			}  			// incoming packets - change destination MAC back to target's MAC  			if (IPtoMACTargets1.ContainsKey (destinationIP) && (destinationMAC != IPtoMACTargets1 [destinationIP].ToString ())) {  				ethernetPacket.SourceHwAddress = physicalAddress;  				ethernetPacket.DestinationHwAddress = IPtoMACTargets1 [destinationIP];  				if (ethernetPacket.Bytes != null)  					sendQueue.Add (packet.Bytes);  			}  			// outgoing packets - change destination MAC to gateway's MAC  			if (IPtoMACTargets1.ContainsKey (sourceIP) && (destinationMAC != SpoofingTarget2.PMAC.ToString ())) {  				ethernetPacket.SourceHwAddress = physicalAddress;  				ethernetPacket.DestinationHwAddress = SpoofingTarget2.PMAC;  				if (ethernetPacket.Bytes != null)  					sendQueue.Add (packet.Bytes);  			}  		}  		sendQueue.Transmit (device' SendQueueTransmitModes.Normal);  		sendQueue.Dispose ();  		threadQueueRouting.Clear ();  	} else {  		Thread.Sleep (1);  	}  }  
Magic Number,Nighthawk,ARPTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\ARPTools.cs,WorkerRouter,The following statement contains a magic number: if (threadQueueRouting.Count > 0) {  	var sendQueue = new SendQueue (bufferSize);  	// loop through packets and change MAC addresses  	foreach (Packet packet in threadQueueRouting) {  		if (packet == null)  			continue;  		var ethernetPacket = (packet as EthernetPacket);  		if (ethernetPacket == null)  			continue;  		var ip = (packet is IpPacket ? (IpPacket)packet : IpPacket.GetEncapsulated (packet));  		// discard invalid packets  		if (ip is IPv4Packet && (((IPv4Packet)ip).Checksum == 0 || !((IPv4Packet)ip).ValidIPChecksum))  			continue;  		var sourceIP = ip.SourceAddress.ToString ();  		var destinationIP = ip.DestinationAddress.ToString ();  		var sourceMAC = ethernetPacket.SourceHwAddress.ToString ();  		var destinationMAC = ethernetPacket.DestinationHwAddress.ToString ();  		if (destinationMAC == sourceMAC)  			continue;  		// block PPTP if necessary (exclude local computer)  		if (blockPPTP && sourceIP != deviceInfo.IP && destinationIP != deviceInfo.IP) {  			// block GRE  			if (ip.Protocol == IPProtocolType.GRE)  				continue;  			// check for port 1723 and block it  			if (ip.Protocol == IPProtocolType.TCP) {  				var tcp = TcpPacket.GetEncapsulated (packet);  				if (tcp != null && (tcp.SourcePort == 1723 || tcp.DestinationPort == 1723))  					continue;  			}  		}  		// incoming packets - change destination MAC back to target's MAC  		if (IPtoMACTargets1.ContainsKey (destinationIP) && (destinationMAC != IPtoMACTargets1 [destinationIP].ToString ())) {  			ethernetPacket.SourceHwAddress = physicalAddress;  			ethernetPacket.DestinationHwAddress = IPtoMACTargets1 [destinationIP];  			if (ethernetPacket.Bytes != null)  				sendQueue.Add (packet.Bytes);  		}  		// outgoing packets - change destination MAC to gateway's MAC  		if (IPtoMACTargets1.ContainsKey (sourceIP) && (destinationMAC != SpoofingTarget2.PMAC.ToString ())) {  			ethernetPacket.SourceHwAddress = physicalAddress;  			ethernetPacket.DestinationHwAddress = SpoofingTarget2.PMAC;  			if (ethernetPacket.Bytes != null)  				sendQueue.Add (packet.Bytes);  		}  	}  	sendQueue.Transmit (device' SendQueueTransmitModes.Normal);  	sendQueue.Dispose ();  	threadQueueRouting.Clear ();  } else {  	Thread.Sleep (1);  }  
Magic Number,Nighthawk,ARPTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\ARPTools.cs,WorkerRouter,The following statement contains a magic number: if (threadQueueRouting.Count > 0) {  	var sendQueue = new SendQueue (bufferSize);  	// loop through packets and change MAC addresses  	foreach (Packet packet in threadQueueRouting) {  		if (packet == null)  			continue;  		var ethernetPacket = (packet as EthernetPacket);  		if (ethernetPacket == null)  			continue;  		var ip = (packet is IpPacket ? (IpPacket)packet : IpPacket.GetEncapsulated (packet));  		// discard invalid packets  		if (ip is IPv4Packet && (((IPv4Packet)ip).Checksum == 0 || !((IPv4Packet)ip).ValidIPChecksum))  			continue;  		var sourceIP = ip.SourceAddress.ToString ();  		var destinationIP = ip.DestinationAddress.ToString ();  		var sourceMAC = ethernetPacket.SourceHwAddress.ToString ();  		var destinationMAC = ethernetPacket.DestinationHwAddress.ToString ();  		if (destinationMAC == sourceMAC)  			continue;  		// block PPTP if necessary (exclude local computer)  		if (blockPPTP && sourceIP != deviceInfo.IP && destinationIP != deviceInfo.IP) {  			// block GRE  			if (ip.Protocol == IPProtocolType.GRE)  				continue;  			// check for port 1723 and block it  			if (ip.Protocol == IPProtocolType.TCP) {  				var tcp = TcpPacket.GetEncapsulated (packet);  				if (tcp != null && (tcp.SourcePort == 1723 || tcp.DestinationPort == 1723))  					continue;  			}  		}  		// incoming packets - change destination MAC back to target's MAC  		if (IPtoMACTargets1.ContainsKey (destinationIP) && (destinationMAC != IPtoMACTargets1 [destinationIP].ToString ())) {  			ethernetPacket.SourceHwAddress = physicalAddress;  			ethernetPacket.DestinationHwAddress = IPtoMACTargets1 [destinationIP];  			if (ethernetPacket.Bytes != null)  				sendQueue.Add (packet.Bytes);  		}  		// outgoing packets - change destination MAC to gateway's MAC  		if (IPtoMACTargets1.ContainsKey (sourceIP) && (destinationMAC != SpoofingTarget2.PMAC.ToString ())) {  			ethernetPacket.SourceHwAddress = physicalAddress;  			ethernetPacket.DestinationHwAddress = SpoofingTarget2.PMAC;  			if (ethernetPacket.Bytes != null)  				sendQueue.Add (packet.Bytes);  		}  	}  	sendQueue.Transmit (device' SendQueueTransmitModes.Normal);  	sendQueue.Dispose ();  	threadQueueRouting.Clear ();  } else {  	Thread.Sleep (1);  }  
Magic Number,Nighthawk,ARPTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\ARPTools.cs,WorkerRouter,The following statement contains a magic number: foreach (Packet packet in threadQueueRouting) {  	if (packet == null)  		continue;  	var ethernetPacket = (packet as EthernetPacket);  	if (ethernetPacket == null)  		continue;  	var ip = (packet is IpPacket ? (IpPacket)packet : IpPacket.GetEncapsulated (packet));  	// discard invalid packets  	if (ip is IPv4Packet && (((IPv4Packet)ip).Checksum == 0 || !((IPv4Packet)ip).ValidIPChecksum))  		continue;  	var sourceIP = ip.SourceAddress.ToString ();  	var destinationIP = ip.DestinationAddress.ToString ();  	var sourceMAC = ethernetPacket.SourceHwAddress.ToString ();  	var destinationMAC = ethernetPacket.DestinationHwAddress.ToString ();  	if (destinationMAC == sourceMAC)  		continue;  	// block PPTP if necessary (exclude local computer)  	if (blockPPTP && sourceIP != deviceInfo.IP && destinationIP != deviceInfo.IP) {  		// block GRE  		if (ip.Protocol == IPProtocolType.GRE)  			continue;  		// check for port 1723 and block it  		if (ip.Protocol == IPProtocolType.TCP) {  			var tcp = TcpPacket.GetEncapsulated (packet);  			if (tcp != null && (tcp.SourcePort == 1723 || tcp.DestinationPort == 1723))  				continue;  		}  	}  	// incoming packets - change destination MAC back to target's MAC  	if (IPtoMACTargets1.ContainsKey (destinationIP) && (destinationMAC != IPtoMACTargets1 [destinationIP].ToString ())) {  		ethernetPacket.SourceHwAddress = physicalAddress;  		ethernetPacket.DestinationHwAddress = IPtoMACTargets1 [destinationIP];  		if (ethernetPacket.Bytes != null)  			sendQueue.Add (packet.Bytes);  	}  	// outgoing packets - change destination MAC to gateway's MAC  	if (IPtoMACTargets1.ContainsKey (sourceIP) && (destinationMAC != SpoofingTarget2.PMAC.ToString ())) {  		ethernetPacket.SourceHwAddress = physicalAddress;  		ethernetPacket.DestinationHwAddress = SpoofingTarget2.PMAC;  		if (ethernetPacket.Bytes != null)  			sendQueue.Add (packet.Bytes);  	}  }  
Magic Number,Nighthawk,ARPTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\ARPTools.cs,WorkerRouter,The following statement contains a magic number: foreach (Packet packet in threadQueueRouting) {  	if (packet == null)  		continue;  	var ethernetPacket = (packet as EthernetPacket);  	if (ethernetPacket == null)  		continue;  	var ip = (packet is IpPacket ? (IpPacket)packet : IpPacket.GetEncapsulated (packet));  	// discard invalid packets  	if (ip is IPv4Packet && (((IPv4Packet)ip).Checksum == 0 || !((IPv4Packet)ip).ValidIPChecksum))  		continue;  	var sourceIP = ip.SourceAddress.ToString ();  	var destinationIP = ip.DestinationAddress.ToString ();  	var sourceMAC = ethernetPacket.SourceHwAddress.ToString ();  	var destinationMAC = ethernetPacket.DestinationHwAddress.ToString ();  	if (destinationMAC == sourceMAC)  		continue;  	// block PPTP if necessary (exclude local computer)  	if (blockPPTP && sourceIP != deviceInfo.IP && destinationIP != deviceInfo.IP) {  		// block GRE  		if (ip.Protocol == IPProtocolType.GRE)  			continue;  		// check for port 1723 and block it  		if (ip.Protocol == IPProtocolType.TCP) {  			var tcp = TcpPacket.GetEncapsulated (packet);  			if (tcp != null && (tcp.SourcePort == 1723 || tcp.DestinationPort == 1723))  				continue;  		}  	}  	// incoming packets - change destination MAC back to target's MAC  	if (IPtoMACTargets1.ContainsKey (destinationIP) && (destinationMAC != IPtoMACTargets1 [destinationIP].ToString ())) {  		ethernetPacket.SourceHwAddress = physicalAddress;  		ethernetPacket.DestinationHwAddress = IPtoMACTargets1 [destinationIP];  		if (ethernetPacket.Bytes != null)  			sendQueue.Add (packet.Bytes);  	}  	// outgoing packets - change destination MAC to gateway's MAC  	if (IPtoMACTargets1.ContainsKey (sourceIP) && (destinationMAC != SpoofingTarget2.PMAC.ToString ())) {  		ethernetPacket.SourceHwAddress = physicalAddress;  		ethernetPacket.DestinationHwAddress = SpoofingTarget2.PMAC;  		if (ethernetPacket.Bytes != null)  			sendQueue.Add (packet.Bytes);  	}  }  
Magic Number,Nighthawk,ARPTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\ARPTools.cs,WorkerRouter,The following statement contains a magic number: if (blockPPTP && sourceIP != deviceInfo.IP && destinationIP != deviceInfo.IP) {  	// block GRE  	if (ip.Protocol == IPProtocolType.GRE)  		continue;  	// check for port 1723 and block it  	if (ip.Protocol == IPProtocolType.TCP) {  		var tcp = TcpPacket.GetEncapsulated (packet);  		if (tcp != null && (tcp.SourcePort == 1723 || tcp.DestinationPort == 1723))  			continue;  	}  }  
Magic Number,Nighthawk,ARPTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\ARPTools.cs,WorkerRouter,The following statement contains a magic number: if (blockPPTP && sourceIP != deviceInfo.IP && destinationIP != deviceInfo.IP) {  	// block GRE  	if (ip.Protocol == IPProtocolType.GRE)  		continue;  	// check for port 1723 and block it  	if (ip.Protocol == IPProtocolType.TCP) {  		var tcp = TcpPacket.GetEncapsulated (packet);  		if (tcp != null && (tcp.SourcePort == 1723 || tcp.DestinationPort == 1723))  			continue;  	}  }  
Magic Number,Nighthawk,ARPTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\ARPTools.cs,WorkerRouter,The following statement contains a magic number: if (ip.Protocol == IPProtocolType.TCP) {  	var tcp = TcpPacket.GetEncapsulated (packet);  	if (tcp != null && (tcp.SourcePort == 1723 || tcp.DestinationPort == 1723))  		continue;  }  
Magic Number,Nighthawk,ARPTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\ARPTools.cs,WorkerRouter,The following statement contains a magic number: if (ip.Protocol == IPProtocolType.TCP) {  	var tcp = TcpPacket.GetEncapsulated (packet);  	if (tcp != null && (tcp.SourcePort == 1723 || tcp.DestinationPort == 1723))  		continue;  }  
Magic Number,Nighthawk,ARPTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\ARPTools.cs,WorkerRouter,The following statement contains a magic number: if (tcp != null && (tcp.SourcePort == 1723 || tcp.DestinationPort == 1723))  	continue;  
Magic Number,Nighthawk,ARPTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\ARPTools.cs,WorkerRouter,The following statement contains a magic number: if (tcp != null && (tcp.SourcePort == 1723 || tcp.DestinationPort == 1723))  	continue;  
Magic Number,Nighthawk,NDTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\NDTools.cs,GetIPv6Gateway,The following statement contains a magic number: if (system.Version.Major > 5) {  	p.StartInfo.Arguments = "/k netsh int ipv6 show route | findstr ::/0 && exit";  	p.Start ();  	var output = p.StandardOutput.ReadToEnd ();  	p.WaitForExit ();  	p.Dispose ();  	var lines = output.Contains ("\r\n") ? Regex.Split (output' "\r\n") : new string[] {  		output  	};  	var line = lines.First ();  	var parts = Regex.Split (line' " ");  	var gateway = parts [parts.Length - 1];  	return gateway;  }  
Magic Number,Nighthawk,NDTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\NDTools.cs,WorkerSender,The following statement contains a magic number: while (SpoofingStarted) {  	// we need to generate packets inside the loop' because IPv6toMACTargets can change (86 bytes for ND' 166 for RA ?)  	var sendQueue = new SendQueue (IPv6toMACTargets.Count * 86 + 166 + 512);  	sendQueue.Add (GenerateRouterAdvertisement (prefix).Bytes);  	foreach (var target in IPv6toMACTargets) {  		// send spoofed ND advertisements to the gateway  		if (target.Key != gatewayIPv6)  			sendQueue.Add (GenerateNDAdvertisement (target.Key).Bytes);  	}  	sendQueue.Transmit (device' SendQueueTransmitModes.Normal);  	sendQueue.Dispose ();  	Thread.Sleep (2500);  }  
Magic Number,Nighthawk,NDTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\NDTools.cs,WorkerSender,The following statement contains a magic number: while (SpoofingStarted) {  	// we need to generate packets inside the loop' because IPv6toMACTargets can change (86 bytes for ND' 166 for RA ?)  	var sendQueue = new SendQueue (IPv6toMACTargets.Count * 86 + 166 + 512);  	sendQueue.Add (GenerateRouterAdvertisement (prefix).Bytes);  	foreach (var target in IPv6toMACTargets) {  		// send spoofed ND advertisements to the gateway  		if (target.Key != gatewayIPv6)  			sendQueue.Add (GenerateNDAdvertisement (target.Key).Bytes);  	}  	sendQueue.Transmit (device' SendQueueTransmitModes.Normal);  	sendQueue.Dispose ();  	Thread.Sleep (2500);  }  
Magic Number,Nighthawk,NDTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\NDTools.cs,WorkerSender,The following statement contains a magic number: while (SpoofingStarted) {  	// we need to generate packets inside the loop' because IPv6toMACTargets can change (86 bytes for ND' 166 for RA ?)  	var sendQueue = new SendQueue (IPv6toMACTargets.Count * 86 + 166 + 512);  	sendQueue.Add (GenerateRouterAdvertisement (prefix).Bytes);  	foreach (var target in IPv6toMACTargets) {  		// send spoofed ND advertisements to the gateway  		if (target.Key != gatewayIPv6)  			sendQueue.Add (GenerateNDAdvertisement (target.Key).Bytes);  	}  	sendQueue.Transmit (device' SendQueueTransmitModes.Normal);  	sendQueue.Dispose ();  	Thread.Sleep (2500);  }  
Magic Number,Nighthawk,NDTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\NDTools.cs,WorkerSender,The following statement contains a magic number: while (SpoofingStarted) {  	// we need to generate packets inside the loop' because IPv6toMACTargets can change (86 bytes for ND' 166 for RA ?)  	var sendQueue = new SendQueue (IPv6toMACTargets.Count * 86 + 166 + 512);  	sendQueue.Add (GenerateRouterAdvertisement (prefix).Bytes);  	foreach (var target in IPv6toMACTargets) {  		// send spoofed ND advertisements to the gateway  		if (target.Key != gatewayIPv6)  			sendQueue.Add (GenerateNDAdvertisement (target.Key).Bytes);  	}  	sendQueue.Transmit (device' SendQueueTransmitModes.Normal);  	sendQueue.Dispose ();  	Thread.Sleep (2500);  }  
Magic Number,Nighthawk,NDTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\NDTools.cs,WorkerSender,The following statement contains a magic number: Thread.Sleep (2500);  
Magic Number,Nighthawk,NDTools,D:\newReposJune17\klemenb_nighthawk\Nighthawk\NDTools.cs,WorkerRouter,The following statement contains a magic number: while (SpoofingStarted) {  	// size of packets - needed for send queue (set some starting value - it seems the length is not set correctly during threadQueue packet copying)  	int bufferSize = 2048;  	// copy packets to threadRoutingQueue  	lock (PacketQueueRouting) {  		foreach (Packet packet in PacketQueueRouting) {  			threadQueueRouting.Add (packet);  			bufferSize += packet.Bytes.Length;  		}  		PacketQueueRouting.Clear ();  	}  	if (threadQueueRouting.Count > 0) {  		var sendQueue = new SendQueue (bufferSize);  		// loop through packets and change MAC addresses  		foreach (Packet packet in threadQueueRouting) {  			if (packet == null)  				continue;  			var ethernetPacket = (packet as EthernetPacket);  			if (ethernetPacket == null)  				continue;  			var ip = (packet is IpPacket ? (IpPacket)packet : IpPacket.GetEncapsulated (packet));  			var sourceIP = ip.SourceAddress.ToString ();  			var destinationIP = ip.DestinationAddress.ToString ();  			var destinationMAC = ethernetPacket.DestinationHwAddress.ToString ();  			if (sourceIP == deviceInfo.IPv6 || destinationIP == deviceInfo.IPv6)  				continue;  			// skip local network traffic  			if ((sourceIP.Contains (prefix.Replace ("::"' ":")) && destinationIP.Contains (prefix.Replace ("::"' ":"))) || (sourceIP.Contains ("fe80::") || destinationIP.Contains ("fe80::")))  				continue;  			// check for IPv6 - MAC entry existance (check only addresses from this network) and add it if necessary (we need this because scanner cannot pick up IPv6 addresses of all the targets)  			if (sourceIP.Contains (prefix.Replace ("::"' ":")) && !IPv6toMACTargets.ContainsKey (sourceIP) && !sourceIP.Contains ("fe80::")) {  				lock (IPv6toMACTargets) {  					IPv6toMACTargets.Add (sourceIP' ethernetPacket.SourceHwAddress);  				}  			}  			// incoming packets (internet -> nighthawk) - change destination MAC back to target's MAC  			if (IPv6toMACTargets.ContainsKey (destinationIP) && (destinationMAC != IPv6toMACTargets [destinationIP].ToString ())) {  				ethernetPacket.SourceHwAddress = physicalAddress;  				ethernetPacket.DestinationHwAddress = IPv6toMACTargets [destinationIP];  				if (ethernetPacket.Bytes != null)  					sendQueue.Add (packet.Bytes);  			}  			// outgoing packets (targets -> nighthawk) - change destination MAC to gateway's MAC  			if (IPv6toMACTargets.ContainsKey (sourceIP) && (destinationMAC != IPv6toMACTargets [gatewayIPv6].ToString ())) {  				ethernetPacket.SourceHwAddress = physicalAddress;  				ethernetPacket.DestinationHwAddress = IPv6toMACTargets [gatewayIPv6];  				if (ethernetPacket.Bytes != null)  					sendQueue.Add (packet.Bytes);  			}  		}  		sendQueue.Transmit (device' SendQueueTransmitModes.Normal);  		sendQueue.Dispose ();  		threadQueueRouting.Clear ();  	} else {  		Thread.Sleep (1);  	}  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,StopDevice,The following statement contains a magic number: Device.StopCaptureTimeout = TimeSpan.FromMilliseconds (200);  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,LoadOUI,The following statement contains a magic number: foreach (var line in dbLines) {  	if (!line.StartsWith ("#") && line.Length > 5) {  		var macSegment = line.Substring (0' 8).Replace ("-"' "");  		var vendor = line.Substring (9' line.Length - 9);  		if (!Vendors.ContainsKey (macSegment))  			Vendors.Add (macSegment' vendor);  	}  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,LoadOUI,The following statement contains a magic number: foreach (var line in dbLines) {  	if (!line.StartsWith ("#") && line.Length > 5) {  		var macSegment = line.Substring (0' 8).Replace ("-"' "");  		var vendor = line.Substring (9' line.Length - 9);  		if (!Vendors.ContainsKey (macSegment))  			Vendors.Add (macSegment' vendor);  	}  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,LoadOUI,The following statement contains a magic number: foreach (var line in dbLines) {  	if (!line.StartsWith ("#") && line.Length > 5) {  		var macSegment = line.Substring (0' 8).Replace ("-"' "");  		var vendor = line.Substring (9' line.Length - 9);  		if (!Vendors.ContainsKey (macSegment))  			Vendors.Add (macSegment' vendor);  	}  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,LoadOUI,The following statement contains a magic number: foreach (var line in dbLines) {  	if (!line.StartsWith ("#") && line.Length > 5) {  		var macSegment = line.Substring (0' 8).Replace ("-"' "");  		var vendor = line.Substring (9' line.Length - 9);  		if (!Vendors.ContainsKey (macSegment))  			Vendors.Add (macSegment' vendor);  	}  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,LoadOUI,The following statement contains a magic number: if (!line.StartsWith ("#") && line.Length > 5) {  	var macSegment = line.Substring (0' 8).Replace ("-"' "");  	var vendor = line.Substring (9' line.Length - 9);  	if (!Vendors.ContainsKey (macSegment))  		Vendors.Add (macSegment' vendor);  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,LoadOUI,The following statement contains a magic number: if (!line.StartsWith ("#") && line.Length > 5) {  	var macSegment = line.Substring (0' 8).Replace ("-"' "");  	var vendor = line.Substring (9' line.Length - 9);  	if (!Vendors.ContainsKey (macSegment))  		Vendors.Add (macSegment' vendor);  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,LoadOUI,The following statement contains a magic number: if (!line.StartsWith ("#") && line.Length > 5) {  	var macSegment = line.Substring (0' 8).Replace ("-"' "");  	var vendor = line.Substring (9' line.Length - 9);  	if (!Vendors.ContainsKey (macSegment))  		Vendors.Add (macSegment' vendor);  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,LoadOUI,The following statement contains a magic number: if (!line.StartsWith ("#") && line.Length > 5) {  	var macSegment = line.Substring (0' 8).Replace ("-"' "");  	var vendor = line.Substring (9' line.Length - 9);  	if (!Vendors.ContainsKey (macSegment))  		Vendors.Add (macSegment' vendor);  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,device_OnPacketArrival,The following statement contains a magic number: if (packet is EthernetPacket) {  	var tcp = TcpPacket.GetEncapsulated (packet);  	var arp = ARPPacket.GetEncapsulated (packet);  	var ip = IpPacket.GetEncapsulated (packet);  	var icmpv6 = ICMPv6Packet.GetEncapsulated (packet);  	// ARP packet  	if (arp != null) {  		if (Scanner.Started) {  			lock (Scanner.PacketQueueARP) {  				Scanner.PacketQueueARP.Add (arp);  			}  		}  	}  	// ICMPv6 packet  	if (icmpv6 != null) {  		if (Scanner.Started) {  			lock (Scanner.PacketQueueNDP) {  				icmpv6.ParentPacket = ip;  				icmpv6.ParentPacket.ParentPacket = packet;  				Scanner.PacketQueueNDP.Add (icmpv6);  			}  		}  	}  	// TCP packet  	if (tcp != null) {  		// HTTP' FTP' IMAP' POP3' SMTP packets (client -> server)  		if (tcp.DestinationPort == 80 || tcp.DestinationPort == 21 || tcp.DestinationPort == 143 || tcp.DestinationPort == 110 || tcp.DestinationPort == 25) {  			if (Sniffer.Started) {  				lock (Sniffer.PacketQueue) {  					Sniffer.PacketQueue.Add (tcp);  				}  			}  		}  		// SSL stripping needs HTTP in & out  		if (tcp.DestinationPort == 80 || tcp.SourcePort == 80) {  			if (SSLStrip.Started) {  				if (!SSLStrip.ProcessPacket (packet' tcp))  					return;  			}  		}  	}  	// IP packet  	if (ip != null) {  		// route IPv4  		if (ARPTools.SpoofingStarted && ip.SourceAddress.AddressFamily == AddressFamily.InterNetwork) {  			lock (ARPTools.PacketQueueRouting) {  				ARPTools.PacketQueueRouting.Add (packet);  			}  		}  		// route IPv6  		if (NDTools.SpoofingStarted && ip.SourceAddress.AddressFamily == AddressFamily.InterNetworkV6) {  			lock (NDTools.PacketQueueRouting) {  				NDTools.PacketQueueRouting.Add (packet);  			}  		}  	}  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,device_OnPacketArrival,The following statement contains a magic number: if (packet is EthernetPacket) {  	var tcp = TcpPacket.GetEncapsulated (packet);  	var arp = ARPPacket.GetEncapsulated (packet);  	var ip = IpPacket.GetEncapsulated (packet);  	var icmpv6 = ICMPv6Packet.GetEncapsulated (packet);  	// ARP packet  	if (arp != null) {  		if (Scanner.Started) {  			lock (Scanner.PacketQueueARP) {  				Scanner.PacketQueueARP.Add (arp);  			}  		}  	}  	// ICMPv6 packet  	if (icmpv6 != null) {  		if (Scanner.Started) {  			lock (Scanner.PacketQueueNDP) {  				icmpv6.ParentPacket = ip;  				icmpv6.ParentPacket.ParentPacket = packet;  				Scanner.PacketQueueNDP.Add (icmpv6);  			}  		}  	}  	// TCP packet  	if (tcp != null) {  		// HTTP' FTP' IMAP' POP3' SMTP packets (client -> server)  		if (tcp.DestinationPort == 80 || tcp.DestinationPort == 21 || tcp.DestinationPort == 143 || tcp.DestinationPort == 110 || tcp.DestinationPort == 25) {  			if (Sniffer.Started) {  				lock (Sniffer.PacketQueue) {  					Sniffer.PacketQueue.Add (tcp);  				}  			}  		}  		// SSL stripping needs HTTP in & out  		if (tcp.DestinationPort == 80 || tcp.SourcePort == 80) {  			if (SSLStrip.Started) {  				if (!SSLStrip.ProcessPacket (packet' tcp))  					return;  			}  		}  	}  	// IP packet  	if (ip != null) {  		// route IPv4  		if (ARPTools.SpoofingStarted && ip.SourceAddress.AddressFamily == AddressFamily.InterNetwork) {  			lock (ARPTools.PacketQueueRouting) {  				ARPTools.PacketQueueRouting.Add (packet);  			}  		}  		// route IPv6  		if (NDTools.SpoofingStarted && ip.SourceAddress.AddressFamily == AddressFamily.InterNetworkV6) {  			lock (NDTools.PacketQueueRouting) {  				NDTools.PacketQueueRouting.Add (packet);  			}  		}  	}  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,device_OnPacketArrival,The following statement contains a magic number: if (packet is EthernetPacket) {  	var tcp = TcpPacket.GetEncapsulated (packet);  	var arp = ARPPacket.GetEncapsulated (packet);  	var ip = IpPacket.GetEncapsulated (packet);  	var icmpv6 = ICMPv6Packet.GetEncapsulated (packet);  	// ARP packet  	if (arp != null) {  		if (Scanner.Started) {  			lock (Scanner.PacketQueueARP) {  				Scanner.PacketQueueARP.Add (arp);  			}  		}  	}  	// ICMPv6 packet  	if (icmpv6 != null) {  		if (Scanner.Started) {  			lock (Scanner.PacketQueueNDP) {  				icmpv6.ParentPacket = ip;  				icmpv6.ParentPacket.ParentPacket = packet;  				Scanner.PacketQueueNDP.Add (icmpv6);  			}  		}  	}  	// TCP packet  	if (tcp != null) {  		// HTTP' FTP' IMAP' POP3' SMTP packets (client -> server)  		if (tcp.DestinationPort == 80 || tcp.DestinationPort == 21 || tcp.DestinationPort == 143 || tcp.DestinationPort == 110 || tcp.DestinationPort == 25) {  			if (Sniffer.Started) {  				lock (Sniffer.PacketQueue) {  					Sniffer.PacketQueue.Add (tcp);  				}  			}  		}  		// SSL stripping needs HTTP in & out  		if (tcp.DestinationPort == 80 || tcp.SourcePort == 80) {  			if (SSLStrip.Started) {  				if (!SSLStrip.ProcessPacket (packet' tcp))  					return;  			}  		}  	}  	// IP packet  	if (ip != null) {  		// route IPv4  		if (ARPTools.SpoofingStarted && ip.SourceAddress.AddressFamily == AddressFamily.InterNetwork) {  			lock (ARPTools.PacketQueueRouting) {  				ARPTools.PacketQueueRouting.Add (packet);  			}  		}  		// route IPv6  		if (NDTools.SpoofingStarted && ip.SourceAddress.AddressFamily == AddressFamily.InterNetworkV6) {  			lock (NDTools.PacketQueueRouting) {  				NDTools.PacketQueueRouting.Add (packet);  			}  		}  	}  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,device_OnPacketArrival,The following statement contains a magic number: if (packet is EthernetPacket) {  	var tcp = TcpPacket.GetEncapsulated (packet);  	var arp = ARPPacket.GetEncapsulated (packet);  	var ip = IpPacket.GetEncapsulated (packet);  	var icmpv6 = ICMPv6Packet.GetEncapsulated (packet);  	// ARP packet  	if (arp != null) {  		if (Scanner.Started) {  			lock (Scanner.PacketQueueARP) {  				Scanner.PacketQueueARP.Add (arp);  			}  		}  	}  	// ICMPv6 packet  	if (icmpv6 != null) {  		if (Scanner.Started) {  			lock (Scanner.PacketQueueNDP) {  				icmpv6.ParentPacket = ip;  				icmpv6.ParentPacket.ParentPacket = packet;  				Scanner.PacketQueueNDP.Add (icmpv6);  			}  		}  	}  	// TCP packet  	if (tcp != null) {  		// HTTP' FTP' IMAP' POP3' SMTP packets (client -> server)  		if (tcp.DestinationPort == 80 || tcp.DestinationPort == 21 || tcp.DestinationPort == 143 || tcp.DestinationPort == 110 || tcp.DestinationPort == 25) {  			if (Sniffer.Started) {  				lock (Sniffer.PacketQueue) {  					Sniffer.PacketQueue.Add (tcp);  				}  			}  		}  		// SSL stripping needs HTTP in & out  		if (tcp.DestinationPort == 80 || tcp.SourcePort == 80) {  			if (SSLStrip.Started) {  				if (!SSLStrip.ProcessPacket (packet' tcp))  					return;  			}  		}  	}  	// IP packet  	if (ip != null) {  		// route IPv4  		if (ARPTools.SpoofingStarted && ip.SourceAddress.AddressFamily == AddressFamily.InterNetwork) {  			lock (ARPTools.PacketQueueRouting) {  				ARPTools.PacketQueueRouting.Add (packet);  			}  		}  		// route IPv6  		if (NDTools.SpoofingStarted && ip.SourceAddress.AddressFamily == AddressFamily.InterNetworkV6) {  			lock (NDTools.PacketQueueRouting) {  				NDTools.PacketQueueRouting.Add (packet);  			}  		}  	}  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,device_OnPacketArrival,The following statement contains a magic number: if (packet is EthernetPacket) {  	var tcp = TcpPacket.GetEncapsulated (packet);  	var arp = ARPPacket.GetEncapsulated (packet);  	var ip = IpPacket.GetEncapsulated (packet);  	var icmpv6 = ICMPv6Packet.GetEncapsulated (packet);  	// ARP packet  	if (arp != null) {  		if (Scanner.Started) {  			lock (Scanner.PacketQueueARP) {  				Scanner.PacketQueueARP.Add (arp);  			}  		}  	}  	// ICMPv6 packet  	if (icmpv6 != null) {  		if (Scanner.Started) {  			lock (Scanner.PacketQueueNDP) {  				icmpv6.ParentPacket = ip;  				icmpv6.ParentPacket.ParentPacket = packet;  				Scanner.PacketQueueNDP.Add (icmpv6);  			}  		}  	}  	// TCP packet  	if (tcp != null) {  		// HTTP' FTP' IMAP' POP3' SMTP packets (client -> server)  		if (tcp.DestinationPort == 80 || tcp.DestinationPort == 21 || tcp.DestinationPort == 143 || tcp.DestinationPort == 110 || tcp.DestinationPort == 25) {  			if (Sniffer.Started) {  				lock (Sniffer.PacketQueue) {  					Sniffer.PacketQueue.Add (tcp);  				}  			}  		}  		// SSL stripping needs HTTP in & out  		if (tcp.DestinationPort == 80 || tcp.SourcePort == 80) {  			if (SSLStrip.Started) {  				if (!SSLStrip.ProcessPacket (packet' tcp))  					return;  			}  		}  	}  	// IP packet  	if (ip != null) {  		// route IPv4  		if (ARPTools.SpoofingStarted && ip.SourceAddress.AddressFamily == AddressFamily.InterNetwork) {  			lock (ARPTools.PacketQueueRouting) {  				ARPTools.PacketQueueRouting.Add (packet);  			}  		}  		// route IPv6  		if (NDTools.SpoofingStarted && ip.SourceAddress.AddressFamily == AddressFamily.InterNetworkV6) {  			lock (NDTools.PacketQueueRouting) {  				NDTools.PacketQueueRouting.Add (packet);  			}  		}  	}  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,device_OnPacketArrival,The following statement contains a magic number: if (packet is EthernetPacket) {  	var tcp = TcpPacket.GetEncapsulated (packet);  	var arp = ARPPacket.GetEncapsulated (packet);  	var ip = IpPacket.GetEncapsulated (packet);  	var icmpv6 = ICMPv6Packet.GetEncapsulated (packet);  	// ARP packet  	if (arp != null) {  		if (Scanner.Started) {  			lock (Scanner.PacketQueueARP) {  				Scanner.PacketQueueARP.Add (arp);  			}  		}  	}  	// ICMPv6 packet  	if (icmpv6 != null) {  		if (Scanner.Started) {  			lock (Scanner.PacketQueueNDP) {  				icmpv6.ParentPacket = ip;  				icmpv6.ParentPacket.ParentPacket = packet;  				Scanner.PacketQueueNDP.Add (icmpv6);  			}  		}  	}  	// TCP packet  	if (tcp != null) {  		// HTTP' FTP' IMAP' POP3' SMTP packets (client -> server)  		if (tcp.DestinationPort == 80 || tcp.DestinationPort == 21 || tcp.DestinationPort == 143 || tcp.DestinationPort == 110 || tcp.DestinationPort == 25) {  			if (Sniffer.Started) {  				lock (Sniffer.PacketQueue) {  					Sniffer.PacketQueue.Add (tcp);  				}  			}  		}  		// SSL stripping needs HTTP in & out  		if (tcp.DestinationPort == 80 || tcp.SourcePort == 80) {  			if (SSLStrip.Started) {  				if (!SSLStrip.ProcessPacket (packet' tcp))  					return;  			}  		}  	}  	// IP packet  	if (ip != null) {  		// route IPv4  		if (ARPTools.SpoofingStarted && ip.SourceAddress.AddressFamily == AddressFamily.InterNetwork) {  			lock (ARPTools.PacketQueueRouting) {  				ARPTools.PacketQueueRouting.Add (packet);  			}  		}  		// route IPv6  		if (NDTools.SpoofingStarted && ip.SourceAddress.AddressFamily == AddressFamily.InterNetworkV6) {  			lock (NDTools.PacketQueueRouting) {  				NDTools.PacketQueueRouting.Add (packet);  			}  		}  	}  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,device_OnPacketArrival,The following statement contains a magic number: if (packet is EthernetPacket) {  	var tcp = TcpPacket.GetEncapsulated (packet);  	var arp = ARPPacket.GetEncapsulated (packet);  	var ip = IpPacket.GetEncapsulated (packet);  	var icmpv6 = ICMPv6Packet.GetEncapsulated (packet);  	// ARP packet  	if (arp != null) {  		if (Scanner.Started) {  			lock (Scanner.PacketQueueARP) {  				Scanner.PacketQueueARP.Add (arp);  			}  		}  	}  	// ICMPv6 packet  	if (icmpv6 != null) {  		if (Scanner.Started) {  			lock (Scanner.PacketQueueNDP) {  				icmpv6.ParentPacket = ip;  				icmpv6.ParentPacket.ParentPacket = packet;  				Scanner.PacketQueueNDP.Add (icmpv6);  			}  		}  	}  	// TCP packet  	if (tcp != null) {  		// HTTP' FTP' IMAP' POP3' SMTP packets (client -> server)  		if (tcp.DestinationPort == 80 || tcp.DestinationPort == 21 || tcp.DestinationPort == 143 || tcp.DestinationPort == 110 || tcp.DestinationPort == 25) {  			if (Sniffer.Started) {  				lock (Sniffer.PacketQueue) {  					Sniffer.PacketQueue.Add (tcp);  				}  			}  		}  		// SSL stripping needs HTTP in & out  		if (tcp.DestinationPort == 80 || tcp.SourcePort == 80) {  			if (SSLStrip.Started) {  				if (!SSLStrip.ProcessPacket (packet' tcp))  					return;  			}  		}  	}  	// IP packet  	if (ip != null) {  		// route IPv4  		if (ARPTools.SpoofingStarted && ip.SourceAddress.AddressFamily == AddressFamily.InterNetwork) {  			lock (ARPTools.PacketQueueRouting) {  				ARPTools.PacketQueueRouting.Add (packet);  			}  		}  		// route IPv6  		if (NDTools.SpoofingStarted && ip.SourceAddress.AddressFamily == AddressFamily.InterNetworkV6) {  			lock (NDTools.PacketQueueRouting) {  				NDTools.PacketQueueRouting.Add (packet);  			}  		}  	}  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,device_OnPacketArrival,The following statement contains a magic number: if (tcp != null) {  	// HTTP' FTP' IMAP' POP3' SMTP packets (client -> server)  	if (tcp.DestinationPort == 80 || tcp.DestinationPort == 21 || tcp.DestinationPort == 143 || tcp.DestinationPort == 110 || tcp.DestinationPort == 25) {  		if (Sniffer.Started) {  			lock (Sniffer.PacketQueue) {  				Sniffer.PacketQueue.Add (tcp);  			}  		}  	}  	// SSL stripping needs HTTP in & out  	if (tcp.DestinationPort == 80 || tcp.SourcePort == 80) {  		if (SSLStrip.Started) {  			if (!SSLStrip.ProcessPacket (packet' tcp))  				return;  		}  	}  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,device_OnPacketArrival,The following statement contains a magic number: if (tcp != null) {  	// HTTP' FTP' IMAP' POP3' SMTP packets (client -> server)  	if (tcp.DestinationPort == 80 || tcp.DestinationPort == 21 || tcp.DestinationPort == 143 || tcp.DestinationPort == 110 || tcp.DestinationPort == 25) {  		if (Sniffer.Started) {  			lock (Sniffer.PacketQueue) {  				Sniffer.PacketQueue.Add (tcp);  			}  		}  	}  	// SSL stripping needs HTTP in & out  	if (tcp.DestinationPort == 80 || tcp.SourcePort == 80) {  		if (SSLStrip.Started) {  			if (!SSLStrip.ProcessPacket (packet' tcp))  				return;  		}  	}  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,device_OnPacketArrival,The following statement contains a magic number: if (tcp != null) {  	// HTTP' FTP' IMAP' POP3' SMTP packets (client -> server)  	if (tcp.DestinationPort == 80 || tcp.DestinationPort == 21 || tcp.DestinationPort == 143 || tcp.DestinationPort == 110 || tcp.DestinationPort == 25) {  		if (Sniffer.Started) {  			lock (Sniffer.PacketQueue) {  				Sniffer.PacketQueue.Add (tcp);  			}  		}  	}  	// SSL stripping needs HTTP in & out  	if (tcp.DestinationPort == 80 || tcp.SourcePort == 80) {  		if (SSLStrip.Started) {  			if (!SSLStrip.ProcessPacket (packet' tcp))  				return;  		}  	}  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,device_OnPacketArrival,The following statement contains a magic number: if (tcp != null) {  	// HTTP' FTP' IMAP' POP3' SMTP packets (client -> server)  	if (tcp.DestinationPort == 80 || tcp.DestinationPort == 21 || tcp.DestinationPort == 143 || tcp.DestinationPort == 110 || tcp.DestinationPort == 25) {  		if (Sniffer.Started) {  			lock (Sniffer.PacketQueue) {  				Sniffer.PacketQueue.Add (tcp);  			}  		}  	}  	// SSL stripping needs HTTP in & out  	if (tcp.DestinationPort == 80 || tcp.SourcePort == 80) {  		if (SSLStrip.Started) {  			if (!SSLStrip.ProcessPacket (packet' tcp))  				return;  		}  	}  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,device_OnPacketArrival,The following statement contains a magic number: if (tcp != null) {  	// HTTP' FTP' IMAP' POP3' SMTP packets (client -> server)  	if (tcp.DestinationPort == 80 || tcp.DestinationPort == 21 || tcp.DestinationPort == 143 || tcp.DestinationPort == 110 || tcp.DestinationPort == 25) {  		if (Sniffer.Started) {  			lock (Sniffer.PacketQueue) {  				Sniffer.PacketQueue.Add (tcp);  			}  		}  	}  	// SSL stripping needs HTTP in & out  	if (tcp.DestinationPort == 80 || tcp.SourcePort == 80) {  		if (SSLStrip.Started) {  			if (!SSLStrip.ProcessPacket (packet' tcp))  				return;  		}  	}  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,device_OnPacketArrival,The following statement contains a magic number: if (tcp != null) {  	// HTTP' FTP' IMAP' POP3' SMTP packets (client -> server)  	if (tcp.DestinationPort == 80 || tcp.DestinationPort == 21 || tcp.DestinationPort == 143 || tcp.DestinationPort == 110 || tcp.DestinationPort == 25) {  		if (Sniffer.Started) {  			lock (Sniffer.PacketQueue) {  				Sniffer.PacketQueue.Add (tcp);  			}  		}  	}  	// SSL stripping needs HTTP in & out  	if (tcp.DestinationPort == 80 || tcp.SourcePort == 80) {  		if (SSLStrip.Started) {  			if (!SSLStrip.ProcessPacket (packet' tcp))  				return;  		}  	}  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,device_OnPacketArrival,The following statement contains a magic number: if (tcp != null) {  	// HTTP' FTP' IMAP' POP3' SMTP packets (client -> server)  	if (tcp.DestinationPort == 80 || tcp.DestinationPort == 21 || tcp.DestinationPort == 143 || tcp.DestinationPort == 110 || tcp.DestinationPort == 25) {  		if (Sniffer.Started) {  			lock (Sniffer.PacketQueue) {  				Sniffer.PacketQueue.Add (tcp);  			}  		}  	}  	// SSL stripping needs HTTP in & out  	if (tcp.DestinationPort == 80 || tcp.SourcePort == 80) {  		if (SSLStrip.Started) {  			if (!SSLStrip.ProcessPacket (packet' tcp))  				return;  		}  	}  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,device_OnPacketArrival,The following statement contains a magic number: if (tcp.DestinationPort == 80 || tcp.DestinationPort == 21 || tcp.DestinationPort == 143 || tcp.DestinationPort == 110 || tcp.DestinationPort == 25) {  	if (Sniffer.Started) {  		lock (Sniffer.PacketQueue) {  			Sniffer.PacketQueue.Add (tcp);  		}  	}  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,device_OnPacketArrival,The following statement contains a magic number: if (tcp.DestinationPort == 80 || tcp.DestinationPort == 21 || tcp.DestinationPort == 143 || tcp.DestinationPort == 110 || tcp.DestinationPort == 25) {  	if (Sniffer.Started) {  		lock (Sniffer.PacketQueue) {  			Sniffer.PacketQueue.Add (tcp);  		}  	}  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,device_OnPacketArrival,The following statement contains a magic number: if (tcp.DestinationPort == 80 || tcp.DestinationPort == 21 || tcp.DestinationPort == 143 || tcp.DestinationPort == 110 || tcp.DestinationPort == 25) {  	if (Sniffer.Started) {  		lock (Sniffer.PacketQueue) {  			Sniffer.PacketQueue.Add (tcp);  		}  	}  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,device_OnPacketArrival,The following statement contains a magic number: if (tcp.DestinationPort == 80 || tcp.DestinationPort == 21 || tcp.DestinationPort == 143 || tcp.DestinationPort == 110 || tcp.DestinationPort == 25) {  	if (Sniffer.Started) {  		lock (Sniffer.PacketQueue) {  			Sniffer.PacketQueue.Add (tcp);  		}  	}  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,device_OnPacketArrival,The following statement contains a magic number: if (tcp.DestinationPort == 80 || tcp.DestinationPort == 21 || tcp.DestinationPort == 143 || tcp.DestinationPort == 110 || tcp.DestinationPort == 25) {  	if (Sniffer.Started) {  		lock (Sniffer.PacketQueue) {  			Sniffer.PacketQueue.Add (tcp);  		}  	}  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,device_OnPacketArrival,The following statement contains a magic number: if (tcp.DestinationPort == 80 || tcp.SourcePort == 80) {  	if (SSLStrip.Started) {  		if (!SSLStrip.ProcessPacket (packet' tcp))  			return;  	}  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,device_OnPacketArrival,The following statement contains a magic number: if (tcp.DestinationPort == 80 || tcp.SourcePort == 80) {  	if (SSLStrip.Started) {  		if (!SSLStrip.ProcessPacket (packet' tcp))  			return;  	}  }  
Magic Number,Nighthawk,Main,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Main.cs,SSLStrip_OnSSLStripped,The following statement contains a magic number: Window.Dispatcher.BeginInvoke (new UI (delegate {  	// construct "changes"  	var changedText = string.Empty;  	foreach (var change in changed) {  		if (change != changed.Last ()) {  			changedText += change + "' ";  		} else {  			changedText += change;  		}  	}  	var text = string.Empty;  	// build whole output string  	if (sourceIP != string.Empty) {  		text = "Stripped: " + changedText + " (" + sourceIP + " -> " + destIP + ")";  	} else {  		text = "Information: " + changedText + "";  	}  	var resultText = new Run (text);  	resultText.Foreground = new SolidColorBrush (Window.ColorSSLStrip);  	var thickness = new Thickness (0' 0' 0' 5);  	var paragraph = new Paragraph (resultText);  	paragraph.Margin = thickness;  	// don't repeat the same entries  	if (lastSSLText != text) {  		lastSSLText = text;  		if (Window.TSSLText.Document.Blocks.Count > 0) {  			Window.TSSLText.Document.Blocks.InsertBefore (Window.TSSLText.Document.Blocks.First ()' paragraph);  		} else {  			Window.TSSLText.Document.Blocks.Add (paragraph);  		}  	}  }));  
Magic Number,Nighthawk,Network,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Network.cs,MaskToCIDR,The following statement contains a magic number: for (int i = 0; i < 32; i++) {  	if (!(mask & subnet).Equals (mask))  		break;  	subnetConsecutiveOnes++;  	mask = mask >> 1;  }  
Magic Number,Nighthawk,Network,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Network.cs,IPToLong,The following statement contains a magic number: if (!string.IsNullOrEmpty (addr)) {  	ipBytes = addr.Split ('.');  	for (int i = ipBytes.Length - 1; i >= 0; i--) {  		num += ((int.Parse (ipBytes [i]) % 256) * Math.Pow (256' (3 - i)));  	}  }  
Magic Number,Nighthawk,Network,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Network.cs,IPToLong,The following statement contains a magic number: if (!string.IsNullOrEmpty (addr)) {  	ipBytes = addr.Split ('.');  	for (int i = ipBytes.Length - 1; i >= 0; i--) {  		num += ((int.Parse (ipBytes [i]) % 256) * Math.Pow (256' (3 - i)));  	}  }  
Magic Number,Nighthawk,Network,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Network.cs,IPToLong,The following statement contains a magic number: if (!string.IsNullOrEmpty (addr)) {  	ipBytes = addr.Split ('.');  	for (int i = ipBytes.Length - 1; i >= 0; i--) {  		num += ((int.Parse (ipBytes [i]) % 256) * Math.Pow (256' (3 - i)));  	}  }  
Magic Number,Nighthawk,Network,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Network.cs,IPToLong,The following statement contains a magic number: for (int i = ipBytes.Length - 1; i >= 0; i--) {  	num += ((int.Parse (ipBytes [i]) % 256) * Math.Pow (256' (3 - i)));  }  
Magic Number,Nighthawk,Network,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Network.cs,IPToLong,The following statement contains a magic number: for (int i = ipBytes.Length - 1; i >= 0; i--) {  	num += ((int.Parse (ipBytes [i]) % 256) * Math.Pow (256' (3 - i)));  }  
Magic Number,Nighthawk,Network,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Network.cs,IPToLong,The following statement contains a magic number: for (int i = ipBytes.Length - 1; i >= 0; i--) {  	num += ((int.Parse (ipBytes [i]) % 256) * Math.Pow (256' (3 - i)));  }  
Magic Number,Nighthawk,Network,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Network.cs,IPToLong,The following statement contains a magic number: num += ((int.Parse (ipBytes [i]) % 256) * Math.Pow (256' (3 - i)));  
Magic Number,Nighthawk,Network,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Network.cs,IPToLong,The following statement contains a magic number: num += ((int.Parse (ipBytes [i]) % 256) * Math.Pow (256' (3 - i)));  
Magic Number,Nighthawk,Network,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Network.cs,IPToLong,The following statement contains a magic number: num += ((int.Parse (ipBytes [i]) % 256) * Math.Pow (256' (3 - i)));  
Magic Number,Nighthawk,Network,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Network.cs,FriendlyPhysicalAddress,The following statement contains a magic number: for (int i = 0; i < macString.Length; i++) {  	if (i % 2 == 0 && i > 0) {  		output += ":" + macString [i];  	} else {  		output += macString [i];  	}  }  
Magic Number,Nighthawk,Network,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Network.cs,FriendlyPhysicalAddress,The following statement contains a magic number: if (i % 2 == 0 && i > 0) {  	output += ":" + macString [i];  } else {  	output += macString [i];  }  
Magic Number,Nighthawk,Network,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Network.cs,HexToByte,The following statement contains a magic number: for (int i = 0; i < numberChars; i += 2) {  	bytes [i / 2] = Convert.ToByte (hex.Substring (i' 2)' 16);  }  
Magic Number,Nighthawk,Network,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Network.cs,HexToByte,The following statement contains a magic number: for (int i = 0; i < numberChars; i += 2) {  	bytes [i / 2] = Convert.ToByte (hex.Substring (i' 2)' 16);  }  
Magic Number,Nighthawk,Network,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Network.cs,HexToByte,The following statement contains a magic number: for (int i = 0; i < numberChars; i += 2) {  	bytes [i / 2] = Convert.ToByte (hex.Substring (i' 2)' 16);  }  
Magic Number,Nighthawk,Network,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Network.cs,HexToByte,The following statement contains a magic number: for (int i = 0; i < numberChars; i += 2) {  	bytes [i / 2] = Convert.ToByte (hex.Substring (i' 2)' 16);  }  
Magic Number,Nighthawk,Network,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Network.cs,HexToByte,The following statement contains a magic number: i += 2
Magic Number,Nighthawk,Network,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Network.cs,HexToByte,The following statement contains a magic number: bytes [i / 2] = Convert.ToByte (hex.Substring (i' 2)' 16);  
Magic Number,Nighthawk,Network,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Network.cs,HexToByte,The following statement contains a magic number: bytes [i / 2] = Convert.ToByte (hex.Substring (i' 2)' 16);  
Magic Number,Nighthawk,Network,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Network.cs,HexToByte,The following statement contains a magic number: bytes [i / 2] = Convert.ToByte (hex.Substring (i' 2)' 16);  
Magic Number,Nighthawk,Network,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Network.cs,GetPrefixFromIP,The following statement contains a magic number: return parts [0] + ":" + parts [1] + ":" + parts [2] + ":" + parts [3] + "::";  
Magic Number,Nighthawk,Network,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Network.cs,GetPrefixFromIP,The following statement contains a magic number: return parts [0] + ":" + parts [1] + ":" + parts [2] + ":" + parts [3] + "::";  
Magic Number,Nighthawk,Network,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Network.cs,GetPseudoHeader,The following statement contains a magic number: pseudoHeader = new byte[40];  
Magic Number,Nighthawk,Network,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Network.cs,GetPseudoHeader,The following statement contains a magic number: payLoadLength = IPAddress.HostToNetworkOrder (4 + icmpv6Length);  
Magic Number,Nighthawk,Scanner,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Scanner.cs,GenerateIpv6Ping,The following statement contains a magic number: icmpv6Packet.Checksum = (ushort)(ChecksumUtils.OnesComplementSum (pseudo.Concat (icmpv6Packet.Bytes).ToArray ()) + 4);  
Magic Number,Nighthawk,Scanner,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Scanner.cs,WorkerSender,The following statement contains a magic number: Thread.Sleep (3000);  
Magic Number,Nighthawk,Scanner,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Scanner.cs,WorkerARP,The following statement contains a magic number: while (Started) {  	// copy packets to thread's packet storage (threadQueue)  	lock (PacketQueueARP) {  		foreach (ARPPacket packet in PacketQueueARP) {  			threadQueueARP.Add (packet);  		}  		PacketQueueARP.Clear ();  	}  	if (threadQueueARP.Count > 0) {  		// loop through packets and parse responses  		foreach (ARPPacket packet in threadQueueARP) {  			// if we have an ARP reply (response) and scanner is still active  			if (packet.Operation == ARPOperation.Response && Started) {  				var ip = packet.SenderProtocolAddress;  				var mac = packet.SenderHardwareAddress;  				var hostname = ResolveHostnames ? "Resolving..." : String.Empty;  				// process IP if not already processed  				if (!processedIPs.Contains (ip)) {  					Response (ip.ToString ()' false' mac' hostname);  					if (ResolveHostnames) {  						// start a background resolver thread  						var resolver = new Thread (new ParameterizedThreadStart (WorkerResolver));  						resolver.Start (ip);  					}  					// start ipv6 resolver thread  					var ipv6Resolve = new Thread (new ParameterizedThreadStart (WorkerIPv6));  					ipv6Resolve.Start (mac);  				}  				processedIPs.Add (ip);  			}  		}  		threadQueueARP.Clear ();  	} else {  		Thread.Sleep (50);  	}  }  
Magic Number,Nighthawk,Scanner,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Scanner.cs,WorkerARP,The following statement contains a magic number: if (threadQueueARP.Count > 0) {  	// loop through packets and parse responses  	foreach (ARPPacket packet in threadQueueARP) {  		// if we have an ARP reply (response) and scanner is still active  		if (packet.Operation == ARPOperation.Response && Started) {  			var ip = packet.SenderProtocolAddress;  			var mac = packet.SenderHardwareAddress;  			var hostname = ResolveHostnames ? "Resolving..." : String.Empty;  			// process IP if not already processed  			if (!processedIPs.Contains (ip)) {  				Response (ip.ToString ()' false' mac' hostname);  				if (ResolveHostnames) {  					// start a background resolver thread  					var resolver = new Thread (new ParameterizedThreadStart (WorkerResolver));  					resolver.Start (ip);  				}  				// start ipv6 resolver thread  				var ipv6Resolve = new Thread (new ParameterizedThreadStart (WorkerIPv6));  				ipv6Resolve.Start (mac);  			}  			processedIPs.Add (ip);  		}  	}  	threadQueueARP.Clear ();  } else {  	Thread.Sleep (50);  }  
Magic Number,Nighthawk,Scanner,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Scanner.cs,WorkerARP,The following statement contains a magic number: Thread.Sleep (50);  
Magic Number,Nighthawk,Scanner,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Scanner.cs,WorkerICMPv6,The following statement contains a magic number: while (Started) {  	// copy packets to thread's packet storage (threadQueue)  	lock (PacketQueueNDP) {  		foreach (ICMPv6Packet packet in PacketQueueNDP) {  			threadQueueNDP.Add (packet);  		}  		PacketQueueNDP.Clear ();  	}  	if (threadQueueNDP.Count > 0) {  		// loop through packets and parse them  		foreach (ICMPv6Packet packet in threadQueueNDP) {  			// if we have a ping reply  			if (packet.Bytes.Count () > 0 && packet.Bytes [0] == 129) {  				if (packet.ParentPacket == null || packet.ParentPacket.ParentPacket == null)  					continue;  				var ip = ((IPv6Packet)packet.ParentPacket).SourceAddress;  				var mac = ((EthernetPacket)packet.ParentPacket.ParentPacket).SourceHwAddress;  				Response (ip.ToString ()' true' mac' "");  			}  		}  		threadQueueNDP.Clear ();  	} else {  		Thread.Sleep (50);  	}  }  
Magic Number,Nighthawk,Scanner,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Scanner.cs,WorkerICMPv6,The following statement contains a magic number: while (Started) {  	// copy packets to thread's packet storage (threadQueue)  	lock (PacketQueueNDP) {  		foreach (ICMPv6Packet packet in PacketQueueNDP) {  			threadQueueNDP.Add (packet);  		}  		PacketQueueNDP.Clear ();  	}  	if (threadQueueNDP.Count > 0) {  		// loop through packets and parse them  		foreach (ICMPv6Packet packet in threadQueueNDP) {  			// if we have a ping reply  			if (packet.Bytes.Count () > 0 && packet.Bytes [0] == 129) {  				if (packet.ParentPacket == null || packet.ParentPacket.ParentPacket == null)  					continue;  				var ip = ((IPv6Packet)packet.ParentPacket).SourceAddress;  				var mac = ((EthernetPacket)packet.ParentPacket.ParentPacket).SourceHwAddress;  				Response (ip.ToString ()' true' mac' "");  			}  		}  		threadQueueNDP.Clear ();  	} else {  		Thread.Sleep (50);  	}  }  
Magic Number,Nighthawk,Scanner,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Scanner.cs,WorkerICMPv6,The following statement contains a magic number: if (threadQueueNDP.Count > 0) {  	// loop through packets and parse them  	foreach (ICMPv6Packet packet in threadQueueNDP) {  		// if we have a ping reply  		if (packet.Bytes.Count () > 0 && packet.Bytes [0] == 129) {  			if (packet.ParentPacket == null || packet.ParentPacket.ParentPacket == null)  				continue;  			var ip = ((IPv6Packet)packet.ParentPacket).SourceAddress;  			var mac = ((EthernetPacket)packet.ParentPacket.ParentPacket).SourceHwAddress;  			Response (ip.ToString ()' true' mac' "");  		}  	}  	threadQueueNDP.Clear ();  } else {  	Thread.Sleep (50);  }  
Magic Number,Nighthawk,Scanner,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Scanner.cs,WorkerICMPv6,The following statement contains a magic number: if (threadQueueNDP.Count > 0) {  	// loop through packets and parse them  	foreach (ICMPv6Packet packet in threadQueueNDP) {  		// if we have a ping reply  		if (packet.Bytes.Count () > 0 && packet.Bytes [0] == 129) {  			if (packet.ParentPacket == null || packet.ParentPacket.ParentPacket == null)  				continue;  			var ip = ((IPv6Packet)packet.ParentPacket).SourceAddress;  			var mac = ((EthernetPacket)packet.ParentPacket.ParentPacket).SourceHwAddress;  			Response (ip.ToString ()' true' mac' "");  		}  	}  	threadQueueNDP.Clear ();  } else {  	Thread.Sleep (50);  }  
Magic Number,Nighthawk,Scanner,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Scanner.cs,WorkerICMPv6,The following statement contains a magic number: foreach (ICMPv6Packet packet in threadQueueNDP) {  	// if we have a ping reply  	if (packet.Bytes.Count () > 0 && packet.Bytes [0] == 129) {  		if (packet.ParentPacket == null || packet.ParentPacket.ParentPacket == null)  			continue;  		var ip = ((IPv6Packet)packet.ParentPacket).SourceAddress;  		var mac = ((EthernetPacket)packet.ParentPacket.ParentPacket).SourceHwAddress;  		Response (ip.ToString ()' true' mac' "");  	}  }  
Magic Number,Nighthawk,Scanner,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Scanner.cs,WorkerICMPv6,The following statement contains a magic number: if (packet.Bytes.Count () > 0 && packet.Bytes [0] == 129) {  	if (packet.ParentPacket == null || packet.ParentPacket.ParentPacket == null)  		continue;  	var ip = ((IPv6Packet)packet.ParentPacket).SourceAddress;  	var mac = ((EthernetPacket)packet.ParentPacket.ParentPacket).SourceHwAddress;  	Response (ip.ToString ()' true' mac' "");  }  
Magic Number,Nighthawk,Scanner,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Scanner.cs,WorkerICMPv6,The following statement contains a magic number: Thread.Sleep (50);  
Magic Number,Nighthawk,Scanner,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Scanner.cs,WorkerResolver,The following statement contains a magic number: Thread.Sleep (100);  
Magic Number,Nighthawk,Scanner,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Scanner.cs,GetIPv6Address,The following statement contains a magic number: if (system.Version.Major > 5) {  	p.StartInfo.Arguments = "/C netsh int ipv6 show neigh | findstr " + macString + "";  	p.Start ();  	var output = p.StandardOutput.ReadToEnd ();  	p.WaitForExit ();  	p.Dispose ();  	var lines = output.Contains ("\r\n") ? Regex.Split (output' "\r\n") : new string[] {  		output  	};  	var ipv6List = new List<string> ();  	foreach (var line in lines) {  		// skip last line  		if (line == lines.Last ())  			continue;  		var split = line.Split (' ');  		if (split [0].Trim () != string.Empty)  			ipv6List.Add (split [0].Trim ());  	}  	return ipv6List;  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: while (Started) {  	// copy packets to threadQueue  	lock (PacketQueue) {  		foreach (TcpPacket packet in PacketQueue) {  			threadQueue.Add (packet);  		}  		PacketQueue.Clear ();  	}  	if (threadQueue.Count > 0) {  		// loop through packets and check them for any useful information  		foreach (TcpPacket packet in threadQueue) {  			if (packet.ParentPacket == null)  				continue;  			var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  			var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  			// check for exclusions  			if (excludeLocalIP) {  				if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  					continue;  				}  			}  			// check for FTP packet  			if (packet.DestinationPort == 21) {  				var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  						ftpLogins.Remove (login);  					}  				} else {  					ftpLogins.Add (new SnifferFTPlogin {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for IMAP  			if (packet.DestinationPort == 143) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// TAG LOGIN "username" "password"  				var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  				var matches = SimpleRegex.GetMatches (regexIMAP' data);  				if (matches.Count > 0) {  					Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  				}  				continue;  			}  			// check for SMTP  			if (packet.DestinationPort == 25) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// AUTH PLAIN base64  				var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  				var matches = SimpleRegex.GetMatches (regexSMTP' data);  				if (matches.Count > 0) {  					var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  					if (credentials.Length > 2)  						Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  				}  				continue;  			}  			// check for POP3  			if (packet.DestinationPort == 110) {  				var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  						pop3Logins.Remove (login);  					}  				} else {  					pop3Logins.Add (new SnifferPOP3login {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for HTTP packet and parse it  			if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  				var http = new HttpPacket (packet);  				// save hostnames for incomplete packets  				if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  					postRequests.Add (new SnifferPostRequest {  						SourceAddress = sourceIP'  						DestinationAddress = destIP'  						Hostname = http.Header.Host  					});  				}  				SnifferSearch (http' sourceIP' destIP);  			}  		}  		threadQueue.Clear ();  	} else {  		Thread.Sleep (50);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: while (Started) {  	// copy packets to threadQueue  	lock (PacketQueue) {  		foreach (TcpPacket packet in PacketQueue) {  			threadQueue.Add (packet);  		}  		PacketQueue.Clear ();  	}  	if (threadQueue.Count > 0) {  		// loop through packets and check them for any useful information  		foreach (TcpPacket packet in threadQueue) {  			if (packet.ParentPacket == null)  				continue;  			var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  			var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  			// check for exclusions  			if (excludeLocalIP) {  				if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  					continue;  				}  			}  			// check for FTP packet  			if (packet.DestinationPort == 21) {  				var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  						ftpLogins.Remove (login);  					}  				} else {  					ftpLogins.Add (new SnifferFTPlogin {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for IMAP  			if (packet.DestinationPort == 143) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// TAG LOGIN "username" "password"  				var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  				var matches = SimpleRegex.GetMatches (regexIMAP' data);  				if (matches.Count > 0) {  					Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  				}  				continue;  			}  			// check for SMTP  			if (packet.DestinationPort == 25) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// AUTH PLAIN base64  				var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  				var matches = SimpleRegex.GetMatches (regexSMTP' data);  				if (matches.Count > 0) {  					var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  					if (credentials.Length > 2)  						Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  				}  				continue;  			}  			// check for POP3  			if (packet.DestinationPort == 110) {  				var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  						pop3Logins.Remove (login);  					}  				} else {  					pop3Logins.Add (new SnifferPOP3login {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for HTTP packet and parse it  			if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  				var http = new HttpPacket (packet);  				// save hostnames for incomplete packets  				if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  					postRequests.Add (new SnifferPostRequest {  						SourceAddress = sourceIP'  						DestinationAddress = destIP'  						Hostname = http.Header.Host  					});  				}  				SnifferSearch (http' sourceIP' destIP);  			}  		}  		threadQueue.Clear ();  	} else {  		Thread.Sleep (50);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: while (Started) {  	// copy packets to threadQueue  	lock (PacketQueue) {  		foreach (TcpPacket packet in PacketQueue) {  			threadQueue.Add (packet);  		}  		PacketQueue.Clear ();  	}  	if (threadQueue.Count > 0) {  		// loop through packets and check them for any useful information  		foreach (TcpPacket packet in threadQueue) {  			if (packet.ParentPacket == null)  				continue;  			var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  			var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  			// check for exclusions  			if (excludeLocalIP) {  				if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  					continue;  				}  			}  			// check for FTP packet  			if (packet.DestinationPort == 21) {  				var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  						ftpLogins.Remove (login);  					}  				} else {  					ftpLogins.Add (new SnifferFTPlogin {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for IMAP  			if (packet.DestinationPort == 143) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// TAG LOGIN "username" "password"  				var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  				var matches = SimpleRegex.GetMatches (regexIMAP' data);  				if (matches.Count > 0) {  					Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  				}  				continue;  			}  			// check for SMTP  			if (packet.DestinationPort == 25) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// AUTH PLAIN base64  				var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  				var matches = SimpleRegex.GetMatches (regexSMTP' data);  				if (matches.Count > 0) {  					var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  					if (credentials.Length > 2)  						Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  				}  				continue;  			}  			// check for POP3  			if (packet.DestinationPort == 110) {  				var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  						pop3Logins.Remove (login);  					}  				} else {  					pop3Logins.Add (new SnifferPOP3login {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for HTTP packet and parse it  			if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  				var http = new HttpPacket (packet);  				// save hostnames for incomplete packets  				if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  					postRequests.Add (new SnifferPostRequest {  						SourceAddress = sourceIP'  						DestinationAddress = destIP'  						Hostname = http.Header.Host  					});  				}  				SnifferSearch (http' sourceIP' destIP);  			}  		}  		threadQueue.Clear ();  	} else {  		Thread.Sleep (50);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: while (Started) {  	// copy packets to threadQueue  	lock (PacketQueue) {  		foreach (TcpPacket packet in PacketQueue) {  			threadQueue.Add (packet);  		}  		PacketQueue.Clear ();  	}  	if (threadQueue.Count > 0) {  		// loop through packets and check them for any useful information  		foreach (TcpPacket packet in threadQueue) {  			if (packet.ParentPacket == null)  				continue;  			var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  			var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  			// check for exclusions  			if (excludeLocalIP) {  				if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  					continue;  				}  			}  			// check for FTP packet  			if (packet.DestinationPort == 21) {  				var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  						ftpLogins.Remove (login);  					}  				} else {  					ftpLogins.Add (new SnifferFTPlogin {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for IMAP  			if (packet.DestinationPort == 143) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// TAG LOGIN "username" "password"  				var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  				var matches = SimpleRegex.GetMatches (regexIMAP' data);  				if (matches.Count > 0) {  					Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  				}  				continue;  			}  			// check for SMTP  			if (packet.DestinationPort == 25) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// AUTH PLAIN base64  				var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  				var matches = SimpleRegex.GetMatches (regexSMTP' data);  				if (matches.Count > 0) {  					var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  					if (credentials.Length > 2)  						Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  				}  				continue;  			}  			// check for POP3  			if (packet.DestinationPort == 110) {  				var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  						pop3Logins.Remove (login);  					}  				} else {  					pop3Logins.Add (new SnifferPOP3login {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for HTTP packet and parse it  			if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  				var http = new HttpPacket (packet);  				// save hostnames for incomplete packets  				if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  					postRequests.Add (new SnifferPostRequest {  						SourceAddress = sourceIP'  						DestinationAddress = destIP'  						Hostname = http.Header.Host  					});  				}  				SnifferSearch (http' sourceIP' destIP);  			}  		}  		threadQueue.Clear ();  	} else {  		Thread.Sleep (50);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: while (Started) {  	// copy packets to threadQueue  	lock (PacketQueue) {  		foreach (TcpPacket packet in PacketQueue) {  			threadQueue.Add (packet);  		}  		PacketQueue.Clear ();  	}  	if (threadQueue.Count > 0) {  		// loop through packets and check them for any useful information  		foreach (TcpPacket packet in threadQueue) {  			if (packet.ParentPacket == null)  				continue;  			var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  			var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  			// check for exclusions  			if (excludeLocalIP) {  				if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  					continue;  				}  			}  			// check for FTP packet  			if (packet.DestinationPort == 21) {  				var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  						ftpLogins.Remove (login);  					}  				} else {  					ftpLogins.Add (new SnifferFTPlogin {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for IMAP  			if (packet.DestinationPort == 143) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// TAG LOGIN "username" "password"  				var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  				var matches = SimpleRegex.GetMatches (regexIMAP' data);  				if (matches.Count > 0) {  					Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  				}  				continue;  			}  			// check for SMTP  			if (packet.DestinationPort == 25) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// AUTH PLAIN base64  				var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  				var matches = SimpleRegex.GetMatches (regexSMTP' data);  				if (matches.Count > 0) {  					var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  					if (credentials.Length > 2)  						Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  				}  				continue;  			}  			// check for POP3  			if (packet.DestinationPort == 110) {  				var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  						pop3Logins.Remove (login);  					}  				} else {  					pop3Logins.Add (new SnifferPOP3login {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for HTTP packet and parse it  			if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  				var http = new HttpPacket (packet);  				// save hostnames for incomplete packets  				if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  					postRequests.Add (new SnifferPostRequest {  						SourceAddress = sourceIP'  						DestinationAddress = destIP'  						Hostname = http.Header.Host  					});  				}  				SnifferSearch (http' sourceIP' destIP);  			}  		}  		threadQueue.Clear ();  	} else {  		Thread.Sleep (50);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: while (Started) {  	// copy packets to threadQueue  	lock (PacketQueue) {  		foreach (TcpPacket packet in PacketQueue) {  			threadQueue.Add (packet);  		}  		PacketQueue.Clear ();  	}  	if (threadQueue.Count > 0) {  		// loop through packets and check them for any useful information  		foreach (TcpPacket packet in threadQueue) {  			if (packet.ParentPacket == null)  				continue;  			var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  			var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  			// check for exclusions  			if (excludeLocalIP) {  				if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  					continue;  				}  			}  			// check for FTP packet  			if (packet.DestinationPort == 21) {  				var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  						ftpLogins.Remove (login);  					}  				} else {  					ftpLogins.Add (new SnifferFTPlogin {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for IMAP  			if (packet.DestinationPort == 143) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// TAG LOGIN "username" "password"  				var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  				var matches = SimpleRegex.GetMatches (regexIMAP' data);  				if (matches.Count > 0) {  					Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  				}  				continue;  			}  			// check for SMTP  			if (packet.DestinationPort == 25) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// AUTH PLAIN base64  				var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  				var matches = SimpleRegex.GetMatches (regexSMTP' data);  				if (matches.Count > 0) {  					var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  					if (credentials.Length > 2)  						Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  				}  				continue;  			}  			// check for POP3  			if (packet.DestinationPort == 110) {  				var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  						pop3Logins.Remove (login);  					}  				} else {  					pop3Logins.Add (new SnifferPOP3login {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for HTTP packet and parse it  			if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  				var http = new HttpPacket (packet);  				// save hostnames for incomplete packets  				if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  					postRequests.Add (new SnifferPostRequest {  						SourceAddress = sourceIP'  						DestinationAddress = destIP'  						Hostname = http.Header.Host  					});  				}  				SnifferSearch (http' sourceIP' destIP);  			}  		}  		threadQueue.Clear ();  	} else {  		Thread.Sleep (50);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: while (Started) {  	// copy packets to threadQueue  	lock (PacketQueue) {  		foreach (TcpPacket packet in PacketQueue) {  			threadQueue.Add (packet);  		}  		PacketQueue.Clear ();  	}  	if (threadQueue.Count > 0) {  		// loop through packets and check them for any useful information  		foreach (TcpPacket packet in threadQueue) {  			if (packet.ParentPacket == null)  				continue;  			var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  			var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  			// check for exclusions  			if (excludeLocalIP) {  				if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  					continue;  				}  			}  			// check for FTP packet  			if (packet.DestinationPort == 21) {  				var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  						ftpLogins.Remove (login);  					}  				} else {  					ftpLogins.Add (new SnifferFTPlogin {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for IMAP  			if (packet.DestinationPort == 143) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// TAG LOGIN "username" "password"  				var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  				var matches = SimpleRegex.GetMatches (regexIMAP' data);  				if (matches.Count > 0) {  					Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  				}  				continue;  			}  			// check for SMTP  			if (packet.DestinationPort == 25) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// AUTH PLAIN base64  				var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  				var matches = SimpleRegex.GetMatches (regexSMTP' data);  				if (matches.Count > 0) {  					var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  					if (credentials.Length > 2)  						Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  				}  				continue;  			}  			// check for POP3  			if (packet.DestinationPort == 110) {  				var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  						pop3Logins.Remove (login);  					}  				} else {  					pop3Logins.Add (new SnifferPOP3login {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for HTTP packet and parse it  			if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  				var http = new HttpPacket (packet);  				// save hostnames for incomplete packets  				if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  					postRequests.Add (new SnifferPostRequest {  						SourceAddress = sourceIP'  						DestinationAddress = destIP'  						Hostname = http.Header.Host  					});  				}  				SnifferSearch (http' sourceIP' destIP);  			}  		}  		threadQueue.Clear ();  	} else {  		Thread.Sleep (50);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: while (Started) {  	// copy packets to threadQueue  	lock (PacketQueue) {  		foreach (TcpPacket packet in PacketQueue) {  			threadQueue.Add (packet);  		}  		PacketQueue.Clear ();  	}  	if (threadQueue.Count > 0) {  		// loop through packets and check them for any useful information  		foreach (TcpPacket packet in threadQueue) {  			if (packet.ParentPacket == null)  				continue;  			var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  			var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  			// check for exclusions  			if (excludeLocalIP) {  				if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  					continue;  				}  			}  			// check for FTP packet  			if (packet.DestinationPort == 21) {  				var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  						ftpLogins.Remove (login);  					}  				} else {  					ftpLogins.Add (new SnifferFTPlogin {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for IMAP  			if (packet.DestinationPort == 143) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// TAG LOGIN "username" "password"  				var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  				var matches = SimpleRegex.GetMatches (regexIMAP' data);  				if (matches.Count > 0) {  					Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  				}  				continue;  			}  			// check for SMTP  			if (packet.DestinationPort == 25) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// AUTH PLAIN base64  				var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  				var matches = SimpleRegex.GetMatches (regexSMTP' data);  				if (matches.Count > 0) {  					var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  					if (credentials.Length > 2)  						Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  				}  				continue;  			}  			// check for POP3  			if (packet.DestinationPort == 110) {  				var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  						pop3Logins.Remove (login);  					}  				} else {  					pop3Logins.Add (new SnifferPOP3login {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for HTTP packet and parse it  			if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  				var http = new HttpPacket (packet);  				// save hostnames for incomplete packets  				if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  					postRequests.Add (new SnifferPostRequest {  						SourceAddress = sourceIP'  						DestinationAddress = destIP'  						Hostname = http.Header.Host  					});  				}  				SnifferSearch (http' sourceIP' destIP);  			}  		}  		threadQueue.Clear ();  	} else {  		Thread.Sleep (50);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: while (Started) {  	// copy packets to threadQueue  	lock (PacketQueue) {  		foreach (TcpPacket packet in PacketQueue) {  			threadQueue.Add (packet);  		}  		PacketQueue.Clear ();  	}  	if (threadQueue.Count > 0) {  		// loop through packets and check them for any useful information  		foreach (TcpPacket packet in threadQueue) {  			if (packet.ParentPacket == null)  				continue;  			var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  			var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  			// check for exclusions  			if (excludeLocalIP) {  				if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  					continue;  				}  			}  			// check for FTP packet  			if (packet.DestinationPort == 21) {  				var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  						ftpLogins.Remove (login);  					}  				} else {  					ftpLogins.Add (new SnifferFTPlogin {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for IMAP  			if (packet.DestinationPort == 143) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// TAG LOGIN "username" "password"  				var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  				var matches = SimpleRegex.GetMatches (regexIMAP' data);  				if (matches.Count > 0) {  					Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  				}  				continue;  			}  			// check for SMTP  			if (packet.DestinationPort == 25) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// AUTH PLAIN base64  				var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  				var matches = SimpleRegex.GetMatches (regexSMTP' data);  				if (matches.Count > 0) {  					var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  					if (credentials.Length > 2)  						Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  				}  				continue;  			}  			// check for POP3  			if (packet.DestinationPort == 110) {  				var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  						pop3Logins.Remove (login);  					}  				} else {  					pop3Logins.Add (new SnifferPOP3login {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for HTTP packet and parse it  			if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  				var http = new HttpPacket (packet);  				// save hostnames for incomplete packets  				if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  					postRequests.Add (new SnifferPostRequest {  						SourceAddress = sourceIP'  						DestinationAddress = destIP'  						Hostname = http.Header.Host  					});  				}  				SnifferSearch (http' sourceIP' destIP);  			}  		}  		threadQueue.Clear ();  	} else {  		Thread.Sleep (50);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: while (Started) {  	// copy packets to threadQueue  	lock (PacketQueue) {  		foreach (TcpPacket packet in PacketQueue) {  			threadQueue.Add (packet);  		}  		PacketQueue.Clear ();  	}  	if (threadQueue.Count > 0) {  		// loop through packets and check them for any useful information  		foreach (TcpPacket packet in threadQueue) {  			if (packet.ParentPacket == null)  				continue;  			var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  			var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  			// check for exclusions  			if (excludeLocalIP) {  				if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  					continue;  				}  			}  			// check for FTP packet  			if (packet.DestinationPort == 21) {  				var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  						ftpLogins.Remove (login);  					}  				} else {  					ftpLogins.Add (new SnifferFTPlogin {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for IMAP  			if (packet.DestinationPort == 143) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// TAG LOGIN "username" "password"  				var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  				var matches = SimpleRegex.GetMatches (regexIMAP' data);  				if (matches.Count > 0) {  					Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  				}  				continue;  			}  			// check for SMTP  			if (packet.DestinationPort == 25) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// AUTH PLAIN base64  				var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  				var matches = SimpleRegex.GetMatches (regexSMTP' data);  				if (matches.Count > 0) {  					var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  					if (credentials.Length > 2)  						Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  				}  				continue;  			}  			// check for POP3  			if (packet.DestinationPort == 110) {  				var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  						pop3Logins.Remove (login);  					}  				} else {  					pop3Logins.Add (new SnifferPOP3login {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for HTTP packet and parse it  			if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  				var http = new HttpPacket (packet);  				// save hostnames for incomplete packets  				if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  					postRequests.Add (new SnifferPostRequest {  						SourceAddress = sourceIP'  						DestinationAddress = destIP'  						Hostname = http.Header.Host  					});  				}  				SnifferSearch (http' sourceIP' destIP);  			}  		}  		threadQueue.Clear ();  	} else {  		Thread.Sleep (50);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: while (Started) {  	// copy packets to threadQueue  	lock (PacketQueue) {  		foreach (TcpPacket packet in PacketQueue) {  			threadQueue.Add (packet);  		}  		PacketQueue.Clear ();  	}  	if (threadQueue.Count > 0) {  		// loop through packets and check them for any useful information  		foreach (TcpPacket packet in threadQueue) {  			if (packet.ParentPacket == null)  				continue;  			var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  			var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  			// check for exclusions  			if (excludeLocalIP) {  				if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  					continue;  				}  			}  			// check for FTP packet  			if (packet.DestinationPort == 21) {  				var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  						ftpLogins.Remove (login);  					}  				} else {  					ftpLogins.Add (new SnifferFTPlogin {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for IMAP  			if (packet.DestinationPort == 143) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// TAG LOGIN "username" "password"  				var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  				var matches = SimpleRegex.GetMatches (regexIMAP' data);  				if (matches.Count > 0) {  					Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  				}  				continue;  			}  			// check for SMTP  			if (packet.DestinationPort == 25) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// AUTH PLAIN base64  				var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  				var matches = SimpleRegex.GetMatches (regexSMTP' data);  				if (matches.Count > 0) {  					var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  					if (credentials.Length > 2)  						Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  				}  				continue;  			}  			// check for POP3  			if (packet.DestinationPort == 110) {  				var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  						pop3Logins.Remove (login);  					}  				} else {  					pop3Logins.Add (new SnifferPOP3login {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for HTTP packet and parse it  			if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  				var http = new HttpPacket (packet);  				// save hostnames for incomplete packets  				if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  					postRequests.Add (new SnifferPostRequest {  						SourceAddress = sourceIP'  						DestinationAddress = destIP'  						Hostname = http.Header.Host  					});  				}  				SnifferSearch (http' sourceIP' destIP);  			}  		}  		threadQueue.Clear ();  	} else {  		Thread.Sleep (50);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: while (Started) {  	// copy packets to threadQueue  	lock (PacketQueue) {  		foreach (TcpPacket packet in PacketQueue) {  			threadQueue.Add (packet);  		}  		PacketQueue.Clear ();  	}  	if (threadQueue.Count > 0) {  		// loop through packets and check them for any useful information  		foreach (TcpPacket packet in threadQueue) {  			if (packet.ParentPacket == null)  				continue;  			var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  			var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  			// check for exclusions  			if (excludeLocalIP) {  				if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  					continue;  				}  			}  			// check for FTP packet  			if (packet.DestinationPort == 21) {  				var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  						ftpLogins.Remove (login);  					}  				} else {  					ftpLogins.Add (new SnifferFTPlogin {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for IMAP  			if (packet.DestinationPort == 143) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// TAG LOGIN "username" "password"  				var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  				var matches = SimpleRegex.GetMatches (regexIMAP' data);  				if (matches.Count > 0) {  					Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  				}  				continue;  			}  			// check for SMTP  			if (packet.DestinationPort == 25) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// AUTH PLAIN base64  				var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  				var matches = SimpleRegex.GetMatches (regexSMTP' data);  				if (matches.Count > 0) {  					var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  					if (credentials.Length > 2)  						Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  				}  				continue;  			}  			// check for POP3  			if (packet.DestinationPort == 110) {  				var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  						pop3Logins.Remove (login);  					}  				} else {  					pop3Logins.Add (new SnifferPOP3login {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for HTTP packet and parse it  			if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  				var http = new HttpPacket (packet);  				// save hostnames for incomplete packets  				if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  					postRequests.Add (new SnifferPostRequest {  						SourceAddress = sourceIP'  						DestinationAddress = destIP'  						Hostname = http.Header.Host  					});  				}  				SnifferSearch (http' sourceIP' destIP);  			}  		}  		threadQueue.Clear ();  	} else {  		Thread.Sleep (50);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: while (Started) {  	// copy packets to threadQueue  	lock (PacketQueue) {  		foreach (TcpPacket packet in PacketQueue) {  			threadQueue.Add (packet);  		}  		PacketQueue.Clear ();  	}  	if (threadQueue.Count > 0) {  		// loop through packets and check them for any useful information  		foreach (TcpPacket packet in threadQueue) {  			if (packet.ParentPacket == null)  				continue;  			var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  			var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  			// check for exclusions  			if (excludeLocalIP) {  				if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  					continue;  				}  			}  			// check for FTP packet  			if (packet.DestinationPort == 21) {  				var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  						ftpLogins.Remove (login);  					}  				} else {  					ftpLogins.Add (new SnifferFTPlogin {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for IMAP  			if (packet.DestinationPort == 143) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// TAG LOGIN "username" "password"  				var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  				var matches = SimpleRegex.GetMatches (regexIMAP' data);  				if (matches.Count > 0) {  					Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  				}  				continue;  			}  			// check for SMTP  			if (packet.DestinationPort == 25) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// AUTH PLAIN base64  				var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  				var matches = SimpleRegex.GetMatches (regexSMTP' data);  				if (matches.Count > 0) {  					var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  					if (credentials.Length > 2)  						Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  				}  				continue;  			}  			// check for POP3  			if (packet.DestinationPort == 110) {  				var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  						pop3Logins.Remove (login);  					}  				} else {  					pop3Logins.Add (new SnifferPOP3login {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for HTTP packet and parse it  			if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  				var http = new HttpPacket (packet);  				// save hostnames for incomplete packets  				if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  					postRequests.Add (new SnifferPostRequest {  						SourceAddress = sourceIP'  						DestinationAddress = destIP'  						Hostname = http.Header.Host  					});  				}  				SnifferSearch (http' sourceIP' destIP);  			}  		}  		threadQueue.Clear ();  	} else {  		Thread.Sleep (50);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: while (Started) {  	// copy packets to threadQueue  	lock (PacketQueue) {  		foreach (TcpPacket packet in PacketQueue) {  			threadQueue.Add (packet);  		}  		PacketQueue.Clear ();  	}  	if (threadQueue.Count > 0) {  		// loop through packets and check them for any useful information  		foreach (TcpPacket packet in threadQueue) {  			if (packet.ParentPacket == null)  				continue;  			var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  			var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  			// check for exclusions  			if (excludeLocalIP) {  				if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  					continue;  				}  			}  			// check for FTP packet  			if (packet.DestinationPort == 21) {  				var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  						ftpLogins.Remove (login);  					}  				} else {  					ftpLogins.Add (new SnifferFTPlogin {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for IMAP  			if (packet.DestinationPort == 143) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// TAG LOGIN "username" "password"  				var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  				var matches = SimpleRegex.GetMatches (regexIMAP' data);  				if (matches.Count > 0) {  					Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  				}  				continue;  			}  			// check for SMTP  			if (packet.DestinationPort == 25) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// AUTH PLAIN base64  				var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  				var matches = SimpleRegex.GetMatches (regexSMTP' data);  				if (matches.Count > 0) {  					var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  					if (credentials.Length > 2)  						Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  				}  				continue;  			}  			// check for POP3  			if (packet.DestinationPort == 110) {  				var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  						pop3Logins.Remove (login);  					}  				} else {  					pop3Logins.Add (new SnifferPOP3login {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for HTTP packet and parse it  			if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  				var http = new HttpPacket (packet);  				// save hostnames for incomplete packets  				if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  					postRequests.Add (new SnifferPostRequest {  						SourceAddress = sourceIP'  						DestinationAddress = destIP'  						Hostname = http.Header.Host  					});  				}  				SnifferSearch (http' sourceIP' destIP);  			}  		}  		threadQueue.Clear ();  	} else {  		Thread.Sleep (50);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: while (Started) {  	// copy packets to threadQueue  	lock (PacketQueue) {  		foreach (TcpPacket packet in PacketQueue) {  			threadQueue.Add (packet);  		}  		PacketQueue.Clear ();  	}  	if (threadQueue.Count > 0) {  		// loop through packets and check them for any useful information  		foreach (TcpPacket packet in threadQueue) {  			if (packet.ParentPacket == null)  				continue;  			var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  			var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  			// check for exclusions  			if (excludeLocalIP) {  				if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  					continue;  				}  			}  			// check for FTP packet  			if (packet.DestinationPort == 21) {  				var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  						ftpLogins.Remove (login);  					}  				} else {  					ftpLogins.Add (new SnifferFTPlogin {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for IMAP  			if (packet.DestinationPort == 143) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// TAG LOGIN "username" "password"  				var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  				var matches = SimpleRegex.GetMatches (regexIMAP' data);  				if (matches.Count > 0) {  					Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  				}  				continue;  			}  			// check for SMTP  			if (packet.DestinationPort == 25) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// AUTH PLAIN base64  				var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  				var matches = SimpleRegex.GetMatches (regexSMTP' data);  				if (matches.Count > 0) {  					var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  					if (credentials.Length > 2)  						Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  				}  				continue;  			}  			// check for POP3  			if (packet.DestinationPort == 110) {  				var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  						pop3Logins.Remove (login);  					}  				} else {  					pop3Logins.Add (new SnifferPOP3login {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for HTTP packet and parse it  			if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  				var http = new HttpPacket (packet);  				// save hostnames for incomplete packets  				if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  					postRequests.Add (new SnifferPostRequest {  						SourceAddress = sourceIP'  						DestinationAddress = destIP'  						Hostname = http.Header.Host  					});  				}  				SnifferSearch (http' sourceIP' destIP);  			}  		}  		threadQueue.Clear ();  	} else {  		Thread.Sleep (50);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: while (Started) {  	// copy packets to threadQueue  	lock (PacketQueue) {  		foreach (TcpPacket packet in PacketQueue) {  			threadQueue.Add (packet);  		}  		PacketQueue.Clear ();  	}  	if (threadQueue.Count > 0) {  		// loop through packets and check them for any useful information  		foreach (TcpPacket packet in threadQueue) {  			if (packet.ParentPacket == null)  				continue;  			var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  			var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  			// check for exclusions  			if (excludeLocalIP) {  				if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  					continue;  				}  			}  			// check for FTP packet  			if (packet.DestinationPort == 21) {  				var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  						ftpLogins.Remove (login);  					}  				} else {  					ftpLogins.Add (new SnifferFTPlogin {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for IMAP  			if (packet.DestinationPort == 143) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// TAG LOGIN "username" "password"  				var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  				var matches = SimpleRegex.GetMatches (regexIMAP' data);  				if (matches.Count > 0) {  					Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  				}  				continue;  			}  			// check for SMTP  			if (packet.DestinationPort == 25) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// AUTH PLAIN base64  				var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  				var matches = SimpleRegex.GetMatches (regexSMTP' data);  				if (matches.Count > 0) {  					var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  					if (credentials.Length > 2)  						Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  				}  				continue;  			}  			// check for POP3  			if (packet.DestinationPort == 110) {  				var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  						pop3Logins.Remove (login);  					}  				} else {  					pop3Logins.Add (new SnifferPOP3login {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for HTTP packet and parse it  			if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  				var http = new HttpPacket (packet);  				// save hostnames for incomplete packets  				if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  					postRequests.Add (new SnifferPostRequest {  						SourceAddress = sourceIP'  						DestinationAddress = destIP'  						Hostname = http.Header.Host  					});  				}  				SnifferSearch (http' sourceIP' destIP);  			}  		}  		threadQueue.Clear ();  	} else {  		Thread.Sleep (50);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: while (Started) {  	// copy packets to threadQueue  	lock (PacketQueue) {  		foreach (TcpPacket packet in PacketQueue) {  			threadQueue.Add (packet);  		}  		PacketQueue.Clear ();  	}  	if (threadQueue.Count > 0) {  		// loop through packets and check them for any useful information  		foreach (TcpPacket packet in threadQueue) {  			if (packet.ParentPacket == null)  				continue;  			var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  			var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  			// check for exclusions  			if (excludeLocalIP) {  				if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  					continue;  				}  			}  			// check for FTP packet  			if (packet.DestinationPort == 21) {  				var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  						ftpLogins.Remove (login);  					}  				} else {  					ftpLogins.Add (new SnifferFTPlogin {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for IMAP  			if (packet.DestinationPort == 143) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// TAG LOGIN "username" "password"  				var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  				var matches = SimpleRegex.GetMatches (regexIMAP' data);  				if (matches.Count > 0) {  					Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  				}  				continue;  			}  			// check for SMTP  			if (packet.DestinationPort == 25) {  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// AUTH PLAIN base64  				var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  				var matches = SimpleRegex.GetMatches (regexSMTP' data);  				if (matches.Count > 0) {  					var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  					if (credentials.Length > 2)  						Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  				}  				continue;  			}  			// check for POP3  			if (packet.DestinationPort == 110) {  				var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  				// parse TCP packet data  				var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  				// check if connection already started  				if (logins.Count () > 0) {  					var login = logins.Last ();  					// get user  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.User = parts [1].Replace ("\r\n"' "");  					}  					// get password  					if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  						var parts = data.Split (' ');  						if (parts.Length > 1)  							login.Password = parts [1].Replace ("\r\n"' "");  						Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  						pop3Logins.Remove (login);  					}  				} else {  					pop3Logins.Add (new SnifferPOP3login {  						DestinationAddress = destIP'  						SourceAddress = sourceIP  					});  				}  				continue;  			}  			// check for HTTP packet and parse it  			if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  				var http = new HttpPacket (packet);  				// save hostnames for incomplete packets  				if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  					postRequests.Add (new SnifferPostRequest {  						SourceAddress = sourceIP'  						DestinationAddress = destIP'  						Hostname = http.Header.Host  					});  				}  				SnifferSearch (http' sourceIP' destIP);  			}  		}  		threadQueue.Clear ();  	} else {  		Thread.Sleep (50);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (threadQueue.Count > 0) {  	// loop through packets and check them for any useful information  	foreach (TcpPacket packet in threadQueue) {  		if (packet.ParentPacket == null)  			continue;  		var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  		var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  		// check for exclusions  		if (excludeLocalIP) {  			if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  				continue;  			}  		}  		// check for FTP packet  		if (packet.DestinationPort == 21) {  			var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  					ftpLogins.Remove (login);  				}  			} else {  				ftpLogins.Add (new SnifferFTPlogin {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for IMAP  		if (packet.DestinationPort == 143) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// TAG LOGIN "username" "password"  			var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  			var matches = SimpleRegex.GetMatches (regexIMAP' data);  			if (matches.Count > 0) {  				Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  			}  			continue;  		}  		// check for SMTP  		if (packet.DestinationPort == 25) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// AUTH PLAIN base64  			var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  			var matches = SimpleRegex.GetMatches (regexSMTP' data);  			if (matches.Count > 0) {  				var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  				if (credentials.Length > 2)  					Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  			}  			continue;  		}  		// check for POP3  		if (packet.DestinationPort == 110) {  			var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  					pop3Logins.Remove (login);  				}  			} else {  				pop3Logins.Add (new SnifferPOP3login {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for HTTP packet and parse it  		if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  			var http = new HttpPacket (packet);  			// save hostnames for incomplete packets  			if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  				postRequests.Add (new SnifferPostRequest {  					SourceAddress = sourceIP'  					DestinationAddress = destIP'  					Hostname = http.Header.Host  				});  			}  			SnifferSearch (http' sourceIP' destIP);  		}  	}  	threadQueue.Clear ();  } else {  	Thread.Sleep (50);  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (threadQueue.Count > 0) {  	// loop through packets and check them for any useful information  	foreach (TcpPacket packet in threadQueue) {  		if (packet.ParentPacket == null)  			continue;  		var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  		var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  		// check for exclusions  		if (excludeLocalIP) {  			if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  				continue;  			}  		}  		// check for FTP packet  		if (packet.DestinationPort == 21) {  			var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  					ftpLogins.Remove (login);  				}  			} else {  				ftpLogins.Add (new SnifferFTPlogin {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for IMAP  		if (packet.DestinationPort == 143) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// TAG LOGIN "username" "password"  			var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  			var matches = SimpleRegex.GetMatches (regexIMAP' data);  			if (matches.Count > 0) {  				Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  			}  			continue;  		}  		// check for SMTP  		if (packet.DestinationPort == 25) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// AUTH PLAIN base64  			var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  			var matches = SimpleRegex.GetMatches (regexSMTP' data);  			if (matches.Count > 0) {  				var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  				if (credentials.Length > 2)  					Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  			}  			continue;  		}  		// check for POP3  		if (packet.DestinationPort == 110) {  			var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  					pop3Logins.Remove (login);  				}  			} else {  				pop3Logins.Add (new SnifferPOP3login {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for HTTP packet and parse it  		if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  			var http = new HttpPacket (packet);  			// save hostnames for incomplete packets  			if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  				postRequests.Add (new SnifferPostRequest {  					SourceAddress = sourceIP'  					DestinationAddress = destIP'  					Hostname = http.Header.Host  				});  			}  			SnifferSearch (http' sourceIP' destIP);  		}  	}  	threadQueue.Clear ();  } else {  	Thread.Sleep (50);  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (threadQueue.Count > 0) {  	// loop through packets and check them for any useful information  	foreach (TcpPacket packet in threadQueue) {  		if (packet.ParentPacket == null)  			continue;  		var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  		var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  		// check for exclusions  		if (excludeLocalIP) {  			if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  				continue;  			}  		}  		// check for FTP packet  		if (packet.DestinationPort == 21) {  			var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  					ftpLogins.Remove (login);  				}  			} else {  				ftpLogins.Add (new SnifferFTPlogin {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for IMAP  		if (packet.DestinationPort == 143) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// TAG LOGIN "username" "password"  			var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  			var matches = SimpleRegex.GetMatches (regexIMAP' data);  			if (matches.Count > 0) {  				Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  			}  			continue;  		}  		// check for SMTP  		if (packet.DestinationPort == 25) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// AUTH PLAIN base64  			var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  			var matches = SimpleRegex.GetMatches (regexSMTP' data);  			if (matches.Count > 0) {  				var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  				if (credentials.Length > 2)  					Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  			}  			continue;  		}  		// check for POP3  		if (packet.DestinationPort == 110) {  			var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  					pop3Logins.Remove (login);  				}  			} else {  				pop3Logins.Add (new SnifferPOP3login {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for HTTP packet and parse it  		if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  			var http = new HttpPacket (packet);  			// save hostnames for incomplete packets  			if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  				postRequests.Add (new SnifferPostRequest {  					SourceAddress = sourceIP'  					DestinationAddress = destIP'  					Hostname = http.Header.Host  				});  			}  			SnifferSearch (http' sourceIP' destIP);  		}  	}  	threadQueue.Clear ();  } else {  	Thread.Sleep (50);  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (threadQueue.Count > 0) {  	// loop through packets and check them for any useful information  	foreach (TcpPacket packet in threadQueue) {  		if (packet.ParentPacket == null)  			continue;  		var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  		var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  		// check for exclusions  		if (excludeLocalIP) {  			if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  				continue;  			}  		}  		// check for FTP packet  		if (packet.DestinationPort == 21) {  			var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  					ftpLogins.Remove (login);  				}  			} else {  				ftpLogins.Add (new SnifferFTPlogin {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for IMAP  		if (packet.DestinationPort == 143) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// TAG LOGIN "username" "password"  			var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  			var matches = SimpleRegex.GetMatches (regexIMAP' data);  			if (matches.Count > 0) {  				Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  			}  			continue;  		}  		// check for SMTP  		if (packet.DestinationPort == 25) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// AUTH PLAIN base64  			var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  			var matches = SimpleRegex.GetMatches (regexSMTP' data);  			if (matches.Count > 0) {  				var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  				if (credentials.Length > 2)  					Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  			}  			continue;  		}  		// check for POP3  		if (packet.DestinationPort == 110) {  			var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  					pop3Logins.Remove (login);  				}  			} else {  				pop3Logins.Add (new SnifferPOP3login {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for HTTP packet and parse it  		if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  			var http = new HttpPacket (packet);  			// save hostnames for incomplete packets  			if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  				postRequests.Add (new SnifferPostRequest {  					SourceAddress = sourceIP'  					DestinationAddress = destIP'  					Hostname = http.Header.Host  				});  			}  			SnifferSearch (http' sourceIP' destIP);  		}  	}  	threadQueue.Clear ();  } else {  	Thread.Sleep (50);  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (threadQueue.Count > 0) {  	// loop through packets and check them for any useful information  	foreach (TcpPacket packet in threadQueue) {  		if (packet.ParentPacket == null)  			continue;  		var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  		var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  		// check for exclusions  		if (excludeLocalIP) {  			if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  				continue;  			}  		}  		// check for FTP packet  		if (packet.DestinationPort == 21) {  			var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  					ftpLogins.Remove (login);  				}  			} else {  				ftpLogins.Add (new SnifferFTPlogin {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for IMAP  		if (packet.DestinationPort == 143) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// TAG LOGIN "username" "password"  			var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  			var matches = SimpleRegex.GetMatches (regexIMAP' data);  			if (matches.Count > 0) {  				Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  			}  			continue;  		}  		// check for SMTP  		if (packet.DestinationPort == 25) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// AUTH PLAIN base64  			var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  			var matches = SimpleRegex.GetMatches (regexSMTP' data);  			if (matches.Count > 0) {  				var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  				if (credentials.Length > 2)  					Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  			}  			continue;  		}  		// check for POP3  		if (packet.DestinationPort == 110) {  			var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  					pop3Logins.Remove (login);  				}  			} else {  				pop3Logins.Add (new SnifferPOP3login {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for HTTP packet and parse it  		if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  			var http = new HttpPacket (packet);  			// save hostnames for incomplete packets  			if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  				postRequests.Add (new SnifferPostRequest {  					SourceAddress = sourceIP'  					DestinationAddress = destIP'  					Hostname = http.Header.Host  				});  			}  			SnifferSearch (http' sourceIP' destIP);  		}  	}  	threadQueue.Clear ();  } else {  	Thread.Sleep (50);  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (threadQueue.Count > 0) {  	// loop through packets and check them for any useful information  	foreach (TcpPacket packet in threadQueue) {  		if (packet.ParentPacket == null)  			continue;  		var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  		var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  		// check for exclusions  		if (excludeLocalIP) {  			if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  				continue;  			}  		}  		// check for FTP packet  		if (packet.DestinationPort == 21) {  			var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  					ftpLogins.Remove (login);  				}  			} else {  				ftpLogins.Add (new SnifferFTPlogin {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for IMAP  		if (packet.DestinationPort == 143) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// TAG LOGIN "username" "password"  			var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  			var matches = SimpleRegex.GetMatches (regexIMAP' data);  			if (matches.Count > 0) {  				Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  			}  			continue;  		}  		// check for SMTP  		if (packet.DestinationPort == 25) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// AUTH PLAIN base64  			var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  			var matches = SimpleRegex.GetMatches (regexSMTP' data);  			if (matches.Count > 0) {  				var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  				if (credentials.Length > 2)  					Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  			}  			continue;  		}  		// check for POP3  		if (packet.DestinationPort == 110) {  			var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  					pop3Logins.Remove (login);  				}  			} else {  				pop3Logins.Add (new SnifferPOP3login {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for HTTP packet and parse it  		if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  			var http = new HttpPacket (packet);  			// save hostnames for incomplete packets  			if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  				postRequests.Add (new SnifferPostRequest {  					SourceAddress = sourceIP'  					DestinationAddress = destIP'  					Hostname = http.Header.Host  				});  			}  			SnifferSearch (http' sourceIP' destIP);  		}  	}  	threadQueue.Clear ();  } else {  	Thread.Sleep (50);  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (threadQueue.Count > 0) {  	// loop through packets and check them for any useful information  	foreach (TcpPacket packet in threadQueue) {  		if (packet.ParentPacket == null)  			continue;  		var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  		var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  		// check for exclusions  		if (excludeLocalIP) {  			if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  				continue;  			}  		}  		// check for FTP packet  		if (packet.DestinationPort == 21) {  			var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  					ftpLogins.Remove (login);  				}  			} else {  				ftpLogins.Add (new SnifferFTPlogin {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for IMAP  		if (packet.DestinationPort == 143) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// TAG LOGIN "username" "password"  			var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  			var matches = SimpleRegex.GetMatches (regexIMAP' data);  			if (matches.Count > 0) {  				Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  			}  			continue;  		}  		// check for SMTP  		if (packet.DestinationPort == 25) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// AUTH PLAIN base64  			var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  			var matches = SimpleRegex.GetMatches (regexSMTP' data);  			if (matches.Count > 0) {  				var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  				if (credentials.Length > 2)  					Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  			}  			continue;  		}  		// check for POP3  		if (packet.DestinationPort == 110) {  			var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  					pop3Logins.Remove (login);  				}  			} else {  				pop3Logins.Add (new SnifferPOP3login {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for HTTP packet and parse it  		if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  			var http = new HttpPacket (packet);  			// save hostnames for incomplete packets  			if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  				postRequests.Add (new SnifferPostRequest {  					SourceAddress = sourceIP'  					DestinationAddress = destIP'  					Hostname = http.Header.Host  				});  			}  			SnifferSearch (http' sourceIP' destIP);  		}  	}  	threadQueue.Clear ();  } else {  	Thread.Sleep (50);  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (threadQueue.Count > 0) {  	// loop through packets and check them for any useful information  	foreach (TcpPacket packet in threadQueue) {  		if (packet.ParentPacket == null)  			continue;  		var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  		var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  		// check for exclusions  		if (excludeLocalIP) {  			if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  				continue;  			}  		}  		// check for FTP packet  		if (packet.DestinationPort == 21) {  			var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  					ftpLogins.Remove (login);  				}  			} else {  				ftpLogins.Add (new SnifferFTPlogin {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for IMAP  		if (packet.DestinationPort == 143) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// TAG LOGIN "username" "password"  			var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  			var matches = SimpleRegex.GetMatches (regexIMAP' data);  			if (matches.Count > 0) {  				Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  			}  			continue;  		}  		// check for SMTP  		if (packet.DestinationPort == 25) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// AUTH PLAIN base64  			var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  			var matches = SimpleRegex.GetMatches (regexSMTP' data);  			if (matches.Count > 0) {  				var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  				if (credentials.Length > 2)  					Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  			}  			continue;  		}  		// check for POP3  		if (packet.DestinationPort == 110) {  			var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  					pop3Logins.Remove (login);  				}  			} else {  				pop3Logins.Add (new SnifferPOP3login {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for HTTP packet and parse it  		if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  			var http = new HttpPacket (packet);  			// save hostnames for incomplete packets  			if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  				postRequests.Add (new SnifferPostRequest {  					SourceAddress = sourceIP'  					DestinationAddress = destIP'  					Hostname = http.Header.Host  				});  			}  			SnifferSearch (http' sourceIP' destIP);  		}  	}  	threadQueue.Clear ();  } else {  	Thread.Sleep (50);  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (threadQueue.Count > 0) {  	// loop through packets and check them for any useful information  	foreach (TcpPacket packet in threadQueue) {  		if (packet.ParentPacket == null)  			continue;  		var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  		var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  		// check for exclusions  		if (excludeLocalIP) {  			if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  				continue;  			}  		}  		// check for FTP packet  		if (packet.DestinationPort == 21) {  			var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  					ftpLogins.Remove (login);  				}  			} else {  				ftpLogins.Add (new SnifferFTPlogin {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for IMAP  		if (packet.DestinationPort == 143) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// TAG LOGIN "username" "password"  			var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  			var matches = SimpleRegex.GetMatches (regexIMAP' data);  			if (matches.Count > 0) {  				Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  			}  			continue;  		}  		// check for SMTP  		if (packet.DestinationPort == 25) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// AUTH PLAIN base64  			var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  			var matches = SimpleRegex.GetMatches (regexSMTP' data);  			if (matches.Count > 0) {  				var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  				if (credentials.Length > 2)  					Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  			}  			continue;  		}  		// check for POP3  		if (packet.DestinationPort == 110) {  			var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  					pop3Logins.Remove (login);  				}  			} else {  				pop3Logins.Add (new SnifferPOP3login {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for HTTP packet and parse it  		if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  			var http = new HttpPacket (packet);  			// save hostnames for incomplete packets  			if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  				postRequests.Add (new SnifferPostRequest {  					SourceAddress = sourceIP'  					DestinationAddress = destIP'  					Hostname = http.Header.Host  				});  			}  			SnifferSearch (http' sourceIP' destIP);  		}  	}  	threadQueue.Clear ();  } else {  	Thread.Sleep (50);  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (threadQueue.Count > 0) {  	// loop through packets and check them for any useful information  	foreach (TcpPacket packet in threadQueue) {  		if (packet.ParentPacket == null)  			continue;  		var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  		var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  		// check for exclusions  		if (excludeLocalIP) {  			if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  				continue;  			}  		}  		// check for FTP packet  		if (packet.DestinationPort == 21) {  			var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  					ftpLogins.Remove (login);  				}  			} else {  				ftpLogins.Add (new SnifferFTPlogin {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for IMAP  		if (packet.DestinationPort == 143) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// TAG LOGIN "username" "password"  			var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  			var matches = SimpleRegex.GetMatches (regexIMAP' data);  			if (matches.Count > 0) {  				Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  			}  			continue;  		}  		// check for SMTP  		if (packet.DestinationPort == 25) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// AUTH PLAIN base64  			var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  			var matches = SimpleRegex.GetMatches (regexSMTP' data);  			if (matches.Count > 0) {  				var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  				if (credentials.Length > 2)  					Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  			}  			continue;  		}  		// check for POP3  		if (packet.DestinationPort == 110) {  			var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  					pop3Logins.Remove (login);  				}  			} else {  				pop3Logins.Add (new SnifferPOP3login {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for HTTP packet and parse it  		if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  			var http = new HttpPacket (packet);  			// save hostnames for incomplete packets  			if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  				postRequests.Add (new SnifferPostRequest {  					SourceAddress = sourceIP'  					DestinationAddress = destIP'  					Hostname = http.Header.Host  				});  			}  			SnifferSearch (http' sourceIP' destIP);  		}  	}  	threadQueue.Clear ();  } else {  	Thread.Sleep (50);  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (threadQueue.Count > 0) {  	// loop through packets and check them for any useful information  	foreach (TcpPacket packet in threadQueue) {  		if (packet.ParentPacket == null)  			continue;  		var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  		var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  		// check for exclusions  		if (excludeLocalIP) {  			if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  				continue;  			}  		}  		// check for FTP packet  		if (packet.DestinationPort == 21) {  			var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  					ftpLogins.Remove (login);  				}  			} else {  				ftpLogins.Add (new SnifferFTPlogin {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for IMAP  		if (packet.DestinationPort == 143) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// TAG LOGIN "username" "password"  			var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  			var matches = SimpleRegex.GetMatches (regexIMAP' data);  			if (matches.Count > 0) {  				Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  			}  			continue;  		}  		// check for SMTP  		if (packet.DestinationPort == 25) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// AUTH PLAIN base64  			var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  			var matches = SimpleRegex.GetMatches (regexSMTP' data);  			if (matches.Count > 0) {  				var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  				if (credentials.Length > 2)  					Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  			}  			continue;  		}  		// check for POP3  		if (packet.DestinationPort == 110) {  			var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  					pop3Logins.Remove (login);  				}  			} else {  				pop3Logins.Add (new SnifferPOP3login {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for HTTP packet and parse it  		if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  			var http = new HttpPacket (packet);  			// save hostnames for incomplete packets  			if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  				postRequests.Add (new SnifferPostRequest {  					SourceAddress = sourceIP'  					DestinationAddress = destIP'  					Hostname = http.Header.Host  				});  			}  			SnifferSearch (http' sourceIP' destIP);  		}  	}  	threadQueue.Clear ();  } else {  	Thread.Sleep (50);  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (threadQueue.Count > 0) {  	// loop through packets and check them for any useful information  	foreach (TcpPacket packet in threadQueue) {  		if (packet.ParentPacket == null)  			continue;  		var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  		var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  		// check for exclusions  		if (excludeLocalIP) {  			if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  				continue;  			}  		}  		// check for FTP packet  		if (packet.DestinationPort == 21) {  			var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  					ftpLogins.Remove (login);  				}  			} else {  				ftpLogins.Add (new SnifferFTPlogin {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for IMAP  		if (packet.DestinationPort == 143) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// TAG LOGIN "username" "password"  			var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  			var matches = SimpleRegex.GetMatches (regexIMAP' data);  			if (matches.Count > 0) {  				Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  			}  			continue;  		}  		// check for SMTP  		if (packet.DestinationPort == 25) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// AUTH PLAIN base64  			var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  			var matches = SimpleRegex.GetMatches (regexSMTP' data);  			if (matches.Count > 0) {  				var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  				if (credentials.Length > 2)  					Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  			}  			continue;  		}  		// check for POP3  		if (packet.DestinationPort == 110) {  			var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  					pop3Logins.Remove (login);  				}  			} else {  				pop3Logins.Add (new SnifferPOP3login {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for HTTP packet and parse it  		if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  			var http = new HttpPacket (packet);  			// save hostnames for incomplete packets  			if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  				postRequests.Add (new SnifferPostRequest {  					SourceAddress = sourceIP'  					DestinationAddress = destIP'  					Hostname = http.Header.Host  				});  			}  			SnifferSearch (http' sourceIP' destIP);  		}  	}  	threadQueue.Clear ();  } else {  	Thread.Sleep (50);  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (threadQueue.Count > 0) {  	// loop through packets and check them for any useful information  	foreach (TcpPacket packet in threadQueue) {  		if (packet.ParentPacket == null)  			continue;  		var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  		var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  		// check for exclusions  		if (excludeLocalIP) {  			if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  				continue;  			}  		}  		// check for FTP packet  		if (packet.DestinationPort == 21) {  			var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  					ftpLogins.Remove (login);  				}  			} else {  				ftpLogins.Add (new SnifferFTPlogin {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for IMAP  		if (packet.DestinationPort == 143) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// TAG LOGIN "username" "password"  			var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  			var matches = SimpleRegex.GetMatches (regexIMAP' data);  			if (matches.Count > 0) {  				Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  			}  			continue;  		}  		// check for SMTP  		if (packet.DestinationPort == 25) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// AUTH PLAIN base64  			var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  			var matches = SimpleRegex.GetMatches (regexSMTP' data);  			if (matches.Count > 0) {  				var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  				if (credentials.Length > 2)  					Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  			}  			continue;  		}  		// check for POP3  		if (packet.DestinationPort == 110) {  			var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  					pop3Logins.Remove (login);  				}  			} else {  				pop3Logins.Add (new SnifferPOP3login {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for HTTP packet and parse it  		if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  			var http = new HttpPacket (packet);  			// save hostnames for incomplete packets  			if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  				postRequests.Add (new SnifferPostRequest {  					SourceAddress = sourceIP'  					DestinationAddress = destIP'  					Hostname = http.Header.Host  				});  			}  			SnifferSearch (http' sourceIP' destIP);  		}  	}  	threadQueue.Clear ();  } else {  	Thread.Sleep (50);  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (threadQueue.Count > 0) {  	// loop through packets and check them for any useful information  	foreach (TcpPacket packet in threadQueue) {  		if (packet.ParentPacket == null)  			continue;  		var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  		var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  		// check for exclusions  		if (excludeLocalIP) {  			if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  				continue;  			}  		}  		// check for FTP packet  		if (packet.DestinationPort == 21) {  			var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  					ftpLogins.Remove (login);  				}  			} else {  				ftpLogins.Add (new SnifferFTPlogin {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for IMAP  		if (packet.DestinationPort == 143) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// TAG LOGIN "username" "password"  			var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  			var matches = SimpleRegex.GetMatches (regexIMAP' data);  			if (matches.Count > 0) {  				Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  			}  			continue;  		}  		// check for SMTP  		if (packet.DestinationPort == 25) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// AUTH PLAIN base64  			var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  			var matches = SimpleRegex.GetMatches (regexSMTP' data);  			if (matches.Count > 0) {  				var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  				if (credentials.Length > 2)  					Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  			}  			continue;  		}  		// check for POP3  		if (packet.DestinationPort == 110) {  			var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  					pop3Logins.Remove (login);  				}  			} else {  				pop3Logins.Add (new SnifferPOP3login {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for HTTP packet and parse it  		if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  			var http = new HttpPacket (packet);  			// save hostnames for incomplete packets  			if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  				postRequests.Add (new SnifferPostRequest {  					SourceAddress = sourceIP'  					DestinationAddress = destIP'  					Hostname = http.Header.Host  				});  			}  			SnifferSearch (http' sourceIP' destIP);  		}  	}  	threadQueue.Clear ();  } else {  	Thread.Sleep (50);  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (threadQueue.Count > 0) {  	// loop through packets and check them for any useful information  	foreach (TcpPacket packet in threadQueue) {  		if (packet.ParentPacket == null)  			continue;  		var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  		var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  		// check for exclusions  		if (excludeLocalIP) {  			if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  				continue;  			}  		}  		// check for FTP packet  		if (packet.DestinationPort == 21) {  			var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  					ftpLogins.Remove (login);  				}  			} else {  				ftpLogins.Add (new SnifferFTPlogin {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for IMAP  		if (packet.DestinationPort == 143) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// TAG LOGIN "username" "password"  			var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  			var matches = SimpleRegex.GetMatches (regexIMAP' data);  			if (matches.Count > 0) {  				Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  			}  			continue;  		}  		// check for SMTP  		if (packet.DestinationPort == 25) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// AUTH PLAIN base64  			var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  			var matches = SimpleRegex.GetMatches (regexSMTP' data);  			if (matches.Count > 0) {  				var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  				if (credentials.Length > 2)  					Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  			}  			continue;  		}  		// check for POP3  		if (packet.DestinationPort == 110) {  			var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  					pop3Logins.Remove (login);  				}  			} else {  				pop3Logins.Add (new SnifferPOP3login {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for HTTP packet and parse it  		if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  			var http = new HttpPacket (packet);  			// save hostnames for incomplete packets  			if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  				postRequests.Add (new SnifferPostRequest {  					SourceAddress = sourceIP'  					DestinationAddress = destIP'  					Hostname = http.Header.Host  				});  			}  			SnifferSearch (http' sourceIP' destIP);  		}  	}  	threadQueue.Clear ();  } else {  	Thread.Sleep (50);  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (threadQueue.Count > 0) {  	// loop through packets and check them for any useful information  	foreach (TcpPacket packet in threadQueue) {  		if (packet.ParentPacket == null)  			continue;  		var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  		var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  		// check for exclusions  		if (excludeLocalIP) {  			if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  				continue;  			}  		}  		// check for FTP packet  		if (packet.DestinationPort == 21) {  			var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  					ftpLogins.Remove (login);  				}  			} else {  				ftpLogins.Add (new SnifferFTPlogin {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for IMAP  		if (packet.DestinationPort == 143) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// TAG LOGIN "username" "password"  			var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  			var matches = SimpleRegex.GetMatches (regexIMAP' data);  			if (matches.Count > 0) {  				Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  			}  			continue;  		}  		// check for SMTP  		if (packet.DestinationPort == 25) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// AUTH PLAIN base64  			var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  			var matches = SimpleRegex.GetMatches (regexSMTP' data);  			if (matches.Count > 0) {  				var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  				if (credentials.Length > 2)  					Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  			}  			continue;  		}  		// check for POP3  		if (packet.DestinationPort == 110) {  			var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  					pop3Logins.Remove (login);  				}  			} else {  				pop3Logins.Add (new SnifferPOP3login {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for HTTP packet and parse it  		if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  			var http = new HttpPacket (packet);  			// save hostnames for incomplete packets  			if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  				postRequests.Add (new SnifferPostRequest {  					SourceAddress = sourceIP'  					DestinationAddress = destIP'  					Hostname = http.Header.Host  				});  			}  			SnifferSearch (http' sourceIP' destIP);  		}  	}  	threadQueue.Clear ();  } else {  	Thread.Sleep (50);  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (threadQueue.Count > 0) {  	// loop through packets and check them for any useful information  	foreach (TcpPacket packet in threadQueue) {  		if (packet.ParentPacket == null)  			continue;  		var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  		var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  		// check for exclusions  		if (excludeLocalIP) {  			if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  				continue;  			}  		}  		// check for FTP packet  		if (packet.DestinationPort == 21) {  			var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  					ftpLogins.Remove (login);  				}  			} else {  				ftpLogins.Add (new SnifferFTPlogin {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for IMAP  		if (packet.DestinationPort == 143) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// TAG LOGIN "username" "password"  			var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  			var matches = SimpleRegex.GetMatches (regexIMAP' data);  			if (matches.Count > 0) {  				Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  			}  			continue;  		}  		// check for SMTP  		if (packet.DestinationPort == 25) {  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// AUTH PLAIN base64  			var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  			var matches = SimpleRegex.GetMatches (regexSMTP' data);  			if (matches.Count > 0) {  				var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  				if (credentials.Length > 2)  					Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  			}  			continue;  		}  		// check for POP3  		if (packet.DestinationPort == 110) {  			var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  			// parse TCP packet data  			var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  			// check if connection already started  			if (logins.Count () > 0) {  				var login = logins.Last ();  				// get user  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.User = parts [1].Replace ("\r\n"' "");  				}  				// get password  				if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  					var parts = data.Split (' ');  					if (parts.Length > 1)  						login.Password = parts [1].Replace ("\r\n"' "");  					Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  					pop3Logins.Remove (login);  				}  			} else {  				pop3Logins.Add (new SnifferPOP3login {  					DestinationAddress = destIP'  					SourceAddress = sourceIP  				});  			}  			continue;  		}  		// check for HTTP packet and parse it  		if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  			var http = new HttpPacket (packet);  			// save hostnames for incomplete packets  			if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  				postRequests.Add (new SnifferPostRequest {  					SourceAddress = sourceIP'  					DestinationAddress = destIP'  					Hostname = http.Header.Host  				});  			}  			SnifferSearch (http' sourceIP' destIP);  		}  	}  	threadQueue.Clear ();  } else {  	Thread.Sleep (50);  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: foreach (TcpPacket packet in threadQueue) {  	if (packet.ParentPacket == null)  		continue;  	var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  	var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  	// check for exclusions  	if (excludeLocalIP) {  		if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  			continue;  		}  	}  	// check for FTP packet  	if (packet.DestinationPort == 21) {  		var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  				ftpLogins.Remove (login);  			}  		} else {  			ftpLogins.Add (new SnifferFTPlogin {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for IMAP  	if (packet.DestinationPort == 143) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// TAG LOGIN "username" "password"  		var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  		var matches = SimpleRegex.GetMatches (regexIMAP' data);  		if (matches.Count > 0) {  			Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  		}  		continue;  	}  	// check for SMTP  	if (packet.DestinationPort == 25) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// AUTH PLAIN base64  		var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  		var matches = SimpleRegex.GetMatches (regexSMTP' data);  		if (matches.Count > 0) {  			var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  			if (credentials.Length > 2)  				Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  		}  		continue;  	}  	// check for POP3  	if (packet.DestinationPort == 110) {  		var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  				pop3Logins.Remove (login);  			}  		} else {  			pop3Logins.Add (new SnifferPOP3login {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for HTTP packet and parse it  	if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  		var http = new HttpPacket (packet);  		// save hostnames for incomplete packets  		if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  			postRequests.Add (new SnifferPostRequest {  				SourceAddress = sourceIP'  				DestinationAddress = destIP'  				Hostname = http.Header.Host  			});  		}  		SnifferSearch (http' sourceIP' destIP);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: foreach (TcpPacket packet in threadQueue) {  	if (packet.ParentPacket == null)  		continue;  	var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  	var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  	// check for exclusions  	if (excludeLocalIP) {  		if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  			continue;  		}  	}  	// check for FTP packet  	if (packet.DestinationPort == 21) {  		var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  				ftpLogins.Remove (login);  			}  		} else {  			ftpLogins.Add (new SnifferFTPlogin {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for IMAP  	if (packet.DestinationPort == 143) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// TAG LOGIN "username" "password"  		var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  		var matches = SimpleRegex.GetMatches (regexIMAP' data);  		if (matches.Count > 0) {  			Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  		}  		continue;  	}  	// check for SMTP  	if (packet.DestinationPort == 25) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// AUTH PLAIN base64  		var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  		var matches = SimpleRegex.GetMatches (regexSMTP' data);  		if (matches.Count > 0) {  			var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  			if (credentials.Length > 2)  				Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  		}  		continue;  	}  	// check for POP3  	if (packet.DestinationPort == 110) {  		var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  				pop3Logins.Remove (login);  			}  		} else {  			pop3Logins.Add (new SnifferPOP3login {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for HTTP packet and parse it  	if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  		var http = new HttpPacket (packet);  		// save hostnames for incomplete packets  		if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  			postRequests.Add (new SnifferPostRequest {  				SourceAddress = sourceIP'  				DestinationAddress = destIP'  				Hostname = http.Header.Host  			});  		}  		SnifferSearch (http' sourceIP' destIP);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: foreach (TcpPacket packet in threadQueue) {  	if (packet.ParentPacket == null)  		continue;  	var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  	var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  	// check for exclusions  	if (excludeLocalIP) {  		if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  			continue;  		}  	}  	// check for FTP packet  	if (packet.DestinationPort == 21) {  		var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  				ftpLogins.Remove (login);  			}  		} else {  			ftpLogins.Add (new SnifferFTPlogin {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for IMAP  	if (packet.DestinationPort == 143) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// TAG LOGIN "username" "password"  		var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  		var matches = SimpleRegex.GetMatches (regexIMAP' data);  		if (matches.Count > 0) {  			Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  		}  		continue;  	}  	// check for SMTP  	if (packet.DestinationPort == 25) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// AUTH PLAIN base64  		var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  		var matches = SimpleRegex.GetMatches (regexSMTP' data);  		if (matches.Count > 0) {  			var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  			if (credentials.Length > 2)  				Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  		}  		continue;  	}  	// check for POP3  	if (packet.DestinationPort == 110) {  		var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  				pop3Logins.Remove (login);  			}  		} else {  			pop3Logins.Add (new SnifferPOP3login {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for HTTP packet and parse it  	if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  		var http = new HttpPacket (packet);  		// save hostnames for incomplete packets  		if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  			postRequests.Add (new SnifferPostRequest {  				SourceAddress = sourceIP'  				DestinationAddress = destIP'  				Hostname = http.Header.Host  			});  		}  		SnifferSearch (http' sourceIP' destIP);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: foreach (TcpPacket packet in threadQueue) {  	if (packet.ParentPacket == null)  		continue;  	var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  	var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  	// check for exclusions  	if (excludeLocalIP) {  		if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  			continue;  		}  	}  	// check for FTP packet  	if (packet.DestinationPort == 21) {  		var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  				ftpLogins.Remove (login);  			}  		} else {  			ftpLogins.Add (new SnifferFTPlogin {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for IMAP  	if (packet.DestinationPort == 143) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// TAG LOGIN "username" "password"  		var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  		var matches = SimpleRegex.GetMatches (regexIMAP' data);  		if (matches.Count > 0) {  			Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  		}  		continue;  	}  	// check for SMTP  	if (packet.DestinationPort == 25) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// AUTH PLAIN base64  		var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  		var matches = SimpleRegex.GetMatches (regexSMTP' data);  		if (matches.Count > 0) {  			var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  			if (credentials.Length > 2)  				Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  		}  		continue;  	}  	// check for POP3  	if (packet.DestinationPort == 110) {  		var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  				pop3Logins.Remove (login);  			}  		} else {  			pop3Logins.Add (new SnifferPOP3login {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for HTTP packet and parse it  	if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  		var http = new HttpPacket (packet);  		// save hostnames for incomplete packets  		if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  			postRequests.Add (new SnifferPostRequest {  				SourceAddress = sourceIP'  				DestinationAddress = destIP'  				Hostname = http.Header.Host  			});  		}  		SnifferSearch (http' sourceIP' destIP);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: foreach (TcpPacket packet in threadQueue) {  	if (packet.ParentPacket == null)  		continue;  	var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  	var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  	// check for exclusions  	if (excludeLocalIP) {  		if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  			continue;  		}  	}  	// check for FTP packet  	if (packet.DestinationPort == 21) {  		var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  				ftpLogins.Remove (login);  			}  		} else {  			ftpLogins.Add (new SnifferFTPlogin {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for IMAP  	if (packet.DestinationPort == 143) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// TAG LOGIN "username" "password"  		var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  		var matches = SimpleRegex.GetMatches (regexIMAP' data);  		if (matches.Count > 0) {  			Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  		}  		continue;  	}  	// check for SMTP  	if (packet.DestinationPort == 25) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// AUTH PLAIN base64  		var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  		var matches = SimpleRegex.GetMatches (regexSMTP' data);  		if (matches.Count > 0) {  			var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  			if (credentials.Length > 2)  				Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  		}  		continue;  	}  	// check for POP3  	if (packet.DestinationPort == 110) {  		var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  				pop3Logins.Remove (login);  			}  		} else {  			pop3Logins.Add (new SnifferPOP3login {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for HTTP packet and parse it  	if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  		var http = new HttpPacket (packet);  		// save hostnames for incomplete packets  		if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  			postRequests.Add (new SnifferPostRequest {  				SourceAddress = sourceIP'  				DestinationAddress = destIP'  				Hostname = http.Header.Host  			});  		}  		SnifferSearch (http' sourceIP' destIP);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: foreach (TcpPacket packet in threadQueue) {  	if (packet.ParentPacket == null)  		continue;  	var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  	var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  	// check for exclusions  	if (excludeLocalIP) {  		if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  			continue;  		}  	}  	// check for FTP packet  	if (packet.DestinationPort == 21) {  		var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  				ftpLogins.Remove (login);  			}  		} else {  			ftpLogins.Add (new SnifferFTPlogin {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for IMAP  	if (packet.DestinationPort == 143) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// TAG LOGIN "username" "password"  		var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  		var matches = SimpleRegex.GetMatches (regexIMAP' data);  		if (matches.Count > 0) {  			Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  		}  		continue;  	}  	// check for SMTP  	if (packet.DestinationPort == 25) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// AUTH PLAIN base64  		var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  		var matches = SimpleRegex.GetMatches (regexSMTP' data);  		if (matches.Count > 0) {  			var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  			if (credentials.Length > 2)  				Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  		}  		continue;  	}  	// check for POP3  	if (packet.DestinationPort == 110) {  		var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  				pop3Logins.Remove (login);  			}  		} else {  			pop3Logins.Add (new SnifferPOP3login {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for HTTP packet and parse it  	if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  		var http = new HttpPacket (packet);  		// save hostnames for incomplete packets  		if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  			postRequests.Add (new SnifferPostRequest {  				SourceAddress = sourceIP'  				DestinationAddress = destIP'  				Hostname = http.Header.Host  			});  		}  		SnifferSearch (http' sourceIP' destIP);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: foreach (TcpPacket packet in threadQueue) {  	if (packet.ParentPacket == null)  		continue;  	var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  	var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  	// check for exclusions  	if (excludeLocalIP) {  		if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  			continue;  		}  	}  	// check for FTP packet  	if (packet.DestinationPort == 21) {  		var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  				ftpLogins.Remove (login);  			}  		} else {  			ftpLogins.Add (new SnifferFTPlogin {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for IMAP  	if (packet.DestinationPort == 143) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// TAG LOGIN "username" "password"  		var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  		var matches = SimpleRegex.GetMatches (regexIMAP' data);  		if (matches.Count > 0) {  			Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  		}  		continue;  	}  	// check for SMTP  	if (packet.DestinationPort == 25) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// AUTH PLAIN base64  		var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  		var matches = SimpleRegex.GetMatches (regexSMTP' data);  		if (matches.Count > 0) {  			var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  			if (credentials.Length > 2)  				Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  		}  		continue;  	}  	// check for POP3  	if (packet.DestinationPort == 110) {  		var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  				pop3Logins.Remove (login);  			}  		} else {  			pop3Logins.Add (new SnifferPOP3login {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for HTTP packet and parse it  	if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  		var http = new HttpPacket (packet);  		// save hostnames for incomplete packets  		if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  			postRequests.Add (new SnifferPostRequest {  				SourceAddress = sourceIP'  				DestinationAddress = destIP'  				Hostname = http.Header.Host  			});  		}  		SnifferSearch (http' sourceIP' destIP);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: foreach (TcpPacket packet in threadQueue) {  	if (packet.ParentPacket == null)  		continue;  	var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  	var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  	// check for exclusions  	if (excludeLocalIP) {  		if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  			continue;  		}  	}  	// check for FTP packet  	if (packet.DestinationPort == 21) {  		var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  				ftpLogins.Remove (login);  			}  		} else {  			ftpLogins.Add (new SnifferFTPlogin {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for IMAP  	if (packet.DestinationPort == 143) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// TAG LOGIN "username" "password"  		var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  		var matches = SimpleRegex.GetMatches (regexIMAP' data);  		if (matches.Count > 0) {  			Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  		}  		continue;  	}  	// check for SMTP  	if (packet.DestinationPort == 25) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// AUTH PLAIN base64  		var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  		var matches = SimpleRegex.GetMatches (regexSMTP' data);  		if (matches.Count > 0) {  			var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  			if (credentials.Length > 2)  				Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  		}  		continue;  	}  	// check for POP3  	if (packet.DestinationPort == 110) {  		var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  				pop3Logins.Remove (login);  			}  		} else {  			pop3Logins.Add (new SnifferPOP3login {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for HTTP packet and parse it  	if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  		var http = new HttpPacket (packet);  		// save hostnames for incomplete packets  		if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  			postRequests.Add (new SnifferPostRequest {  				SourceAddress = sourceIP'  				DestinationAddress = destIP'  				Hostname = http.Header.Host  			});  		}  		SnifferSearch (http' sourceIP' destIP);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: foreach (TcpPacket packet in threadQueue) {  	if (packet.ParentPacket == null)  		continue;  	var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  	var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  	// check for exclusions  	if (excludeLocalIP) {  		if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  			continue;  		}  	}  	// check for FTP packet  	if (packet.DestinationPort == 21) {  		var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  				ftpLogins.Remove (login);  			}  		} else {  			ftpLogins.Add (new SnifferFTPlogin {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for IMAP  	if (packet.DestinationPort == 143) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// TAG LOGIN "username" "password"  		var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  		var matches = SimpleRegex.GetMatches (regexIMAP' data);  		if (matches.Count > 0) {  			Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  		}  		continue;  	}  	// check for SMTP  	if (packet.DestinationPort == 25) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// AUTH PLAIN base64  		var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  		var matches = SimpleRegex.GetMatches (regexSMTP' data);  		if (matches.Count > 0) {  			var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  			if (credentials.Length > 2)  				Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  		}  		continue;  	}  	// check for POP3  	if (packet.DestinationPort == 110) {  		var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  				pop3Logins.Remove (login);  			}  		} else {  			pop3Logins.Add (new SnifferPOP3login {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for HTTP packet and parse it  	if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  		var http = new HttpPacket (packet);  		// save hostnames for incomplete packets  		if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  			postRequests.Add (new SnifferPostRequest {  				SourceAddress = sourceIP'  				DestinationAddress = destIP'  				Hostname = http.Header.Host  			});  		}  		SnifferSearch (http' sourceIP' destIP);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: foreach (TcpPacket packet in threadQueue) {  	if (packet.ParentPacket == null)  		continue;  	var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  	var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  	// check for exclusions  	if (excludeLocalIP) {  		if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  			continue;  		}  	}  	// check for FTP packet  	if (packet.DestinationPort == 21) {  		var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  				ftpLogins.Remove (login);  			}  		} else {  			ftpLogins.Add (new SnifferFTPlogin {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for IMAP  	if (packet.DestinationPort == 143) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// TAG LOGIN "username" "password"  		var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  		var matches = SimpleRegex.GetMatches (regexIMAP' data);  		if (matches.Count > 0) {  			Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  		}  		continue;  	}  	// check for SMTP  	if (packet.DestinationPort == 25) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// AUTH PLAIN base64  		var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  		var matches = SimpleRegex.GetMatches (regexSMTP' data);  		if (matches.Count > 0) {  			var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  			if (credentials.Length > 2)  				Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  		}  		continue;  	}  	// check for POP3  	if (packet.DestinationPort == 110) {  		var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  				pop3Logins.Remove (login);  			}  		} else {  			pop3Logins.Add (new SnifferPOP3login {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for HTTP packet and parse it  	if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  		var http = new HttpPacket (packet);  		// save hostnames for incomplete packets  		if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  			postRequests.Add (new SnifferPostRequest {  				SourceAddress = sourceIP'  				DestinationAddress = destIP'  				Hostname = http.Header.Host  			});  		}  		SnifferSearch (http' sourceIP' destIP);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: foreach (TcpPacket packet in threadQueue) {  	if (packet.ParentPacket == null)  		continue;  	var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  	var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  	// check for exclusions  	if (excludeLocalIP) {  		if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  			continue;  		}  	}  	// check for FTP packet  	if (packet.DestinationPort == 21) {  		var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  				ftpLogins.Remove (login);  			}  		} else {  			ftpLogins.Add (new SnifferFTPlogin {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for IMAP  	if (packet.DestinationPort == 143) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// TAG LOGIN "username" "password"  		var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  		var matches = SimpleRegex.GetMatches (regexIMAP' data);  		if (matches.Count > 0) {  			Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  		}  		continue;  	}  	// check for SMTP  	if (packet.DestinationPort == 25) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// AUTH PLAIN base64  		var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  		var matches = SimpleRegex.GetMatches (regexSMTP' data);  		if (matches.Count > 0) {  			var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  			if (credentials.Length > 2)  				Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  		}  		continue;  	}  	// check for POP3  	if (packet.DestinationPort == 110) {  		var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  				pop3Logins.Remove (login);  			}  		} else {  			pop3Logins.Add (new SnifferPOP3login {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for HTTP packet and parse it  	if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  		var http = new HttpPacket (packet);  		// save hostnames for incomplete packets  		if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  			postRequests.Add (new SnifferPostRequest {  				SourceAddress = sourceIP'  				DestinationAddress = destIP'  				Hostname = http.Header.Host  			});  		}  		SnifferSearch (http' sourceIP' destIP);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: foreach (TcpPacket packet in threadQueue) {  	if (packet.ParentPacket == null)  		continue;  	var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  	var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  	// check for exclusions  	if (excludeLocalIP) {  		if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  			continue;  		}  	}  	// check for FTP packet  	if (packet.DestinationPort == 21) {  		var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  				ftpLogins.Remove (login);  			}  		} else {  			ftpLogins.Add (new SnifferFTPlogin {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for IMAP  	if (packet.DestinationPort == 143) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// TAG LOGIN "username" "password"  		var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  		var matches = SimpleRegex.GetMatches (regexIMAP' data);  		if (matches.Count > 0) {  			Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  		}  		continue;  	}  	// check for SMTP  	if (packet.DestinationPort == 25) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// AUTH PLAIN base64  		var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  		var matches = SimpleRegex.GetMatches (regexSMTP' data);  		if (matches.Count > 0) {  			var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  			if (credentials.Length > 2)  				Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  		}  		continue;  	}  	// check for POP3  	if (packet.DestinationPort == 110) {  		var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  				pop3Logins.Remove (login);  			}  		} else {  			pop3Logins.Add (new SnifferPOP3login {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for HTTP packet and parse it  	if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  		var http = new HttpPacket (packet);  		// save hostnames for incomplete packets  		if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  			postRequests.Add (new SnifferPostRequest {  				SourceAddress = sourceIP'  				DestinationAddress = destIP'  				Hostname = http.Header.Host  			});  		}  		SnifferSearch (http' sourceIP' destIP);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: foreach (TcpPacket packet in threadQueue) {  	if (packet.ParentPacket == null)  		continue;  	var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  	var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  	// check for exclusions  	if (excludeLocalIP) {  		if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  			continue;  		}  	}  	// check for FTP packet  	if (packet.DestinationPort == 21) {  		var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  				ftpLogins.Remove (login);  			}  		} else {  			ftpLogins.Add (new SnifferFTPlogin {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for IMAP  	if (packet.DestinationPort == 143) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// TAG LOGIN "username" "password"  		var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  		var matches = SimpleRegex.GetMatches (regexIMAP' data);  		if (matches.Count > 0) {  			Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  		}  		continue;  	}  	// check for SMTP  	if (packet.DestinationPort == 25) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// AUTH PLAIN base64  		var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  		var matches = SimpleRegex.GetMatches (regexSMTP' data);  		if (matches.Count > 0) {  			var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  			if (credentials.Length > 2)  				Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  		}  		continue;  	}  	// check for POP3  	if (packet.DestinationPort == 110) {  		var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  				pop3Logins.Remove (login);  			}  		} else {  			pop3Logins.Add (new SnifferPOP3login {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for HTTP packet and parse it  	if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  		var http = new HttpPacket (packet);  		// save hostnames for incomplete packets  		if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  			postRequests.Add (new SnifferPostRequest {  				SourceAddress = sourceIP'  				DestinationAddress = destIP'  				Hostname = http.Header.Host  			});  		}  		SnifferSearch (http' sourceIP' destIP);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: foreach (TcpPacket packet in threadQueue) {  	if (packet.ParentPacket == null)  		continue;  	var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  	var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  	// check for exclusions  	if (excludeLocalIP) {  		if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  			continue;  		}  	}  	// check for FTP packet  	if (packet.DestinationPort == 21) {  		var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  				ftpLogins.Remove (login);  			}  		} else {  			ftpLogins.Add (new SnifferFTPlogin {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for IMAP  	if (packet.DestinationPort == 143) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// TAG LOGIN "username" "password"  		var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  		var matches = SimpleRegex.GetMatches (regexIMAP' data);  		if (matches.Count > 0) {  			Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  		}  		continue;  	}  	// check for SMTP  	if (packet.DestinationPort == 25) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// AUTH PLAIN base64  		var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  		var matches = SimpleRegex.GetMatches (regexSMTP' data);  		if (matches.Count > 0) {  			var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  			if (credentials.Length > 2)  				Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  		}  		continue;  	}  	// check for POP3  	if (packet.DestinationPort == 110) {  		var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  				pop3Logins.Remove (login);  			}  		} else {  			pop3Logins.Add (new SnifferPOP3login {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for HTTP packet and parse it  	if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  		var http = new HttpPacket (packet);  		// save hostnames for incomplete packets  		if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  			postRequests.Add (new SnifferPostRequest {  				SourceAddress = sourceIP'  				DestinationAddress = destIP'  				Hostname = http.Header.Host  			});  		}  		SnifferSearch (http' sourceIP' destIP);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: foreach (TcpPacket packet in threadQueue) {  	if (packet.ParentPacket == null)  		continue;  	var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  	var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  	// check for exclusions  	if (excludeLocalIP) {  		if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  			continue;  		}  	}  	// check for FTP packet  	if (packet.DestinationPort == 21) {  		var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  				ftpLogins.Remove (login);  			}  		} else {  			ftpLogins.Add (new SnifferFTPlogin {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for IMAP  	if (packet.DestinationPort == 143) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// TAG LOGIN "username" "password"  		var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  		var matches = SimpleRegex.GetMatches (regexIMAP' data);  		if (matches.Count > 0) {  			Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  		}  		continue;  	}  	// check for SMTP  	if (packet.DestinationPort == 25) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// AUTH PLAIN base64  		var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  		var matches = SimpleRegex.GetMatches (regexSMTP' data);  		if (matches.Count > 0) {  			var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  			if (credentials.Length > 2)  				Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  		}  		continue;  	}  	// check for POP3  	if (packet.DestinationPort == 110) {  		var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  				pop3Logins.Remove (login);  			}  		} else {  			pop3Logins.Add (new SnifferPOP3login {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for HTTP packet and parse it  	if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  		var http = new HttpPacket (packet);  		// save hostnames for incomplete packets  		if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  			postRequests.Add (new SnifferPostRequest {  				SourceAddress = sourceIP'  				DestinationAddress = destIP'  				Hostname = http.Header.Host  			});  		}  		SnifferSearch (http' sourceIP' destIP);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: foreach (TcpPacket packet in threadQueue) {  	if (packet.ParentPacket == null)  		continue;  	var sourceIP = ((IpPacket)packet.ParentPacket).SourceAddress;  	var destIP = ((IpPacket)packet.ParentPacket).DestinationAddress;  	// check for exclusions  	if (excludeLocalIP) {  		if (sourceIP.ToString () == deviceInfo.IP || deviceInfo.IPv6List.Contains (sourceIP.ToString ())) {  			continue;  		}  	}  	// check for FTP packet  	if (packet.DestinationPort == 21) {  		var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  				ftpLogins.Remove (login);  			}  		} else {  			ftpLogins.Add (new SnifferFTPlogin {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for IMAP  	if (packet.DestinationPort == 143) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// TAG LOGIN "username" "password"  		var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  		var matches = SimpleRegex.GetMatches (regexIMAP' data);  		if (matches.Count > 0) {  			Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  		}  		continue;  	}  	// check for SMTP  	if (packet.DestinationPort == 25) {  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// AUTH PLAIN base64  		var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  		var matches = SimpleRegex.GetMatches (regexSMTP' data);  		if (matches.Count > 0) {  			var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  			if (credentials.Length > 2)  				Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  		}  		continue;  	}  	// check for POP3  	if (packet.DestinationPort == 110) {  		var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  		// parse TCP packet data  		var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  		// check if connection already started  		if (logins.Count () > 0) {  			var login = logins.Last ();  			// get user  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.User = parts [1].Replace ("\r\n"' "");  			}  			// get password  			if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  				var parts = data.Split (' ');  				if (parts.Length > 1)  					login.Password = parts [1].Replace ("\r\n"' "");  				Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  				pop3Logins.Remove (login);  			}  		} else {  			pop3Logins.Add (new SnifferPOP3login {  				DestinationAddress = destIP'  				SourceAddress = sourceIP  			});  		}  		continue;  	}  	// check for HTTP packet and parse it  	if (HttpPacket.IsHTTP (packet) || HttpPacket.HasPOST (packet)) {  		var http = new HttpPacket (packet);  		// save hostnames for incomplete packets  		if (http.Header.Type == HttpHeader.PacketType.Request && http.Header.ReqType == HttpHeader.RequestType.POST) {  			postRequests.Add (new SnifferPostRequest {  				SourceAddress = sourceIP'  				DestinationAddress = destIP'  				Hostname = http.Header.Host  			});  		}  		SnifferSearch (http' sourceIP' destIP);  	}  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (packet.DestinationPort == 21) {  	var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  	// parse TCP packet data  	var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  	// check if connection already started  	if (logins.Count () > 0) {  		var login = logins.Last ();  		// get user  		if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  			var parts = data.Split (' ');  			if (parts.Length > 1)  				login.User = parts [1].Replace ("\r\n"' "");  		}  		// get password  		if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  			var parts = data.Split (' ');  			if (parts.Length > 1)  				login.Password = parts [1].Replace ("\r\n"' "");  			Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  			ftpLogins.Remove (login);  		}  	} else {  		ftpLogins.Add (new SnifferFTPlogin {  			DestinationAddress = destIP'  			SourceAddress = sourceIP  		});  	}  	continue;  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (packet.DestinationPort == 21) {  	var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  	// parse TCP packet data  	var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  	// check if connection already started  	if (logins.Count () > 0) {  		var login = logins.Last ();  		// get user  		if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  			var parts = data.Split (' ');  			if (parts.Length > 1)  				login.User = parts [1].Replace ("\r\n"' "");  		}  		// get password  		if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  			var parts = data.Split (' ');  			if (parts.Length > 1)  				login.Password = parts [1].Replace ("\r\n"' "");  			Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  			ftpLogins.Remove (login);  		}  	} else {  		ftpLogins.Add (new SnifferFTPlogin {  			DestinationAddress = destIP'  			SourceAddress = sourceIP  		});  	}  	continue;  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (packet.DestinationPort == 21) {  	var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  	// parse TCP packet data  	var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  	// check if connection already started  	if (logins.Count () > 0) {  		var login = logins.Last ();  		// get user  		if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  			var parts = data.Split (' ');  			if (parts.Length > 1)  				login.User = parts [1].Replace ("\r\n"' "");  		}  		// get password  		if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  			var parts = data.Split (' ');  			if (parts.Length > 1)  				login.Password = parts [1].Replace ("\r\n"' "");  			Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  			ftpLogins.Remove (login);  		}  	} else {  		ftpLogins.Add (new SnifferFTPlogin {  			DestinationAddress = destIP'  			SourceAddress = sourceIP  		});  	}  	continue;  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (packet.DestinationPort == 21) {  	var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  	// parse TCP packet data  	var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  	// check if connection already started  	if (logins.Count () > 0) {  		var login = logins.Last ();  		// get user  		if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  			var parts = data.Split (' ');  			if (parts.Length > 1)  				login.User = parts [1].Replace ("\r\n"' "");  		}  		// get password  		if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  			var parts = data.Split (' ');  			if (parts.Length > 1)  				login.Password = parts [1].Replace ("\r\n"' "");  			Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  			ftpLogins.Remove (login);  		}  	} else {  		ftpLogins.Add (new SnifferFTPlogin {  			DestinationAddress = destIP'  			SourceAddress = sourceIP  		});  	}  	continue;  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (packet.DestinationPort == 21) {  	var logins = ftpLogins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  	// parse TCP packet data  	var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  	// check if connection already started  	if (logins.Count () > 0) {  		var login = logins.Last ();  		// get user  		if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  			var parts = data.Split (' ');  			if (parts.Length > 1)  				login.User = parts [1].Replace ("\r\n"' "");  		}  		// get password  		if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  			var parts = data.Split (' ');  			if (parts.Length > 1)  				login.Password = parts [1].Replace ("\r\n"' "");  			Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  			ftpLogins.Remove (login);  		}  	} else {  		ftpLogins.Add (new SnifferFTPlogin {  			DestinationAddress = destIP'  			SourceAddress = sourceIP  		});  	}  	continue;  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (logins.Count () > 0) {  	var login = logins.Last ();  	// get user  	if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  		var parts = data.Split (' ');  		if (parts.Length > 1)  			login.User = parts [1].Replace ("\r\n"' "");  	}  	// get password  	if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  		var parts = data.Split (' ');  		if (parts.Length > 1)  			login.Password = parts [1].Replace ("\r\n"' "");  		Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  		ftpLogins.Remove (login);  	}  } else {  	ftpLogins.Add (new SnifferFTPlogin {  		DestinationAddress = destIP'  		SourceAddress = sourceIP  	});  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (logins.Count () > 0) {  	var login = logins.Last ();  	// get user  	if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  		var parts = data.Split (' ');  		if (parts.Length > 1)  			login.User = parts [1].Replace ("\r\n"' "");  	}  	// get password  	if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  		var parts = data.Split (' ');  		if (parts.Length > 1)  			login.Password = parts [1].Replace ("\r\n"' "");  		Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  		ftpLogins.Remove (login);  	}  } else {  	ftpLogins.Add (new SnifferFTPlogin {  		DestinationAddress = destIP'  		SourceAddress = sourceIP  	});  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (logins.Count () > 0) {  	var login = logins.Last ();  	// get user  	if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  		var parts = data.Split (' ');  		if (parts.Length > 1)  			login.User = parts [1].Replace ("\r\n"' "");  	}  	// get password  	if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  		var parts = data.Split (' ');  		if (parts.Length > 1)  			login.Password = parts [1].Replace ("\r\n"' "");  		Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  		ftpLogins.Remove (login);  	}  } else {  	ftpLogins.Add (new SnifferFTPlogin {  		DestinationAddress = destIP'  		SourceAddress = sourceIP  	});  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (logins.Count () > 0) {  	var login = logins.Last ();  	// get user  	if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  		var parts = data.Split (' ');  		if (parts.Length > 1)  			login.User = parts [1].Replace ("\r\n"' "");  	}  	// get password  	if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  		var parts = data.Split (' ');  		if (parts.Length > 1)  			login.Password = parts [1].Replace ("\r\n"' "");  		Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  		ftpLogins.Remove (login);  	}  } else {  	ftpLogins.Add (new SnifferFTPlogin {  		DestinationAddress = destIP'  		SourceAddress = sourceIP  	});  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  	var parts = data.Split (' ');  	if (parts.Length > 1)  		login.User = parts [1].Replace ("\r\n"' "");  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  	var parts = data.Split (' ');  	if (parts.Length > 1)  		login.User = parts [1].Replace ("\r\n"' "");  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  	var parts = data.Split (' ');  	if (parts.Length > 1)  		login.Password = parts [1].Replace ("\r\n"' "");  	Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  	ftpLogins.Remove (login);  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  	var parts = data.Split (' ');  	if (parts.Length > 1)  		login.Password = parts [1].Replace ("\r\n"' "");  	Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.FTP);  	ftpLogins.Remove (login);  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (packet.DestinationPort == 143) {  	// parse TCP packet data  	var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  	// TAG LOGIN "username" "password"  	var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  	var matches = SimpleRegex.GetMatches (regexIMAP' data);  	if (matches.Count > 0) {  		Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  	}  	continue;  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (packet.DestinationPort == 143) {  	// parse TCP packet data  	var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  	// TAG LOGIN "username" "password"  	var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  	var matches = SimpleRegex.GetMatches (regexIMAP' data);  	if (matches.Count > 0) {  		Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  	}  	continue;  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (packet.DestinationPort == 143) {  	// parse TCP packet data  	var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  	// TAG LOGIN "username" "password"  	var regexIMAP = new Regex ("(.*?) login \"(.*?)\" \"(.*?)\"");  	var matches = SimpleRegex.GetMatches (regexIMAP' data);  	if (matches.Count > 0) {  		Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  	}  	continue;  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (matches.Count > 0) {  	Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (matches.Count > 0) {  	Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: Result (sourceIP.ToString ()' matches [2]' matches [3]' "/"' SnifferResultType.IMAP);  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (packet.DestinationPort == 25) {  	// parse TCP packet data  	var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  	// AUTH PLAIN base64  	var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  	var matches = SimpleRegex.GetMatches (regexSMTP' data);  	if (matches.Count > 0) {  		var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  		if (credentials.Length > 2)  			Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  	}  	continue;  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (packet.DestinationPort == 25) {  	// parse TCP packet data  	var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  	// AUTH PLAIN base64  	var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  	var matches = SimpleRegex.GetMatches (regexSMTP' data);  	if (matches.Count > 0) {  		var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  		if (credentials.Length > 2)  			Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  	}  	continue;  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (packet.DestinationPort == 25) {  	// parse TCP packet data  	var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  	// AUTH PLAIN base64  	var regexSMTP = new Regex ("AUTH PLAIN (.*?)$");  	var matches = SimpleRegex.GetMatches (regexSMTP' data);  	if (matches.Count > 0) {  		var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  		if (credentials.Length > 2)  			Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  	}  	continue;  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (matches.Count > 0) {  	var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  	if (credentials.Length > 2)  		Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (matches.Count > 0) {  	var credentials = encoding.GetString (Convert.FromBase64String (matches [1].Replace ("\r"' ""))).Split (Convert.ToChar (0x0));  	if (credentials.Length > 2)  		Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (credentials.Length > 2)  	Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (credentials.Length > 2)  	Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: Result (sourceIP.ToString ()' credentials [1]' credentials [2]' "/"' SnifferResultType.SMTP);  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (packet.DestinationPort == 110) {  	var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  	// parse TCP packet data  	var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  	// check if connection already started  	if (logins.Count () > 0) {  		var login = logins.Last ();  		// get user  		if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  			var parts = data.Split (' ');  			if (parts.Length > 1)  				login.User = parts [1].Replace ("\r\n"' "");  		}  		// get password  		if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  			var parts = data.Split (' ');  			if (parts.Length > 1)  				login.Password = parts [1].Replace ("\r\n"' "");  			Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  			pop3Logins.Remove (login);  		}  	} else {  		pop3Logins.Add (new SnifferPOP3login {  			DestinationAddress = destIP'  			SourceAddress = sourceIP  		});  	}  	continue;  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (packet.DestinationPort == 110) {  	var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  	// parse TCP packet data  	var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  	// check if connection already started  	if (logins.Count () > 0) {  		var login = logins.Last ();  		// get user  		if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  			var parts = data.Split (' ');  			if (parts.Length > 1)  				login.User = parts [1].Replace ("\r\n"' "");  		}  		// get password  		if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  			var parts = data.Split (' ');  			if (parts.Length > 1)  				login.Password = parts [1].Replace ("\r\n"' "");  			Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  			pop3Logins.Remove (login);  		}  	} else {  		pop3Logins.Add (new SnifferPOP3login {  			DestinationAddress = destIP'  			SourceAddress = sourceIP  		});  	}  	continue;  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (packet.DestinationPort == 110) {  	var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  	// parse TCP packet data  	var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  	// check if connection already started  	if (logins.Count () > 0) {  		var login = logins.Last ();  		// get user  		if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  			var parts = data.Split (' ');  			if (parts.Length > 1)  				login.User = parts [1].Replace ("\r\n"' "");  		}  		// get password  		if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  			var parts = data.Split (' ');  			if (parts.Length > 1)  				login.Password = parts [1].Replace ("\r\n"' "");  			Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  			pop3Logins.Remove (login);  		}  	} else {  		pop3Logins.Add (new SnifferPOP3login {  			DestinationAddress = destIP'  			SourceAddress = sourceIP  		});  	}  	continue;  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (packet.DestinationPort == 110) {  	var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  	// parse TCP packet data  	var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  	// check if connection already started  	if (logins.Count () > 0) {  		var login = logins.Last ();  		// get user  		if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  			var parts = data.Split (' ');  			if (parts.Length > 1)  				login.User = parts [1].Replace ("\r\n"' "");  		}  		// get password  		if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  			var parts = data.Split (' ');  			if (parts.Length > 1)  				login.Password = parts [1].Replace ("\r\n"' "");  			Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  			pop3Logins.Remove (login);  		}  	} else {  		pop3Logins.Add (new SnifferPOP3login {  			DestinationAddress = destIP'  			SourceAddress = sourceIP  		});  	}  	continue;  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (packet.DestinationPort == 110) {  	var logins = pop3Logins.Where (l => (l.DestinationAddress.ToString () == destIP.ToString () && l.SourceAddress.ToString () == sourceIP.ToString ()));  	// parse TCP packet data  	var data = packet.PayloadData != null ? encoding.GetString (packet.PayloadData) : "";  	// check if connection already started  	if (logins.Count () > 0) {  		var login = logins.Last ();  		// get user  		if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  			var parts = data.Split (' ');  			if (parts.Length > 1)  				login.User = parts [1].Replace ("\r\n"' "");  		}  		// get password  		if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  			var parts = data.Split (' ');  			if (parts.Length > 1)  				login.Password = parts [1].Replace ("\r\n"' "");  			Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  			pop3Logins.Remove (login);  		}  	} else {  		pop3Logins.Add (new SnifferPOP3login {  			DestinationAddress = destIP'  			SourceAddress = sourceIP  		});  	}  	continue;  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (logins.Count () > 0) {  	var login = logins.Last ();  	// get user  	if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  		var parts = data.Split (' ');  		if (parts.Length > 1)  			login.User = parts [1].Replace ("\r\n"' "");  	}  	// get password  	if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  		var parts = data.Split (' ');  		if (parts.Length > 1)  			login.Password = parts [1].Replace ("\r\n"' "");  		Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  		pop3Logins.Remove (login);  	}  } else {  	pop3Logins.Add (new SnifferPOP3login {  		DestinationAddress = destIP'  		SourceAddress = sourceIP  	});  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (logins.Count () > 0) {  	var login = logins.Last ();  	// get user  	if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  		var parts = data.Split (' ');  		if (parts.Length > 1)  			login.User = parts [1].Replace ("\r\n"' "");  	}  	// get password  	if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  		var parts = data.Split (' ');  		if (parts.Length > 1)  			login.Password = parts [1].Replace ("\r\n"' "");  		Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  		pop3Logins.Remove (login);  	}  } else {  	pop3Logins.Add (new SnifferPOP3login {  		DestinationAddress = destIP'  		SourceAddress = sourceIP  	});  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (logins.Count () > 0) {  	var login = logins.Last ();  	// get user  	if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  		var parts = data.Split (' ');  		if (parts.Length > 1)  			login.User = parts [1].Replace ("\r\n"' "");  	}  	// get password  	if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  		var parts = data.Split (' ');  		if (parts.Length > 1)  			login.Password = parts [1].Replace ("\r\n"' "");  		Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  		pop3Logins.Remove (login);  	}  } else {  	pop3Logins.Add (new SnifferPOP3login {  		DestinationAddress = destIP'  		SourceAddress = sourceIP  	});  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (logins.Count () > 0) {  	var login = logins.Last ();  	// get user  	if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  		var parts = data.Split (' ');  		if (parts.Length > 1)  			login.User = parts [1].Replace ("\r\n"' "");  	}  	// get password  	if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  		var parts = data.Split (' ');  		if (parts.Length > 1)  			login.Password = parts [1].Replace ("\r\n"' "");  		Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  		pop3Logins.Remove (login);  	}  } else {  	pop3Logins.Add (new SnifferPOP3login {  		DestinationAddress = destIP'  		SourceAddress = sourceIP  	});  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  	var parts = data.Split (' ');  	if (parts.Length > 1)  		login.User = parts [1].Replace ("\r\n"' "");  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "USER") {  	var parts = data.Split (' ');  	if (parts.Length > 1)  		login.User = parts [1].Replace ("\r\n"' "");  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  	var parts = data.Split (' ');  	if (parts.Length > 1)  		login.Password = parts [1].Replace ("\r\n"' "");  	Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  	pop3Logins.Remove (login);  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: if (data.Length > 4 && data.Substring (0' 4).ToUpper () == "PASS") {  	var parts = data.Split (' ');  	if (parts.Length > 1)  		login.Password = parts [1].Replace ("\r\n"' "");  	Result (login.DestinationAddress.ToString ()' login.User' login.Password' "/"' SnifferResultType.POP3);  	pop3Logins.Remove (login);  }  
Magic Number,Nighthawk,Sniffer,D:\newReposJune17\klemenb_nighthawk\Nighthawk\Sniffer.cs,Worker,The following statement contains a magic number: Thread.Sleep (50);  
Magic Number,Nighthawk,SSLStrip,D:\newReposJune17\klemenb_nighthawk\Nighthawk\SSLStrip.cs,ProcessPacket,The following statement contains a magic number: if (data != string.Empty) {  	var changed = new List<string> ();  	var matches = SimpleRegex.GetMatches (regexType' data);  	// HTTP request  	if (matches.Count > 2) {  		// check for images - stop further processing  		if (matches [2].Contains (".png") || matches [2].Contains (".jpg") || matches [2].Contains (".gif"))  			return true;  		// check for Accept-Encoding and replace it to prevent unreadable data  		if (data.Contains ("Accept-Encoding:")) {  			var diff = data.Length - regexEncoding.Replace (data' "Accept-Encoding: \r\n").Length;  			var extra = string.Empty;  			for (int i = 0; i < diff; i++) {  				extra += " ";  			}  			data = regexEncoding.Replace (data' "Accept-Encoding: " + extra + "\r\n");  			changed.Add ("Accept-Encoding");  		}  		// check for If-Modified-Since and replace it to prevent caching  		if (data.Contains ("If-Modified-Since:")) {  			var time = new DateTime (2000' 1' 1);  			data = regexModified.Replace (data' "If-Modified-Since: " + time.ToString ("R") + "\r\n");  			changed.Add ("If-Modified-Since");  		}  		// check for cookies and strip them if necessary  		if (stripCookies && data.Contains ("Cookie:")) {  			data = data.Replace ("Cookie:"' "C00kie:");  			changed.Add ("Cookies");  		}  	} // HTTP response  	else {  		// check for html tags - stop further processing  		if (!(data.Contains ("<form") || data.Contains ("<input") || data.Contains ("<a ") || data.Contains ("</a>") || data.Contains ("</div>") || data.Contains ("<meta") || data.Contains ("javascript")))  			return true;  		var cmatches = SimpleRegex.GetMatches (regexCType' data);  		// check for images - stop further processing  		if (cmatches.Count > 1 && cmatches [1].Contains ("image"))  			return true;  		// HTTP 302 redirect stripping  		foreach (var item in stripRedirects) {  			if (data.Contains ("Location: " + item)) {  				data = data.Replace ("Location: https://"' "Location:  http://");  				changed.Add ("HTTPS (302 redirect)");  			}  		}  		// other links' actions...  		if (data.Contains ("\"https://") || data.Contains ("'https://")) {  			data = data.Replace ("\"https://"' "\" http://");  			data = data.Replace ("'https://"' "' http://");  			changed.Add ("HTTPS");  		}  	}  	if (changed.Count > 0) {  		// change packet data to stripped one  		var bytes = encodingUtf8.GetBytes (data);  		var diff = packet.PayloadData.Length - bytes.Length;  		packet.PayloadData = bytes;  		packet.UpdateTCPChecksum ();  		// checksum fixes for IPv4 packets (IPv6 packet doesn't have a checksum)  		if (packet.ParentPacket is IPv4Packet) {  			var ip = (IPv4Packet)packet.ParentPacket;  			ip.TotalLength = ip.HeaderLength + packet.Bytes.Length;  			ip.PayloadLength = (ushort)packet.Bytes.Length;  			ip.Checksum = (ushort)(ip.Checksum + diff);  		}  		Stripped (sourceIP' destIP' changed);  	}  }  
Magic Number,Nighthawk,SSLStrip,D:\newReposJune17\klemenb_nighthawk\Nighthawk\SSLStrip.cs,ProcessPacket,The following statement contains a magic number: if (data != string.Empty) {  	var changed = new List<string> ();  	var matches = SimpleRegex.GetMatches (regexType' data);  	// HTTP request  	if (matches.Count > 2) {  		// check for images - stop further processing  		if (matches [2].Contains (".png") || matches [2].Contains (".jpg") || matches [2].Contains (".gif"))  			return true;  		// check for Accept-Encoding and replace it to prevent unreadable data  		if (data.Contains ("Accept-Encoding:")) {  			var diff = data.Length - regexEncoding.Replace (data' "Accept-Encoding: \r\n").Length;  			var extra = string.Empty;  			for (int i = 0; i < diff; i++) {  				extra += " ";  			}  			data = regexEncoding.Replace (data' "Accept-Encoding: " + extra + "\r\n");  			changed.Add ("Accept-Encoding");  		}  		// check for If-Modified-Since and replace it to prevent caching  		if (data.Contains ("If-Modified-Since:")) {  			var time = new DateTime (2000' 1' 1);  			data = regexModified.Replace (data' "If-Modified-Since: " + time.ToString ("R") + "\r\n");  			changed.Add ("If-Modified-Since");  		}  		// check for cookies and strip them if necessary  		if (stripCookies && data.Contains ("Cookie:")) {  			data = data.Replace ("Cookie:"' "C00kie:");  			changed.Add ("Cookies");  		}  	} // HTTP response  	else {  		// check for html tags - stop further processing  		if (!(data.Contains ("<form") || data.Contains ("<input") || data.Contains ("<a ") || data.Contains ("</a>") || data.Contains ("</div>") || data.Contains ("<meta") || data.Contains ("javascript")))  			return true;  		var cmatches = SimpleRegex.GetMatches (regexCType' data);  		// check for images - stop further processing  		if (cmatches.Count > 1 && cmatches [1].Contains ("image"))  			return true;  		// HTTP 302 redirect stripping  		foreach (var item in stripRedirects) {  			if (data.Contains ("Location: " + item)) {  				data = data.Replace ("Location: https://"' "Location:  http://");  				changed.Add ("HTTPS (302 redirect)");  			}  		}  		// other links' actions...  		if (data.Contains ("\"https://") || data.Contains ("'https://")) {  			data = data.Replace ("\"https://"' "\" http://");  			data = data.Replace ("'https://"' "' http://");  			changed.Add ("HTTPS");  		}  	}  	if (changed.Count > 0) {  		// change packet data to stripped one  		var bytes = encodingUtf8.GetBytes (data);  		var diff = packet.PayloadData.Length - bytes.Length;  		packet.PayloadData = bytes;  		packet.UpdateTCPChecksum ();  		// checksum fixes for IPv4 packets (IPv6 packet doesn't have a checksum)  		if (packet.ParentPacket is IPv4Packet) {  			var ip = (IPv4Packet)packet.ParentPacket;  			ip.TotalLength = ip.HeaderLength + packet.Bytes.Length;  			ip.PayloadLength = (ushort)packet.Bytes.Length;  			ip.Checksum = (ushort)(ip.Checksum + diff);  		}  		Stripped (sourceIP' destIP' changed);  	}  }  
Magic Number,Nighthawk,SSLStrip,D:\newReposJune17\klemenb_nighthawk\Nighthawk\SSLStrip.cs,ProcessPacket,The following statement contains a magic number: if (data != string.Empty) {  	var changed = new List<string> ();  	var matches = SimpleRegex.GetMatches (regexType' data);  	// HTTP request  	if (matches.Count > 2) {  		// check for images - stop further processing  		if (matches [2].Contains (".png") || matches [2].Contains (".jpg") || matches [2].Contains (".gif"))  			return true;  		// check for Accept-Encoding and replace it to prevent unreadable data  		if (data.Contains ("Accept-Encoding:")) {  			var diff = data.Length - regexEncoding.Replace (data' "Accept-Encoding: \r\n").Length;  			var extra = string.Empty;  			for (int i = 0; i < diff; i++) {  				extra += " ";  			}  			data = regexEncoding.Replace (data' "Accept-Encoding: " + extra + "\r\n");  			changed.Add ("Accept-Encoding");  		}  		// check for If-Modified-Since and replace it to prevent caching  		if (data.Contains ("If-Modified-Since:")) {  			var time = new DateTime (2000' 1' 1);  			data = regexModified.Replace (data' "If-Modified-Since: " + time.ToString ("R") + "\r\n");  			changed.Add ("If-Modified-Since");  		}  		// check for cookies and strip them if necessary  		if (stripCookies && data.Contains ("Cookie:")) {  			data = data.Replace ("Cookie:"' "C00kie:");  			changed.Add ("Cookies");  		}  	} // HTTP response  	else {  		// check for html tags - stop further processing  		if (!(data.Contains ("<form") || data.Contains ("<input") || data.Contains ("<a ") || data.Contains ("</a>") || data.Contains ("</div>") || data.Contains ("<meta") || data.Contains ("javascript")))  			return true;  		var cmatches = SimpleRegex.GetMatches (regexCType' data);  		// check for images - stop further processing  		if (cmatches.Count > 1 && cmatches [1].Contains ("image"))  			return true;  		// HTTP 302 redirect stripping  		foreach (var item in stripRedirects) {  			if (data.Contains ("Location: " + item)) {  				data = data.Replace ("Location: https://"' "Location:  http://");  				changed.Add ("HTTPS (302 redirect)");  			}  		}  		// other links' actions...  		if (data.Contains ("\"https://") || data.Contains ("'https://")) {  			data = data.Replace ("\"https://"' "\" http://");  			data = data.Replace ("'https://"' "' http://");  			changed.Add ("HTTPS");  		}  	}  	if (changed.Count > 0) {  		// change packet data to stripped one  		var bytes = encodingUtf8.GetBytes (data);  		var diff = packet.PayloadData.Length - bytes.Length;  		packet.PayloadData = bytes;  		packet.UpdateTCPChecksum ();  		// checksum fixes for IPv4 packets (IPv6 packet doesn't have a checksum)  		if (packet.ParentPacket is IPv4Packet) {  			var ip = (IPv4Packet)packet.ParentPacket;  			ip.TotalLength = ip.HeaderLength + packet.Bytes.Length;  			ip.PayloadLength = (ushort)packet.Bytes.Length;  			ip.Checksum = (ushort)(ip.Checksum + diff);  		}  		Stripped (sourceIP' destIP' changed);  	}  }  
Magic Number,Nighthawk,SSLStrip,D:\newReposJune17\klemenb_nighthawk\Nighthawk\SSLStrip.cs,ProcessPacket,The following statement contains a magic number: if (data != string.Empty) {  	var changed = new List<string> ();  	var matches = SimpleRegex.GetMatches (regexType' data);  	// HTTP request  	if (matches.Count > 2) {  		// check for images - stop further processing  		if (matches [2].Contains (".png") || matches [2].Contains (".jpg") || matches [2].Contains (".gif"))  			return true;  		// check for Accept-Encoding and replace it to prevent unreadable data  		if (data.Contains ("Accept-Encoding:")) {  			var diff = data.Length - regexEncoding.Replace (data' "Accept-Encoding: \r\n").Length;  			var extra = string.Empty;  			for (int i = 0; i < diff; i++) {  				extra += " ";  			}  			data = regexEncoding.Replace (data' "Accept-Encoding: " + extra + "\r\n");  			changed.Add ("Accept-Encoding");  		}  		// check for If-Modified-Since and replace it to prevent caching  		if (data.Contains ("If-Modified-Since:")) {  			var time = new DateTime (2000' 1' 1);  			data = regexModified.Replace (data' "If-Modified-Since: " + time.ToString ("R") + "\r\n");  			changed.Add ("If-Modified-Since");  		}  		// check for cookies and strip them if necessary  		if (stripCookies && data.Contains ("Cookie:")) {  			data = data.Replace ("Cookie:"' "C00kie:");  			changed.Add ("Cookies");  		}  	} // HTTP response  	else {  		// check for html tags - stop further processing  		if (!(data.Contains ("<form") || data.Contains ("<input") || data.Contains ("<a ") || data.Contains ("</a>") || data.Contains ("</div>") || data.Contains ("<meta") || data.Contains ("javascript")))  			return true;  		var cmatches = SimpleRegex.GetMatches (regexCType' data);  		// check for images - stop further processing  		if (cmatches.Count > 1 && cmatches [1].Contains ("image"))  			return true;  		// HTTP 302 redirect stripping  		foreach (var item in stripRedirects) {  			if (data.Contains ("Location: " + item)) {  				data = data.Replace ("Location: https://"' "Location:  http://");  				changed.Add ("HTTPS (302 redirect)");  			}  		}  		// other links' actions...  		if (data.Contains ("\"https://") || data.Contains ("'https://")) {  			data = data.Replace ("\"https://"' "\" http://");  			data = data.Replace ("'https://"' "' http://");  			changed.Add ("HTTPS");  		}  	}  	if (changed.Count > 0) {  		// change packet data to stripped one  		var bytes = encodingUtf8.GetBytes (data);  		var diff = packet.PayloadData.Length - bytes.Length;  		packet.PayloadData = bytes;  		packet.UpdateTCPChecksum ();  		// checksum fixes for IPv4 packets (IPv6 packet doesn't have a checksum)  		if (packet.ParentPacket is IPv4Packet) {  			var ip = (IPv4Packet)packet.ParentPacket;  			ip.TotalLength = ip.HeaderLength + packet.Bytes.Length;  			ip.PayloadLength = (ushort)packet.Bytes.Length;  			ip.Checksum = (ushort)(ip.Checksum + diff);  		}  		Stripped (sourceIP' destIP' changed);  	}  }  
Magic Number,Nighthawk,SSLStrip,D:\newReposJune17\klemenb_nighthawk\Nighthawk\SSLStrip.cs,ProcessPacket,The following statement contains a magic number: if (data != string.Empty) {  	var changed = new List<string> ();  	var matches = SimpleRegex.GetMatches (regexType' data);  	// HTTP request  	if (matches.Count > 2) {  		// check for images - stop further processing  		if (matches [2].Contains (".png") || matches [2].Contains (".jpg") || matches [2].Contains (".gif"))  			return true;  		// check for Accept-Encoding and replace it to prevent unreadable data  		if (data.Contains ("Accept-Encoding:")) {  			var diff = data.Length - regexEncoding.Replace (data' "Accept-Encoding: \r\n").Length;  			var extra = string.Empty;  			for (int i = 0; i < diff; i++) {  				extra += " ";  			}  			data = regexEncoding.Replace (data' "Accept-Encoding: " + extra + "\r\n");  			changed.Add ("Accept-Encoding");  		}  		// check for If-Modified-Since and replace it to prevent caching  		if (data.Contains ("If-Modified-Since:")) {  			var time = new DateTime (2000' 1' 1);  			data = regexModified.Replace (data' "If-Modified-Since: " + time.ToString ("R") + "\r\n");  			changed.Add ("If-Modified-Since");  		}  		// check for cookies and strip them if necessary  		if (stripCookies && data.Contains ("Cookie:")) {  			data = data.Replace ("Cookie:"' "C00kie:");  			changed.Add ("Cookies");  		}  	} // HTTP response  	else {  		// check for html tags - stop further processing  		if (!(data.Contains ("<form") || data.Contains ("<input") || data.Contains ("<a ") || data.Contains ("</a>") || data.Contains ("</div>") || data.Contains ("<meta") || data.Contains ("javascript")))  			return true;  		var cmatches = SimpleRegex.GetMatches (regexCType' data);  		// check for images - stop further processing  		if (cmatches.Count > 1 && cmatches [1].Contains ("image"))  			return true;  		// HTTP 302 redirect stripping  		foreach (var item in stripRedirects) {  			if (data.Contains ("Location: " + item)) {  				data = data.Replace ("Location: https://"' "Location:  http://");  				changed.Add ("HTTPS (302 redirect)");  			}  		}  		// other links' actions...  		if (data.Contains ("\"https://") || data.Contains ("'https://")) {  			data = data.Replace ("\"https://"' "\" http://");  			data = data.Replace ("'https://"' "' http://");  			changed.Add ("HTTPS");  		}  	}  	if (changed.Count > 0) {  		// change packet data to stripped one  		var bytes = encodingUtf8.GetBytes (data);  		var diff = packet.PayloadData.Length - bytes.Length;  		packet.PayloadData = bytes;  		packet.UpdateTCPChecksum ();  		// checksum fixes for IPv4 packets (IPv6 packet doesn't have a checksum)  		if (packet.ParentPacket is IPv4Packet) {  			var ip = (IPv4Packet)packet.ParentPacket;  			ip.TotalLength = ip.HeaderLength + packet.Bytes.Length;  			ip.PayloadLength = (ushort)packet.Bytes.Length;  			ip.Checksum = (ushort)(ip.Checksum + diff);  		}  		Stripped (sourceIP' destIP' changed);  	}  }  
Magic Number,Nighthawk,SSLStrip,D:\newReposJune17\klemenb_nighthawk\Nighthawk\SSLStrip.cs,ProcessPacket,The following statement contains a magic number: if (matches.Count > 2) {  	// check for images - stop further processing  	if (matches [2].Contains (".png") || matches [2].Contains (".jpg") || matches [2].Contains (".gif"))  		return true;  	// check for Accept-Encoding and replace it to prevent unreadable data  	if (data.Contains ("Accept-Encoding:")) {  		var diff = data.Length - regexEncoding.Replace (data' "Accept-Encoding: \r\n").Length;  		var extra = string.Empty;  		for (int i = 0; i < diff; i++) {  			extra += " ";  		}  		data = regexEncoding.Replace (data' "Accept-Encoding: " + extra + "\r\n");  		changed.Add ("Accept-Encoding");  	}  	// check for If-Modified-Since and replace it to prevent caching  	if (data.Contains ("If-Modified-Since:")) {  		var time = new DateTime (2000' 1' 1);  		data = regexModified.Replace (data' "If-Modified-Since: " + time.ToString ("R") + "\r\n");  		changed.Add ("If-Modified-Since");  	}  	// check for cookies and strip them if necessary  	if (stripCookies && data.Contains ("Cookie:")) {  		data = data.Replace ("Cookie:"' "C00kie:");  		changed.Add ("Cookies");  	}  } // HTTP response  else {  	// check for html tags - stop further processing  	if (!(data.Contains ("<form") || data.Contains ("<input") || data.Contains ("<a ") || data.Contains ("</a>") || data.Contains ("</div>") || data.Contains ("<meta") || data.Contains ("javascript")))  		return true;  	var cmatches = SimpleRegex.GetMatches (regexCType' data);  	// check for images - stop further processing  	if (cmatches.Count > 1 && cmatches [1].Contains ("image"))  		return true;  	// HTTP 302 redirect stripping  	foreach (var item in stripRedirects) {  		if (data.Contains ("Location: " + item)) {  			data = data.Replace ("Location: https://"' "Location:  http://");  			changed.Add ("HTTPS (302 redirect)");  		}  	}  	// other links' actions...  	if (data.Contains ("\"https://") || data.Contains ("'https://")) {  		data = data.Replace ("\"https://"' "\" http://");  		data = data.Replace ("'https://"' "' http://");  		changed.Add ("HTTPS");  	}  }  
Magic Number,Nighthawk,SSLStrip,D:\newReposJune17\klemenb_nighthawk\Nighthawk\SSLStrip.cs,ProcessPacket,The following statement contains a magic number: if (matches.Count > 2) {  	// check for images - stop further processing  	if (matches [2].Contains (".png") || matches [2].Contains (".jpg") || matches [2].Contains (".gif"))  		return true;  	// check for Accept-Encoding and replace it to prevent unreadable data  	if (data.Contains ("Accept-Encoding:")) {  		var diff = data.Length - regexEncoding.Replace (data' "Accept-Encoding: \r\n").Length;  		var extra = string.Empty;  		for (int i = 0; i < diff; i++) {  			extra += " ";  		}  		data = regexEncoding.Replace (data' "Accept-Encoding: " + extra + "\r\n");  		changed.Add ("Accept-Encoding");  	}  	// check for If-Modified-Since and replace it to prevent caching  	if (data.Contains ("If-Modified-Since:")) {  		var time = new DateTime (2000' 1' 1);  		data = regexModified.Replace (data' "If-Modified-Since: " + time.ToString ("R") + "\r\n");  		changed.Add ("If-Modified-Since");  	}  	// check for cookies and strip them if necessary  	if (stripCookies && data.Contains ("Cookie:")) {  		data = data.Replace ("Cookie:"' "C00kie:");  		changed.Add ("Cookies");  	}  } // HTTP response  else {  	// check for html tags - stop further processing  	if (!(data.Contains ("<form") || data.Contains ("<input") || data.Contains ("<a ") || data.Contains ("</a>") || data.Contains ("</div>") || data.Contains ("<meta") || data.Contains ("javascript")))  		return true;  	var cmatches = SimpleRegex.GetMatches (regexCType' data);  	// check for images - stop further processing  	if (cmatches.Count > 1 && cmatches [1].Contains ("image"))  		return true;  	// HTTP 302 redirect stripping  	foreach (var item in stripRedirects) {  		if (data.Contains ("Location: " + item)) {  			data = data.Replace ("Location: https://"' "Location:  http://");  			changed.Add ("HTTPS (302 redirect)");  		}  	}  	// other links' actions...  	if (data.Contains ("\"https://") || data.Contains ("'https://")) {  		data = data.Replace ("\"https://"' "\" http://");  		data = data.Replace ("'https://"' "' http://");  		changed.Add ("HTTPS");  	}  }  
Magic Number,Nighthawk,SSLStrip,D:\newReposJune17\klemenb_nighthawk\Nighthawk\SSLStrip.cs,ProcessPacket,The following statement contains a magic number: if (matches.Count > 2) {  	// check for images - stop further processing  	if (matches [2].Contains (".png") || matches [2].Contains (".jpg") || matches [2].Contains (".gif"))  		return true;  	// check for Accept-Encoding and replace it to prevent unreadable data  	if (data.Contains ("Accept-Encoding:")) {  		var diff = data.Length - regexEncoding.Replace (data' "Accept-Encoding: \r\n").Length;  		var extra = string.Empty;  		for (int i = 0; i < diff; i++) {  			extra += " ";  		}  		data = regexEncoding.Replace (data' "Accept-Encoding: " + extra + "\r\n");  		changed.Add ("Accept-Encoding");  	}  	// check for If-Modified-Since and replace it to prevent caching  	if (data.Contains ("If-Modified-Since:")) {  		var time = new DateTime (2000' 1' 1);  		data = regexModified.Replace (data' "If-Modified-Since: " + time.ToString ("R") + "\r\n");  		changed.Add ("If-Modified-Since");  	}  	// check for cookies and strip them if necessary  	if (stripCookies && data.Contains ("Cookie:")) {  		data = data.Replace ("Cookie:"' "C00kie:");  		changed.Add ("Cookies");  	}  } // HTTP response  else {  	// check for html tags - stop further processing  	if (!(data.Contains ("<form") || data.Contains ("<input") || data.Contains ("<a ") || data.Contains ("</a>") || data.Contains ("</div>") || data.Contains ("<meta") || data.Contains ("javascript")))  		return true;  	var cmatches = SimpleRegex.GetMatches (regexCType' data);  	// check for images - stop further processing  	if (cmatches.Count > 1 && cmatches [1].Contains ("image"))  		return true;  	// HTTP 302 redirect stripping  	foreach (var item in stripRedirects) {  		if (data.Contains ("Location: " + item)) {  			data = data.Replace ("Location: https://"' "Location:  http://");  			changed.Add ("HTTPS (302 redirect)");  		}  	}  	// other links' actions...  	if (data.Contains ("\"https://") || data.Contains ("'https://")) {  		data = data.Replace ("\"https://"' "\" http://");  		data = data.Replace ("'https://"' "' http://");  		changed.Add ("HTTPS");  	}  }  
Magic Number,Nighthawk,SSLStrip,D:\newReposJune17\klemenb_nighthawk\Nighthawk\SSLStrip.cs,ProcessPacket,The following statement contains a magic number: if (matches.Count > 2) {  	// check for images - stop further processing  	if (matches [2].Contains (".png") || matches [2].Contains (".jpg") || matches [2].Contains (".gif"))  		return true;  	// check for Accept-Encoding and replace it to prevent unreadable data  	if (data.Contains ("Accept-Encoding:")) {  		var diff = data.Length - regexEncoding.Replace (data' "Accept-Encoding: \r\n").Length;  		var extra = string.Empty;  		for (int i = 0; i < diff; i++) {  			extra += " ";  		}  		data = regexEncoding.Replace (data' "Accept-Encoding: " + extra + "\r\n");  		changed.Add ("Accept-Encoding");  	}  	// check for If-Modified-Since and replace it to prevent caching  	if (data.Contains ("If-Modified-Since:")) {  		var time = new DateTime (2000' 1' 1);  		data = regexModified.Replace (data' "If-Modified-Since: " + time.ToString ("R") + "\r\n");  		changed.Add ("If-Modified-Since");  	}  	// check for cookies and strip them if necessary  	if (stripCookies && data.Contains ("Cookie:")) {  		data = data.Replace ("Cookie:"' "C00kie:");  		changed.Add ("Cookies");  	}  } // HTTP response  else {  	// check for html tags - stop further processing  	if (!(data.Contains ("<form") || data.Contains ("<input") || data.Contains ("<a ") || data.Contains ("</a>") || data.Contains ("</div>") || data.Contains ("<meta") || data.Contains ("javascript")))  		return true;  	var cmatches = SimpleRegex.GetMatches (regexCType' data);  	// check for images - stop further processing  	if (cmatches.Count > 1 && cmatches [1].Contains ("image"))  		return true;  	// HTTP 302 redirect stripping  	foreach (var item in stripRedirects) {  		if (data.Contains ("Location: " + item)) {  			data = data.Replace ("Location: https://"' "Location:  http://");  			changed.Add ("HTTPS (302 redirect)");  		}  	}  	// other links' actions...  	if (data.Contains ("\"https://") || data.Contains ("'https://")) {  		data = data.Replace ("\"https://"' "\" http://");  		data = data.Replace ("'https://"' "' http://");  		changed.Add ("HTTPS");  	}  }  
Magic Number,Nighthawk,SSLStrip,D:\newReposJune17\klemenb_nighthawk\Nighthawk\SSLStrip.cs,ProcessPacket,The following statement contains a magic number: if (matches.Count > 2) {  	// check for images - stop further processing  	if (matches [2].Contains (".png") || matches [2].Contains (".jpg") || matches [2].Contains (".gif"))  		return true;  	// check for Accept-Encoding and replace it to prevent unreadable data  	if (data.Contains ("Accept-Encoding:")) {  		var diff = data.Length - regexEncoding.Replace (data' "Accept-Encoding: \r\n").Length;  		var extra = string.Empty;  		for (int i = 0; i < diff; i++) {  			extra += " ";  		}  		data = regexEncoding.Replace (data' "Accept-Encoding: " + extra + "\r\n");  		changed.Add ("Accept-Encoding");  	}  	// check for If-Modified-Since and replace it to prevent caching  	if (data.Contains ("If-Modified-Since:")) {  		var time = new DateTime (2000' 1' 1);  		data = regexModified.Replace (data' "If-Modified-Since: " + time.ToString ("R") + "\r\n");  		changed.Add ("If-Modified-Since");  	}  	// check for cookies and strip them if necessary  	if (stripCookies && data.Contains ("Cookie:")) {  		data = data.Replace ("Cookie:"' "C00kie:");  		changed.Add ("Cookies");  	}  } // HTTP response  else {  	// check for html tags - stop further processing  	if (!(data.Contains ("<form") || data.Contains ("<input") || data.Contains ("<a ") || data.Contains ("</a>") || data.Contains ("</div>") || data.Contains ("<meta") || data.Contains ("javascript")))  		return true;  	var cmatches = SimpleRegex.GetMatches (regexCType' data);  	// check for images - stop further processing  	if (cmatches.Count > 1 && cmatches [1].Contains ("image"))  		return true;  	// HTTP 302 redirect stripping  	foreach (var item in stripRedirects) {  		if (data.Contains ("Location: " + item)) {  			data = data.Replace ("Location: https://"' "Location:  http://");  			changed.Add ("HTTPS (302 redirect)");  		}  	}  	// other links' actions...  	if (data.Contains ("\"https://") || data.Contains ("'https://")) {  		data = data.Replace ("\"https://"' "\" http://");  		data = data.Replace ("'https://"' "' http://");  		changed.Add ("HTTPS");  	}  }  
Magic Number,Nighthawk,SSLStrip,D:\newReposJune17\klemenb_nighthawk\Nighthawk\SSLStrip.cs,ProcessPacket,The following statement contains a magic number: if (matches [2].Contains (".png") || matches [2].Contains (".jpg") || matches [2].Contains (".gif"))  	return true;  
Magic Number,Nighthawk,SSLStrip,D:\newReposJune17\klemenb_nighthawk\Nighthawk\SSLStrip.cs,ProcessPacket,The following statement contains a magic number: if (matches [2].Contains (".png") || matches [2].Contains (".jpg") || matches [2].Contains (".gif"))  	return true;  
Magic Number,Nighthawk,SSLStrip,D:\newReposJune17\klemenb_nighthawk\Nighthawk\SSLStrip.cs,ProcessPacket,The following statement contains a magic number: if (matches [2].Contains (".png") || matches [2].Contains (".jpg") || matches [2].Contains (".gif"))  	return true;  
Magic Number,Nighthawk,SSLStrip,D:\newReposJune17\klemenb_nighthawk\Nighthawk\SSLStrip.cs,ProcessPacket,The following statement contains a magic number: if (data.Contains ("If-Modified-Since:")) {  	var time = new DateTime (2000' 1' 1);  	data = regexModified.Replace (data' "If-Modified-Since: " + time.ToString ("R") + "\r\n");  	changed.Add ("If-Modified-Since");  }  
Magic Number,Nighthawk,HttpPacket,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HttpPacket,The following statement contains a magic number: if (postParts || parts [0].Substring (0' 4) == "POST") {  	// split params  	if (postParts || parts.Length > 1) {  		var postLine = data;  		// if we have headers in the packet  		if (parts.Length > 1) {  			postLine = parts [1];  		}  		var postParams = postLine.Split ('&');  		if (postParams.Length > 1) {  			foreach (var param in postParams) {  				if (param.Contains ('=')) {  					var splitParam = param.Split ('=');  					if (splitParam.Length == 2) {  						PostParams.Add (new string[] {  							splitParam [0] != null ? splitParam [0] : string.Empty'  							splitParam [1] != null ? splitParam [1] : string.Empty  						});  					}  				}  			}  		}  	}  }  
Magic Number,Nighthawk,HttpPacket,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HttpPacket,The following statement contains a magic number: if (postParts || parts [0].Substring (0' 4) == "POST") {  	// split params  	if (postParts || parts.Length > 1) {  		var postLine = data;  		// if we have headers in the packet  		if (parts.Length > 1) {  			postLine = parts [1];  		}  		var postParams = postLine.Split ('&');  		if (postParams.Length > 1) {  			foreach (var param in postParams) {  				if (param.Contains ('=')) {  					var splitParam = param.Split ('=');  					if (splitParam.Length == 2) {  						PostParams.Add (new string[] {  							splitParam [0] != null ? splitParam [0] : string.Empty'  							splitParam [1] != null ? splitParam [1] : string.Empty  						});  					}  				}  			}  		}  	}  }  
Magic Number,Nighthawk,HttpPacket,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HttpPacket,The following statement contains a magic number: if (postParts || parts.Length > 1) {  	var postLine = data;  	// if we have headers in the packet  	if (parts.Length > 1) {  		postLine = parts [1];  	}  	var postParams = postLine.Split ('&');  	if (postParams.Length > 1) {  		foreach (var param in postParams) {  			if (param.Contains ('=')) {  				var splitParam = param.Split ('=');  				if (splitParam.Length == 2) {  					PostParams.Add (new string[] {  						splitParam [0] != null ? splitParam [0] : string.Empty'  						splitParam [1] != null ? splitParam [1] : string.Empty  					});  				}  			}  		}  	}  }  
Magic Number,Nighthawk,HttpPacket,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HttpPacket,The following statement contains a magic number: if (postParams.Length > 1) {  	foreach (var param in postParams) {  		if (param.Contains ('=')) {  			var splitParam = param.Split ('=');  			if (splitParam.Length == 2) {  				PostParams.Add (new string[] {  					splitParam [0] != null ? splitParam [0] : string.Empty'  					splitParam [1] != null ? splitParam [1] : string.Empty  				});  			}  		}  	}  }  
Magic Number,Nighthawk,HttpPacket,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HttpPacket,The following statement contains a magic number: foreach (var param in postParams) {  	if (param.Contains ('=')) {  		var splitParam = param.Split ('=');  		if (splitParam.Length == 2) {  			PostParams.Add (new string[] {  				splitParam [0] != null ? splitParam [0] : string.Empty'  				splitParam [1] != null ? splitParam [1] : string.Empty  			});  		}  	}  }  
Magic Number,Nighthawk,HttpPacket,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HttpPacket,The following statement contains a magic number: if (param.Contains ('=')) {  	var splitParam = param.Split ('=');  	if (splitParam.Length == 2) {  		PostParams.Add (new string[] {  			splitParam [0] != null ? splitParam [0] : string.Empty'  			splitParam [1] != null ? splitParam [1] : string.Empty  		});  	}  }  
Magic Number,Nighthawk,HttpPacket,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HttpPacket,The following statement contains a magic number: if (splitParam.Length == 2) {  	PostParams.Add (new string[] {  		splitParam [0] != null ? splitParam [0] : string.Empty'  		splitParam [1] != null ? splitParam [1] : string.Empty  	});  }  
Magic Number,Nighthawk,HttpPacket,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HasPOST,The following statement contains a magic number: if (packet.PayloadData != null) {  	var data = encoding.GetString (packet.PayloadData);  	// check for possible full GET/POST requests  	if (data.Length > 3 && (data.Substring (0' 4) == "POST" || data.Substring (0' 3) == "GET"))  		return false;  	// get rid of possible left-over headers  	if (data.Contains ("\r\n\r\n")) {  		var parts = Regex.Split (data' "\r\n\r\n");  		if (parts.Length > 1)  			data = parts [1];  	}  	// check for "key=value" pairs  	var split = data.Split ('&');  	if (split.Length > 0) {  		var keys = split [0].Split ('=');  		if (keys.Length > 0)  			return true;  	}  }  
Magic Number,Nighthawk,HttpPacket,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HasPOST,The following statement contains a magic number: if (packet.PayloadData != null) {  	var data = encoding.GetString (packet.PayloadData);  	// check for possible full GET/POST requests  	if (data.Length > 3 && (data.Substring (0' 4) == "POST" || data.Substring (0' 3) == "GET"))  		return false;  	// get rid of possible left-over headers  	if (data.Contains ("\r\n\r\n")) {  		var parts = Regex.Split (data' "\r\n\r\n");  		if (parts.Length > 1)  			data = parts [1];  	}  	// check for "key=value" pairs  	var split = data.Split ('&');  	if (split.Length > 0) {  		var keys = split [0].Split ('=');  		if (keys.Length > 0)  			return true;  	}  }  
Magic Number,Nighthawk,HttpPacket,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HasPOST,The following statement contains a magic number: if (packet.PayloadData != null) {  	var data = encoding.GetString (packet.PayloadData);  	// check for possible full GET/POST requests  	if (data.Length > 3 && (data.Substring (0' 4) == "POST" || data.Substring (0' 3) == "GET"))  		return false;  	// get rid of possible left-over headers  	if (data.Contains ("\r\n\r\n")) {  		var parts = Regex.Split (data' "\r\n\r\n");  		if (parts.Length > 1)  			data = parts [1];  	}  	// check for "key=value" pairs  	var split = data.Split ('&');  	if (split.Length > 0) {  		var keys = split [0].Split ('=');  		if (keys.Length > 0)  			return true;  	}  }  
Magic Number,Nighthawk,HttpPacket,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HasPOST,The following statement contains a magic number: if (data.Length > 3 && (data.Substring (0' 4) == "POST" || data.Substring (0' 3) == "GET"))  	return false;  
Magic Number,Nighthawk,HttpPacket,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HasPOST,The following statement contains a magic number: if (data.Length > 3 && (data.Substring (0' 4) == "POST" || data.Substring (0' 3) == "GET"))  	return false;  
Magic Number,Nighthawk,HttpPacket,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HasPOST,The following statement contains a magic number: if (data.Length > 3 && (data.Substring (0' 4) == "POST" || data.Substring (0' 3) == "GET"))  	return false;  
Magic Number,Nighthawk,HttpHeader,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HttpHeader,The following statement contains a magic number: if (header.Length > 4 && (header.Substring (0' 3) == "GET" || header.Substring (0' 4) == "POST")) {  	Type = PacketType.Request;  } else {  	Type = PacketType.Response;  }  
Magic Number,Nighthawk,HttpHeader,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HttpHeader,The following statement contains a magic number: if (header.Length > 4 && (header.Substring (0' 3) == "GET" || header.Substring (0' 4) == "POST")) {  	Type = PacketType.Request;  } else {  	Type = PacketType.Response;  }  
Magic Number,Nighthawk,HttpHeader,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HttpHeader,The following statement contains a magic number: if (header.Length > 4 && (header.Substring (0' 3) == "GET" || header.Substring (0' 4) == "POST")) {  	Type = PacketType.Request;  } else {  	Type = PacketType.Response;  }  
Magic Number,Nighthawk,HttpHeader,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HttpHeader,The following statement contains a magic number: if (Type == PacketType.Response) {  	var codeMatches = SimpleRegex.GetMatches (regexCode' header);  	if (codeMatches != null && codeMatches.Count > 1)  		Code = codeMatches [2];  }  
Magic Number,Nighthawk,HttpHeader,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HttpHeader,The following statement contains a magic number: if (codeMatches != null && codeMatches.Count > 1)  	Code = codeMatches [2];  
Magic Number,Nighthawk,HttpHeader,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HttpHeader,The following statement contains a magic number: Code = codeMatches [2];  
Magic Number,Nighthawk,HttpHeader,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HttpHeader,The following statement contains a magic number: if (Type == PacketType.Request) {  	var pathMatches = SimpleRegex.GetMatches (regexPath' header);  	if (pathMatches != null && pathMatches.Count > 1) {  		if (pathMatches [1] == "GET") {  			ReqType = RequestType.GET;  		} else if (pathMatches [1] == "POST") {  			ReqType = RequestType.POST;  		}  		Path = pathMatches [2];  	}  }  
Magic Number,Nighthawk,HttpHeader,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HttpHeader,The following statement contains a magic number: if (pathMatches != null && pathMatches.Count > 1) {  	if (pathMatches [1] == "GET") {  		ReqType = RequestType.GET;  	} else if (pathMatches [1] == "POST") {  		ReqType = RequestType.POST;  	}  	Path = pathMatches [2];  }  
Magic Number,Nighthawk,HttpHeader,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HttpHeader,The following statement contains a magic number: Path = pathMatches [2];  
Magic Number,Nighthawk,HttpHeader,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HttpHeader,The following statement contains a magic number: if (Type == PacketType.Request) {  	var getLine = Path.Split ('?');  	// are there any params?  	if (getLine.Length == 2) {  		var getParams = getLine [1].Split ('&');  		foreach (var param in getParams) {  			var splitParam = param.Split ('=');  			if (splitParam.Count () == 2)  				GetParams.Add (new string[] {  					splitParam [0] != null ? splitParam [0] : string.Empty'  					splitParam [1] != null ? splitParam [1] : string.Empty  				});  		}  	}  }  
Magic Number,Nighthawk,HttpHeader,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HttpHeader,The following statement contains a magic number: if (Type == PacketType.Request) {  	var getLine = Path.Split ('?');  	// are there any params?  	if (getLine.Length == 2) {  		var getParams = getLine [1].Split ('&');  		foreach (var param in getParams) {  			var splitParam = param.Split ('=');  			if (splitParam.Count () == 2)  				GetParams.Add (new string[] {  					splitParam [0] != null ? splitParam [0] : string.Empty'  					splitParam [1] != null ? splitParam [1] : string.Empty  				});  		}  	}  }  
Magic Number,Nighthawk,HttpHeader,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HttpHeader,The following statement contains a magic number: if (getLine.Length == 2) {  	var getParams = getLine [1].Split ('&');  	foreach (var param in getParams) {  		var splitParam = param.Split ('=');  		if (splitParam.Count () == 2)  			GetParams.Add (new string[] {  				splitParam [0] != null ? splitParam [0] : string.Empty'  				splitParam [1] != null ? splitParam [1] : string.Empty  			});  	}  }  
Magic Number,Nighthawk,HttpHeader,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HttpHeader,The following statement contains a magic number: if (getLine.Length == 2) {  	var getParams = getLine [1].Split ('&');  	foreach (var param in getParams) {  		var splitParam = param.Split ('=');  		if (splitParam.Count () == 2)  			GetParams.Add (new string[] {  				splitParam [0] != null ? splitParam [0] : string.Empty'  				splitParam [1] != null ? splitParam [1] : string.Empty  			});  	}  }  
Magic Number,Nighthawk,HttpHeader,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HttpHeader,The following statement contains a magic number: foreach (var param in getParams) {  	var splitParam = param.Split ('=');  	if (splitParam.Count () == 2)  		GetParams.Add (new string[] {  			splitParam [0] != null ? splitParam [0] : string.Empty'  			splitParam [1] != null ? splitParam [1] : string.Empty  		});  }  
Magic Number,Nighthawk,HttpHeader,D:\newReposJune17\klemenb_nighthawk\Nighthawk\HTTP.cs,HttpHeader,The following statement contains a magic number: if (splitParam.Count () == 2)  	GetParams.Add (new string[] {  		splitParam [0] != null ? splitParam [0] : string.Empty'  		splitParam [1] != null ? splitParam [1] : string.Empty  	});  
Magic Number,Nighthawk,MainWindow,D:\newReposJune17\klemenb_nighthawk\Nighthawk\MainWindow.xaml.cs,Window_Loaded,The following statement contains a magic number: if (Environment.OSVersion.Version.Major == 6 && Environment.OSVersion.Version.Minor > 1)  	RCTSnifferUpdated.Margin = new Thickness (122' RCTSnifferUpdated.Margin.Top' RCTSnifferUpdated.Margin.Right' RCTSnifferUpdated.Margin.Bottom);  
Magic Number,Nighthawk,MainWindow,D:\newReposJune17\klemenb_nighthawk\Nighthawk\MainWindow.xaml.cs,Window_Loaded,The following statement contains a magic number: if (Environment.OSVersion.Version.Major == 6 && Environment.OSVersion.Version.Minor > 1)  	RCTSnifferUpdated.Margin = new Thickness (122' RCTSnifferUpdated.Margin.Top' RCTSnifferUpdated.Margin.Right' RCTSnifferUpdated.Margin.Bottom);  
Magic Number,Nighthawk,MainWindow,D:\newReposJune17\klemenb_nighthawk\Nighthawk\MainWindow.xaml.cs,Window_Loaded,The following statement contains a magic number: RCTSnifferUpdated.Margin = new Thickness (122' RCTSnifferUpdated.Margin.Top' RCTSnifferUpdated.Margin.Right' RCTSnifferUpdated.Margin.Bottom);  
Magic Number,Nighthawk,MainWindow,D:\newReposJune17\klemenb_nighthawk\Nighthawk\MainWindow.xaml.cs,Window_Closed,The following statement contains a magic number: if (WindowLoaded && Nighthawk.Started) {  	Nighthawk.ARPTools.StopSpoofing ();  	Nighthawk.NDTools.StopSpoofing ();  	Nighthawk.Sniffer.Stop ();  	Nighthawk.SSLStrip.Stop ();  	while (Nighthawk.Scanner.Started) {  		Thread.Sleep (50);  	}  	Nighthawk.StopDevice ();  	Application.Current.Shutdown ();  }  
Magic Number,Nighthawk,MainWindow,D:\newReposJune17\klemenb_nighthawk\Nighthawk\MainWindow.xaml.cs,Window_Closed,The following statement contains a magic number: while (Nighthawk.Scanner.Started) {  	Thread.Sleep (50);  }  
Magic Number,Nighthawk,MainWindow,D:\newReposJune17\klemenb_nighthawk\Nighthawk\MainWindow.xaml.cs,Window_Closed,The following statement contains a magic number: Thread.Sleep (50);  
