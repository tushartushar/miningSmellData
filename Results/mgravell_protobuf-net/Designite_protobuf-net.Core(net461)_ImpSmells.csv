Implementation smell,Namespace,Class,File,Method,Description
Complex Method,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,ReadLongLengthPrefix,Cyclomatic complexity of the method is 11
Complex Method,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,TryReadUInt64Varint,Cyclomatic complexity of the method is 8
Complex Method,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,Seek,Cyclomatic complexity of the method is 8
Complex Method,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt64Varint,Cyclomatic complexity of the method is 21
Complex Method,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ReadPackedScalar,Cyclomatic complexity of the method is 10
Complex Method,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,WriteObject,Cyclomatic complexity of the method is 8
Complex Method,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt32Varint,Cyclomatic complexity of the method is 12
Complex Method,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt32VarintWithoutMoving,Cyclomatic complexity of the method is 13
Complex Method,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,Cyclomatic complexity of the method is 22
Complex Method,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,Ensure,Cyclomatic complexity of the method is 9
Complex Method,ProtoBuf,BufferWriterProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.BufferWriter.cs,WriteWithLengthPrefix,Cyclomatic complexity of the method is 8
Complex Method,ProtoBuf.Internal,ScaledTicks,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\PrimaryTypeProvider.TimeSpan.cs,ToDateTime,Cyclomatic complexity of the method is 10
Complex Method,ProtoBuf.Internal,ScaledTicks,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\PrimaryTypeProvider.TimeSpan.cs,ScaledTicks,Cyclomatic complexity of the method is 8
Complex Method,ProtoBuf.Internal,ScaledTicks,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\PrimaryTypeProvider.TimeSpan.cs,ToTimeSpan,Cyclomatic complexity of the method is 10
Complex Method,ProtoBuf.Internal,TypeHelper,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\TypeHelperT.cs,ResolveUniqueEnumerableT,Cyclomatic complexity of the method is 8
Complex Method,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,TrySerializeAuxiliaryType,Cyclomatic complexity of the method is 8
Complex Method,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,CreateListInstance,Cyclomatic complexity of the method is 8
Complex Method,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,TryDeserializeAuxiliaryType,Cyclomatic complexity of the method is 16
Complex Method,ProtoBuf.Serializers,SerializerCache,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\SerializerCache.cs,Verify,Cyclomatic complexity of the method is 11
Long Parameter List,ProtoBuf,Extensible,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Extensible.cs,AppendValue,The method has 5 parameters. Parameters: model' instance' tag' value' format
Long Parameter List,ProtoBuf,Extensible,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Extensible.cs,TryGetValue,The method has 5 parameters. Parameters: instance' tag' format' allowDefinedTag' value
Long Parameter List,ProtoBuf,Extensible,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Extensible.cs,TryGetValue,The method has 6 parameters. Parameters: model' instance' tag' value' format' allowDefinedTag
Long Parameter List,ProtoBuf,Extensible,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Extensible.cs,TryGetValue,The method has 7 parameters. Parameters: model' type' instance' tag' format' allowDefinedTag' value
Long Parameter List,ProtoBuf,Extensible,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Extensible.cs,GetValues,The method has 5 parameters. Parameters: model' type' instance' tag' format
Long Parameter List,ProtoBuf,Extensible,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Extensible.cs,AppendValue,The method has 5 parameters. Parameters: model' instance' tag' format' value
Long Parameter List,ProtoBuf,ExtensibleUtil,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ExtensibleUtil.cs,GetExtendedValues,The method has 6 parameters. Parameters: model' instance' tag' format' singleton' allowDefinedTag
Long Parameter List,ProtoBuf,ExtensibleUtil,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ExtensibleUtil.cs,GetExtendedValues,The method has 7 parameters. Parameters: model' type' instance' tag' format' singleton' allowDefinedTag
Long Parameter List,ProtoBuf,ExtensibleUtil,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ExtensibleUtil.cs,AppendExtendValue,The method has 5 parameters. Parameters: model' instance' tag' format' value
Long Parameter List,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,ReadLengthPrefix,The method has 5 parameters. Parameters: source' expectHeader' style' fieldNumber' bytesRead
Long Parameter List,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,ReadLongLengthPrefix,The method has 5 parameters. Parameters: source' expectHeader' style' fieldNumber' bytesRead
Long Parameter List,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ReadRepeatedCore,The method has 5 parameters. Parameters: values' category' wireType' serializer' initialValue
Long Parameter List,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt32Varint,The method has 5 parameters. Parameters: state' offset' trimNegative' value' span
Long Parameter List,ProtoBuf,ProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.BufferWriter.cs,WriteMessage,The method has 5 parameters. Parameters: state' value' serializer' style' recursionCheck
Long Parameter List,ProtoBuf,BufferWriterProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.BufferWriter.cs,WriteMessage,The method has 5 parameters. Parameters: state' value' serializer' style' recursionCheck
Long Parameter List,ProtoBuf,NullProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Null.cs,WriteMessage,The method has 5 parameters. Parameters: state' value' serializer' style' recursionCheck
Long Parameter List,ProtoBuf.Internal,DynamicStub,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\DynamicStub.cs,TryDeserializeRoot,The method has 5 parameters. Parameters: type' model' state' value' autoCreate
Long Parameter List,ProtoBuf.Internal,DynamicStub,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\DynamicStub.cs,TryDeserialize,The method has 5 parameters. Parameters: scope' type' model' state' value
Long Parameter List,ProtoBuf.Internal,DynamicStub,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\DynamicStub.cs,TrySerializeAny,The method has 6 parameters. Parameters: fieldNumber' features' type' model' state' value
Long Parameter List,ProtoBuf.Internal,DynamicStub,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\DynamicStub.cs,TrySerializeAny,The method has 5 parameters. Parameters: fieldNumber' features' model' state' value
Long Parameter List,ProtoBuf.Internal,NilStub,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\DynamicStub.cs,TrySerializeAny,The method has 5 parameters. Parameters: fieldNumber' features' model' state' value
Long Parameter List,ProtoBuf.Internal,ConcreteStub<T>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\DynamicStub.cs,TrySerializeAny,The method has 5 parameters. Parameters: fieldNumber' features' model' state' value
Long Parameter List,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,TrySerializeAuxiliaryType,The method has 7 parameters. Parameters: state' type' format' tag' value' isInsideList' parentList
Long Parameter List,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,DeserializeWithLengthPrefix,The method has 5 parameters. Parameters: source' value' type' style' fieldNumber
Long Parameter List,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,DeserializeWithLengthPrefix,The method has 6 parameters. Parameters: source' value' type' style' expectedField' resolver
Long Parameter List,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,DeserializeWithLengthPrefix,The method has 7 parameters. Parameters: source' value' type' style' expectedField' resolver' bytesRead
Long Parameter List,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,DeserializeWithLengthPrefix,The method has 7 parameters. Parameters: source' value' type' style' expectedField' resolver' bytesRead
Long Parameter List,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,DeserializeWithLengthPrefix,The method has 9 parameters. Parameters: source' value' type' style' expectedField' resolver' bytesRead' haveObject' context
Long Parameter List,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,DeserializeItems,The method has 5 parameters. Parameters: source' type' style' expectedField' resolver
Long Parameter List,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,DeserializeItems,The method has 6 parameters. Parameters: source' type' style' expectedField' resolver' context
Long Parameter List,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,SerializeWithLengthPrefix,The method has 5 parameters. Parameters: dest' value' type' style' fieldNumber
Long Parameter List,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,SerializeWithLengthPrefix,The method has 6 parameters. Parameters: dest' value' type' style' fieldNumber' context
Long Parameter List,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,Deserialize,The method has 5 parameters. Parameters: source' value' type' length' context
Long Parameter List,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,Deserialize,The method has 5 parameters. Parameters: source' value' type' length' context
Long Parameter List,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,TryDeserializeList,The method has 6 parameters. Parameters: state' format' tag' listType' itemType' value
Long Parameter List,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,TryDeserializeAuxiliaryType,The method has 10 parameters. Parameters: state' format' tag' type' value' skipOtherFields' asListItem' autoCreate' insideList' parentListOrType
Long Parameter List,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,TryDeserializeAuxiliaryType,The method has 10 parameters. Parameters: state' format' tag' type' value' skipOtherFields' asListItem' autoCreate' insideList' parentListOrType
Long Parameter List,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,CanSerialize,The method has 5 parameters. Parameters: type' allowBasic' allowContract' allowLists' category
Long Parameter List,ProtoBuf.Meta,DeserializeItemsIterator<T>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,DeserializeItemsIterator,The method has 5 parameters. Parameters: model' source' style' expectedField' context
Long Parameter List,ProtoBuf.Meta,DeserializeItemsIterator,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,DeserializeItemsIterator,The method has 7 parameters. Parameters: model' source' type' style' expectedField' resolver' context
Long Parameter List,ProtoBuf.Serializers,ConcurrentDictionarySerializer<TCollection;TKey;TValue>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\MapSerializer.Concurrent.cs,Write,The method has 5 parameters. Parameters: state' fieldNumber' wireType' values' pairSerializer
Long Parameter List,ProtoBuf.Serializers,MapSerializer<TCollection;TKey;TValue>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\MapSerializer.cs,GetSerializer,The method has 5 parameters. Parameters: model' keyFeatures' valueFeatures' keySerializer' valueSerializer
Long Parameter List,ProtoBuf.Serializers,MapSerializer<TCollection;TKey;TValue>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\MapSerializer.cs,WriteMap,The method has 8 parameters. Parameters: state' fieldNumber' features' values' keyFeatures' valueFeatures' keySerializer' valueSerializer
Long Parameter List,ProtoBuf.Serializers,MapSerializer<TCollection;TKey;TValue>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\MapSerializer.cs,Write,The method has 5 parameters. Parameters: state' fieldNumber' wireType' values' pairSerializer
Long Parameter List,ProtoBuf.Serializers,MapSerializer<TCollection;TKey;TValue>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\MapSerializer.cs,Write,The method has 5 parameters. Parameters: state' fieldNumber' wireType' enumerator' pairSerializer
Long Parameter List,ProtoBuf.Serializers,MapSerializer<TCollection;TKey;TValue>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\MapSerializer.cs,ReadMap,The method has 7 parameters. Parameters: state' features' values' keyFeatures' valueFeatures' keySerializer' valueSerializer
Long Parameter List,ProtoBuf.Serializers,DictionarySerializer<TKey;TValue>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\MapSerializer.cs,Write,The method has 5 parameters. Parameters: state' fieldNumber' wireType' values' pairSerializer
Long Parameter List,ProtoBuf.Serializers,DictionarySerializer<TCollection;TKey;TValue>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\MapSerializer.cs,Write,The method has 5 parameters. Parameters: state' fieldNumber' wireType' values' pairSerializer
Long Parameter List,ProtoBuf.Serializers,ImmutableDictionarySerializer<TKey;TValue>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\MapSerializer.Immutable.cs,Write,The method has 5 parameters. Parameters: state' fieldNumber' wireType' values' pairSerializer
Long Parameter List,ProtoBuf.Serializers,ImmutableSortedDictionarySerializer<TKey;TValue>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\MapSerializer.Immutable.cs,Write,The method has 5 parameters. Parameters: state' fieldNumber' wireType' values' pairSerializer
Long Parameter List,ProtoBuf.Serializers,ImmutableIDictionarySerializer<TKey;TValue>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\MapSerializer.Immutable.cs,Write,The method has 5 parameters. Parameters: state' fieldNumber' wireType' values' pairSerializer
Long Parameter List,ProtoBuf.Serializers,ProducerConsumerSerializer<TCollection;T>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\RepeatedSerializer.Concurrent.cs,Write,The method has 6 parameters. Parameters: state' fieldNumber' category' wireType' values' serializer
Long Parameter List,ProtoBuf.Serializers,RepeatedSerializer<TCollection;TItem>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\RepeatedSerializer.cs,WriteRepeated,The method has 5 parameters. Parameters: state' fieldNumber' features' values' serializer
Long Parameter List,ProtoBuf.Serializers,RepeatedSerializer<TCollection;TItem>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\RepeatedSerializer.cs,Write,The method has 6 parameters. Parameters: state' fieldNumber' category' wireType' values' serializer
Long Parameter List,ProtoBuf.Serializers,RepeatedSerializer<TCollection;TItem>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\RepeatedSerializer.cs,Write,The method has 6 parameters. Parameters: state' fieldNumber' category' wireType' values' serializer
Long Parameter List,ProtoBuf.Serializers,RepeatedSerializer<TCollection;TItem>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\RepeatedSerializer.cs,WritePacked,The method has 6 parameters. Parameters: state' fieldNumber' wireType' values' count' serializer
Long Parameter List,ProtoBuf.Serializers,StackSerializer<TCollection;T>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\RepeatedSerializer.cs,Write,The method has 6 parameters. Parameters: state' fieldNumber' category' wireType' values' serializer
Long Parameter List,ProtoBuf.Serializers,ListSerializer<TList;T>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\RepeatedSerializer.cs,Write,The method has 6 parameters. Parameters: state' fieldNumber' category' wireType' values' serializer
Long Parameter List,ProtoBuf.Serializers,EnumerableSerializer<TCollection;TCreate;T>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\RepeatedSerializer.cs,Write,The method has 6 parameters. Parameters: state' fieldNumber' category' wireType' values' serializer
Long Parameter List,ProtoBuf.Serializers,VectorSerializer<T>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\RepeatedSerializer.cs,Write,The method has 6 parameters. Parameters: state' fieldNumber' category' wireType' values' serializer
Long Parameter List,ProtoBuf.Serializers,QueueSerializer<TCollection;T>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\RepeatedSerializer.cs,Write,The method has 6 parameters. Parameters: state' fieldNumber' category' wireType' values' serializer
Long Parameter List,ProtoBuf.Serializers,ImmutableArraySerializer<T>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\RepeatedSerializer.Immutable.cs,Write,The method has 6 parameters. Parameters: state' fieldNumber' category' wireType' values' serializer
Long Parameter List,ProtoBuf.Serializers,ImmutableListSerializer<T>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\RepeatedSerializer.Immutable.cs,Write,The method has 6 parameters. Parameters: state' fieldNumber' category' wireType' values' serializer
Long Parameter List,ProtoBuf.Serializers,ImmutableIListSerializer<T>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\RepeatedSerializer.Immutable.cs,Write,The method has 6 parameters. Parameters: state' fieldNumber' category' wireType' values' serializer
Long Parameter List,ProtoBuf.Serializers,ImmutableHashSetSerializer<T>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\RepeatedSerializer.Immutable.cs,Write,The method has 6 parameters. Parameters: state' fieldNumber' category' wireType' values' serializer
Long Parameter List,ProtoBuf.Serializers,ImmutableSortedSetSerializer<T>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\RepeatedSerializer.Immutable.cs,Write,The method has 6 parameters. Parameters: state' fieldNumber' category' wireType' values' serializer
Long Parameter List,ProtoBuf.Serializers,ImmutableISetSerializer<T>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\RepeatedSerializer.Immutable.cs,Write,The method has 6 parameters. Parameters: state' fieldNumber' category' wireType' values' serializer
Long Parameter List,ProtoBuf.Serializers,ImmutableStackSerializer<T>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\RepeatedSerializer.Immutable.cs,Write,The method has 6 parameters. Parameters: state' fieldNumber' category' wireType' values' serializer
Long Parameter List,ProtoBuf.Serializers,ImmutableIStackSerializer<T>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\RepeatedSerializer.Immutable.cs,Write,The method has 6 parameters. Parameters: state' fieldNumber' category' wireType' values' serializer
Long Parameter List,ProtoBuf.Serializers,ImmutableQueueSerializer<T>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\RepeatedSerializer.Immutable.cs,Write,The method has 6 parameters. Parameters: state' fieldNumber' category' wireType' values' serializer
Long Parameter List,ProtoBuf.Serializers,ImmutableIQueueSerializer<T>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\RepeatedSerializer.Immutable.cs,Write,The method has 6 parameters. Parameters: state' fieldNumber' category' wireType' values' serializer
Long Identifier,ProtoBuf,ProtoContractAttribute,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoContractAttribute.cs,,The length of the parameter OPTIONS_InferTagFromNameHasValue is 32.
Long Statement,ProtoBuf,BclHelpers,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\BclHelpers.cs,WriteTimeSpanImpl,The length of the statement  "                    state.WriteMessage<ScaledTicks>(SerializerFeatures.OptionSkipRecursionCheck' scaled' SerializerCache<PrimaryTypeProvider>.InstanceField); " is 137.
Long Statement,ProtoBuf,BclHelpers,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\BclHelpers.cs,ReadTimeSpan,The length of the statement  "                    var scaled = state.ReadMessage<ScaledTicks>(default' default' serializer: SerializerCache<PrimaryTypeProvider>.InstanceField); " is 126.
Long Statement,ProtoBuf,BclHelpers,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\BclHelpers.cs,ReadDateTime,The length of the statement  "                    var scaled = state.ReadMessage<ScaledTicks>(default' default' serializer: SerializerCache<PrimaryTypeProvider>.InstanceField); " is 126.
Long Statement,ProtoBuf,ExtensibleUtil,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ExtensibleUtil.cs,GetExtendedValues,The length of the statement  "                    while (model.TryDeserializeAuxiliaryType(ref state' format' tag' type' ref value' true' true' false' false' null) && value != null) " is 131.
Long Statement,ProtoBuf,ExtensibleUtil,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ExtensibleUtil.cs,AppendExtendValue,The length of the statement  "            if (extn == null) ThrowHelper.ThrowInvalidOperationException("No extension object available; appended data would be lost.");" is 124.
Long Statement,ProtoBuf,Helpers,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Helpers.cs,GetInstanceFieldsAndProperties,The length of the statement  "            BindingFlags flags = publicOnly ? BindingFlags.Public | BindingFlags.Instance : BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic; " is 149.
Long Statement,ProtoBuf,MeasureState,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\MeasureState.cs,SerializeCore,The length of the statement  "                if (actual != Length) ThrowHelper.ThrowInvalidOperationException($"Invalid length; expected {Length}' actual: {actual}"); " is 121.
Long Statement,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,ReadLongLengthPrefix,The length of the statement  "                                ThrowHelper.ThrowInvalidOperationException($"Unexpected wire-type: {(WireType)(val & 7)}' expected {WireType.String})"); " is 120.
Long Statement,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,Merge,The length of the statement  "            if (model == null) ThrowHelper.ThrowInvalidOperationException("Types cannot be merged unless a type-model has been specified"); " is 127.
Long Statement,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,AppendBytesImpl,The length of the statement  "                            ThrowHelper.ThrowInvalidOperationException($"The memory converter ({converter.GetType().NormalizeName()}) got the lengths wrong for the updated value; expected {oldLength + len}' got {converter.GetLength(value)}"); " is 214.
Long Statement,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,AppendBytesImpl,The length of the statement  "                            ThrowHelper.ThrowInvalidOperationException($"The memory converter ({converter.GetType().NormalizeName()}) got the lengths wrong for the returned chunk; expected {len}' got {newChunk.Length}"); " is 192.
Long Statement,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ReadTypedObject,The length of the statement  "                if (type != null && model.TryDeserializeAuxiliaryType(ref this' DataFormat.Default' TypeModel.ListItemTag' type' ref value' true' false' true' false' null)) " is 156.
Long Statement,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ThrowWireTypeException,The length of the statement  "                var message = _reader == null ? "(no reader)" : $"Invalid wire-type ({_reader.WireType}); this usually means you have over-written a file without truncating or setting the length; see https://stackoverflow.com/q/2152978/23354"; " is 227.
Long Statement,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ThrowEnumException,The length of the statement  "                throw AddErrorData(new ProtoException("No " + desc + " enum is mapped to the wire-value " + value.ToString())' _reader' ref this); " is 130.
Long Statement,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ReadBaseType,The length of the statement  "                return (T)(serializer ?? TypeModel.GetSubTypeSerializer<TBaseType>(_reader._model)).ReadSubType(ref this' SubTypeState<TBaseType>.Create<T>(_reader' value)); " is 157.
Long Statement,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,WriteFieldHeader,The length of the statement  "                    ThrowHelper.ThrowInvalidOperationException($"Cannot write a {wireType}/{fieldNumber} header until the {writer.WireType}/{writer.fieldNumber} data has been written; writer: {writer}"); " is 183.
Long Statement,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,WriteFieldHeader,The length of the statement  "                        ThrowHelper.ThrowInvalidOperationException("Field mismatch during packed encoding; expected " + writer.packedFieldNumber.ToString() + " but received " + fieldNumber.ToString()); " is 177.
Long Statement,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,WriteObject,The length of the statement  "                if (!DynamicStub.TrySerializeAny(TypeModel.ListItemTag' SerializerFeatures.CategoryMessageWrappedAtRoot' type' Model' ref this' value)) " is 135.
Long Statement,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ThrowInvalidSerializationOperation,The length of the statement  "                ThrowHelper.ThrowProtoException($"Invalid serialization operation with wire-type {WireType} at position {GetPosition()}' depth {Depth}"); " is 137.
Long Statement,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ClearPackedField,The length of the statement  "                    ThrowHelper.ThrowInvalidOperationException("Field mismatch during packed encoding; expected " + writer.packedFieldNumber.ToString() + " but received " + fieldNumber.ToString()); " is 177.
Long Statement,ProtoBuf,ProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.BufferWriter.cs,PreSubItem,The length of the statement  "            if (packedFieldNumber != 0) ThrowHelper.ThrowInvalidOperationException("Cannot begin a sub-item while performing packed encoding"); " is 131.
Long Statement,ProtoBuf,ProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.BufferWriter.cs,CheckRecursionStackAndPush,The length of the statement  "                        ThrowHelper.ThrowProtoException($"Possible recursion detected (offset: {(recursionStack.Count - hitLevel)} level(s)): {instance}"); " is 131.
Long Statement,ProtoBuf,ProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.BufferWriter.cs,Cleanup,The length of the statement  "                ThrowHelper.ThrowInvalidOperationException("Writer was diposed without being flushed; data may be lost - you should ensure that Flush (or Abandon) is called");" is 159.
Long Statement,ProtoBuf,ProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.BufferWriter.cs,CheckClear,The length of the statement  "            if (depth != 0 || !TryFlush(ref state)) ThrowHelper.ThrowInvalidOperationException($"The writer is in an incomplete state (depth: {depth}' type: {GetType().Name}' field: {fieldNumber}' wire-type: {WireType}' position: {state.GetPosition()})");" is 243.
Long Statement,ProtoBuf,BufferWriterProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.BufferWriter.cs,DefaultState,The length of the statement  "                ThrowHelper.ThrowInvalidOperationException("You must retain and pass the state from ProtoWriter.CreateForBufferWriter"); " is 120.
Long Statement,ProtoBuf,BufferWriterProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.BufferWriter.cs,WriteWithLengthPrefix,The length of the statement  "                        ThrowHelper.ThrowInvalidOperationException($"Length mismatch; calculated '{calculatedLength}'' actual '{actualLength}'"); " is 121.
Long Statement,ProtoBuf,BufferWriterProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.BufferWriter.cs,WriteWithLengthPrefix,The length of the statement  "                    ThrowHelper.ThrowInvalidOperationException($"Length mismatch; calculated '{calculatedLength}'' actual '{actualLength}'"); " is 121.
Long Statement,ProtoBuf,NullProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Null.cs,CheckOversized,The length of the statement  "                if (max >= 0 & actual > max) ThrowHelper.ThrowProtoException($"Length {actual} exceeds constrained size of {max} bytes"); " is 121.
Long Statement,ProtoBuf,SerializationContext,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\SerializationContext.cs,ThrowIfFrozen,The length of the statement  "{ if (frozen) ThrowHelper.ThrowInvalidOperationException("The serialization-context cannot be changed once it is in use"); }" is 124.
Long Statement,ProtoBuf.Internal,ConcreteStub<T>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\DynamicStub.cs,TrySerializeAny,The length of the statement  "                    if (fieldNumber != TypeModel.ListItemTag) ThrowHelper.ThrowInvalidOperationException($"Special root-like wrapping is limited to field {TypeModel.ListItemTag}"); " is 160.
Long Statement,ProtoBuf.Internal,ConcreteStub<T>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\DynamicStub.cs,CheckAnyAuxFlow,The length of the statement  "                if ((features & TypeModel.FromAux) != 0 && serializer.Features.GetCategory() == SerializerFeatures.CategoryMessageWrappedAtRoot) " is 128.
Long Statement,ProtoBuf.Internal,ConcreteStub<T>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\DynamicStub.cs,CheckAnyAuxFlow,The length of the statement  "                    ThrowHelper.ThrowNotImplementedException($"Tell Marc: ambiguous category in an any/aux flow for {typeof(T).NormalizeName()}"); " is 126.
Long Statement,ProtoBuf.Internal,PrimaryTypeProvider,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\PrimaryTypeProvider.Decimal.cs,VerifyDecimalLayout,The length of the statement  "                // test against example taken from https://docs.microsoft.com/en-us/dotnet/api/system.decimal.getbits?view=netframework-4.8 " is 123.
Long Statement,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,TrySerializeAuxiliaryType,The length of the statement  "                    ThrowHelper.ThrowProtoException(ex.Message + $"; scope: {scope}' features: {features}; type: {type.NormalizeName()}"' ex); " is 122.
Long Statement,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,DeserializeWithLengthPrefix,The length of the statement  "            object result = DeserializeWithLengthPrefix(source' value' type' style' expectedField' resolver' out long bytesRead64' out bool _' null);" is 137.
Long Statement,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,DeserializeWithLengthPrefix,The length of the statement  "                ThrowHelper.ThrowInvalidOperationException("A type must be provided unless base-128 prefixing is being used in combination with a resolver");" is 141.
Long Statement,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,DeserializeWithLengthPrefix,The length of the statement  "                    if (!(TryDeserializeAuxiliaryType(ref state' DataFormat.Default' TypeModel.ListItemTag' type' ref value' true' false' true' false' null) || len == 0)) " is 150.
Long Statement,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,DeserializeRootAny,The length of the statement  "                TryDeserializeAuxiliaryType(ref state' DataFormat.Default' TypeModel.ListItemTag' type' ref value' true' false' autoCreate' false' null); " is 137.
Long Statement,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,TryDeserializeList,The length of the statement  "            var arraySurrogate = list == null ? (IList)Activator.CreateInstance(typeof(List<>).MakeGenericType(itemType)' nonPublic: true) : null; " is 134.
Long Statement,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,TryDeserializeList,The length of the statement  "            while (TryDeserializeAuxiliaryType(ref state' format' tag' itemType' ref nextItem' true' true' true' true' value ?? listType)) " is 126.
Long Statement,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,CreateListInstance,The length of the statement  "#pragma warning disable IDE0059 // unnecessary assignment; I can reason better with it here' in case we need to add more scenarios" is 130.
Long Statement,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,NoSerializer,The length of the statement  "            ThrowHelper.ThrowInvalidOperationException($"No serializer for type {typeof(T).NormalizeName()} is available for model {model?.ToString() ?? "(none)"}{suffix}"); " is 161.
Long Statement,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,NoSubTypeSerializer,The length of the statement  "            ThrowHelper.ThrowInvalidOperationException($"No sub-type serializer for type {typeof(T).NormalizeName()} is available for model {model?.ToString() ?? "(none)"}"); " is 162.
Long Statement,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,DeepCloneFallback,The length of the statement  "                TryDeserializeAuxiliaryType(ref readState' DataFormat.Default' TypeModel.ListItemTag' type' ref value' true' false' true' false' null); " is 135.
Long Statement,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,ThrowUnexpectedType,The length of the statement  "                        "Are you mixing protobuf-net and protobuf-csharp-port? See https://stackoverflow.com/q/11564914/23354; type: " + fullName);" is 123.
Long Statement,ProtoBuf.Meta,DeserializeItemsIterator,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,MoveNext,The length of the statement  "                    current = model.DeserializeWithLengthPrefix(source' null' type' style' expectedField' resolver' out long _' out haveObject' context);" is 133.
Long Statement,ProtoBuf.Serializers,DefaultMemoryConverter<T>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\IMemoryConverter.cs,NotSupported,The length of the statement  "                $"No memory-converter is available for storage {typeof(TStorage).NormalizeName()} with element-type {typeof(T).NormalizeName()}."); " is 131.
Long Statement,ProtoBuf.Serializers,SubTypeState,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\IProtoSerializerT.cs,OnBeforeDeserialize,The length of the statement  "                else if (_onBeforeDeserialize is object) ThrowHelper.ThrowInvalidOperationException("Only one pending " + nameof(OnBeforeDeserialize) + " callback is supported"); " is 162.
Long Statement,ProtoBuf.Serializers,MapSerializer<TCollection;TKey;TValue>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\MapSerializer.cs,Read,The length of the statement  "            ThrowHelper.ThrowInvalidOperationException("Should have used " + nameof(IRepeatedSerializer<TCollection>.ReadRepeated)); " is 120.
Long Statement,ProtoBuf.Serializers,ProducerConsumerSerializer<TCollection;T>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\RepeatedSerializer.Concurrent.cs,AddRange,The length of the statement  "                if (!values.TryAdd(item)) ThrowHelper.ThrowInvalidOperationException("Unable to add to the collection: " + values.GetType().NormalizeName()); " is 141.
Long Statement,ProtoBuf.Serializers,RepeatedSerializer<TCollection;TItem>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\RepeatedSerializer.cs,Read,The length of the statement  "            ThrowHelper.ThrowInvalidOperationException("Should have used " + nameof(IRepeatedSerializer<TCollection>.ReadRepeated)); " is 120.
Long Statement,ProtoBuf.Serializers,RepeatedSerializer<TCollection;TItem>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\RepeatedSerializer.cs,WriteRepeated,The length of the statement  "            if (TypeHelper<TItem>.CanBePacked && !features.IsPackedDisabled() && (count == 0 || count > 1) && serializer is IMeasuringSerializer<TItem> measurer) " is 149.
Long Statement,ProtoBuf.Serializers,RepeatedSerializer<TCollection;TItem>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\RepeatedSerializer.cs,WritePacked,The length of the statement  "                $"packed encoding length miscalculation for {typeof(TItem).NormalizeName()}' {wireType}; expected {expectedLength}' got {actualLength}"); " is 137.
Long Statement,ProtoBuf.Serializers,SerializerCache,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\SerializerCache.cs,Verify,The length of the statement  "                    if ((features & ~PermittedRepeatedFeatures) != 0) ThrowInvalidSerializer(serializer' $"repeated serializers may only specify {PermittedRepeatedFeatures}"); " is 155.
Long Statement,ProtoBuf.Serializers,SerializerCache,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\SerializerCache.cs,Verify,The length of the statement  "                        if (TypeHelper<T>.CanBePacked) ThrowInvalidSerializer(serializer' "message serializer specified for a type that can be 'packed'"); " is 130.
Long Statement,ProtoBuf.Serializers,SerializerCache,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\SerializerCache.cs,Verify,The length of the statement  "                const SerializerFeatures InvalidFeatures = SerializerFeatures.OptionClearCollection | SerializerFeatures.OptionPackedDisabled; " is 126.
Long Statement,ProtoBuf.Serializers,SerializerCache,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\SerializerCache.cs,Verify,The length of the statement  "                if ((features & InvalidFeatures) != 0) ThrowInvalidSerializer(serializer' $"serializers should not specify {InvalidFeatures}"); " is 127.
Complex Conditional,ProtoBuf,BufferExtension,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\BufferExtension.cs,EndAppend,The conditional expression  "commit && stream is MemoryStream ms && ms.TryGetBuffer(out var segment) && segment.Count != 0"  is complex.
Complex Conditional,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,TryConsumeSegmentRespectingPosition,The conditional expression  "source is MemoryStream ms && ms.CanSeek                  && (ms.TryGetBuffer(out var segment) || ReflectionTryGetBuffer(ms' out segment))"  is complex.
Complex Conditional,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt32Varint,The conditional expression  "trimNegative // allow for -ve values                      && (chunk & 0xF0) == 0xF0                      && offset + 4 < (uint)span.Length                          && span[offset] == 0xFF                          && span[offset + 1] == 0xFF                          && span[offset + 2] == 0xFF                          && span[offset + 3] == 0xFF                          && span[offset + 4] == 0x01"  is complex.
Complex Conditional,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt32VarintWithoutMoving,The conditional expression  "mode == Read32VarintMode.Signed // allow for -ve values                      && (chunk & 0xF0) == 0xF0                      && _available >= 10                          && _ioBuffer[++readPos] == 0xFF                          && _ioBuffer[++readPos] == 0xFF                          && _ioBuffer[++readPos] == 0xFF                          && _ioBuffer[++readPos] == 0xFF                          && _ioBuffer[++readPos] == 0x01"  is complex.
Complex Conditional,ProtoBuf.Internal,TypeHelper,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\TypeHelperT.cs,ResolveUniqueEnumerableT,The conditional expression  "type == null                  || type == typeof(string) || type == typeof(byte[]) || type == typeof(object)"  is complex.
Complex Conditional,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,DeserializeWithLengthPrefix,The conditional expression  "expectPrefix && expectedField == 0 && type == null && resolver != null"  is complex.
Complex Conditional,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,TryDeserializeAuxiliaryType,The conditional expression  "itemType == null && type.IsArray && type.GetArrayRank() == 1 && type != typeof(byte[])"  is complex.
Complex Conditional,ProtoBuf.Serializers,RepeatedSerializer<TCollection;TItem>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\RepeatedSerializer.cs,WriteRepeated,The conditional expression  "TypeHelper<TItem>.CanBePacked && !features.IsPackedDisabled() && (count == 0 || count > 1) && serializer is IMeasuringSerializer<TItem> measurer"  is complex.
Empty Catch Block,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,ReflectionTryGetBuffer,The method has an empty catch block.
Empty Catch Block,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,FillBuffer,The method has an empty catch block.
Empty Catch Block,ProtoBuf.Internal,PrimaryTypeProvider,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\PrimaryTypeProvider.Decimal.cs,VerifyDecimalLayout,The method has an empty catch block.
Empty Catch Block,ProtoBuf.Internal,PrimaryTypeProvider,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\PrimaryTypeProvider.Decimal.cs,VerifyGuidLayout,The method has an empty catch block.
Empty Catch Block,ProtoBuf.Internal,TypeHelper,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\TypeHelperT.cs,ResolveUniqueEnumerableT,The method has an empty catch block.
Empty Catch Block,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,ResolveKnownType,The method has an empty catch block.
Empty Catch Block,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,ResolveKnownType,The method has an empty catch block.
Magic Number,ProtoBuf,BufferPool,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\BufferPool.cs,ResizeAndFlushLeft,The following statement contains a magic number: int newLength = buffer.Length * 2;
Magic Number,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,SetTag,The following statement contains a magic number: (_fieldNumber = (int)(tag >> 3)) < 1
Magic Number,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,SetTag,The following statement contains a magic number: (WireType = (WireType)(tag & 7)) == WireType.EndGroup
Magic Number,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,DirectReadLittleEndianInt32,The following statement contains a magic number: return ReadByteOrThrow(source)                  | (ReadByteOrThrow(source) << 8)                  | (ReadByteOrThrow(source) << 16)                  | (ReadByteOrThrow(source) << 24);
Magic Number,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,DirectReadLittleEndianInt32,The following statement contains a magic number: return ReadByteOrThrow(source)                  | (ReadByteOrThrow(source) << 8)                  | (ReadByteOrThrow(source) << 16)                  | (ReadByteOrThrow(source) << 24);
Magic Number,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,DirectReadLittleEndianInt32,The following statement contains a magic number: return ReadByteOrThrow(source)                  | (ReadByteOrThrow(source) << 8)                  | (ReadByteOrThrow(source) << 16)                  | (ReadByteOrThrow(source) << 24);
Magic Number,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,DirectReadBigEndianInt32,The following statement contains a magic number: return (ReadByteOrThrow(source) << 24)                   | (ReadByteOrThrow(source) << 16)                   | (ReadByteOrThrow(source) << 8)                   | ReadByteOrThrow(source);
Magic Number,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,DirectReadBigEndianInt32,The following statement contains a magic number: return (ReadByteOrThrow(source) << 24)                   | (ReadByteOrThrow(source) << 16)                   | (ReadByteOrThrow(source) << 8)                   | ReadByteOrThrow(source);
Magic Number,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,DirectReadBigEndianInt32,The following statement contains a magic number: return (ReadByteOrThrow(source) << 24)                   | (ReadByteOrThrow(source) << 16)                   | (ReadByteOrThrow(source) << 8)                   | ReadByteOrThrow(source);
Magic Number,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,ReadLongLengthPrefix,The following statement contains a magic number: switch (style)              {                  case PrefixStyle.None:                      bytesRead = 0;                      return long.MaxValue;                  case PrefixStyle.Base128:                      ulong val;                      int tmpBytesRead;                      bytesRead = 0;                      if (expectHeader)                      {                          tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                          bytesRead += tmpBytesRead;                          if (tmpBytesRead > 0)                          {                              if ((val & 7) != (uint)WireType.String)                              { // got a header' but it isn't a string                                  ThrowHelper.ThrowInvalidOperationException($"Unexpected wire-type: {(WireType)(val & 7)}' expected {WireType.String})");                              }                              fieldNumber = (int)(val >> 3);                              tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                              bytesRead += tmpBytesRead;                              if (bytesRead == 0) ThrowEoF(); // got a header' but no length                              return (long)val;                          }                          else                          { // no header                              bytesRead = 0;                              return -1;                          }                      }                      // check for a length                      tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                      bytesRead += tmpBytesRead;                      return bytesRead < 0 ? -1 : (long)val;                    case PrefixStyle.Fixed32:                      {                          int b = source.ReadByte();                          if (b < 0)                          {                              bytesRead = 0;                              return -1;                          }                          bytesRead = 4;                          return b                               | (ReadByteOrThrow(source) << 8)                               | (ReadByteOrThrow(source) << 16)                               | (ReadByteOrThrow(source) << 24);                      }                  case PrefixStyle.Fixed32BigEndian:                      {                          int b = source.ReadByte();                          if (b < 0)                          {                              bytesRead = 0;                              return -1;                          }                          bytesRead = 4;                          return (b << 24)                              | (ReadByteOrThrow(source) << 16)                              | (ReadByteOrThrow(source) << 8)                              | ReadByteOrThrow(source);                      }                  default:                      ThrowHelper.ThrowArgumentOutOfRangeException(nameof(style));                      bytesRead = default;                      return default;              }
Magic Number,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,ReadLongLengthPrefix,The following statement contains a magic number: switch (style)              {                  case PrefixStyle.None:                      bytesRead = 0;                      return long.MaxValue;                  case PrefixStyle.Base128:                      ulong val;                      int tmpBytesRead;                      bytesRead = 0;                      if (expectHeader)                      {                          tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                          bytesRead += tmpBytesRead;                          if (tmpBytesRead > 0)                          {                              if ((val & 7) != (uint)WireType.String)                              { // got a header' but it isn't a string                                  ThrowHelper.ThrowInvalidOperationException($"Unexpected wire-type: {(WireType)(val & 7)}' expected {WireType.String})");                              }                              fieldNumber = (int)(val >> 3);                              tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                              bytesRead += tmpBytesRead;                              if (bytesRead == 0) ThrowEoF(); // got a header' but no length                              return (long)val;                          }                          else                          { // no header                              bytesRead = 0;                              return -1;                          }                      }                      // check for a length                      tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                      bytesRead += tmpBytesRead;                      return bytesRead < 0 ? -1 : (long)val;                    case PrefixStyle.Fixed32:                      {                          int b = source.ReadByte();                          if (b < 0)                          {                              bytesRead = 0;                              return -1;                          }                          bytesRead = 4;                          return b                               | (ReadByteOrThrow(source) << 8)                               | (ReadByteOrThrow(source) << 16)                               | (ReadByteOrThrow(source) << 24);                      }                  case PrefixStyle.Fixed32BigEndian:                      {                          int b = source.ReadByte();                          if (b < 0)                          {                              bytesRead = 0;                              return -1;                          }                          bytesRead = 4;                          return (b << 24)                              | (ReadByteOrThrow(source) << 16)                              | (ReadByteOrThrow(source) << 8)                              | ReadByteOrThrow(source);                      }                  default:                      ThrowHelper.ThrowArgumentOutOfRangeException(nameof(style));                      bytesRead = default;                      return default;              }
Magic Number,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,ReadLongLengthPrefix,The following statement contains a magic number: switch (style)              {                  case PrefixStyle.None:                      bytesRead = 0;                      return long.MaxValue;                  case PrefixStyle.Base128:                      ulong val;                      int tmpBytesRead;                      bytesRead = 0;                      if (expectHeader)                      {                          tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                          bytesRead += tmpBytesRead;                          if (tmpBytesRead > 0)                          {                              if ((val & 7) != (uint)WireType.String)                              { // got a header' but it isn't a string                                  ThrowHelper.ThrowInvalidOperationException($"Unexpected wire-type: {(WireType)(val & 7)}' expected {WireType.String})");                              }                              fieldNumber = (int)(val >> 3);                              tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                              bytesRead += tmpBytesRead;                              if (bytesRead == 0) ThrowEoF(); // got a header' but no length                              return (long)val;                          }                          else                          { // no header                              bytesRead = 0;                              return -1;                          }                      }                      // check for a length                      tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                      bytesRead += tmpBytesRead;                      return bytesRead < 0 ? -1 : (long)val;                    case PrefixStyle.Fixed32:                      {                          int b = source.ReadByte();                          if (b < 0)                          {                              bytesRead = 0;                              return -1;                          }                          bytesRead = 4;                          return b                               | (ReadByteOrThrow(source) << 8)                               | (ReadByteOrThrow(source) << 16)                               | (ReadByteOrThrow(source) << 24);                      }                  case PrefixStyle.Fixed32BigEndian:                      {                          int b = source.ReadByte();                          if (b < 0)                          {                              bytesRead = 0;                              return -1;                          }                          bytesRead = 4;                          return (b << 24)                              | (ReadByteOrThrow(source) << 16)                              | (ReadByteOrThrow(source) << 8)                              | ReadByteOrThrow(source);                      }                  default:                      ThrowHelper.ThrowArgumentOutOfRangeException(nameof(style));                      bytesRead = default;                      return default;              }
Magic Number,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,ReadLongLengthPrefix,The following statement contains a magic number: switch (style)              {                  case PrefixStyle.None:                      bytesRead = 0;                      return long.MaxValue;                  case PrefixStyle.Base128:                      ulong val;                      int tmpBytesRead;                      bytesRead = 0;                      if (expectHeader)                      {                          tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                          bytesRead += tmpBytesRead;                          if (tmpBytesRead > 0)                          {                              if ((val & 7) != (uint)WireType.String)                              { // got a header' but it isn't a string                                  ThrowHelper.ThrowInvalidOperationException($"Unexpected wire-type: {(WireType)(val & 7)}' expected {WireType.String})");                              }                              fieldNumber = (int)(val >> 3);                              tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                              bytesRead += tmpBytesRead;                              if (bytesRead == 0) ThrowEoF(); // got a header' but no length                              return (long)val;                          }                          else                          { // no header                              bytesRead = 0;                              return -1;                          }                      }                      // check for a length                      tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                      bytesRead += tmpBytesRead;                      return bytesRead < 0 ? -1 : (long)val;                    case PrefixStyle.Fixed32:                      {                          int b = source.ReadByte();                          if (b < 0)                          {                              bytesRead = 0;                              return -1;                          }                          bytesRead = 4;                          return b                               | (ReadByteOrThrow(source) << 8)                               | (ReadByteOrThrow(source) << 16)                               | (ReadByteOrThrow(source) << 24);                      }                  case PrefixStyle.Fixed32BigEndian:                      {                          int b = source.ReadByte();                          if (b < 0)                          {                              bytesRead = 0;                              return -1;                          }                          bytesRead = 4;                          return (b << 24)                              | (ReadByteOrThrow(source) << 16)                              | (ReadByteOrThrow(source) << 8)                              | ReadByteOrThrow(source);                      }                  default:                      ThrowHelper.ThrowArgumentOutOfRangeException(nameof(style));                      bytesRead = default;                      return default;              }
Magic Number,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,ReadLongLengthPrefix,The following statement contains a magic number: switch (style)              {                  case PrefixStyle.None:                      bytesRead = 0;                      return long.MaxValue;                  case PrefixStyle.Base128:                      ulong val;                      int tmpBytesRead;                      bytesRead = 0;                      if (expectHeader)                      {                          tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                          bytesRead += tmpBytesRead;                          if (tmpBytesRead > 0)                          {                              if ((val & 7) != (uint)WireType.String)                              { // got a header' but it isn't a string                                  ThrowHelper.ThrowInvalidOperationException($"Unexpected wire-type: {(WireType)(val & 7)}' expected {WireType.String})");                              }                              fieldNumber = (int)(val >> 3);                              tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                              bytesRead += tmpBytesRead;                              if (bytesRead == 0) ThrowEoF(); // got a header' but no length                              return (long)val;                          }                          else                          { // no header                              bytesRead = 0;                              return -1;                          }                      }                      // check for a length                      tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                      bytesRead += tmpBytesRead;                      return bytesRead < 0 ? -1 : (long)val;                    case PrefixStyle.Fixed32:                      {                          int b = source.ReadByte();                          if (b < 0)                          {                              bytesRead = 0;                              return -1;                          }                          bytesRead = 4;                          return b                               | (ReadByteOrThrow(source) << 8)                               | (ReadByteOrThrow(source) << 16)                               | (ReadByteOrThrow(source) << 24);                      }                  case PrefixStyle.Fixed32BigEndian:                      {                          int b = source.ReadByte();                          if (b < 0)                          {                              bytesRead = 0;                              return -1;                          }                          bytesRead = 4;                          return (b << 24)                              | (ReadByteOrThrow(source) << 16)                              | (ReadByteOrThrow(source) << 8)                              | ReadByteOrThrow(source);                      }                  default:                      ThrowHelper.ThrowArgumentOutOfRangeException(nameof(style));                      bytesRead = default;                      return default;              }
Magic Number,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,ReadLongLengthPrefix,The following statement contains a magic number: switch (style)              {                  case PrefixStyle.None:                      bytesRead = 0;                      return long.MaxValue;                  case PrefixStyle.Base128:                      ulong val;                      int tmpBytesRead;                      bytesRead = 0;                      if (expectHeader)                      {                          tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                          bytesRead += tmpBytesRead;                          if (tmpBytesRead > 0)                          {                              if ((val & 7) != (uint)WireType.String)                              { // got a header' but it isn't a string                                  ThrowHelper.ThrowInvalidOperationException($"Unexpected wire-type: {(WireType)(val & 7)}' expected {WireType.String})");                              }                              fieldNumber = (int)(val >> 3);                              tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                              bytesRead += tmpBytesRead;                              if (bytesRead == 0) ThrowEoF(); // got a header' but no length                              return (long)val;                          }                          else                          { // no header                              bytesRead = 0;                              return -1;                          }                      }                      // check for a length                      tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                      bytesRead += tmpBytesRead;                      return bytesRead < 0 ? -1 : (long)val;                    case PrefixStyle.Fixed32:                      {                          int b = source.ReadByte();                          if (b < 0)                          {                              bytesRead = 0;                              return -1;                          }                          bytesRead = 4;                          return b                               | (ReadByteOrThrow(source) << 8)                               | (ReadByteOrThrow(source) << 16)                               | (ReadByteOrThrow(source) << 24);                      }                  case PrefixStyle.Fixed32BigEndian:                      {                          int b = source.ReadByte();                          if (b < 0)                          {                              bytesRead = 0;                              return -1;                          }                          bytesRead = 4;                          return (b << 24)                              | (ReadByteOrThrow(source) << 16)                              | (ReadByteOrThrow(source) << 8)                              | ReadByteOrThrow(source);                      }                  default:                      ThrowHelper.ThrowArgumentOutOfRangeException(nameof(style));                      bytesRead = default;                      return default;              }
Magic Number,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,ReadLongLengthPrefix,The following statement contains a magic number: switch (style)              {                  case PrefixStyle.None:                      bytesRead = 0;                      return long.MaxValue;                  case PrefixStyle.Base128:                      ulong val;                      int tmpBytesRead;                      bytesRead = 0;                      if (expectHeader)                      {                          tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                          bytesRead += tmpBytesRead;                          if (tmpBytesRead > 0)                          {                              if ((val & 7) != (uint)WireType.String)                              { // got a header' but it isn't a string                                  ThrowHelper.ThrowInvalidOperationException($"Unexpected wire-type: {(WireType)(val & 7)}' expected {WireType.String})");                              }                              fieldNumber = (int)(val >> 3);                              tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                              bytesRead += tmpBytesRead;                              if (bytesRead == 0) ThrowEoF(); // got a header' but no length                              return (long)val;                          }                          else                          { // no header                              bytesRead = 0;                              return -1;                          }                      }                      // check for a length                      tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                      bytesRead += tmpBytesRead;                      return bytesRead < 0 ? -1 : (long)val;                    case PrefixStyle.Fixed32:                      {                          int b = source.ReadByte();                          if (b < 0)                          {                              bytesRead = 0;                              return -1;                          }                          bytesRead = 4;                          return b                               | (ReadByteOrThrow(source) << 8)                               | (ReadByteOrThrow(source) << 16)                               | (ReadByteOrThrow(source) << 24);                      }                  case PrefixStyle.Fixed32BigEndian:                      {                          int b = source.ReadByte();                          if (b < 0)                          {                              bytesRead = 0;                              return -1;                          }                          bytesRead = 4;                          return (b << 24)                              | (ReadByteOrThrow(source) << 16)                              | (ReadByteOrThrow(source) << 8)                              | ReadByteOrThrow(source);                      }                  default:                      ThrowHelper.ThrowArgumentOutOfRangeException(nameof(style));                      bytesRead = default;                      return default;              }
Magic Number,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,ReadLongLengthPrefix,The following statement contains a magic number: switch (style)              {                  case PrefixStyle.None:                      bytesRead = 0;                      return long.MaxValue;                  case PrefixStyle.Base128:                      ulong val;                      int tmpBytesRead;                      bytesRead = 0;                      if (expectHeader)                      {                          tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                          bytesRead += tmpBytesRead;                          if (tmpBytesRead > 0)                          {                              if ((val & 7) != (uint)WireType.String)                              { // got a header' but it isn't a string                                  ThrowHelper.ThrowInvalidOperationException($"Unexpected wire-type: {(WireType)(val & 7)}' expected {WireType.String})");                              }                              fieldNumber = (int)(val >> 3);                              tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                              bytesRead += tmpBytesRead;                              if (bytesRead == 0) ThrowEoF(); // got a header' but no length                              return (long)val;                          }                          else                          { // no header                              bytesRead = 0;                              return -1;                          }                      }                      // check for a length                      tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                      bytesRead += tmpBytesRead;                      return bytesRead < 0 ? -1 : (long)val;                    case PrefixStyle.Fixed32:                      {                          int b = source.ReadByte();                          if (b < 0)                          {                              bytesRead = 0;                              return -1;                          }                          bytesRead = 4;                          return b                               | (ReadByteOrThrow(source) << 8)                               | (ReadByteOrThrow(source) << 16)                               | (ReadByteOrThrow(source) << 24);                      }                  case PrefixStyle.Fixed32BigEndian:                      {                          int b = source.ReadByte();                          if (b < 0)                          {                              bytesRead = 0;                              return -1;                          }                          bytesRead = 4;                          return (b << 24)                              | (ReadByteOrThrow(source) << 16)                              | (ReadByteOrThrow(source) << 8)                              | ReadByteOrThrow(source);                      }                  default:                      ThrowHelper.ThrowArgumentOutOfRangeException(nameof(style));                      bytesRead = default;                      return default;              }
Magic Number,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,ReadLongLengthPrefix,The following statement contains a magic number: switch (style)              {                  case PrefixStyle.None:                      bytesRead = 0;                      return long.MaxValue;                  case PrefixStyle.Base128:                      ulong val;                      int tmpBytesRead;                      bytesRead = 0;                      if (expectHeader)                      {                          tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                          bytesRead += tmpBytesRead;                          if (tmpBytesRead > 0)                          {                              if ((val & 7) != (uint)WireType.String)                              { // got a header' but it isn't a string                                  ThrowHelper.ThrowInvalidOperationException($"Unexpected wire-type: {(WireType)(val & 7)}' expected {WireType.String})");                              }                              fieldNumber = (int)(val >> 3);                              tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                              bytesRead += tmpBytesRead;                              if (bytesRead == 0) ThrowEoF(); // got a header' but no length                              return (long)val;                          }                          else                          { // no header                              bytesRead = 0;                              return -1;                          }                      }                      // check for a length                      tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                      bytesRead += tmpBytesRead;                      return bytesRead < 0 ? -1 : (long)val;                    case PrefixStyle.Fixed32:                      {                          int b = source.ReadByte();                          if (b < 0)                          {                              bytesRead = 0;                              return -1;                          }                          bytesRead = 4;                          return b                               | (ReadByteOrThrow(source) << 8)                               | (ReadByteOrThrow(source) << 16)                               | (ReadByteOrThrow(source) << 24);                      }                  case PrefixStyle.Fixed32BigEndian:                      {                          int b = source.ReadByte();                          if (b < 0)                          {                              bytesRead = 0;                              return -1;                          }                          bytesRead = 4;                          return (b << 24)                              | (ReadByteOrThrow(source) << 16)                              | (ReadByteOrThrow(source) << 8)                              | ReadByteOrThrow(source);                      }                  default:                      ThrowHelper.ThrowArgumentOutOfRangeException(nameof(style));                      bytesRead = default;                      return default;              }
Magic Number,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,ReadLongLengthPrefix,The following statement contains a magic number: switch (style)              {                  case PrefixStyle.None:                      bytesRead = 0;                      return long.MaxValue;                  case PrefixStyle.Base128:                      ulong val;                      int tmpBytesRead;                      bytesRead = 0;                      if (expectHeader)                      {                          tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                          bytesRead += tmpBytesRead;                          if (tmpBytesRead > 0)                          {                              if ((val & 7) != (uint)WireType.String)                              { // got a header' but it isn't a string                                  ThrowHelper.ThrowInvalidOperationException($"Unexpected wire-type: {(WireType)(val & 7)}' expected {WireType.String})");                              }                              fieldNumber = (int)(val >> 3);                              tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                              bytesRead += tmpBytesRead;                              if (bytesRead == 0) ThrowEoF(); // got a header' but no length                              return (long)val;                          }                          else                          { // no header                              bytesRead = 0;                              return -1;                          }                      }                      // check for a length                      tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                      bytesRead += tmpBytesRead;                      return bytesRead < 0 ? -1 : (long)val;                    case PrefixStyle.Fixed32:                      {                          int b = source.ReadByte();                          if (b < 0)                          {                              bytesRead = 0;                              return -1;                          }                          bytesRead = 4;                          return b                               | (ReadByteOrThrow(source) << 8)                               | (ReadByteOrThrow(source) << 16)                               | (ReadByteOrThrow(source) << 24);                      }                  case PrefixStyle.Fixed32BigEndian:                      {                          int b = source.ReadByte();                          if (b < 0)                          {                              bytesRead = 0;                              return -1;                          }                          bytesRead = 4;                          return (b << 24)                              | (ReadByteOrThrow(source) << 16)                              | (ReadByteOrThrow(source) << 8)                              | ReadByteOrThrow(source);                      }                  default:                      ThrowHelper.ThrowArgumentOutOfRangeException(nameof(style));                      bytesRead = default;                      return default;              }
Magic Number,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,ReadLongLengthPrefix,The following statement contains a magic number: switch (style)              {                  case PrefixStyle.None:                      bytesRead = 0;                      return long.MaxValue;                  case PrefixStyle.Base128:                      ulong val;                      int tmpBytesRead;                      bytesRead = 0;                      if (expectHeader)                      {                          tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                          bytesRead += tmpBytesRead;                          if (tmpBytesRead > 0)                          {                              if ((val & 7) != (uint)WireType.String)                              { // got a header' but it isn't a string                                  ThrowHelper.ThrowInvalidOperationException($"Unexpected wire-type: {(WireType)(val & 7)}' expected {WireType.String})");                              }                              fieldNumber = (int)(val >> 3);                              tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                              bytesRead += tmpBytesRead;                              if (bytesRead == 0) ThrowEoF(); // got a header' but no length                              return (long)val;                          }                          else                          { // no header                              bytesRead = 0;                              return -1;                          }                      }                      // check for a length                      tmpBytesRead = ProtoReader.TryReadUInt64Varint(source' out val);                      bytesRead += tmpBytesRead;                      return bytesRead < 0 ? -1 : (long)val;                    case PrefixStyle.Fixed32:                      {                          int b = source.ReadByte();                          if (b < 0)                          {                              bytesRead = 0;                              return -1;                          }                          bytesRead = 4;                          return b                               | (ReadByteOrThrow(source) << 8)                               | (ReadByteOrThrow(source) << 16)                               | (ReadByteOrThrow(source) << 24);                      }                  case PrefixStyle.Fixed32BigEndian:                      {                          int b = source.ReadByte();                          if (b < 0)                          {                              bytesRead = 0;                              return -1;                          }                          bytesRead = 4;                          return (b << 24)                              | (ReadByteOrThrow(source) << 16)                              | (ReadByteOrThrow(source) << 8)                              | ReadByteOrThrow(source);                      }                  default:                      ThrowHelper.ThrowArgumentOutOfRangeException(nameof(style));                      bytesRead = default;                      return default;              }
Magic Number,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,TryReadUInt64Varint,The following statement contains a magic number: int bytesRead = 1' shift = 7;
Magic Number,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,TryReadUInt64Varint,The following statement contains a magic number: shift += 7;
Magic Number,ProtoBuf,ProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.cs,TryReadUInt64Varint,The following statement contains a magic number: bytesRead < 9
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ReadVarintUInt32,The following statement contains a magic number: Debug.Assert(RemainingInCurrent >= 5);
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ParseVarintUInt32Tail,The following statement contains a magic number: value = (value & 0x7F) | (chunk & 0x7F) << 7;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ParseVarintUInt32Tail,The following statement contains a magic number: return 2;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ParseVarintUInt32Tail,The following statement contains a magic number: chunk = span[2];
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ParseVarintUInt32Tail,The following statement contains a magic number: value |= (chunk & 0x7F) << 14;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ParseVarintUInt32Tail,The following statement contains a magic number: return 3;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ParseVarintUInt32Tail,The following statement contains a magic number: chunk = span[3];
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ParseVarintUInt32Tail,The following statement contains a magic number: value |= (chunk & 0x7F) << 21;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ParseVarintUInt32Tail,The following statement contains a magic number: return 4;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ParseVarintUInt32Tail,The following statement contains a magic number: chunk = span[4];
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ParseVarintUInt32Tail,The following statement contains a magic number: value |= chunk << 28;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ParseVarintUInt32Tail,The following statement contains a magic number: return 5;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt64Varint,The following statement contains a magic number: value |= (chunk & 0x7F) << 7;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt64Varint,The following statement contains a magic number: return 2;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt64Varint,The following statement contains a magic number: value |= (chunk & 0x7F) << 14;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt64Varint,The following statement contains a magic number: return 3;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt64Varint,The following statement contains a magic number: value |= (chunk & 0x7F) << 21;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt64Varint,The following statement contains a magic number: return 4;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt64Varint,The following statement contains a magic number: value |= (chunk & 0x7F) << 28;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt64Varint,The following statement contains a magic number: return 5;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt64Varint,The following statement contains a magic number: value |= (chunk & 0x7F) << 35;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt64Varint,The following statement contains a magic number: return 6;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt64Varint,The following statement contains a magic number: value |= (chunk & 0x7F) << 42;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt64Varint,The following statement contains a magic number: return 7;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt64Varint,The following statement contains a magic number: value |= (chunk & 0x7F) << 49;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt64Varint,The following statement contains a magic number: return 8;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt64Varint,The following statement contains a magic number: value |= (chunk & 0x7F) << 56;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt64Varint,The following statement contains a magic number: return 9;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt64Varint,The following statement contains a magic number: value |= chunk << 63;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt64Varint,The following statement contains a magic number: return 10;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ReadPackedScalar,The following statement contains a magic number: switch (wireType)                  {                      case WireType.Fixed32:                          if ((bytes % 4) != 0) ThrowHelper.ThrowInvalidOperationException("packed length should be multiple of 4");                          var count = bytes / 4;                          goto ReadFixedQuantity;                      case WireType.Fixed64:                          if ((bytes % 8) != 0) ThrowHelper.ThrowInvalidOperationException("packed length should be multiple of 8");                          count = bytes / 8;                          ReadFixedQuantity:                          // boost the List<T> capacity if we can' as long as it is within reason (i.e. don't let                          // a small message lie and claim to have a huge payload)                            const int MAX_GROW = 8192; // if they are much bigge than this' then the doubling API will help' anyhows                          if (list is List<T> l) l.Capacity = Math.Max(l.Capacity' l.Count + Math.Min(count' MAX_GROW));                            for (int i = 0; i < count; i++)                          {                              _reader.WireType = wireType;                              list.Add(serializer.Read(ref this' default));                          }                          break;                      case WireType.Varint:                      case WireType.SignedVarint:                          long end = GetPosition() + bytes;                          do                          {                              _reader.WireType = wireType;                              list.Add(serializer.Read(ref this' default));                          } while (GetPosition() < end);                          if (GetPosition() != end) ThrowHelper.ThrowInvalidOperationException("over-read packed data");                          break;                      default:                          ThrowHelper.ThrowInvalidPackedOperationException(WireType' typeof(T));                          break;                  }
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ReadPackedScalar,The following statement contains a magic number: switch (wireType)                  {                      case WireType.Fixed32:                          if ((bytes % 4) != 0) ThrowHelper.ThrowInvalidOperationException("packed length should be multiple of 4");                          var count = bytes / 4;                          goto ReadFixedQuantity;                      case WireType.Fixed64:                          if ((bytes % 8) != 0) ThrowHelper.ThrowInvalidOperationException("packed length should be multiple of 8");                          count = bytes / 8;                          ReadFixedQuantity:                          // boost the List<T> capacity if we can' as long as it is within reason (i.e. don't let                          // a small message lie and claim to have a huge payload)                            const int MAX_GROW = 8192; // if they are much bigge than this' then the doubling API will help' anyhows                          if (list is List<T> l) l.Capacity = Math.Max(l.Capacity' l.Count + Math.Min(count' MAX_GROW));                            for (int i = 0; i < count; i++)                          {                              _reader.WireType = wireType;                              list.Add(serializer.Read(ref this' default));                          }                          break;                      case WireType.Varint:                      case WireType.SignedVarint:                          long end = GetPosition() + bytes;                          do                          {                              _reader.WireType = wireType;                              list.Add(serializer.Read(ref this' default));                          } while (GetPosition() < end);                          if (GetPosition() != end) ThrowHelper.ThrowInvalidOperationException("over-read packed data");                          break;                      default:                          ThrowHelper.ThrowInvalidPackedOperationException(WireType' typeof(T));                          break;                  }
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ReadPackedScalar,The following statement contains a magic number: switch (wireType)                  {                      case WireType.Fixed32:                          if ((bytes % 4) != 0) ThrowHelper.ThrowInvalidOperationException("packed length should be multiple of 4");                          var count = bytes / 4;                          goto ReadFixedQuantity;                      case WireType.Fixed64:                          if ((bytes % 8) != 0) ThrowHelper.ThrowInvalidOperationException("packed length should be multiple of 8");                          count = bytes / 8;                          ReadFixedQuantity:                          // boost the List<T> capacity if we can' as long as it is within reason (i.e. don't let                          // a small message lie and claim to have a huge payload)                            const int MAX_GROW = 8192; // if they are much bigge than this' then the doubling API will help' anyhows                          if (list is List<T> l) l.Capacity = Math.Max(l.Capacity' l.Count + Math.Min(count' MAX_GROW));                            for (int i = 0; i < count; i++)                          {                              _reader.WireType = wireType;                              list.Add(serializer.Read(ref this' default));                          }                          break;                      case WireType.Varint:                      case WireType.SignedVarint:                          long end = GetPosition() + bytes;                          do                          {                              _reader.WireType = wireType;                              list.Add(serializer.Read(ref this' default));                          } while (GetPosition() < end);                          if (GetPosition() != end) ThrowHelper.ThrowInvalidOperationException("over-read packed data");                          break;                      default:                          ThrowHelper.ThrowInvalidPackedOperationException(WireType' typeof(T));                          break;                  }
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ReadPackedScalar,The following statement contains a magic number: switch (wireType)                  {                      case WireType.Fixed32:                          if ((bytes % 4) != 0) ThrowHelper.ThrowInvalidOperationException("packed length should be multiple of 4");                          var count = bytes / 4;                          goto ReadFixedQuantity;                      case WireType.Fixed64:                          if ((bytes % 8) != 0) ThrowHelper.ThrowInvalidOperationException("packed length should be multiple of 8");                          count = bytes / 8;                          ReadFixedQuantity:                          // boost the List<T> capacity if we can' as long as it is within reason (i.e. don't let                          // a small message lie and claim to have a huge payload)                            const int MAX_GROW = 8192; // if they are much bigge than this' then the doubling API will help' anyhows                          if (list is List<T> l) l.Capacity = Math.Max(l.Capacity' l.Count + Math.Min(count' MAX_GROW));                            for (int i = 0; i < count; i++)                          {                              _reader.WireType = wireType;                              list.Add(serializer.Read(ref this' default));                          }                          break;                      case WireType.Varint:                      case WireType.SignedVarint:                          long end = GetPosition() + bytes;                          do                          {                              _reader.WireType = wireType;                              list.Add(serializer.Read(ref this' default));                          } while (GetPosition() < end);                          if (GetPosition() != end) ThrowHelper.ThrowInvalidOperationException("over-read packed data");                          break;                      default:                          ThrowHelper.ThrowInvalidPackedOperationException(WireType' typeof(T));                          break;                  }
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ReadPackedScalar,The following statement contains a magic number: switch (wireType)                  {                      case WireType.Fixed32:                          if ((bytes % 4) != 0) ThrowHelper.ThrowInvalidOperationException("packed length should be multiple of 4");                          var count = bytes / 4;                          goto ReadFixedQuantity;                      case WireType.Fixed64:                          if ((bytes % 8) != 0) ThrowHelper.ThrowInvalidOperationException("packed length should be multiple of 8");                          count = bytes / 8;                          ReadFixedQuantity:                          // boost the List<T> capacity if we can' as long as it is within reason (i.e. don't let                          // a small message lie and claim to have a huge payload)                            const int MAX_GROW = 8192; // if they are much bigge than this' then the doubling API will help' anyhows                          if (list is List<T> l) l.Capacity = Math.Max(l.Capacity' l.Count + Math.Min(count' MAX_GROW));                            for (int i = 0; i < count; i++)                          {                              _reader.WireType = wireType;                              list.Add(serializer.Read(ref this' default));                          }                          break;                      case WireType.Varint:                      case WireType.SignedVarint:                          long end = GetPosition() + bytes;                          do                          {                              _reader.WireType = wireType;                              list.Add(serializer.Read(ref this' default));                          } while (GetPosition() < end);                          if (GetPosition() != end) ThrowHelper.ThrowInvalidOperationException("over-read packed data");                          break;                      default:                          ThrowHelper.ThrowInvalidPackedOperationException(WireType' typeof(T));                          break;                  }
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,SkipField,The following statement contains a magic number: switch (_reader.WireType)                  {                      case WireType.Fixed32:                          _reader.ImplSkipBytes(ref this' 4);                          break;                      case WireType.Fixed64:                          _reader.ImplSkipBytes(ref this' 8);                          break;                      case WireType.String:                          long len = (long)ReadUInt64Varint();                          _reader.ImplSkipBytes(ref this' len);                          break;                      case WireType.Varint:                      case WireType.SignedVarint:                          ReadUInt64Varint(); // and drop it                          break;                      case WireType.StartGroup:                          SkipGroup();                          break;                      case WireType.None: // treat as explicit errorr                      case WireType.EndGroup: // treat as explicit error                      default: // treat as implicit error                          ThrowWireTypeException();                          break;                  }
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,SkipField,The following statement contains a magic number: switch (_reader.WireType)                  {                      case WireType.Fixed32:                          _reader.ImplSkipBytes(ref this' 4);                          break;                      case WireType.Fixed64:                          _reader.ImplSkipBytes(ref this' 8);                          break;                      case WireType.String:                          long len = (long)ReadUInt64Varint();                          _reader.ImplSkipBytes(ref this' len);                          break;                      case WireType.Varint:                      case WireType.SignedVarint:                          ReadUInt64Varint(); // and drop it                          break;                      case WireType.StartGroup:                          SkipGroup();                          break;                      case WireType.None: // treat as explicit errorr                      case WireType.EndGroup: // treat as explicit error                      default: // treat as implicit error                          ThrowWireTypeException();                          break;                  }
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ReadFieldHeader,The following statement contains a magic number: RemainingInCurrent >= 5
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryReadFieldHeader,The following statement contains a magic number: read > 0 && ((int)tag >> 3) == field                      && (tmpWireType = (WireType)(tag & 7)) != WireType.EndGroup
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryReadFieldHeader,The following statement contains a magic number: read > 0 && ((int)tag >> 3) == field                      && (tmpWireType = (WireType)(tag & 7)) != WireType.EndGroup
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,Zag,The following statement contains a magic number: const int Int32Msb = 1 << 31;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,Zag,The following statement contains a magic number: const long Int64Msb = 1L << 63;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,LocalWriteFixed32,The following statement contains a magic number: OffsetInCurrent += 4;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,LocalWriteFixed32,The following statement contains a magic number: RemainingInCurrent -= 4;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,LocalWriteFixed64,The following statement contains a magic number: OffsetInCurrent += 8;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,LocalWriteFixed64,The following statement contains a magic number: RemainingInCurrent -= 8;
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,WriteInt32,The following statement contains a magic number: switch (writer.WireType)                  {                      case WireType.Fixed32:                          writer.ImplWriteFixed32(ref this' (uint)value);                          writer.AdvanceAndReset(4);                          return;                      case WireType.Fixed64:                          writer.ImplWriteFixed64(ref this' (ulong)(long)value);                          writer.AdvanceAndReset(8);                          return;                      case WireType.Varint:                          WriteInt32VarintImpl(value);                          return;                      case WireType.SignedVarint:                          writer.AdvanceAndReset(writer.ImplWriteVarint32(ref this' Zig(value)));                          return;                      default:                          ThrowInvalidSerializationOperation();                          break;                  }
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,WriteInt32,The following statement contains a magic number: switch (writer.WireType)                  {                      case WireType.Fixed32:                          writer.ImplWriteFixed32(ref this' (uint)value);                          writer.AdvanceAndReset(4);                          return;                      case WireType.Fixed64:                          writer.ImplWriteFixed64(ref this' (ulong)(long)value);                          writer.AdvanceAndReset(8);                          return;                      case WireType.Varint:                          WriteInt32VarintImpl(value);                          return;                      case WireType.SignedVarint:                          writer.AdvanceAndReset(writer.ImplWriteVarint32(ref this' Zig(value)));                          return;                      default:                          ThrowInvalidSerializationOperation();                          break;                  }
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,WriteUInt32,The following statement contains a magic number: switch (writer.WireType)                  {                      case WireType.Fixed32:                          writer.ImplWriteFixed32(ref this' value);                          writer.AdvanceAndReset(4);                          return;                      case WireType.Fixed64:                          writer.ImplWriteFixed64(ref this' value);                          writer.AdvanceAndReset(8);                          return;                      case WireType.Varint:                          int bytes = writer.ImplWriteVarint32(ref this' value);                          writer.AdvanceAndReset(bytes);                          return;                      default:                          ThrowInvalidSerializationOperation();                          break;                  }
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,WriteUInt32,The following statement contains a magic number: switch (writer.WireType)                  {                      case WireType.Fixed32:                          writer.ImplWriteFixed32(ref this' value);                          writer.AdvanceAndReset(4);                          return;                      case WireType.Fixed64:                          writer.ImplWriteFixed64(ref this' value);                          writer.AdvanceAndReset(8);                          return;                      case WireType.Varint:                          int bytes = writer.ImplWriteVarint32(ref this' value);                          writer.AdvanceAndReset(bytes);                          return;                      default:                          ThrowInvalidSerializationOperation();                          break;                  }
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,WriteDouble,The following statement contains a magic number: switch (writer.WireType)                  {                      case WireType.Fixed32:                          float f = (float)value;                          if (float.IsInfinity(f) && !double.IsInfinity(value))                          {                              ThrowHelper.ThrowOverflowException();                          }                          WriteSingle(f);                          return;                      case WireType.Fixed64:                          unsafe { writer.ImplWriteFixed64(ref this' *(ulong*)&value); }                          writer.AdvanceAndReset(8);                          return;                      default:                          ThrowInvalidSerializationOperation();                          return;                  }
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,WriteSingle,The following statement contains a magic number: switch (writer.WireType)                  {                      case WireType.Fixed32:                          unsafe { writer.ImplWriteFixed32(ref this' *(uint*)&value); }                          writer.AdvanceAndReset(4);                          return;                      case WireType.Fixed64:                          WriteDouble(value);                          return;                      default:                          ThrowInvalidSerializationOperation();                          break;                  }
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,WriteInt64,The following statement contains a magic number: switch (writer.WireType)                  {                      case WireType.Fixed64:                          writer.ImplWriteFixed64(ref this' (ulong)value);                          writer.AdvanceAndReset(8);                          return;                      case WireType.Varint:                          writer.AdvanceAndReset(writer.ImplWriteVarint64(ref this' (ulong)value));                          return;                      case WireType.SignedVarint:                          writer.AdvanceAndReset(writer.ImplWriteVarint64(ref this' Zig(value)));                          return;                      case WireType.Fixed32:                          writer.ImplWriteFixed32(ref this' checked((uint)(int)value));                          writer.AdvanceAndReset(4);                          return;                      default:                          ThrowInvalidSerializationOperation();                          break;                  }
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,WriteInt64,The following statement contains a magic number: switch (writer.WireType)                  {                      case WireType.Fixed64:                          writer.ImplWriteFixed64(ref this' (ulong)value);                          writer.AdvanceAndReset(8);                          return;                      case WireType.Varint:                          writer.AdvanceAndReset(writer.ImplWriteVarint64(ref this' (ulong)value));                          return;                      case WireType.SignedVarint:                          writer.AdvanceAndReset(writer.ImplWriteVarint64(ref this' Zig(value)));                          return;                      case WireType.Fixed32:                          writer.ImplWriteFixed32(ref this' checked((uint)(int)value));                          writer.AdvanceAndReset(4);                          return;                      default:                          ThrowInvalidSerializationOperation();                          break;                  }
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,WriteUInt64,The following statement contains a magic number: switch (writer.WireType)                  {                      case WireType.Fixed64:                          writer.ImplWriteFixed64(ref this' value);                          writer.AdvanceAndReset(8);                          return;                      case WireType.Varint:                          int bytes = writer.ImplWriteVarint64(ref this' value);                          writer.AdvanceAndReset(bytes);                          return;                      case WireType.Fixed32:                          writer.ImplWriteFixed32(ref this' checked((uint)value));                          writer.AdvanceAndReset(4);                          return;                      default:                          ThrowInvalidSerializationOperation();                          break;                  }
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,WriteUInt64,The following statement contains a magic number: switch (writer.WireType)                  {                      case WireType.Fixed64:                          writer.ImplWriteFixed64(ref this' value);                          writer.AdvanceAndReset(8);                          return;                      case WireType.Varint:                          int bytes = writer.ImplWriteVarint64(ref this' value);                          writer.AdvanceAndReset(bytes);                          return;                      case WireType.Fixed32:                          writer.ImplWriteFixed32(ref this' checked((uint)value));                          writer.AdvanceAndReset(4);                          return;                      default:                          ThrowInvalidSerializationOperation();                          break;                  }
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,WriteBytes,The following statement contains a magic number: switch (writer.WireType)                  {                      case WireType.Fixed32:                          if (length != 4) ThrowHelper.ThrowArgumentException(nameof(length));                          writer.ImplWriteBytes(ref this' data);                          writer.AdvanceAndReset(4);                          return;                      case WireType.Fixed64:                          if (length != 8) ThrowHelper.ThrowArgumentException(nameof(length));                          writer.ImplWriteBytes(ref this' data);                          writer.AdvanceAndReset(8);                          return;                      case WireType.String:                          writer.AdvanceAndReset(writer.ImplWriteVarint32(ref this' (uint)length) + length);                          if (length == 0) return;                          writer.ImplWriteBytes(ref this' data);                          break;                      default:                          ThrowInvalidSerializationOperation();                          break;                  }
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,WriteBytes,The following statement contains a magic number: switch (writer.WireType)                  {                      case WireType.Fixed32:                          if (length != 4) ThrowHelper.ThrowArgumentException(nameof(length));                          writer.ImplWriteBytes(ref this' data);                          writer.AdvanceAndReset(4);                          return;                      case WireType.Fixed64:                          if (length != 8) ThrowHelper.ThrowArgumentException(nameof(length));                          writer.ImplWriteBytes(ref this' data);                          writer.AdvanceAndReset(8);                          return;                      case WireType.String:                          writer.AdvanceAndReset(writer.ImplWriteVarint32(ref this' (uint)length) + length);                          if (length == 0) return;                          writer.ImplWriteBytes(ref this' data);                          break;                      default:                          ThrowInvalidSerializationOperation();                          break;                  }
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,WriteBytes,The following statement contains a magic number: switch (writer.WireType)                  {                      case WireType.Fixed32:                          if (length != 4) ThrowHelper.ThrowArgumentException(nameof(length));                          writer.ImplWriteBytes(ref this' data);                          writer.AdvanceAndReset(4);                          return;                      case WireType.Fixed64:                          if (length != 8) ThrowHelper.ThrowArgumentException(nameof(length));                          writer.ImplWriteBytes(ref this' data);                          writer.AdvanceAndReset(8);                          return;                      case WireType.String:                          writer.AdvanceAndReset(writer.ImplWriteVarint32(ref this' (uint)length) + length);                          if (length == 0) return;                          writer.ImplWriteBytes(ref this' data);                          break;                      default:                          ThrowInvalidSerializationOperation();                          break;                  }
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,WriteBytes,The following statement contains a magic number: switch (writer.WireType)                  {                      case WireType.Fixed32:                          if (length != 4) ThrowHelper.ThrowArgumentException(nameof(length));                          writer.ImplWriteBytes(ref this' data);                          writer.AdvanceAndReset(4);                          return;                      case WireType.Fixed64:                          if (length != 8) ThrowHelper.ThrowArgumentException(nameof(length));                          writer.ImplWriteBytes(ref this' data);                          writer.AdvanceAndReset(8);                          return;                      case WireType.String:                          writer.AdvanceAndReset(writer.ImplWriteVarint32(ref this' (uint)length) + length);                          if (length == 0) return;                          writer.ImplWriteBytes(ref this' data);                          break;                      default:                          ThrowInvalidSerializationOperation();                          break;                  }
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,WriteBytes,The following statement contains a magic number: switch (writer.WireType)                  {                      case WireType.Fixed32:                          if (length != 4) ThrowHelper.ThrowArgumentException(nameof(length));                          writer.ImplWriteBytes(ref this' data);                          writer.AdvanceAndReset(4);                          return;                      case WireType.Fixed64:                          if (length != 8) ThrowHelper.ThrowArgumentException(nameof(length));                          writer.ImplWriteBytes(ref this' data);                          writer.AdvanceAndReset(8);                          return;                      case WireType.String:                          writer.AdvanceAndReset(writer.ImplWriteVarint32(ref this' (uint)length) + length);                          if (length == 0) return;                          writer.ImplWriteBytes(ref this' data);                          break;                      default:                          ThrowInvalidSerializationOperation();                          break;                  }
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,WriteBytes,The following statement contains a magic number: switch (writer.WireType)                  {                      case WireType.Fixed32:                          if (length != 4) ThrowHelper.ThrowArgumentException(nameof(length));                          writer.ImplWriteBytes(ref this' data);                          writer.AdvanceAndReset(4);                          return;                      case WireType.Fixed64:                          if (length != 8) ThrowHelper.ThrowArgumentException(nameof(length));                          writer.ImplWriteBytes(ref this' data);                          writer.AdvanceAndReset(8);                          return;                      case WireType.String:                          writer.AdvanceAndReset(writer.ImplWriteVarint32(ref this' (uint)length) + length);                          if (length == 0) return;                          writer.ImplWriteBytes(ref this' data);                          break;                      default:                          ThrowInvalidSerializationOperation();                          break;                  }
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,WriteBytes,The following statement contains a magic number: switch (writer.WireType)                  {                      case WireType.Fixed32:                          if (length != 4) ThrowHelper.ThrowArgumentException(nameof(length));                          writer.ImplWriteBytes(ref this' data);                          writer.AdvanceAndReset(4);                          return;                      case WireType.Fixed64:                          if (length != 8) ThrowHelper.ThrowArgumentException(nameof(length));                          writer.ImplWriteBytes(ref this' data);                          writer.AdvanceAndReset(8);                          return;                      case WireType.String:                          writer.AdvanceAndReset(writer.ImplWriteVarint32(ref this' (uint)length) + length);                          if (length == 0) return;                          writer.ImplWriteBytes(ref this' data);                          break;                      default:                          ThrowInvalidSerializationOperation();                          break;                  }
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,WriteBytes,The following statement contains a magic number: switch (writer.WireType)                  {                      case WireType.Fixed32:                          if (length != 4) ThrowHelper.ThrowArgumentException(nameof(length));                          writer.ImplWriteBytes(ref this' data);                          writer.AdvanceAndReset(4);                          return;                      case WireType.Fixed64:                          if (length != 8) ThrowHelper.ThrowArgumentException(nameof(length));                          writer.ImplWriteBytes(ref this' data);                          writer.AdvanceAndReset(8);                          return;                      case WireType.String:                          writer.AdvanceAndReset(writer.ImplWriteVarint32(ref this' (uint)length) + length);                          if (length == 0) return;                          writer.ImplWriteBytes(ref this' data);                          break;                      default:                          ThrowInvalidSerializationOperation();                          break;                  }
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,WritePackedPrefix,The following statement contains a magic number: switch (wireType)                  {                      // use long in case very large arrays are enabled                      case WireType.Fixed32: bytes = ((ulong)elementCount) << 2; break; // x4                      case WireType.Fixed64: bytes = ((ulong)elementCount) << 3; break; // x8                      default:                          ThrowHelper.ThrowArgumentOutOfRangeException(nameof(wireType)' "Invalid wire-type: " + wireType);                          bytes = default;                          break;                  }
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,WritePackedPrefix,The following statement contains a magic number: switch (wireType)                  {                      // use long in case very large arrays are enabled                      case WireType.Fixed32: bytes = ((ulong)elementCount) << 2; break; // x4                      case WireType.Fixed64: bytes = ((ulong)elementCount) << 3; break; // x8                      default:                          ThrowHelper.ThrowArgumentOutOfRangeException(nameof(wireType)' "Invalid wire-type: " + wireType);                          bytes = default;                          break;                  }
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,WriteHeaderCore,The following statement contains a magic number: uint header = (((uint)fieldNumber) << 3)                      | (((uint)wireType) & 7);
Magic Number,ProtoBuf,State,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,WriteHeaderCore,The following statement contains a magic number: uint header = (((uint)fieldNumber) << 3)                      | (((uint)wireType) & 7);
Magic Number,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt32Varint,The following statement contains a magic number: value |= (chunk & 0x7F) << 7;
Magic Number,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt32Varint,The following statement contains a magic number: return 2;
Magic Number,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt32Varint,The following statement contains a magic number: value |= (chunk & 0x7F) << 14;
Magic Number,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt32Varint,The following statement contains a magic number: return 3;
Magic Number,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt32Varint,The following statement contains a magic number: value |= (chunk & 0x7F) << 21;
Magic Number,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt32Varint,The following statement contains a magic number: return 4;
Magic Number,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt32Varint,The following statement contains a magic number: value |= chunk << 28;
Magic Number,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt32Varint,The following statement contains a magic number: return 5;
Magic Number,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt32Varint,The following statement contains a magic number: return 10;
Magic Number,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt32Varint,The following statement contains a magic number: trimNegative // allow for -ve values                      && (chunk & 0xF0) == 0xF0                      && offset + 4 < (uint)span.Length                          && span[offset] == 0xFF                          && span[offset + 1] == 0xFF                          && span[offset + 2] == 0xFF                          && span[offset + 3] == 0xFF                          && span[offset + 4] == 0x01
Magic Number,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt32Varint,The following statement contains a magic number: trimNegative // allow for -ve values                      && (chunk & 0xF0) == 0xF0                      && offset + 4 < (uint)span.Length                          && span[offset] == 0xFF                          && span[offset + 1] == 0xFF                          && span[offset + 2] == 0xFF                          && span[offset + 3] == 0xFF                          && span[offset + 4] == 0x01
Magic Number,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt32Varint,The following statement contains a magic number: trimNegative // allow for -ve values                      && (chunk & 0xF0) == 0xF0                      && offset + 4 < (uint)span.Length                          && span[offset] == 0xFF                          && span[offset + 1] == 0xFF                          && span[offset + 2] == 0xFF                          && span[offset + 3] == 0xFF                          && span[offset + 4] == 0x01
Magic Number,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,TryParseUInt32Varint,The following statement contains a magic number: trimNegative // allow for -ve values                      && (chunk & 0xF0) == 0xF0                      && offset + 4 < (uint)span.Length                          && span[offset] == 0xFF                          && span[offset + 1] == 0xFF                          && span[offset + 2] == 0xFF                          && span[offset + 3] == 0xFF                          && span[offset + 4] == 0x01
Magic Number,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: return state.RemainingInCurrent >= 10                      ? State.TryParseUInt64Varint(state.Span' state.OffsetInCurrent' out value)                      : ViaStackAlloc(this' ref state' out value);
Magic Number,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: Span<byte> span = stackalloc byte[10];
Magic Number,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: available != 10
Magic Number,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ImplReadUInt32Fixed,The following statement contains a magic number: return state.RemainingInCurrent >= 4                      ? BinaryPrimitives.ReadUInt32LittleEndian(Consume(ref state' 4))                      : ViaStackAlloc(ref state);
Magic Number,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ImplReadUInt32Fixed,The following statement contains a magic number: return state.RemainingInCurrent >= 4                      ? BinaryPrimitives.ReadUInt32LittleEndian(Consume(ref state' 4))                      : ViaStackAlloc(ref state);
Magic Number,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ImplReadUInt32Fixed,The following statement contains a magic number: Span<byte> span = stackalloc byte[4];
Magic Number,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ImplReadUInt64Fixed,The following statement contains a magic number: return state.RemainingInCurrent >= 8                      ? BinaryPrimitives.ReadUInt64LittleEndian(Consume(ref state' 8))                      : ViaStackAlloc(ref state);
Magic Number,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ImplReadUInt64Fixed,The following statement contains a magic number: return state.RemainingInCurrent >= 8                      ? BinaryPrimitives.ReadUInt64LittleEndian(Consume(ref state' 8))                      : ViaStackAlloc(ref state);
Magic Number,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ImplReadUInt64Fixed,The following statement contains a magic number: Span<byte> span = stackalloc byte[8];
Magic Number,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ImplTryReadUInt32VarintWithoutMoving,The following statement contains a magic number: return state.RemainingInCurrent >= 10                      ? TryParseUInt32Varint(ref state' state.OffsetInCurrent'                          mode == Read32VarintMode.Signed' out value' state.Span)                      : ViaStackAlloc(ref state' mode' out value);
Magic Number,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ImplTryReadUInt32VarintWithoutMoving,The following statement contains a magic number: byte* stack = stackalloc byte[10];
Magic Number,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ImplTryReadUInt32VarintWithoutMoving,The following statement contains a magic number: Span<byte> span = new Span<byte>(stack' 10);
Magic Number,ProtoBuf,ReadOnlySequenceProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.ReadOnlySequence.cs,ImplTryReadUInt32VarintWithoutMoving,The following statement contains a magic number: available != 10
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt32VarintWithoutMoving,The following statement contains a magic number: Ensure(ref state' 10' false);
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt32VarintWithoutMoving,The following statement contains a magic number: _available < 10
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt32VarintWithoutMoving,The following statement contains a magic number: value |= (chunk & 0x7F) << 7;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt32VarintWithoutMoving,The following statement contains a magic number: return 2;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt32VarintWithoutMoving,The following statement contains a magic number: _available == 2
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt32VarintWithoutMoving,The following statement contains a magic number: value |= (chunk & 0x7F) << 14;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt32VarintWithoutMoving,The following statement contains a magic number: return 3;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt32VarintWithoutMoving,The following statement contains a magic number: _available == 3
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt32VarintWithoutMoving,The following statement contains a magic number: value |= (chunk & 0x7F) << 21;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt32VarintWithoutMoving,The following statement contains a magic number: return 4;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt32VarintWithoutMoving,The following statement contains a magic number: _available == 4
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt32VarintWithoutMoving,The following statement contains a magic number: value |= chunk << 28;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt32VarintWithoutMoving,The following statement contains a magic number: return 5;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt32VarintWithoutMoving,The following statement contains a magic number: return 10;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt32VarintWithoutMoving,The following statement contains a magic number: mode == Read32VarintMode.Signed // allow for -ve values                      && (chunk & 0xF0) == 0xF0                      && _available >= 10                          && _ioBuffer[++readPos] == 0xFF                          && _ioBuffer[++readPos] == 0xFF                          && _ioBuffer[++readPos] == 0xFF                          && _ioBuffer[++readPos] == 0xFF                          && _ioBuffer[++readPos] == 0x01
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplReadUInt64Fixed,The following statement contains a magic number: Ensure(ref state' 8' true);
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplReadUInt64Fixed,The following statement contains a magic number: _available < 8
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplReadUInt64Fixed,The following statement contains a magic number: Advance(8);
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplReadUInt64Fixed,The following statement contains a magic number: _available -= 8;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplReadUInt64Fixed,The following statement contains a magic number: var result = System.Buffers.Binary.BinaryPrimitives.ReadUInt64LittleEndian(_ioBuffer.AsSpan(_ioIndex' 8));
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplReadUInt64Fixed,The following statement contains a magic number: _ioIndex += 8;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: Ensure(ref state' 10' false);
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: _available < 10
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: value |= (chunk & 0x7F) << 7;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: return 2;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: _available == 2
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: value |= (chunk & 0x7F) << 14;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: return 3;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: _available == 3
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: value |= (chunk & 0x7F) << 21;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: return 4;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: _available == 4
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: value |= (chunk & 0x7F) << 28;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: return 5;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: _available == 5
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: value |= (chunk & 0x7F) << 35;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: return 6;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: _available == 6
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: value |= (chunk & 0x7F) << 42;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: return 7;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: _available == 7
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: value |= (chunk & 0x7F) << 49;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: return 8;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: _available == 8
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: value |= (chunk & 0x7F) << 56;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: return 9;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: _available == 9
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: value |= chunk << 63;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplTryReadUInt64VarintWithoutMoving,The following statement contains a magic number: return 10;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplReadUInt32Fixed,The following statement contains a magic number: Ensure(ref state' 4' true);
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplReadUInt32Fixed,The following statement contains a magic number: _available < 4
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplReadUInt32Fixed,The following statement contains a magic number: Advance(4);
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplReadUInt32Fixed,The following statement contains a magic number: _available -= 4;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplReadUInt32Fixed,The following statement contains a magic number: var result = System.Buffers.Binary.BinaryPrimitives.ReadUInt32LittleEndian(_ioBuffer.AsSpan(_ioIndex' 4));
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplReadUInt32Fixed,The following statement contains a magic number: _ioIndex += 4;
Magic Number,ProtoBuf,StreamProtoReader,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoReader.Stream.cs,ImplSkipBytes,The following statement contains a magic number: _available < count && count < 128
Magic Number,ProtoBuf,ProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.BufferWriter.cs,Zig,The following statement contains a magic number: return (uint)((value << 1) ^ (value >> 31));
Magic Number,ProtoBuf,ProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.BufferWriter.cs,Zig,The following statement contains a magic number: return (ulong)((value << 1) ^ (value >> 63));
Magic Number,ProtoBuf,ProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.BufferWriter.cs,MeasureUInt32,The following statement contains a magic number: (value >>= 7) != 0
Magic Number,ProtoBuf,ProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.BufferWriter.cs,MeasureUInt64,The following statement contains a magic number: (value >>= 7) != 0
Magic Number,ProtoBuf,BufferWriterProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.BufferWriter.cs,ImplWriteFixed32,The following statement contains a magic number: state.RemainingInCurrent < 4
Magic Number,ProtoBuf,BufferWriterProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.BufferWriter.cs,ImplWriteFixed64,The following statement contains a magic number: state.RemainingInCurrent < 8
Magic Number,ProtoBuf,BufferWriterProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.BufferWriter.cs,GetBuffer,The following statement contains a magic number: state.Init(_writer.GetMemory(128));
Magic Number,ProtoBuf,BufferWriterProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.BufferWriter.cs,ImplWriteVarint32,The following statement contains a magic number: state.RemainingInCurrent < 5
Magic Number,ProtoBuf,BufferWriterProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.BufferWriter.cs,ImplWriteVarint64,The following statement contains a magic number: state.RemainingInCurrent < 10
Magic Number,ProtoBuf,BufferWriterProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.BufferWriter.cs,WriteWithLengthPrefix,The following statement contains a magic number: switch (style)                  {                      case PrefixStyle.None:                          break;                      case PrefixStyle.Base128:                          AdvanceAndReset(ImplWriteVarint64(ref state' (ulong)calculatedLength));                          break;                      case PrefixStyle.Fixed32:                      case PrefixStyle.Fixed32BigEndian:                          ImplWriteFixed32(ref state' checked((uint)calculatedLength));                          if (style == PrefixStyle.Fixed32BigEndian)                              state.ReverseLast32();                          AdvanceAndReset(4);                          break;                      default:                          ThrowHelper.ThrowNotImplementedException($"Sub-object prefix style not implemented: {style}");                          break;                  }
Magic Number,ProtoBuf,NullProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Null.cs,ImplCopyRawFromStream,The following statement contains a magic number: var buffer = ArrayPool<byte>.Shared.Rent(8 * 1024);
Magic Number,ProtoBuf,NullProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Null.cs,ImplCopyRawFromStream,The following statement contains a magic number: var buffer = ArrayPool<byte>.Shared.Rent(8 * 1024);
Magic Number,ProtoBuf,NullProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Null.cs,AdvanceSubMessage,The following statement contains a magic number: switch (WireType)                  {                      case WireType.String:                      case WireType.Fixed32:                          switch (style)                          {                              case PrefixStyle.None:                                  preamble = 0;                                  break;                              case PrefixStyle.Fixed32:                              case PrefixStyle.Fixed32BigEndian:                                  preamble = 4;                                  break;                              case PrefixStyle.Base128:                                  preamble = ImplWriteVarint64(ref state' (ulong)length);                                  break;                              default:                                  state.ThrowInvalidSerializationOperation();                                  preamble = default;                                  break;                          }                          break;                      case WireType.StartGroup:                          // the start group is already written' so w just need to leave the end group                          preamble = ImplWriteVarint32(ref state' (uint)(fieldNumber << 3));                          break;                      default:                          state.ThrowInvalidSerializationOperation();                          preamble = default;                          break;                  }
Magic Number,ProtoBuf,NullProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Null.cs,AdvanceSubMessage,The following statement contains a magic number: switch (WireType)                  {                      case WireType.String:                      case WireType.Fixed32:                          switch (style)                          {                              case PrefixStyle.None:                                  preamble = 0;                                  break;                              case PrefixStyle.Fixed32:                              case PrefixStyle.Fixed32BigEndian:                                  preamble = 4;                                  break;                              case PrefixStyle.Base128:                                  preamble = ImplWriteVarint64(ref state' (ulong)length);                                  break;                              default:                                  state.ThrowInvalidSerializationOperation();                                  preamble = default;                                  break;                          }                          break;                      case WireType.StartGroup:                          // the start group is already written' so w just need to leave the end group                          preamble = ImplWriteVarint32(ref state' (uint)(fieldNumber << 3));                          break;                      default:                          state.ThrowInvalidSerializationOperation();                          preamble = default;                          break;                  }
Magic Number,ProtoBuf,NullProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Null.cs,ImplEndLengthPrefixedSubItem,The following statement contains a magic number: switch(style)                  {                      case PrefixStyle.Fixed32BigEndian:                      case PrefixStyle.Fixed32:                          bytes = 4;                          break;                      case PrefixStyle.Base128:                          bytes = ImplWriteVarint64(ref state' (ulong)len);                          break;                      default:                          state.ThrowInvalidSerializationOperation();                          goto case PrefixStyle.None;                      case PrefixStyle.None:                          bytes = 0;                          break;                  }
Magic Number,ProtoBuf,StreamProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Stream.cs,WriteFallback,The following statement contains a magic number: var buffer = ArrayPool<byte>.Shared.Rent(2048);
Magic Number,ProtoBuf,StreamProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Stream.cs,WriteUInt32ToBuffer,The following statement contains a magic number: System.Buffers.Binary.BinaryPrimitives.WriteUInt32LittleEndian(buffer.AsSpan(index' 4)' value);
Magic Number,ProtoBuf,StreamProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Stream.cs,ImplWriteFixed32,The following statement contains a magic number: DemandSpace(4' this' ref state);
Magic Number,ProtoBuf,StreamProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Stream.cs,ImplWriteFixed32,The following statement contains a magic number: ioIndex += 4;
Magic Number,ProtoBuf,StreamProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Stream.cs,ImplWriteFixed64,The following statement contains a magic number: DemandSpace(8' this' ref state);
Magic Number,ProtoBuf,StreamProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Stream.cs,ImplWriteFixed64,The following statement contains a magic number: System.Buffers.Binary.BinaryPrimitives.WriteUInt64LittleEndian(buffer.AsSpan(index' 8)' value);
Magic Number,ProtoBuf,StreamProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Stream.cs,ImplWriteFixed64,The following statement contains a magic number: ioIndex += 8;
Magic Number,ProtoBuf,StreamProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Stream.cs,ImplWriteVarint64,The following statement contains a magic number: DemandSpace(10' this' ref state);
Magic Number,ProtoBuf,StreamProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Stream.cs,ImplWriteVarint32,The following statement contains a magic number: DemandSpace(5' this' ref state);
Magic Number,ProtoBuf,StreamProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Stream.cs,ImplStartLengthPrefixedSubItem,The following statement contains a magic number: switch (WireType)                  {                      case WireType.String:                          WireType = WireType.None;                          DemandSpace(32' this' ref state); // make some space in anticipation...                          flushLock++;                          Advance(1);                          return new SubItemToken((long)(ioIndex++)); // leave 1 space (optimistic) for length                      case WireType.Fixed32:                          DemandSpace(32' this' ref state); // make some space in anticipation...                          flushLock++;                          SubItemToken token = new SubItemToken((long)ioIndex);                          IncrementedAndReset(4' this); // leave 4 space (rigid) for length                          return token;                      default:                          state.ThrowInvalidSerializationOperation();                          return default;                  }
Magic Number,ProtoBuf,StreamProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Stream.cs,ImplStartLengthPrefixedSubItem,The following statement contains a magic number: switch (WireType)                  {                      case WireType.String:                          WireType = WireType.None;                          DemandSpace(32' this' ref state); // make some space in anticipation...                          flushLock++;                          Advance(1);                          return new SubItemToken((long)(ioIndex++)); // leave 1 space (optimistic) for length                      case WireType.Fixed32:                          DemandSpace(32' this' ref state); // make some space in anticipation...                          flushLock++;                          SubItemToken token = new SubItemToken((long)ioIndex);                          IncrementedAndReset(4' this); // leave 4 space (rigid) for length                          return token;                      default:                          state.ThrowInvalidSerializationOperation();                          return default;                  }
Magic Number,ProtoBuf,StreamProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Stream.cs,ImplStartLengthPrefixedSubItem,The following statement contains a magic number: switch (WireType)                  {                      case WireType.String:                          WireType = WireType.None;                          DemandSpace(32' this' ref state); // make some space in anticipation...                          flushLock++;                          Advance(1);                          return new SubItemToken((long)(ioIndex++)); // leave 1 space (optimistic) for length                      case WireType.Fixed32:                          DemandSpace(32' this' ref state); // make some space in anticipation...                          flushLock++;                          SubItemToken token = new SubItemToken((long)ioIndex);                          IncrementedAndReset(4' this); // leave 4 space (rigid) for length                          return token;                      default:                          state.ThrowInvalidSerializationOperation();                          return default;                  }
Magic Number,ProtoBuf,StreamProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Stream.cs,ImplEndLengthPrefixedSubItem,The following statement contains a magic number: switch (style)                  {                      case PrefixStyle.Fixed32:                          len = (int)(ioIndex - value - 4);                          WriteUInt32ToBuffer((uint)len' ioBuffer' value);                          break;                      case PrefixStyle.Fixed32BigEndian:                          len = (int)(ioIndex - value - 4);                          byte[] buffer = ioBuffer;                          WriteUInt32ToBuffer((uint)len' buffer' value);                          // and swap the byte order                          byte b = buffer[value];                          buffer[value] = buffer[value + 3];                          buffer[value + 3] = b;                          b = buffer[value + 1];                          buffer[value + 1] = buffer[value + 2];                          buffer[value + 2] = b;                          break;                      case PrefixStyle.Base128:                          // string - complicated because we only reserved one byte;                          // if the prefix turns out to need more than this then                          // we need to shuffle the existing data                          len = (int)(ioIndex - value - 1);                          int offset = 0;                          uint tmp = (uint)len;                          while ((tmp >>= 7) != 0) offset++;                          if (offset == 0)                          {                              ioBuffer[value] = (byte)(len & 0x7F);                          }                          else                          {                              DemandSpace(offset' this' ref state);                              byte[] blob = ioBuffer;                              Buffer.BlockCopy(blob' value + 1' blob' value + 1 + offset' len);                              tmp = (uint)len;                              do                              {                                  blob[value++] = (byte)((tmp & 0x7F) | 0x80);                              } while ((tmp >>= 7) != 0);                              blob[value - 1] = (byte)(blob[value - 1] & ~0x80);                              Advance(offset);                              ioIndex += offset;                          }                          break;                      default:                          ThrowHelper.ThrowArgumentOutOfRangeException(nameof(style));                          break;                  }
Magic Number,ProtoBuf,StreamProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Stream.cs,ImplEndLengthPrefixedSubItem,The following statement contains a magic number: switch (style)                  {                      case PrefixStyle.Fixed32:                          len = (int)(ioIndex - value - 4);                          WriteUInt32ToBuffer((uint)len' ioBuffer' value);                          break;                      case PrefixStyle.Fixed32BigEndian:                          len = (int)(ioIndex - value - 4);                          byte[] buffer = ioBuffer;                          WriteUInt32ToBuffer((uint)len' buffer' value);                          // and swap the byte order                          byte b = buffer[value];                          buffer[value] = buffer[value + 3];                          buffer[value + 3] = b;                          b = buffer[value + 1];                          buffer[value + 1] = buffer[value + 2];                          buffer[value + 2] = b;                          break;                      case PrefixStyle.Base128:                          // string - complicated because we only reserved one byte;                          // if the prefix turns out to need more than this then                          // we need to shuffle the existing data                          len = (int)(ioIndex - value - 1);                          int offset = 0;                          uint tmp = (uint)len;                          while ((tmp >>= 7) != 0) offset++;                          if (offset == 0)                          {                              ioBuffer[value] = (byte)(len & 0x7F);                          }                          else                          {                              DemandSpace(offset' this' ref state);                              byte[] blob = ioBuffer;                              Buffer.BlockCopy(blob' value + 1' blob' value + 1 + offset' len);                              tmp = (uint)len;                              do                              {                                  blob[value++] = (byte)((tmp & 0x7F) | 0x80);                              } while ((tmp >>= 7) != 0);                              blob[value - 1] = (byte)(blob[value - 1] & ~0x80);                              Advance(offset);                              ioIndex += offset;                          }                          break;                      default:                          ThrowHelper.ThrowArgumentOutOfRangeException(nameof(style));                          break;                  }
Magic Number,ProtoBuf,StreamProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Stream.cs,ImplEndLengthPrefixedSubItem,The following statement contains a magic number: switch (style)                  {                      case PrefixStyle.Fixed32:                          len = (int)(ioIndex - value - 4);                          WriteUInt32ToBuffer((uint)len' ioBuffer' value);                          break;                      case PrefixStyle.Fixed32BigEndian:                          len = (int)(ioIndex - value - 4);                          byte[] buffer = ioBuffer;                          WriteUInt32ToBuffer((uint)len' buffer' value);                          // and swap the byte order                          byte b = buffer[value];                          buffer[value] = buffer[value + 3];                          buffer[value + 3] = b;                          b = buffer[value + 1];                          buffer[value + 1] = buffer[value + 2];                          buffer[value + 2] = b;                          break;                      case PrefixStyle.Base128:                          // string - complicated because we only reserved one byte;                          // if the prefix turns out to need more than this then                          // we need to shuffle the existing data                          len = (int)(ioIndex - value - 1);                          int offset = 0;                          uint tmp = (uint)len;                          while ((tmp >>= 7) != 0) offset++;                          if (offset == 0)                          {                              ioBuffer[value] = (byte)(len & 0x7F);                          }                          else                          {                              DemandSpace(offset' this' ref state);                              byte[] blob = ioBuffer;                              Buffer.BlockCopy(blob' value + 1' blob' value + 1 + offset' len);                              tmp = (uint)len;                              do                              {                                  blob[value++] = (byte)((tmp & 0x7F) | 0x80);                              } while ((tmp >>= 7) != 0);                              blob[value - 1] = (byte)(blob[value - 1] & ~0x80);                              Advance(offset);                              ioIndex += offset;                          }                          break;                      default:                          ThrowHelper.ThrowArgumentOutOfRangeException(nameof(style));                          break;                  }
Magic Number,ProtoBuf,StreamProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Stream.cs,ImplEndLengthPrefixedSubItem,The following statement contains a magic number: switch (style)                  {                      case PrefixStyle.Fixed32:                          len = (int)(ioIndex - value - 4);                          WriteUInt32ToBuffer((uint)len' ioBuffer' value);                          break;                      case PrefixStyle.Fixed32BigEndian:                          len = (int)(ioIndex - value - 4);                          byte[] buffer = ioBuffer;                          WriteUInt32ToBuffer((uint)len' buffer' value);                          // and swap the byte order                          byte b = buffer[value];                          buffer[value] = buffer[value + 3];                          buffer[value + 3] = b;                          b = buffer[value + 1];                          buffer[value + 1] = buffer[value + 2];                          buffer[value + 2] = b;                          break;                      case PrefixStyle.Base128:                          // string - complicated because we only reserved one byte;                          // if the prefix turns out to need more than this then                          // we need to shuffle the existing data                          len = (int)(ioIndex - value - 1);                          int offset = 0;                          uint tmp = (uint)len;                          while ((tmp >>= 7) != 0) offset++;                          if (offset == 0)                          {                              ioBuffer[value] = (byte)(len & 0x7F);                          }                          else                          {                              DemandSpace(offset' this' ref state);                              byte[] blob = ioBuffer;                              Buffer.BlockCopy(blob' value + 1' blob' value + 1 + offset' len);                              tmp = (uint)len;                              do                              {                                  blob[value++] = (byte)((tmp & 0x7F) | 0x80);                              } while ((tmp >>= 7) != 0);                              blob[value - 1] = (byte)(blob[value - 1] & ~0x80);                              Advance(offset);                              ioIndex += offset;                          }                          break;                      default:                          ThrowHelper.ThrowArgumentOutOfRangeException(nameof(style));                          break;                  }
Magic Number,ProtoBuf,StreamProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Stream.cs,ImplEndLengthPrefixedSubItem,The following statement contains a magic number: switch (style)                  {                      case PrefixStyle.Fixed32:                          len = (int)(ioIndex - value - 4);                          WriteUInt32ToBuffer((uint)len' ioBuffer' value);                          break;                      case PrefixStyle.Fixed32BigEndian:                          len = (int)(ioIndex - value - 4);                          byte[] buffer = ioBuffer;                          WriteUInt32ToBuffer((uint)len' buffer' value);                          // and swap the byte order                          byte b = buffer[value];                          buffer[value] = buffer[value + 3];                          buffer[value + 3] = b;                          b = buffer[value + 1];                          buffer[value + 1] = buffer[value + 2];                          buffer[value + 2] = b;                          break;                      case PrefixStyle.Base128:                          // string - complicated because we only reserved one byte;                          // if the prefix turns out to need more than this then                          // we need to shuffle the existing data                          len = (int)(ioIndex - value - 1);                          int offset = 0;                          uint tmp = (uint)len;                          while ((tmp >>= 7) != 0) offset++;                          if (offset == 0)                          {                              ioBuffer[value] = (byte)(len & 0x7F);                          }                          else                          {                              DemandSpace(offset' this' ref state);                              byte[] blob = ioBuffer;                              Buffer.BlockCopy(blob' value + 1' blob' value + 1 + offset' len);                              tmp = (uint)len;                              do                              {                                  blob[value++] = (byte)((tmp & 0x7F) | 0x80);                              } while ((tmp >>= 7) != 0);                              blob[value - 1] = (byte)(blob[value - 1] & ~0x80);                              Advance(offset);                              ioIndex += offset;                          }                          break;                      default:                          ThrowHelper.ThrowArgumentOutOfRangeException(nameof(style));                          break;                  }
Magic Number,ProtoBuf,StreamProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Stream.cs,ImplEndLengthPrefixedSubItem,The following statement contains a magic number: switch (style)                  {                      case PrefixStyle.Fixed32:                          len = (int)(ioIndex - value - 4);                          WriteUInt32ToBuffer((uint)len' ioBuffer' value);                          break;                      case PrefixStyle.Fixed32BigEndian:                          len = (int)(ioIndex - value - 4);                          byte[] buffer = ioBuffer;                          WriteUInt32ToBuffer((uint)len' buffer' value);                          // and swap the byte order                          byte b = buffer[value];                          buffer[value] = buffer[value + 3];                          buffer[value + 3] = b;                          b = buffer[value + 1];                          buffer[value + 1] = buffer[value + 2];                          buffer[value + 2] = b;                          break;                      case PrefixStyle.Base128:                          // string - complicated because we only reserved one byte;                          // if the prefix turns out to need more than this then                          // we need to shuffle the existing data                          len = (int)(ioIndex - value - 1);                          int offset = 0;                          uint tmp = (uint)len;                          while ((tmp >>= 7) != 0) offset++;                          if (offset == 0)                          {                              ioBuffer[value] = (byte)(len & 0x7F);                          }                          else                          {                              DemandSpace(offset' this' ref state);                              byte[] blob = ioBuffer;                              Buffer.BlockCopy(blob' value + 1' blob' value + 1 + offset' len);                              tmp = (uint)len;                              do                              {                                  blob[value++] = (byte)((tmp & 0x7F) | 0x80);                              } while ((tmp >>= 7) != 0);                              blob[value - 1] = (byte)(blob[value - 1] & ~0x80);                              Advance(offset);                              ioIndex += offset;                          }                          break;                      default:                          ThrowHelper.ThrowArgumentOutOfRangeException(nameof(style));                          break;                  }
Magic Number,ProtoBuf,StreamProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Stream.cs,ImplEndLengthPrefixedSubItem,The following statement contains a magic number: switch (style)                  {                      case PrefixStyle.Fixed32:                          len = (int)(ioIndex - value - 4);                          WriteUInt32ToBuffer((uint)len' ioBuffer' value);                          break;                      case PrefixStyle.Fixed32BigEndian:                          len = (int)(ioIndex - value - 4);                          byte[] buffer = ioBuffer;                          WriteUInt32ToBuffer((uint)len' buffer' value);                          // and swap the byte order                          byte b = buffer[value];                          buffer[value] = buffer[value + 3];                          buffer[value + 3] = b;                          b = buffer[value + 1];                          buffer[value + 1] = buffer[value + 2];                          buffer[value + 2] = b;                          break;                      case PrefixStyle.Base128:                          // string - complicated because we only reserved one byte;                          // if the prefix turns out to need more than this then                          // we need to shuffle the existing data                          len = (int)(ioIndex - value - 1);                          int offset = 0;                          uint tmp = (uint)len;                          while ((tmp >>= 7) != 0) offset++;                          if (offset == 0)                          {                              ioBuffer[value] = (byte)(len & 0x7F);                          }                          else                          {                              DemandSpace(offset' this' ref state);                              byte[] blob = ioBuffer;                              Buffer.BlockCopy(blob' value + 1' blob' value + 1 + offset' len);                              tmp = (uint)len;                              do                              {                                  blob[value++] = (byte)((tmp & 0x7F) | 0x80);                              } while ((tmp >>= 7) != 0);                              blob[value - 1] = (byte)(blob[value - 1] & ~0x80);                              Advance(offset);                              ioIndex += offset;                          }                          break;                      default:                          ThrowHelper.ThrowArgumentOutOfRangeException(nameof(style));                          break;                  }
Magic Number,ProtoBuf,StreamProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Stream.cs,ImplEndLengthPrefixedSubItem,The following statement contains a magic number: switch (style)                  {                      case PrefixStyle.Fixed32:                          len = (int)(ioIndex - value - 4);                          WriteUInt32ToBuffer((uint)len' ioBuffer' value);                          break;                      case PrefixStyle.Fixed32BigEndian:                          len = (int)(ioIndex - value - 4);                          byte[] buffer = ioBuffer;                          WriteUInt32ToBuffer((uint)len' buffer' value);                          // and swap the byte order                          byte b = buffer[value];                          buffer[value] = buffer[value + 3];                          buffer[value + 3] = b;                          b = buffer[value + 1];                          buffer[value + 1] = buffer[value + 2];                          buffer[value + 2] = b;                          break;                      case PrefixStyle.Base128:                          // string - complicated because we only reserved one byte;                          // if the prefix turns out to need more than this then                          // we need to shuffle the existing data                          len = (int)(ioIndex - value - 1);                          int offset = 0;                          uint tmp = (uint)len;                          while ((tmp >>= 7) != 0) offset++;                          if (offset == 0)                          {                              ioBuffer[value] = (byte)(len & 0x7F);                          }                          else                          {                              DemandSpace(offset' this' ref state);                              byte[] blob = ioBuffer;                              Buffer.BlockCopy(blob' value + 1' blob' value + 1 + offset' len);                              tmp = (uint)len;                              do                              {                                  blob[value++] = (byte)((tmp & 0x7F) | 0x80);                              } while ((tmp >>= 7) != 0);                              blob[value - 1] = (byte)(blob[value - 1] & ~0x80);                              Advance(offset);                              ioIndex += offset;                          }                          break;                      default:                          ThrowHelper.ThrowArgumentOutOfRangeException(nameof(style));                          break;                  }
Magic Number,ProtoBuf,StreamProtoWriter,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\ProtoWriter.Stream.cs,ImplEndLengthPrefixedSubItem,The following statement contains a magic number: const int ADVISORY_FLUSH_SIZE = 1024;
Magic Number,ProtoBuf.Internal,KeyValuePairSerializer,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\KeyValuePairSerializer.cs,Read,The following statement contains a magic number: switch (field)                  {                      case 1:                          key = state.ReadAny(_keyFeatures' key' _keySerializer);                          break;                      case 2:                          value = state.ReadAny(_valueFeatures' value' _valueSerializer);                          break;                      default:                          state.SkipField();                          break;                  }
Magic Number,ProtoBuf.Internal,KeyValuePairSerializer,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\KeyValuePairSerializer.cs,Write,The following statement contains a magic number: state.WriteAny(2' _valueFeatures' value.Value' _valueSerializer);
Magic Number,ProtoBuf.Internal,PrimaryTypeProvider,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\PrimaryTypeProvider.Decimal.cs,Read,The following statement contains a magic number: int lo = (int)(low & 0xFFFFFFFFL)'                 mid = (int)((low >> 32) & 0xFFFFFFFFL)'                 hi = (int)high;
Magic Number,ProtoBuf.Internal,PrimaryTypeProvider,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\PrimaryTypeProvider.Decimal.cs,Write,The following statement contains a magic number: ulong a = ((ulong)dec.Mid) << 32' b = ((ulong)dec.Lo) & 0xFFFFFFFFL;
Magic Number,ProtoBuf.Internal,PrimaryTypeProvider,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\PrimaryTypeProvider.Decimal.cs,Write,The following statement contains a magic number: signScale = (uint)(((dec.Flags >> 15) & 0x01FE) | ((dec.Flags >> 31) & 0x0001));
Magic Number,ProtoBuf.Internal,PrimaryTypeProvider,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\PrimaryTypeProvider.Decimal.cs,Write,The following statement contains a magic number: signScale = (uint)(((dec.Flags >> 15) & 0x01FE) | ((dec.Flags >> 31) & 0x0001));
Magic Number,ProtoBuf.Internal,PrimaryTypeProvider,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\PrimaryTypeProvider.Decimal.cs,VerifyDecimalLayout,The following statement contains a magic number: return layout.Lo == bits[0]                              & layout.Mid == bits[1]                              & layout.Hi == bits[2]                              & layout.Flags == bits[3];
Magic Number,ProtoBuf.Internal,PrimaryTypeProvider,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\PrimaryTypeProvider.Decimal.cs,VerifyDecimalLayout,The following statement contains a magic number: return layout.Lo == bits[0]                              & layout.Mid == bits[1]                              & layout.Hi == bits[2]                              & layout.Flags == bits[3];
Magic Number,ProtoBuf.Internal,PrimaryTypeProvider,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\PrimaryTypeProvider.Decimal.cs,VerifyDecimalLayout,The following statement contains a magic number: bits.Length == 4
Magic Number,ProtoBuf.Internal,PrimaryTypeProvider,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\PrimaryTypeProvider.Decimal.cs,VerifyGuidLayout,The following statement contains a magic number: expected[i] != (byte)(low >> (8 * i))
Magic Number,ProtoBuf.Internal,PrimaryTypeProvider,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\PrimaryTypeProvider.Decimal.cs,VerifyGuidLayout,The following statement contains a magic number: i < 8
Magic Number,ProtoBuf.Internal,PrimaryTypeProvider,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\PrimaryTypeProvider.Decimal.cs,VerifyGuidLayout,The following statement contains a magic number: expected[i + 8] != (byte)(high >> (8 * i))
Magic Number,ProtoBuf.Internal,PrimaryTypeProvider,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\PrimaryTypeProvider.Decimal.cs,VerifyGuidLayout,The following statement contains a magic number: expected[i + 8] != (byte)(high >> (8 * i))
Magic Number,ProtoBuf.Internal,PrimaryTypeProvider,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\PrimaryTypeProvider.Decimal.cs,VerifyGuidLayout,The following statement contains a magic number: i < 8
Magic Number,ProtoBuf.Internal,PrimaryTypeProvider,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\PrimaryTypeProvider.Decimal.cs,ReadDuration,The following statement contains a magic number: state.WireType == WireType.String && state.RemainingInCurrent >= 20
Magic Number,ProtoBuf.Internal,PrimaryTypeProvider,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\PrimaryTypeProvider.Decimal.cs,TryReadDurationFast,The following statement contains a magic number: span[offset] != (1 << 3)
Magic Number,ProtoBuf.Internal,PrimaryTypeProvider,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\PrimaryTypeProvider.Decimal.cs,TryReadDurationFast,The following statement contains a magic number: span[msgOffset++ + offset] != (2 << 3)
Magic Number,ProtoBuf.Internal,PrimaryTypeProvider,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\PrimaryTypeProvider.Decimal.cs,TryReadDurationFast,The following statement contains a magic number: span[msgOffset++ + offset] != (2 << 3)
Magic Number,ProtoBuf.Internal,PrimaryTypeProvider,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\PrimaryTypeProvider.Decimal.cs,ReadDurationFallback,The following statement contains a magic number: switch (fieldNumber)                  {                      case 1:                          seconds = state.ReadInt64();                          break;                      case 2:                          nanos = state.ReadInt32();                          break;                      default:                          state.SkipField();                          break;                  }
Magic Number,ProtoBuf.Internal,PrimaryTypeProvider,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\PrimaryTypeProvider.Decimal.cs,ToDurationSeconds,The following statement contains a magic number: nanos = (int)(((value.Ticks % TimeSpan.TicksPerSecond) * 1000000)                  / TimeSpan.TicksPerMillisecond);
Magic Number,ProtoBuf.Internal,PrimaryTypeProvider,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\PrimaryTypeProvider.Decimal.cs,ToTicks,The following statement contains a magic number: long ticks = checked((seconds * TimeSpan.TicksPerSecond)                  + (nanos * TimeSpan.TicksPerMillisecond / 1000000));
Magic Number,ProtoBuf.Internal,PrimaryTypeProvider,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\PrimaryTypeProvider.Decimal.cs,NormalizeSecondsNanoseconds,The following statement contains a magic number: const int SECOND_NANOS = 1000000000;
Magic Number,ProtoBuf.Internal,PrimaryTypeProvider,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\PrimaryTypeProvider.Decimal.cs,WriteSecondsNanos,The following statement contains a magic number: state.WriteFieldHeader(2' WireType.Varint);
Magic Number,ProtoBuf.Internal,ReadBuffer,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\ReadBufferT.cs,Grow,The following statement contains a magic number: var newCapacity = Math.Min(oldCapacity * 2' 0X7FEFFFFF);
Magic Number,ProtoBuf.Serializers,RepeatedSerializer<TCollection;TItem>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\RepeatedSerializer.cs,WritePacked,The following statement contains a magic number: switch (wireType)              {                  case WireType.Fixed32:                      expectedLength = count * 4;                      break;                  case WireType.Fixed64:                      expectedLength = count * 8;                      break;                  case WireType.Varint:                  case WireType.SignedVarint:                      expectedLength = Measure(values' serializer' state.Context' wireType);                      break;                  default:                      ThrowHelper.ThrowInvalidPackedOperationException(wireType' typeof(TItem));                      expectedLength = default;                      break;              }
Magic Number,ProtoBuf.Serializers,RepeatedSerializer<TCollection;TItem>,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Serializers\RepeatedSerializer.cs,WritePacked,The following statement contains a magic number: switch (wireType)              {                  case WireType.Fixed32:                      expectedLength = count * 4;                      break;                  case WireType.Fixed64:                      expectedLength = count * 8;                      break;                  case WireType.Varint:                  case WireType.SignedVarint:                      expectedLength = Measure(values' serializer' state.Context' wireType);                      break;                  default:                      ThrowHelper.ThrowInvalidPackedOperationException(wireType' typeof(TItem));                      expectedLength = default;                      break;              }
Missing Default,ProtoBuf,DiscriminatedUnionObject,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\DiscriminatedUnion.cs,DiscriminatedUnionObject,The following switch statement is missing a default case: switch (field.Name)                  {                      case "d": Discriminator = (int)field.Value; break;                      case "o": Object = field.Value; break;                  }
Missing Default,ProtoBuf,DiscriminatedUnion64,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\DiscriminatedUnion.cs,DiscriminatedUnion64,The following switch statement is missing a default case: switch (field.Name)                  {                      case "d": _discriminator = (int)field.Value; break;                      case "i": Int64 = (long)field.Value; break;                  }
Missing Default,ProtoBuf,DiscriminatedUnion128Object,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\DiscriminatedUnion.cs,DiscriminatedUnion128Object,The following switch statement is missing a default case: switch (field.Name)                  {                      case "d": _discriminator = (int)field.Value; break;                      case "l": _lo = (long)field.Value; break;                      case "h": _hi = (long)field.Value; break;                      case "o": Object = field.Value; break;                  }
Missing Default,ProtoBuf,DiscriminatedUnion128,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\DiscriminatedUnion.cs,DiscriminatedUnion128,The following switch statement is missing a default case: switch (field.Name)                  {                      case "d": _discriminator = (int)field.Value; break;                      case "l": _lo = (long)field.Value; break;                      case "h": _hi = (long)field.Value; break;                  }
Missing Default,ProtoBuf,DiscriminatedUnion64Object,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\DiscriminatedUnion.cs,DiscriminatedUnion64Object,The following switch statement is missing a default case: switch (field.Name)                  {                      case "d": _discriminator = (int)field.Value; break;                      case "i": Int64 = (long)field.Value; break;                      case "o": Object = field.Value; break;                  }
Missing Default,ProtoBuf,DiscriminatedUnion32,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\DiscriminatedUnion.cs,DiscriminatedUnion32,The following switch statement is missing a default case: switch (field.Name)                  {                      case "d": _discriminator = (int)field.Value; break;                      case "i": Int32 = (int)field.Value; break;                  }
Missing Default,ProtoBuf,DiscriminatedUnion32Object,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\DiscriminatedUnion.cs,DiscriminatedUnion32Object,The following switch statement is missing a default case: switch (field.Name)                  {                      case "d": _discriminator = (int)field.Value; break;                      case "i": Int32 = (int)field.Value; break;                      case "o": Object = field.Value; break;                  }
Missing Default,ProtoBuf,Helpers,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Helpers.cs,GetTypeCode,The following switch statement is missing a default case: switch (code)              {                  case TypeCode.Empty:                  case TypeCode.Boolean:                  case TypeCode.Char:                  case TypeCode.SByte:                  case TypeCode.Byte:                  case TypeCode.Int16:                  case TypeCode.UInt16:                  case TypeCode.Int32:                  case TypeCode.UInt32:                  case TypeCode.Int64:                  case TypeCode.UInt64:                  case TypeCode.Single:                  case TypeCode.Double:                  case TypeCode.Decimal:                  case TypeCode.DateTime:                  case TypeCode.String:                      return (ProtoTypeCode)code;              }
Missing Default,ProtoBuf.Internal,DynamicStub,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\DynamicStub.cs,SlowGet,The following switch statement is missing a default case: switch (t.FullName)                      {                          case "NHibernate.Proxy.INHibernateProxy":                          case "NHibernate.Proxy.DynamicProxy.IProxy":                          case "NHibernate.Intercept.IFieldInterceptorAccessor":                              return type.BaseType;                      }
Missing Default,ProtoBuf.Internal,TypeHelper,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Internal\TypeHelperT.cs,CanBePacked,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))              {                  case TypeCode.Double:                  case TypeCode.Single:                  case TypeCode.SByte:                  case TypeCode.Int16:                  case TypeCode.Int32:                  case TypeCode.Int64:                  case TypeCode.Byte:                  case TypeCode.UInt16:                  case TypeCode.UInt32:                  case TypeCode.UInt64:                  case TypeCode.Boolean:                  case TypeCode.Char:                      return true;              }
Missing Default,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,GetWireType,The following switch statement is missing a default case: switch (Helpers.GetTypeCode(type))             {                 case ProtoTypeCode.Int64:                 case ProtoTypeCode.UInt64:                     return format == DataFormat.FixedSize ? WireType.Fixed64 : WireType.Varint;                 case ProtoTypeCode.Int16:                 case ProtoTypeCode.Int32:                 case ProtoTypeCode.UInt16:                 case ProtoTypeCode.UInt32:                 case ProtoTypeCode.Boolean:                 case ProtoTypeCode.SByte:                 case ProtoTypeCode.Byte:                 case ProtoTypeCode.Char:                     return format == DataFormat.FixedSize ? WireType.Fixed32 : WireType.Varint;                 case ProtoTypeCode.Double:                     return WireType.Fixed64;                 case ProtoTypeCode.Single:                     return WireType.Fixed32;                 case ProtoTypeCode.String:                 case ProtoTypeCode.DateTime:                 case ProtoTypeCode.Decimal:                 case ProtoTypeCode.ByteArray:                 case ProtoTypeCode.TimeSpan:                 case ProtoTypeCode.Guid:                 case ProtoTypeCode.Uri:                     return WireType.String;             }
Missing Default,ProtoBuf.Meta,TypeModel,D:\research\architectureSmells\repos\mgravell_protobuf-net\src\protobuf-net.Core\Meta\TypeModel.cs,CanSerialize,The following switch statement is missing a default case: switch (category)                      {                          case SerializerFeatures.CategoryRepeated:                              return allowLists && DoCheckLists(type' this' allowBasic' allowContract);                          case SerializerFeatures.CategoryMessage:                              return allowContract;                          case SerializerFeatures.CategoryScalar:                          case SerializerFeatures.CategoryMessageWrappedAtRoot:                              return allowBasic;                      }
