Implementation smell,Namespace,Class,File,Method,Description
Long Method,MoreInternals.Compiler.Tasks,Minify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Minify.cs,MinifyPropertyList,The method has 144 lines of code.
Long Method,MoreInternals.Compiler.Tasks,Verify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Verify.cs,VerifyTypes,The method has 106 lines of code.
Long Method,MoreInternals.Compiler.Tasks,Verify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Verify.cs,VerifyPossible,The method has 121 lines of code.
Long Method,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToRGB,The method has 107 lines of code.
Long Method,MoreInternals.Model,SelectorAndBlock,C:\repos\kevin-montrose_More\MoreInternals\Model\Block.cs,BindAndEvaluateMixins,The method has 181 lines of code.
Long Method,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The method has 302 lines of code.
Complex Method,MoreInternals.Compiler.Tasks,AutoPrefix,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\AutoPrefix.cs,Task,Cyclomatic complexity of the method is 14
Complex Method,MoreInternals.Compiler.Tasks,CacheBreak,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\CacheBreak.cs,Task,Cyclomatic complexity of the method is 11
Complex Method,MoreInternals.Compiler.Tasks,Evaluate,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Evaluate.cs,Task,Cyclomatic complexity of the method is 15
Complex Method,MoreInternals.Compiler.Tasks,FontFace,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\FontFace.cs,Task,Cyclomatic complexity of the method is 12
Complex Method,MoreInternals.Compiler.Tasks,Important,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Important.cs,Task,Cyclomatic complexity of the method is 10
Complex Method,MoreInternals.Compiler.Tasks,Includes,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Includes.cs,Impl,Cyclomatic complexity of the method is 11
Complex Method,MoreInternals.Compiler.Tasks,Media,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Media.cs,Task,Cyclomatic complexity of the method is 8
Complex Method,MoreInternals.Compiler.Tasks,Minify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Minify.cs,MinifyValue,Cyclomatic complexity of the method is 8
Complex Method,MoreInternals.Compiler.Tasks,Minify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Minify.cs,ForQuery,Cyclomatic complexity of the method is 9
Complex Method,MoreInternals.Compiler.Tasks,Minify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Minify.cs,Task,Cyclomatic complexity of the method is 9
Complex Method,MoreInternals.Compiler.Tasks,Minify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Minify.cs,MinifyFontProperties,Cyclomatic complexity of the method is 8
Complex Method,MoreInternals.Compiler.Tasks,Mixin,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Mixins.cs,Task,Cyclomatic complexity of the method is 9
Complex Method,MoreInternals.Compiler.Tasks,Using,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Using.cs,EvaluateUsingsImpl,Cyclomatic complexity of the method is 10
Complex Method,MoreInternals.Compiler.Tasks,References,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\References.cs,VerifyBlockVariableReferences,Cyclomatic complexity of the method is 9
Complex Method,MoreInternals.Compiler.Tasks,References,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\References.cs,VerifyVariableReferencesImpl,Cyclomatic complexity of the method is 19
Complex Method,MoreInternals.Compiler.Tasks,Verify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Verify.cs,VerifyTypes,Cyclomatic complexity of the method is 15
Complex Method,MoreInternals.Compiler.Tasks,Verify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Verify.cs,VerifyPossible,Cyclomatic complexity of the method is 26
Complex Method,MoreInternals.Compiler.Tasks,Verify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Verify.cs,VerifyCubicBezier,Cyclomatic complexity of the method is 8
Complex Method,MoreInternals.Compiler.Tasks,Verify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Verify.cs,VerifyColorStop,Cyclomatic complexity of the method is 8
Complex Method,MoreInternals.Helpers,Validation,C:\repos\kevin-montrose_More\MoreInternals\Helpers\Validation.cs,RemoveEscapes,Cyclomatic complexity of the method is 9
Complex Method,MoreInternals.Helpers,Validation,C:\repos\kevin-montrose_More\MoreInternals\Helpers\Validation.cs,IsIdentifier,Cyclomatic complexity of the method is 8
Complex Method,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToRGB,Cyclomatic complexity of the method is 16
Complex Method,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertColorPart,Cyclomatic complexity of the method is 8
Complex Method,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToHSL,Cyclomatic complexity of the method is 14
Complex Method,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Round,Cyclomatic complexity of the method is 9
Complex Method,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,FadeIn,Cyclomatic complexity of the method is 8
Complex Method,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,FadeOut,Cyclomatic complexity of the method is 8
Complex Method,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Mix,Cyclomatic complexity of the method is 14
Complex Method,MoreInternals.Model,Value,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,UnrollMath,Cyclomatic complexity of the method is 8
Complex Method,MoreInternals.Model,HSLColorValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,MoreInternals.Model,StringEvalMap,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Parse,Cyclomatic complexity of the method is 10
Complex Method,MoreInternals.Model,Selector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,ParseRawCompoundSelector,Cyclomatic complexity of the method is 19
Complex Method,MoreInternals.Model,Selector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,ApplyEscapeMap,Cyclomatic complexity of the method is 19
Complex Method,MoreInternals.Model,Selector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,ParseRawSelector,Cyclomatic complexity of the method is 9
Complex Method,MoreInternals.Model,PseudoClassSelector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,Parse,Cyclomatic complexity of the method is 9
Complex Method,MoreInternals.Model,SelectorAndBlock,C:\repos\kevin-montrose_More\MoreInternals\Model\Block.cs,BindAndEvaluateMixins,Cyclomatic complexity of the method is 31
Complex Method,MoreInternals.Model,SelectorAndBlock,C:\repos\kevin-montrose_More\MoreInternals\Model\Block.cs,CombineSelectors,Cyclomatic complexity of the method is 8
Complex Method,MoreInternals.Parser,CommentlessStream,C:\repos\kevin-montrose_More\MoreInternals\Parser\CommentlessStream.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,MoreInternals.Parser,MediaQueryParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MediaQueryParser.cs,ParseMediaClause,Cyclomatic complexity of the method is 10
Complex Method,MoreInternals.Parser,MediaQueryParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MediaQueryParser.cs,ParseQuery,Cyclomatic complexity of the method is 8
Complex Method,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,Cyclomatic complexity of the method is 48
Complex Method,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseFuncValue,Cyclomatic complexity of the method is 11
Complex Method,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParsePossibleUnit,Cyclomatic complexity of the method is 13
Complex Method,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseNumber,Cyclomatic complexity of the method is 10
Complex Method,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseImpl,Cyclomatic complexity of the method is 13
Complex Method,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseKeyFramesDirective,Cyclomatic complexity of the method is 9
Complex Method,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseResetDirective,Cyclomatic complexity of the method is 8
Complex Method,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseDirective,Cyclomatic complexity of the method is 12
Complex Method,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseApplicationParameters,Cyclomatic complexity of the method is 8
Complex Method,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseMixinOrVariableRule,Cyclomatic complexity of the method is 14
Complex Method,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseRule,Cyclomatic complexity of the method is 9
Long Parameter List,MoreInternals.Compiler,Compiler,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Compiler.cs,Compile,The method has 7 parameters. Parameters: currentDir' inputFile' outputFile' lookup' context' options' writerMode
Long Parameter List,MoreInternals.Compiler,SubSprite,C:\repos\kevin-montrose_More\MoreInternals\Compiler\SpriteExport.cs,SubSprite,The method has 5 parameters. Parameters: tl' w' h' name' file
Long Parameter List,MoreInternals.Compiler.Tasks,Minify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Minify.cs,MinifyBorderWidthShorthand,The method has 7 parameters. Parameters: props' into' topProp' rightProp' bottomProp' leftProp' default
Long Parameter List,MoreInternals.Model,NameValueProperty,C:\repos\kevin-montrose_More\MoreInternals\Model\Property.cs,NameValueProperty,The method has 5 parameters. Parameters: name' value' start' stop' filePath
Long Parameter List,MoreInternals.Model,MixinApplicationProperty,C:\repos\kevin-montrose_More\MoreInternals\Model\Property.cs,MixinApplicationProperty,The method has 7 parameters. Parameters: name' parameters' optional' overrides' start' stop' filePath
Long Parameter List,MoreInternals.Model,IncludeSelectorProperty,C:\repos\kevin-montrose_More\MoreInternals\Model\Property.cs,IncludeSelectorProperty,The method has 5 parameters. Parameters: selector' overrides' start' stop' file
Long Parameter List,MoreInternals.Model,VariableProperty,C:\repos\kevin-montrose_More\MoreInternals\Model\Property.cs,VariableProperty,The method has 5 parameters. Parameters: name' value' start' stop' file
Long Parameter List,MoreInternals.Model,InnerMediaProperty,C:\repos\kevin-montrose_More\MoreInternals\Model\Property.cs,InnerMediaProperty,The method has 5 parameters. Parameters: media' block' start' stop' file
Long Parameter List,MoreInternals.Model,Error,C:\repos\kevin-montrose_More\MoreInternals\Model\Error.cs,Create,The method has 5 parameters. Parameters: type' start' stop' msg' file
Long Parameter List,MoreInternals.Model,Value,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Parse,The method has 5 parameters. Parameters: rawValue' start' stop' filePath' allowSelectorIncludes
Long Parameter List,MoreInternals.Model,AttributeOperatorSelector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,AttributeOperatorSelector,The method has 6 parameters. Parameters: attr' op' value' start' stop' filePath
Long Parameter List,MoreInternals.Model,CompoundSelector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,CompoundSelector,The method has 5 parameters. Parameters: outer' inner' start' stop' filePath
Long Parameter List,MoreInternals.Model,CompoundSelector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,CombineSelectors,The method has 5 parameters. Parameters: outer' inner' start' stop' filePath
Long Parameter List,MoreInternals.Model,AdjacentSiblingSelector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,AdjacentSiblingSelector,The method has 5 parameters. Parameters: older' younger' start' stop' filePath
Long Parameter List,MoreInternals.Model,ChildSelector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,ChildSelector,The method has 5 parameters. Parameters: parent' child' start' stop' filePath
Long Parameter List,MoreInternals.Model,Import,C:\repos\kevin-montrose_More\MoreInternals\Model\Block.cs,Import,The method has 5 parameters. Parameters: import' forMedia' start' stop' file
Long Parameter List,MoreInternals.Model,SpriteRule,C:\repos\kevin-montrose_More\MoreInternals\Model\Block.cs,SpriteRule,The method has 5 parameters. Parameters: name' path' start' stop' file
Long Parameter List,MoreInternals.Model,SpriteBlock,C:\repos\kevin-montrose_More\MoreInternals\Model\Block.cs,SpriteBlock,The method has 5 parameters. Parameters: output' sprites' start' stop' filePath
Long Parameter List,MoreInternals.Model,MixinBlock,C:\repos\kevin-montrose_More\MoreInternals\Model\Block.cs,MixinBlock,The method has 6 parameters. Parameters: name' params' rules' start' stop' filePath
Long Parameter List,MoreInternals.Model,MoreVariable,C:\repos\kevin-montrose_More\MoreInternals\Model\Block.cs,MoreVariable,The method has 5 parameters. Parameters: varName' value' start' stop' filePath
Long Parameter List,MoreInternals.Model,Using,C:\repos\kevin-montrose_More\MoreInternals\Model\Block.cs,Using,The method has 5 parameters. Parameters: rawPath' media' start' stop' file
Long Parameter List,MoreInternals.Model,SelectorAndBlock,C:\repos\kevin-montrose_More\MoreInternals\Model\Block.cs,SelectorAndBlock,The method has 6 parameters. Parameters: selector' cssRules' resetContext' start' stop' filePath
Long Parameter List,MoreInternals.Model,SelectorAndBlock,C:\repos\kevin-montrose_More\MoreInternals\Model\Block.cs,BindParameter,The method has 5 parameters. Parameters: scope' mixinReferences' boundVariables' param' value
Long Parameter List,MoreInternals.Model,SelectorAndBlock,C:\repos\kevin-montrose_More\MoreInternals\Model\Block.cs,CombineSelectors,The method has 5 parameters. Parameters: s1' s2' start' stop' filePath
Long Parameter List,MoreInternals.Model,MediaBlock,C:\repos\kevin-montrose_More\MoreInternals\Model\Block.cs,MediaBlock,The method has 5 parameters. Parameters: media' statements' start' stop' file
Long Parameter List,MoreInternals.Model,KeyFrame,C:\repos\kevin-montrose_More\MoreInternals\Model\Block.cs,KeyFrame,The method has 5 parameters. Parameters: percents' rules' start' stop' file
Long Parameter List,MoreInternals.Model,KeyFramesBlock,C:\repos\kevin-montrose_More\MoreInternals\Model\Block.cs,KeyFramesBlock,The method has 7 parameters. Parameters: prefix' name' frames' vars' start' stop' file
Long Statement,MoreInternals.Compiler,NoOps,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\NoOps.cs,Task,The length of the statement  "                        return new KeyFramesBlock(keyframes.Prefix' keyframes.Name' frames' keyframes.Variables.ToList()' keyframes.Start' keyframes.Stop' keyframes.FilePath); " is 151.
Long Statement,MoreInternals.Compiler,SpriteExport,C:\repos\kevin-montrose_More\MoreInternals\Compiler\SpriteExport.cs,MixinEquivalents,The length of the statement  "                rules.Add(new NameValueProperty("background-image"' UrlValue.Parse("url(" + RelativePath(RelativeToFile' OutputFile) + ")"))); " is 126.
Long Statement,MoreInternals.Compiler,SpriteExport,C:\repos\kevin-montrose_More\MoreInternals\Compiler\SpriteExport.cs,MixinEquivalents,The length of the statement  "                rules.Add(new NameValueProperty("background-position"' new CompoundValue(new List<Value>() { new NumberWithUnitValue(sprite.TopLeft.X' Unit.PX)' new NumberWithUnitValue(sprite.TopLeft.Y' Unit.PX) }))); " is 201.
Long Statement,MoreInternals.Compiler,SpriteExport,C:\repos\kevin-montrose_More\MoreInternals\Compiler\SpriteExport.cs,MixinEquivalents,The length of the statement  "                rules.Add(new MixinApplicationProperty(mixinName' new List<MixinApplicationParameter>()' optional: true' overrides: false' start: -1' stop: -1' filePath: "artificial sprites mixin")); " is 183.
Long Statement,MoreInternals.Compiler,SpriteExport,C:\repos\kevin-montrose_More\MoreInternals\Compiler\SpriteExport.cs,MixinEquivalents,The length of the statement  "                ret.Add(new MixinBlock(sprite.Name' new List<MixinParameter>() { new MixinParameter(mixinName' ExcludeFromOutputValue.Singleton) }' rules' -1' -1' null)); " is 154.
Long Statement,MoreInternals.Compiler,SpriteExport,C:\repos\kevin-montrose_More\MoreInternals\Compiler\SpriteExport.cs,RelativePath,The length of the statement  "                Current.RecordError(ErrorType.Compiler' Position.NoSite' "Cannot find relative path between [" + relativeToFile + "] & [" + outputFile + "]"); " is 142.
Long Statement,MoreInternals.Compiler.Tasks,AutoPrefix,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\AutoPrefix.cs,IEOpacity,The length of the statement  "            if (!opacity.Name.Equals("opacity"' StringComparison.InvariantCultureIgnoreCase)) throw new InvalidOperationException("Prefix only valid on opacity property"); " is 159.
Long Statement,MoreInternals.Compiler.Tasks,AutoPrefix,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\AutoPrefix.cs,PrefixBox,The length of the statement  "            if(!display.Name.Equals("display"' StringComparison.InvariantCultureIgnoreCase)) throw new InvalidOperationException("Prefixer only valid on display property"); " is 160.
Long Statement,MoreInternals.Compiler.Tasks,AutoPrefix,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\AutoPrefix.cs,WebkitBorderRadius,The length of the statement  "            if (borderRadius.Name != "border-radius") throw new InvalidOperationException("Prefixer only valid for border-radius property"); " is 128.
Long Statement,MoreInternals.Compiler.Tasks,AutoPrefix,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\AutoPrefix.cs,PrefixBlock,The length of the statement  "                        Current.RecordInfo("Prefixed property " + dupe.Name + " in '" + block.Selector + "' could have been generated automatically"); " is 126.
Long Statement,MoreInternals.Compiler.Tasks,AutoPrefix,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\AutoPrefix.cs,Task,The length of the statement  "                    var prefixedKeyframe = new KeyFramesBlock(keyframesBlock.Prefix' keyframesBlock.Name' keyframeRet' keyframesBlock.Variables.ToList()' keyframesBlock.Start' keyframesBlock.Stop' keyframesBlock.FilePath); " is 202.
Long Statement,MoreInternals.Compiler.Tasks,AutoPrefix,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\AutoPrefix.cs,Task,The length of the statement  "                        if (!blocks.OfType<KeyFramesBlock>().Any(a => a.Prefix.Equals("-webkit-"' StringComparison.InvariantCultureIgnoreCase) && a.Name == prefixedKeyframe.Name)) " is 155.
Long Statement,MoreInternals.Compiler.Tasks,AutoPrefix,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\AutoPrefix.cs,Task,The length of the statement  "                            ret.Add(new KeyFramesBlock("-webkit-"' prefixedKeyframe.Name' prefixedKeyframe.Frames.ToList()' prefixedKeyframe.Variables.ToList()' prefixedKeyframe.Start' prefixedKeyframe.Stop' prefixedKeyframe.FilePath)); " is 208.
Long Statement,MoreInternals.Compiler.Tasks,AutoPrefix,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\AutoPrefix.cs,Task,The length of the statement  "                        if (!blocks.OfType<KeyFramesBlock>().Any(a => a.Prefix.Equals("-moz-"' StringComparison.InvariantCultureIgnoreCase) && a.Name == prefixedKeyframe.Name)) " is 152.
Long Statement,MoreInternals.Compiler.Tasks,AutoPrefix,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\AutoPrefix.cs,Task,The length of the statement  "                            ret.Add(new KeyFramesBlock("-moz-"' prefixedKeyframe.Name' prefixedKeyframe.Frames.ToList()' prefixedKeyframe.Variables.ToList()' prefixedKeyframe.Start' prefixedKeyframe.Stop' prefixedKeyframe.FilePath)); " is 205.
Long Statement,MoreInternals.Compiler.Tasks,AutoPrefix,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\AutoPrefix.cs,Task,The length of the statement  "                        if (!blocks.OfType<KeyFramesBlock>().Any(a => a.Prefix.Equals("-o-"' StringComparison.InvariantCultureIgnoreCase) && a.Name == prefixedKeyframe.Name)) " is 150.
Long Statement,MoreInternals.Compiler.Tasks,AutoPrefix,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\AutoPrefix.cs,Task,The length of the statement  "                            ret.Add(new KeyFramesBlock("-o-"' prefixedKeyframe.Name' prefixedKeyframe.Frames.ToList()' prefixedKeyframe.Variables.ToList()' prefixedKeyframe.Start' prefixedKeyframe.Stop' prefixedKeyframe.FilePath)); " is 203.
Long Statement,MoreInternals.Compiler.Tasks,CacheBreak,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\CacheBreak.cs,Task,The length of the statement  "                    ret.Add(new KeyFramesBlock(keyframesBlock.Prefix' keyframesBlock.Name' keyframeRet' keyframesBlock.Variables.ToList()' keyframesBlock.Start' keyframesBlock.Stop' keyframesBlock.FilePath)); " is 188.
Long Statement,MoreInternals.Compiler.Tasks,CacheBreak,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\CacheBreak.cs,Task,The length of the statement  "                    ret.Add(new Model.Import(CacheBreakValue(import.ToImport)' import.MediaQuery' import.Start' import.Stop' import.FilePath)); " is 123.
Long Statement,MoreInternals.Compiler.Tasks,Evaluate,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Evaluate.cs,Task,The length of the statement  "                    ret.Add(new SelectorAndBlock(block.Selector' processedRules' block.ResetContext' block.Start' block.Stop' block.FilePath)); " is 123.
Long Statement,MoreInternals.Compiler.Tasks,Evaluate,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Evaluate.cs,Task,The length of the statement  "                        var blockEquiv = new SelectorAndBlock(InvalidSelector.Singleton' frame.Properties' null' frame.Start' frame.Stop' frame.FilePath); " is 130.
Long Statement,MoreInternals.Compiler.Tasks,Evaluate,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Evaluate.cs,Task,The length of the statement  "                        frames.Add(new KeyFrame(frame.Percentages.ToList()' ((SelectorAndBlock)evald[0]).Properties.ToList()' frame.Start' frame.Stop' frame.FilePath)); " is 144.
Long Statement,MoreInternals.Compiler.Tasks,Evaluate,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Evaluate.cs,Task,The length of the statement  "                    ret.Add(new KeyFramesBlock(keyframes.Prefix' keyframes.Name' frames' keyframes.Variables.ToList()' keyframes.Start' keyframes.Stop' keyframes.FilePath)); " is 153.
Long Statement,MoreInternals.Compiler.Tasks,FontFace,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\FontFace.cs,Task,The length of the statement  "                var fontFamily = font.Properties.Cast<NameValueProperty>().FirstOrDefault(a => a.Name.Equals("font-family"' StringComparison.InvariantCultureIgnoreCase)); " is 154.
Long Statement,MoreInternals.Compiler.Tasks,FontFace,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\FontFace.cs,Task,The length of the statement  "                var src = font.Properties.Cast<NameValueProperty>().FirstOrDefault(a => a.Name.Equals("src"' StringComparison.InvariantCultureIgnoreCase)); " is 139.
Long Statement,MoreInternals.Compiler.Tasks,FontFace,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\FontFace.cs,Task,The length of the statement  "                fontRules.AddRange(block.Properties.Cast<NameValueProperty>().Where(w => w.Name.Equals("font"' StringComparison.InvariantCultureIgnoreCase) || w.Name.Equals("font-family"))); " is 174.
Long Statement,MoreInternals.Compiler.Tasks,FontFace,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\FontFace.cs,Task,The length of the statement  "                    fontRules.AddRange(block.Properties.Cast<NameValueProperty>().Where(w => w.Name.Equals("font"' StringComparison.InvariantCultureIgnoreCase) || w.Name.Equals("font-family"))); " is 174.
Long Statement,MoreInternals.Compiler.Tasks,FontFace,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\FontFace.cs,Task,The length of the statement  "                    fontRules.AddRange(frame.Properties.Cast<NameValueProperty>().Where(w => w.Name.Equals("font"' StringComparison.InvariantCultureIgnoreCase) || w.Name.Equals("font-family"))); " is 174.
Long Statement,MoreInternals.Compiler.Tasks,Important,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Important.cs,Task,The length of the statement  "                                Current.RecordWarning(ErrorType.Compiler' block' "More than one definition for [" + group.Key + "]' did you mean for one to be !important?"); " is 141.
Long Statement,MoreInternals.Compiler.Tasks,Important,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Important.cs,Task,The length of the statement  "                        var blockEquiv = new SelectorAndBlock(InvalidSelector.Singleton' frame.Properties' null' frame.Start' frame.Stop' frame.FilePath); " is 130.
Long Statement,MoreInternals.Compiler.Tasks,Important,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Important.cs,Task,The length of the statement  "                        frames.Add(new KeyFrame(frame.Percentages.ToList()' ((SelectorAndBlock)resolved[0]).Properties.ToList()' frame.Stop' frame.Stop' frame.FilePath)); " is 146.
Long Statement,MoreInternals.Compiler.Tasks,Important,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Important.cs,Task,The length of the statement  "                    ret.Add(new KeyFramesBlock(keyframes.Prefix' keyframes.Name' frames' keyframes.Variables.ToList()' keyframes.Start' keyframes.Stop' keyframes.FilePath)); " is 153.
Long Statement,MoreInternals.Compiler.Tasks,Important,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Important.cs,Task,The length of the statement  "                    var blockEquiv = new SelectorAndBlock(InvalidSelector.Singleton' fontface.Properties' null' fontface.Start' fontface.Stop' fontface.FilePath); " is 142.
Long Statement,MoreInternals.Compiler.Tasks,Includes,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Includes.cs,Impl,The length of the statement  "                        Current.RecordError(ErrorType.Compiler' block' "After resolving selector includes' the [" + e.Key + "] rule would be included as an override " + e.Count() + " times."); " is 168.
Long Statement,MoreInternals.Compiler.Tasks,Includes,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Includes.cs,Impl,The length of the statement  "                        var blockEquiv = new SelectorAndBlock(InvalidSelector.Singleton' frame.Properties' null' frame.Start' frame.Stop' frame.FilePath); " is 130.
Long Statement,MoreInternals.Compiler.Tasks,Includes,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Includes.cs,Impl,The length of the statement  "                        frames.Add(new KeyFrame(frame.Percentages.ToList()' ((SelectorAndBlock)copied[0]).Properties.ToList()' frame.Start' frame.Stop' frame.FilePath)); " is 145.
Long Statement,MoreInternals.Compiler.Tasks,Includes,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Includes.cs,Impl,The length of the statement  "                    ret.Add(new KeyFramesBlock(keyframes.Prefix' keyframes.Name' frames' keyframes.Variables.ToList()' keyframes.Start' keyframes.Stop' keyframes.FilePath)); " is 153.
Long Statement,MoreInternals.Compiler.Tasks,Includes,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Includes.cs,Impl,The length of the statement  "                    var blockEquiv = new SelectorAndBlock(InvalidSelector.Singleton' fontface.Properties' null' fontface.Start' fontface.Stop' fontface.FilePath); " is 142.
Long Statement,MoreInternals.Compiler.Tasks,Minify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Minify.cs,MinifyPropertyList,The length of the statement  "                    "animation-name"' "animation-duration"' "animation-timing-function"' "animation-delay"' "animation-iteration-count"' "animation-direction"' "animation-fill-mode" " is 161.
Long Statement,MoreInternals.Compiler.Tasks,Minify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Minify.cs,MinifyPropertyList,The length of the statement  "            if (!Current.DisableMultipleMinificationPasses && (ret.Count() != original.Count() || !ret.All(r => original.Contains(r)))) " is 123.
Long Statement,MoreInternals.Compiler.Tasks,Minify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Minify.cs,Task,The length of the statement  "            ret.AddRange(blocks.OfType<Model.Import>().Select(s => new Model.Import(MinifyValue(s.ToImport)' ForQuery(s.MediaQuery)' s.Start' s.Stop' s.FilePath))); " is 152.
Long Statement,MoreInternals.Compiler.Tasks,Minify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Minify.cs,Task,The length of the statement  "                        var blockEquiv = new SelectorAndBlock(InvalidSelector.Singleton' frame.Properties' null' frame.Start' frame.Stop' frame.FilePath); " is 130.
Long Statement,MoreInternals.Compiler.Tasks,Minify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Minify.cs,Task,The length of the statement  "                        frames.Add(new KeyFrame(frame.Percentages.ToList()' ((SelectorAndBlock)mind[0]).Properties.ToList()' frame.Start' frame.Stop' frame.FilePath)); " is 143.
Long Statement,MoreInternals.Compiler.Tasks,Minify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Minify.cs,Task,The length of the statement  "                    ret.Add(new KeyFramesBlock(keyframes.Prefix' keyframes.Name' frames' keyframes.Variables.ToList()' keyframes.Start' keyframes.Stop' keyframes.FilePath)); " is 153.
Long Statement,MoreInternals.Compiler.Tasks,Minify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Minify.cs,MinifyFontProperties,The length of the statement  "            ret.AddRange(props.Where(w => !w.Name.In("font-size"' "font-family"' "font-style"' "font-variant"' "font-weight"' "line-height"))); " is 131.
Long Statement,MoreInternals.Compiler.Tasks,Mixin,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Mixins.cs,Task,The length of the statement  "                    var blockEquivalent = new SelectorAndBlock(InvalidSelector.Singleton' frame.Properties' null' frame.Start' frame.Stop' frame.FilePath); " is 135.
Long Statement,MoreInternals.Compiler.Tasks,Mixin,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Mixins.cs,Task,The length of the statement  "                    frames.Add(new KeyFrame(frame.Percentages.ToList()' bound.Properties.ToList()' frame.Start' frame.Stop' frame.FilePath)); " is 121.
Long Statement,MoreInternals.Compiler.Tasks,Mixin,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Mixins.cs,Task,The length of the statement  "                ret.Add(new KeyFramesBlock(animation.Prefix' animation.Name' frames.ToList()' animation.Variables.ToList()' animation.Start' animation.Stop' animation.FilePath)); " is 162.
Long Statement,MoreInternals.Compiler.Tasks,Mixin,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Mixins.cs,Task,The length of the statement  "                var blockEquiv = new SelectorAndBlock(InvalidSelector.Singleton' font.Properties' null' font.Start' font.Stop' font.FilePath); " is 126.
Long Statement,MoreInternals.Compiler.Tasks,Parse,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Parse.cs,CheckPostImport,The length of the statement  "                            Current.RecordWarning(ErrorType.Parser' ret[i]' "@import should appear before any other statements.  Statement will be moved."); " is 128.
Long Statement,MoreInternals.Compiler.Tasks,ResetIncludes,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\ResetIncludes.cs,Task,The length of the statement  "                            if (props.Any(a => a is NameValueProperty && ((NameValueProperty)a).Name.Equals(p.Name' StringComparison.InvariantCultureIgnoreCase))) continue; " is 144.
Long Statement,MoreInternals.Compiler.Tasks,Using,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Using.cs,EvaluateUsingsImpl,The length of the statement  "                if (loaded.Item1 == null || (loaded.Item1.MediaQuery is MediaType && ((MediaType)loaded.Item1.MediaQuery).Type == Model.Media.all)) continue; " is 141.
Long Statement,MoreInternals.Compiler.Tasks,Using,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Using.cs,EvaluateUsingsImpl,The length of the statement  "            foreach (var loaded in imports.Where(w => w.Item1 == null || (w.Item1.MediaQuery is MediaType && ((MediaType)w.Item1.MediaQuery).Type == Model.Media.all))) " is 155.
Long Statement,MoreInternals.Compiler.Tasks,Using,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Using.cs,EvaluateUsingsImpl,The length of the statement  "            foreach (var loaded in imports.Where(w => w.Item1 != null && !(w.Item1.MediaQuery is MediaType && ((MediaType)w.Item1.MediaQuery).Type == Model.Media.all))) " is 156.
Long Statement,MoreInternals.Compiler.Tasks,Using,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Using.cs,EvaluateUsingsImpl,The length of the statement  "                ret.Add(new MediaBlock(loaded.Item1.MediaQuery' inner.ToList()' loaded.Item1.Start' loaded.Item1.Stop' loaded.Item1.FilePath)); " is 127.
Long Statement,MoreInternals.Compiler.Tasks,Verify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Verify.cs,VerifyTypes,The length of the statement  "                        Current.RecordError(ErrorType.Compiler' min' "'" + min.Feature + "' cannot have a minimum constraint in a media query."); " is 121.
Long Statement,MoreInternals.Compiler.Tasks,Verify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Verify.cs,VerifyTypes,The length of the statement  "                            Current.RecordError(ErrorType.Compiler' min' "'" + min.Min + "' is not a valid parameter for media query feature '" + min.Feature + "'."); " is 138.
Long Statement,MoreInternals.Compiler.Tasks,Verify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Verify.cs,VerifyTypes,The length of the statement  "                        Current.RecordError(ErrorType.Compiler' max' "'" + max.Feature + "' cannot have a minimum constraint in a media query."); " is 121.
Long Statement,MoreInternals.Compiler.Tasks,Verify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Verify.cs,VerifyTypes,The length of the statement  "                            Current.RecordError(ErrorType.Compiler' max' "'" + max.Max + "' is not a valid parameter for media query feature '" + max.Feature + "'."); " is 138.
Long Statement,MoreInternals.Compiler.Tasks,Verify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Verify.cs,VerifyTypes,The length of the statement  "                        Current.RecordError(ErrorType.Compiler' eq' "'" + eq.EqualsValue + "' is not a valid parameter for media query feature '" + eq.Feature + "'."); " is 143.
Long Statement,MoreInternals.Compiler.Tasks,Verify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Verify.cs,VerifyPossible,The length of the statement  "                    Current.RecordError(ErrorType.Compiler' on' "'" + h.Feature + "' is never set for media type '" + type.Type + "'' making this query unsatisfiable"); " is 148.
Long Statement,MoreInternals.Compiler.Tasks,Verify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Verify.cs,VerifyPossible,The length of the statement  "                    Current.RecordError(ErrorType.Compiler' on' "'" + min.Feature + "' is impossibly constrained' [" + min.Min + " < " + pairedMax.Max + "] is impossible"); " is 152.
Long Statement,MoreInternals.Compiler.Tasks,Verify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Verify.cs,VerifyColorStop,The length of the statement  "                    Current.RecordError(ErrorType.Compiler' value' "color-stops should be composed of two values' one color and one length or percentage"); " is 135.
Long Statement,MoreInternals.Compiler.Tasks,Verify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Verify.cs,VerifyColorStop,The length of the statement  "                        Current.RecordError(ErrorType.Compiler' value' "a color-stop's second value' if a percentage' should be between 0% and 100%"); " is 126.
Long Statement,MoreInternals.Compiler.Tasks,Verify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Verify.cs,VerifyColorStop,The length of the statement  "                    if (!second.Unit.In(Unit.EM' Unit.EX' Unit.CH' Unit.REM' Unit.VH' Unit.VW' Unit.VM' Unit.PX' Unit.MM' Unit.CM' Unit.IN' Unit.PT' Unit.PC)) " is 138.
Long Statement,MoreInternals.Compiler.Tasks,Verify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Verify.cs,VerifyLinearGradient,The length of the statement  "                            var parts = asString.Substring(3).Trim().Split(new[] { ' ' }' StringSplitOptions.RemoveEmptyEntries).Distinct().ToList(); " is 121.
Long Statement,MoreInternals.Compiler.Tasks,Verify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Verify.cs,VerifyLinearGradient,The length of the statement  "                                Current.RecordError(ErrorType.Compiler' first' "linear-gradient's first parameter' if an angle shorthand' must be of the form 'to [left | right] || [top | bottom]'"); " is 166.
Long Statement,MoreInternals.Compiler.Tasks,Verify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Verify.cs,VerifyLinearGradient,The length of the statement  "                                Current.RecordError(ErrorType.Compiler' first' "linear-gradient's first parameter' if an angle shorthand' must be of the form 'to [left | right] || [top | bottom]'"); " is 166.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToRGB,The length of the statement  "                if (!(ConvertColorPart(rgb.Red' position' out r) & ConvertColorPart(rgb.Green' position' out g) & ConvertColorPart(rgb.Blue' position' out b))) " is 143.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToRGB,The length of the statement  "                if (!(ConvertColorPart(rgba.Red' position' out r) & ConvertColorPart(rgba.Green' position' out g) & ConvertColorPart(rgba.Blue' position' out b))) " is 146.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToHSL,The length of the statement  "                if (!(ConvertColorPart(rgb.Red' position' out r) & ConvertColorPart(rgb.Green' position' out g) & ConvertColorPart(rgb.Blue' position' out b))) " is 143.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToHSL,The length of the statement  "                if (!(ConvertColorPart(rgba.Red' position' out r) & ConvertColorPart(rgba.Green' position' out g) & ConvertColorPart(rgba.Blue' position' out b))) " is 146.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Round,The length of the statement  "            if (parameters.Any(a => a is NotFoundValue)) return NotFoundValue.Default.BindToPosition(position.Start' position.Stop' position.FilePath); " is 139.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Round,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "Round expects a number' with optional unit' as its first parameter; found [" + toRound + "]"); " is 145.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Round,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "Round expects a number' without a unit' as its second parameter; found [" + precision + "]"); " is 144.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Round,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "Round expects an integer as its second parameter' found [" + nPrecision + "]"); " is 130.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Gray,The length of the statement  "            if (param is NotFoundValue) return NotFoundValue.Default.BindToPosition(position.Start' position.Start' position.FilePath); " is 123.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Lighten,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "Lighten expects a color as its first parameter' found [" + color + "]"); " is 123.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Lighten,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "Lighten expects a percentage as its second parameter' found [" + percent + "]"); " is 131.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Lighten,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "Lighten expects a percentage as its second parameter' found [" + percent + "]"); " is 131.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Darken,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "Darken expects a color as its first parameter' found [" + color + "]"); " is 122.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Darken,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "Darken expects a percentage as its second parameter' found [" + percent + "]"); " is 130.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Darken,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "Darken expects a percentage as its second parameter' found [" + percent + "]"); " is 130.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Saturate,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "Saturate expects a color as its first parameter' found [" + color + "]"); " is 124.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Saturate,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "Saturate expects a percentage as its second parameter' found [" + percent + "]"); " is 132.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Saturate,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "Saturate expects a percentage as its second parameter' found [" + percent + "]"); " is 132.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Desaturate,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "Desaturate expects a color as its first parameter' found [" + color + "]"); " is 126.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Desaturate,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "Desaturate expects a percentage as its second parameter' found [" + percent + "]"); " is 134.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Desaturate,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "Desaturate expects a percentage as its second parameter' found [" + percent + "]"); " is 134.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,FadeIn,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "FadeIn expects a color as its first parameter' found [" + color + "]"); " is 122.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,FadeIn,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "FadeIn expects a percentage as its second parameter' found [" + percent + "]"); " is 130.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,FadeIn,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "FadeIn expects a percentage as its second parameter' found [" + percent + "]"); " is 130.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,FadeIn,The length of the statement  "            return new RGBAColorValue(new NumberValue(parts.Item1)' new NumberValue(parts.Item2)' new NumberValue(parts.Item3)' new NumberValue(newAlpha)); " is 143.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,FadeOut,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "FadeOut expects a color as its first parameter' found [" + color + "]"); " is 123.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,FadeOut,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "FadeOut expects a percentage as its second parameter' found [" + percent + "]"); " is 131.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,FadeOut,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "FadeOut expects a percentage as its second parameter' found [" + percent + "]"); " is 131.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,FadeOut,The length of the statement  "            return new RGBAColorValue(new NumberValue(parts.Item1)' new NumberValue(parts.Item2)' new NumberValue(parts.Item3)' new NumberValue(newAlpha)); " is 143.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Fade,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "Fade expects a color as its first parameter' found [" + color + "]"); " is 120.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Fade,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "Fade expects a percentage as its second parameter' found [" + percent + "]"); " is 128.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Fade,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "Fade expects a percentage as its second parameter' found [" + percent + "]"); " is 128.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Fade,The length of the statement  "            return new RGBAColorValue(new NumberValue(parts.Item1)' new NumberValue(parts.Item2)' new NumberValue(parts.Item3)' new NumberValue(newAlpha)); " is 143.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Spin,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "Spin expects a color as its first parameter' found [" + color + "]"); " is 120.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Spin,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "Spin expects a unit-less number as its second parameter' found [" + number + "]"); " is 133.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Spin,The length of the statement  "                return new RGBAColorValue(new NumberValue(rgbParts.Item1)' new NumberValue(rgbParts.Item2)' new NumberValue(rgbParts.Item3)' ((RGBAColorValue)colorV).Alpha); " is 157.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Mix,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "Mix expects its second parameter to be a color' found [" + c2 + "]"); " is 120.
Long Statement,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Mix,The length of the statement  "                Current.RecordError(ErrorType.Compiler' position' "Mix expects its third parameter to be a number or percentage' found [" + p + "]"); " is 133.
Long Statement,MoreInternals.Model,Value,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,TryConvertBetweenUnits,The length of the statement  "            if (!ConvertableSizeUnits.TryGetValue(fromUnit' out fromRatio) || !ConvertableSizeUnits.TryGetValue(toUnit' out toRatio)) " is 121.
Long Statement,MoreInternals.Model,Value,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,TryConvertBetweenUnits,The length of the statement  "                if (!ConvertableTimeUnits.TryGetValue(fromUnit' out fromRatio) || !ConvertableTimeUnits.TryGetValue(toUnit' out toRatio)) " is 121.
Long Statement,MoreInternals.Model,Value,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,TryConvertBetweenUnits,The length of the statement  "                    if (!ConvertableResolutionUnits.TryGetValue(fromUnit' out fromRatio) || !ConvertableResolutionUnits.TryGetValue(toUnit' out toRatio)) " is 133.
Long Statement,MoreInternals.Model,Value,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,TryConvertBetweenUnits,The length of the statement  "                        if (!ConvertableAngleUnits.TryGetValue(fromUnit' out fromRatio) || !ConvertableAngleUnits.TryGetValue(toUnit' out toRatio)) " is 123.
Long Statement,MoreInternals.Model,Value,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,TryConvertBetweenUnits,The length of the statement  "                            if (!ConvertableFrequencyUnits.TryGetValue(fromUnit' out fromRatio) || !ConvertableFrequencyUnits.TryGetValue(toUnit' out toRatio)) " is 131.
Long Statement,MoreInternals.Model,HexTripleColorValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Parse,The length of the statement  "            return new HexTripleColorValue(byte.Parse(r' NumberStyles.HexNumber)' byte.Parse(g' NumberStyles.HexNumber)' byte.Parse(b' NumberStyles.HexNumber)); " is 148.
Long Statement,MoreInternals.Model,HexSextupleColorValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Parse,The length of the statement  "            return new HexSextupleColorValue(byte.Parse(r' NumberStyles.HexNumber)' byte.Parse(g' NumberStyles.HexNumber)' byte.Parse(b' NumberStyles.HexNumber)); " is 150.
Long Statement,MoreInternals.Model,HSLColorValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Write,The length of the statement  "            if (sat == null || sat.Unit != Unit.Percent) throw new InvalidOperationException("satuartion must be a percentage' found [" + Saturation + "]"); " is 144.
Long Statement,MoreInternals.Model,HSLColorValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Write,The length of the statement  "            if (lit == null || lit.Unit != Unit.Percent) throw new InvalidOperationException("lightness must be a percentage' found [" + Lightness + "]"); " is 142.
Long Statement,MoreInternals.Model,CommaDelimittedValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Evaluate,The length of the statement  "            return new CommaDelimittedValue(Values.Select(s => s.Evaluate()).Where(s => s != ExcludeFromOutputValue.Singleton).ToList()); " is 125.
Long Statement,MoreInternals.Model,Scope,C:\repos\kevin-montrose_More\MoreInternals\Model\Scope.cs,Push,The length of the statement  "                Current.RecordError(ErrorType.Compiler' parent.InvocationSite' "Scope max depth exceeded' probably infinite recursion"); " is 120.
Long Statement,MoreInternals.Model,Selector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,ParseRawCompoundSelector,The length of the statement  "                return new ConcatWithParentSelector(ParseRawCompoundSelector(raw.Substring(1)' start' stop' filePath)' start' stop' filePath); " is 126.
Long Statement,MoreInternals.Model,Selector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,ParseRawCompoundSelector,The length of the statement  "                        Current.RecordError(ErrorType.Parser' Position.Create(start' stop' filePath)' "[" + id + "] is not a valid identifier"); " is 120.
Long Statement,MoreInternals.Model,Selector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,ParseRawCompoundSelector,The length of the statement  "                        Current.RecordWarning(ErrorType.Parser' pseudo' pseudo.Name + " was used as a class' but is an element.  Use :: instead."); " is 123.
Long Statement,MoreInternals.Model,Selector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,ParseRawCompoundSelector,The length of the statement  "                            Current.RecordWarning(ErrorType.Parser' pseudo' pseudo.Name + " was used as an element' but is a class.  Use : instead."); " is 122.
Long Statement,MoreInternals.Model,Selector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,ParseRawCompoundSelector,The length of the statement  "                    Current.RecordError(ErrorType.Parser' Position.Create(start' stop' filePath)' "[" + name + "] is not a valid identifier"); " is 122.
Long Statement,MoreInternals.Model,Selector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,ParseRawChildSelector,The length of the statement  "            return new ChildSelector(left' ParseRawChildSelector(parts.Skip(1).ToArray()' start' stop' filePath)' start' stop' filePath); " is 125.
Long Statement,MoreInternals.Model,Selector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,ParseRawSiblingSelector,The length of the statement  "                Current.RecordError(ErrorType.Parser' Position.Create(start' stop' filePath)' "Sibling selectors can only have 2 components"); " is 126.
Long Statement,MoreInternals.Model,Selector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,ParseRawSelector,The length of the statement  "            if (raw.Contains(''')) return ApplyEscapeMap(ParseRawCommaDelimittedSelector(raw.Split(''')' start' stop' filePath)' escapeMap); " is 128.
Long Statement,MoreInternals.Model,Selector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,ParseRawSelector,The length of the statement  "            if (raw.Contains('+')) return ApplyEscapeMap(ParseRawSiblingSelector(raw.Split('+')' start' stop' filePath)' escapeMap); " is 120.
Long Statement,MoreInternals.Model,AttributeSelector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,Parse,The length of the statement  "                    Current.RecordError(ErrorType.Parser' Position.Create(start' stop' filePath)' "[" + contains + "] is not an identifier or string"); " is 131.
Long Statement,MoreInternals.Model,AttributeSelector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,Parse,The length of the statement  "                return new AttributeOperatorSelector(contains' AttributeOperator.Contains' raw.Substring(i - 1 + 2)' start' stop' filePath); " is 124.
Long Statement,MoreInternals.Model,AttributeSelector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,Parse,The length of the statement  "                    Current.RecordError(ErrorType.Parser' Position.Create(start' stop' filePath)' "[" + starts + "] is not an identifier or string"); " is 129.
Long Statement,MoreInternals.Model,AttributeSelector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,Parse,The length of the statement  "                return new AttributeOperatorSelector(starts' AttributeOperator.Starts' raw.Substring(i - 1 + 2)' start' stop' filePath); " is 120.
Long Statement,MoreInternals.Model,AttributeSelector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,Parse,The length of the statement  "                Current.RecordError(ErrorType.Parser' Position.Create(start' stop' filePath)' "[" + equals + "] is not an identifier or string"); " is 129.
Long Statement,MoreInternals.Model,CompoundSelector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,CombineSelectors,The length of the statement  "            if (outer is MultiSelector) throw new InvalidOperationException("Cannot combine MultiSelectors' outer was a MultiSelector"); " is 124.
Long Statement,MoreInternals.Model,CompoundSelector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,CombineSelectors,The length of the statement  "            if (inner is MultiSelector) throw new InvalidOperationException("Cannot combine MultiSelectors' inner was a MultiSelector"); " is 124.
Long Statement,MoreInternals.Model,CompoundSelector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,CombineSelectors,The length of the statement  "                return new ConcatWithParentSelector(new CompoundSelector(outerConcat.Selector' inner' start' stop' filePath)' start' stop' filePath); " is 133.
Long Statement,MoreInternals.Model,CompoundSelector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,CombineSelectors,The length of the statement  "            return new ConcatWithParentSelector(new ConcatSelector(new List<Selector>() { outerConcat.Selector' innerConcat.Selector }' start' stop' filePath)' start' stop' filePath); " is 171.
Long Statement,MoreInternals.Model,PseudoClassSelector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,Parse,The length of the statement  "            if (name.StartsWith("not(")) return new NotPseudoClassSelector(Selector.Parse(inner' start' stop' filePath)' start' stop' filePath); " is 132.
Long Statement,MoreInternals.Model,PseudoClassSelector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,Parse,The length of the statement  "            if (name.StartsWith("nth-last-child(")) return new NthLastChildPseudoClassSelector(NthParameter.Parse(inner)' start' stop' filePath); " is 133.
Long Statement,MoreInternals.Model,PseudoClassSelector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,Parse,The length of the statement  "            if (name.StartsWith("nth-of-type(")) return new NthOfTypePseudoClassSelector(NthParameter.Parse(inner)' start' stop' filePath); " is 127.
Long Statement,MoreInternals.Model,PseudoClassSelector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,Parse,The length of the statement  "            if (name.StartsWith("nth-last-of-type(")) return new NthLastOfTypePseudoClassSelector(NthParameter.Parse(inner)' start' stop' filePath); " is 136.
Long Statement,MoreInternals.Model,PseudoClassSelector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,Parse,The length of the statement  "            if (name.StartsWith("nth-child(")) return new NthChildPsuedoClassSelector(NthParameter.Parse(inner)' start' stop' filePath); " is 124.
Long Statement,MoreInternals.Model,SelectorAndBlock,C:\repos\kevin-montrose_More\MoreInternals\Model\Block.cs,BindAndEvaluateMixins,The length of the statement  "                Current.RecordError(ErrorType.Compiler' invokationChain.Last.Value' "Scope max depth exceeded' probably infinite recursion"); " is 125.
Long Statement,MoreInternals.Model,SelectorAndBlock,C:\repos\kevin-montrose_More\MoreInternals\Model\Block.cs,BindAndEvaluateMixins,The length of the statement  "                retRules.Add(new NameValueProperty(nameValue.Name' nameValue.Value.Bind(scope)' nameValue.Start' nameValue.Stop' nameValue.FilePath)); " is 134.
Long Statement,MoreInternals.Model,SelectorAndBlock,C:\repos\kevin-montrose_More\MoreInternals\Model\Block.cs,BindAndEvaluateMixins,The length of the statement  "                        Current.RecordError(ErrorType.Compiler' rule' "Argument to mixin [" + rule.Name + "] passed with name [" + byName.Name + "] but no parameter with that name exists."); " is 166.
Long Statement,MoreInternals.Model,SelectorAndBlock,C:\repos\kevin-montrose_More\MoreInternals\Model\Block.cs,BindAndEvaluateMixins,The length of the statement  "                        Current.RecordError(ErrorType.Compiler' rule' "Argument [" + byName.Name + "] passed by name' but already passed earlier in mixin declaration"); " is 144.
Long Statement,MoreInternals.Model,SelectorAndBlock,C:\repos\kevin-montrose_More\MoreInternals\Model\Block.cs,BindAndEvaluateMixins,The length of the statement  "                    Current.RecordError(ErrorType.Compiler' rule' "Tried to invoke mixin [" + rule.Name + "] with " + passedCount + " parameters' when a minimum of " + minimum + " are needed."); " is 174.
Long Statement,MoreInternals.Model,SelectorAndBlock,C:\repos\kevin-montrose_More\MoreInternals\Model\Block.cs,BindAndEvaluateMixins,The length of the statement  "                    Current.RecordError(ErrorType.Compiler' rule' "Tried to invoke mixin [" + rule.Name + "] with " + passedCount + " parameters' when a maximum of " + maximum + " are allowed."); " is 175.
Long Statement,MoreInternals.Model,SelectorAndBlock,C:\repos\kevin-montrose_More\MoreInternals\Model\Block.cs,BindAndEvaluateMixins,The length of the statement  "                foreach (var withDefault in mixin.Parameters.Where(w => !(w.DefaultValue is NotFoundValue) && !alreadyDefined.Contains(w.Name))) " is 128.
Long Statement,MoreInternals.Model,SelectorAndBlock,C:\repos\kevin-montrose_More\MoreInternals\Model\Block.cs,BindAndEvaluateMixins,The length of the statement  "                    retRules.RemoveAll(r => r is NameValueProperty && newRules.OfType<NameValueProperty>().Any(a => a.Name == ((NameValueProperty)r).Name)); " is 136.
Long Statement,MoreInternals.Model,SelectorAndBlock,C:\repos\kevin-montrose_More\MoreInternals\Model\Block.cs,BindAndEvaluateMixins,The length of the statement  "                retRules.Add(new InnerMediaProperty(media.MediaQuery' media.Block.BindAndEvaluateMixins(scope)' media.Start' media.Stop' media.FilePath)); " is 138.
Long Statement,MoreInternals.Model,SelectorAndBlock,C:\repos\kevin-montrose_More\MoreInternals\Model\Block.cs,UnrollNestedBlocks,The length of the statement  "            var theseRules = Properties.Where(r => r is NameValueProperty || r is IncludeSelectorProperty || r is ResetSelfProperty || r is ResetProperty || r is InnerMediaProperty); " is 170.
Long Statement,MoreInternals.Model,SelectorAndBlock,C:\repos\kevin-montrose_More\MoreInternals\Model\Block.cs,UnrollNestedBlocks,The length of the statement  "                        foreach (var perm in CombineSelectors(this.Selector' e.Selector' this.Selector.Start' this.Selector.Stop' this.Selector.FilePath)) " is 130.
Long Statement,MoreInternals.Parser,MediaQueryParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MediaQueryParser.cs,ParseMediaClause,The length of the statement  "                Current.RecordError(ErrorType.Parser' forPosition' "Media features must be enclosed in paranthesis' found '" + media + "'"); " is 124.
Long Statement,MoreInternals.Parser,MediaQueryParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MediaQueryParser.cs,ParseMediaClause,The length of the statement  "                    Current.RecordError(ErrorType.Parser' forPosition' "Media feature not recognized in min clause' found '" + feature + "'"); " is 122.
Long Statement,MoreInternals.Parser,MediaQueryParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MediaQueryParser.cs,ParseMediaClause,The length of the statement  "                    Current.RecordError(ErrorType.Parser' forPosition' "Media feature not recognized in max clause' found '" + feature + "'"); " is 122.
Long Statement,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The length of the statement  "                    if (toDate.Equals("rgb"' StringComparison.InvariantCultureIgnoreCase) || toDate.Equals("hsl"' StringComparison.InvariantCultureIgnoreCase)) " is 139.
Long Statement,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The length of the statement  "                                Current.RecordError(ErrorType.Parser' forPosition' "attr expects an attribute name and optionally a type' found " + compound); " is 126.
Long Statement,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The length of the statement  "                            Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to local() value' found " + comma.Values.Count()); " is 123.
Long Statement,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The length of the statement  "                            Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to steps() value' found " + comma.Values.Count()); " is 132.
Long Statement,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The length of the statement  "                            Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to format() value' found " + comma.Values.Count()); " is 124.
Long Statement,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The length of the statement  "                            Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counter() value' found " + comma.Values.Count()); " is 134.
Long Statement,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The length of the statement  "                            Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counters() value' found " + comma.Values.Count()); " is 135.
Long Statement,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseHashColor,The length of the statement  "            while (buffer.Length < 6 && stream.HasMore() && char.ToLower(stream.Peek()).In('a'' 'b'' 'c'' 'd'' 'e'' 'f'' '1'' '2'' '3'' '4'' '5'' '6'' '7'' '8'' '9'' '0')) " is 159.
Long Statement,MoreInternals.Parser,ParserStream,C:\repos\kevin-montrose_More\MoreInternals\Parser\ParserStream.cs,ScanUntilWithNesting,The length of the statement  "                Current.RecordError(Model.ErrorType.Parser' Model.Position.Create(start' Position' Current.CurrentFilePath)' "Expected '" + needle + "'"); " is 138.
Long Statement,MoreInternals.Parser,ParserStream,C:\repos\kevin-montrose_More\MoreInternals\Parser\ParserStream.cs,AdvancePast,The length of the statement  "                Current.RecordError(Model.ErrorType.Parser' Model.Position.Create(start' Position' Current.CurrentFilePath)' "Expected '" + needle + "'"); " is 138.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseInnerMediaDirective,The length of the statement  "                Current.RecordError(ErrorType.Parser' Position.Create(start' stream.Position' Current.CurrentFilePath)' "Expected media list"); " is 127.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseInnerMediaDirective,The length of the statement  "            var blockEquiv = new SelectorAndBlock(InvalidSelector.Singleton' props' null' start' stream.Position' Current.CurrentFilePath); " is 127.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseMediaDirective,The length of the statement  "                Current.RecordError(ErrorType.Parser' Position.Create(start' stream.Position' Current.CurrentFilePath)' "Expected media list"); " is 127.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseCharsetDirective,The length of the statement  "                Current.RecordError(ErrorType.Parser' Model.Position.Create(start' stream.Position' Current.CurrentFilePath)' "Expected quotation mark"); " is 137.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseCharsetDirective,The length of the statement  "                Current.RecordWarning(ErrorType.Parser' Model.Position.Create(start' stream.Position' Current.CurrentFilePath)' "Unrecognized charset"); " is 136.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseUsingDirective,The length of the statement  "                Current.RecordError(ErrorType.Parser' Position.Create(start' stream.Position' Current.CurrentFilePath)' "Expected quotation mark"); " is 131.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseImportDirective,The length of the statement  "                    Current.RecordError(ErrorType.Parser' Position.Create(start' stream.Position' Current.CurrentFilePath)' "Expected ')'"); ; " is 122.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseImportDirective,The length of the statement  "                    Current.RecordError(ErrorType.Parser' Position.Create(start' stream.Position' Current.CurrentFilePath)' "Expected quote"); " is 122.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseImportDirective,The length of the statement  "                    Current.RecordError(ErrorType.Parser' Position.Create(start' stream.Position' Current.CurrentFilePath)' "Expected '" + toParse[0] + "'"); " is 137.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseSpriteRule,The length of the statement  "                Current.RecordError(ErrorType.Parser' Position.Create(start' stream.Position' Current.CurrentFilePath)' "Expected '@'"); " is 120.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseSpriteRule,The length of the statement  "                Current.RecordError(ErrorType.Parser' Position.Create(start' stream.Position' Current.CurrentFilePath)' "Expected quotation mark"); " is 131.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseSpriteDeclaration,The length of the statement  "                Current.RecordError(ErrorType.Parser' Position.Create(start' stream.Position' Current.CurrentFilePath)' "Expected quotation mark"); " is 131.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseSpriteDeclaration,The length of the statement  "                Current.RecordError(ErrorType.Parser' Position.Create(start' stream.Position' Current.CurrentFilePath)' "Expected quotation mark"); " is 131.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseSpriteDeclaration,The length of the statement  "            return new SpriteBlock((QuotedStringValue)Value.Parse(name.ToString()' nameStart' nameStop' Current.CurrentFilePath)' rules' start' stream.Position' Current.CurrentFilePath); " is 174.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseMixinDeclarationParameter,The length of the statement  "                    Current.RecordError(ErrorType.Parser' Position.Create(start' start + offset' Current.CurrentFilePath)' "Unable to parse value"); " is 128.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseMixinDeclarationParameter,The length of the statement  "                    Current.RecordError(ErrorType.Parser' Position.Create(start' stop' Current.CurrentFilePath)' "'" + name + "' cannot be the name of a parameter to a mixin."); " is 157.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseMixinDeclaration,The length of the statement  "                Current.RecordError(ErrorType.Parser' Position.Create(start' stream.Position' Current.CurrentFilePath)' "Expected mixin name"); " is 127.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseMixinDeclaration,The length of the statement  "                Current.RecordError(ErrorType.Parser' Position.Create(start' stream.Position' Current.CurrentFilePath)' "'" + name + "' cannot be the name of a mixin."); " is 153.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseMoreVariable,The length of the statement  "            var value = Value.Parse(valueStr.ToString().Trim()' valueStart' stream.Position' Current.CurrentFilePath' allowSelectorIncludes: true); " is 135.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseMoreVariable,The length of the statement  "                Current.RecordError(ErrorType.Parser' Position.Create(start' stream.Position' Current.CurrentFilePath)' "'" + name + "' cannot be a variable name."); " is 149.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseKeyFrame,The length of the statement  "                    Current.RecordError(ErrorType.Parser' Position.Create(start' stream.Position' Current.CurrentFilePath)' "Expected `from`' `to`' or a percentage"); " is 146.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseKeyFrame,The length of the statement  "                            Current.RecordError(ErrorType.Parser' Position.Create(start' stream.Position' Current.CurrentFilePath)' "Expected `from`' `to`' or a percentage.  Found `" + p + "`"); " is 166.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseKeyFramesDirective,The length of the statement  "                Current.RecordError(ErrorType.Parser' Position.Create(start' stream.Position' Current.CurrentFilePath)' "Expected a name for the keyframe animation"); " is 150.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseKeyFramesDirective,The length of the statement  "                Current.RecordError(ErrorType.Parser' Position.Create(start' stream.Position' Current.CurrentFilePath)' "Animation name `"+name+"` is not a valid identifier"); " is 159.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseKeyFramesDirective,The length of the statement  "                Current.RecordError(ErrorType.Parser' Position.Create(start' stream.Position' Current.CurrentFilePath)' "Expected '}'"); " is 120.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseDirective,The length of the statement  "            var next = stream.WhichNextInsensitive(buffer' @using' sprite' import' charset' media' keyframes' mozKeyframes' webKeyframes' fontFace' reset); " is 143.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseMixinParameter,The length of the statement  "                return new MixinApplicationParameter(null' Value.Parse(piece' start' stop' Current.CurrentFilePath' allowSelectorIncludes: true)); " is 130.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseMixinParameter,The length of the statement  "                return new MixinApplicationParameter(null' Value.Parse(piece' start' stop' Current.CurrentFilePath' allowSelectorIncludes: true)); " is 130.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseMixinParameter,The length of the statement  "            return new MixinApplicationParameter(name.Trim()' Value.Parse(value.Trim()' start' stop' Current.CurrentFilePath' allowSelectorIncludes: true)); " is 144.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseApplicationParameters,The length of the statement  "                        Current.RecordError(ErrorType.Parser' Position.Create(start' start + i' Current.CurrentFilePath)' "Expected '" + advanceTo + "'"); " is 130.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseMixinOrVariableRule,The length of the statement  "                    Current.RecordError(ErrorType.Parser' Position.Create(start' stream.Position' Current.CurrentFilePath)' "Unexpected character '" + c + "'"); " is 140.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseMixinOrVariableRule,The length of the statement  "                Current.RecordError(ErrorType.Parser' Position.Create(start' stream.Position' Current.CurrentFilePath)' "Expected '(' or '='"); " is 127.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseMixinOrVariableRule,The length of the statement  "                    Current.RecordError(ErrorType.Parser' Position.Create(start' stream.Position' Current.CurrentFilePath)' "'" + varName + "' cannot be a variable name."); " is 152.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseMixinOrVariableRule,The length of the statement  "                    Current.RecordError(ErrorType.Parser' Position.Create(start' optionsStart + options.Length' Current.CurrentFilePath)' "Unexpected character '" + unexpected.ElementAt(0) + "'"); " is 176.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseMixinOrVariableRule,The length of the statement  "                    Current.RecordWarning(ErrorType.Parser' Position.Create(start' optionsStart + options.Length' Current.CurrentFilePath)' "Include directives are always optional' no trailing '?' is needed."); " is 190.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseMixinOrVariableRule,The length of the statement  "                return new IncludeSelectorProperty(Selector.Parse(paramsStr' paramStart' paramStop' Current.CurrentFilePath)' overrides' start' stream.Position' Current.CurrentFilePath); " is 170.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseMixinOrVariableRule,The length of the statement  "                    return new ResetProperty(Selector.Parse(paramsStr' paramStart' paramStop' Current.CurrentFilePath)' start' stream.Position' Current.CurrentFilePath); " is 149.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseMixinOrVariableRule,The length of the statement  "            return new MixinApplicationProperty(nameStr' ParseApplicationParameters(paramsStr' startParams)' optional: optional' overrides: overrides' start: start' stop: stream.Position' filePath: Current.CurrentFilePath); " is 211.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseRule,The length of the statement  "                Current.RecordError(ErrorType.Parser' Position.Create(start' stream.Position' Current.CurrentFilePath)' "Expected ';'' '{'' or '}'"); " is 133.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseRule,The length of the statement  "                Current.RecordError(ErrorType.Parser' Position.Create(start' stream.Position' Current.CurrentFilePath)' "Expected ':'"); " is 120.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseRule,The length of the statement  "                Current.RecordError(ErrorType.Parser' Position.Create(start' stream.Position' Current.CurrentFilePath)' "Expected value"); " is 122.
Long Statement,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseSelectorAndBlock,The length of the statement  "                    Current.RecordError(ErrorType.Parser' Position.Create(mark' stream.Position' Current.CurrentFilePath)' "Expected selector"); " is 124.
Complex Conditional,MoreInternals.Compiler.Tasks,Evaluate,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Evaluate.cs,Task,The conditional expression  "block == null && media == null && keyframes == null && fontface == null && import == null"  is complex.
Complex Conditional,MoreInternals.Compiler.Tasks,Important,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Important.cs,Task,The conditional expression  "block == null && media == null && keyframes == null && fontface == null"  is complex.
Complex Conditional,MoreInternals.Compiler.Tasks,Includes,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Includes.cs,Impl,The conditional expression  "block == null && media == null && keyframes == null && fontface == null"  is complex.
Complex Conditional,MoreInternals.Compiler.Tasks,Minify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Minify.cs,MinifyBorderWidthShorthand,The conditional expression  "topProps.Count() > 1 || bottomProps.Count() > 1 || rightProps.Count() > 1 || leftProps.Count() > 1"  is complex.
Complex Conditional,MoreInternals.Compiler.Tasks,Minify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Minify.cs,MinifyBorderWidthShorthand,The conditional expression  "topProps.Count() == 0 && bottomProps.Count() == 0 && rightProps.Count() == 0 && leftProps.Count() == 0"  is complex.
Complex Conditional,MoreInternals.Compiler.Tasks,Minify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Minify.cs,MinifyFontProperties,The conditional expression  "fontSize.Count() > 1 || fontVariant.Count() > 1 || fontWeight.Count() > 1 || lineHeight.Count() > 1"  is complex.
Complex Conditional,MoreInternals.Compiler.Tasks,Verify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Verify.cs,VerifySteps,The conditional expression  "(steps.Direction != null && dir == null) || (dir != null && !(dir.Value.ToLowerInvariant().In("end"' "start")))"  is complex.
Complex Conditional,MoreInternals.Compiler.Tasks,Verify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Verify.cs,VerifyCubicBezier,The conditional expression  "x1 == null || y1 == null || x2 == null || y2 == null ||                         (x1 is NumberWithUnitValue) || (y1 is NumberWithUnitValue) ||                         (x2 is NumberWithUnitValue) || (y2 is NumberWithUnitValue)"  is complex.
Complex Conditional,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseNumber,The conditional expression  "stream.HasMore() && (char.IsDigit(stream.Peek()) || (stream.Peek() == '.' && !decimalPassed))"  is complex.
Complex Conditional,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseMixinDeclarationParameter,The conditional expression  "(q1 != -1 && i > q1) || (q2 != -1 && i > q2)"  is complex.
Complex Conditional,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseKeyFramesDirective,The conditional expression  "(name[0] != '-' && char.IsDigit(name[0])) ||                  (name[0] == '-' && name.Length > 1 && char.IsDigit(name[1])) ||                 name.Any(a => a != '-' && !char.IsLetterOrDigit(a))"  is complex.
Empty Catch Block,MoreInternals.Helpers,MinimalCssWriter,C:\repos\kevin-montrose_More\MoreInternals\Helpers\CssWriter.cs,Dispose,The method has an empty catch block.
Magic Number,MoreInternals.Compiler.Tasks,AutoPrefix,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\AutoPrefix.cs,IEOpacity,The following statement contains a magic number: var percent = decimal.Round(asNumber.Value * 100' 0);
Magic Number,MoreInternals.Compiler.Tasks,AutoPrefix,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\AutoPrefix.cs,WebkitBorderRadius,The following statement contains a magic number: if (asCompound == null || asCompound.Values.Count() != 2)              {                     return Simple(pre' borderRadius);              }
Magic Number,MoreInternals.Compiler.Tasks,CacheBreak,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\CacheBreak.cs,Encode,The following statement contains a magic number: var chunks = bits.Count / 5;
Magic Number,MoreInternals.Compiler.Tasks,CacheBreak,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\CacheBreak.cs,Encode,The following statement contains a magic number: for (var i = 0; i < chunks; i++)              {                  var start = i * 5;                  var index = bits[start] ? 16 : 0;                  index += bits[start + 1] ? 8 : 0;                  index += bits[start + 2] ? 4 : 0;                  index += bits[start + 3] ? 2 : 0;                  index += bits[start + 4] ? 1 : 0;                    ret.Add(EncodingCharacters.ElementAt(index));              }
Magic Number,MoreInternals.Compiler.Tasks,CacheBreak,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\CacheBreak.cs,Encode,The following statement contains a magic number: for (var i = 0; i < chunks; i++)              {                  var start = i * 5;                  var index = bits[start] ? 16 : 0;                  index += bits[start + 1] ? 8 : 0;                  index += bits[start + 2] ? 4 : 0;                  index += bits[start + 3] ? 2 : 0;                  index += bits[start + 4] ? 1 : 0;                    ret.Add(EncodingCharacters.ElementAt(index));              }
Magic Number,MoreInternals.Compiler.Tasks,CacheBreak,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\CacheBreak.cs,Encode,The following statement contains a magic number: for (var i = 0; i < chunks; i++)              {                  var start = i * 5;                  var index = bits[start] ? 16 : 0;                  index += bits[start + 1] ? 8 : 0;                  index += bits[start + 2] ? 4 : 0;                  index += bits[start + 3] ? 2 : 0;                  index += bits[start + 4] ? 1 : 0;                    ret.Add(EncodingCharacters.ElementAt(index));              }
Magic Number,MoreInternals.Compiler.Tasks,CacheBreak,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\CacheBreak.cs,Encode,The following statement contains a magic number: for (var i = 0; i < chunks; i++)              {                  var start = i * 5;                  var index = bits[start] ? 16 : 0;                  index += bits[start + 1] ? 8 : 0;                  index += bits[start + 2] ? 4 : 0;                  index += bits[start + 3] ? 2 : 0;                  index += bits[start + 4] ? 1 : 0;                    ret.Add(EncodingCharacters.ElementAt(index));              }
Magic Number,MoreInternals.Compiler.Tasks,CacheBreak,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\CacheBreak.cs,Encode,The following statement contains a magic number: for (var i = 0; i < chunks; i++)              {                  var start = i * 5;                  var index = bits[start] ? 16 : 0;                  index += bits[start + 1] ? 8 : 0;                  index += bits[start + 2] ? 4 : 0;                  index += bits[start + 3] ? 2 : 0;                  index += bits[start + 4] ? 1 : 0;                    ret.Add(EncodingCharacters.ElementAt(index));              }
Magic Number,MoreInternals.Compiler.Tasks,CacheBreak,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\CacheBreak.cs,Encode,The following statement contains a magic number: for (var i = 0; i < chunks; i++)              {                  var start = i * 5;                  var index = bits[start] ? 16 : 0;                  index += bits[start + 1] ? 8 : 0;                  index += bits[start + 2] ? 4 : 0;                  index += bits[start + 3] ? 2 : 0;                  index += bits[start + 4] ? 1 : 0;                    ret.Add(EncodingCharacters.ElementAt(index));              }
Magic Number,MoreInternals.Compiler.Tasks,CacheBreak,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\CacheBreak.cs,Encode,The following statement contains a magic number: for (var i = 0; i < chunks; i++)              {                  var start = i * 5;                  var index = bits[start] ? 16 : 0;                  index += bits[start + 1] ? 8 : 0;                  index += bits[start + 2] ? 4 : 0;                  index += bits[start + 3] ? 2 : 0;                  index += bits[start + 4] ? 1 : 0;                    ret.Add(EncodingCharacters.ElementAt(index));              }
Magic Number,MoreInternals.Compiler.Tasks,CacheBreak,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\CacheBreak.cs,Encode,The following statement contains a magic number: for (var i = 0; i < chunks; i++)              {                  var start = i * 5;                  var index = bits[start] ? 16 : 0;                  index += bits[start + 1] ? 8 : 0;                  index += bits[start + 2] ? 4 : 0;                  index += bits[start + 3] ? 2 : 0;                  index += bits[start + 4] ? 1 : 0;                    ret.Add(EncodingCharacters.ElementAt(index));              }
Magic Number,MoreInternals.Compiler.Tasks,CacheBreak,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\CacheBreak.cs,Encode,The following statement contains a magic number: if (bits.Count % 5 != 0)              {                  var start = chunks * 5;                  var index = 0;                    index += start < bits.Count && bits[start] ? 16 : 0;                  start++;                    index += start < bits.Count && bits[start] ? 8 : 0;                  start++;                    index += start < bits.Count && bits[start] ? 4 : 0;                  start++;                    index += start < bits.Count && bits[start] ? 2 : 0;                  start++;                    index += start < bits.Count && bits[start] ? 1 : 0;                  start++;                    ret.Add(EncodingCharacters.ElementAt(index));              }
Magic Number,MoreInternals.Compiler.Tasks,CacheBreak,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\CacheBreak.cs,Encode,The following statement contains a magic number: if (bits.Count % 5 != 0)              {                  var start = chunks * 5;                  var index = 0;                    index += start < bits.Count && bits[start] ? 16 : 0;                  start++;                    index += start < bits.Count && bits[start] ? 8 : 0;                  start++;                    index += start < bits.Count && bits[start] ? 4 : 0;                  start++;                    index += start < bits.Count && bits[start] ? 2 : 0;                  start++;                    index += start < bits.Count && bits[start] ? 1 : 0;                  start++;                    ret.Add(EncodingCharacters.ElementAt(index));              }
Magic Number,MoreInternals.Compiler.Tasks,CacheBreak,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\CacheBreak.cs,Encode,The following statement contains a magic number: if (bits.Count % 5 != 0)              {                  var start = chunks * 5;                  var index = 0;                    index += start < bits.Count && bits[start] ? 16 : 0;                  start++;                    index += start < bits.Count && bits[start] ? 8 : 0;                  start++;                    index += start < bits.Count && bits[start] ? 4 : 0;                  start++;                    index += start < bits.Count && bits[start] ? 2 : 0;                  start++;                    index += start < bits.Count && bits[start] ? 1 : 0;                  start++;                    ret.Add(EncodingCharacters.ElementAt(index));              }
Magic Number,MoreInternals.Compiler.Tasks,CacheBreak,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\CacheBreak.cs,Encode,The following statement contains a magic number: if (bits.Count % 5 != 0)              {                  var start = chunks * 5;                  var index = 0;                    index += start < bits.Count && bits[start] ? 16 : 0;                  start++;                    index += start < bits.Count && bits[start] ? 8 : 0;                  start++;                    index += start < bits.Count && bits[start] ? 4 : 0;                  start++;                    index += start < bits.Count && bits[start] ? 2 : 0;                  start++;                    index += start < bits.Count && bits[start] ? 1 : 0;                  start++;                    ret.Add(EncodingCharacters.ElementAt(index));              }
Magic Number,MoreInternals.Compiler.Tasks,CacheBreak,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\CacheBreak.cs,Encode,The following statement contains a magic number: if (bits.Count % 5 != 0)              {                  var start = chunks * 5;                  var index = 0;                    index += start < bits.Count && bits[start] ? 16 : 0;                  start++;                    index += start < bits.Count && bits[start] ? 8 : 0;                  start++;                    index += start < bits.Count && bits[start] ? 4 : 0;                  start++;                    index += start < bits.Count && bits[start] ? 2 : 0;                  start++;                    index += start < bits.Count && bits[start] ? 1 : 0;                  start++;                    ret.Add(EncodingCharacters.ElementAt(index));              }
Magic Number,MoreInternals.Compiler.Tasks,CacheBreak,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\CacheBreak.cs,Encode,The following statement contains a magic number: if (bits.Count % 5 != 0)              {                  var start = chunks * 5;                  var index = 0;                    index += start < bits.Count && bits[start] ? 16 : 0;                  start++;                    index += start < bits.Count && bits[start] ? 8 : 0;                  start++;                    index += start < bits.Count && bits[start] ? 4 : 0;                  start++;                    index += start < bits.Count && bits[start] ? 2 : 0;                  start++;                    index += start < bits.Count && bits[start] ? 1 : 0;                  start++;                    ret.Add(EncodingCharacters.ElementAt(index));              }
Magic Number,MoreInternals.Compiler.Tasks,CacheBreak,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\CacheBreak.cs,HashAndTruncate,The following statement contains a magic number: ivBytes.AddRange(BitConverter.GetBytes(8));
Magic Number,MoreInternals.Compiler.Tasks,CacheBreak,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\CacheBreak.cs,HashAndTruncate,The following statement contains a magic number: var buffer = new byte[4096];
Magic Number,MoreInternals.Compiler.Tasks,CacheBreak,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\CacheBreak.cs,HashAndTruncate,The following statement contains a magic number: return untruncated.Take(8).ToArray();
Magic Number,MoreInternals.Compiler.Tasks,CacheBreak,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\CacheBreak.cs,GenerateCacheBreaker,The following statement contains a magic number: if (!Current.FileLookup.Exists(path))              {                  var breaker = new List<byte>(8);                  breaker.AddRange(GetRandom(4));                    var low = (uint)(DateTime.UtcNow.Ticks & 0xFFFFFFFF);                    breaker.AddRange(BitConverter.GetBytes(low));                    return Encode(breaker.ToArray());              }
Magic Number,MoreInternals.Compiler.Tasks,CacheBreak,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\CacheBreak.cs,GenerateCacheBreaker,The following statement contains a magic number: if (!Current.FileLookup.Exists(path))              {                  var breaker = new List<byte>(8);                  breaker.AddRange(GetRandom(4));                    var low = (uint)(DateTime.UtcNow.Ticks & 0xFFFFFFFF);                    breaker.AddRange(BitConverter.GetBytes(low));                    return Encode(breaker.ToArray());              }
Magic Number,MoreInternals.Compiler.Tasks,Minify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Minify.cs,MinifyColor,The following statement contains a magic number: if (asNamed.HasValue() && asNamed.Length < 7)              {                  return new NamedColorValue((NamedColor)asNum);              }
Magic Number,MoreInternals.Compiler.Tasks,Minify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Minify.cs,TryMinifyNumberWithUnit,The following statement contains a magic number: foreach (var unit in possibleConversions.Keys)              {                  var conversion = possibleConversions[unit];                    var maxPrecision = inBasic / conversion;                    // 5 decimal points seems like an acceptable level of precision; webkit seems to agree                  var inUnit = decimal.Round(maxPrecision' 5);                    var asNum = new NumberValue(inUnit);                  var minified = MinifyNumberValue(asNum);                    var newMin = new NumberWithUnitValue(minified.Value' unit);                  string newMinStr;                    using (var buffer = new StringWriter())                  {                      newMin.Write(buffer);                      newMinStr = buffer.ToString();                  }                    if (newMinStr.Length < retStr.Length)                  {                      ret = newMin;                      retStr = newMinStr;                  }              }
Magic Number,MoreInternals.Compiler.Tasks,Minify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Minify.cs,MinifyLinearGradient,The following statement contains a magic number: switch (cleanedStr)              {                  case "to top": newParams.Add(new NumberWithUnitValue(0' Unit.DEG)); break;                  case "to right": newParams.Add(new NumberWithUnitValue(90' Unit.DEG)); break;                  case "to bottom": newParams.Add(new NumberWithUnitValue(180' Unit.DEG)); break;                  case "to left": newParams.Add(new NumberWithUnitValue(270' Unit.DEG)); break;                    case "to top left":                  case "to left top": newParams.Add(new NumberWithUnitValue(315' Unit.DEG)); break;                    case "to top right":                  case "to right top": newParams.Add(new NumberWithUnitValue(45' Unit.DEG)); break;                    case "to bottom left":                  case "to left bottom": newParams.Add(new NumberWithUnitValue(225' Unit.DEG)); break;                    case "to bottom right":                  case "to right bottom": newParams.Add(new NumberWithUnitValue(135' Unit.DEG)); break;                    default: newParams.Add(first); break;              }
Magic Number,MoreInternals.Compiler.Tasks,Minify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Minify.cs,MinifyLinearGradient,The following statement contains a magic number: switch (cleanedStr)              {                  case "to top": newParams.Add(new NumberWithUnitValue(0' Unit.DEG)); break;                  case "to right": newParams.Add(new NumberWithUnitValue(90' Unit.DEG)); break;                  case "to bottom": newParams.Add(new NumberWithUnitValue(180' Unit.DEG)); break;                  case "to left": newParams.Add(new NumberWithUnitValue(270' Unit.DEG)); break;                    case "to top left":                  case "to left top": newParams.Add(new NumberWithUnitValue(315' Unit.DEG)); break;                    case "to top right":                  case "to right top": newParams.Add(new NumberWithUnitValue(45' Unit.DEG)); break;                    case "to bottom left":                  case "to left bottom": newParams.Add(new NumberWithUnitValue(225' Unit.DEG)); break;                    case "to bottom right":                  case "to right bottom": newParams.Add(new NumberWithUnitValue(135' Unit.DEG)); break;                    default: newParams.Add(first); break;              }
Magic Number,MoreInternals.Compiler.Tasks,Minify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Minify.cs,MinifyLinearGradient,The following statement contains a magic number: switch (cleanedStr)              {                  case "to top": newParams.Add(new NumberWithUnitValue(0' Unit.DEG)); break;                  case "to right": newParams.Add(new NumberWithUnitValue(90' Unit.DEG)); break;                  case "to bottom": newParams.Add(new NumberWithUnitValue(180' Unit.DEG)); break;                  case "to left": newParams.Add(new NumberWithUnitValue(270' Unit.DEG)); break;                    case "to top left":                  case "to left top": newParams.Add(new NumberWithUnitValue(315' Unit.DEG)); break;                    case "to top right":                  case "to right top": newParams.Add(new NumberWithUnitValue(45' Unit.DEG)); break;                    case "to bottom left":                  case "to left bottom": newParams.Add(new NumberWithUnitValue(225' Unit.DEG)); break;                    case "to bottom right":                  case "to right bottom": newParams.Add(new NumberWithUnitValue(135' Unit.DEG)); break;                    default: newParams.Add(first); break;              }
Magic Number,MoreInternals.Compiler.Tasks,Minify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Minify.cs,MinifyLinearGradient,The following statement contains a magic number: switch (cleanedStr)              {                  case "to top": newParams.Add(new NumberWithUnitValue(0' Unit.DEG)); break;                  case "to right": newParams.Add(new NumberWithUnitValue(90' Unit.DEG)); break;                  case "to bottom": newParams.Add(new NumberWithUnitValue(180' Unit.DEG)); break;                  case "to left": newParams.Add(new NumberWithUnitValue(270' Unit.DEG)); break;                    case "to top left":                  case "to left top": newParams.Add(new NumberWithUnitValue(315' Unit.DEG)); break;                    case "to top right":                  case "to right top": newParams.Add(new NumberWithUnitValue(45' Unit.DEG)); break;                    case "to bottom left":                  case "to left bottom": newParams.Add(new NumberWithUnitValue(225' Unit.DEG)); break;                    case "to bottom right":                  case "to right bottom": newParams.Add(new NumberWithUnitValue(135' Unit.DEG)); break;                    default: newParams.Add(first); break;              }
Magic Number,MoreInternals.Compiler.Tasks,Minify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Minify.cs,MinifyLinearGradient,The following statement contains a magic number: switch (cleanedStr)              {                  case "to top": newParams.Add(new NumberWithUnitValue(0' Unit.DEG)); break;                  case "to right": newParams.Add(new NumberWithUnitValue(90' Unit.DEG)); break;                  case "to bottom": newParams.Add(new NumberWithUnitValue(180' Unit.DEG)); break;                  case "to left": newParams.Add(new NumberWithUnitValue(270' Unit.DEG)); break;                    case "to top left":                  case "to left top": newParams.Add(new NumberWithUnitValue(315' Unit.DEG)); break;                    case "to top right":                  case "to right top": newParams.Add(new NumberWithUnitValue(45' Unit.DEG)); break;                    case "to bottom left":                  case "to left bottom": newParams.Add(new NumberWithUnitValue(225' Unit.DEG)); break;                    case "to bottom right":                  case "to right bottom": newParams.Add(new NumberWithUnitValue(135' Unit.DEG)); break;                    default: newParams.Add(first); break;              }
Magic Number,MoreInternals.Compiler.Tasks,Minify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Minify.cs,MinifyLinearGradient,The following statement contains a magic number: switch (cleanedStr)              {                  case "to top": newParams.Add(new NumberWithUnitValue(0' Unit.DEG)); break;                  case "to right": newParams.Add(new NumberWithUnitValue(90' Unit.DEG)); break;                  case "to bottom": newParams.Add(new NumberWithUnitValue(180' Unit.DEG)); break;                  case "to left": newParams.Add(new NumberWithUnitValue(270' Unit.DEG)); break;                    case "to top left":                  case "to left top": newParams.Add(new NumberWithUnitValue(315' Unit.DEG)); break;                    case "to top right":                  case "to right top": newParams.Add(new NumberWithUnitValue(45' Unit.DEG)); break;                    case "to bottom left":                  case "to left bottom": newParams.Add(new NumberWithUnitValue(225' Unit.DEG)); break;                    case "to bottom right":                  case "to right bottom": newParams.Add(new NumberWithUnitValue(135' Unit.DEG)); break;                    default: newParams.Add(first); break;              }
Magic Number,MoreInternals.Compiler.Tasks,Minify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Minify.cs,MinifyLinearGradient,The following statement contains a magic number: switch (cleanedStr)              {                  case "to top": newParams.Add(new NumberWithUnitValue(0' Unit.DEG)); break;                  case "to right": newParams.Add(new NumberWithUnitValue(90' Unit.DEG)); break;                  case "to bottom": newParams.Add(new NumberWithUnitValue(180' Unit.DEG)); break;                  case "to left": newParams.Add(new NumberWithUnitValue(270' Unit.DEG)); break;                    case "to top left":                  case "to left top": newParams.Add(new NumberWithUnitValue(315' Unit.DEG)); break;                    case "to top right":                  case "to right top": newParams.Add(new NumberWithUnitValue(45' Unit.DEG)); break;                    case "to bottom left":                  case "to left bottom": newParams.Add(new NumberWithUnitValue(225' Unit.DEG)); break;                    case "to bottom right":                  case "to right bottom": newParams.Add(new NumberWithUnitValue(135' Unit.DEG)); break;                    default: newParams.Add(first); break;              }
Magic Number,MoreInternals.Compiler.Tasks,Verify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Verify.cs,VerifyColorStop,The following statement contains a magic number: if (asCompound != null)              {                  if (asCompound.Values.Count() != 2)                  {                      Current.RecordError(ErrorType.Compiler' value' "color-stops should be composed of two values' one color and one length or percentage");                      return;                  }                    var first = asCompound.Values.ElementAt(0) as ColorValue;                  var second = asCompound.Values.ElementAt(1) as NumberWithUnitValue;                    if (first == null)                  {                      Current.RecordError(ErrorType.Compiler' value' "a color-stop's first value should be a color");                      return;                  }                    if (second == null)                  {                      Current.RecordError(ErrorType.Compiler' value' "a color-stop's second value should be a percentage or length");                      return;                  }                    if (second.Unit == Unit.Percent)                  {                      if (second.Value < 0 || second.Value > 100)                      {                          Current.RecordError(ErrorType.Compiler' value' "a color-stop's second value' if a percentage' should be between 0% and 100%");                          return;                      }                  }                  else                  {                      if (!second.Unit.In(Unit.EM' Unit.EX' Unit.CH' Unit.REM' Unit.VH' Unit.VW' Unit.VM' Unit.PX' Unit.MM' Unit.CM' Unit.IN' Unit.PT' Unit.PC))                      {                          Current.RecordError(ErrorType.Compiler' value' "a color-stop's second value' if not a percentage' should be a length");                          return;                      }                  }                    return;              }
Magic Number,MoreInternals.Compiler.Tasks,Verify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Verify.cs,VerifyColorStop,The following statement contains a magic number: if (asCompound != null)              {                  if (asCompound.Values.Count() != 2)                  {                      Current.RecordError(ErrorType.Compiler' value' "color-stops should be composed of two values' one color and one length or percentage");                      return;                  }                    var first = asCompound.Values.ElementAt(0) as ColorValue;                  var second = asCompound.Values.ElementAt(1) as NumberWithUnitValue;                    if (first == null)                  {                      Current.RecordError(ErrorType.Compiler' value' "a color-stop's first value should be a color");                      return;                  }                    if (second == null)                  {                      Current.RecordError(ErrorType.Compiler' value' "a color-stop's second value should be a percentage or length");                      return;                  }                    if (second.Unit == Unit.Percent)                  {                      if (second.Value < 0 || second.Value > 100)                      {                          Current.RecordError(ErrorType.Compiler' value' "a color-stop's second value' if a percentage' should be between 0% and 100%");                          return;                      }                  }                  else                  {                      if (!second.Unit.In(Unit.EM' Unit.EX' Unit.CH' Unit.REM' Unit.VH' Unit.VW' Unit.VM' Unit.PX' Unit.MM' Unit.CM' Unit.IN' Unit.PT' Unit.PC))                      {                          Current.RecordError(ErrorType.Compiler' value' "a color-stop's second value' if not a percentage' should be a length");                          return;                      }                  }                    return;              }
Magic Number,MoreInternals.Compiler.Tasks,Verify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Verify.cs,VerifyLinearGradient,The following statement contains a magic number: foreach (var value in values)              {                  var comma = value as CommaDelimittedValue;                  if (comma != null)                  {                      VerifySteps(comma.Values);                      continue;                  }                    var compound = value as CompoundValue;                  if (compound != null)                  {                      VerifySteps(compound.Values);                      continue;                  }                    var linGrad = value as LinearGradientValue;                  if (linGrad != null)                  {                      linGrad.Parameters.Skip(1).Each(v => VerifyColorStop(v));                        var first = linGrad.Parameters.First();                      var asNum = first as NumberWithUnitValue;                      if (asNum != null)                      {                          if (!asNum.Unit.In(Unit.DEG' Unit.GRAD' Unit.RAD' Unit.TURN))                          {                              Current.RecordError(ErrorType.Compiler' first' "linear-gradient's first parameter' if not a color' must be an angle");                              continue;                          }                      }                      else                      {                          var asString = first.ToString().Trim();                          if (asString.StartsWith("to "' StringComparison.InvariantCultureIgnoreCase))                          {                              var parts = asString.Substring(3).Trim().Split(new[] { ' ' }' StringSplitOptions.RemoveEmptyEntries).Distinct().ToList();                              if (parts.Count > 2 || parts.Count == 0)                              {                                  Current.RecordError(ErrorType.Compiler' first' "linear-gradient's first parameter' if an angle shorthand' must be of the form 'to [left | right] || [top | bottom]'");                                  continue;                              }                                if (parts.Any(a => !a.ToLowerInvariant().In("top"' "left"' "bottom"' "right")))                              {                                  Current.RecordError(ErrorType.Compiler' first' "linear-gradient's first parameter' if an angle shorthand' must be of the form 'to [left | right] || [top | bottom]'");                                  continue;                              }                          }                          else                          {                              VerifyColorStop(first);                          }                      }                        continue;                  }              }
Magic Number,MoreInternals.Compiler.Tasks,Verify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Verify.cs,VerifyLinearGradient,The following statement contains a magic number: foreach (var value in values)              {                  var comma = value as CommaDelimittedValue;                  if (comma != null)                  {                      VerifySteps(comma.Values);                      continue;                  }                    var compound = value as CompoundValue;                  if (compound != null)                  {                      VerifySteps(compound.Values);                      continue;                  }                    var linGrad = value as LinearGradientValue;                  if (linGrad != null)                  {                      linGrad.Parameters.Skip(1).Each(v => VerifyColorStop(v));                        var first = linGrad.Parameters.First();                      var asNum = first as NumberWithUnitValue;                      if (asNum != null)                      {                          if (!asNum.Unit.In(Unit.DEG' Unit.GRAD' Unit.RAD' Unit.TURN))                          {                              Current.RecordError(ErrorType.Compiler' first' "linear-gradient's first parameter' if not a color' must be an angle");                              continue;                          }                      }                      else                      {                          var asString = first.ToString().Trim();                          if (asString.StartsWith("to "' StringComparison.InvariantCultureIgnoreCase))                          {                              var parts = asString.Substring(3).Trim().Split(new[] { ' ' }' StringSplitOptions.RemoveEmptyEntries).Distinct().ToList();                              if (parts.Count > 2 || parts.Count == 0)                              {                                  Current.RecordError(ErrorType.Compiler' first' "linear-gradient's first parameter' if an angle shorthand' must be of the form 'to [left | right] || [top | bottom]'");                                  continue;                              }                                if (parts.Any(a => !a.ToLowerInvariant().In("top"' "left"' "bottom"' "right")))                              {                                  Current.RecordError(ErrorType.Compiler' first' "linear-gradient's first parameter' if an angle shorthand' must be of the form 'to [left | right] || [top | bottom]'");                                  continue;                              }                          }                          else                          {                              VerifyColorStop(first);                          }                      }                        continue;                  }              }
Magic Number,MoreInternals.Helpers,Validation,C:\repos\kevin-montrose_More\MoreInternals\Helpers\Validation.cs,IsValidEscape,The following statement contains a magic number: if (escapeSequence.Length < 7) escapeSequence = escapeSequence.Trim();
Magic Number,MoreInternals.Helpers,Validation,C:\repos\kevin-montrose_More\MoreInternals\Helpers\Validation.cs,IsValidEscape,The following statement contains a magic number: return                  escapeSequence.Length > 1 &&                  escapeSequence.Length <= 7 &&                  escapeSequence[0] == '\\' &&                  escapeSequence.ToLowerInvariant().Skip(1).All(c => (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f'));
Magic Number,MoreInternals.Helpers,Validation,C:\repos\kevin-montrose_More\MoreInternals\Helpers\Validation.cs,RemoveEscapes,The following statement contains a magic number: for (var i = 0; i < id.Length; i++)              {                  var c = id[i];                    if (c == '\\')                  {                      inEscape = true;                      escapeStarts = i;                      continue;                  }                    if (!inEscape)                  {                      ret.Add(c);                      continue;                  }                    // in an escape '\r\n' needs to be collapsed to just a single whitespace character                  if (c == '\r')                  {                      if (i + 1 < id.Length)                      {                          if (id[i + 1] == '\n')                          {                              i++;                              c = id[i];                          }                      }                  }                    // end of the escape                  if (char.IsWhiteSpace(c) ||  (i - escapeStarts == 7))                  {                      var escaped = id.Substring(escapeStarts' i - escapeStarts + 1);                        var subsectionWelformed = IsValidEscape(escaped);                        if (!subsectionWelformed)                      {                          ret.AddRange(escaped.Skip(1));                      }                        inEscape = false;                  }              }
Magic Number,MoreInternals.Helpers,Validation,C:\repos\kevin-montrose_More\MoreInternals\Helpers\Validation.cs,IsIdentifier,The following statement contains a magic number: if (id.Length >= 2 && id[0] == '-' && char.IsDigit(id[1])) return false;
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToRGB,The following statement contains a magic number: if (param is NamedColorValue)              {                  var named = (NamedColorValue)param;                  r = ((int)named.Color >> 16) & 0xFF;                  g = ((int)named.Color >> 8) & 0xFF;                  b = ((int)named.Color >> 0) & 0xFF;                    return Tuple.Create(r' g' b);              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToRGB,The following statement contains a magic number: if (param is NamedColorValue)              {                  var named = (NamedColorValue)param;                  r = ((int)named.Color >> 16) & 0xFF;                  g = ((int)named.Color >> 8) & 0xFF;                  b = ((int)named.Color >> 0) & 0xFF;                    return Tuple.Create(r' g' b);              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToRGB,The following statement contains a magic number: var c = (1 - Math.Abs(2 * l - 1)) * s;
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToRGB,The following statement contains a magic number: var x = c * (1 - Math.Abs(hPrime % 2 - 1));
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToRGB,The following statement contains a magic number: if (hPrime >= 1 && hPrime < 2)              {                  r = x;                  g = c;                  b = 0;              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToRGB,The following statement contains a magic number: if (hPrime >= 2 && hPrime < 3)              {                  r = 0;                  g = c;                  b = x;              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToRGB,The following statement contains a magic number: if (hPrime >= 2 && hPrime < 3)              {                  r = 0;                  g = c;                  b = x;              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToRGB,The following statement contains a magic number: if (hPrime >= 3 && hPrime < 4)              {                  r = 0;                  g = x;                  b = c;              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToRGB,The following statement contains a magic number: if (hPrime >= 3 && hPrime < 4)              {                  r = 0;                  g = x;                  b = c;              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToRGB,The following statement contains a magic number: if (hPrime >= 4 && hPrime < 5)              {                  r = x;                  g = 0;                  b = c;              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToRGB,The following statement contains a magic number: if (hPrime >= 4 && hPrime < 5)              {                  r = x;                  g = 0;                  b = c;              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToRGB,The following statement contains a magic number: if (hPrime >= 5 && hPrime < 6)              {                  r = c;                  g = 0;                  b = x;              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToRGB,The following statement contains a magic number: if (hPrime >= 5 && hPrime < 6)              {                  r = c;                  g = 0;                  b = x;              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToRGB,The following statement contains a magic number: r = decimal.Round(r' 2' MidpointRounding.AwayFromZero);
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToRGB,The following statement contains a magic number: g = decimal.Round(g' 2' MidpointRounding.AwayFromZero);
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToRGB,The following statement contains a magic number: b = decimal.Round(b' 2' MidpointRounding.AwayFromZero);
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertColorPart,The following statement contains a magic number: if (val is NumberWithUnitValue)              {                  var unit = (NumberWithUnitValue)val;                  if (unit.Unit != Unit.Percent)                  {                      Current.RecordError(ErrorType.Compiler' position' "Color parts must be raw numbers or percents' found [" + val + "]");                      return false;                  }                    var v = unit.Value;                  if(v > 100)                  {                      v = 100;                      Current.RecordWarning(ErrorType.Compiler' position' "Clipped color-part percent from [" + unit.Value + "] to 100");                  }                  if(v < 0)                   {                      v = 0;                      Current.RecordWarning(ErrorType.Compiler' position' "Clipped color-part percent from [" + unit.Value + "] to 0");                  }                    part = decimal.Round(255m * (v / 100m)' 0' MidpointRounding.AwayFromZero);                  return true;              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertColorPart,The following statement contains a magic number: if (val is NumberWithUnitValue)              {                  var unit = (NumberWithUnitValue)val;                  if (unit.Unit != Unit.Percent)                  {                      Current.RecordError(ErrorType.Compiler' position' "Color parts must be raw numbers or percents' found [" + val + "]");                      return false;                  }                    var v = unit.Value;                  if(v > 100)                  {                      v = 100;                      Current.RecordWarning(ErrorType.Compiler' position' "Clipped color-part percent from [" + unit.Value + "] to 100");                  }                  if(v < 0)                   {                      v = 0;                      Current.RecordWarning(ErrorType.Compiler' position' "Clipped color-part percent from [" + unit.Value + "] to 0");                  }                    part = decimal.Round(255m * (v / 100m)' 0' MidpointRounding.AwayFromZero);                  return true;              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertColorPart,The following statement contains a magic number: if (x > 255)              {                  x = 255;                  Current.RecordWarning(ErrorType.Compiler' position' "Clipped color-part from [" + noUnit.Value + "] to 255");              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertColorPart,The following statement contains a magic number: if (x > 255)              {                  x = 255;                  Current.RecordWarning(ErrorType.Compiler' position' "Clipped color-part from [" + noUnit.Value + "] to 255");              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToHSL,The following statement contains a magic number: if (param is NamedColorValue)              {                  var named = (NamedColorValue)param;                  r = ((int)named.Color >> 16) & 0xFF;                  g = ((int)named.Color >>  8) & 0xFF;                  b = ((int)named.Color >>  0) & 0xFF;              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToHSL,The following statement contains a magic number: if (param is NamedColorValue)              {                  var named = (NamedColorValue)param;                  r = ((int)named.Color >> 16) & 0xFF;                  g = ((int)named.Color >>  8) & 0xFF;                  b = ((int)named.Color >>  0) & 0xFF;              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToHSL,The following statement contains a magic number: var lightness = (max + min) / 2;
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToHSL,The following statement contains a magic number: hue *= 360;
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToHSL,The following statement contains a magic number: hue = decimal.Round(hue' 2' MidpointRounding.AwayFromZero);
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToHSL,The following statement contains a magic number: saturation = decimal.Round(saturation' 2' MidpointRounding.AwayFromZero);
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,ConvertToHSL,The following statement contains a magic number: lightness = decimal.Round(lightness' 2' MidpointRounding.AwayFromZero);
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Round,The following statement contains a magic number: if (parameters.Count() < 1 || parameters.Count() > 2)              {                  Current.RecordError(ErrorType.Compiler' position' "Round expects 1 or 2 numeric parameters");                  return ExcludeFromOutputValue.Singleton;              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Round,The following statement contains a magic number: if (parameters.Count() == 2)              {                  precision = parameters.ElementAt(1);              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Gray,The following statement contains a magic number: var newPart = new NumberValue(decimal.Round((parts.Item1 + parts.Item2 + parts.Item3) / 3.0m' 2));
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Lighten,The following statement contains a magic number: if (parameters.Count() != 2)              {                  Current.RecordError(ErrorType.Compiler' position' "Lighten expects a color parameter' and a percentage");                  return ExcludeFromOutputValue.Singleton;              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Lighten,The following statement contains a magic number: var l = decimal.Round(hsl.Item3 + percentV.Value / 100m' 2);
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Darken,The following statement contains a magic number: if (parameters.Count() != 2)              {                  Current.RecordError(ErrorType.Compiler' position' "Darken expects a color parameter' and a percentage");                  return ExcludeFromOutputValue.Singleton;              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Darken,The following statement contains a magic number: var l = decimal.Round(hsl.Item3 - percentV.Value / 100m' 2);
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Saturate,The following statement contains a magic number: if (parameters.Count() != 2)              {                  Current.RecordError(ErrorType.Compiler' position' "Saturate expects a color parameter' and a percentage");                  return ExcludeFromOutputValue.Singleton;              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Saturate,The following statement contains a magic number: var s = decimal.Round(hsl.Item2 + percentV.Value / 100m' 2);
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Desaturate,The following statement contains a magic number: if (parameters.Count() != 2)              {                  Current.RecordError(ErrorType.Compiler' position' "Desaturate expects a color parameter' and a percentage");                  return ExcludeFromOutputValue.Singleton;              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Desaturate,The following statement contains a magic number: var s = decimal.Round(hsl.Item2 - percentV.Value / 100m' 2);
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,FadeIn,The following statement contains a magic number: if (parameters.Count() != 2)              {                  Current.RecordError(ErrorType.Compiler' position' "FadeIn expects a color parameter' and a percentage");                  return ExcludeFromOutputValue.Singleton;              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,FadeIn,The following statement contains a magic number: var alpha = new NumberWithUnitValue(100' Unit.Percent);
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,FadeOut,The following statement contains a magic number: if (parameters.Count() != 2)              {                  Current.RecordError(ErrorType.Compiler' position' "FadeOut expects a color parameter' and a percentage");                  return ExcludeFromOutputValue.Singleton;              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,FadeOut,The following statement contains a magic number: var alpha = new NumberWithUnitValue(100' Unit.Percent);
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Fade,The following statement contains a magic number: if (parameters.Count() != 2)              {                  Current.RecordError(ErrorType.Compiler' position' "Fade expects a color parameter' and a percentage");                  return ExcludeFromOutputValue.Singleton;              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Spin,The following statement contains a magic number: if (parameters.Count() != 2)              {                  Current.RecordError(ErrorType.Compiler' position' "Spin expects a color parameter' and a unit-less number");                  return ExcludeFromOutputValue.Singleton;              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Spin,The following statement contains a magic number: h = ((h % 360) + 360) % 360;
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Spin,The following statement contains a magic number: h = ((h % 360) + 360) % 360;
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Spin,The following statement contains a magic number: h = ((h % 360) + 360) % 360;
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Mix,The following statement contains a magic number: if (parameters.Count() != 3)              {                  Current.RecordError(ErrorType.Compiler' position' "Mix expects 3 parameters' 2 colors and 1 percentage or number");                  return ExcludeFromOutputValue.Singleton;              }
Magic Number,MoreInternals.Model,BuiltInFunctions,C:\repos\kevin-montrose_More\MoreInternals\Model\MoreFunction.cs,Mix,The following statement contains a magic number: var p = parameters.ElementAt(2);
Magic Number,MoreInternals.Model,Value,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Precedence,The following statement contains a magic number: switch (o)              {                  case Operator.Div: return 3;                  case Operator.Mod: return 3;                  case Operator.Mult: return 3;                    case Operator.Minus: return 2;                  case Operator.Plus: return 2;                                    case Operator.Take_Exists: return 1;                    default: throw new NotImplementedException();              }
Magic Number,MoreInternals.Model,Value,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Precedence,The following statement contains a magic number: switch (o)              {                  case Operator.Div: return 3;                  case Operator.Mod: return 3;                  case Operator.Mult: return 3;                    case Operator.Minus: return 2;                  case Operator.Plus: return 2;                                    case Operator.Take_Exists: return 1;                    default: throw new NotImplementedException();              }
Magic Number,MoreInternals.Model,Value,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Precedence,The following statement contains a magic number: switch (o)              {                  case Operator.Div: return 3;                  case Operator.Mod: return 3;                  case Operator.Mult: return 3;                    case Operator.Minus: return 2;                  case Operator.Plus: return 2;                                    case Operator.Take_Exists: return 1;                    default: throw new NotImplementedException();              }
Magic Number,MoreInternals.Model,Value,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Precedence,The following statement contains a magic number: switch (o)              {                  case Operator.Div: return 3;                  case Operator.Mod: return 3;                  case Operator.Mult: return 3;                    case Operator.Minus: return 2;                  case Operator.Plus: return 2;                                    case Operator.Take_Exists: return 1;                    default: throw new NotImplementedException();              }
Magic Number,MoreInternals.Model,Value,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Precedence,The following statement contains a magic number: switch (o)              {                  case Operator.Div: return 3;                  case Operator.Mod: return 3;                  case Operator.Mult: return 3;                    case Operator.Minus: return 2;                  case Operator.Plus: return 2;                                    case Operator.Take_Exists: return 1;                    default: throw new NotImplementedException();              }
Magic Number,MoreInternals.Model,HexTripleColorValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Parse,The following statement contains a magic number: var b = raw[2] + "" + raw[2];
Magic Number,MoreInternals.Model,HexTripleColorValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Parse,The following statement contains a magic number: var b = raw[2] + "" + raw[2];
Magic Number,MoreInternals.Model,HexSextupleColorValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Parse,The following statement contains a magic number: var r = raw.Substring(0' 2);
Magic Number,MoreInternals.Model,HexSextupleColorValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Parse,The following statement contains a magic number: var g = raw.Substring(2' 2);
Magic Number,MoreInternals.Model,HexSextupleColorValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Parse,The following statement contains a magic number: var g = raw.Substring(2' 2);
Magic Number,MoreInternals.Model,HexSextupleColorValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Parse,The following statement contains a magic number: var b = raw.Substring(4' 2);
Magic Number,MoreInternals.Model,HexSextupleColorValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Parse,The following statement contains a magic number: var b = raw.Substring(4' 2);
Magic Number,MoreInternals.Model,RGBColorValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,ParseColor,The following statement contains a magic number: try              {                  if (color.EndsWith("%"))                  {                      var rP = decimal.Parse(color.Substring(0' color.Length - 1));                      var temp = (255m * (rP / 100m));                      if (temp > 255) temp = 255;                      if (temp < 0) temp = 0;                        return (byte)temp;                  }                    var ret = int.Parse(color);                  if (ret > 255) ret = 255;                  if (ret < 0) ret = 0;                    return (byte)ret;              }              catch (Exception)              {                  throw new InvalidOperationException("Could not parse [" + color + "] as a color component value");              }
Magic Number,MoreInternals.Model,RGBColorValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,ParseColor,The following statement contains a magic number: try              {                  if (color.EndsWith("%"))                  {                      var rP = decimal.Parse(color.Substring(0' color.Length - 1));                      var temp = (255m * (rP / 100m));                      if (temp > 255) temp = 255;                      if (temp < 0) temp = 0;                        return (byte)temp;                  }                    var ret = int.Parse(color);                  if (ret > 255) ret = 255;                  if (ret < 0) ret = 0;                    return (byte)ret;              }              catch (Exception)              {                  throw new InvalidOperationException("Could not parse [" + color + "] as a color component value");              }
Magic Number,MoreInternals.Model,RGBColorValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,ParseColor,The following statement contains a magic number: try              {                  if (color.EndsWith("%"))                  {                      var rP = decimal.Parse(color.Substring(0' color.Length - 1));                      var temp = (255m * (rP / 100m));                      if (temp > 255) temp = 255;                      if (temp < 0) temp = 0;                        return (byte)temp;                  }                    var ret = int.Parse(color);                  if (ret > 255) ret = 255;                  if (ret < 0) ret = 0;                    return (byte)ret;              }              catch (Exception)              {                  throw new InvalidOperationException("Could not parse [" + color + "] as a color component value");              }
Magic Number,MoreInternals.Model,RGBColorValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,ParseColor,The following statement contains a magic number: try              {                  if (color.EndsWith("%"))                  {                      var rP = decimal.Parse(color.Substring(0' color.Length - 1));                      var temp = (255m * (rP / 100m));                      if (temp > 255) temp = 255;                      if (temp < 0) temp = 0;                        return (byte)temp;                  }                    var ret = int.Parse(color);                  if (ret > 255) ret = 255;                  if (ret < 0) ret = 0;                    return (byte)ret;              }              catch (Exception)              {                  throw new InvalidOperationException("Could not parse [" + color + "] as a color component value");              }
Magic Number,MoreInternals.Model,RGBColorValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,WriteSanityCheck,The following statement contains a magic number: if (val > 255) val = 255;
Magic Number,MoreInternals.Model,RGBColorValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,WriteSanityCheck,The following statement contains a magic number: if (val > 255) val = 255;
Magic Number,MoreInternals.Model,HSLColorValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Write,The following statement contains a magic number: h = (h % 360 + 360) % 360;
Magic Number,MoreInternals.Model,HSLColorValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Write,The following statement contains a magic number: h = (h % 360 + 360) % 360;
Magic Number,MoreInternals.Model,HSLColorValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Write,The following statement contains a magic number: h = (h % 360 + 360) % 360;
Magic Number,MoreInternals.Model,HSLColorValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Write,The following statement contains a magic number: if (s > 100) s = 100;
Magic Number,MoreInternals.Model,HSLColorValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Write,The following statement contains a magic number: if (s > 100) s = 100;
Magic Number,MoreInternals.Model,HSLColorValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Write,The following statement contains a magic number: if (l > 100) l = 100;
Magic Number,MoreInternals.Model,HSLColorValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Write,The following statement contains a magic number: if (l > 100) l = 100;
Magic Number,MoreInternals.Model,StringEvalMap,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Parse,The following statement contains a magic number: for (int i = 0; i < value.Length; i++)              {                  var c = value[i];                    if (c == '@' && !inValue)                  {                      depth = 0;                      start = i;                      inValue = true;                      val.Append(c);                      continue;                  }                    if (inValue && c == '(')                  {                      depth++;                      val.Append(c);                      continue;                  }                    if (inValue && c == ')' && depth > 0)                  {                      depth--;                      val.Append(c);                        if (depth == 0)                      {                          inValue = false;                            var str = val.ToString();                          val.Clear();                          if (str.StartsWith("@("))                          {                              str = str.Substring(2' str.Length - 3);                          }                            var moreVal = Value.Parse(str' valStart' valStop' filePath);                          map[Tuple.Create(start' i)] = moreVal;                      }                      continue;                  }                    if (!char.IsLetterOrDigit(c) && inValue && depth == 0)                  {                      inValue = false;                        var str = val.ToString();                      val.Clear();                        var moreVal = Value.Parse(str' valStart' valStop' filePath);                      map[Tuple.Create(start' i - 1)] = moreVal;                      continue;                  }                    if (inValue)                  {                      val.Append(c);                  }              }
Magic Number,MoreInternals.Model,StringEvalMap,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,Parse,The following statement contains a magic number: for (int i = 0; i < value.Length; i++)              {                  var c = value[i];                    if (c == '@' && !inValue)                  {                      depth = 0;                      start = i;                      inValue = true;                      val.Append(c);                      continue;                  }                    if (inValue && c == '(')                  {                      depth++;                      val.Append(c);                      continue;                  }                    if (inValue && c == ')' && depth > 0)                  {                      depth--;                      val.Append(c);                        if (depth == 0)                      {                          inValue = false;                            var str = val.ToString();                          val.Clear();                          if (str.StartsWith("@("))                          {                              str = str.Substring(2' str.Length - 3);                          }                            var moreVal = Value.Parse(str' valStart' valStop' filePath);                          map[Tuple.Create(start' i)] = moreVal;                      }                      continue;                  }                    if (!char.IsLetterOrDigit(c) && inValue && depth == 0)                  {                      inValue = false;                        var str = val.ToString();                      val.Clear();                        var moreVal = Value.Parse(str' valStart' valStop' filePath);                      map[Tuple.Create(start' i - 1)] = moreVal;                      continue;                  }                    if (inValue)                  {                      val.Append(c);                  }              }
Magic Number,MoreInternals.Model,CompoundValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,GetHashCode,The following statement contains a magic number: for (var i = 0; i < Values.Count(); i++)              {                  var vHash = Values.ElementAt(i).GetHashCode();                    var bytes = BitConverter.GetBytes(vHash).ToList();                    var rotateBy = i % bytes.Count;                    var firstI = bytes.Take(rotateBy);                  var theRest = bytes.Skip(rotateBy);                    var rotatedBytes = new List<byte>(4);                  rotatedBytes.AddRange(firstI);                  rotatedBytes.AddRange(theRest);                    var rotated = BitConverter.ToInt32(rotatedBytes.ToArray()' 0);                    ret ^= rotated;              }
Magic Number,MoreInternals.Model,CommaDelimittedValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,GetHashCode,The following statement contains a magic number: for (var i = 0; i < Values.Count(); i++)              {                  var vHash = Values.ElementAt(i).GetHashCode();                    var bytes = BitConverter.GetBytes(vHash).ToList();                    var rotateBy = i % bytes.Count;                    var firstI = bytes.Take(rotateBy);                  var theRest = bytes.Skip(rotateBy);                    var rotatedBytes = new List<byte>(4);                  rotatedBytes.AddRange(firstI);                  rotatedBytes.AddRange(theRest);                    var rotated = BitConverter.ToInt32(rotatedBytes.ToArray()' 0);                    ret ^= rotated;              }
Magic Number,MoreInternals.Model,CycleValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,GetHashCode,The following statement contains a magic number: for(var i = 0; i < Values.Count(); i++)              {                  var val = Values.ElementAt(i);                  ret ^= val.GetHashCode();                    if (i % 2 == 0) ret *= -1;              }
Magic Number,MoreInternals.Model,RadialGradientValue,C:\repos\kevin-montrose_More\MoreInternals\Model\Value.cs,GetHashCode,The following statement contains a magic number: for (var i = 0; i < Parameters.Count(); i++)              {                  ret ^= (i % 2 == 0 ? 1 : -1) * Parameters.ElementAt(i).GetHashCode();              }
Magic Number,MoreInternals.Model,Scope,C:\repos\kevin-montrose_More\MoreInternals\Model\Scope.cs,LookupMixin,The following statement contains a magic number: if (lookupDepth > 100)              {                  Current.RecordError(ErrorType.Compiler' InvocationSite' "Scope max depth exceeded' probably infinite recursion");                  throw new StoppedCompilingException();              }
Magic Number,MoreInternals.Model,Selector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,ParseRawChildSelector,The following statement contains a magic number: if (parts.Length == 2)              {                  Selector parent' child;                    if (parts.Count(c => c.Trim().Length > 0) == 2)                  {                      parent = ParseRawSelector(parts[0]' start' stop' filePath);                      child = ParseRawSelector(parts[1]' start' stop' filePath);                  }                  else                  {                      parent = null;                      child = ParseRawSelector(parts[1]' start' stop' filePath);                  }                    return new ChildSelector(parent' child' start' stop' filePath);              }
Magic Number,MoreInternals.Model,Selector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,ParseRawChildSelector,The following statement contains a magic number: if (parts.Length == 2)              {                  Selector parent' child;                    if (parts.Count(c => c.Trim().Length > 0) == 2)                  {                      parent = ParseRawSelector(parts[0]' start' stop' filePath);                      child = ParseRawSelector(parts[1]' start' stop' filePath);                  }                  else                  {                      parent = null;                      child = ParseRawSelector(parts[1]' start' stop' filePath);                  }                    return new ChildSelector(parent' child' start' stop' filePath);              }
Magic Number,MoreInternals.Model,Selector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,ParseRawSiblingSelector,The following statement contains a magic number: if (parts.Length != 2)              {                  Current.RecordError(ErrorType.Parser' Position.Create(start' stop' filePath)' "Sibling selectors can only have 2 components");                  throw new StoppedParsingException();              }
Magic Number,MoreInternals.Model,Selector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,BuildEscapeMap,The following statement contains a magic number: for (var i = 0; i < rawSelector.Length; i++)              {                  var c = rawSelector[i];                    if (c == '\\')                  {                      inEscape = true;                      escapeStarts = i;                      continue;                  }                    if (!inEscape)                  {                      cleaned.Add(c);                      continue;                  }                    // special character! (maybe!)                  if (!char.IsLetterOrDigit(c) && i == escapeStarts + 1)                  {                      var replacement = NextSpecialChar(ret.Keys' rawSelector);                        ret[replacement] = "\\" + c;                      cleaned.Add(replacement);                      inEscape = false;                      continue;                  }                    if (c == ' ' || (i - escapeStarts == 7))                  {                      var sequence = rawSelector.Substring(escapeStarts' i - escapeStarts + 1);                        var replacement = NextSpecialChar(ret.Keys' rawSelector);                        ret[replacement] = sequence;                        cleaned.Add(replacement);                      inEscape = false;                      continue;                  }              }
Magic Number,MoreInternals.Model,Selector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,ParseRawSelector,The following statement contains a magic number: for (int i = parts.Count - 2; i >= 0; i--)              {                  ret = CompoundSelector.CombineSelectors(parts[i]' ret' start' stop' filePath);              }
Magic Number,MoreInternals.Model,AttributeSelector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,Parse,The following statement contains a magic number: if (raw[i - 1] == '~')              {                  var contains = raw.Substring(0' i - 1);                    if (!IsStringAttributeValue(contains) && !Validation.IsIdentifier(contains))                  {                      Current.RecordError(ErrorType.Parser' Position.Create(start' stop' filePath)' "[" + contains + "] is not an identifier or string");                      throw new StoppedParsingException();                  }                    return new AttributeOperatorSelector(contains' AttributeOperator.Contains' raw.Substring(i - 1 + 2)' start' stop' filePath);              }
Magic Number,MoreInternals.Model,AttributeSelector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,Parse,The following statement contains a magic number: if (raw[i - 1] == '|')              {                  var starts = raw.Substring(0' i - 1);                    if (!IsStringAttributeValue(starts) && !Validation.IsIdentifier(starts))                  {                      Current.RecordError(ErrorType.Parser' Position.Create(start' stop' filePath)' "[" + starts + "] is not an identifier or string");                      throw new StoppedParsingException();                  }                    return new AttributeOperatorSelector(starts' AttributeOperator.Starts' raw.Substring(i - 1 + 2)' start' stop' filePath);              }
Magic Number,MoreInternals.Parser,MediaQueryParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MediaQueryParser.cs,ParseMediaClause,The following statement contains a magic number: media = media.Substring(1' media.Length - 2).Trim();
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The following statement contains a magic number: while (stream.HasMore() && !char.IsWhiteSpace(stream.Peek()))              {                  buffer.Append(stream.Read());                    if (buffer.Length == 3 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgb"' StringComparison.InvariantCultureIgnoreCase) || toDate.Equals("hsl"' StringComparison.InvariantCultureIgnoreCase))                      {                          var group = ParseGroup(stream' forPosition);                          var @params = group.Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 3)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            if(toDate == "rgb")                           {                              return                                  new RGBColorValue(                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                            if (toDate == "hsl")                          {                              return                                  new HSLColorValue                                  (                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                      }                        if (toDate.Equals("url"' StringComparison.InvariantCultureIgnoreCase))                      {                          var value = ParseGroup(stream' forPosition).Value;                            if(value is StringValue || value is QuotedStringValue)                          {                              return new UrlValue(value);                          }                            Current.RecordError(ErrorType.Parser' forPosition' "Expected string or quoted string");                          throw new StoppedParsingException();                      }                  }                    if (buffer.Length == 4 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgba"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 4 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            return                              new RGBAColorValue(                                  @params.Values.ElementAt(0)'                                  @params.Values.ElementAt(1)'                                  @params.Values.ElementAt(2)'                                  @params.Values.ElementAt(3)                              );                      }                        if (toDate.Equals("attr"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            Value attrAndType' attr' type' fallback;                            var comma = @params as CommaDelimittedValue;                          if (comma != null)                          {                              if (comma.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects 1 or 2 parameters' found " + comma);                                  throw new StoppedParsingException();                              }                                attrAndType = comma.Values.ElementAt(0);                                fallback = comma.Values.Count() == 2 ? comma.Values.ElementAt(1) : null;                          }                          else                          {                              attrAndType = @params;                              fallback = null;                          }                            var compound = attrAndType as CompoundValue;                          if (compound != null)                          {                              if (compound.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects an attribute name and optionally a type' found " + compound);                                  throw new StoppedParsingException();                              }                                attr = compound.Values.ElementAt(0);                              type = compound.Values.Count() == 2 ? compound.Values.ElementAt(1) : null;                          }                          else                          {                              attr = attrAndType;                              type = null;                          }                            return new AttributeValue(attr' type' fallback);                      }                        if (toDate.Equals("calc"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            if (@params is CommaDelimittedValue)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "calc expects an expression' found " + @params);                          }                            string strVersion;                          using(var writer = new StringWriter())                          {                              @params.Write(writer);                              strVersion = writer.ToString();                          }                            // Things passed to calc are opting out of More magic' they don't get anything but in string replacements                          return new CalcValue(new StringValue(strVersion));                      }                  }                    if (buffer.Length == 5 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("local"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to local() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new LocalValue(val);                      }                        if (toDate.Equals("cycle"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var param = new List<Value>();                            var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              param.AddRange(comma.Values);                          }                          else                          {                              param.Add(val);                          }                            return new CycleValue(param);                      }                        if (toDate.Equals("steps"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to steps() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var steps = comma != null ? comma.Values.ElementAt(0) : val;                          var dir = comma != null ? comma.Values.ElementAt(1) : null;                            return new StepsValue(steps' dir);                      }                  }                    if (buffer.Length == 6 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("format"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to format() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new FormatValue(val);                      }                  }                    if (buffer.Length == 7 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counter"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counter() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CounterValue(counter' style);                      }                  }                    if (buffer.Length == 8 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counters"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counters() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CountersValue(counter' style);                      }                  }                    if (buffer.Length == 12 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("cubic-bezier"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma == null || comma.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Excepted 4 parameters to cubic-bezier()");                              throw new StoppedParsingException();                          }                            return                              new CubicBezierValue(                                  comma.Values.ElementAt(0)'                                  comma.Values.ElementAt(1)'                                  comma.Values.ElementAt(2)'                                  comma.Values.ElementAt(3)                              );                      }                  }                    if (buffer.Length == 15 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("linear-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "linear-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new LinearGradientValue(comma.Values);                      }                        if (toDate.Equals("radial-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "radial-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new RadialGradientValue(comma.Values);                      }                  }              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The following statement contains a magic number: while (stream.HasMore() && !char.IsWhiteSpace(stream.Peek()))              {                  buffer.Append(stream.Read());                    if (buffer.Length == 3 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgb"' StringComparison.InvariantCultureIgnoreCase) || toDate.Equals("hsl"' StringComparison.InvariantCultureIgnoreCase))                      {                          var group = ParseGroup(stream' forPosition);                          var @params = group.Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 3)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            if(toDate == "rgb")                           {                              return                                  new RGBColorValue(                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                            if (toDate == "hsl")                          {                              return                                  new HSLColorValue                                  (                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                      }                        if (toDate.Equals("url"' StringComparison.InvariantCultureIgnoreCase))                      {                          var value = ParseGroup(stream' forPosition).Value;                            if(value is StringValue || value is QuotedStringValue)                          {                              return new UrlValue(value);                          }                            Current.RecordError(ErrorType.Parser' forPosition' "Expected string or quoted string");                          throw new StoppedParsingException();                      }                  }                    if (buffer.Length == 4 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgba"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 4 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            return                              new RGBAColorValue(                                  @params.Values.ElementAt(0)'                                  @params.Values.ElementAt(1)'                                  @params.Values.ElementAt(2)'                                  @params.Values.ElementAt(3)                              );                      }                        if (toDate.Equals("attr"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            Value attrAndType' attr' type' fallback;                            var comma = @params as CommaDelimittedValue;                          if (comma != null)                          {                              if (comma.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects 1 or 2 parameters' found " + comma);                                  throw new StoppedParsingException();                              }                                attrAndType = comma.Values.ElementAt(0);                                fallback = comma.Values.Count() == 2 ? comma.Values.ElementAt(1) : null;                          }                          else                          {                              attrAndType = @params;                              fallback = null;                          }                            var compound = attrAndType as CompoundValue;                          if (compound != null)                          {                              if (compound.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects an attribute name and optionally a type' found " + compound);                                  throw new StoppedParsingException();                              }                                attr = compound.Values.ElementAt(0);                              type = compound.Values.Count() == 2 ? compound.Values.ElementAt(1) : null;                          }                          else                          {                              attr = attrAndType;                              type = null;                          }                            return new AttributeValue(attr' type' fallback);                      }                        if (toDate.Equals("calc"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            if (@params is CommaDelimittedValue)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "calc expects an expression' found " + @params);                          }                            string strVersion;                          using(var writer = new StringWriter())                          {                              @params.Write(writer);                              strVersion = writer.ToString();                          }                            // Things passed to calc are opting out of More magic' they don't get anything but in string replacements                          return new CalcValue(new StringValue(strVersion));                      }                  }                    if (buffer.Length == 5 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("local"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to local() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new LocalValue(val);                      }                        if (toDate.Equals("cycle"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var param = new List<Value>();                            var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              param.AddRange(comma.Values);                          }                          else                          {                              param.Add(val);                          }                            return new CycleValue(param);                      }                        if (toDate.Equals("steps"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to steps() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var steps = comma != null ? comma.Values.ElementAt(0) : val;                          var dir = comma != null ? comma.Values.ElementAt(1) : null;                            return new StepsValue(steps' dir);                      }                  }                    if (buffer.Length == 6 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("format"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to format() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new FormatValue(val);                      }                  }                    if (buffer.Length == 7 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counter"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counter() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CounterValue(counter' style);                      }                  }                    if (buffer.Length == 8 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counters"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counters() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CountersValue(counter' style);                      }                  }                    if (buffer.Length == 12 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("cubic-bezier"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma == null || comma.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Excepted 4 parameters to cubic-bezier()");                              throw new StoppedParsingException();                          }                            return                              new CubicBezierValue(                                  comma.Values.ElementAt(0)'                                  comma.Values.ElementAt(1)'                                  comma.Values.ElementAt(2)'                                  comma.Values.ElementAt(3)                              );                      }                  }                    if (buffer.Length == 15 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("linear-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "linear-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new LinearGradientValue(comma.Values);                      }                        if (toDate.Equals("radial-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "radial-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new RadialGradientValue(comma.Values);                      }                  }              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The following statement contains a magic number: while (stream.HasMore() && !char.IsWhiteSpace(stream.Peek()))              {                  buffer.Append(stream.Read());                    if (buffer.Length == 3 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgb"' StringComparison.InvariantCultureIgnoreCase) || toDate.Equals("hsl"' StringComparison.InvariantCultureIgnoreCase))                      {                          var group = ParseGroup(stream' forPosition);                          var @params = group.Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 3)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            if(toDate == "rgb")                           {                              return                                  new RGBColorValue(                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                            if (toDate == "hsl")                          {                              return                                  new HSLColorValue                                  (                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                      }                        if (toDate.Equals("url"' StringComparison.InvariantCultureIgnoreCase))                      {                          var value = ParseGroup(stream' forPosition).Value;                            if(value is StringValue || value is QuotedStringValue)                          {                              return new UrlValue(value);                          }                            Current.RecordError(ErrorType.Parser' forPosition' "Expected string or quoted string");                          throw new StoppedParsingException();                      }                  }                    if (buffer.Length == 4 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgba"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 4 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            return                              new RGBAColorValue(                                  @params.Values.ElementAt(0)'                                  @params.Values.ElementAt(1)'                                  @params.Values.ElementAt(2)'                                  @params.Values.ElementAt(3)                              );                      }                        if (toDate.Equals("attr"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            Value attrAndType' attr' type' fallback;                            var comma = @params as CommaDelimittedValue;                          if (comma != null)                          {                              if (comma.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects 1 or 2 parameters' found " + comma);                                  throw new StoppedParsingException();                              }                                attrAndType = comma.Values.ElementAt(0);                                fallback = comma.Values.Count() == 2 ? comma.Values.ElementAt(1) : null;                          }                          else                          {                              attrAndType = @params;                              fallback = null;                          }                            var compound = attrAndType as CompoundValue;                          if (compound != null)                          {                              if (compound.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects an attribute name and optionally a type' found " + compound);                                  throw new StoppedParsingException();                              }                                attr = compound.Values.ElementAt(0);                              type = compound.Values.Count() == 2 ? compound.Values.ElementAt(1) : null;                          }                          else                          {                              attr = attrAndType;                              type = null;                          }                            return new AttributeValue(attr' type' fallback);                      }                        if (toDate.Equals("calc"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            if (@params is CommaDelimittedValue)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "calc expects an expression' found " + @params);                          }                            string strVersion;                          using(var writer = new StringWriter())                          {                              @params.Write(writer);                              strVersion = writer.ToString();                          }                            // Things passed to calc are opting out of More magic' they don't get anything but in string replacements                          return new CalcValue(new StringValue(strVersion));                      }                  }                    if (buffer.Length == 5 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("local"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to local() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new LocalValue(val);                      }                        if (toDate.Equals("cycle"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var param = new List<Value>();                            var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              param.AddRange(comma.Values);                          }                          else                          {                              param.Add(val);                          }                            return new CycleValue(param);                      }                        if (toDate.Equals("steps"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to steps() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var steps = comma != null ? comma.Values.ElementAt(0) : val;                          var dir = comma != null ? comma.Values.ElementAt(1) : null;                            return new StepsValue(steps' dir);                      }                  }                    if (buffer.Length == 6 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("format"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to format() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new FormatValue(val);                      }                  }                    if (buffer.Length == 7 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counter"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counter() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CounterValue(counter' style);                      }                  }                    if (buffer.Length == 8 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counters"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counters() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CountersValue(counter' style);                      }                  }                    if (buffer.Length == 12 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("cubic-bezier"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma == null || comma.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Excepted 4 parameters to cubic-bezier()");                              throw new StoppedParsingException();                          }                            return                              new CubicBezierValue(                                  comma.Values.ElementAt(0)'                                  comma.Values.ElementAt(1)'                                  comma.Values.ElementAt(2)'                                  comma.Values.ElementAt(3)                              );                      }                  }                    if (buffer.Length == 15 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("linear-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "linear-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new LinearGradientValue(comma.Values);                      }                        if (toDate.Equals("radial-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "radial-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new RadialGradientValue(comma.Values);                      }                  }              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The following statement contains a magic number: while (stream.HasMore() && !char.IsWhiteSpace(stream.Peek()))              {                  buffer.Append(stream.Read());                    if (buffer.Length == 3 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgb"' StringComparison.InvariantCultureIgnoreCase) || toDate.Equals("hsl"' StringComparison.InvariantCultureIgnoreCase))                      {                          var group = ParseGroup(stream' forPosition);                          var @params = group.Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 3)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            if(toDate == "rgb")                           {                              return                                  new RGBColorValue(                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                            if (toDate == "hsl")                          {                              return                                  new HSLColorValue                                  (                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                      }                        if (toDate.Equals("url"' StringComparison.InvariantCultureIgnoreCase))                      {                          var value = ParseGroup(stream' forPosition).Value;                            if(value is StringValue || value is QuotedStringValue)                          {                              return new UrlValue(value);                          }                            Current.RecordError(ErrorType.Parser' forPosition' "Expected string or quoted string");                          throw new StoppedParsingException();                      }                  }                    if (buffer.Length == 4 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgba"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 4 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            return                              new RGBAColorValue(                                  @params.Values.ElementAt(0)'                                  @params.Values.ElementAt(1)'                                  @params.Values.ElementAt(2)'                                  @params.Values.ElementAt(3)                              );                      }                        if (toDate.Equals("attr"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            Value attrAndType' attr' type' fallback;                            var comma = @params as CommaDelimittedValue;                          if (comma != null)                          {                              if (comma.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects 1 or 2 parameters' found " + comma);                                  throw new StoppedParsingException();                              }                                attrAndType = comma.Values.ElementAt(0);                                fallback = comma.Values.Count() == 2 ? comma.Values.ElementAt(1) : null;                          }                          else                          {                              attrAndType = @params;                              fallback = null;                          }                            var compound = attrAndType as CompoundValue;                          if (compound != null)                          {                              if (compound.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects an attribute name and optionally a type' found " + compound);                                  throw new StoppedParsingException();                              }                                attr = compound.Values.ElementAt(0);                              type = compound.Values.Count() == 2 ? compound.Values.ElementAt(1) : null;                          }                          else                          {                              attr = attrAndType;                              type = null;                          }                            return new AttributeValue(attr' type' fallback);                      }                        if (toDate.Equals("calc"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            if (@params is CommaDelimittedValue)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "calc expects an expression' found " + @params);                          }                            string strVersion;                          using(var writer = new StringWriter())                          {                              @params.Write(writer);                              strVersion = writer.ToString();                          }                            // Things passed to calc are opting out of More magic' they don't get anything but in string replacements                          return new CalcValue(new StringValue(strVersion));                      }                  }                    if (buffer.Length == 5 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("local"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to local() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new LocalValue(val);                      }                        if (toDate.Equals("cycle"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var param = new List<Value>();                            var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              param.AddRange(comma.Values);                          }                          else                          {                              param.Add(val);                          }                            return new CycleValue(param);                      }                        if (toDate.Equals("steps"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to steps() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var steps = comma != null ? comma.Values.ElementAt(0) : val;                          var dir = comma != null ? comma.Values.ElementAt(1) : null;                            return new StepsValue(steps' dir);                      }                  }                    if (buffer.Length == 6 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("format"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to format() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new FormatValue(val);                      }                  }                    if (buffer.Length == 7 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counter"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counter() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CounterValue(counter' style);                      }                  }                    if (buffer.Length == 8 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counters"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counters() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CountersValue(counter' style);                      }                  }                    if (buffer.Length == 12 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("cubic-bezier"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma == null || comma.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Excepted 4 parameters to cubic-bezier()");                              throw new StoppedParsingException();                          }                            return                              new CubicBezierValue(                                  comma.Values.ElementAt(0)'                                  comma.Values.ElementAt(1)'                                  comma.Values.ElementAt(2)'                                  comma.Values.ElementAt(3)                              );                      }                  }                    if (buffer.Length == 15 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("linear-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "linear-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new LinearGradientValue(comma.Values);                      }                        if (toDate.Equals("radial-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "radial-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new RadialGradientValue(comma.Values);                      }                  }              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The following statement contains a magic number: while (stream.HasMore() && !char.IsWhiteSpace(stream.Peek()))              {                  buffer.Append(stream.Read());                    if (buffer.Length == 3 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgb"' StringComparison.InvariantCultureIgnoreCase) || toDate.Equals("hsl"' StringComparison.InvariantCultureIgnoreCase))                      {                          var group = ParseGroup(stream' forPosition);                          var @params = group.Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 3)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            if(toDate == "rgb")                           {                              return                                  new RGBColorValue(                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                            if (toDate == "hsl")                          {                              return                                  new HSLColorValue                                  (                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                      }                        if (toDate.Equals("url"' StringComparison.InvariantCultureIgnoreCase))                      {                          var value = ParseGroup(stream' forPosition).Value;                            if(value is StringValue || value is QuotedStringValue)                          {                              return new UrlValue(value);                          }                            Current.RecordError(ErrorType.Parser' forPosition' "Expected string or quoted string");                          throw new StoppedParsingException();                      }                  }                    if (buffer.Length == 4 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgba"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 4 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            return                              new RGBAColorValue(                                  @params.Values.ElementAt(0)'                                  @params.Values.ElementAt(1)'                                  @params.Values.ElementAt(2)'                                  @params.Values.ElementAt(3)                              );                      }                        if (toDate.Equals("attr"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            Value attrAndType' attr' type' fallback;                            var comma = @params as CommaDelimittedValue;                          if (comma != null)                          {                              if (comma.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects 1 or 2 parameters' found " + comma);                                  throw new StoppedParsingException();                              }                                attrAndType = comma.Values.ElementAt(0);                                fallback = comma.Values.Count() == 2 ? comma.Values.ElementAt(1) : null;                          }                          else                          {                              attrAndType = @params;                              fallback = null;                          }                            var compound = attrAndType as CompoundValue;                          if (compound != null)                          {                              if (compound.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects an attribute name and optionally a type' found " + compound);                                  throw new StoppedParsingException();                              }                                attr = compound.Values.ElementAt(0);                              type = compound.Values.Count() == 2 ? compound.Values.ElementAt(1) : null;                          }                          else                          {                              attr = attrAndType;                              type = null;                          }                            return new AttributeValue(attr' type' fallback);                      }                        if (toDate.Equals("calc"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            if (@params is CommaDelimittedValue)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "calc expects an expression' found " + @params);                          }                            string strVersion;                          using(var writer = new StringWriter())                          {                              @params.Write(writer);                              strVersion = writer.ToString();                          }                            // Things passed to calc are opting out of More magic' they don't get anything but in string replacements                          return new CalcValue(new StringValue(strVersion));                      }                  }                    if (buffer.Length == 5 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("local"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to local() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new LocalValue(val);                      }                        if (toDate.Equals("cycle"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var param = new List<Value>();                            var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              param.AddRange(comma.Values);                          }                          else                          {                              param.Add(val);                          }                            return new CycleValue(param);                      }                        if (toDate.Equals("steps"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to steps() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var steps = comma != null ? comma.Values.ElementAt(0) : val;                          var dir = comma != null ? comma.Values.ElementAt(1) : null;                            return new StepsValue(steps' dir);                      }                  }                    if (buffer.Length == 6 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("format"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to format() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new FormatValue(val);                      }                  }                    if (buffer.Length == 7 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counter"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counter() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CounterValue(counter' style);                      }                  }                    if (buffer.Length == 8 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counters"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counters() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CountersValue(counter' style);                      }                  }                    if (buffer.Length == 12 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("cubic-bezier"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma == null || comma.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Excepted 4 parameters to cubic-bezier()");                              throw new StoppedParsingException();                          }                            return                              new CubicBezierValue(                                  comma.Values.ElementAt(0)'                                  comma.Values.ElementAt(1)'                                  comma.Values.ElementAt(2)'                                  comma.Values.ElementAt(3)                              );                      }                  }                    if (buffer.Length == 15 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("linear-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "linear-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new LinearGradientValue(comma.Values);                      }                        if (toDate.Equals("radial-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "radial-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new RadialGradientValue(comma.Values);                      }                  }              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The following statement contains a magic number: while (stream.HasMore() && !char.IsWhiteSpace(stream.Peek()))              {                  buffer.Append(stream.Read());                    if (buffer.Length == 3 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgb"' StringComparison.InvariantCultureIgnoreCase) || toDate.Equals("hsl"' StringComparison.InvariantCultureIgnoreCase))                      {                          var group = ParseGroup(stream' forPosition);                          var @params = group.Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 3)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            if(toDate == "rgb")                           {                              return                                  new RGBColorValue(                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                            if (toDate == "hsl")                          {                              return                                  new HSLColorValue                                  (                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                      }                        if (toDate.Equals("url"' StringComparison.InvariantCultureIgnoreCase))                      {                          var value = ParseGroup(stream' forPosition).Value;                            if(value is StringValue || value is QuotedStringValue)                          {                              return new UrlValue(value);                          }                            Current.RecordError(ErrorType.Parser' forPosition' "Expected string or quoted string");                          throw new StoppedParsingException();                      }                  }                    if (buffer.Length == 4 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgba"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 4 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            return                              new RGBAColorValue(                                  @params.Values.ElementAt(0)'                                  @params.Values.ElementAt(1)'                                  @params.Values.ElementAt(2)'                                  @params.Values.ElementAt(3)                              );                      }                        if (toDate.Equals("attr"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            Value attrAndType' attr' type' fallback;                            var comma = @params as CommaDelimittedValue;                          if (comma != null)                          {                              if (comma.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects 1 or 2 parameters' found " + comma);                                  throw new StoppedParsingException();                              }                                attrAndType = comma.Values.ElementAt(0);                                fallback = comma.Values.Count() == 2 ? comma.Values.ElementAt(1) : null;                          }                          else                          {                              attrAndType = @params;                              fallback = null;                          }                            var compound = attrAndType as CompoundValue;                          if (compound != null)                          {                              if (compound.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects an attribute name and optionally a type' found " + compound);                                  throw new StoppedParsingException();                              }                                attr = compound.Values.ElementAt(0);                              type = compound.Values.Count() == 2 ? compound.Values.ElementAt(1) : null;                          }                          else                          {                              attr = attrAndType;                              type = null;                          }                            return new AttributeValue(attr' type' fallback);                      }                        if (toDate.Equals("calc"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            if (@params is CommaDelimittedValue)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "calc expects an expression' found " + @params);                          }                            string strVersion;                          using(var writer = new StringWriter())                          {                              @params.Write(writer);                              strVersion = writer.ToString();                          }                            // Things passed to calc are opting out of More magic' they don't get anything but in string replacements                          return new CalcValue(new StringValue(strVersion));                      }                  }                    if (buffer.Length == 5 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("local"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to local() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new LocalValue(val);                      }                        if (toDate.Equals("cycle"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var param = new List<Value>();                            var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              param.AddRange(comma.Values);                          }                          else                          {                              param.Add(val);                          }                            return new CycleValue(param);                      }                        if (toDate.Equals("steps"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to steps() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var steps = comma != null ? comma.Values.ElementAt(0) : val;                          var dir = comma != null ? comma.Values.ElementAt(1) : null;                            return new StepsValue(steps' dir);                      }                  }                    if (buffer.Length == 6 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("format"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to format() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new FormatValue(val);                      }                  }                    if (buffer.Length == 7 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counter"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counter() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CounterValue(counter' style);                      }                  }                    if (buffer.Length == 8 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counters"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counters() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CountersValue(counter' style);                      }                  }                    if (buffer.Length == 12 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("cubic-bezier"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma == null || comma.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Excepted 4 parameters to cubic-bezier()");                              throw new StoppedParsingException();                          }                            return                              new CubicBezierValue(                                  comma.Values.ElementAt(0)'                                  comma.Values.ElementAt(1)'                                  comma.Values.ElementAt(2)'                                  comma.Values.ElementAt(3)                              );                      }                  }                    if (buffer.Length == 15 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("linear-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "linear-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new LinearGradientValue(comma.Values);                      }                        if (toDate.Equals("radial-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "radial-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new RadialGradientValue(comma.Values);                      }                  }              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The following statement contains a magic number: while (stream.HasMore() && !char.IsWhiteSpace(stream.Peek()))              {                  buffer.Append(stream.Read());                    if (buffer.Length == 3 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgb"' StringComparison.InvariantCultureIgnoreCase) || toDate.Equals("hsl"' StringComparison.InvariantCultureIgnoreCase))                      {                          var group = ParseGroup(stream' forPosition);                          var @params = group.Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 3)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            if(toDate == "rgb")                           {                              return                                  new RGBColorValue(                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                            if (toDate == "hsl")                          {                              return                                  new HSLColorValue                                  (                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                      }                        if (toDate.Equals("url"' StringComparison.InvariantCultureIgnoreCase))                      {                          var value = ParseGroup(stream' forPosition).Value;                            if(value is StringValue || value is QuotedStringValue)                          {                              return new UrlValue(value);                          }                            Current.RecordError(ErrorType.Parser' forPosition' "Expected string or quoted string");                          throw new StoppedParsingException();                      }                  }                    if (buffer.Length == 4 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgba"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 4 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            return                              new RGBAColorValue(                                  @params.Values.ElementAt(0)'                                  @params.Values.ElementAt(1)'                                  @params.Values.ElementAt(2)'                                  @params.Values.ElementAt(3)                              );                      }                        if (toDate.Equals("attr"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            Value attrAndType' attr' type' fallback;                            var comma = @params as CommaDelimittedValue;                          if (comma != null)                          {                              if (comma.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects 1 or 2 parameters' found " + comma);                                  throw new StoppedParsingException();                              }                                attrAndType = comma.Values.ElementAt(0);                                fallback = comma.Values.Count() == 2 ? comma.Values.ElementAt(1) : null;                          }                          else                          {                              attrAndType = @params;                              fallback = null;                          }                            var compound = attrAndType as CompoundValue;                          if (compound != null)                          {                              if (compound.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects an attribute name and optionally a type' found " + compound);                                  throw new StoppedParsingException();                              }                                attr = compound.Values.ElementAt(0);                              type = compound.Values.Count() == 2 ? compound.Values.ElementAt(1) : null;                          }                          else                          {                              attr = attrAndType;                              type = null;                          }                            return new AttributeValue(attr' type' fallback);                      }                        if (toDate.Equals("calc"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            if (@params is CommaDelimittedValue)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "calc expects an expression' found " + @params);                          }                            string strVersion;                          using(var writer = new StringWriter())                          {                              @params.Write(writer);                              strVersion = writer.ToString();                          }                            // Things passed to calc are opting out of More magic' they don't get anything but in string replacements                          return new CalcValue(new StringValue(strVersion));                      }                  }                    if (buffer.Length == 5 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("local"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to local() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new LocalValue(val);                      }                        if (toDate.Equals("cycle"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var param = new List<Value>();                            var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              param.AddRange(comma.Values);                          }                          else                          {                              param.Add(val);                          }                            return new CycleValue(param);                      }                        if (toDate.Equals("steps"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to steps() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var steps = comma != null ? comma.Values.ElementAt(0) : val;                          var dir = comma != null ? comma.Values.ElementAt(1) : null;                            return new StepsValue(steps' dir);                      }                  }                    if (buffer.Length == 6 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("format"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to format() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new FormatValue(val);                      }                  }                    if (buffer.Length == 7 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counter"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counter() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CounterValue(counter' style);                      }                  }                    if (buffer.Length == 8 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counters"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counters() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CountersValue(counter' style);                      }                  }                    if (buffer.Length == 12 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("cubic-bezier"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma == null || comma.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Excepted 4 parameters to cubic-bezier()");                              throw new StoppedParsingException();                          }                            return                              new CubicBezierValue(                                  comma.Values.ElementAt(0)'                                  comma.Values.ElementAt(1)'                                  comma.Values.ElementAt(2)'                                  comma.Values.ElementAt(3)                              );                      }                  }                    if (buffer.Length == 15 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("linear-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "linear-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new LinearGradientValue(comma.Values);                      }                        if (toDate.Equals("radial-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "radial-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new RadialGradientValue(comma.Values);                      }                  }              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The following statement contains a magic number: while (stream.HasMore() && !char.IsWhiteSpace(stream.Peek()))              {                  buffer.Append(stream.Read());                    if (buffer.Length == 3 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgb"' StringComparison.InvariantCultureIgnoreCase) || toDate.Equals("hsl"' StringComparison.InvariantCultureIgnoreCase))                      {                          var group = ParseGroup(stream' forPosition);                          var @params = group.Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 3)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            if(toDate == "rgb")                           {                              return                                  new RGBColorValue(                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                            if (toDate == "hsl")                          {                              return                                  new HSLColorValue                                  (                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                      }                        if (toDate.Equals("url"' StringComparison.InvariantCultureIgnoreCase))                      {                          var value = ParseGroup(stream' forPosition).Value;                            if(value is StringValue || value is QuotedStringValue)                          {                              return new UrlValue(value);                          }                            Current.RecordError(ErrorType.Parser' forPosition' "Expected string or quoted string");                          throw new StoppedParsingException();                      }                  }                    if (buffer.Length == 4 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgba"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 4 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            return                              new RGBAColorValue(                                  @params.Values.ElementAt(0)'                                  @params.Values.ElementAt(1)'                                  @params.Values.ElementAt(2)'                                  @params.Values.ElementAt(3)                              );                      }                        if (toDate.Equals("attr"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            Value attrAndType' attr' type' fallback;                            var comma = @params as CommaDelimittedValue;                          if (comma != null)                          {                              if (comma.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects 1 or 2 parameters' found " + comma);                                  throw new StoppedParsingException();                              }                                attrAndType = comma.Values.ElementAt(0);                                fallback = comma.Values.Count() == 2 ? comma.Values.ElementAt(1) : null;                          }                          else                          {                              attrAndType = @params;                              fallback = null;                          }                            var compound = attrAndType as CompoundValue;                          if (compound != null)                          {                              if (compound.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects an attribute name and optionally a type' found " + compound);                                  throw new StoppedParsingException();                              }                                attr = compound.Values.ElementAt(0);                              type = compound.Values.Count() == 2 ? compound.Values.ElementAt(1) : null;                          }                          else                          {                              attr = attrAndType;                              type = null;                          }                            return new AttributeValue(attr' type' fallback);                      }                        if (toDate.Equals("calc"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            if (@params is CommaDelimittedValue)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "calc expects an expression' found " + @params);                          }                            string strVersion;                          using(var writer = new StringWriter())                          {                              @params.Write(writer);                              strVersion = writer.ToString();                          }                            // Things passed to calc are opting out of More magic' they don't get anything but in string replacements                          return new CalcValue(new StringValue(strVersion));                      }                  }                    if (buffer.Length == 5 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("local"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to local() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new LocalValue(val);                      }                        if (toDate.Equals("cycle"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var param = new List<Value>();                            var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              param.AddRange(comma.Values);                          }                          else                          {                              param.Add(val);                          }                            return new CycleValue(param);                      }                        if (toDate.Equals("steps"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to steps() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var steps = comma != null ? comma.Values.ElementAt(0) : val;                          var dir = comma != null ? comma.Values.ElementAt(1) : null;                            return new StepsValue(steps' dir);                      }                  }                    if (buffer.Length == 6 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("format"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to format() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new FormatValue(val);                      }                  }                    if (buffer.Length == 7 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counter"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counter() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CounterValue(counter' style);                      }                  }                    if (buffer.Length == 8 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counters"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counters() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CountersValue(counter' style);                      }                  }                    if (buffer.Length == 12 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("cubic-bezier"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma == null || comma.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Excepted 4 parameters to cubic-bezier()");                              throw new StoppedParsingException();                          }                            return                              new CubicBezierValue(                                  comma.Values.ElementAt(0)'                                  comma.Values.ElementAt(1)'                                  comma.Values.ElementAt(2)'                                  comma.Values.ElementAt(3)                              );                      }                  }                    if (buffer.Length == 15 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("linear-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "linear-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new LinearGradientValue(comma.Values);                      }                        if (toDate.Equals("radial-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "radial-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new RadialGradientValue(comma.Values);                      }                  }              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The following statement contains a magic number: while (stream.HasMore() && !char.IsWhiteSpace(stream.Peek()))              {                  buffer.Append(stream.Read());                    if (buffer.Length == 3 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgb"' StringComparison.InvariantCultureIgnoreCase) || toDate.Equals("hsl"' StringComparison.InvariantCultureIgnoreCase))                      {                          var group = ParseGroup(stream' forPosition);                          var @params = group.Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 3)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            if(toDate == "rgb")                           {                              return                                  new RGBColorValue(                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                            if (toDate == "hsl")                          {                              return                                  new HSLColorValue                                  (                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                      }                        if (toDate.Equals("url"' StringComparison.InvariantCultureIgnoreCase))                      {                          var value = ParseGroup(stream' forPosition).Value;                            if(value is StringValue || value is QuotedStringValue)                          {                              return new UrlValue(value);                          }                            Current.RecordError(ErrorType.Parser' forPosition' "Expected string or quoted string");                          throw new StoppedParsingException();                      }                  }                    if (buffer.Length == 4 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgba"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 4 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            return                              new RGBAColorValue(                                  @params.Values.ElementAt(0)'                                  @params.Values.ElementAt(1)'                                  @params.Values.ElementAt(2)'                                  @params.Values.ElementAt(3)                              );                      }                        if (toDate.Equals("attr"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            Value attrAndType' attr' type' fallback;                            var comma = @params as CommaDelimittedValue;                          if (comma != null)                          {                              if (comma.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects 1 or 2 parameters' found " + comma);                                  throw new StoppedParsingException();                              }                                attrAndType = comma.Values.ElementAt(0);                                fallback = comma.Values.Count() == 2 ? comma.Values.ElementAt(1) : null;                          }                          else                          {                              attrAndType = @params;                              fallback = null;                          }                            var compound = attrAndType as CompoundValue;                          if (compound != null)                          {                              if (compound.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects an attribute name and optionally a type' found " + compound);                                  throw new StoppedParsingException();                              }                                attr = compound.Values.ElementAt(0);                              type = compound.Values.Count() == 2 ? compound.Values.ElementAt(1) : null;                          }                          else                          {                              attr = attrAndType;                              type = null;                          }                            return new AttributeValue(attr' type' fallback);                      }                        if (toDate.Equals("calc"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            if (@params is CommaDelimittedValue)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "calc expects an expression' found " + @params);                          }                            string strVersion;                          using(var writer = new StringWriter())                          {                              @params.Write(writer);                              strVersion = writer.ToString();                          }                            // Things passed to calc are opting out of More magic' they don't get anything but in string replacements                          return new CalcValue(new StringValue(strVersion));                      }                  }                    if (buffer.Length == 5 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("local"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to local() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new LocalValue(val);                      }                        if (toDate.Equals("cycle"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var param = new List<Value>();                            var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              param.AddRange(comma.Values);                          }                          else                          {                              param.Add(val);                          }                            return new CycleValue(param);                      }                        if (toDate.Equals("steps"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to steps() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var steps = comma != null ? comma.Values.ElementAt(0) : val;                          var dir = comma != null ? comma.Values.ElementAt(1) : null;                            return new StepsValue(steps' dir);                      }                  }                    if (buffer.Length == 6 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("format"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to format() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new FormatValue(val);                      }                  }                    if (buffer.Length == 7 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counter"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counter() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CounterValue(counter' style);                      }                  }                    if (buffer.Length == 8 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counters"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counters() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CountersValue(counter' style);                      }                  }                    if (buffer.Length == 12 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("cubic-bezier"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma == null || comma.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Excepted 4 parameters to cubic-bezier()");                              throw new StoppedParsingException();                          }                            return                              new CubicBezierValue(                                  comma.Values.ElementAt(0)'                                  comma.Values.ElementAt(1)'                                  comma.Values.ElementAt(2)'                                  comma.Values.ElementAt(3)                              );                      }                  }                    if (buffer.Length == 15 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("linear-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "linear-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new LinearGradientValue(comma.Values);                      }                        if (toDate.Equals("radial-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "radial-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new RadialGradientValue(comma.Values);                      }                  }              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The following statement contains a magic number: while (stream.HasMore() && !char.IsWhiteSpace(stream.Peek()))              {                  buffer.Append(stream.Read());                    if (buffer.Length == 3 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgb"' StringComparison.InvariantCultureIgnoreCase) || toDate.Equals("hsl"' StringComparison.InvariantCultureIgnoreCase))                      {                          var group = ParseGroup(stream' forPosition);                          var @params = group.Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 3)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            if(toDate == "rgb")                           {                              return                                  new RGBColorValue(                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                            if (toDate == "hsl")                          {                              return                                  new HSLColorValue                                  (                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                      }                        if (toDate.Equals("url"' StringComparison.InvariantCultureIgnoreCase))                      {                          var value = ParseGroup(stream' forPosition).Value;                            if(value is StringValue || value is QuotedStringValue)                          {                              return new UrlValue(value);                          }                            Current.RecordError(ErrorType.Parser' forPosition' "Expected string or quoted string");                          throw new StoppedParsingException();                      }                  }                    if (buffer.Length == 4 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgba"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 4 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            return                              new RGBAColorValue(                                  @params.Values.ElementAt(0)'                                  @params.Values.ElementAt(1)'                                  @params.Values.ElementAt(2)'                                  @params.Values.ElementAt(3)                              );                      }                        if (toDate.Equals("attr"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            Value attrAndType' attr' type' fallback;                            var comma = @params as CommaDelimittedValue;                          if (comma != null)                          {                              if (comma.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects 1 or 2 parameters' found " + comma);                                  throw new StoppedParsingException();                              }                                attrAndType = comma.Values.ElementAt(0);                                fallback = comma.Values.Count() == 2 ? comma.Values.ElementAt(1) : null;                          }                          else                          {                              attrAndType = @params;                              fallback = null;                          }                            var compound = attrAndType as CompoundValue;                          if (compound != null)                          {                              if (compound.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects an attribute name and optionally a type' found " + compound);                                  throw new StoppedParsingException();                              }                                attr = compound.Values.ElementAt(0);                              type = compound.Values.Count() == 2 ? compound.Values.ElementAt(1) : null;                          }                          else                          {                              attr = attrAndType;                              type = null;                          }                            return new AttributeValue(attr' type' fallback);                      }                        if (toDate.Equals("calc"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            if (@params is CommaDelimittedValue)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "calc expects an expression' found " + @params);                          }                            string strVersion;                          using(var writer = new StringWriter())                          {                              @params.Write(writer);                              strVersion = writer.ToString();                          }                            // Things passed to calc are opting out of More magic' they don't get anything but in string replacements                          return new CalcValue(new StringValue(strVersion));                      }                  }                    if (buffer.Length == 5 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("local"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to local() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new LocalValue(val);                      }                        if (toDate.Equals("cycle"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var param = new List<Value>();                            var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              param.AddRange(comma.Values);                          }                          else                          {                              param.Add(val);                          }                            return new CycleValue(param);                      }                        if (toDate.Equals("steps"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to steps() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var steps = comma != null ? comma.Values.ElementAt(0) : val;                          var dir = comma != null ? comma.Values.ElementAt(1) : null;                            return new StepsValue(steps' dir);                      }                  }                    if (buffer.Length == 6 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("format"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to format() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new FormatValue(val);                      }                  }                    if (buffer.Length == 7 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counter"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counter() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CounterValue(counter' style);                      }                  }                    if (buffer.Length == 8 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counters"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counters() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CountersValue(counter' style);                      }                  }                    if (buffer.Length == 12 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("cubic-bezier"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma == null || comma.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Excepted 4 parameters to cubic-bezier()");                              throw new StoppedParsingException();                          }                            return                              new CubicBezierValue(                                  comma.Values.ElementAt(0)'                                  comma.Values.ElementAt(1)'                                  comma.Values.ElementAt(2)'                                  comma.Values.ElementAt(3)                              );                      }                  }                    if (buffer.Length == 15 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("linear-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "linear-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new LinearGradientValue(comma.Values);                      }                        if (toDate.Equals("radial-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "radial-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new RadialGradientValue(comma.Values);                      }                  }              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The following statement contains a magic number: while (stream.HasMore() && !char.IsWhiteSpace(stream.Peek()))              {                  buffer.Append(stream.Read());                    if (buffer.Length == 3 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgb"' StringComparison.InvariantCultureIgnoreCase) || toDate.Equals("hsl"' StringComparison.InvariantCultureIgnoreCase))                      {                          var group = ParseGroup(stream' forPosition);                          var @params = group.Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 3)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            if(toDate == "rgb")                           {                              return                                  new RGBColorValue(                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                            if (toDate == "hsl")                          {                              return                                  new HSLColorValue                                  (                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                      }                        if (toDate.Equals("url"' StringComparison.InvariantCultureIgnoreCase))                      {                          var value = ParseGroup(stream' forPosition).Value;                            if(value is StringValue || value is QuotedStringValue)                          {                              return new UrlValue(value);                          }                            Current.RecordError(ErrorType.Parser' forPosition' "Expected string or quoted string");                          throw new StoppedParsingException();                      }                  }                    if (buffer.Length == 4 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgba"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 4 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            return                              new RGBAColorValue(                                  @params.Values.ElementAt(0)'                                  @params.Values.ElementAt(1)'                                  @params.Values.ElementAt(2)'                                  @params.Values.ElementAt(3)                              );                      }                        if (toDate.Equals("attr"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            Value attrAndType' attr' type' fallback;                            var comma = @params as CommaDelimittedValue;                          if (comma != null)                          {                              if (comma.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects 1 or 2 parameters' found " + comma);                                  throw new StoppedParsingException();                              }                                attrAndType = comma.Values.ElementAt(0);                                fallback = comma.Values.Count() == 2 ? comma.Values.ElementAt(1) : null;                          }                          else                          {                              attrAndType = @params;                              fallback = null;                          }                            var compound = attrAndType as CompoundValue;                          if (compound != null)                          {                              if (compound.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects an attribute name and optionally a type' found " + compound);                                  throw new StoppedParsingException();                              }                                attr = compound.Values.ElementAt(0);                              type = compound.Values.Count() == 2 ? compound.Values.ElementAt(1) : null;                          }                          else                          {                              attr = attrAndType;                              type = null;                          }                            return new AttributeValue(attr' type' fallback);                      }                        if (toDate.Equals("calc"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            if (@params is CommaDelimittedValue)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "calc expects an expression' found " + @params);                          }                            string strVersion;                          using(var writer = new StringWriter())                          {                              @params.Write(writer);                              strVersion = writer.ToString();                          }                            // Things passed to calc are opting out of More magic' they don't get anything but in string replacements                          return new CalcValue(new StringValue(strVersion));                      }                  }                    if (buffer.Length == 5 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("local"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to local() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new LocalValue(val);                      }                        if (toDate.Equals("cycle"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var param = new List<Value>();                            var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              param.AddRange(comma.Values);                          }                          else                          {                              param.Add(val);                          }                            return new CycleValue(param);                      }                        if (toDate.Equals("steps"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to steps() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var steps = comma != null ? comma.Values.ElementAt(0) : val;                          var dir = comma != null ? comma.Values.ElementAt(1) : null;                            return new StepsValue(steps' dir);                      }                  }                    if (buffer.Length == 6 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("format"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to format() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new FormatValue(val);                      }                  }                    if (buffer.Length == 7 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counter"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counter() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CounterValue(counter' style);                      }                  }                    if (buffer.Length == 8 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counters"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counters() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CountersValue(counter' style);                      }                  }                    if (buffer.Length == 12 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("cubic-bezier"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma == null || comma.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Excepted 4 parameters to cubic-bezier()");                              throw new StoppedParsingException();                          }                            return                              new CubicBezierValue(                                  comma.Values.ElementAt(0)'                                  comma.Values.ElementAt(1)'                                  comma.Values.ElementAt(2)'                                  comma.Values.ElementAt(3)                              );                      }                  }                    if (buffer.Length == 15 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("linear-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "linear-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new LinearGradientValue(comma.Values);                      }                        if (toDate.Equals("radial-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "radial-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new RadialGradientValue(comma.Values);                      }                  }              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The following statement contains a magic number: while (stream.HasMore() && !char.IsWhiteSpace(stream.Peek()))              {                  buffer.Append(stream.Read());                    if (buffer.Length == 3 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgb"' StringComparison.InvariantCultureIgnoreCase) || toDate.Equals("hsl"' StringComparison.InvariantCultureIgnoreCase))                      {                          var group = ParseGroup(stream' forPosition);                          var @params = group.Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 3)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            if(toDate == "rgb")                           {                              return                                  new RGBColorValue(                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                            if (toDate == "hsl")                          {                              return                                  new HSLColorValue                                  (                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                      }                        if (toDate.Equals("url"' StringComparison.InvariantCultureIgnoreCase))                      {                          var value = ParseGroup(stream' forPosition).Value;                            if(value is StringValue || value is QuotedStringValue)                          {                              return new UrlValue(value);                          }                            Current.RecordError(ErrorType.Parser' forPosition' "Expected string or quoted string");                          throw new StoppedParsingException();                      }                  }                    if (buffer.Length == 4 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgba"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 4 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            return                              new RGBAColorValue(                                  @params.Values.ElementAt(0)'                                  @params.Values.ElementAt(1)'                                  @params.Values.ElementAt(2)'                                  @params.Values.ElementAt(3)                              );                      }                        if (toDate.Equals("attr"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            Value attrAndType' attr' type' fallback;                            var comma = @params as CommaDelimittedValue;                          if (comma != null)                          {                              if (comma.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects 1 or 2 parameters' found " + comma);                                  throw new StoppedParsingException();                              }                                attrAndType = comma.Values.ElementAt(0);                                fallback = comma.Values.Count() == 2 ? comma.Values.ElementAt(1) : null;                          }                          else                          {                              attrAndType = @params;                              fallback = null;                          }                            var compound = attrAndType as CompoundValue;                          if (compound != null)                          {                              if (compound.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects an attribute name and optionally a type' found " + compound);                                  throw new StoppedParsingException();                              }                                attr = compound.Values.ElementAt(0);                              type = compound.Values.Count() == 2 ? compound.Values.ElementAt(1) : null;                          }                          else                          {                              attr = attrAndType;                              type = null;                          }                            return new AttributeValue(attr' type' fallback);                      }                        if (toDate.Equals("calc"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            if (@params is CommaDelimittedValue)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "calc expects an expression' found " + @params);                          }                            string strVersion;                          using(var writer = new StringWriter())                          {                              @params.Write(writer);                              strVersion = writer.ToString();                          }                            // Things passed to calc are opting out of More magic' they don't get anything but in string replacements                          return new CalcValue(new StringValue(strVersion));                      }                  }                    if (buffer.Length == 5 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("local"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to local() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new LocalValue(val);                      }                        if (toDate.Equals("cycle"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var param = new List<Value>();                            var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              param.AddRange(comma.Values);                          }                          else                          {                              param.Add(val);                          }                            return new CycleValue(param);                      }                        if (toDate.Equals("steps"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to steps() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var steps = comma != null ? comma.Values.ElementAt(0) : val;                          var dir = comma != null ? comma.Values.ElementAt(1) : null;                            return new StepsValue(steps' dir);                      }                  }                    if (buffer.Length == 6 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("format"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to format() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new FormatValue(val);                      }                  }                    if (buffer.Length == 7 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counter"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counter() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CounterValue(counter' style);                      }                  }                    if (buffer.Length == 8 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counters"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counters() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CountersValue(counter' style);                      }                  }                    if (buffer.Length == 12 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("cubic-bezier"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma == null || comma.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Excepted 4 parameters to cubic-bezier()");                              throw new StoppedParsingException();                          }                            return                              new CubicBezierValue(                                  comma.Values.ElementAt(0)'                                  comma.Values.ElementAt(1)'                                  comma.Values.ElementAt(2)'                                  comma.Values.ElementAt(3)                              );                      }                  }                    if (buffer.Length == 15 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("linear-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "linear-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new LinearGradientValue(comma.Values);                      }                        if (toDate.Equals("radial-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "radial-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new RadialGradientValue(comma.Values);                      }                  }              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The following statement contains a magic number: while (stream.HasMore() && !char.IsWhiteSpace(stream.Peek()))              {                  buffer.Append(stream.Read());                    if (buffer.Length == 3 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgb"' StringComparison.InvariantCultureIgnoreCase) || toDate.Equals("hsl"' StringComparison.InvariantCultureIgnoreCase))                      {                          var group = ParseGroup(stream' forPosition);                          var @params = group.Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 3)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            if(toDate == "rgb")                           {                              return                                  new RGBColorValue(                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                            if (toDate == "hsl")                          {                              return                                  new HSLColorValue                                  (                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                      }                        if (toDate.Equals("url"' StringComparison.InvariantCultureIgnoreCase))                      {                          var value = ParseGroup(stream' forPosition).Value;                            if(value is StringValue || value is QuotedStringValue)                          {                              return new UrlValue(value);                          }                            Current.RecordError(ErrorType.Parser' forPosition' "Expected string or quoted string");                          throw new StoppedParsingException();                      }                  }                    if (buffer.Length == 4 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgba"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 4 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            return                              new RGBAColorValue(                                  @params.Values.ElementAt(0)'                                  @params.Values.ElementAt(1)'                                  @params.Values.ElementAt(2)'                                  @params.Values.ElementAt(3)                              );                      }                        if (toDate.Equals("attr"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            Value attrAndType' attr' type' fallback;                            var comma = @params as CommaDelimittedValue;                          if (comma != null)                          {                              if (comma.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects 1 or 2 parameters' found " + comma);                                  throw new StoppedParsingException();                              }                                attrAndType = comma.Values.ElementAt(0);                                fallback = comma.Values.Count() == 2 ? comma.Values.ElementAt(1) : null;                          }                          else                          {                              attrAndType = @params;                              fallback = null;                          }                            var compound = attrAndType as CompoundValue;                          if (compound != null)                          {                              if (compound.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects an attribute name and optionally a type' found " + compound);                                  throw new StoppedParsingException();                              }                                attr = compound.Values.ElementAt(0);                              type = compound.Values.Count() == 2 ? compound.Values.ElementAt(1) : null;                          }                          else                          {                              attr = attrAndType;                              type = null;                          }                            return new AttributeValue(attr' type' fallback);                      }                        if (toDate.Equals("calc"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            if (@params is CommaDelimittedValue)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "calc expects an expression' found " + @params);                          }                            string strVersion;                          using(var writer = new StringWriter())                          {                              @params.Write(writer);                              strVersion = writer.ToString();                          }                            // Things passed to calc are opting out of More magic' they don't get anything but in string replacements                          return new CalcValue(new StringValue(strVersion));                      }                  }                    if (buffer.Length == 5 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("local"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to local() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new LocalValue(val);                      }                        if (toDate.Equals("cycle"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var param = new List<Value>();                            var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              param.AddRange(comma.Values);                          }                          else                          {                              param.Add(val);                          }                            return new CycleValue(param);                      }                        if (toDate.Equals("steps"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to steps() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var steps = comma != null ? comma.Values.ElementAt(0) : val;                          var dir = comma != null ? comma.Values.ElementAt(1) : null;                            return new StepsValue(steps' dir);                      }                  }                    if (buffer.Length == 6 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("format"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to format() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new FormatValue(val);                      }                  }                    if (buffer.Length == 7 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counter"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counter() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CounterValue(counter' style);                      }                  }                    if (buffer.Length == 8 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counters"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counters() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CountersValue(counter' style);                      }                  }                    if (buffer.Length == 12 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("cubic-bezier"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma == null || comma.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Excepted 4 parameters to cubic-bezier()");                              throw new StoppedParsingException();                          }                            return                              new CubicBezierValue(                                  comma.Values.ElementAt(0)'                                  comma.Values.ElementAt(1)'                                  comma.Values.ElementAt(2)'                                  comma.Values.ElementAt(3)                              );                      }                  }                    if (buffer.Length == 15 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("linear-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "linear-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new LinearGradientValue(comma.Values);                      }                        if (toDate.Equals("radial-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "radial-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new RadialGradientValue(comma.Values);                      }                  }              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The following statement contains a magic number: while (stream.HasMore() && !char.IsWhiteSpace(stream.Peek()))              {                  buffer.Append(stream.Read());                    if (buffer.Length == 3 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgb"' StringComparison.InvariantCultureIgnoreCase) || toDate.Equals("hsl"' StringComparison.InvariantCultureIgnoreCase))                      {                          var group = ParseGroup(stream' forPosition);                          var @params = group.Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 3)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            if(toDate == "rgb")                           {                              return                                  new RGBColorValue(                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                            if (toDate == "hsl")                          {                              return                                  new HSLColorValue                                  (                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                      }                        if (toDate.Equals("url"' StringComparison.InvariantCultureIgnoreCase))                      {                          var value = ParseGroup(stream' forPosition).Value;                            if(value is StringValue || value is QuotedStringValue)                          {                              return new UrlValue(value);                          }                            Current.RecordError(ErrorType.Parser' forPosition' "Expected string or quoted string");                          throw new StoppedParsingException();                      }                  }                    if (buffer.Length == 4 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgba"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 4 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            return                              new RGBAColorValue(                                  @params.Values.ElementAt(0)'                                  @params.Values.ElementAt(1)'                                  @params.Values.ElementAt(2)'                                  @params.Values.ElementAt(3)                              );                      }                        if (toDate.Equals("attr"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            Value attrAndType' attr' type' fallback;                            var comma = @params as CommaDelimittedValue;                          if (comma != null)                          {                              if (comma.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects 1 or 2 parameters' found " + comma);                                  throw new StoppedParsingException();                              }                                attrAndType = comma.Values.ElementAt(0);                                fallback = comma.Values.Count() == 2 ? comma.Values.ElementAt(1) : null;                          }                          else                          {                              attrAndType = @params;                              fallback = null;                          }                            var compound = attrAndType as CompoundValue;                          if (compound != null)                          {                              if (compound.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects an attribute name and optionally a type' found " + compound);                                  throw new StoppedParsingException();                              }                                attr = compound.Values.ElementAt(0);                              type = compound.Values.Count() == 2 ? compound.Values.ElementAt(1) : null;                          }                          else                          {                              attr = attrAndType;                              type = null;                          }                            return new AttributeValue(attr' type' fallback);                      }                        if (toDate.Equals("calc"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            if (@params is CommaDelimittedValue)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "calc expects an expression' found " + @params);                          }                            string strVersion;                          using(var writer = new StringWriter())                          {                              @params.Write(writer);                              strVersion = writer.ToString();                          }                            // Things passed to calc are opting out of More magic' they don't get anything but in string replacements                          return new CalcValue(new StringValue(strVersion));                      }                  }                    if (buffer.Length == 5 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("local"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to local() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new LocalValue(val);                      }                        if (toDate.Equals("cycle"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var param = new List<Value>();                            var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              param.AddRange(comma.Values);                          }                          else                          {                              param.Add(val);                          }                            return new CycleValue(param);                      }                        if (toDate.Equals("steps"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to steps() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var steps = comma != null ? comma.Values.ElementAt(0) : val;                          var dir = comma != null ? comma.Values.ElementAt(1) : null;                            return new StepsValue(steps' dir);                      }                  }                    if (buffer.Length == 6 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("format"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to format() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new FormatValue(val);                      }                  }                    if (buffer.Length == 7 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counter"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counter() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CounterValue(counter' style);                      }                  }                    if (buffer.Length == 8 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counters"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counters() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CountersValue(counter' style);                      }                  }                    if (buffer.Length == 12 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("cubic-bezier"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma == null || comma.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Excepted 4 parameters to cubic-bezier()");                              throw new StoppedParsingException();                          }                            return                              new CubicBezierValue(                                  comma.Values.ElementAt(0)'                                  comma.Values.ElementAt(1)'                                  comma.Values.ElementAt(2)'                                  comma.Values.ElementAt(3)                              );                      }                  }                    if (buffer.Length == 15 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("linear-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "linear-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new LinearGradientValue(comma.Values);                      }                        if (toDate.Equals("radial-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "radial-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new RadialGradientValue(comma.Values);                      }                  }              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The following statement contains a magic number: while (stream.HasMore() && !char.IsWhiteSpace(stream.Peek()))              {                  buffer.Append(stream.Read());                    if (buffer.Length == 3 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgb"' StringComparison.InvariantCultureIgnoreCase) || toDate.Equals("hsl"' StringComparison.InvariantCultureIgnoreCase))                      {                          var group = ParseGroup(stream' forPosition);                          var @params = group.Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 3)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            if(toDate == "rgb")                           {                              return                                  new RGBColorValue(                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                            if (toDate == "hsl")                          {                              return                                  new HSLColorValue                                  (                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                      }                        if (toDate.Equals("url"' StringComparison.InvariantCultureIgnoreCase))                      {                          var value = ParseGroup(stream' forPosition).Value;                            if(value is StringValue || value is QuotedStringValue)                          {                              return new UrlValue(value);                          }                            Current.RecordError(ErrorType.Parser' forPosition' "Expected string or quoted string");                          throw new StoppedParsingException();                      }                  }                    if (buffer.Length == 4 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgba"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 4 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            return                              new RGBAColorValue(                                  @params.Values.ElementAt(0)'                                  @params.Values.ElementAt(1)'                                  @params.Values.ElementAt(2)'                                  @params.Values.ElementAt(3)                              );                      }                        if (toDate.Equals("attr"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            Value attrAndType' attr' type' fallback;                            var comma = @params as CommaDelimittedValue;                          if (comma != null)                          {                              if (comma.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects 1 or 2 parameters' found " + comma);                                  throw new StoppedParsingException();                              }                                attrAndType = comma.Values.ElementAt(0);                                fallback = comma.Values.Count() == 2 ? comma.Values.ElementAt(1) : null;                          }                          else                          {                              attrAndType = @params;                              fallback = null;                          }                            var compound = attrAndType as CompoundValue;                          if (compound != null)                          {                              if (compound.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects an attribute name and optionally a type' found " + compound);                                  throw new StoppedParsingException();                              }                                attr = compound.Values.ElementAt(0);                              type = compound.Values.Count() == 2 ? compound.Values.ElementAt(1) : null;                          }                          else                          {                              attr = attrAndType;                              type = null;                          }                            return new AttributeValue(attr' type' fallback);                      }                        if (toDate.Equals("calc"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            if (@params is CommaDelimittedValue)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "calc expects an expression' found " + @params);                          }                            string strVersion;                          using(var writer = new StringWriter())                          {                              @params.Write(writer);                              strVersion = writer.ToString();                          }                            // Things passed to calc are opting out of More magic' they don't get anything but in string replacements                          return new CalcValue(new StringValue(strVersion));                      }                  }                    if (buffer.Length == 5 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("local"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to local() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new LocalValue(val);                      }                        if (toDate.Equals("cycle"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var param = new List<Value>();                            var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              param.AddRange(comma.Values);                          }                          else                          {                              param.Add(val);                          }                            return new CycleValue(param);                      }                        if (toDate.Equals("steps"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to steps() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var steps = comma != null ? comma.Values.ElementAt(0) : val;                          var dir = comma != null ? comma.Values.ElementAt(1) : null;                            return new StepsValue(steps' dir);                      }                  }                    if (buffer.Length == 6 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("format"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to format() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new FormatValue(val);                      }                  }                    if (buffer.Length == 7 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counter"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counter() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CounterValue(counter' style);                      }                  }                    if (buffer.Length == 8 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counters"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counters() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CountersValue(counter' style);                      }                  }                    if (buffer.Length == 12 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("cubic-bezier"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma == null || comma.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Excepted 4 parameters to cubic-bezier()");                              throw new StoppedParsingException();                          }                            return                              new CubicBezierValue(                                  comma.Values.ElementAt(0)'                                  comma.Values.ElementAt(1)'                                  comma.Values.ElementAt(2)'                                  comma.Values.ElementAt(3)                              );                      }                  }                    if (buffer.Length == 15 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("linear-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "linear-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new LinearGradientValue(comma.Values);                      }                        if (toDate.Equals("radial-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "radial-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new RadialGradientValue(comma.Values);                      }                  }              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The following statement contains a magic number: while (stream.HasMore() && !char.IsWhiteSpace(stream.Peek()))              {                  buffer.Append(stream.Read());                    if (buffer.Length == 3 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgb"' StringComparison.InvariantCultureIgnoreCase) || toDate.Equals("hsl"' StringComparison.InvariantCultureIgnoreCase))                      {                          var group = ParseGroup(stream' forPosition);                          var @params = group.Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 3)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            if(toDate == "rgb")                           {                              return                                  new RGBColorValue(                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                            if (toDate == "hsl")                          {                              return                                  new HSLColorValue                                  (                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                      }                        if (toDate.Equals("url"' StringComparison.InvariantCultureIgnoreCase))                      {                          var value = ParseGroup(stream' forPosition).Value;                            if(value is StringValue || value is QuotedStringValue)                          {                              return new UrlValue(value);                          }                            Current.RecordError(ErrorType.Parser' forPosition' "Expected string or quoted string");                          throw new StoppedParsingException();                      }                  }                    if (buffer.Length == 4 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgba"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 4 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            return                              new RGBAColorValue(                                  @params.Values.ElementAt(0)'                                  @params.Values.ElementAt(1)'                                  @params.Values.ElementAt(2)'                                  @params.Values.ElementAt(3)                              );                      }                        if (toDate.Equals("attr"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            Value attrAndType' attr' type' fallback;                            var comma = @params as CommaDelimittedValue;                          if (comma != null)                          {                              if (comma.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects 1 or 2 parameters' found " + comma);                                  throw new StoppedParsingException();                              }                                attrAndType = comma.Values.ElementAt(0);                                fallback = comma.Values.Count() == 2 ? comma.Values.ElementAt(1) : null;                          }                          else                          {                              attrAndType = @params;                              fallback = null;                          }                            var compound = attrAndType as CompoundValue;                          if (compound != null)                          {                              if (compound.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects an attribute name and optionally a type' found " + compound);                                  throw new StoppedParsingException();                              }                                attr = compound.Values.ElementAt(0);                              type = compound.Values.Count() == 2 ? compound.Values.ElementAt(1) : null;                          }                          else                          {                              attr = attrAndType;                              type = null;                          }                            return new AttributeValue(attr' type' fallback);                      }                        if (toDate.Equals("calc"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            if (@params is CommaDelimittedValue)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "calc expects an expression' found " + @params);                          }                            string strVersion;                          using(var writer = new StringWriter())                          {                              @params.Write(writer);                              strVersion = writer.ToString();                          }                            // Things passed to calc are opting out of More magic' they don't get anything but in string replacements                          return new CalcValue(new StringValue(strVersion));                      }                  }                    if (buffer.Length == 5 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("local"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to local() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new LocalValue(val);                      }                        if (toDate.Equals("cycle"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var param = new List<Value>();                            var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              param.AddRange(comma.Values);                          }                          else                          {                              param.Add(val);                          }                            return new CycleValue(param);                      }                        if (toDate.Equals("steps"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to steps() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var steps = comma != null ? comma.Values.ElementAt(0) : val;                          var dir = comma != null ? comma.Values.ElementAt(1) : null;                            return new StepsValue(steps' dir);                      }                  }                    if (buffer.Length == 6 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("format"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to format() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new FormatValue(val);                      }                  }                    if (buffer.Length == 7 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counter"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counter() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CounterValue(counter' style);                      }                  }                    if (buffer.Length == 8 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counters"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counters() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CountersValue(counter' style);                      }                  }                    if (buffer.Length == 12 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("cubic-bezier"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma == null || comma.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Excepted 4 parameters to cubic-bezier()");                              throw new StoppedParsingException();                          }                            return                              new CubicBezierValue(                                  comma.Values.ElementAt(0)'                                  comma.Values.ElementAt(1)'                                  comma.Values.ElementAt(2)'                                  comma.Values.ElementAt(3)                              );                      }                  }                    if (buffer.Length == 15 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("linear-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "linear-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new LinearGradientValue(comma.Values);                      }                        if (toDate.Equals("radial-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "radial-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new RadialGradientValue(comma.Values);                      }                  }              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The following statement contains a magic number: while (stream.HasMore() && !char.IsWhiteSpace(stream.Peek()))              {                  buffer.Append(stream.Read());                    if (buffer.Length == 3 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgb"' StringComparison.InvariantCultureIgnoreCase) || toDate.Equals("hsl"' StringComparison.InvariantCultureIgnoreCase))                      {                          var group = ParseGroup(stream' forPosition);                          var @params = group.Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 3)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            if(toDate == "rgb")                           {                              return                                  new RGBColorValue(                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                            if (toDate == "hsl")                          {                              return                                  new HSLColorValue                                  (                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                      }                        if (toDate.Equals("url"' StringComparison.InvariantCultureIgnoreCase))                      {                          var value = ParseGroup(stream' forPosition).Value;                            if(value is StringValue || value is QuotedStringValue)                          {                              return new UrlValue(value);                          }                            Current.RecordError(ErrorType.Parser' forPosition' "Expected string or quoted string");                          throw new StoppedParsingException();                      }                  }                    if (buffer.Length == 4 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgba"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 4 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            return                              new RGBAColorValue(                                  @params.Values.ElementAt(0)'                                  @params.Values.ElementAt(1)'                                  @params.Values.ElementAt(2)'                                  @params.Values.ElementAt(3)                              );                      }                        if (toDate.Equals("attr"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            Value attrAndType' attr' type' fallback;                            var comma = @params as CommaDelimittedValue;                          if (comma != null)                          {                              if (comma.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects 1 or 2 parameters' found " + comma);                                  throw new StoppedParsingException();                              }                                attrAndType = comma.Values.ElementAt(0);                                fallback = comma.Values.Count() == 2 ? comma.Values.ElementAt(1) : null;                          }                          else                          {                              attrAndType = @params;                              fallback = null;                          }                            var compound = attrAndType as CompoundValue;                          if (compound != null)                          {                              if (compound.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects an attribute name and optionally a type' found " + compound);                                  throw new StoppedParsingException();                              }                                attr = compound.Values.ElementAt(0);                              type = compound.Values.Count() == 2 ? compound.Values.ElementAt(1) : null;                          }                          else                          {                              attr = attrAndType;                              type = null;                          }                            return new AttributeValue(attr' type' fallback);                      }                        if (toDate.Equals("calc"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            if (@params is CommaDelimittedValue)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "calc expects an expression' found " + @params);                          }                            string strVersion;                          using(var writer = new StringWriter())                          {                              @params.Write(writer);                              strVersion = writer.ToString();                          }                            // Things passed to calc are opting out of More magic' they don't get anything but in string replacements                          return new CalcValue(new StringValue(strVersion));                      }                  }                    if (buffer.Length == 5 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("local"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to local() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new LocalValue(val);                      }                        if (toDate.Equals("cycle"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var param = new List<Value>();                            var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              param.AddRange(comma.Values);                          }                          else                          {                              param.Add(val);                          }                            return new CycleValue(param);                      }                        if (toDate.Equals("steps"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to steps() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var steps = comma != null ? comma.Values.ElementAt(0) : val;                          var dir = comma != null ? comma.Values.ElementAt(1) : null;                            return new StepsValue(steps' dir);                      }                  }                    if (buffer.Length == 6 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("format"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to format() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new FormatValue(val);                      }                  }                    if (buffer.Length == 7 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counter"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counter() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CounterValue(counter' style);                      }                  }                    if (buffer.Length == 8 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counters"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counters() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CountersValue(counter' style);                      }                  }                    if (buffer.Length == 12 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("cubic-bezier"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma == null || comma.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Excepted 4 parameters to cubic-bezier()");                              throw new StoppedParsingException();                          }                            return                              new CubicBezierValue(                                  comma.Values.ElementAt(0)'                                  comma.Values.ElementAt(1)'                                  comma.Values.ElementAt(2)'                                  comma.Values.ElementAt(3)                              );                      }                  }                    if (buffer.Length == 15 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("linear-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "linear-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new LinearGradientValue(comma.Values);                      }                        if (toDate.Equals("radial-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "radial-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new RadialGradientValue(comma.Values);                      }                  }              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The following statement contains a magic number: while (stream.HasMore() && !char.IsWhiteSpace(stream.Peek()))              {                  buffer.Append(stream.Read());                    if (buffer.Length == 3 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgb"' StringComparison.InvariantCultureIgnoreCase) || toDate.Equals("hsl"' StringComparison.InvariantCultureIgnoreCase))                      {                          var group = ParseGroup(stream' forPosition);                          var @params = group.Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 3)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            if(toDate == "rgb")                           {                              return                                  new RGBColorValue(                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                            if (toDate == "hsl")                          {                              return                                  new HSLColorValue                                  (                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                      }                        if (toDate.Equals("url"' StringComparison.InvariantCultureIgnoreCase))                      {                          var value = ParseGroup(stream' forPosition).Value;                            if(value is StringValue || value is QuotedStringValue)                          {                              return new UrlValue(value);                          }                            Current.RecordError(ErrorType.Parser' forPosition' "Expected string or quoted string");                          throw new StoppedParsingException();                      }                  }                    if (buffer.Length == 4 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgba"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 4 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            return                              new RGBAColorValue(                                  @params.Values.ElementAt(0)'                                  @params.Values.ElementAt(1)'                                  @params.Values.ElementAt(2)'                                  @params.Values.ElementAt(3)                              );                      }                        if (toDate.Equals("attr"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            Value attrAndType' attr' type' fallback;                            var comma = @params as CommaDelimittedValue;                          if (comma != null)                          {                              if (comma.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects 1 or 2 parameters' found " + comma);                                  throw new StoppedParsingException();                              }                                attrAndType = comma.Values.ElementAt(0);                                fallback = comma.Values.Count() == 2 ? comma.Values.ElementAt(1) : null;                          }                          else                          {                              attrAndType = @params;                              fallback = null;                          }                            var compound = attrAndType as CompoundValue;                          if (compound != null)                          {                              if (compound.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects an attribute name and optionally a type' found " + compound);                                  throw new StoppedParsingException();                              }                                attr = compound.Values.ElementAt(0);                              type = compound.Values.Count() == 2 ? compound.Values.ElementAt(1) : null;                          }                          else                          {                              attr = attrAndType;                              type = null;                          }                            return new AttributeValue(attr' type' fallback);                      }                        if (toDate.Equals("calc"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            if (@params is CommaDelimittedValue)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "calc expects an expression' found " + @params);                          }                            string strVersion;                          using(var writer = new StringWriter())                          {                              @params.Write(writer);                              strVersion = writer.ToString();                          }                            // Things passed to calc are opting out of More magic' they don't get anything but in string replacements                          return new CalcValue(new StringValue(strVersion));                      }                  }                    if (buffer.Length == 5 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("local"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to local() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new LocalValue(val);                      }                        if (toDate.Equals("cycle"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var param = new List<Value>();                            var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              param.AddRange(comma.Values);                          }                          else                          {                              param.Add(val);                          }                            return new CycleValue(param);                      }                        if (toDate.Equals("steps"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to steps() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var steps = comma != null ? comma.Values.ElementAt(0) : val;                          var dir = comma != null ? comma.Values.ElementAt(1) : null;                            return new StepsValue(steps' dir);                      }                  }                    if (buffer.Length == 6 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("format"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to format() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new FormatValue(val);                      }                  }                    if (buffer.Length == 7 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counter"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counter() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CounterValue(counter' style);                      }                  }                    if (buffer.Length == 8 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counters"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counters() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CountersValue(counter' style);                      }                  }                    if (buffer.Length == 12 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("cubic-bezier"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma == null || comma.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Excepted 4 parameters to cubic-bezier()");                              throw new StoppedParsingException();                          }                            return                              new CubicBezierValue(                                  comma.Values.ElementAt(0)'                                  comma.Values.ElementAt(1)'                                  comma.Values.ElementAt(2)'                                  comma.Values.ElementAt(3)                              );                      }                  }                    if (buffer.Length == 15 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("linear-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "linear-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new LinearGradientValue(comma.Values);                      }                        if (toDate.Equals("radial-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "radial-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new RadialGradientValue(comma.Values);                      }                  }              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The following statement contains a magic number: while (stream.HasMore() && !char.IsWhiteSpace(stream.Peek()))              {                  buffer.Append(stream.Read());                    if (buffer.Length == 3 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgb"' StringComparison.InvariantCultureIgnoreCase) || toDate.Equals("hsl"' StringComparison.InvariantCultureIgnoreCase))                      {                          var group = ParseGroup(stream' forPosition);                          var @params = group.Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 3)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            if(toDate == "rgb")                           {                              return                                  new RGBColorValue(                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                            if (toDate == "hsl")                          {                              return                                  new HSLColorValue                                  (                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                      }                        if (toDate.Equals("url"' StringComparison.InvariantCultureIgnoreCase))                      {                          var value = ParseGroup(stream' forPosition).Value;                            if(value is StringValue || value is QuotedStringValue)                          {                              return new UrlValue(value);                          }                            Current.RecordError(ErrorType.Parser' forPosition' "Expected string or quoted string");                          throw new StoppedParsingException();                      }                  }                    if (buffer.Length == 4 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgba"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 4 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            return                              new RGBAColorValue(                                  @params.Values.ElementAt(0)'                                  @params.Values.ElementAt(1)'                                  @params.Values.ElementAt(2)'                                  @params.Values.ElementAt(3)                              );                      }                        if (toDate.Equals("attr"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            Value attrAndType' attr' type' fallback;                            var comma = @params as CommaDelimittedValue;                          if (comma != null)                          {                              if (comma.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects 1 or 2 parameters' found " + comma);                                  throw new StoppedParsingException();                              }                                attrAndType = comma.Values.ElementAt(0);                                fallback = comma.Values.Count() == 2 ? comma.Values.ElementAt(1) : null;                          }                          else                          {                              attrAndType = @params;                              fallback = null;                          }                            var compound = attrAndType as CompoundValue;                          if (compound != null)                          {                              if (compound.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects an attribute name and optionally a type' found " + compound);                                  throw new StoppedParsingException();                              }                                attr = compound.Values.ElementAt(0);                              type = compound.Values.Count() == 2 ? compound.Values.ElementAt(1) : null;                          }                          else                          {                              attr = attrAndType;                              type = null;                          }                            return new AttributeValue(attr' type' fallback);                      }                        if (toDate.Equals("calc"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            if (@params is CommaDelimittedValue)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "calc expects an expression' found " + @params);                          }                            string strVersion;                          using(var writer = new StringWriter())                          {                              @params.Write(writer);                              strVersion = writer.ToString();                          }                            // Things passed to calc are opting out of More magic' they don't get anything but in string replacements                          return new CalcValue(new StringValue(strVersion));                      }                  }                    if (buffer.Length == 5 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("local"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to local() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new LocalValue(val);                      }                        if (toDate.Equals("cycle"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var param = new List<Value>();                            var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              param.AddRange(comma.Values);                          }                          else                          {                              param.Add(val);                          }                            return new CycleValue(param);                      }                        if (toDate.Equals("steps"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to steps() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var steps = comma != null ? comma.Values.ElementAt(0) : val;                          var dir = comma != null ? comma.Values.ElementAt(1) : null;                            return new StepsValue(steps' dir);                      }                  }                    if (buffer.Length == 6 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("format"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to format() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new FormatValue(val);                      }                  }                    if (buffer.Length == 7 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counter"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counter() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CounterValue(counter' style);                      }                  }                    if (buffer.Length == 8 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counters"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counters() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CountersValue(counter' style);                      }                  }                    if (buffer.Length == 12 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("cubic-bezier"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma == null || comma.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Excepted 4 parameters to cubic-bezier()");                              throw new StoppedParsingException();                          }                            return                              new CubicBezierValue(                                  comma.Values.ElementAt(0)'                                  comma.Values.ElementAt(1)'                                  comma.Values.ElementAt(2)'                                  comma.Values.ElementAt(3)                              );                      }                  }                    if (buffer.Length == 15 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("linear-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "linear-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new LinearGradientValue(comma.Values);                      }                        if (toDate.Equals("radial-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "radial-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new RadialGradientValue(comma.Values);                      }                  }              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The following statement contains a magic number: while (stream.HasMore() && !char.IsWhiteSpace(stream.Peek()))              {                  buffer.Append(stream.Read());                    if (buffer.Length == 3 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgb"' StringComparison.InvariantCultureIgnoreCase) || toDate.Equals("hsl"' StringComparison.InvariantCultureIgnoreCase))                      {                          var group = ParseGroup(stream' forPosition);                          var @params = group.Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 3)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            if(toDate == "rgb")                           {                              return                                  new RGBColorValue(                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                            if (toDate == "hsl")                          {                              return                                  new HSLColorValue                                  (                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                      }                        if (toDate.Equals("url"' StringComparison.InvariantCultureIgnoreCase))                      {                          var value = ParseGroup(stream' forPosition).Value;                            if(value is StringValue || value is QuotedStringValue)                          {                              return new UrlValue(value);                          }                            Current.RecordError(ErrorType.Parser' forPosition' "Expected string or quoted string");                          throw new StoppedParsingException();                      }                  }                    if (buffer.Length == 4 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgba"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 4 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            return                              new RGBAColorValue(                                  @params.Values.ElementAt(0)'                                  @params.Values.ElementAt(1)'                                  @params.Values.ElementAt(2)'                                  @params.Values.ElementAt(3)                              );                      }                        if (toDate.Equals("attr"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            Value attrAndType' attr' type' fallback;                            var comma = @params as CommaDelimittedValue;                          if (comma != null)                          {                              if (comma.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects 1 or 2 parameters' found " + comma);                                  throw new StoppedParsingException();                              }                                attrAndType = comma.Values.ElementAt(0);                                fallback = comma.Values.Count() == 2 ? comma.Values.ElementAt(1) : null;                          }                          else                          {                              attrAndType = @params;                              fallback = null;                          }                            var compound = attrAndType as CompoundValue;                          if (compound != null)                          {                              if (compound.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects an attribute name and optionally a type' found " + compound);                                  throw new StoppedParsingException();                              }                                attr = compound.Values.ElementAt(0);                              type = compound.Values.Count() == 2 ? compound.Values.ElementAt(1) : null;                          }                          else                          {                              attr = attrAndType;                              type = null;                          }                            return new AttributeValue(attr' type' fallback);                      }                        if (toDate.Equals("calc"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            if (@params is CommaDelimittedValue)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "calc expects an expression' found " + @params);                          }                            string strVersion;                          using(var writer = new StringWriter())                          {                              @params.Write(writer);                              strVersion = writer.ToString();                          }                            // Things passed to calc are opting out of More magic' they don't get anything but in string replacements                          return new CalcValue(new StringValue(strVersion));                      }                  }                    if (buffer.Length == 5 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("local"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to local() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new LocalValue(val);                      }                        if (toDate.Equals("cycle"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var param = new List<Value>();                            var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              param.AddRange(comma.Values);                          }                          else                          {                              param.Add(val);                          }                            return new CycleValue(param);                      }                        if (toDate.Equals("steps"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to steps() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var steps = comma != null ? comma.Values.ElementAt(0) : val;                          var dir = comma != null ? comma.Values.ElementAt(1) : null;                            return new StepsValue(steps' dir);                      }                  }                    if (buffer.Length == 6 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("format"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to format() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new FormatValue(val);                      }                  }                    if (buffer.Length == 7 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counter"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counter() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CounterValue(counter' style);                      }                  }                    if (buffer.Length == 8 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counters"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counters() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CountersValue(counter' style);                      }                  }                    if (buffer.Length == 12 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("cubic-bezier"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma == null || comma.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Excepted 4 parameters to cubic-bezier()");                              throw new StoppedParsingException();                          }                            return                              new CubicBezierValue(                                  comma.Values.ElementAt(0)'                                  comma.Values.ElementAt(1)'                                  comma.Values.ElementAt(2)'                                  comma.Values.ElementAt(3)                              );                      }                  }                    if (buffer.Length == 15 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("linear-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "linear-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new LinearGradientValue(comma.Values);                      }                        if (toDate.Equals("radial-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "radial-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new RadialGradientValue(comma.Values);                      }                  }              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The following statement contains a magic number: while (stream.HasMore() && !char.IsWhiteSpace(stream.Peek()))              {                  buffer.Append(stream.Read());                    if (buffer.Length == 3 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgb"' StringComparison.InvariantCultureIgnoreCase) || toDate.Equals("hsl"' StringComparison.InvariantCultureIgnoreCase))                      {                          var group = ParseGroup(stream' forPosition);                          var @params = group.Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 3)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            if(toDate == "rgb")                           {                              return                                  new RGBColorValue(                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                            if (toDate == "hsl")                          {                              return                                  new HSLColorValue                                  (                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                      }                        if (toDate.Equals("url"' StringComparison.InvariantCultureIgnoreCase))                      {                          var value = ParseGroup(stream' forPosition).Value;                            if(value is StringValue || value is QuotedStringValue)                          {                              return new UrlValue(value);                          }                            Current.RecordError(ErrorType.Parser' forPosition' "Expected string or quoted string");                          throw new StoppedParsingException();                      }                  }                    if (buffer.Length == 4 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgba"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 4 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            return                              new RGBAColorValue(                                  @params.Values.ElementAt(0)'                                  @params.Values.ElementAt(1)'                                  @params.Values.ElementAt(2)'                                  @params.Values.ElementAt(3)                              );                      }                        if (toDate.Equals("attr"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            Value attrAndType' attr' type' fallback;                            var comma = @params as CommaDelimittedValue;                          if (comma != null)                          {                              if (comma.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects 1 or 2 parameters' found " + comma);                                  throw new StoppedParsingException();                              }                                attrAndType = comma.Values.ElementAt(0);                                fallback = comma.Values.Count() == 2 ? comma.Values.ElementAt(1) : null;                          }                          else                          {                              attrAndType = @params;                              fallback = null;                          }                            var compound = attrAndType as CompoundValue;                          if (compound != null)                          {                              if (compound.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects an attribute name and optionally a type' found " + compound);                                  throw new StoppedParsingException();                              }                                attr = compound.Values.ElementAt(0);                              type = compound.Values.Count() == 2 ? compound.Values.ElementAt(1) : null;                          }                          else                          {                              attr = attrAndType;                              type = null;                          }                            return new AttributeValue(attr' type' fallback);                      }                        if (toDate.Equals("calc"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            if (@params is CommaDelimittedValue)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "calc expects an expression' found " + @params);                          }                            string strVersion;                          using(var writer = new StringWriter())                          {                              @params.Write(writer);                              strVersion = writer.ToString();                          }                            // Things passed to calc are opting out of More magic' they don't get anything but in string replacements                          return new CalcValue(new StringValue(strVersion));                      }                  }                    if (buffer.Length == 5 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("local"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to local() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new LocalValue(val);                      }                        if (toDate.Equals("cycle"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var param = new List<Value>();                            var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              param.AddRange(comma.Values);                          }                          else                          {                              param.Add(val);                          }                            return new CycleValue(param);                      }                        if (toDate.Equals("steps"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to steps() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var steps = comma != null ? comma.Values.ElementAt(0) : val;                          var dir = comma != null ? comma.Values.ElementAt(1) : null;                            return new StepsValue(steps' dir);                      }                  }                    if (buffer.Length == 6 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("format"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to format() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new FormatValue(val);                      }                  }                    if (buffer.Length == 7 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counter"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counter() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CounterValue(counter' style);                      }                  }                    if (buffer.Length == 8 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counters"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counters() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CountersValue(counter' style);                      }                  }                    if (buffer.Length == 12 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("cubic-bezier"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma == null || comma.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Excepted 4 parameters to cubic-bezier()");                              throw new StoppedParsingException();                          }                            return                              new CubicBezierValue(                                  comma.Values.ElementAt(0)'                                  comma.Values.ElementAt(1)'                                  comma.Values.ElementAt(2)'                                  comma.Values.ElementAt(3)                              );                      }                  }                    if (buffer.Length == 15 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("linear-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "linear-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new LinearGradientValue(comma.Values);                      }                        if (toDate.Equals("radial-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "radial-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new RadialGradientValue(comma.Values);                      }                  }              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The following statement contains a magic number: while (stream.HasMore() && !char.IsWhiteSpace(stream.Peek()))              {                  buffer.Append(stream.Read());                    if (buffer.Length == 3 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgb"' StringComparison.InvariantCultureIgnoreCase) || toDate.Equals("hsl"' StringComparison.InvariantCultureIgnoreCase))                      {                          var group = ParseGroup(stream' forPosition);                          var @params = group.Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 3)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            if(toDate == "rgb")                           {                              return                                  new RGBColorValue(                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                            if (toDate == "hsl")                          {                              return                                  new HSLColorValue                                  (                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                      }                        if (toDate.Equals("url"' StringComparison.InvariantCultureIgnoreCase))                      {                          var value = ParseGroup(stream' forPosition).Value;                            if(value is StringValue || value is QuotedStringValue)                          {                              return new UrlValue(value);                          }                            Current.RecordError(ErrorType.Parser' forPosition' "Expected string or quoted string");                          throw new StoppedParsingException();                      }                  }                    if (buffer.Length == 4 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgba"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 4 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            return                              new RGBAColorValue(                                  @params.Values.ElementAt(0)'                                  @params.Values.ElementAt(1)'                                  @params.Values.ElementAt(2)'                                  @params.Values.ElementAt(3)                              );                      }                        if (toDate.Equals("attr"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            Value attrAndType' attr' type' fallback;                            var comma = @params as CommaDelimittedValue;                          if (comma != null)                          {                              if (comma.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects 1 or 2 parameters' found " + comma);                                  throw new StoppedParsingException();                              }                                attrAndType = comma.Values.ElementAt(0);                                fallback = comma.Values.Count() == 2 ? comma.Values.ElementAt(1) : null;                          }                          else                          {                              attrAndType = @params;                              fallback = null;                          }                            var compound = attrAndType as CompoundValue;                          if (compound != null)                          {                              if (compound.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects an attribute name and optionally a type' found " + compound);                                  throw new StoppedParsingException();                              }                                attr = compound.Values.ElementAt(0);                              type = compound.Values.Count() == 2 ? compound.Values.ElementAt(1) : null;                          }                          else                          {                              attr = attrAndType;                              type = null;                          }                            return new AttributeValue(attr' type' fallback);                      }                        if (toDate.Equals("calc"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            if (@params is CommaDelimittedValue)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "calc expects an expression' found " + @params);                          }                            string strVersion;                          using(var writer = new StringWriter())                          {                              @params.Write(writer);                              strVersion = writer.ToString();                          }                            // Things passed to calc are opting out of More magic' they don't get anything but in string replacements                          return new CalcValue(new StringValue(strVersion));                      }                  }                    if (buffer.Length == 5 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("local"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to local() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new LocalValue(val);                      }                        if (toDate.Equals("cycle"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var param = new List<Value>();                            var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              param.AddRange(comma.Values);                          }                          else                          {                              param.Add(val);                          }                            return new CycleValue(param);                      }                        if (toDate.Equals("steps"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to steps() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var steps = comma != null ? comma.Values.ElementAt(0) : val;                          var dir = comma != null ? comma.Values.ElementAt(1) : null;                            return new StepsValue(steps' dir);                      }                  }                    if (buffer.Length == 6 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("format"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to format() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new FormatValue(val);                      }                  }                    if (buffer.Length == 7 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counter"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counter() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CounterValue(counter' style);                      }                  }                    if (buffer.Length == 8 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counters"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counters() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CountersValue(counter' style);                      }                  }                    if (buffer.Length == 12 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("cubic-bezier"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma == null || comma.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Excepted 4 parameters to cubic-bezier()");                              throw new StoppedParsingException();                          }                            return                              new CubicBezierValue(                                  comma.Values.ElementAt(0)'                                  comma.Values.ElementAt(1)'                                  comma.Values.ElementAt(2)'                                  comma.Values.ElementAt(3)                              );                      }                  }                    if (buffer.Length == 15 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("linear-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "linear-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new LinearGradientValue(comma.Values);                      }                        if (toDate.Equals("radial-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "radial-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new RadialGradientValue(comma.Values);                      }                  }              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The following statement contains a magic number: while (stream.HasMore() && !char.IsWhiteSpace(stream.Peek()))              {                  buffer.Append(stream.Read());                    if (buffer.Length == 3 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgb"' StringComparison.InvariantCultureIgnoreCase) || toDate.Equals("hsl"' StringComparison.InvariantCultureIgnoreCase))                      {                          var group = ParseGroup(stream' forPosition);                          var @params = group.Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 3)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            if(toDate == "rgb")                           {                              return                                  new RGBColorValue(                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                            if (toDate == "hsl")                          {                              return                                  new HSLColorValue                                  (                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                      }                        if (toDate.Equals("url"' StringComparison.InvariantCultureIgnoreCase))                      {                          var value = ParseGroup(stream' forPosition).Value;                            if(value is StringValue || value is QuotedStringValue)                          {                              return new UrlValue(value);                          }                            Current.RecordError(ErrorType.Parser' forPosition' "Expected string or quoted string");                          throw new StoppedParsingException();                      }                  }                    if (buffer.Length == 4 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgba"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 4 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            return                              new RGBAColorValue(                                  @params.Values.ElementAt(0)'                                  @params.Values.ElementAt(1)'                                  @params.Values.ElementAt(2)'                                  @params.Values.ElementAt(3)                              );                      }                        if (toDate.Equals("attr"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            Value attrAndType' attr' type' fallback;                            var comma = @params as CommaDelimittedValue;                          if (comma != null)                          {                              if (comma.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects 1 or 2 parameters' found " + comma);                                  throw new StoppedParsingException();                              }                                attrAndType = comma.Values.ElementAt(0);                                fallback = comma.Values.Count() == 2 ? comma.Values.ElementAt(1) : null;                          }                          else                          {                              attrAndType = @params;                              fallback = null;                          }                            var compound = attrAndType as CompoundValue;                          if (compound != null)                          {                              if (compound.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects an attribute name and optionally a type' found " + compound);                                  throw new StoppedParsingException();                              }                                attr = compound.Values.ElementAt(0);                              type = compound.Values.Count() == 2 ? compound.Values.ElementAt(1) : null;                          }                          else                          {                              attr = attrAndType;                              type = null;                          }                            return new AttributeValue(attr' type' fallback);                      }                        if (toDate.Equals("calc"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            if (@params is CommaDelimittedValue)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "calc expects an expression' found " + @params);                          }                            string strVersion;                          using(var writer = new StringWriter())                          {                              @params.Write(writer);                              strVersion = writer.ToString();                          }                            // Things passed to calc are opting out of More magic' they don't get anything but in string replacements                          return new CalcValue(new StringValue(strVersion));                      }                  }                    if (buffer.Length == 5 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("local"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to local() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new LocalValue(val);                      }                        if (toDate.Equals("cycle"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var param = new List<Value>();                            var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              param.AddRange(comma.Values);                          }                          else                          {                              param.Add(val);                          }                            return new CycleValue(param);                      }                        if (toDate.Equals("steps"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to steps() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var steps = comma != null ? comma.Values.ElementAt(0) : val;                          var dir = comma != null ? comma.Values.ElementAt(1) : null;                            return new StepsValue(steps' dir);                      }                  }                    if (buffer.Length == 6 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("format"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to format() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new FormatValue(val);                      }                  }                    if (buffer.Length == 7 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counter"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counter() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CounterValue(counter' style);                      }                  }                    if (buffer.Length == 8 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counters"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counters() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CountersValue(counter' style);                      }                  }                    if (buffer.Length == 12 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("cubic-bezier"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma == null || comma.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Excepted 4 parameters to cubic-bezier()");                              throw new StoppedParsingException();                          }                            return                              new CubicBezierValue(                                  comma.Values.ElementAt(0)'                                  comma.Values.ElementAt(1)'                                  comma.Values.ElementAt(2)'                                  comma.Values.ElementAt(3)                              );                      }                  }                    if (buffer.Length == 15 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("linear-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "linear-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new LinearGradientValue(comma.Values);                      }                        if (toDate.Equals("radial-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "radial-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new RadialGradientValue(comma.Values);                      }                  }              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The following statement contains a magic number: while (stream.HasMore() && !char.IsWhiteSpace(stream.Peek()))              {                  buffer.Append(stream.Read());                    if (buffer.Length == 3 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgb"' StringComparison.InvariantCultureIgnoreCase) || toDate.Equals("hsl"' StringComparison.InvariantCultureIgnoreCase))                      {                          var group = ParseGroup(stream' forPosition);                          var @params = group.Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 3)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            if(toDate == "rgb")                           {                              return                                  new RGBColorValue(                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                            if (toDate == "hsl")                          {                              return                                  new HSLColorValue                                  (                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                      }                        if (toDate.Equals("url"' StringComparison.InvariantCultureIgnoreCase))                      {                          var value = ParseGroup(stream' forPosition).Value;                            if(value is StringValue || value is QuotedStringValue)                          {                              return new UrlValue(value);                          }                            Current.RecordError(ErrorType.Parser' forPosition' "Expected string or quoted string");                          throw new StoppedParsingException();                      }                  }                    if (buffer.Length == 4 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgba"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 4 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            return                              new RGBAColorValue(                                  @params.Values.ElementAt(0)'                                  @params.Values.ElementAt(1)'                                  @params.Values.ElementAt(2)'                                  @params.Values.ElementAt(3)                              );                      }                        if (toDate.Equals("attr"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            Value attrAndType' attr' type' fallback;                            var comma = @params as CommaDelimittedValue;                          if (comma != null)                          {                              if (comma.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects 1 or 2 parameters' found " + comma);                                  throw new StoppedParsingException();                              }                                attrAndType = comma.Values.ElementAt(0);                                fallback = comma.Values.Count() == 2 ? comma.Values.ElementAt(1) : null;                          }                          else                          {                              attrAndType = @params;                              fallback = null;                          }                            var compound = attrAndType as CompoundValue;                          if (compound != null)                          {                              if (compound.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects an attribute name and optionally a type' found " + compound);                                  throw new StoppedParsingException();                              }                                attr = compound.Values.ElementAt(0);                              type = compound.Values.Count() == 2 ? compound.Values.ElementAt(1) : null;                          }                          else                          {                              attr = attrAndType;                              type = null;                          }                            return new AttributeValue(attr' type' fallback);                      }                        if (toDate.Equals("calc"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            if (@params is CommaDelimittedValue)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "calc expects an expression' found " + @params);                          }                            string strVersion;                          using(var writer = new StringWriter())                          {                              @params.Write(writer);                              strVersion = writer.ToString();                          }                            // Things passed to calc are opting out of More magic' they don't get anything but in string replacements                          return new CalcValue(new StringValue(strVersion));                      }                  }                    if (buffer.Length == 5 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("local"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to local() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new LocalValue(val);                      }                        if (toDate.Equals("cycle"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var param = new List<Value>();                            var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              param.AddRange(comma.Values);                          }                          else                          {                              param.Add(val);                          }                            return new CycleValue(param);                      }                        if (toDate.Equals("steps"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to steps() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var steps = comma != null ? comma.Values.ElementAt(0) : val;                          var dir = comma != null ? comma.Values.ElementAt(1) : null;                            return new StepsValue(steps' dir);                      }                  }                    if (buffer.Length == 6 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("format"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to format() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new FormatValue(val);                      }                  }                    if (buffer.Length == 7 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counter"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counter() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CounterValue(counter' style);                      }                  }                    if (buffer.Length == 8 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counters"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counters() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CountersValue(counter' style);                      }                  }                    if (buffer.Length == 12 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("cubic-bezier"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma == null || comma.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Excepted 4 parameters to cubic-bezier()");                              throw new StoppedParsingException();                          }                            return                              new CubicBezierValue(                                  comma.Values.ElementAt(0)'                                  comma.Values.ElementAt(1)'                                  comma.Values.ElementAt(2)'                                  comma.Values.ElementAt(3)                              );                      }                  }                    if (buffer.Length == 15 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("linear-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "linear-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new LinearGradientValue(comma.Values);                      }                        if (toDate.Equals("radial-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "radial-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new RadialGradientValue(comma.Values);                      }                  }              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The following statement contains a magic number: while (stream.HasMore() && !char.IsWhiteSpace(stream.Peek()))              {                  buffer.Append(stream.Read());                    if (buffer.Length == 3 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgb"' StringComparison.InvariantCultureIgnoreCase) || toDate.Equals("hsl"' StringComparison.InvariantCultureIgnoreCase))                      {                          var group = ParseGroup(stream' forPosition);                          var @params = group.Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 3)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            if(toDate == "rgb")                           {                              return                                  new RGBColorValue(                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                            if (toDate == "hsl")                          {                              return                                  new HSLColorValue                                  (                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                      }                        if (toDate.Equals("url"' StringComparison.InvariantCultureIgnoreCase))                      {                          var value = ParseGroup(stream' forPosition).Value;                            if(value is StringValue || value is QuotedStringValue)                          {                              return new UrlValue(value);                          }                            Current.RecordError(ErrorType.Parser' forPosition' "Expected string or quoted string");                          throw new StoppedParsingException();                      }                  }                    if (buffer.Length == 4 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgba"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 4 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            return                              new RGBAColorValue(                                  @params.Values.ElementAt(0)'                                  @params.Values.ElementAt(1)'                                  @params.Values.ElementAt(2)'                                  @params.Values.ElementAt(3)                              );                      }                        if (toDate.Equals("attr"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            Value attrAndType' attr' type' fallback;                            var comma = @params as CommaDelimittedValue;                          if (comma != null)                          {                              if (comma.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects 1 or 2 parameters' found " + comma);                                  throw new StoppedParsingException();                              }                                attrAndType = comma.Values.ElementAt(0);                                fallback = comma.Values.Count() == 2 ? comma.Values.ElementAt(1) : null;                          }                          else                          {                              attrAndType = @params;                              fallback = null;                          }                            var compound = attrAndType as CompoundValue;                          if (compound != null)                          {                              if (compound.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects an attribute name and optionally a type' found " + compound);                                  throw new StoppedParsingException();                              }                                attr = compound.Values.ElementAt(0);                              type = compound.Values.Count() == 2 ? compound.Values.ElementAt(1) : null;                          }                          else                          {                              attr = attrAndType;                              type = null;                          }                            return new AttributeValue(attr' type' fallback);                      }                        if (toDate.Equals("calc"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            if (@params is CommaDelimittedValue)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "calc expects an expression' found " + @params);                          }                            string strVersion;                          using(var writer = new StringWriter())                          {                              @params.Write(writer);                              strVersion = writer.ToString();                          }                            // Things passed to calc are opting out of More magic' they don't get anything but in string replacements                          return new CalcValue(new StringValue(strVersion));                      }                  }                    if (buffer.Length == 5 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("local"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to local() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new LocalValue(val);                      }                        if (toDate.Equals("cycle"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var param = new List<Value>();                            var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              param.AddRange(comma.Values);                          }                          else                          {                              param.Add(val);                          }                            return new CycleValue(param);                      }                        if (toDate.Equals("steps"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to steps() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var steps = comma != null ? comma.Values.ElementAt(0) : val;                          var dir = comma != null ? comma.Values.ElementAt(1) : null;                            return new StepsValue(steps' dir);                      }                  }                    if (buffer.Length == 6 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("format"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to format() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new FormatValue(val);                      }                  }                    if (buffer.Length == 7 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counter"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counter() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CounterValue(counter' style);                      }                  }                    if (buffer.Length == 8 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counters"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counters() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CountersValue(counter' style);                      }                  }                    if (buffer.Length == 12 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("cubic-bezier"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma == null || comma.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Excepted 4 parameters to cubic-bezier()");                              throw new StoppedParsingException();                          }                            return                              new CubicBezierValue(                                  comma.Values.ElementAt(0)'                                  comma.Values.ElementAt(1)'                                  comma.Values.ElementAt(2)'                                  comma.Values.ElementAt(3)                              );                      }                  }                    if (buffer.Length == 15 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("linear-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "linear-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new LinearGradientValue(comma.Values);                      }                        if (toDate.Equals("radial-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "radial-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new RadialGradientValue(comma.Values);                      }                  }              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseString,The following statement contains a magic number: while (stream.HasMore() && !char.IsWhiteSpace(stream.Peek()))              {                  buffer.Append(stream.Read());                    if (buffer.Length == 3 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgb"' StringComparison.InvariantCultureIgnoreCase) || toDate.Equals("hsl"' StringComparison.InvariantCultureIgnoreCase))                      {                          var group = ParseGroup(stream' forPosition);                          var @params = group.Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 3)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            if(toDate == "rgb")                           {                              return                                  new RGBColorValue(                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                            if (toDate == "hsl")                          {                              return                                  new HSLColorValue                                  (                                      @params.Values.ElementAt(0)'                                      @params.Values.ElementAt(1)'                                      @params.Values.ElementAt(2)                                  );                          }                      }                        if (toDate.Equals("url"' StringComparison.InvariantCultureIgnoreCase))                      {                          var value = ParseGroup(stream' forPosition).Value;                            if(value is StringValue || value is QuotedStringValue)                          {                              return new UrlValue(value);                          }                            Current.RecordError(ErrorType.Parser' forPosition' "Expected string or quoted string");                          throw new StoppedParsingException();                      }                  }                    if (buffer.Length == 4 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("rgba"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value as CommaDelimittedValue;                          if (@params == null || @params.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 4 parameters to '" + toDate + "'");                              throw new StoppedParsingException();                          }                            return                              new RGBAColorValue(                                  @params.Values.ElementAt(0)'                                  @params.Values.ElementAt(1)'                                  @params.Values.ElementAt(2)'                                  @params.Values.ElementAt(3)                              );                      }                        if (toDate.Equals("attr"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            Value attrAndType' attr' type' fallback;                            var comma = @params as CommaDelimittedValue;                          if (comma != null)                          {                              if (comma.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects 1 or 2 parameters' found " + comma);                                  throw new StoppedParsingException();                              }                                attrAndType = comma.Values.ElementAt(0);                                fallback = comma.Values.Count() == 2 ? comma.Values.ElementAt(1) : null;                          }                          else                          {                              attrAndType = @params;                              fallback = null;                          }                            var compound = attrAndType as CompoundValue;                          if (compound != null)                          {                              if (compound.Values.Count() > 2)                              {                                  Current.RecordError(ErrorType.Parser' forPosition' "attr expects an attribute name and optionally a type' found " + compound);                                  throw new StoppedParsingException();                              }                                attr = compound.Values.ElementAt(0);                              type = compound.Values.Count() == 2 ? compound.Values.ElementAt(1) : null;                          }                          else                          {                              attr = attrAndType;                              type = null;                          }                            return new AttributeValue(attr' type' fallback);                      }                        if (toDate.Equals("calc"' StringComparison.InvariantCultureIgnoreCase))                      {                          var @params = ParseGroup(stream' forPosition).Value;                            if (@params is CommaDelimittedValue)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "calc expects an expression' found " + @params);                          }                            string strVersion;                          using(var writer = new StringWriter())                          {                              @params.Write(writer);                              strVersion = writer.ToString();                          }                            // Things passed to calc are opting out of More magic' they don't get anything but in string replacements                          return new CalcValue(new StringValue(strVersion));                      }                  }                    if (buffer.Length == 5 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("local"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to local() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new LocalValue(val);                      }                        if (toDate.Equals("cycle"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var param = new List<Value>();                            var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              param.AddRange(comma.Values);                          }                          else                          {                              param.Add(val);                          }                            return new CycleValue(param);                      }                        if (toDate.Equals("steps"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to steps() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var steps = comma != null ? comma.Values.ElementAt(0) : val;                          var dir = comma != null ? comma.Values.ElementAt(1) : null;                            return new StepsValue(steps' dir);                      }                  }                    if (buffer.Length == 6 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("format"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected 1 parameter to format() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            return new FormatValue(val);                      }                  }                    if (buffer.Length == 7 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counter"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counter() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CounterValue(counter' style);                      }                  }                    if (buffer.Length == 8 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("counters"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma != null && comma.Values.Count() > 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Expected at most 2 parameters to counters() value' found " + comma.Values.Count());                              throw new StoppedParsingException();                          }                            var counter = comma != null ? comma.Values.ElementAt(0) : val;                          var style = comma != null ? comma.Values.ElementAt(1) : null;                            return new CountersValue(counter' style);                      }                  }                    if (buffer.Length == 12 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("cubic-bezier"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                          if (comma == null || comma.Values.Count() != 4)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "Excepted 4 parameters to cubic-bezier()");                              throw new StoppedParsingException();                          }                            return                              new CubicBezierValue(                                  comma.Values.ElementAt(0)'                                  comma.Values.ElementAt(1)'                                  comma.Values.ElementAt(2)'                                  comma.Values.ElementAt(3)                              );                      }                  }                    if (buffer.Length == 15 && (stream.HasMore() && stream.Peek() == '('))                  {                      var toDate = buffer.ToString();                      if (toDate.Equals("linear-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "linear-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new LinearGradientValue(comma.Values);                      }                        if (toDate.Equals("radial-gradient"' StringComparison.InvariantCultureIgnoreCase))                      {                          var val = ParseGroup(stream' forPosition).Value;                          var comma = val as CommaDelimittedValue;                            if (comma == null || comma.Values.Count() < 2)                          {                              Current.RecordError(ErrorType.Parser' forPosition' "radial-gradient expects at least two parameters");                              throw new StoppedParsingException();                          }                            return new RadialGradientValue(comma.Values);                      }                  }              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseHashColor,The following statement contains a magic number: while (buffer.Length < 6 && stream.HasMore() && char.ToLower(stream.Peek()).In('a'' 'b'' 'c'' 'd'' 'e'' 'f'' '1'' '2'' '3'' '4'' '5'' '6'' '7'' '8'' '9'' '0'))              {                  buffer.Append(stream.Read());              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseHashColor,The following statement contains a magic number: if (buffer.Length != 3 && buffer.Length != 6)              {                  Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 or 6 hexidecimal characters");                  throw new StoppedParsingException();              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseHashColor,The following statement contains a magic number: if (buffer.Length != 3 && buffer.Length != 6)              {                  Current.RecordError(ErrorType.Parser' forPosition' "Expected 3 or 6 hexidecimal characters");                  throw new StoppedParsingException();              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseHashColor,The following statement contains a magic number: if (buffer.Length == 3)              {                  return HexTripleColorValue.Parse(buffer.ToString());              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParsePossibleUnit,The following statement contains a magic number: foreach (var name in UnitTwoLetterDictionary.Keys)              {                  if (inStr.StartsWith(name' StringComparison.InvariantCultureIgnoreCase))                  {                      pushBack = inStr.Skip(2).ToList();                      return UnitTwoLetterDictionary[name];                  }              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParsePossibleUnit,The following statement contains a magic number: if (inStr.StartsWith("khz"' StringComparison.InvariantCultureIgnoreCase))              {                  pushBack = inStr.Skip(3).ToList();                  return Unit.KHZ;              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParsePossibleUnit,The following statement contains a magic number: if (inStr.StartsWith("rem"' StringComparison.InvariantCultureIgnoreCase))              {                  pushBack = inStr.Skip(3).ToList();                  return Unit.REM;              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParsePossibleUnit,The following statement contains a magic number: if (inStr.StartsWith("deg"' StringComparison.InvariantCultureIgnoreCase))              {                  pushBack = inStr.Skip(3).ToList();                  return Unit.DEG;              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParsePossibleUnit,The following statement contains a magic number: if (inStr.StartsWith("rad"' StringComparison.InvariantCultureIgnoreCase))              {                  pushBack = inStr.Skip(3).ToList();                  return Unit.RAD;              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParsePossibleUnit,The following statement contains a magic number: if (inStr.StartsWith("dpi"' StringComparison.InvariantCultureIgnoreCase))              {                  pushBack = inStr.Skip(3).ToList();                  return Unit.DPI;              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParsePossibleUnit,The following statement contains a magic number: if (inStr.StartsWith("dpcm"' StringComparison.InvariantCultureIgnoreCase))              {                  pushBack = inStr.Skip(4).ToList();                  return Unit.DPCM;              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParsePossibleUnit,The following statement contains a magic number: if (inStr.StartsWith("grad"' StringComparison.InvariantCultureIgnoreCase))              {                  pushBack = inStr.Skip(4).ToList();                  return Unit.GRAD;              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParsePossibleUnit,The following statement contains a magic number: if (inStr.StartsWith("turn"' StringComparison.InvariantCultureIgnoreCase))              {                  pushBack = inStr.Skip(4).ToList();                  return Unit.TURN;              }
Magic Number,MoreInternals.Parser,MoreValueParser,C:\repos\kevin-montrose_More\MoreInternals\Parser\MoreValueParser.cs,ParseNumber,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  if (stream.HasMore())                  {                      nextFour.Append(stream.Read());                  }              }
Magic Number,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseKeyFrame,The following statement contains a magic number: foreach (var p in percentsStr.Split(''').Select(s => s.Trim()))              {                  if (p.Length == 0)                  {                      Current.RecordError(ErrorType.Parser' Position.Create(start' stream.Position' Current.CurrentFilePath)' "Expected `from`' `to`' or a percentage");                      throw new StoppedParsingException();                  }                    decimal percent;                  if (p.Equals("from"' StringComparison.InvariantCultureIgnoreCase))                  {                      percent = 0;                  }                  else                  {                      if (p.Equals("to"' StringComparison.InvariantCultureIgnoreCase))                      {                          percent = 100;                      }                      else                      {                          if (!p.EndsWith("%") || !decimal.TryParse(p.Substring(0' p.Length -1 )' out percent))                          {                              Current.RecordError(ErrorType.Parser' Position.Create(start' stream.Position' Current.CurrentFilePath)' "Expected `from`' `to`' or a percentage.  Found `" + p + "`");                              throw new StoppedParsingException();                          }                      }                  }                    percents.Add(percent);              }
Magic Number,MoreInternals.Parser,Parser,C:\repos\kevin-montrose_More\MoreInternals\Parser\Parser.cs,ParseBackgroundPositionValue,The following statement contains a magic number: if (parts.Length != 2)              {                  return MoreValueParser.Parse(value' pos);              }
Missing Default,MoreInternals.Compiler.Tasks,Verify,C:\repos\kevin-montrose_More\MoreInternals\Compiler\Tasks\Verify.cs,IsValidTypeFor,The following switch statement is missing a default case: switch (featureName.ToLowerInvariant())              {                  case "monochrome":                  case "color":                  case "color-index":                       // Must be a non-negative integer                      var numValue = ((NumberValue)value).Value;                      return Math.Sign(numValue) != -1 && Math.Truncate(numValue) == numValue;                    case "grid": return ((NumberValue)value).Value.In(0' 1);                    case "orientation": return ((StringValue)value).Value.ToLowerInvariant().In("landscape"' "portrait");                  case "resolution": return ((NumberWithUnitValue)value).Unit.In(Unit.DPI' Unit.DPCM);                    case "scan": return ((StringValue)value).Value.ToLowerInvariant().In("progressive"' "scan");              }
Missing Default,MoreInternals.Model,PseudoClassSelector,C:\repos\kevin-montrose_More\MoreInternals\Model\Selector.cs,Parse,The following switch statement is missing a default case: switch (name)              {                  case "link": return LinkSingleton.BindToPosition(start' stop' filePath);                  case "visited": return VisitedSingleton.BindToPosition(start' stop' filePath);                  case "active": return ActiveSingleton.BindToPosition(start' stop' filePath);                  case "hover": return HoverSingleton.BindToPosition(start' stop' filePath);                  case "focus": return FocusSingleton.BindToPosition(start' stop' filePath);                  case "first-letter": return FirstLetterSingleton.BindToPosition(start' stop' filePath);                  case "first-line": return FirstLineSingleton.BindToPosition(start' stop' filePath);                  case "first-child": return FirstChildSingleton.BindToPosition(start' stop' filePath);                  case "before": return BeforeSingleton.BindToPosition(start' stop' filePath);                  case "after": return AfterSingleton.BindToPosition(start' stop' filePath);                  case "last-child": return LastChildSingleton.BindToPosition(start' stop' filePath);                  case "empty": return EmptySingleton.BindToPosition(start' stop' filePath);                  case "checked": return CheckedSingleton.BindToPosition(start' stop' filePath);                  case "disabled": return DisabledSingleton.BindToPosition(start' stop' filePath);                  case "first-of-type": return FirstOfTypeSingleton.BindToPosition(start' stop' filePath);                  case "last-of-type": return LastOfTypeSingleton.BindToPosition(start' stop' filePath);                  case "only-child": return OnlyChildSingleton.BindToPosition(start' stop' filePath);                  case "only-of-type": return OnlyOfTypeSingleton.BindToPosition(start' stop' filePath);                  case "root": return RootSingleton.BindToPosition(start' stop' filePath);                  case "target": return TargetSingleton.BindToPosition(start' stop' filePath);                  case "enabled": return EnabledSingleton.BindToPosition(start' stop' filePath);                  case "default": return DefaultSingleton.BindToPosition(start' stop' filePath);                  case "valid": return ValidSingleton.BindToPosition(start' stop' filePath);                  case "invalid": return InvalidSingleton.BindToPosition(start' stop' filePath);                  case "in-range": return InRangeSingleton.BindToPosition(start' stop' filePath);                  case "out-of-range": return OutOfRangeSingleton.BindToPosition(start' stop' filePath);                  case "required": return RequiredSingleton.BindToPosition(start' stop' filePath);                  case "optional": return OptionalSingleton.BindToPosition(start' stop' filePath);                  case "read-only": return ReadOnlySingleton.BindToPosition(start' stop' filePath);                  case "read-write": return ReadWriteSingleton.BindToPosition(start' stop' filePath);              }
