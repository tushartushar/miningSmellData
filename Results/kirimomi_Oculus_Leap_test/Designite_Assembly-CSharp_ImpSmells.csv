Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Leap,Config,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Config.cs,handleConfigResponse,Cyclomatic complexity of the method is 19
Complex Method,Leap,LeapHandController,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\LeapHandController.cs,UpdateHandRepresentations,Cyclomatic complexity of the method is 9
Complex Method,Leap,LeapProvider,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\LeapProvider.cs,GetDeviceInfo,Cyclomatic complexity of the method is 12
Complex Method,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,processMessages,Cyclomatic complexity of the method is 61
Complex Method,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleFailedImageRequest,Cyclomatic complexity of the method is 22
Complex Method,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleFailedDevice,Cyclomatic complexity of the method is 16
Complex Method,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleConfigResponse,Cyclomatic complexity of the method is 18
Long Parameter List,Leap,Arm,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Arm.cs,Arm,The method has 8 parameters.
Long Parameter List,Leap,Bone,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Bone.cs,Bone,The method has 8 parameters.
Long Parameter List,Leap,CSharpExtensions,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\CSharpExtensions.cs,DispatchOnContext,The method has 5 parameters.
Long Parameter List,Leap,Device,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Device.cs,Device,The method has 8 parameters.
Long Parameter List,Leap,Device,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Device.cs,Update,The method has 7 parameters.
Long Parameter List,Leap,ImageRequestFailedEventArgs,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Events.cs,ImageRequestFailedEventArgs,The method has 5 parameters.
Long Parameter List,Leap,Finger,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Finger.cs,Finger,The method has 16 parameters.
Long Parameter List,Leap,Hand,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Hand.cs,Hand,The method has 18 parameters.
Long Parameter List,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,Matrix,The method has 9 parameters.
Long Parameter List,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,Matrix,The method has 12 parameters.
Long Parameter List,Leap,TrackedQuad,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\TrackedQuad.cs,TrackedQuad,The method has 8 parameters.
Long Parameter List,Leap,TestHandFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\Hands\TestHandFactory.cs,MakeFinger,The method has 8 parameters.
Long Parameter List,Leap,TestHandFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\Hands\TestHandFactory.cs,MakeBone,The method has 6 parameters.
Long Parameter List,LeapInternal,ImageData,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\ImageData.cs,CompleteImageData,The method has 14 parameters.
Long Statement,Leap,Arm,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Arm.cs,TransformedCopy,The length of the statement  "	return new Arm (trs.TransformPoint (PrevJoint)' trs.TransformPoint (NextJoint)' trs.TransformPoint (Center)' trs.TransformDirection (Direction)' Length * dScale' Width * hScale' Type' trs * Basis); " is 197.
Long Statement,Leap,Bone,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Bone.cs,TransformedCopy,The length of the statement  "	return new Bone (trs.TransformPoint (_prevJoint)' trs.TransformPoint (_nextJoint)' trs.TransformPoint (_center)' trs.TransformDirection (_direction).Normalized' _length * dScale' _width * hScale' _type' trs * _basis); " is 217.
Long Statement,Leap,Bone,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Bone.cs,Equals,The length of the statement  "	return this.IsValid && other.IsValid && (this.Center == other.Center) && (this.Direction == other.Direction) && (this.Length == other.Length); " is 142.
Long Statement,Leap,Finger,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Finger.cs,TransformedCopy,The length of the statement  "	return new Finger (_frameId' _handID' _id' _timeVisible' trs.TransformPoint (_tipPosition)' trs.TransformPoint (_tipVelocity)' trs.TransformDirection (_direction).Normalized' trs.TransformPoint (_stabilizedTipPosition)' _width * hScale' _length * dScale' _isExtended' _type' _bones [0].TransformedCopy (trs)' _bones [1].TransformedCopy (trs)' _bones [2].TransformedCopy (trs)' _bones [3].TransformedCopy (trs)); " is 411.
Long Statement,Leap,Frame,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Frame.cs,TransformedCopy,The length of the statement  "	Frame transformedFrame = new Frame (_id' _timestamp' _fps' new InteractionBox (InteractionBox.Center' InteractionBox.Size)); " is 124.
Long Statement,Leap,Hand,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Hand.cs,TransformedCopy,The length of the statement  "	return new Hand (_frameId' _id' _confidence' _grabStrength' _grabAngle' _pinchStrength' _pinchDistance' _palmWidth * hScale' _isLeft' _timeVisible' _arm.TransformedCopy (trs)' transformedFingers' trs.TransformPoint (_palmPosition)' trs.TransformPoint (_stabilizedPalmPosition)' trs.TransformPoint (_palmVelocity)' trs.TransformDirection (_palmNormal).Normalized' trs.TransformDirection (_direction).Normalized' trs.TransformPoint (_wristPosition)); " is 448.
Long Statement,Leap,Hand,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Hand.cs,TranslationProbability,The length of the statement  "	//TODO probabilities based on comparison of percentage of "likely" max change (scale:.5' trans' 100mm' rotation 45 degrees) -- time normalize? " is 142.
Long Statement,Leap,Image,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Image.cs,Warp,The length of the statement  "		float dX = dX1 * (1 - weightX) * (1 - weightY) + dX2 * weightX * (1 - weightY) + dX3 * (1 - weightX) * weightY + dX4 * weightX * weightY; " is 137.
Long Statement,Leap,Image,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Image.cs,Warp,The length of the statement  "		float dY = dY1 * (1 - weightX) * (1 - weightY) + dY2 * weightX * (1 - weightY) + dY3 * (1 - weightX) * weightY + dY4 * weightX * weightY; " is 137.
Long Statement,Leap,Image,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Image.cs,Equals,The length of the statement  "	return this.IsValid && other.IsValid && this.SequenceId == other.SequenceId && this.Type == other.Type && this.Timestamp == other.Timestamp; " is 140.
Long Statement,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,RigidInverse,The length of the statement  "	Matrix rotInverse = new Matrix (new Vector (xBasis [0]' yBasis [0]' zBasis [0])' new Vector (xBasis [1]' yBasis [1]' zBasis [1])' new Vector (xBasis [2]' yBasis [2]' zBasis [2])); " is 179.
Long Statement,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,_operator_mul,The length of the statement  "	return new Matrix (TransformDirection (other.xBasis)' TransformDirection (other.yBasis)' TransformDirection (other.zBasis)' TransformPoint (other.origin)); " is 155.
Long Statement,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToString,The length of the statement  "	return "xBasis: " + xBasis.ToString () + " yBasis: " + yBasis.ToString () + " zBasis: " + zBasis.ToString () + " origin: " + origin.ToString (); " is 144.
Long Statement,Leap,Vector,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Vector.cs,DistanceTo,The length of the statement  "	return (float)Math.Sqrt ((x - other.x) * (x - other.x) + (y - other.y) * (y - other.y) + (z - other.z) * (z - other.z)); " is 120.
Long Statement,Leap,HandPool,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\HandPool.cs,ValidateIHandModelPrefab,The length of the statement  "		EditorUtility.DisplayDialog ("Warning"' "This slot needs to have an instance of a prefab from your scene. Make your hand prefab a child of the LeapHanadContrller in your scene'  then drag here"' "OK"); " is 201.
Long Statement,Leap,TestHandFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\Hands\TestHandFactory.cs,MakeTestHand,The length of the statement  "	Arm arm = new Arm (elbow' armWrist' (elbow + armWrist) / 2' Vector.Forward' 250f' 41f' Bone.BoneType.TYPE_DISTAL' armBasis); " is 124.
Long Statement,Leap,TestHandFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\Hands\TestHandFactory.cs,MakeTestHand,The length of the statement  "	Hand testHand = new Hand (frameId' handId' 1.0f' 0.0f' 0.0f' 0.0f' 0.0f' 85f' isLeft' 0.0f' arm' fingers' new Vector (0' 0' 0)' new Vector (0' 0' 0)' new Vector (0' 0' 0)' Vector.Down' Vector.Backward' new Vector (-4.36385750984f' 6.5f' 31.0111342526f)); " is 254.
Long Statement,Leap,TestHandFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\Hands\TestHandFactory.cs,MakeFinger,The length of the statement  "	Bone metacarpal = MakeBone (Bone.BoneType.TYPE_METACARPAL' position + forward * proximalDistance' jointLengths [0]' 8f' forward' up); " is 133.
Long Statement,Leap,TestHandFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\Hands\TestHandFactory.cs,MakeFinger,The length of the statement  "	Bone proximal = MakeBone (Bone.BoneType.TYPE_PROXIMAL' position + forward * proximalDistance' jointLengths [1]' 8f' forward' up); " is 129.
Long Statement,Leap,TestHandFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\Hands\TestHandFactory.cs,MakeFinger,The length of the statement  "	Bone intermediate = MakeBone (Bone.BoneType.TYPE_INTERMEDIATE' position + forward * proximalDistance' jointLengths [2]' 8f' forward' up); " is 137.
Long Statement,Leap,TestHandFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\Hands\TestHandFactory.cs,MakeFinger,The length of the statement  "	Bone distal = MakeBone (Bone.BoneType.TYPE_DISTAL' position + forward * proximalDistance' jointLengths [3]' 8f' forward' up); " is 125.
Long Statement,Leap,TestHandFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\Hands\TestHandFactory.cs,MakeFinger,The length of the statement  "	return new Finger (frameId' handId' fingerId' 0.0f' position' new Vector (0' 0' 0)' forward' position' 8f' jointLengths [1] + jointLengths [2] + jointLengths [3]' true' name' bones [0]' bones [1]' bones [2]' bones [3]); " is 219.
Long Statement,Leap,TestHandFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\Hands\TestHandFactory.cs,MakeBone,The length of the statement  "	return new Bone (proximalPosition' proximalPosition + direction * length' Vector.Lerp (proximalPosition' proximalPosition + direction * length' 2)' direction' length' width' name' basis); " is 187.
Long Statement,Leap,LeapProvider,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\LeapProvider.cs,Update,The length of the statement  "	//Debug.Log("leap_controller_.Now():" + leap_controller_.Now() + " - CurrentFrame.Timestamp:" + CurrentFrame.Timestamp + " = " + (leap_controller_.Now() - CurrentFrame.Timestamp)); " is 180.
Long Statement,Leap,LeapProvider,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\LeapProvider.cs,GetFixedFrame,The length of the statement  "		if (Mathf.Abs (historyFrame.Timestamp - correctedTimestamp) < Mathf.Abs (closestFrame.Timestamp - correctedTimestamp)) { " is 120.
Long Statement,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,processMessages,The length of the statement  "						LEAP_IMAGE_FRAME_REQUEST_ERROR_EVENT failed_image_evt = LeapC.PtrToStruct<LEAP_IMAGE_FRAME_REQUEST_ERROR_EVENT> (_msg.eventStructPtr); " is 134.
Long Statement,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleImageCompletion,The length of the statement  "			if (_currentDistortionData.Data == null || _currentDistortionData.Data.Length != (2 * _currentDistortionData.Width * _currentDistortionData.Height * 2)) " is 152.
Long Statement,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleImageCompletion,The length of the statement  "		pendingImage.imageData.CompleteImageData (props.type' props.format' props.bpp' props.width' props.height' imageMsg.info.timestamp' imageMsg.info.frame_id' props.x_offset' props.y_offset' props.x_scale' props.y_scale' _currentDistortionData' LeapC.DistortionSize' imageMsg.matrix_version); " is 288.
Long Statement,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleFailedImageRequest,The length of the statement  "		ImageRequestFailedEventArgs errorEventArgs = new ImageRequestFailedEventArgs (failed_image_evt.description.frame_id' pendingImage.imageObject.Type); " is 148.
Long Statement,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleFailedImageRequest,The length of the statement  "			if (failed_image_evt.description.type == eLeapImageType.eLeapImageType_Default && _standardImageBufferSize < failed_image_evt.required_buffer_len) " is 146.
Long Statement,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleFailedImageRequest,The length of the statement  "			else if (failed_image_evt.description.type == eLeapImageType.eLeapImageType_Raw && _standardRawBufferSize < failed_image_evt.required_buffer_len) " is 145.
Long Statement,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleDevice,The length of the statement  "			(deviceInfo.caps == (UInt32)eLeapDeviceCaps.eLeapDeviceCaps_Embedded)' (deviceInfo.status == (UInt32)eLeapDeviceStatus.eLeapDeviceStatus_Streaming)' Marshal.PtrToStringAnsi (deviceInfo.serial)); " is 194.
Long Statement,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleFailedDevice,The length of the statement  "	this.LeapDeviceFailure.Dispatch<DeviceFailureEventArgs> (this' new DeviceFailureEventArgs ((uint)deviceMsg.status' failureMessage' failedSerialNumber)); " is 152.
Long Statement,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleConfigChange,The length of the statement  "	this.LeapConfigChange.Dispatch<ConfigChangeEventArgs> (this' new ConfigChangeEventArgs (config_key' configEvent.status' configEvent.requestId)); " is 144.
Long Statement,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleConfigResponse,The length of the statement  "	LEAP_CONFIG_RESPONSE_EVENT config_response_evt = LeapC.PtrToStruct<LEAP_CONFIG_RESPONSE_EVENT> (configMsg.eventStructPtr); " is 122.
Long Statement,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleConfigResponse,The length of the statement  "		LEAP_CONFIG_RESPONSE_EVENT_WITH_REF_TYPE config_ref_value = LeapC.PtrToStruct<LEAP_CONFIG_RESPONSE_EVENT_WITH_REF_TYPE> (configMsg.eventStructPtr); " is 147.
Long Statement,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,reportLogMessage,The length of the statement  "	this.LeapLogEvent.Dispatch<LogEventArgs> (this' new LogEventArgs (publicSeverity (logMsg.severity)' logMsg.timestamp' logMsg.message)); " is 135.
Long Statement,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handlePolicyChange,The length of the statement  "	this.LeapPolicyChange.Dispatch<PolicyEventArgs> (this' new PolicyEventArgs (policyMsg.current_policy' _activePolicies)); " is 120.
Long Statement,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,reportAbnormalResults,The length of the statement  "		this.LeapLogEvent.Dispatch<LogEventArgs> (this' new LogEventArgs (MessageSeverity.MESSAGE_CRITICAL' LeapC.GetNow ()' msg)); " is 123.
Long Statement,LeapInternal,LeapC,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\LeapC.cs,PtrToStruct,The length of the statement  "		Logger.Log ("Problem converting structure " + typeof(T).ToString () + " from ptr " + ptr.ToString () + " : " + e.Message); " is 122.
Long Statement,LeapInternal,ServiceFrameFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\ServiceFrameFactory.cs,makeFrame,The length of the statement  "	Frame newFrame = new Leap.Frame ((long)trackingMsg.info.frame_id' (long)trackingMsg.info.timestamp' trackingMsg.framerate' new InteractionBox (trackingMsg.interaction_box_center.ToLeapVector ()' trackingMsg.interaction_box_size.ToLeapVector ())); " is 246.
Long Statement,LeapInternal,ServiceFrameFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\ServiceFrameFactory.cs,makeQuad,The length of the statement  "	TrackedQuad quad = new TrackedQuad (quadMsg.width' quadMsg.height' quadMsg.resolutionX' quadMsg.resolutionY' quadMsg.visible' quadMsg.position.ToLeapVector ()' quadMsg.orientation.ToLeapMatrix ()' quadMsg.info.frame_id); " is 220.
Long Statement,LeapInternal,ServiceFrameFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\ServiceFrameFactory.cs,makeHand,The length of the statement  "	Hand newHand = new Hand ((int)owningFrame.Id' (int)hand.id' hand.confidence' hand.grab_strength' hand.grab_angle' hand.pinch_strength' hand.pinch_distance' palm.width' hand.type == eLeapHandType.eLeapHandType_Left' hand.visible_time' newArm' new FingerList ()' new Vector (palm.position.x' palm.position.y' palm.position.z)' new Vector (palm.stabilized_position.x' palm.stabilized_position.y' palm.stabilized_position.z)' new Vector (palm.velocity.x' palm.velocity.y' palm.velocity.z)' new Vector (palm.normal.x' palm.normal.y' palm.normal.z)' new Vector (palm.direction.x' palm.direction.y' palm.direction.z)' newArm.NextJoint//wrist position " is 643.
Long Statement,LeapInternal,ServiceFrameFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\ServiceFrameFactory.cs,makeFinger,The length of the statement  "	return new Finger ((int)owner.Id' (int)hand.id' (int)digit.finger_id' hand.visible_time' distal.NextJoint' new Vector (digit.tip_velocity.x' digit.tip_velocity.y' digit.tip_velocity.z)' intermediate.Direction' new Vector (digit.stabilized_tip_position.x' digit.stabilized_tip_position.y' digit.stabilized_tip_position.z)' intermediate.Width' proximal.Length + intermediate.Length + (distal.Length * 0.77f)' //0.77 is used in platform code for this calculation " is 459.
Long Statement,LeapInternal,ServiceFrameFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\ServiceFrameFactory.cs,makeBone,The length of the statement  "	Matrix basis = new Matrix (bone.basis.x_basis.x' bone.basis.x_basis.y' bone.basis.x_basis.z' bone.basis.y_basis.x' bone.basis.y_basis.y' bone.basis.y_basis.z' bone.basis.z_basis.x' bone.basis.z_basis.y' bone.basis.z_basis.z); " is 225.
Long Statement,LeapInternal,ServiceFrameFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\ServiceFrameFactory.cs,makeArm,The length of the statement  "	Matrix basis = new Matrix (bone.basis.x_basis.x' bone.basis.x_basis.y' bone.basis.x_basis.z' bone.basis.y_basis.x' bone.basis.y_basis.y' bone.basis.y_basis.z' bone.basis.z_basis.x' bone.basis.z_basis.y' bone.basis.z_basis.z); " is 225.
Virtual Method Call from Constructor,Leap,HandProxy,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\HandProxy.cs,HandProxy,The constructor "HandProxy" calls a virtual method "Reset".
Magic Number,Leap,Finger,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Finger.cs,Finger,The following statement contains a magic number: _bones [2] = intermediate;  
Magic Number,Leap,Finger,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Finger.cs,Finger,The following statement contains a magic number: _bones [3] = distal;  
Magic Number,Leap,Finger,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Finger.cs,Finger,The following statement contains a magic number: _id = (handId * 10) + fingerId;  
Magic Number,Leap,Finger,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Finger.cs,TransformedCopy,The following statement contains a magic number: return new Finger (_frameId' _handID' _id' _timeVisible' trs.TransformPoint (_tipPosition)' trs.TransformPoint (_tipVelocity)' trs.TransformDirection (_direction).Normalized' trs.TransformPoint (_stabilizedTipPosition)' _width * hScale' _length * dScale' _isExtended' _type' _bones [0].TransformedCopy (trs)' _bones [1].TransformedCopy (trs)' _bones [2].TransformedCopy (trs)' _bones [3].TransformedCopy (trs));  
Magic Number,Leap,Finger,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Finger.cs,TransformedCopy,The following statement contains a magic number: return new Finger (_frameId' _handID' _id' _timeVisible' trs.TransformPoint (_tipPosition)' trs.TransformPoint (_tipVelocity)' trs.TransformDirection (_direction).Normalized' trs.TransformPoint (_stabilizedTipPosition)' _width * hScale' _length * dScale' _isExtended' _type' _bones [0].TransformedCopy (trs)' _bones [1].TransformedCopy (trs)' _bones [2].TransformedCopy (trs)' _bones [3].TransformedCopy (trs));  
Magic Number,Leap,Finger,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Finger.cs,JointPosition,The following statement contains a magic number: switch (jointIx) {  case FingerJoint.JOINT_MCP:  	return _bones [0].NextJoint;  case FingerJoint.JOINT_PIP:  	return _bones [1].NextJoint;  case FingerJoint.JOINT_DIP:  	return _bones [2].NextJoint;  case FingerJoint.JOINT_TIP:  	return _bones [3].NextJoint;  }  
Magic Number,Leap,Finger,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Finger.cs,JointPosition,The following statement contains a magic number: switch (jointIx) {  case FingerJoint.JOINT_MCP:  	return _bones [0].NextJoint;  case FingerJoint.JOINT_PIP:  	return _bones [1].NextJoint;  case FingerJoint.JOINT_DIP:  	return _bones [2].NextJoint;  case FingerJoint.JOINT_TIP:  	return _bones [3].NextJoint;  }  
Magic Number,Leap,Finger,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Finger.cs,JointPosition,The following statement contains a magic number: return _bones [2].NextJoint;  
Magic Number,Leap,Finger,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Finger.cs,JointPosition,The following statement contains a magic number: return _bones [3].NextJoint;  
Magic Number,Leap,Frame,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Frame.cs,Frame,The following statement contains a magic number: _fingers = new FingerList (15);  
Magic Number,Leap,Frame,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Frame.cs,Frame,The following statement contains a magic number: _hands = new HandList (3);  
Magic Number,Leap,Frame,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Frame.cs,AddHand,The following statement contains a magic number: if (_hands == null)  	_hands = new HandList (3);  
Magic Number,Leap,Frame,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Frame.cs,AddHand,The following statement contains a magic number: _hands = new HandList (3);  
Magic Number,Leap,Frame,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Frame.cs,AddHand,The following statement contains a magic number: if (_fingers == null)  	_fingers = new FingerList (15);  
Magic Number,Leap,Frame,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Frame.cs,AddHand,The following statement contains a magic number: _fingers = new FingerList (15);  
Magic Number,Leap,Frame,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Frame.cs,Frame,The following statement contains a magic number: _fingers = new FingerList (15);  
Magic Number,Leap,Frame,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Frame.cs,Frame,The following statement contains a magic number: _hands = new HandList (3);  
Magic Number,Leap,Hand,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Hand.cs,calculateSphere,The following statement contains a magic number: _sphereCenter = PalmPosition + PalmNormal * _sphereRadius * 2;  
Magic Number,Leap,Image,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Image.cs,Warp,The following statement contains a magic number: if (this.IsValid && imageData.isComplete) {  	//Calculate the position in the calibration map (still with a fractional part)  	float calibrationX = 63 * xy.x / targetWidth;  	float calibrationY = 62 * (1 - xy.y / targetHeight);  	// The y origin is at the bottom  	//Save the fractional part to use as the weight for interpolation  	float weightX = calibrationX - (int)calibrationX;  	float weightY = calibrationY - (int)calibrationY;  	//Get the integer x'y coordinates of the closest calibration map points to the target pixel  	int x1 = (int)calibrationX;  	//Note truncation to int  	int y1 = (int)calibrationY;  	int x2 = x1 + 1;  	int y2 = y1 + 1;  	//Look up the x and y values for the 4 calibration map points around the target  	float dX1 = Distortion [x1 * 2 + y1 * DistortionWidth];  	float dX2 = Distortion [x2 * 2 + y1 * DistortionWidth];  	float dX3 = Distortion [x1 * 2 + y2 * DistortionWidth];  	float dX4 = Distortion [x2 * 2 + y2 * DistortionWidth];  	float dY1 = Distortion [x1 * 2 + y1 * DistortionWidth + 1];  	float dY2 = Distortion [x2 * 2 + y1 * DistortionWidth + 1];  	float dY3 = Distortion [x1 * 2 + y2 * DistortionWidth + 1];  	float dY4 = Distortion [x2 * 2 + y2 * DistortionWidth + 1];  	//Bilinear interpolation of the looked-up values:  	// X value  	float dX = dX1 * (1 - weightX) * (1 - weightY) + dX2 * weightX * (1 - weightY) + dX3 * (1 - weightX) * weightY + dX4 * weightX * weightY;  	// Y value  	float dY = dY1 * (1 - weightX) * (1 - weightY) + dY2 * weightX * (1 - weightY) + dY3 * (1 - weightX) * weightY + dY4 * weightX * weightY;  	return new Vector (dX * Width' dY * Height' 0);  }  
Magic Number,Leap,Image,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Image.cs,Warp,The following statement contains a magic number: if (this.IsValid && imageData.isComplete) {  	//Calculate the position in the calibration map (still with a fractional part)  	float calibrationX = 63 * xy.x / targetWidth;  	float calibrationY = 62 * (1 - xy.y / targetHeight);  	// The y origin is at the bottom  	//Save the fractional part to use as the weight for interpolation  	float weightX = calibrationX - (int)calibrationX;  	float weightY = calibrationY - (int)calibrationY;  	//Get the integer x'y coordinates of the closest calibration map points to the target pixel  	int x1 = (int)calibrationX;  	//Note truncation to int  	int y1 = (int)calibrationY;  	int x2 = x1 + 1;  	int y2 = y1 + 1;  	//Look up the x and y values for the 4 calibration map points around the target  	float dX1 = Distortion [x1 * 2 + y1 * DistortionWidth];  	float dX2 = Distortion [x2 * 2 + y1 * DistortionWidth];  	float dX3 = Distortion [x1 * 2 + y2 * DistortionWidth];  	float dX4 = Distortion [x2 * 2 + y2 * DistortionWidth];  	float dY1 = Distortion [x1 * 2 + y1 * DistortionWidth + 1];  	float dY2 = Distortion [x2 * 2 + y1 * DistortionWidth + 1];  	float dY3 = Distortion [x1 * 2 + y2 * DistortionWidth + 1];  	float dY4 = Distortion [x2 * 2 + y2 * DistortionWidth + 1];  	//Bilinear interpolation of the looked-up values:  	// X value  	float dX = dX1 * (1 - weightX) * (1 - weightY) + dX2 * weightX * (1 - weightY) + dX3 * (1 - weightX) * weightY + dX4 * weightX * weightY;  	// Y value  	float dY = dY1 * (1 - weightX) * (1 - weightY) + dY2 * weightX * (1 - weightY) + dY3 * (1 - weightX) * weightY + dY4 * weightX * weightY;  	return new Vector (dX * Width' dY * Height' 0);  }  
Magic Number,Leap,Image,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Image.cs,Warp,The following statement contains a magic number: if (this.IsValid && imageData.isComplete) {  	//Calculate the position in the calibration map (still with a fractional part)  	float calibrationX = 63 * xy.x / targetWidth;  	float calibrationY = 62 * (1 - xy.y / targetHeight);  	// The y origin is at the bottom  	//Save the fractional part to use as the weight for interpolation  	float weightX = calibrationX - (int)calibrationX;  	float weightY = calibrationY - (int)calibrationY;  	//Get the integer x'y coordinates of the closest calibration map points to the target pixel  	int x1 = (int)calibrationX;  	//Note truncation to int  	int y1 = (int)calibrationY;  	int x2 = x1 + 1;  	int y2 = y1 + 1;  	//Look up the x and y values for the 4 calibration map points around the target  	float dX1 = Distortion [x1 * 2 + y1 * DistortionWidth];  	float dX2 = Distortion [x2 * 2 + y1 * DistortionWidth];  	float dX3 = Distortion [x1 * 2 + y2 * DistortionWidth];  	float dX4 = Distortion [x2 * 2 + y2 * DistortionWidth];  	float dY1 = Distortion [x1 * 2 + y1 * DistortionWidth + 1];  	float dY2 = Distortion [x2 * 2 + y1 * DistortionWidth + 1];  	float dY3 = Distortion [x1 * 2 + y2 * DistortionWidth + 1];  	float dY4 = Distortion [x2 * 2 + y2 * DistortionWidth + 1];  	//Bilinear interpolation of the looked-up values:  	// X value  	float dX = dX1 * (1 - weightX) * (1 - weightY) + dX2 * weightX * (1 - weightY) + dX3 * (1 - weightX) * weightY + dX4 * weightX * weightY;  	// Y value  	float dY = dY1 * (1 - weightX) * (1 - weightY) + dY2 * weightX * (1 - weightY) + dY3 * (1 - weightX) * weightY + dY4 * weightX * weightY;  	return new Vector (dX * Width' dY * Height' 0);  }  
Magic Number,Leap,Image,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Image.cs,Warp,The following statement contains a magic number: if (this.IsValid && imageData.isComplete) {  	//Calculate the position in the calibration map (still with a fractional part)  	float calibrationX = 63 * xy.x / targetWidth;  	float calibrationY = 62 * (1 - xy.y / targetHeight);  	// The y origin is at the bottom  	//Save the fractional part to use as the weight for interpolation  	float weightX = calibrationX - (int)calibrationX;  	float weightY = calibrationY - (int)calibrationY;  	//Get the integer x'y coordinates of the closest calibration map points to the target pixel  	int x1 = (int)calibrationX;  	//Note truncation to int  	int y1 = (int)calibrationY;  	int x2 = x1 + 1;  	int y2 = y1 + 1;  	//Look up the x and y values for the 4 calibration map points around the target  	float dX1 = Distortion [x1 * 2 + y1 * DistortionWidth];  	float dX2 = Distortion [x2 * 2 + y1 * DistortionWidth];  	float dX3 = Distortion [x1 * 2 + y2 * DistortionWidth];  	float dX4 = Distortion [x2 * 2 + y2 * DistortionWidth];  	float dY1 = Distortion [x1 * 2 + y1 * DistortionWidth + 1];  	float dY2 = Distortion [x2 * 2 + y1 * DistortionWidth + 1];  	float dY3 = Distortion [x1 * 2 + y2 * DistortionWidth + 1];  	float dY4 = Distortion [x2 * 2 + y2 * DistortionWidth + 1];  	//Bilinear interpolation of the looked-up values:  	// X value  	float dX = dX1 * (1 - weightX) * (1 - weightY) + dX2 * weightX * (1 - weightY) + dX3 * (1 - weightX) * weightY + dX4 * weightX * weightY;  	// Y value  	float dY = dY1 * (1 - weightX) * (1 - weightY) + dY2 * weightX * (1 - weightY) + dY3 * (1 - weightX) * weightY + dY4 * weightX * weightY;  	return new Vector (dX * Width' dY * Height' 0);  }  
Magic Number,Leap,Image,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Image.cs,Warp,The following statement contains a magic number: if (this.IsValid && imageData.isComplete) {  	//Calculate the position in the calibration map (still with a fractional part)  	float calibrationX = 63 * xy.x / targetWidth;  	float calibrationY = 62 * (1 - xy.y / targetHeight);  	// The y origin is at the bottom  	//Save the fractional part to use as the weight for interpolation  	float weightX = calibrationX - (int)calibrationX;  	float weightY = calibrationY - (int)calibrationY;  	//Get the integer x'y coordinates of the closest calibration map points to the target pixel  	int x1 = (int)calibrationX;  	//Note truncation to int  	int y1 = (int)calibrationY;  	int x2 = x1 + 1;  	int y2 = y1 + 1;  	//Look up the x and y values for the 4 calibration map points around the target  	float dX1 = Distortion [x1 * 2 + y1 * DistortionWidth];  	float dX2 = Distortion [x2 * 2 + y1 * DistortionWidth];  	float dX3 = Distortion [x1 * 2 + y2 * DistortionWidth];  	float dX4 = Distortion [x2 * 2 + y2 * DistortionWidth];  	float dY1 = Distortion [x1 * 2 + y1 * DistortionWidth + 1];  	float dY2 = Distortion [x2 * 2 + y1 * DistortionWidth + 1];  	float dY3 = Distortion [x1 * 2 + y2 * DistortionWidth + 1];  	float dY4 = Distortion [x2 * 2 + y2 * DistortionWidth + 1];  	//Bilinear interpolation of the looked-up values:  	// X value  	float dX = dX1 * (1 - weightX) * (1 - weightY) + dX2 * weightX * (1 - weightY) + dX3 * (1 - weightX) * weightY + dX4 * weightX * weightY;  	// Y value  	float dY = dY1 * (1 - weightX) * (1 - weightY) + dY2 * weightX * (1 - weightY) + dY3 * (1 - weightX) * weightY + dY4 * weightX * weightY;  	return new Vector (dX * Width' dY * Height' 0);  }  
Magic Number,Leap,Image,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Image.cs,Warp,The following statement contains a magic number: if (this.IsValid && imageData.isComplete) {  	//Calculate the position in the calibration map (still with a fractional part)  	float calibrationX = 63 * xy.x / targetWidth;  	float calibrationY = 62 * (1 - xy.y / targetHeight);  	// The y origin is at the bottom  	//Save the fractional part to use as the weight for interpolation  	float weightX = calibrationX - (int)calibrationX;  	float weightY = calibrationY - (int)calibrationY;  	//Get the integer x'y coordinates of the closest calibration map points to the target pixel  	int x1 = (int)calibrationX;  	//Note truncation to int  	int y1 = (int)calibrationY;  	int x2 = x1 + 1;  	int y2 = y1 + 1;  	//Look up the x and y values for the 4 calibration map points around the target  	float dX1 = Distortion [x1 * 2 + y1 * DistortionWidth];  	float dX2 = Distortion [x2 * 2 + y1 * DistortionWidth];  	float dX3 = Distortion [x1 * 2 + y2 * DistortionWidth];  	float dX4 = Distortion [x2 * 2 + y2 * DistortionWidth];  	float dY1 = Distortion [x1 * 2 + y1 * DistortionWidth + 1];  	float dY2 = Distortion [x2 * 2 + y1 * DistortionWidth + 1];  	float dY3 = Distortion [x1 * 2 + y2 * DistortionWidth + 1];  	float dY4 = Distortion [x2 * 2 + y2 * DistortionWidth + 1];  	//Bilinear interpolation of the looked-up values:  	// X value  	float dX = dX1 * (1 - weightX) * (1 - weightY) + dX2 * weightX * (1 - weightY) + dX3 * (1 - weightX) * weightY + dX4 * weightX * weightY;  	// Y value  	float dY = dY1 * (1 - weightX) * (1 - weightY) + dY2 * weightX * (1 - weightY) + dY3 * (1 - weightX) * weightY + dY4 * weightX * weightY;  	return new Vector (dX * Width' dY * Height' 0);  }  
Magic Number,Leap,Image,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Image.cs,Warp,The following statement contains a magic number: if (this.IsValid && imageData.isComplete) {  	//Calculate the position in the calibration map (still with a fractional part)  	float calibrationX = 63 * xy.x / targetWidth;  	float calibrationY = 62 * (1 - xy.y / targetHeight);  	// The y origin is at the bottom  	//Save the fractional part to use as the weight for interpolation  	float weightX = calibrationX - (int)calibrationX;  	float weightY = calibrationY - (int)calibrationY;  	//Get the integer x'y coordinates of the closest calibration map points to the target pixel  	int x1 = (int)calibrationX;  	//Note truncation to int  	int y1 = (int)calibrationY;  	int x2 = x1 + 1;  	int y2 = y1 + 1;  	//Look up the x and y values for the 4 calibration map points around the target  	float dX1 = Distortion [x1 * 2 + y1 * DistortionWidth];  	float dX2 = Distortion [x2 * 2 + y1 * DistortionWidth];  	float dX3 = Distortion [x1 * 2 + y2 * DistortionWidth];  	float dX4 = Distortion [x2 * 2 + y2 * DistortionWidth];  	float dY1 = Distortion [x1 * 2 + y1 * DistortionWidth + 1];  	float dY2 = Distortion [x2 * 2 + y1 * DistortionWidth + 1];  	float dY3 = Distortion [x1 * 2 + y2 * DistortionWidth + 1];  	float dY4 = Distortion [x2 * 2 + y2 * DistortionWidth + 1];  	//Bilinear interpolation of the looked-up values:  	// X value  	float dX = dX1 * (1 - weightX) * (1 - weightY) + dX2 * weightX * (1 - weightY) + dX3 * (1 - weightX) * weightY + dX4 * weightX * weightY;  	// Y value  	float dY = dY1 * (1 - weightX) * (1 - weightY) + dY2 * weightX * (1 - weightY) + dY3 * (1 - weightX) * weightY + dY4 * weightX * weightY;  	return new Vector (dX * Width' dY * Height' 0);  }  
Magic Number,Leap,Image,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Image.cs,Warp,The following statement contains a magic number: if (this.IsValid && imageData.isComplete) {  	//Calculate the position in the calibration map (still with a fractional part)  	float calibrationX = 63 * xy.x / targetWidth;  	float calibrationY = 62 * (1 - xy.y / targetHeight);  	// The y origin is at the bottom  	//Save the fractional part to use as the weight for interpolation  	float weightX = calibrationX - (int)calibrationX;  	float weightY = calibrationY - (int)calibrationY;  	//Get the integer x'y coordinates of the closest calibration map points to the target pixel  	int x1 = (int)calibrationX;  	//Note truncation to int  	int y1 = (int)calibrationY;  	int x2 = x1 + 1;  	int y2 = y1 + 1;  	//Look up the x and y values for the 4 calibration map points around the target  	float dX1 = Distortion [x1 * 2 + y1 * DistortionWidth];  	float dX2 = Distortion [x2 * 2 + y1 * DistortionWidth];  	float dX3 = Distortion [x1 * 2 + y2 * DistortionWidth];  	float dX4 = Distortion [x2 * 2 + y2 * DistortionWidth];  	float dY1 = Distortion [x1 * 2 + y1 * DistortionWidth + 1];  	float dY2 = Distortion [x2 * 2 + y1 * DistortionWidth + 1];  	float dY3 = Distortion [x1 * 2 + y2 * DistortionWidth + 1];  	float dY4 = Distortion [x2 * 2 + y2 * DistortionWidth + 1];  	//Bilinear interpolation of the looked-up values:  	// X value  	float dX = dX1 * (1 - weightX) * (1 - weightY) + dX2 * weightX * (1 - weightY) + dX3 * (1 - weightX) * weightY + dX4 * weightX * weightY;  	// Y value  	float dY = dY1 * (1 - weightX) * (1 - weightY) + dY2 * weightX * (1 - weightY) + dY3 * (1 - weightX) * weightY + dY4 * weightX * weightY;  	return new Vector (dX * Width' dY * Height' 0);  }  
Magic Number,Leap,Image,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Image.cs,Warp,The following statement contains a magic number: if (this.IsValid && imageData.isComplete) {  	//Calculate the position in the calibration map (still with a fractional part)  	float calibrationX = 63 * xy.x / targetWidth;  	float calibrationY = 62 * (1 - xy.y / targetHeight);  	// The y origin is at the bottom  	//Save the fractional part to use as the weight for interpolation  	float weightX = calibrationX - (int)calibrationX;  	float weightY = calibrationY - (int)calibrationY;  	//Get the integer x'y coordinates of the closest calibration map points to the target pixel  	int x1 = (int)calibrationX;  	//Note truncation to int  	int y1 = (int)calibrationY;  	int x2 = x1 + 1;  	int y2 = y1 + 1;  	//Look up the x and y values for the 4 calibration map points around the target  	float dX1 = Distortion [x1 * 2 + y1 * DistortionWidth];  	float dX2 = Distortion [x2 * 2 + y1 * DistortionWidth];  	float dX3 = Distortion [x1 * 2 + y2 * DistortionWidth];  	float dX4 = Distortion [x2 * 2 + y2 * DistortionWidth];  	float dY1 = Distortion [x1 * 2 + y1 * DistortionWidth + 1];  	float dY2 = Distortion [x2 * 2 + y1 * DistortionWidth + 1];  	float dY3 = Distortion [x1 * 2 + y2 * DistortionWidth + 1];  	float dY4 = Distortion [x2 * 2 + y2 * DistortionWidth + 1];  	//Bilinear interpolation of the looked-up values:  	// X value  	float dX = dX1 * (1 - weightX) * (1 - weightY) + dX2 * weightX * (1 - weightY) + dX3 * (1 - weightX) * weightY + dX4 * weightX * weightY;  	// Y value  	float dY = dY1 * (1 - weightX) * (1 - weightY) + dY2 * weightX * (1 - weightY) + dY3 * (1 - weightX) * weightY + dY4 * weightX * weightY;  	return new Vector (dX * Width' dY * Height' 0);  }  
Magic Number,Leap,Image,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Image.cs,Warp,The following statement contains a magic number: if (this.IsValid && imageData.isComplete) {  	//Calculate the position in the calibration map (still with a fractional part)  	float calibrationX = 63 * xy.x / targetWidth;  	float calibrationY = 62 * (1 - xy.y / targetHeight);  	// The y origin is at the bottom  	//Save the fractional part to use as the weight for interpolation  	float weightX = calibrationX - (int)calibrationX;  	float weightY = calibrationY - (int)calibrationY;  	//Get the integer x'y coordinates of the closest calibration map points to the target pixel  	int x1 = (int)calibrationX;  	//Note truncation to int  	int y1 = (int)calibrationY;  	int x2 = x1 + 1;  	int y2 = y1 + 1;  	//Look up the x and y values for the 4 calibration map points around the target  	float dX1 = Distortion [x1 * 2 + y1 * DistortionWidth];  	float dX2 = Distortion [x2 * 2 + y1 * DistortionWidth];  	float dX3 = Distortion [x1 * 2 + y2 * DistortionWidth];  	float dX4 = Distortion [x2 * 2 + y2 * DistortionWidth];  	float dY1 = Distortion [x1 * 2 + y1 * DistortionWidth + 1];  	float dY2 = Distortion [x2 * 2 + y1 * DistortionWidth + 1];  	float dY3 = Distortion [x1 * 2 + y2 * DistortionWidth + 1];  	float dY4 = Distortion [x2 * 2 + y2 * DistortionWidth + 1];  	//Bilinear interpolation of the looked-up values:  	// X value  	float dX = dX1 * (1 - weightX) * (1 - weightY) + dX2 * weightX * (1 - weightY) + dX3 * (1 - weightX) * weightY + dX4 * weightX * weightY;  	// Y value  	float dY = dY1 * (1 - weightX) * (1 - weightY) + dY2 * weightX * (1 - weightY) + dY3 * (1 - weightX) * weightY + dY4 * weightX * weightY;  	return new Vector (dX * Width' dY * Height' 0);  }  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray3x3,The following statement contains a magic number: output [2] = xBasis.z;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray3x3,The following statement contains a magic number: output [3] = yBasis.x;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray3x3,The following statement contains a magic number: output [4] = yBasis.y;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray3x3,The following statement contains a magic number: output [5] = yBasis.z;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray3x3,The following statement contains a magic number: output [6] = zBasis.x;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray3x3,The following statement contains a magic number: output [7] = zBasis.y;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray3x3,The following statement contains a magic number: output [8] = zBasis.z;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray3x3,The following statement contains a magic number: output [2] = xBasis.z;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray3x3,The following statement contains a magic number: output [3] = yBasis.x;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray3x3,The following statement contains a magic number: output [4] = yBasis.y;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray3x3,The following statement contains a magic number: output [5] = yBasis.z;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray3x3,The following statement contains a magic number: output [6] = zBasis.x;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray3x3,The following statement contains a magic number: output [7] = zBasis.y;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray3x3,The following statement contains a magic number: output [8] = zBasis.z;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray3x3,The following statement contains a magic number: return ToArray3x3 (new float[9]);  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [2] = xBasis.z;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [3] = 0.0f;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [4] = yBasis.x;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [5] = yBasis.y;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [6] = yBasis.z;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [7] = 0.0f;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [8] = zBasis.x;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [9] = zBasis.y;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [10] = zBasis.z;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [11] = 0.0f;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [12] = origin.x;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [13] = origin.y;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [14] = origin.z;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [15] = 1.0f;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [2] = xBasis.z;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [3] = 0.0f;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [4] = yBasis.x;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [5] = yBasis.y;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [6] = yBasis.z;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [7] = 0.0f;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [8] = zBasis.x;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [9] = zBasis.y;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [10] = zBasis.z;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [11] = 0.0f;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [12] = origin.x;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [13] = origin.y;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [14] = origin.z;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: output [15] = 1.0f;  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,ToArray4x4,The following statement contains a magic number: return ToArray4x4 (new float[16]);  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,SetRotation,The following statement contains a magic number: xBasis = new Vector (n [0] * n [0] * C + c' n [0] * n [1] * C - n [2] * s' n [0] * n [2] * C + n [1] * s);  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,SetRotation,The following statement contains a magic number: xBasis = new Vector (n [0] * n [0] * C + c' n [0] * n [1] * C - n [2] * s' n [0] * n [2] * C + n [1] * s);  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,SetRotation,The following statement contains a magic number: yBasis = new Vector (n [1] * n [0] * C + n [2] * s' n [1] * n [1] * C + c' n [1] * n [2] * C - n [0] * s);  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,SetRotation,The following statement contains a magic number: yBasis = new Vector (n [1] * n [0] * C + n [2] * s' n [1] * n [1] * C + c' n [1] * n [2] * C - n [0] * s);  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,SetRotation,The following statement contains a magic number: zBasis = new Vector (n [2] * n [0] * C - n [1] * s' n [2] * n [1] * C + n [0] * s' n [2] * n [2] * C + c);  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,SetRotation,The following statement contains a magic number: zBasis = new Vector (n [2] * n [0] * C - n [1] * s' n [2] * n [1] * C + n [0] * s' n [2] * n [2] * C + c);  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,SetRotation,The following statement contains a magic number: zBasis = new Vector (n [2] * n [0] * C - n [1] * s' n [2] * n [1] * C + n [0] * s' n [2] * n [2] * C + c);  
Magic Number,Leap,Matrix,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Matrix.cs,SetRotation,The following statement contains a magic number: zBasis = new Vector (n [2] * n [0] * C - n [1] * s' n [2] * n [1] * C + n [0] * s' n [2] * n [2] * C + c);  
Magic Number,Leap,Vector,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Vector.cs,_operator_get,The following statement contains a magic number: if (index == 2)  	return z;  
Magic Number,Leap,Vector,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Vector.cs,GetHashCode,The following statement contains a magic number: unchecked// Overflow is fine' just wrap   {  	int hash = 17;  	hash = hash * 23 + x.GetHashCode ();  	hash = hash * 23 + y.GetHashCode ();  	hash = hash * 23 + z.GetHashCode ();  	return hash;  }  
Magic Number,Leap,Vector,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Vector.cs,GetHashCode,The following statement contains a magic number: unchecked// Overflow is fine' just wrap   {  	int hash = 17;  	hash = hash * 23 + x.GetHashCode ();  	hash = hash * 23 + y.GetHashCode ();  	hash = hash * 23 + z.GetHashCode ();  	return hash;  }  
Magic Number,Leap,Vector,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Vector.cs,GetHashCode,The following statement contains a magic number: unchecked// Overflow is fine' just wrap   {  	int hash = 17;  	hash = hash * 23 + x.GetHashCode ();  	hash = hash * 23 + y.GetHashCode ();  	hash = hash * 23 + z.GetHashCode ();  	return hash;  }  
Magic Number,Leap,Vector,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Vector.cs,GetHashCode,The following statement contains a magic number: unchecked// Overflow is fine' just wrap   {  	int hash = 17;  	hash = hash * 23 + x.GetHashCode ();  	hash = hash * 23 + y.GetHashCode ();  	hash = hash * 23 + z.GetHashCode ();  	return hash;  }  
Magic Number,Leap,Vector,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Vector.cs,GetHashCode,The following statement contains a magic number: hash = hash * 23 + x.GetHashCode ();  
Magic Number,Leap,Vector,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Vector.cs,GetHashCode,The following statement contains a magic number: hash = hash * 23 + y.GetHashCode ();  
Magic Number,Leap,Vector,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Vector.cs,GetHashCode,The following statement contains a magic number: hash = hash * 23 + z.GetHashCode ();  
Magic Number,Leap,TestHandFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\Hands\TestHandFactory.cs,MakeTestFrame,The following statement contains a magic number: if (leftHandIncluded)  	testFrame.AddHand (MakeTestHand (frameId' 10' true));  
Magic Number,Leap,TestHandFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\Hands\TestHandFactory.cs,MakeTestFrame,The following statement contains a magic number: testFrame.AddHand (MakeTestHand (frameId' 10' true));  
Magic Number,Leap,TestHandFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\Hands\TestHandFactory.cs,MakeTestFrame,The following statement contains a magic number: if (rightHandIncluded)  	testFrame.AddHand (MakeTestHand (frameId' 20' false));  
Magic Number,Leap,TestHandFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\Hands\TestHandFactory.cs,MakeTestFrame,The following statement contains a magic number: testFrame.AddHand (MakeTestHand (frameId' 20' false));  
Magic Number,Leap,TestHandFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\Hands\TestHandFactory.cs,MakeMiddleFinger,The following statement contains a magic number: return MakeFinger (Finger.FingerType.TYPE_MIDDLE' position' forward' up' jointLengths' frameId' handId' handId + 2);  
Magic Number,Leap,TestHandFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\Hands\TestHandFactory.cs,MakeRingFinger,The following statement contains a magic number: return MakeFinger (Finger.FingerType.TYPE_RING' position' forward' up' jointLengths' frameId' handId' handId + 3);  
Magic Number,Leap,TestHandFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\Hands\TestHandFactory.cs,MakePinky,The following statement contains a magic number: return MakeFinger (Finger.FingerType.TYPE_PINKY' position' forward' up' jointLengths' frameId' handId' handId + 4);  
Magic Number,Leap,TestHandFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\Hands\TestHandFactory.cs,MakeFinger,The following statement contains a magic number: proximalDistance += jointLengths [2];  
Magic Number,Leap,TestHandFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\Hands\TestHandFactory.cs,MakeFinger,The following statement contains a magic number: bones [2] = intermediate;  
Magic Number,Leap,TestHandFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\Hands\TestHandFactory.cs,MakeFinger,The following statement contains a magic number: bones [3] = distal;  
Magic Number,Leap,TestHandFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\Hands\TestHandFactory.cs,MakeFinger,The following statement contains a magic number: return new Finger (frameId' handId' fingerId' 0.0f' position' new Vector (0' 0' 0)' forward' position' 8f' jointLengths [1] + jointLengths [2] + jointLengths [3]' true' name' bones [0]' bones [1]' bones [2]' bones [3]);  
Magic Number,Leap,TestHandFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\Hands\TestHandFactory.cs,MakeFinger,The following statement contains a magic number: return new Finger (frameId' handId' fingerId' 0.0f' position' new Vector (0' 0' 0)' forward' position' 8f' jointLengths [1] + jointLengths [2] + jointLengths [3]' true' name' bones [0]' bones [1]' bones [2]' bones [3]);  
Magic Number,Leap,TestHandFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\Hands\TestHandFactory.cs,MakeFinger,The following statement contains a magic number: return new Finger (frameId' handId' fingerId' 0.0f' position' new Vector (0' 0' 0)' forward' position' 8f' jointLengths [1] + jointLengths [2] + jointLengths [3]' true' name' bones [0]' bones [1]' bones [2]' bones [3]);  
Magic Number,Leap,TestHandFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\Hands\TestHandFactory.cs,MakeFinger,The following statement contains a magic number: return new Finger (frameId' handId' fingerId' 0.0f' position' new Vector (0' 0' 0)' forward' position' 8f' jointLengths [1] + jointLengths [2] + jointLengths [3]' true' name' bones [0]' bones [1]' bones [2]' bones [3]);  
Magic Number,Leap,TestHandFactory,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\Hands\TestHandFactory.cs,MakeBone,The following statement contains a magic number: return new Bone (proximalPosition' proximalPosition + direction * length' Vector.Lerp (proximalPosition' proximalPosition + direction * length' 2)' direction' length' width' name' basis);  
Magic Number,Leap,LeapProvider,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\LeapProvider.cs,GetDeviceInfo,The following statement contains a magic number: if (devices.Count == 1) {  	LeapDeviceInfo info = new LeapDeviceInfo (LeapDeviceType.Peripheral);  	// TODO: DeviceList does not tell us the device type. Dragonfly serial starts with "LE" and peripheral starts with "LP"  	if (devices [0].SerialNumber.Length >= 2) {  		switch (devices [0].SerialNumber.Substring (0' 2)) {  		case ("LP"):  			info = new LeapDeviceInfo (LeapDeviceType.Peripheral);  			break;  		case ("LE"):  			info = new LeapDeviceInfo (LeapDeviceType.Dragonfly);  			break;  		default:  			break;  		}  	}  	// TODO: Add baseline & offset when included in API  	// NOTE: Alternative is to use device type since all parameters are invariant  	info.isEmbedded = devices [0].IsEmbedded;  	info.horizontalViewAngle = devices [0].HorizontalViewAngle * Mathf.Rad2Deg;  	info.verticalViewAngle = devices [0].VerticalViewAngle * Mathf.Rad2Deg;  	info.trackingRange = devices [0].Range / 1000f;  	info.serialID = devices [0].SerialNumber;  	return info;  }  else if (devices.Count > 1) {  	return new LeapDeviceInfo (LeapDeviceType.Peripheral);  }  
Magic Number,Leap,LeapProvider,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\LeapProvider.cs,GetDeviceInfo,The following statement contains a magic number: if (devices.Count == 1) {  	LeapDeviceInfo info = new LeapDeviceInfo (LeapDeviceType.Peripheral);  	// TODO: DeviceList does not tell us the device type. Dragonfly serial starts with "LE" and peripheral starts with "LP"  	if (devices [0].SerialNumber.Length >= 2) {  		switch (devices [0].SerialNumber.Substring (0' 2)) {  		case ("LP"):  			info = new LeapDeviceInfo (LeapDeviceType.Peripheral);  			break;  		case ("LE"):  			info = new LeapDeviceInfo (LeapDeviceType.Dragonfly);  			break;  		default:  			break;  		}  	}  	// TODO: Add baseline & offset when included in API  	// NOTE: Alternative is to use device type since all parameters are invariant  	info.isEmbedded = devices [0].IsEmbedded;  	info.horizontalViewAngle = devices [0].HorizontalViewAngle * Mathf.Rad2Deg;  	info.verticalViewAngle = devices [0].VerticalViewAngle * Mathf.Rad2Deg;  	info.trackingRange = devices [0].Range / 1000f;  	info.serialID = devices [0].SerialNumber;  	return info;  }  else if (devices.Count > 1) {  	return new LeapDeviceInfo (LeapDeviceType.Peripheral);  }  
Magic Number,Leap,LeapProvider,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\LeapProvider.cs,GetDeviceInfo,The following statement contains a magic number: if (devices [0].SerialNumber.Length >= 2) {  	switch (devices [0].SerialNumber.Substring (0' 2)) {  	case ("LP"):  		info = new LeapDeviceInfo (LeapDeviceType.Peripheral);  		break;  	case ("LE"):  		info = new LeapDeviceInfo (LeapDeviceType.Dragonfly);  		break;  	default:  		break;  	}  }  
Magic Number,Leap,LeapProvider,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\LeapProvider.cs,GetDeviceInfo,The following statement contains a magic number: if (devices [0].SerialNumber.Length >= 2) {  	switch (devices [0].SerialNumber.Substring (0' 2)) {  	case ("LP"):  		info = new LeapDeviceInfo (LeapDeviceType.Peripheral);  		break;  	case ("LE"):  		info = new LeapDeviceInfo (LeapDeviceType.Dragonfly);  		break;  	default:  		break;  	}  }  
Magic Number,Leap,LeapProvider,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\LeapProvider.cs,GetDeviceInfo,The following statement contains a magic number: switch (devices [0].SerialNumber.Substring (0' 2)) {  case ("LP"):  	info = new LeapDeviceInfo (LeapDeviceType.Peripheral);  	break;  case ("LE"):  	info = new LeapDeviceInfo (LeapDeviceType.Dragonfly);  	break;  default:  	break;  }  
Magic Number,Leap,LeapProvider,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapMotion\Scripts\LeapProvider.cs,GetFixedFrame,The following statement contains a magic number: for (int searchHistoryIndex = 0; searchHistoryIndex < 60; searchHistoryIndex++) {  	leapMat = GetLeapMatrix ();  	Frame historyFrame = leap_controller_.GetTransformedFrame (leapMat' searchHistoryIndex);  	//If we reach an invalid frame' terminate the search  	if (!historyFrame.IsValid) {  		break;  	}  	if (Mathf.Abs (historyFrame.Timestamp - correctedTimestamp) < Mathf.Abs (closestFrame.Timestamp - correctedTimestamp)) {  		closestFrame = historyFrame;  	}  	else {  		//Since frames are always reported in order' we can terminate the search once we stop finding a closer frame  		break;  	}  }  
Magic Number,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,processMessages,The following statement contains a magic number: try {  	eLeapRS result;  	LeapInit.Dispatch<LeapEventArgs> (this' new LeapEventArgs (LeapEvent.EVENT_INIT));  	while (_isRunning) {  		if (_leapConnection != IntPtr.Zero) {  			LEAP_CONNECTION_MESSAGE _msg = new LEAP_CONNECTION_MESSAGE ();  			uint timeout = 1000;  			result = LeapC.PollConnection (_leapConnection' timeout' ref _msg);  			reportAbnormalResults ("LeapC PollConnection call was "' result);  			if (result == eLeapRS.eLeapRS_Success) {  				switch (_msg.type) {  				case eLeapEventType.eLeapEventType_Connection:  					LEAP_CONNECTION_EVENT connection_evt = LeapC.PtrToStruct<LEAP_CONNECTION_EVENT> (_msg.eventStructPtr);  					handleConnection (ref connection_evt);  					break;  				case eLeapEventType.eLeapEventType_ConnectionLost:  					LEAP_CONNECTION_LOST_EVENT connection_lost_evt = LeapC.PtrToStruct<LEAP_CONNECTION_LOST_EVENT> (_msg.eventStructPtr);  					handleConnectionLost (ref connection_lost_evt);  					break;  				case eLeapEventType.eLeapEventType_Device:  					LEAP_DEVICE_EVENT device_evt = LeapC.PtrToStruct<LEAP_DEVICE_EVENT> (_msg.eventStructPtr);  					handleDevice (ref device_evt);  					break;  				case eLeapEventType.eLeapEventType_DeviceLost:  					LEAP_DEVICE_EVENT device_lost_evt = LeapC.PtrToStruct<LEAP_DEVICE_EVENT> (_msg.eventStructPtr);  					handleLostDevice (ref device_lost_evt);  					break;  				case eLeapEventType.eLeapEventType_DeviceFailure:  					LEAP_DEVICE_FAILURE_EVENT device_failure_evt = LeapC.PtrToStruct<LEAP_DEVICE_FAILURE_EVENT> (_msg.eventStructPtr);  					handleFailedDevice (ref device_failure_evt);  					break;  				case eLeapEventType.eLeapEventType_Tracking:  					LEAP_TRACKING_EVENT tracking_evt = LeapC.PtrToStruct<LEAP_TRACKING_EVENT> (_msg.eventStructPtr);  					handleTrackingMessage (ref tracking_evt);  					break;  				case eLeapEventType.eLeapEventType_ImageComplete:  					completeCount++;  					LEAP_IMAGE_COMPLETE_EVENT image_complete_evt = LeapC.PtrToStruct<LEAP_IMAGE_COMPLETE_EVENT> (_msg.eventStructPtr);  					handleImageCompletion (ref image_complete_evt);  					break;  				case eLeapEventType.eLeapEventType_ImageRequestError:  					failedCount++;  					LEAP_IMAGE_FRAME_REQUEST_ERROR_EVENT failed_image_evt = LeapC.PtrToStruct<LEAP_IMAGE_FRAME_REQUEST_ERROR_EVENT> (_msg.eventStructPtr);  					handleFailedImageRequest (ref failed_image_evt);  					break;  				case eLeapEventType.eLeapEventType_TrackedQuad:  					LEAP_TRACKED_QUAD_EVENT quad_evt = LeapC.PtrToStruct<LEAP_TRACKED_QUAD_EVENT> (_msg.eventStructPtr);  					handleQuadMessage (ref quad_evt);  					break;  				case eLeapEventType.eLeapEventType_LogEvent:  					LEAP_LOG_EVENT log_evt = LeapC.PtrToStruct<LEAP_LOG_EVENT> (_msg.eventStructPtr);  					reportLogMessage (ref log_evt);  					break;  				case eLeapEventType.eLeapEventType_PolicyChange:  					LEAP_POLICY_EVENT policy_evt = LeapC.PtrToStruct<LEAP_POLICY_EVENT> (_msg.eventStructPtr);  					handlePolicyChange (ref policy_evt);  					break;  				case eLeapEventType.eLeapEventType_ConfigChange:  					LEAP_CONFIG_CHANGE_EVENT config_change_evt = LeapC.PtrToStruct<LEAP_CONFIG_CHANGE_EVENT> (_msg.eventStructPtr);  					handleConfigChange (ref config_change_evt);  					break;  				case eLeapEventType.eLeapEventType_ConfigResponse:  					handleConfigResponse (ref _msg);  					break;  				default:  					//discard unknown message types  					Logger.Log ("Unhandled message type " + Enum.GetName (typeof(eLeapEventType)' _msg.type));  					break;  				}  				//switch on _msg.type  			}  			// if valid _msg.type  			else if (result == eLeapRS.eLeapRS_NotConnected) {  				this.LeapConnectionLost.Dispatch<ConnectionLostEventArgs> (this' new ConnectionLostEventArgs ());  				result = LeapC.CreateConnection (out _leapConnection);  				reportAbnormalResults ("LeapC CreateConnection call was "' result);  				result = LeapC.OpenConnection (_leapConnection);  				reportAbnormalResults ("LeapC OpenConnection call was "' result);  			}  		}  		// if have connection handle  	}  	//while running  }  catch (Exception e) {  	Logger.Log ("Exception: " + e);  }  
Magic Number,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,processMessages,The following statement contains a magic number: while (_isRunning) {  	if (_leapConnection != IntPtr.Zero) {  		LEAP_CONNECTION_MESSAGE _msg = new LEAP_CONNECTION_MESSAGE ();  		uint timeout = 1000;  		result = LeapC.PollConnection (_leapConnection' timeout' ref _msg);  		reportAbnormalResults ("LeapC PollConnection call was "' result);  		if (result == eLeapRS.eLeapRS_Success) {  			switch (_msg.type) {  			case eLeapEventType.eLeapEventType_Connection:  				LEAP_CONNECTION_EVENT connection_evt = LeapC.PtrToStruct<LEAP_CONNECTION_EVENT> (_msg.eventStructPtr);  				handleConnection (ref connection_evt);  				break;  			case eLeapEventType.eLeapEventType_ConnectionLost:  				LEAP_CONNECTION_LOST_EVENT connection_lost_evt = LeapC.PtrToStruct<LEAP_CONNECTION_LOST_EVENT> (_msg.eventStructPtr);  				handleConnectionLost (ref connection_lost_evt);  				break;  			case eLeapEventType.eLeapEventType_Device:  				LEAP_DEVICE_EVENT device_evt = LeapC.PtrToStruct<LEAP_DEVICE_EVENT> (_msg.eventStructPtr);  				handleDevice (ref device_evt);  				break;  			case eLeapEventType.eLeapEventType_DeviceLost:  				LEAP_DEVICE_EVENT device_lost_evt = LeapC.PtrToStruct<LEAP_DEVICE_EVENT> (_msg.eventStructPtr);  				handleLostDevice (ref device_lost_evt);  				break;  			case eLeapEventType.eLeapEventType_DeviceFailure:  				LEAP_DEVICE_FAILURE_EVENT device_failure_evt = LeapC.PtrToStruct<LEAP_DEVICE_FAILURE_EVENT> (_msg.eventStructPtr);  				handleFailedDevice (ref device_failure_evt);  				break;  			case eLeapEventType.eLeapEventType_Tracking:  				LEAP_TRACKING_EVENT tracking_evt = LeapC.PtrToStruct<LEAP_TRACKING_EVENT> (_msg.eventStructPtr);  				handleTrackingMessage (ref tracking_evt);  				break;  			case eLeapEventType.eLeapEventType_ImageComplete:  				completeCount++;  				LEAP_IMAGE_COMPLETE_EVENT image_complete_evt = LeapC.PtrToStruct<LEAP_IMAGE_COMPLETE_EVENT> (_msg.eventStructPtr);  				handleImageCompletion (ref image_complete_evt);  				break;  			case eLeapEventType.eLeapEventType_ImageRequestError:  				failedCount++;  				LEAP_IMAGE_FRAME_REQUEST_ERROR_EVENT failed_image_evt = LeapC.PtrToStruct<LEAP_IMAGE_FRAME_REQUEST_ERROR_EVENT> (_msg.eventStructPtr);  				handleFailedImageRequest (ref failed_image_evt);  				break;  			case eLeapEventType.eLeapEventType_TrackedQuad:  				LEAP_TRACKED_QUAD_EVENT quad_evt = LeapC.PtrToStruct<LEAP_TRACKED_QUAD_EVENT> (_msg.eventStructPtr);  				handleQuadMessage (ref quad_evt);  				break;  			case eLeapEventType.eLeapEventType_LogEvent:  				LEAP_LOG_EVENT log_evt = LeapC.PtrToStruct<LEAP_LOG_EVENT> (_msg.eventStructPtr);  				reportLogMessage (ref log_evt);  				break;  			case eLeapEventType.eLeapEventType_PolicyChange:  				LEAP_POLICY_EVENT policy_evt = LeapC.PtrToStruct<LEAP_POLICY_EVENT> (_msg.eventStructPtr);  				handlePolicyChange (ref policy_evt);  				break;  			case eLeapEventType.eLeapEventType_ConfigChange:  				LEAP_CONFIG_CHANGE_EVENT config_change_evt = LeapC.PtrToStruct<LEAP_CONFIG_CHANGE_EVENT> (_msg.eventStructPtr);  				handleConfigChange (ref config_change_evt);  				break;  			case eLeapEventType.eLeapEventType_ConfigResponse:  				handleConfigResponse (ref _msg);  				break;  			default:  				//discard unknown message types  				Logger.Log ("Unhandled message type " + Enum.GetName (typeof(eLeapEventType)' _msg.type));  				break;  			}  			//switch on _msg.type  		}  		// if valid _msg.type  		else if (result == eLeapRS.eLeapRS_NotConnected) {  			this.LeapConnectionLost.Dispatch<ConnectionLostEventArgs> (this' new ConnectionLostEventArgs ());  			result = LeapC.CreateConnection (out _leapConnection);  			reportAbnormalResults ("LeapC CreateConnection call was "' result);  			result = LeapC.OpenConnection (_leapConnection);  			reportAbnormalResults ("LeapC OpenConnection call was "' result);  		}  	}  	// if have connection handle  }  
Magic Number,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,processMessages,The following statement contains a magic number: if (_leapConnection != IntPtr.Zero) {  	LEAP_CONNECTION_MESSAGE _msg = new LEAP_CONNECTION_MESSAGE ();  	uint timeout = 1000;  	result = LeapC.PollConnection (_leapConnection' timeout' ref _msg);  	reportAbnormalResults ("LeapC PollConnection call was "' result);  	if (result == eLeapRS.eLeapRS_Success) {  		switch (_msg.type) {  		case eLeapEventType.eLeapEventType_Connection:  			LEAP_CONNECTION_EVENT connection_evt = LeapC.PtrToStruct<LEAP_CONNECTION_EVENT> (_msg.eventStructPtr);  			handleConnection (ref connection_evt);  			break;  		case eLeapEventType.eLeapEventType_ConnectionLost:  			LEAP_CONNECTION_LOST_EVENT connection_lost_evt = LeapC.PtrToStruct<LEAP_CONNECTION_LOST_EVENT> (_msg.eventStructPtr);  			handleConnectionLost (ref connection_lost_evt);  			break;  		case eLeapEventType.eLeapEventType_Device:  			LEAP_DEVICE_EVENT device_evt = LeapC.PtrToStruct<LEAP_DEVICE_EVENT> (_msg.eventStructPtr);  			handleDevice (ref device_evt);  			break;  		case eLeapEventType.eLeapEventType_DeviceLost:  			LEAP_DEVICE_EVENT device_lost_evt = LeapC.PtrToStruct<LEAP_DEVICE_EVENT> (_msg.eventStructPtr);  			handleLostDevice (ref device_lost_evt);  			break;  		case eLeapEventType.eLeapEventType_DeviceFailure:  			LEAP_DEVICE_FAILURE_EVENT device_failure_evt = LeapC.PtrToStruct<LEAP_DEVICE_FAILURE_EVENT> (_msg.eventStructPtr);  			handleFailedDevice (ref device_failure_evt);  			break;  		case eLeapEventType.eLeapEventType_Tracking:  			LEAP_TRACKING_EVENT tracking_evt = LeapC.PtrToStruct<LEAP_TRACKING_EVENT> (_msg.eventStructPtr);  			handleTrackingMessage (ref tracking_evt);  			break;  		case eLeapEventType.eLeapEventType_ImageComplete:  			completeCount++;  			LEAP_IMAGE_COMPLETE_EVENT image_complete_evt = LeapC.PtrToStruct<LEAP_IMAGE_COMPLETE_EVENT> (_msg.eventStructPtr);  			handleImageCompletion (ref image_complete_evt);  			break;  		case eLeapEventType.eLeapEventType_ImageRequestError:  			failedCount++;  			LEAP_IMAGE_FRAME_REQUEST_ERROR_EVENT failed_image_evt = LeapC.PtrToStruct<LEAP_IMAGE_FRAME_REQUEST_ERROR_EVENT> (_msg.eventStructPtr);  			handleFailedImageRequest (ref failed_image_evt);  			break;  		case eLeapEventType.eLeapEventType_TrackedQuad:  			LEAP_TRACKED_QUAD_EVENT quad_evt = LeapC.PtrToStruct<LEAP_TRACKED_QUAD_EVENT> (_msg.eventStructPtr);  			handleQuadMessage (ref quad_evt);  			break;  		case eLeapEventType.eLeapEventType_LogEvent:  			LEAP_LOG_EVENT log_evt = LeapC.PtrToStruct<LEAP_LOG_EVENT> (_msg.eventStructPtr);  			reportLogMessage (ref log_evt);  			break;  		case eLeapEventType.eLeapEventType_PolicyChange:  			LEAP_POLICY_EVENT policy_evt = LeapC.PtrToStruct<LEAP_POLICY_EVENT> (_msg.eventStructPtr);  			handlePolicyChange (ref policy_evt);  			break;  		case eLeapEventType.eLeapEventType_ConfigChange:  			LEAP_CONFIG_CHANGE_EVENT config_change_evt = LeapC.PtrToStruct<LEAP_CONFIG_CHANGE_EVENT> (_msg.eventStructPtr);  			handleConfigChange (ref config_change_evt);  			break;  		case eLeapEventType.eLeapEventType_ConfigResponse:  			handleConfigResponse (ref _msg);  			break;  		default:  			//discard unknown message types  			Logger.Log ("Unhandled message type " + Enum.GetName (typeof(eLeapEventType)' _msg.type));  			break;  		}  		//switch on _msg.type  	}  	// if valid _msg.type  	else if (result == eLeapRS.eLeapRS_NotConnected) {  		this.LeapConnectionLost.Dispatch<ConnectionLostEventArgs> (this' new ConnectionLostEventArgs ());  		result = LeapC.CreateConnection (out _leapConnection);  		reportAbnormalResults ("LeapC CreateConnection call was "' result);  		result = LeapC.OpenConnection (_leapConnection);  		reportAbnormalResults ("LeapC OpenConnection call was "' result);  	}  }  
Magic Number,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleImageCompletion,The following statement contains a magic number: if (pendingImage != null) {  	//Update distortion data' if changed  	if ((_currentDistortionData.Version != imageMsg.matrix_version) || !_currentDistortionData.IsValid) {  		_currentDistortionData = new DistortionData ();  		_currentDistortionData.Version = imageMsg.matrix_version;  		_currentDistortionData.Width = LeapC.DistortionSize;  		//fixed value for now  		_currentDistortionData.Height = LeapC.DistortionSize;  		//fixed value for now  		if (_currentDistortionData.Data == null || _currentDistortionData.Data.Length != (2 * _currentDistortionData.Width * _currentDistortionData.Height * 2))  			_currentDistortionData.Data = new float[(int)(2 * _currentDistortionData.Width * _currentDistortionData.Height * 2)];  		//2 float values per map point  		LEAP_DISTORTION_MATRIX matrix = LeapC.PtrToStruct<LEAP_DISTORTION_MATRIX> (imageMsg.distortionMatrix);  		Array.Copy (matrix.matrix_data' _currentDistortionData.Data' matrix.matrix_data.Length);  		this.LeapDistortionChange.Dispatch<DistortionEventArgs> (this' new DistortionEventArgs (_currentDistortionData));  	}  	pendingImage.imageData.CompleteImageData (props.type' props.format' props.bpp' props.width' props.height' imageMsg.info.timestamp' imageMsg.info.frame_id' props.x_offset' props.y_offset' props.x_scale' props.y_scale' _currentDistortionData' LeapC.DistortionSize' imageMsg.matrix_version);  	Image completedImage = pendingImage.imageObject;  	lock (lockPendingImageList) {  		_pendingImageRequests.Remove (imageMsg.token.requestID);  	}  	this.LeapImageReady.Dispatch<ImageEventArgs> (this' new ImageEventArgs (completedImage));  }  
Magic Number,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleImageCompletion,The following statement contains a magic number: if (pendingImage != null) {  	//Update distortion data' if changed  	if ((_currentDistortionData.Version != imageMsg.matrix_version) || !_currentDistortionData.IsValid) {  		_currentDistortionData = new DistortionData ();  		_currentDistortionData.Version = imageMsg.matrix_version;  		_currentDistortionData.Width = LeapC.DistortionSize;  		//fixed value for now  		_currentDistortionData.Height = LeapC.DistortionSize;  		//fixed value for now  		if (_currentDistortionData.Data == null || _currentDistortionData.Data.Length != (2 * _currentDistortionData.Width * _currentDistortionData.Height * 2))  			_currentDistortionData.Data = new float[(int)(2 * _currentDistortionData.Width * _currentDistortionData.Height * 2)];  		//2 float values per map point  		LEAP_DISTORTION_MATRIX matrix = LeapC.PtrToStruct<LEAP_DISTORTION_MATRIX> (imageMsg.distortionMatrix);  		Array.Copy (matrix.matrix_data' _currentDistortionData.Data' matrix.matrix_data.Length);  		this.LeapDistortionChange.Dispatch<DistortionEventArgs> (this' new DistortionEventArgs (_currentDistortionData));  	}  	pendingImage.imageData.CompleteImageData (props.type' props.format' props.bpp' props.width' props.height' imageMsg.info.timestamp' imageMsg.info.frame_id' props.x_offset' props.y_offset' props.x_scale' props.y_scale' _currentDistortionData' LeapC.DistortionSize' imageMsg.matrix_version);  	Image completedImage = pendingImage.imageObject;  	lock (lockPendingImageList) {  		_pendingImageRequests.Remove (imageMsg.token.requestID);  	}  	this.LeapImageReady.Dispatch<ImageEventArgs> (this' new ImageEventArgs (completedImage));  }  
Magic Number,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleImageCompletion,The following statement contains a magic number: if (pendingImage != null) {  	//Update distortion data' if changed  	if ((_currentDistortionData.Version != imageMsg.matrix_version) || !_currentDistortionData.IsValid) {  		_currentDistortionData = new DistortionData ();  		_currentDistortionData.Version = imageMsg.matrix_version;  		_currentDistortionData.Width = LeapC.DistortionSize;  		//fixed value for now  		_currentDistortionData.Height = LeapC.DistortionSize;  		//fixed value for now  		if (_currentDistortionData.Data == null || _currentDistortionData.Data.Length != (2 * _currentDistortionData.Width * _currentDistortionData.Height * 2))  			_currentDistortionData.Data = new float[(int)(2 * _currentDistortionData.Width * _currentDistortionData.Height * 2)];  		//2 float values per map point  		LEAP_DISTORTION_MATRIX matrix = LeapC.PtrToStruct<LEAP_DISTORTION_MATRIX> (imageMsg.distortionMatrix);  		Array.Copy (matrix.matrix_data' _currentDistortionData.Data' matrix.matrix_data.Length);  		this.LeapDistortionChange.Dispatch<DistortionEventArgs> (this' new DistortionEventArgs (_currentDistortionData));  	}  	pendingImage.imageData.CompleteImageData (props.type' props.format' props.bpp' props.width' props.height' imageMsg.info.timestamp' imageMsg.info.frame_id' props.x_offset' props.y_offset' props.x_scale' props.y_scale' _currentDistortionData' LeapC.DistortionSize' imageMsg.matrix_version);  	Image completedImage = pendingImage.imageObject;  	lock (lockPendingImageList) {  		_pendingImageRequests.Remove (imageMsg.token.requestID);  	}  	this.LeapImageReady.Dispatch<ImageEventArgs> (this' new ImageEventArgs (completedImage));  }  
Magic Number,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleImageCompletion,The following statement contains a magic number: if (pendingImage != null) {  	//Update distortion data' if changed  	if ((_currentDistortionData.Version != imageMsg.matrix_version) || !_currentDistortionData.IsValid) {  		_currentDistortionData = new DistortionData ();  		_currentDistortionData.Version = imageMsg.matrix_version;  		_currentDistortionData.Width = LeapC.DistortionSize;  		//fixed value for now  		_currentDistortionData.Height = LeapC.DistortionSize;  		//fixed value for now  		if (_currentDistortionData.Data == null || _currentDistortionData.Data.Length != (2 * _currentDistortionData.Width * _currentDistortionData.Height * 2))  			_currentDistortionData.Data = new float[(int)(2 * _currentDistortionData.Width * _currentDistortionData.Height * 2)];  		//2 float values per map point  		LEAP_DISTORTION_MATRIX matrix = LeapC.PtrToStruct<LEAP_DISTORTION_MATRIX> (imageMsg.distortionMatrix);  		Array.Copy (matrix.matrix_data' _currentDistortionData.Data' matrix.matrix_data.Length);  		this.LeapDistortionChange.Dispatch<DistortionEventArgs> (this' new DistortionEventArgs (_currentDistortionData));  	}  	pendingImage.imageData.CompleteImageData (props.type' props.format' props.bpp' props.width' props.height' imageMsg.info.timestamp' imageMsg.info.frame_id' props.x_offset' props.y_offset' props.x_scale' props.y_scale' _currentDistortionData' LeapC.DistortionSize' imageMsg.matrix_version);  	Image completedImage = pendingImage.imageObject;  	lock (lockPendingImageList) {  		_pendingImageRequests.Remove (imageMsg.token.requestID);  	}  	this.LeapImageReady.Dispatch<ImageEventArgs> (this' new ImageEventArgs (completedImage));  }  
Magic Number,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleImageCompletion,The following statement contains a magic number: if ((_currentDistortionData.Version != imageMsg.matrix_version) || !_currentDistortionData.IsValid) {  	_currentDistortionData = new DistortionData ();  	_currentDistortionData.Version = imageMsg.matrix_version;  	_currentDistortionData.Width = LeapC.DistortionSize;  	//fixed value for now  	_currentDistortionData.Height = LeapC.DistortionSize;  	//fixed value for now  	if (_currentDistortionData.Data == null || _currentDistortionData.Data.Length != (2 * _currentDistortionData.Width * _currentDistortionData.Height * 2))  		_currentDistortionData.Data = new float[(int)(2 * _currentDistortionData.Width * _currentDistortionData.Height * 2)];  	//2 float values per map point  	LEAP_DISTORTION_MATRIX matrix = LeapC.PtrToStruct<LEAP_DISTORTION_MATRIX> (imageMsg.distortionMatrix);  	Array.Copy (matrix.matrix_data' _currentDistortionData.Data' matrix.matrix_data.Length);  	this.LeapDistortionChange.Dispatch<DistortionEventArgs> (this' new DistortionEventArgs (_currentDistortionData));  }  
Magic Number,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleImageCompletion,The following statement contains a magic number: if ((_currentDistortionData.Version != imageMsg.matrix_version) || !_currentDistortionData.IsValid) {  	_currentDistortionData = new DistortionData ();  	_currentDistortionData.Version = imageMsg.matrix_version;  	_currentDistortionData.Width = LeapC.DistortionSize;  	//fixed value for now  	_currentDistortionData.Height = LeapC.DistortionSize;  	//fixed value for now  	if (_currentDistortionData.Data == null || _currentDistortionData.Data.Length != (2 * _currentDistortionData.Width * _currentDistortionData.Height * 2))  		_currentDistortionData.Data = new float[(int)(2 * _currentDistortionData.Width * _currentDistortionData.Height * 2)];  	//2 float values per map point  	LEAP_DISTORTION_MATRIX matrix = LeapC.PtrToStruct<LEAP_DISTORTION_MATRIX> (imageMsg.distortionMatrix);  	Array.Copy (matrix.matrix_data' _currentDistortionData.Data' matrix.matrix_data.Length);  	this.LeapDistortionChange.Dispatch<DistortionEventArgs> (this' new DistortionEventArgs (_currentDistortionData));  }  
Magic Number,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleImageCompletion,The following statement contains a magic number: if ((_currentDistortionData.Version != imageMsg.matrix_version) || !_currentDistortionData.IsValid) {  	_currentDistortionData = new DistortionData ();  	_currentDistortionData.Version = imageMsg.matrix_version;  	_currentDistortionData.Width = LeapC.DistortionSize;  	//fixed value for now  	_currentDistortionData.Height = LeapC.DistortionSize;  	//fixed value for now  	if (_currentDistortionData.Data == null || _currentDistortionData.Data.Length != (2 * _currentDistortionData.Width * _currentDistortionData.Height * 2))  		_currentDistortionData.Data = new float[(int)(2 * _currentDistortionData.Width * _currentDistortionData.Height * 2)];  	//2 float values per map point  	LEAP_DISTORTION_MATRIX matrix = LeapC.PtrToStruct<LEAP_DISTORTION_MATRIX> (imageMsg.distortionMatrix);  	Array.Copy (matrix.matrix_data' _currentDistortionData.Data' matrix.matrix_data.Length);  	this.LeapDistortionChange.Dispatch<DistortionEventArgs> (this' new DistortionEventArgs (_currentDistortionData));  }  
Magic Number,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleImageCompletion,The following statement contains a magic number: if ((_currentDistortionData.Version != imageMsg.matrix_version) || !_currentDistortionData.IsValid) {  	_currentDistortionData = new DistortionData ();  	_currentDistortionData.Version = imageMsg.matrix_version;  	_currentDistortionData.Width = LeapC.DistortionSize;  	//fixed value for now  	_currentDistortionData.Height = LeapC.DistortionSize;  	//fixed value for now  	if (_currentDistortionData.Data == null || _currentDistortionData.Data.Length != (2 * _currentDistortionData.Width * _currentDistortionData.Height * 2))  		_currentDistortionData.Data = new float[(int)(2 * _currentDistortionData.Width * _currentDistortionData.Height * 2)];  	//2 float values per map point  	LEAP_DISTORTION_MATRIX matrix = LeapC.PtrToStruct<LEAP_DISTORTION_MATRIX> (imageMsg.distortionMatrix);  	Array.Copy (matrix.matrix_data' _currentDistortionData.Data' matrix.matrix_data.Length);  	this.LeapDistortionChange.Dispatch<DistortionEventArgs> (this' new DistortionEventArgs (_currentDistortionData));  }  
Magic Number,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleImageCompletion,The following statement contains a magic number: if (_currentDistortionData.Data == null || _currentDistortionData.Data.Length != (2 * _currentDistortionData.Width * _currentDistortionData.Height * 2))  	_currentDistortionData.Data = new float[(int)(2 * _currentDistortionData.Width * _currentDistortionData.Height * 2)];  
Magic Number,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleImageCompletion,The following statement contains a magic number: if (_currentDistortionData.Data == null || _currentDistortionData.Data.Length != (2 * _currentDistortionData.Width * _currentDistortionData.Height * 2))  	_currentDistortionData.Data = new float[(int)(2 * _currentDistortionData.Width * _currentDistortionData.Height * 2)];  
Magic Number,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleImageCompletion,The following statement contains a magic number: if (_currentDistortionData.Data == null || _currentDistortionData.Data.Length != (2 * _currentDistortionData.Width * _currentDistortionData.Height * 2))  	_currentDistortionData.Data = new float[(int)(2 * _currentDistortionData.Width * _currentDistortionData.Height * 2)];  
Magic Number,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleImageCompletion,The following statement contains a magic number: if (_currentDistortionData.Data == null || _currentDistortionData.Data.Length != (2 * _currentDistortionData.Width * _currentDistortionData.Height * 2))  	_currentDistortionData.Data = new float[(int)(2 * _currentDistortionData.Width * _currentDistortionData.Height * 2)];  
Magic Number,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleImageCompletion,The following statement contains a magic number: _currentDistortionData.Data = new float[(int)(2 * _currentDistortionData.Width * _currentDistortionData.Height * 2)];  
Magic Number,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleImageCompletion,The following statement contains a magic number: _currentDistortionData.Data = new float[(int)(2 * _currentDistortionData.Width * _currentDistortionData.Height * 2)];  
Magic Number,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleFailedImageRequest,The following statement contains a magic number: for (int k = 0; k < keys.Count; k++) {  	request = _pendingImageRequests [keys [k]];  	if ((now - request.Timestamp) > 90000) {  		lock (_pendingImageRequests) {  			_pendingImageRequests.Remove (keys [k]);  		}  		request.imageData.CheckIn ();  	}  }  
Magic Number,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleFailedImageRequest,The following statement contains a magic number: if ((now - request.Timestamp) > 90000) {  	lock (_pendingImageRequests) {  		_pendingImageRequests.Remove (keys [k]);  	}  	request.imageData.CheckIn ();  }  
Magic Number,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleDevice,The following statement contains a magic number: if (deviceHandle != IntPtr.Zero) {  	IntPtr device;  	eLeapRS result = LeapC.OpenDevice (deviceMsg.device' out device);  	LEAP_DEVICE_INFO deviceInfo = new LEAP_DEVICE_INFO ();  	uint defaultLength = 14;  	deviceInfo.serial_length = defaultLength;  	deviceInfo.serial = Marshal.AllocCoTaskMem ((int)defaultLength);  	deviceInfo.size = (uint)Marshal.SizeOf (deviceInfo);  	result = LeapC.GetDeviceInfo (device' out deviceInfo);  	if (result == eLeapRS.eLeapRS_InsufficientBuffer) {  		Marshal.FreeCoTaskMem (deviceInfo.serial);  		deviceInfo.serial = Marshal.AllocCoTaskMem ((int)deviceInfo.serial_length);  		deviceInfo.size = (uint)Marshal.SizeOf (deviceInfo);  		result = LeapC.GetDeviceInfo (deviceHandle' out deviceInfo);  	}  	if (result == eLeapRS.eLeapRS_Success) {  		Device apiDevice = new Device (deviceHandle' deviceInfo.h_fov' //radians  		deviceInfo.v_fov' //radians  		deviceInfo.range / 1000' //to mm   		deviceInfo.baseline / 1000' //to mm   		(deviceInfo.caps == (UInt32)eLeapDeviceCaps.eLeapDeviceCaps_Embedded)' (deviceInfo.status == (UInt32)eLeapDeviceStatus.eLeapDeviceStatus_Streaming)' Marshal.PtrToStringAnsi (deviceInfo.serial));  		Marshal.FreeCoTaskMem (deviceInfo.serial);  		_devices.AddOrUpdate (apiDevice);  		this.LeapDevice.Dispatch (this' new DeviceEventArgs (apiDevice));  	}  }  
Magic Number,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleDevice,The following statement contains a magic number: if (deviceHandle != IntPtr.Zero) {  	IntPtr device;  	eLeapRS result = LeapC.OpenDevice (deviceMsg.device' out device);  	LEAP_DEVICE_INFO deviceInfo = new LEAP_DEVICE_INFO ();  	uint defaultLength = 14;  	deviceInfo.serial_length = defaultLength;  	deviceInfo.serial = Marshal.AllocCoTaskMem ((int)defaultLength);  	deviceInfo.size = (uint)Marshal.SizeOf (deviceInfo);  	result = LeapC.GetDeviceInfo (device' out deviceInfo);  	if (result == eLeapRS.eLeapRS_InsufficientBuffer) {  		Marshal.FreeCoTaskMem (deviceInfo.serial);  		deviceInfo.serial = Marshal.AllocCoTaskMem ((int)deviceInfo.serial_length);  		deviceInfo.size = (uint)Marshal.SizeOf (deviceInfo);  		result = LeapC.GetDeviceInfo (deviceHandle' out deviceInfo);  	}  	if (result == eLeapRS.eLeapRS_Success) {  		Device apiDevice = new Device (deviceHandle' deviceInfo.h_fov' //radians  		deviceInfo.v_fov' //radians  		deviceInfo.range / 1000' //to mm   		deviceInfo.baseline / 1000' //to mm   		(deviceInfo.caps == (UInt32)eLeapDeviceCaps.eLeapDeviceCaps_Embedded)' (deviceInfo.status == (UInt32)eLeapDeviceStatus.eLeapDeviceStatus_Streaming)' Marshal.PtrToStringAnsi (deviceInfo.serial));  		Marshal.FreeCoTaskMem (deviceInfo.serial);  		_devices.AddOrUpdate (apiDevice);  		this.LeapDevice.Dispatch (this' new DeviceEventArgs (apiDevice));  	}  }  
Magic Number,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleDevice,The following statement contains a magic number: if (deviceHandle != IntPtr.Zero) {  	IntPtr device;  	eLeapRS result = LeapC.OpenDevice (deviceMsg.device' out device);  	LEAP_DEVICE_INFO deviceInfo = new LEAP_DEVICE_INFO ();  	uint defaultLength = 14;  	deviceInfo.serial_length = defaultLength;  	deviceInfo.serial = Marshal.AllocCoTaskMem ((int)defaultLength);  	deviceInfo.size = (uint)Marshal.SizeOf (deviceInfo);  	result = LeapC.GetDeviceInfo (device' out deviceInfo);  	if (result == eLeapRS.eLeapRS_InsufficientBuffer) {  		Marshal.FreeCoTaskMem (deviceInfo.serial);  		deviceInfo.serial = Marshal.AllocCoTaskMem ((int)deviceInfo.serial_length);  		deviceInfo.size = (uint)Marshal.SizeOf (deviceInfo);  		result = LeapC.GetDeviceInfo (deviceHandle' out deviceInfo);  	}  	if (result == eLeapRS.eLeapRS_Success) {  		Device apiDevice = new Device (deviceHandle' deviceInfo.h_fov' //radians  		deviceInfo.v_fov' //radians  		deviceInfo.range / 1000' //to mm   		deviceInfo.baseline / 1000' //to mm   		(deviceInfo.caps == (UInt32)eLeapDeviceCaps.eLeapDeviceCaps_Embedded)' (deviceInfo.status == (UInt32)eLeapDeviceStatus.eLeapDeviceStatus_Streaming)' Marshal.PtrToStringAnsi (deviceInfo.serial));  		Marshal.FreeCoTaskMem (deviceInfo.serial);  		_devices.AddOrUpdate (apiDevice);  		this.LeapDevice.Dispatch (this' new DeviceEventArgs (apiDevice));  	}  }  
Magic Number,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleDevice,The following statement contains a magic number: if (result == eLeapRS.eLeapRS_Success) {  	Device apiDevice = new Device (deviceHandle' deviceInfo.h_fov' //radians  	deviceInfo.v_fov' //radians  	deviceInfo.range / 1000' //to mm   	deviceInfo.baseline / 1000' //to mm   	(deviceInfo.caps == (UInt32)eLeapDeviceCaps.eLeapDeviceCaps_Embedded)' (deviceInfo.status == (UInt32)eLeapDeviceStatus.eLeapDeviceStatus_Streaming)' Marshal.PtrToStringAnsi (deviceInfo.serial));  	Marshal.FreeCoTaskMem (deviceInfo.serial);  	_devices.AddOrUpdate (apiDevice);  	this.LeapDevice.Dispatch (this' new DeviceEventArgs (apiDevice));  }  
Magic Number,LeapInternal,Connection,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Connection.cs,handleDevice,The following statement contains a magic number: if (result == eLeapRS.eLeapRS_Success) {  	Device apiDevice = new Device (deviceHandle' deviceInfo.h_fov' //radians  	deviceInfo.v_fov' //radians  	deviceInfo.range / 1000' //to mm   	deviceInfo.baseline / 1000' //to mm   	(deviceInfo.caps == (UInt32)eLeapDeviceCaps.eLeapDeviceCaps_Embedded)' (deviceInfo.status == (UInt32)eLeapDeviceStatus.eLeapDeviceStatus_Streaming)' Marshal.PtrToStringAnsi (deviceInfo.serial));  	Marshal.FreeCoTaskMem (deviceInfo.serial);  	_devices.AddOrUpdate (apiDevice);  	this.LeapDevice.Dispatch (this' new DeviceEventArgs (apiDevice));  }  
Missing Default,Leap,Finger,C:\repos\kirimomi_Oculus_Leap_test\Assets\LeapC\Finger.cs,JointPosition,The following switch statement is missing a default case: switch (jointIx) {  case FingerJoint.JOINT_MCP:  	return _bones [0].NextJoint;  case FingerJoint.JOINT_PIP:  	return _bones [1].NextJoint;  case FingerJoint.JOINT_DIP:  	return _bones [2].NextJoint;  case FingerJoint.JOINT_TIP:  	return _bones [3].NextJoint;  }  
