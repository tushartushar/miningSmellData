Implementation smell,Namespace,Class,File,Method,Description
Long Method,CLKsFATXLib,Entry,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Move,The method has 111 lines of code.
Long Method,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,CreateNewFile,The method has 182 lines of code.
Long Method,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ProcessBootSector,The method has 147 lines of code.
Complex Method,CLKsFATXLib,Drive,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\Drive.cs,IsFATXDrive,Cyclomatic complexity of the method is 16
Complex Method,CLKsFATXLib,Drive,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\Drive.cs,Stream,Cyclomatic complexity of the method is 10
Complex Method,CLKsFATXLib,Drive,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\Drive.cs,FileFromPath,Cyclomatic complexity of the method is 10
Complex Method,CLKsFATXLib,Drive,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\Drive.cs,FolderFromPath,Cyclomatic complexity of the method is 9
Complex Method,CLKsFATXLib,Drive,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\Drive.cs,CreateDirectory,Cyclomatic complexity of the method is 8
Complex Method,CLKsFATXLib,Drive,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\Drive.cs,GetFreeBlocks,Cyclomatic complexity of the method is 14
Complex Method,CLKsFATXLib,Entry,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Move,Cyclomatic complexity of the method is 22
Complex Method,CLKsFATXLib,File,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Extract,Cyclomatic complexity of the method is 9
Complex Method,CLKsFATXLib,File,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,IsSTFSPackage,Cyclomatic complexity of the method is 16
Complex Method,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Extract,Cyclomatic complexity of the method is 9
Complex Method,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,IsProfileFolder,Cyclomatic complexity of the method is 8
Complex Method,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,GameName,Cyclomatic complexity of the method is 15
Complex Method,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,GameIcon,Cyclomatic complexity of the method is 8
Complex Method,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Delete,Cyclomatic complexity of the method is 8
Complex Method,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,CreateNewFile,Cyclomatic complexity of the method is 17
Complex Method,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,InjectFolder,Cyclomatic complexity of the method is 12
Complex Method,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ProcessBootSector,Cyclomatic complexity of the method is 15
Complex Method,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,GetFreeSpace,Cyclomatic complexity of the method is 9
Complex Method,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,PartitionSize,Cyclomatic complexity of the method is 35
Complex Method,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,GetEntries,Cyclomatic complexity of the method is 9
Complex Method,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,GetBlocksOccupied,Cyclomatic complexity of the method is 14
Complex Method,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,WriteFATChain,Cyclomatic complexity of the method is 12
Complex Method,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ClearFATChain,Cyclomatic complexity of the method is 10
Complex Method,CLKsFATXLib,StartHere,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,GetFATXDrives,Cyclomatic complexity of the method is 11
Complex Method,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,EOF,Cyclomatic complexity of the method is 8
Complex Method,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,CheckFileName,Cyclomatic complexity of the method is 9
Long Parameter List,CLKsFATXLib,API,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\API.cs,CreateFile,The method has 7 parameters.
Long Parameter List,CLKsFATXLib,API,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\API.cs,CreateFile,The method has 7 parameters.
Long Parameter List,CLKsFATXLib,API,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\API.cs,DeviceIoControl,The method has 8 parameters.
Long Parameter List,CLKsFATXLib,Drive,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\Drive.cs,GetFreeBlocks,The method has 5 parameters.
Long Statement,CLKsFATXLib,API,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\API.cs,GetDriveGeometry,The length of the statement  "	bResult = DeviceIoControl (handle' (uint)EIOControlCode.IOCTL_DISK_GET_DRIVE_GEOMETRY' IntPtr.Zero' 0' ref diskGeo' (uint)Marshal.SizeOf (typeof(DISK_GEOMETRY))' out dummy' IntPtr.Zero); " is 186.
Long Statement,CLKsFATXLib,Drive,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\Drive.cs,PartitionSizeTotal,The length of the statement  "		size += Partitions [i].PartitionInfo.Size - (Partitions [i].PartitionInfo.DataOffset - Partitions [i].PartitionInfo.Offset); " is 124.
Long Statement,CLKsFATXLib,Drive,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\Drive.cs,GetFreeBlocks,The length of the statement  "	for (long i = VariousFunctions.DownToNearest200 (VariousFunctions.BlockToFATOffset (StartBlock' Partition)); i < end; i += Clustersize) { " is 137.
Long Statement,CLKsFATXLib,Drive,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\Drive.cs,GetFreeBlocks,The length of the statement  "		for (int j = 0; j < buffer.Length; j += (int)Partition.PartitionInfo.EntrySize' Block += (uint)Partition.PartitionInfo.EntrySize) { " is 131.
Long Statement,CLKsFATXLib,Drive,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\Drive.cs,GetFreeBlocks,The length of the statement  "		BlockList.AddRange (GetFreeBlocks (Partition' blocksNeeded - BlockList.Count' 1' VariousFunctions.DownToNearest200 (VariousFunctions.BlockToFATOffset (StartBlock' Partition))' true)); " is 183.
Long Statement,CLKsFATXLib,Entry,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Move,The length of the statement  "	if (f.EntryOffset >= VariousFunctions.GetBlockOffset (this.BlocksOccupied [BlocksOccupied.Length - 1]' this) + this.PartitionInfo.ClusterSize) { " is 144.
Long Statement,CLKsFATXLib,File,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Extract,The length of the statement  "	Streams.Writer FileWriter = new CLKsFATXLib.Streams.Writer (new System.IO.FileStream (Destination' System.IO.FileMode.Create)); " is 127.
Long Statement,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,CreateNewFolder,The length of the statement  "	if (f.EntryOffset >= VariousFunctions.GetBlockOffset (this.BlocksOccupied [BlocksOccupied.Length - 1]' this) + this.PartitionInfo.ClusterSize) { " is 144.
Long Statement,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,CreateNewFile,The length of the statement  "		File f = new File (this.PartitionInfo' new EntryFunctions (this).GetNewEntry (this' 0' new CLKsFATXLib.Geometry.Flags[0]' NewName)' this.Drive); " is 144.
Long Statement,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,CreateNewFile,The length of the statement  "		int BlocksNeeded = (int)(VariousFunctions.UpToNearestCluster (new System.IO.FileInfo (Path).Length' PartitionInfo.ClusterSize) / PartitionInfo.ClusterSize); " is 156.
Long Statement,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,CreateNewFile,The length of the statement  "		EntryData newE = new EntryFunctions (this).GetNewEntry (this' (uint)new System.IO.FileInfo (Path).Length' new CLKsFATXLib.Geometry.Flags[0]' NewName); " is 150.
Long Statement,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,CreateNewFile,The length of the statement  "		if (newE.EntryOffset >= VariousFunctions.GetBlockOffset (this.BlocksOccupied [BlocksOccupied.Length - 1]' this) + this.PartitionInfo.ClusterSize) { " is 147.
Long Statement,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,CreateNewFile,The length of the statement  "		byte[] ToWrite = new byte[(int)VariousFunctions.UpToNearest200 (VariousFunctions.RemainingData (BlocksNeeded' new System.IO.FileInfo (Path).Length' this))]; " is 156.
Long Statement,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,CreateNewFile,The length of the statement  "		if ((int)VariousFunctions.RemainingData (BlocksNeeded' new System.IO.FileInfo (Path).Length' this) < (int)VariousFunctions.UpToNearest200 ((int)VariousFunctions.RemainingData (BlocksNeeded' new System.IO.FileInfo (Path).Length' this))) { " is 237.
Long Statement,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,CreateNewFile,The length of the statement  "			for (int i = (int)VariousFunctions.RemainingData (BlocksNeeded' new System.IO.FileInfo (Path).Length' this) + 1; i < ToWrite.Length; i++) { " is 139.
Long Statement,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,CreateNewFile,The length of the statement  "		byte[] Buffer = FileReader.ReadBytes ((int)VariousFunctions.RemainingData (BlocksNeeded' new System.IO.FileInfo (Path).Length' this)); " is 134.
Long Statement,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,GetBlocksOccupied,The length of the statement  "		int OffsetInBuffer = (int)(VariousFunctions.BlockToFATOffset (Blocks [i]' Parent) - VariousFunctions.BlockToFATOffset (Blocks [i]' Parent).DownToNearestCluster (0x1000)); " is 170.
Long Statement,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,GetBlocksOccupied,The length of the statement  "					throw new Exception ("Bad FAT chain in file or folder " + Parent.FullPath + "\r\nEntry Offset: 0x" + Parent.EntryOffset.ToString ("X")); " is 136.
Long Statement,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,GetBlocksOccupied,The length of the statement  "					throw new Exception ("Bad FAT chain in file or folder " + Parent.FullPath + "\r\nEntry Offset: 0x" + Parent.EntryOffset.ToString ("X")); " is 136.
Long Statement,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,WriteFATChain,The length of the statement  "		mem.BaseStream.Position = VariousFunctions.BlockToFATOffset (Chain [i]' Parent) - VariousFunctions.BlockToFATOffset (Chain [i]' Parent).DownToNearestCluster (0x1000); " is 166.
Long Statement,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ClearFATChain,The length of the statement  "		mem.BaseStream.Position = VariousFunctions.BlockToFATOffset (Chain [i]' Parent) - VariousFunctions.BlockToFATOffset (Chain [i]' Parent).DownToNearestCluster (0x1000); " is 166.
Long Statement,CLKsFATXLib,StartHere,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,GetFATXDrives,The length of the statement  "		ManagementObjectCollection drives = new ManagementObjectSearcher ("SELECT Caption' DeviceID FROM Win32_DiskDrive").Get (); " is 122.
Long Statement,CLKsFATXLib,StartHere,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,GetFATXDrives,The length of the statement  "	foreach (string s in Environment.GetLogicalDrives ().Where (drive => System.IO.Directory.Exists (drive + "\\Xbox360"))) { " is 121.
Long Statement,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,CreateHandle,The length of the statement  "	return API.CreateFile (@"\\.\PhysicalDrive" + deviceNumber.ToString ()' System.IO.FileAccess.ReadWrite' System.IO.FileShare.ReadWrite' IntPtr.Zero' System.IO.FileMode.Open' API.FlagsAndAttributes.Device | API.FlagsAndAttributes.NoBuffering | API.FlagsAndAttributes.Write_Through' IntPtr.Zero); " is 293.
Long Statement,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,DateTimeToFATInt,The length of the statement  "		OurDateTime = new DateTime (1980' OurDateTime.Month' OurDateTime.Day' OurDateTime.Hour' OurDateTime.Minute' OurDateTime.Second); " is 128.
Long Statement,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,DateTimeToFATShort,The length of the statement  "		OurDateTime = new DateTime (1980' OurDateTime.Month' OurDateTime.Day' OurDateTime.Hour' OurDateTime.Minute' OurDateTime.Second); " is 128.
Long Statement,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,CheckFileName,The length of the statement  "		byte[] Acceptable = Encoding.ASCII.GetBytes ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&'()-.@[]^_`{}~ "); " is 131.
Long Statement,CLKsFATXLib.Streams,FATXFileStream,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,ReadByte,The length of the statement  "		Underlying.Position = VariousFunctions.GetBlockOffset (xFile.BlocksOccupied [DetermineBlockIndex (VariousFunctions.UpToNearestClusterForce (RealSectorOffset' xFile.PartitionInfo.ClusterSize))]' xFile); " is 201.
Long Statement,CLKsFATXLib.Streams,FATXFileStream,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,Read,The length of the statement  "		//long v_eToRemove = VariousFunctions.UpToNearest200(xPositionInFile + count + v_bToRemove) - (xPositionInFile + count + v_bToRemove); " is 134.
Long Statement,CLKsFATXLib.Streams,FATXFileStream,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,Read,The length of the statement  "		long v_Cluster = VariousFunctions.UpToNearestCluster (RealSectorOffset' xFile.PartitionInfo.ClusterSize) - RealSectorOffset; " is 124.
Long Statement,CLKsFATXLib.Streams,FATXFileStream,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,Read,The length of the statement  "		long v_eToRemove = VariousFunctions.UpToNearest200 ((count - v_Cluster) + v_bToRemove) - ((count - v_Cluster) + v_bToRemove); " is 125.
Long Statement,CLKsFATXLib.Streams,FATXFileStream,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,Read,The length of the statement  "		long v_eToReadNotRounded = ((count - v_Cluster) + v_bToRemove) - VariousFunctions.DownToNearestCluster (count - v_Cluster + v_bToRemove' xFile.PartitionInfo.ClusterSize); " is 170.
Long Statement,CLKsFATXLib.Streams,FATXFileStream,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,GetRealSectorOffset,The length of the statement  "	long SizeInCluster = VariousFunctions.DownToNearest200 (off - VariousFunctions.DownToNearestCluster (off' xFile.PartitionInfo.ClusterSize)); " is 140.
Long Statement,CLKsFATXLib.Streams,FATXFileStream,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,GetRealSectorOffset,The length of the statement  "	//VariousFunctions.GetBlockOffset(xFile.StartingCluster) + 0x4000;            long SizeInCluster = VariousFunctions.DownToNearestCluster(off' xFile.PartitionInfo.ClusterSize) / xFile.PartitionInfo.ClusterSize) " is 209.
Long Statement,CLKsFATXLib.Streams,FATXFileStream,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,GetRealSectorOffset,The length of the statement  "	uint Cluster = (uint)(VariousFunctions.DownToNearestCluster (off' xFile.PartitionInfo.ClusterSize) / xFile.PartitionInfo.ClusterSize); " is 134.
Long Statement,CLKsFATXLib.Streams,FATXFileStream,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,ClusterSpanned,The length of the statement  "	long rounded = VariousFunctions.DownToNearestCluster (value' xFile.PartitionInfo.ClusterSize) + xFile.PartitionInfo.ClusterSize; " is 128.
Complex Conditional,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Folders,The conditional expression  "cachedFolders == null && cachedFiles == null && cachedDeletedFiles == null && cachedDeletedFolders == null"  is complex.
Complex Conditional,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Files,The conditional expression  "cachedFolders == null && cachedFiles == null && cachedDeletedFiles == null && cachedDeletedFolders == null"  is complex.
Complex Conditional,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ProcessBootSector,The conditional expression  "!(r11 <= 2) && (r11 != 0x4) && (r11 != 0x8) && (r11 != 0x20) && (r11 != 0x40) && (r11 != 0x80)"  is complex.
Complex Conditional,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,GetNewEntry,The conditional expression  "(Size == 0 && Flags.Contains (Geometry.Flags.Directory)) || (Size != 0 && Flags.Length == 0)"  is complex.
Empty Catch Block,CLKsFATXLib,Drive,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\Drive.cs,Close,The method has an empty catch block.
Empty Catch Block,CLKsFATXLib,Drive,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\Drive.cs,IsFATXDrive,The method has an empty catch block.
Empty Catch Block,CLKsFATXLib,Drive,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\Drive.cs,IsFATXDrive,The method has an empty catch block.
Empty Catch Block,CLKsFATXLib,Drive,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\Drive.cs,IsFATXDrive,The method has an empty catch block.
Empty Catch Block,CLKsFATXLib,Drive,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\Drive.cs,GetFreeBlocks,The method has an empty catch block.
Empty Catch Block,CLKsFATXLib,File,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Extract,The method has an empty catch block.
Empty Catch Block,CLKsFATXLib,File,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,TitleIcon,The method has an empty catch block.
Empty Catch Block,CLKsFATXLib,File,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,ContentIcon,The method has an empty catch block.
Empty Catch Block,CLKsFATXLib,File,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Delete,The method has an empty catch block.
Empty Catch Block,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,GameIcon,The method has an empty catch block.
Empty Catch Block,CLKsFATXLib.Streams,FATXFileStream,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,ReadByte,The method has an empty catch block.
Magic Number,CLKsFATXLib,Drive,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\Drive.cs,FolderFromPath,The following statement contains a magic number: if (Split.Length == 2 && Split [1] == "") {  	return Current;  }  
Magic Number,CLKsFATXLib,Drive,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\Drive.cs,PartitionTimeStamp,The following statement contains a magic number: return VariousFunctions.DateTimeFromFATInt ((ushort)((PI.ID & ~0xFFFF) >> 8)' (ushort)PI.ID);  
Magic Number,CLKsFATXLib,File,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Extract,The following statement contains a magic number: for (int i = 0; i < Blocks.Length - 1; i++) {  	if (Fa.Cancel) {  		Fa.Cancel = false;  		FileWriter.Close ();  		return;  	}  	// Set the position to the beginning of the block  	FileReader.BaseStream.Position = VariousFunctions.GetBlockOffset (Blocks [i]' this);  	for (int j = 1' k = 0; j <= 0x100; j++' k++) {  		if (i + k == Blocks.Length - 1) {  			FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * k));  			i += k;  			Fa.Progress += k;  			break;  		}  		else if (Blocks [i + k] == Blocks.Length - 2 || Blocks [i + k] + 1 != Blocks [i + j] || j == 10) {  			FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * j));  			i += k;  			Fa.Progress += j;  			break;  		}  	}  	OnFileAction (ref Fa);  }  
Magic Number,CLKsFATXLib,File,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Extract,The following statement contains a magic number: for (int i = 0; i < Blocks.Length - 1; i++) {  	if (Fa.Cancel) {  		Fa.Cancel = false;  		FileWriter.Close ();  		return;  	}  	// Set the position to the beginning of the block  	FileReader.BaseStream.Position = VariousFunctions.GetBlockOffset (Blocks [i]' this);  	for (int j = 1' k = 0; j <= 0x100; j++' k++) {  		if (i + k == Blocks.Length - 1) {  			FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * k));  			i += k;  			Fa.Progress += k;  			break;  		}  		else if (Blocks [i + k] == Blocks.Length - 2 || Blocks [i + k] + 1 != Blocks [i + j] || j == 10) {  			FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * j));  			i += k;  			Fa.Progress += j;  			break;  		}  	}  	OnFileAction (ref Fa);  }  
Magic Number,CLKsFATXLib,File,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Extract,The following statement contains a magic number: for (int j = 1' k = 0; j <= 0x100; j++' k++) {  	if (i + k == Blocks.Length - 1) {  		FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * k));  		i += k;  		Fa.Progress += k;  		break;  	}  	else if (Blocks [i + k] == Blocks.Length - 2 || Blocks [i + k] + 1 != Blocks [i + j] || j == 10) {  		FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * j));  		i += k;  		Fa.Progress += j;  		break;  	}  }  
Magic Number,CLKsFATXLib,File,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Extract,The following statement contains a magic number: for (int j = 1' k = 0; j <= 0x100; j++' k++) {  	if (i + k == Blocks.Length - 1) {  		FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * k));  		i += k;  		Fa.Progress += k;  		break;  	}  	else if (Blocks [i + k] == Blocks.Length - 2 || Blocks [i + k] + 1 != Blocks [i + j] || j == 10) {  		FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * j));  		i += k;  		Fa.Progress += j;  		break;  	}  }  
Magic Number,CLKsFATXLib,File,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Extract,The following statement contains a magic number: if (i + k == Blocks.Length - 1) {  	FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * k));  	i += k;  	Fa.Progress += k;  	break;  }  else if (Blocks [i + k] == Blocks.Length - 2 || Blocks [i + k] + 1 != Blocks [i + j] || j == 10) {  	FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * j));  	i += k;  	Fa.Progress += j;  	break;  }  
Magic Number,CLKsFATXLib,File,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Extract,The following statement contains a magic number: if (i + k == Blocks.Length - 1) {  	FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * k));  	i += k;  	Fa.Progress += k;  	break;  }  else if (Blocks [i + k] == Blocks.Length - 2 || Blocks [i + k] + 1 != Blocks [i + j] || j == 10) {  	FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * j));  	i += k;  	Fa.Progress += j;  	break;  }  
Magic Number,CLKsFATXLib,File,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Extract,The following statement contains a magic number: if (Blocks [i + k] == Blocks.Length - 2 || Blocks [i + k] + 1 != Blocks [i + j] || j == 10) {  	FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * j));  	i += k;  	Fa.Progress += j;  	break;  }  
Magic Number,CLKsFATXLib,File,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Extract,The following statement contains a magic number: if (Blocks [i + k] == Blocks.Length - 2 || Blocks [i + k] + 1 != Blocks [i + j] || j == 10) {  	FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * j));  	i += k;  	Fa.Progress += j;  	break;  }  
Magic Number,CLKsFATXLib,File,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Delete,The following statement contains a magic number: fa.MaxValue = 2;  
Magic Number,CLKsFATXLib,File,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Delete,The following statement contains a magic number: fa.Progress = 2;  
Magic Number,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Folders,The following statement contains a magic number: if (cachedFolders == null && cachedFiles == null && cachedDeletedFiles == null && cachedDeletedFolders == null) {  	object[] entries = new EntryFunctions (this).GetEntries (this);  	cachedFiles = (List<File>)entries [0];  	cachedFolders = (List<Folder>)entries [1];  	cachedDeletedFolders = (List<Folder>)entries [3];  	cachedDeletedFiles = (List<File>)entries [2];  }  
Magic Number,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Folders,The following statement contains a magic number: if (cachedFolders == null && cachedFiles == null && cachedDeletedFiles == null && cachedDeletedFolders == null) {  	object[] entries = new EntryFunctions (this).GetEntries (this);  	cachedFiles = (List<File>)entries [0];  	cachedFolders = (List<Folder>)entries [1];  	cachedDeletedFolders = (List<Folder>)entries [3];  	cachedDeletedFiles = (List<File>)entries [2];  }  
Magic Number,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Folders,The following statement contains a magic number: cachedDeletedFolders = (List<Folder>)entries [3];  
Magic Number,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Folders,The following statement contains a magic number: cachedDeletedFiles = (List<File>)entries [2];  
Magic Number,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Files,The following statement contains a magic number: if (cachedFolders == null && cachedFiles == null && cachedDeletedFiles == null && cachedDeletedFolders == null) {  	object[] entries = new EntryFunctions (this).GetEntries (this);  	cachedFiles = (List<File>)entries [0];  	cachedFolders = (List<Folder>)entries [1];  	cachedDeletedFolders = (List<Folder>)entries [3];  	cachedDeletedFiles = (List<File>)entries [2];  }  
Magic Number,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Files,The following statement contains a magic number: if (cachedFolders == null && cachedFiles == null && cachedDeletedFiles == null && cachedDeletedFolders == null) {  	object[] entries = new EntryFunctions (this).GetEntries (this);  	cachedFiles = (List<File>)entries [0];  	cachedFolders = (List<Folder>)entries [1];  	cachedDeletedFolders = (List<Folder>)entries [3];  	cachedDeletedFiles = (List<File>)entries [2];  }  
Magic Number,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Files,The following statement contains a magic number: cachedDeletedFolders = (List<Folder>)entries [3];  
Magic Number,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Files,The following statement contains a magic number: cachedDeletedFiles = (List<File>)entries [2];  
Magic Number,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Delete,The following statement contains a magic number: fa.MaxValue = 2;  
Magic Number,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,Delete,The following statement contains a magic number: fa.Progress = 2;  
Magic Number,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,CreateNewFile,The following statement contains a magic number: if (new System.IO.FileInfo (Path).Length == 0) {  	Console.WriteLine ("Creating null file");  	File f = new File (this.PartitionInfo' new EntryFunctions (this).GetNewEntry (this' 0' new CLKsFATXLib.Geometry.Flags[0]' NewName)' this.Drive);  	f.Parent = this;  	f.FullPath = this.FullPath + "\\" + f.Name;  	Return.Entry = f;  	eea.ModifiedEntry = f;  }  else {  	Console.WriteLine (sw.Elapsed.ToString ());  	Console.WriteLine ("Getting blocks needed");  	int BlocksNeeded = (int)(VariousFunctions.UpToNearestCluster (new System.IO.FileInfo (Path).Length' PartitionInfo.ClusterSize) / PartitionInfo.ClusterSize);  	Console.WriteLine (sw.Elapsed.ToString ());  	List<uint> Blocks = new List<uint> ();  	Console.WriteLine ("Getting new entry");  	EntryData newE = new EntryFunctions (this).GetNewEntry (this' (uint)new System.IO.FileInfo (Path).Length' new CLKsFATXLib.Geometry.Flags[0]' NewName);  	if (newE.EntryOffset >= VariousFunctions.GetBlockOffset (this.BlocksOccupied [BlocksOccupied.Length - 1]' this) + this.PartitionInfo.ClusterSize) {  		List<uint> blocks = this.BlocksOccupied.ToList ();  		blocks.Add (VariousFunctions.GetBlockFromOffset (newE.EntryOffset' this.PartitionInfo));  		this.BlocksOccupied = blocks.ToArray ();  	}  	Console.WriteLine (sw.Elapsed.ToString ());  	Blocks.Add (newE.StartingCluster);  	try {  		Console.WriteLine ("Getting free blocks");  		Blocks.AddRange (Drive.GetFreeBlocks (this' BlocksNeeded - 1' newE.StartingCluster' 0' false));  		Console.WriteLine (sw.Elapsed.ToString ());  	}  	// This excpetion here is going to be that we're out of space...  	catch (Exception x) {  		Console.WriteLine ("Exception thrown' deleting written entry");  		// Delete this entry  		newE.NameSize = 0xE5;  		// Create a new entry functions class so we can get rid of this entry  		EntryFunctions ef = new EntryFunctions (this);  		// Clear the FAT chain  		Console.WriteLine ("Clearing FAT chain");  		ef.ClearFATChain (new uint[] {  			newE.StartingCluster  		});  		// Mark this entry as deleted  		ef.CreateNewEntry (newE);  		throw x;  	}  	Console.WriteLine ("Writing FAT chain");  	// Write that FAT chain  	new EntryFunctions (this).WriteFATChain (Blocks.ToArray ());  	Console.WriteLine (sw.Elapsed.ToString ());  	// Write the file data...  	// FileAction to be used  	fa.MaxValue = Blocks.Count;  	// The IO to read the file  	Streams.Reader FileReader = null;  	try {  		FileReader = new CLKsFATXLib.Streams.Reader (new System.IO.FileStream (Path' System.IO.FileMode.Open));  	}  	catch {  		System.Threading.Thread.Sleep (1000);  		try {  			FileReader = new CLKsFATXLib.Streams.Reader (new System.IO.FileStream (Path' System.IO.FileMode.Open));  		}  		catch (Exception x) {  			Console.WriteLine ("Exception thrown' deleting written entry");  			// Delete this entry  			newE.NameSize = 0xE5;  			// Create a new entry functions class so we can get rid of this entry  			EntryFunctions ef = new EntryFunctions (this);  			// Clear the FAT chain  			Console.WriteLine ("Clearing FAT chain");  			ef.ClearFATChain (Blocks.ToArray ());  			// Mark this entry as deleted  			ef.CreateNewEntry (newE);  			throw x;  		}  	}  	// The IO to write to the destination file  	Streams.Writer FileWriter = Drive.Writer ();  	// Loop for each block...  	for (int i = 0; i < Blocks.Count - 1; i++) {  		if (fa.Cancel) {  			Console.WriteLine ("Cancel engaged");  			FileReader.Close ();  			File newfile = new File (this.PartitionInfo' newE' this.Drive);  			newfile.Parent = this;  			newfile.FullPath = this.FullPath + "\\" + newfile.Name;  			this.cachedFiles.Add (newfile);  			eea.FullParentPath = FullPath;  			eea.ModifiedEntry = newfile;  			eea.ParentFolder = this;  			OnEntryEvent (ref eea);  			UpdateModifiedTime ();  			Return.Entry = newfile;  			return Return;  		}  		// Set the position to the beginning of the block  		FileWriter.BaseStream.Position = VariousFunctions.GetBlockOffset (Blocks [i]' this);  		for (int j = 1' k = 0; j <= 0x100; j++' k++) {  			if (i + k == Blocks.Count - 1) {  				//Console.WriteLine("Writing part of file");  				FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * k));  				i += k;  				fa.Progress += k;  				break;  			}  			else if (Blocks [i + k] == Blocks.Count - 2 || Blocks [i + k] + 1 != Blocks [i + j] || j == 10) {  				//Console.WriteLine("Writing part of file");  				FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * j));  				i += k;  				fa.Progress += j;  				break;  			}  		}  		OnFolderAction (ref fa);  	}  	Console.WriteLine (sw.Elapsed.ToString ());  	// For the last cluster' we don't know how long it is... so we use  	// this nifty function I made to do that for us  	Console.WriteLine ("Seeking to final cluster");  	FileWriter.BaseStream.Position = VariousFunctions.GetBlockOffset (Blocks [Blocks.Count - 1]' this);  	// Read/write data  	byte[] ToWrite = new byte[(int)VariousFunctions.UpToNearest200 (VariousFunctions.RemainingData (BlocksNeeded' new System.IO.FileInfo (Path).Length' this))];  	if ((int)VariousFunctions.RemainingData (BlocksNeeded' new System.IO.FileInfo (Path).Length' this) < (int)VariousFunctions.UpToNearest200 ((int)VariousFunctions.RemainingData (BlocksNeeded' new System.IO.FileInfo (Path).Length' this))) {  		for (int i = (int)VariousFunctions.RemainingData (BlocksNeeded' new System.IO.FileInfo (Path).Length' this) + 1; i < ToWrite.Length; i++) {  			ToWrite [i] = 0xFF;  		}  	}  	byte[] Buffer = FileReader.ReadBytes ((int)VariousFunctions.RemainingData (BlocksNeeded' new System.IO.FileInfo (Path).Length' this));  	Array.Copy (Buffer' 0' ToWrite' 0' Buffer.Length);  	Buffer = null;  	Console.WriteLine ("Writing final cluster");  	FileWriter.Write (ToWrite);  	fa.Progress++;  	OnFolderAction (ref fa);  	Console.WriteLine ("Closing streams");  	FileReader.Close ();  	Console.WriteLine (sw.Elapsed.ToString ());  	File newF = new File (this.PartitionInfo' newE' this.Drive);  	newF.Parent = this;  	newF.FullPath = this.FullPath + "\\" + newF.Name;  	this.cachedFiles.Add (newF);  	Return.Entry = newF;  	eea.ModifiedEntry = newF;  }  
Magic Number,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,CreateNewFile,The following statement contains a magic number: if (new System.IO.FileInfo (Path).Length == 0) {  	Console.WriteLine ("Creating null file");  	File f = new File (this.PartitionInfo' new EntryFunctions (this).GetNewEntry (this' 0' new CLKsFATXLib.Geometry.Flags[0]' NewName)' this.Drive);  	f.Parent = this;  	f.FullPath = this.FullPath + "\\" + f.Name;  	Return.Entry = f;  	eea.ModifiedEntry = f;  }  else {  	Console.WriteLine (sw.Elapsed.ToString ());  	Console.WriteLine ("Getting blocks needed");  	int BlocksNeeded = (int)(VariousFunctions.UpToNearestCluster (new System.IO.FileInfo (Path).Length' PartitionInfo.ClusterSize) / PartitionInfo.ClusterSize);  	Console.WriteLine (sw.Elapsed.ToString ());  	List<uint> Blocks = new List<uint> ();  	Console.WriteLine ("Getting new entry");  	EntryData newE = new EntryFunctions (this).GetNewEntry (this' (uint)new System.IO.FileInfo (Path).Length' new CLKsFATXLib.Geometry.Flags[0]' NewName);  	if (newE.EntryOffset >= VariousFunctions.GetBlockOffset (this.BlocksOccupied [BlocksOccupied.Length - 1]' this) + this.PartitionInfo.ClusterSize) {  		List<uint> blocks = this.BlocksOccupied.ToList ();  		blocks.Add (VariousFunctions.GetBlockFromOffset (newE.EntryOffset' this.PartitionInfo));  		this.BlocksOccupied = blocks.ToArray ();  	}  	Console.WriteLine (sw.Elapsed.ToString ());  	Blocks.Add (newE.StartingCluster);  	try {  		Console.WriteLine ("Getting free blocks");  		Blocks.AddRange (Drive.GetFreeBlocks (this' BlocksNeeded - 1' newE.StartingCluster' 0' false));  		Console.WriteLine (sw.Elapsed.ToString ());  	}  	// This excpetion here is going to be that we're out of space...  	catch (Exception x) {  		Console.WriteLine ("Exception thrown' deleting written entry");  		// Delete this entry  		newE.NameSize = 0xE5;  		// Create a new entry functions class so we can get rid of this entry  		EntryFunctions ef = new EntryFunctions (this);  		// Clear the FAT chain  		Console.WriteLine ("Clearing FAT chain");  		ef.ClearFATChain (new uint[] {  			newE.StartingCluster  		});  		// Mark this entry as deleted  		ef.CreateNewEntry (newE);  		throw x;  	}  	Console.WriteLine ("Writing FAT chain");  	// Write that FAT chain  	new EntryFunctions (this).WriteFATChain (Blocks.ToArray ());  	Console.WriteLine (sw.Elapsed.ToString ());  	// Write the file data...  	// FileAction to be used  	fa.MaxValue = Blocks.Count;  	// The IO to read the file  	Streams.Reader FileReader = null;  	try {  		FileReader = new CLKsFATXLib.Streams.Reader (new System.IO.FileStream (Path' System.IO.FileMode.Open));  	}  	catch {  		System.Threading.Thread.Sleep (1000);  		try {  			FileReader = new CLKsFATXLib.Streams.Reader (new System.IO.FileStream (Path' System.IO.FileMode.Open));  		}  		catch (Exception x) {  			Console.WriteLine ("Exception thrown' deleting written entry");  			// Delete this entry  			newE.NameSize = 0xE5;  			// Create a new entry functions class so we can get rid of this entry  			EntryFunctions ef = new EntryFunctions (this);  			// Clear the FAT chain  			Console.WriteLine ("Clearing FAT chain");  			ef.ClearFATChain (Blocks.ToArray ());  			// Mark this entry as deleted  			ef.CreateNewEntry (newE);  			throw x;  		}  	}  	// The IO to write to the destination file  	Streams.Writer FileWriter = Drive.Writer ();  	// Loop for each block...  	for (int i = 0; i < Blocks.Count - 1; i++) {  		if (fa.Cancel) {  			Console.WriteLine ("Cancel engaged");  			FileReader.Close ();  			File newfile = new File (this.PartitionInfo' newE' this.Drive);  			newfile.Parent = this;  			newfile.FullPath = this.FullPath + "\\" + newfile.Name;  			this.cachedFiles.Add (newfile);  			eea.FullParentPath = FullPath;  			eea.ModifiedEntry = newfile;  			eea.ParentFolder = this;  			OnEntryEvent (ref eea);  			UpdateModifiedTime ();  			Return.Entry = newfile;  			return Return;  		}  		// Set the position to the beginning of the block  		FileWriter.BaseStream.Position = VariousFunctions.GetBlockOffset (Blocks [i]' this);  		for (int j = 1' k = 0; j <= 0x100; j++' k++) {  			if (i + k == Blocks.Count - 1) {  				//Console.WriteLine("Writing part of file");  				FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * k));  				i += k;  				fa.Progress += k;  				break;  			}  			else if (Blocks [i + k] == Blocks.Count - 2 || Blocks [i + k] + 1 != Blocks [i + j] || j == 10) {  				//Console.WriteLine("Writing part of file");  				FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * j));  				i += k;  				fa.Progress += j;  				break;  			}  		}  		OnFolderAction (ref fa);  	}  	Console.WriteLine (sw.Elapsed.ToString ());  	// For the last cluster' we don't know how long it is... so we use  	// this nifty function I made to do that for us  	Console.WriteLine ("Seeking to final cluster");  	FileWriter.BaseStream.Position = VariousFunctions.GetBlockOffset (Blocks [Blocks.Count - 1]' this);  	// Read/write data  	byte[] ToWrite = new byte[(int)VariousFunctions.UpToNearest200 (VariousFunctions.RemainingData (BlocksNeeded' new System.IO.FileInfo (Path).Length' this))];  	if ((int)VariousFunctions.RemainingData (BlocksNeeded' new System.IO.FileInfo (Path).Length' this) < (int)VariousFunctions.UpToNearest200 ((int)VariousFunctions.RemainingData (BlocksNeeded' new System.IO.FileInfo (Path).Length' this))) {  		for (int i = (int)VariousFunctions.RemainingData (BlocksNeeded' new System.IO.FileInfo (Path).Length' this) + 1; i < ToWrite.Length; i++) {  			ToWrite [i] = 0xFF;  		}  	}  	byte[] Buffer = FileReader.ReadBytes ((int)VariousFunctions.RemainingData (BlocksNeeded' new System.IO.FileInfo (Path).Length' this));  	Array.Copy (Buffer' 0' ToWrite' 0' Buffer.Length);  	Buffer = null;  	Console.WriteLine ("Writing final cluster");  	FileWriter.Write (ToWrite);  	fa.Progress++;  	OnFolderAction (ref fa);  	Console.WriteLine ("Closing streams");  	FileReader.Close ();  	Console.WriteLine (sw.Elapsed.ToString ());  	File newF = new File (this.PartitionInfo' newE' this.Drive);  	newF.Parent = this;  	newF.FullPath = this.FullPath + "\\" + newF.Name;  	this.cachedFiles.Add (newF);  	Return.Entry = newF;  	eea.ModifiedEntry = newF;  }  
Magic Number,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,CreateNewFile,The following statement contains a magic number: if (new System.IO.FileInfo (Path).Length == 0) {  	Console.WriteLine ("Creating null file");  	File f = new File (this.PartitionInfo' new EntryFunctions (this).GetNewEntry (this' 0' new CLKsFATXLib.Geometry.Flags[0]' NewName)' this.Drive);  	f.Parent = this;  	f.FullPath = this.FullPath + "\\" + f.Name;  	Return.Entry = f;  	eea.ModifiedEntry = f;  }  else {  	Console.WriteLine (sw.Elapsed.ToString ());  	Console.WriteLine ("Getting blocks needed");  	int BlocksNeeded = (int)(VariousFunctions.UpToNearestCluster (new System.IO.FileInfo (Path).Length' PartitionInfo.ClusterSize) / PartitionInfo.ClusterSize);  	Console.WriteLine (sw.Elapsed.ToString ());  	List<uint> Blocks = new List<uint> ();  	Console.WriteLine ("Getting new entry");  	EntryData newE = new EntryFunctions (this).GetNewEntry (this' (uint)new System.IO.FileInfo (Path).Length' new CLKsFATXLib.Geometry.Flags[0]' NewName);  	if (newE.EntryOffset >= VariousFunctions.GetBlockOffset (this.BlocksOccupied [BlocksOccupied.Length - 1]' this) + this.PartitionInfo.ClusterSize) {  		List<uint> blocks = this.BlocksOccupied.ToList ();  		blocks.Add (VariousFunctions.GetBlockFromOffset (newE.EntryOffset' this.PartitionInfo));  		this.BlocksOccupied = blocks.ToArray ();  	}  	Console.WriteLine (sw.Elapsed.ToString ());  	Blocks.Add (newE.StartingCluster);  	try {  		Console.WriteLine ("Getting free blocks");  		Blocks.AddRange (Drive.GetFreeBlocks (this' BlocksNeeded - 1' newE.StartingCluster' 0' false));  		Console.WriteLine (sw.Elapsed.ToString ());  	}  	// This excpetion here is going to be that we're out of space...  	catch (Exception x) {  		Console.WriteLine ("Exception thrown' deleting written entry");  		// Delete this entry  		newE.NameSize = 0xE5;  		// Create a new entry functions class so we can get rid of this entry  		EntryFunctions ef = new EntryFunctions (this);  		// Clear the FAT chain  		Console.WriteLine ("Clearing FAT chain");  		ef.ClearFATChain (new uint[] {  			newE.StartingCluster  		});  		// Mark this entry as deleted  		ef.CreateNewEntry (newE);  		throw x;  	}  	Console.WriteLine ("Writing FAT chain");  	// Write that FAT chain  	new EntryFunctions (this).WriteFATChain (Blocks.ToArray ());  	Console.WriteLine (sw.Elapsed.ToString ());  	// Write the file data...  	// FileAction to be used  	fa.MaxValue = Blocks.Count;  	// The IO to read the file  	Streams.Reader FileReader = null;  	try {  		FileReader = new CLKsFATXLib.Streams.Reader (new System.IO.FileStream (Path' System.IO.FileMode.Open));  	}  	catch {  		System.Threading.Thread.Sleep (1000);  		try {  			FileReader = new CLKsFATXLib.Streams.Reader (new System.IO.FileStream (Path' System.IO.FileMode.Open));  		}  		catch (Exception x) {  			Console.WriteLine ("Exception thrown' deleting written entry");  			// Delete this entry  			newE.NameSize = 0xE5;  			// Create a new entry functions class so we can get rid of this entry  			EntryFunctions ef = new EntryFunctions (this);  			// Clear the FAT chain  			Console.WriteLine ("Clearing FAT chain");  			ef.ClearFATChain (Blocks.ToArray ());  			// Mark this entry as deleted  			ef.CreateNewEntry (newE);  			throw x;  		}  	}  	// The IO to write to the destination file  	Streams.Writer FileWriter = Drive.Writer ();  	// Loop for each block...  	for (int i = 0; i < Blocks.Count - 1; i++) {  		if (fa.Cancel) {  			Console.WriteLine ("Cancel engaged");  			FileReader.Close ();  			File newfile = new File (this.PartitionInfo' newE' this.Drive);  			newfile.Parent = this;  			newfile.FullPath = this.FullPath + "\\" + newfile.Name;  			this.cachedFiles.Add (newfile);  			eea.FullParentPath = FullPath;  			eea.ModifiedEntry = newfile;  			eea.ParentFolder = this;  			OnEntryEvent (ref eea);  			UpdateModifiedTime ();  			Return.Entry = newfile;  			return Return;  		}  		// Set the position to the beginning of the block  		FileWriter.BaseStream.Position = VariousFunctions.GetBlockOffset (Blocks [i]' this);  		for (int j = 1' k = 0; j <= 0x100; j++' k++) {  			if (i + k == Blocks.Count - 1) {  				//Console.WriteLine("Writing part of file");  				FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * k));  				i += k;  				fa.Progress += k;  				break;  			}  			else if (Blocks [i + k] == Blocks.Count - 2 || Blocks [i + k] + 1 != Blocks [i + j] || j == 10) {  				//Console.WriteLine("Writing part of file");  				FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * j));  				i += k;  				fa.Progress += j;  				break;  			}  		}  		OnFolderAction (ref fa);  	}  	Console.WriteLine (sw.Elapsed.ToString ());  	// For the last cluster' we don't know how long it is... so we use  	// this nifty function I made to do that for us  	Console.WriteLine ("Seeking to final cluster");  	FileWriter.BaseStream.Position = VariousFunctions.GetBlockOffset (Blocks [Blocks.Count - 1]' this);  	// Read/write data  	byte[] ToWrite = new byte[(int)VariousFunctions.UpToNearest200 (VariousFunctions.RemainingData (BlocksNeeded' new System.IO.FileInfo (Path).Length' this))];  	if ((int)VariousFunctions.RemainingData (BlocksNeeded' new System.IO.FileInfo (Path).Length' this) < (int)VariousFunctions.UpToNearest200 ((int)VariousFunctions.RemainingData (BlocksNeeded' new System.IO.FileInfo (Path).Length' this))) {  		for (int i = (int)VariousFunctions.RemainingData (BlocksNeeded' new System.IO.FileInfo (Path).Length' this) + 1; i < ToWrite.Length; i++) {  			ToWrite [i] = 0xFF;  		}  	}  	byte[] Buffer = FileReader.ReadBytes ((int)VariousFunctions.RemainingData (BlocksNeeded' new System.IO.FileInfo (Path).Length' this));  	Array.Copy (Buffer' 0' ToWrite' 0' Buffer.Length);  	Buffer = null;  	Console.WriteLine ("Writing final cluster");  	FileWriter.Write (ToWrite);  	fa.Progress++;  	OnFolderAction (ref fa);  	Console.WriteLine ("Closing streams");  	FileReader.Close ();  	Console.WriteLine (sw.Elapsed.ToString ());  	File newF = new File (this.PartitionInfo' newE' this.Drive);  	newF.Parent = this;  	newF.FullPath = this.FullPath + "\\" + newF.Name;  	this.cachedFiles.Add (newF);  	Return.Entry = newF;  	eea.ModifiedEntry = newF;  }  
Magic Number,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,CreateNewFile,The following statement contains a magic number: try {  	FileReader = new CLKsFATXLib.Streams.Reader (new System.IO.FileStream (Path' System.IO.FileMode.Open));  }  catch {  	System.Threading.Thread.Sleep (1000);  	try {  		FileReader = new CLKsFATXLib.Streams.Reader (new System.IO.FileStream (Path' System.IO.FileMode.Open));  	}  	catch (Exception x) {  		Console.WriteLine ("Exception thrown' deleting written entry");  		// Delete this entry  		newE.NameSize = 0xE5;  		// Create a new entry functions class so we can get rid of this entry  		EntryFunctions ef = new EntryFunctions (this);  		// Clear the FAT chain  		Console.WriteLine ("Clearing FAT chain");  		ef.ClearFATChain (Blocks.ToArray ());  		// Mark this entry as deleted  		ef.CreateNewEntry (newE);  		throw x;  	}  }  
Magic Number,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,CreateNewFile,The following statement contains a magic number: System.Threading.Thread.Sleep (1000);  
Magic Number,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,CreateNewFile,The following statement contains a magic number: for (int i = 0; i < Blocks.Count - 1; i++) {  	if (fa.Cancel) {  		Console.WriteLine ("Cancel engaged");  		FileReader.Close ();  		File newfile = new File (this.PartitionInfo' newE' this.Drive);  		newfile.Parent = this;  		newfile.FullPath = this.FullPath + "\\" + newfile.Name;  		this.cachedFiles.Add (newfile);  		eea.FullParentPath = FullPath;  		eea.ModifiedEntry = newfile;  		eea.ParentFolder = this;  		OnEntryEvent (ref eea);  		UpdateModifiedTime ();  		Return.Entry = newfile;  		return Return;  	}  	// Set the position to the beginning of the block  	FileWriter.BaseStream.Position = VariousFunctions.GetBlockOffset (Blocks [i]' this);  	for (int j = 1' k = 0; j <= 0x100; j++' k++) {  		if (i + k == Blocks.Count - 1) {  			//Console.WriteLine("Writing part of file");  			FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * k));  			i += k;  			fa.Progress += k;  			break;  		}  		else if (Blocks [i + k] == Blocks.Count - 2 || Blocks [i + k] + 1 != Blocks [i + j] || j == 10) {  			//Console.WriteLine("Writing part of file");  			FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * j));  			i += k;  			fa.Progress += j;  			break;  		}  	}  	OnFolderAction (ref fa);  }  
Magic Number,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,CreateNewFile,The following statement contains a magic number: for (int i = 0; i < Blocks.Count - 1; i++) {  	if (fa.Cancel) {  		Console.WriteLine ("Cancel engaged");  		FileReader.Close ();  		File newfile = new File (this.PartitionInfo' newE' this.Drive);  		newfile.Parent = this;  		newfile.FullPath = this.FullPath + "\\" + newfile.Name;  		this.cachedFiles.Add (newfile);  		eea.FullParentPath = FullPath;  		eea.ModifiedEntry = newfile;  		eea.ParentFolder = this;  		OnEntryEvent (ref eea);  		UpdateModifiedTime ();  		Return.Entry = newfile;  		return Return;  	}  	// Set the position to the beginning of the block  	FileWriter.BaseStream.Position = VariousFunctions.GetBlockOffset (Blocks [i]' this);  	for (int j = 1' k = 0; j <= 0x100; j++' k++) {  		if (i + k == Blocks.Count - 1) {  			//Console.WriteLine("Writing part of file");  			FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * k));  			i += k;  			fa.Progress += k;  			break;  		}  		else if (Blocks [i + k] == Blocks.Count - 2 || Blocks [i + k] + 1 != Blocks [i + j] || j == 10) {  			//Console.WriteLine("Writing part of file");  			FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * j));  			i += k;  			fa.Progress += j;  			break;  		}  	}  	OnFolderAction (ref fa);  }  
Magic Number,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,CreateNewFile,The following statement contains a magic number: for (int j = 1' k = 0; j <= 0x100; j++' k++) {  	if (i + k == Blocks.Count - 1) {  		//Console.WriteLine("Writing part of file");  		FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * k));  		i += k;  		fa.Progress += k;  		break;  	}  	else if (Blocks [i + k] == Blocks.Count - 2 || Blocks [i + k] + 1 != Blocks [i + j] || j == 10) {  		//Console.WriteLine("Writing part of file");  		FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * j));  		i += k;  		fa.Progress += j;  		break;  	}  }  
Magic Number,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,CreateNewFile,The following statement contains a magic number: for (int j = 1' k = 0; j <= 0x100; j++' k++) {  	if (i + k == Blocks.Count - 1) {  		//Console.WriteLine("Writing part of file");  		FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * k));  		i += k;  		fa.Progress += k;  		break;  	}  	else if (Blocks [i + k] == Blocks.Count - 2 || Blocks [i + k] + 1 != Blocks [i + j] || j == 10) {  		//Console.WriteLine("Writing part of file");  		FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * j));  		i += k;  		fa.Progress += j;  		break;  	}  }  
Magic Number,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,CreateNewFile,The following statement contains a magic number: if (i + k == Blocks.Count - 1) {  	//Console.WriteLine("Writing part of file");  	FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * k));  	i += k;  	fa.Progress += k;  	break;  }  else if (Blocks [i + k] == Blocks.Count - 2 || Blocks [i + k] + 1 != Blocks [i + j] || j == 10) {  	//Console.WriteLine("Writing part of file");  	FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * j));  	i += k;  	fa.Progress += j;  	break;  }  
Magic Number,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,CreateNewFile,The following statement contains a magic number: if (i + k == Blocks.Count - 1) {  	//Console.WriteLine("Writing part of file");  	FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * k));  	i += k;  	fa.Progress += k;  	break;  }  else if (Blocks [i + k] == Blocks.Count - 2 || Blocks [i + k] + 1 != Blocks [i + j] || j == 10) {  	//Console.WriteLine("Writing part of file");  	FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * j));  	i += k;  	fa.Progress += j;  	break;  }  
Magic Number,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,CreateNewFile,The following statement contains a magic number: if (Blocks [i + k] == Blocks.Count - 2 || Blocks [i + k] + 1 != Blocks [i + j] || j == 10) {  	//Console.WriteLine("Writing part of file");  	FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * j));  	i += k;  	fa.Progress += j;  	break;  }  
Magic Number,CLKsFATXLib,Folder,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\EntryTypes.cs,CreateNewFile,The following statement contains a magic number: if (Blocks [i + k] == Blocks.Count - 2 || Blocks [i + k] + 1 != Blocks [i + j] || j == 10) {  	//Console.WriteLine("Writing part of file");  	FileWriter.Write (FileReader.ReadBytes ((int)PartitionInfo.ClusterSize * j));  	i += k;  	fa.Progress += j;  	break;  }  
Magic Number,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ProcessBootSector,The following statement contains a magic number: if (r25 < r11) {  	// BRANCH  	//long r7 = 0 /* Should be SP + 0x50' but that's 0. */' r5 = 0' r6 = 0;  	long r3 = r31;  	// Call fsc map buffer here' but we're not going to  	r10 = 0;  	r9 = 0;  	r3 = 0;  	if (r3 == 0) {  		r9 = 0x58544146;  		// FATX ("XTAF") magic  		r11 = Magic ();  		if ((uint)r9 == Magic ()) {  			// Read sectors per cluster  			r11 = SectorsPerCluster ();  			if (r11 == 0) {  				throw InvalidSectorsPerCluster;  				return;  			}  			if (!(r11 <= 2) && (r11 != 0x4) && (r11 != 0x8) && (r11 != 0x20) && (r11 != 0x40) && (r11 != 0x80)) {  				throw InvalidSectorsPerCluster;  			}  			r9 = 9;  			// 9 because 0x1000 / 8 = 0x200' 0x200 = sector size  			// Shift  			r11 = r11 << (int)r9;  			// cluster size  			long r31CC = r11;  			if (r11 == 0) {  				// what  				r11 = 0;  				//r30;  			}  			else// Usually branches here  			 {  				r11 = cntlzw ((uint)r11);  				r11 = 0x1F - r11;  			}  			long r31D1 = r11;  			if (r26 != 0)// Usually skips this  			 {  				r11 = r31CC;  				if (r11 != 0x4000) {  					throw InvalidBytesPerSector;  				}  			}  			r11 = PartitionID ();  			long r31160 = r11;  			r3 = SP50;  			// becomes pointer to FATX partition  			long r27 = RootDirectoryCluster ();  			// FscUnmapBuffer  			SP50 = r30;  			r11 = r31CC;  			if (r11 < r29) {  				throw TooSmallClusterSize;  			}  			r9 = (byte)r31D1;  			r11 = r28;  			r11 = (r11 >> (int)r9);  			r11++;  			// Entry size?  			if (r11 < 0x0000FFF0 && r26 == 0) {  				// Should branch here  				r10 = 1;  				r11 = ((long)r11 << 1);  			}  			else if (r11 >= 0x0000FFF0) {  				r10 = 2;  				r11 = ((long)r11 << 2);  			}  			r11 += r29;  			long r31D2 = r10;  			long r8 = r29 - 1;  			r10 = (long)r28;  			r11--;  			r10 = r10 - r25;  			// And with complement  			r11 = r11 & ~r8;  			r11 &= 0xFFFFFFFF;  			if (r11 >= r10) {  				throw VolumeTooSmall;  			}  			r10 -= r11;  			r9 &= 0xFFFFFFFFFFFFFF;  			r8 = 0x000000000FFFFFFF;  			r10 >>= (int)r9;  			long r31C8 = clusters = (uint)r10;  			if (r10 > r8) {  				throw TooManyClusters;  			}  			Console.WriteLine (Partition.Offset.ToString ("X") + " Clusters " + r10.ToString ("X"));  			fatsize = r11;  			Console.WriteLine ("r11 " + r11.ToString ("X"));  			r11 += r25;  			Console.WriteLine ("r11 " + r11.ToString ("X"));  			long r31D4 = r25;  			r10 = r25 & 0xFFF;  			Console.WriteLine ("r25 " + r25.ToString ("X") + "\r\nr10 " + r10.ToString ("X"));  			r11 &= 0xFFF;  			Console.WriteLine ("r11 " + r11.ToString ("X"));  			//fatsize = r11.UpToNearestCluster(r31CC);  			r11 = r31CC;  			Console.WriteLine ("r11 " + r11.ToString ("X"));  			r11 &= 0xFFF;  			Console.WriteLine ("r11 " + r11.ToString ("X"));  		}  	}  	else {  		// BRANCH  	}  }  
Magic Number,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ProcessBootSector,The following statement contains a magic number: if (r25 < r11) {  	// BRANCH  	//long r7 = 0 /* Should be SP + 0x50' but that's 0. */' r5 = 0' r6 = 0;  	long r3 = r31;  	// Call fsc map buffer here' but we're not going to  	r10 = 0;  	r9 = 0;  	r3 = 0;  	if (r3 == 0) {  		r9 = 0x58544146;  		// FATX ("XTAF") magic  		r11 = Magic ();  		if ((uint)r9 == Magic ()) {  			// Read sectors per cluster  			r11 = SectorsPerCluster ();  			if (r11 == 0) {  				throw InvalidSectorsPerCluster;  				return;  			}  			if (!(r11 <= 2) && (r11 != 0x4) && (r11 != 0x8) && (r11 != 0x20) && (r11 != 0x40) && (r11 != 0x80)) {  				throw InvalidSectorsPerCluster;  			}  			r9 = 9;  			// 9 because 0x1000 / 8 = 0x200' 0x200 = sector size  			// Shift  			r11 = r11 << (int)r9;  			// cluster size  			long r31CC = r11;  			if (r11 == 0) {  				// what  				r11 = 0;  				//r30;  			}  			else// Usually branches here  			 {  				r11 = cntlzw ((uint)r11);  				r11 = 0x1F - r11;  			}  			long r31D1 = r11;  			if (r26 != 0)// Usually skips this  			 {  				r11 = r31CC;  				if (r11 != 0x4000) {  					throw InvalidBytesPerSector;  				}  			}  			r11 = PartitionID ();  			long r31160 = r11;  			r3 = SP50;  			// becomes pointer to FATX partition  			long r27 = RootDirectoryCluster ();  			// FscUnmapBuffer  			SP50 = r30;  			r11 = r31CC;  			if (r11 < r29) {  				throw TooSmallClusterSize;  			}  			r9 = (byte)r31D1;  			r11 = r28;  			r11 = (r11 >> (int)r9);  			r11++;  			// Entry size?  			if (r11 < 0x0000FFF0 && r26 == 0) {  				// Should branch here  				r10 = 1;  				r11 = ((long)r11 << 1);  			}  			else if (r11 >= 0x0000FFF0) {  				r10 = 2;  				r11 = ((long)r11 << 2);  			}  			r11 += r29;  			long r31D2 = r10;  			long r8 = r29 - 1;  			r10 = (long)r28;  			r11--;  			r10 = r10 - r25;  			// And with complement  			r11 = r11 & ~r8;  			r11 &= 0xFFFFFFFF;  			if (r11 >= r10) {  				throw VolumeTooSmall;  			}  			r10 -= r11;  			r9 &= 0xFFFFFFFFFFFFFF;  			r8 = 0x000000000FFFFFFF;  			r10 >>= (int)r9;  			long r31C8 = clusters = (uint)r10;  			if (r10 > r8) {  				throw TooManyClusters;  			}  			Console.WriteLine (Partition.Offset.ToString ("X") + " Clusters " + r10.ToString ("X"));  			fatsize = r11;  			Console.WriteLine ("r11 " + r11.ToString ("X"));  			r11 += r25;  			Console.WriteLine ("r11 " + r11.ToString ("X"));  			long r31D4 = r25;  			r10 = r25 & 0xFFF;  			Console.WriteLine ("r25 " + r25.ToString ("X") + "\r\nr10 " + r10.ToString ("X"));  			r11 &= 0xFFF;  			Console.WriteLine ("r11 " + r11.ToString ("X"));  			//fatsize = r11.UpToNearestCluster(r31CC);  			r11 = r31CC;  			Console.WriteLine ("r11 " + r11.ToString ("X"));  			r11 &= 0xFFF;  			Console.WriteLine ("r11 " + r11.ToString ("X"));  		}  	}  	else {  		// BRANCH  	}  }  
Magic Number,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ProcessBootSector,The following statement contains a magic number: if (r25 < r11) {  	// BRANCH  	//long r7 = 0 /* Should be SP + 0x50' but that's 0. */' r5 = 0' r6 = 0;  	long r3 = r31;  	// Call fsc map buffer here' but we're not going to  	r10 = 0;  	r9 = 0;  	r3 = 0;  	if (r3 == 0) {  		r9 = 0x58544146;  		// FATX ("XTAF") magic  		r11 = Magic ();  		if ((uint)r9 == Magic ()) {  			// Read sectors per cluster  			r11 = SectorsPerCluster ();  			if (r11 == 0) {  				throw InvalidSectorsPerCluster;  				return;  			}  			if (!(r11 <= 2) && (r11 != 0x4) && (r11 != 0x8) && (r11 != 0x20) && (r11 != 0x40) && (r11 != 0x80)) {  				throw InvalidSectorsPerCluster;  			}  			r9 = 9;  			// 9 because 0x1000 / 8 = 0x200' 0x200 = sector size  			// Shift  			r11 = r11 << (int)r9;  			// cluster size  			long r31CC = r11;  			if (r11 == 0) {  				// what  				r11 = 0;  				//r30;  			}  			else// Usually branches here  			 {  				r11 = cntlzw ((uint)r11);  				r11 = 0x1F - r11;  			}  			long r31D1 = r11;  			if (r26 != 0)// Usually skips this  			 {  				r11 = r31CC;  				if (r11 != 0x4000) {  					throw InvalidBytesPerSector;  				}  			}  			r11 = PartitionID ();  			long r31160 = r11;  			r3 = SP50;  			// becomes pointer to FATX partition  			long r27 = RootDirectoryCluster ();  			// FscUnmapBuffer  			SP50 = r30;  			r11 = r31CC;  			if (r11 < r29) {  				throw TooSmallClusterSize;  			}  			r9 = (byte)r31D1;  			r11 = r28;  			r11 = (r11 >> (int)r9);  			r11++;  			// Entry size?  			if (r11 < 0x0000FFF0 && r26 == 0) {  				// Should branch here  				r10 = 1;  				r11 = ((long)r11 << 1);  			}  			else if (r11 >= 0x0000FFF0) {  				r10 = 2;  				r11 = ((long)r11 << 2);  			}  			r11 += r29;  			long r31D2 = r10;  			long r8 = r29 - 1;  			r10 = (long)r28;  			r11--;  			r10 = r10 - r25;  			// And with complement  			r11 = r11 & ~r8;  			r11 &= 0xFFFFFFFF;  			if (r11 >= r10) {  				throw VolumeTooSmall;  			}  			r10 -= r11;  			r9 &= 0xFFFFFFFFFFFFFF;  			r8 = 0x000000000FFFFFFF;  			r10 >>= (int)r9;  			long r31C8 = clusters = (uint)r10;  			if (r10 > r8) {  				throw TooManyClusters;  			}  			Console.WriteLine (Partition.Offset.ToString ("X") + " Clusters " + r10.ToString ("X"));  			fatsize = r11;  			Console.WriteLine ("r11 " + r11.ToString ("X"));  			r11 += r25;  			Console.WriteLine ("r11 " + r11.ToString ("X"));  			long r31D4 = r25;  			r10 = r25 & 0xFFF;  			Console.WriteLine ("r25 " + r25.ToString ("X") + "\r\nr10 " + r10.ToString ("X"));  			r11 &= 0xFFF;  			Console.WriteLine ("r11 " + r11.ToString ("X"));  			//fatsize = r11.UpToNearestCluster(r31CC);  			r11 = r31CC;  			Console.WriteLine ("r11 " + r11.ToString ("X"));  			r11 &= 0xFFF;  			Console.WriteLine ("r11 " + r11.ToString ("X"));  		}  	}  	else {  		// BRANCH  	}  }  
Magic Number,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ProcessBootSector,The following statement contains a magic number: if (r25 < r11) {  	// BRANCH  	//long r7 = 0 /* Should be SP + 0x50' but that's 0. */' r5 = 0' r6 = 0;  	long r3 = r31;  	// Call fsc map buffer here' but we're not going to  	r10 = 0;  	r9 = 0;  	r3 = 0;  	if (r3 == 0) {  		r9 = 0x58544146;  		// FATX ("XTAF") magic  		r11 = Magic ();  		if ((uint)r9 == Magic ()) {  			// Read sectors per cluster  			r11 = SectorsPerCluster ();  			if (r11 == 0) {  				throw InvalidSectorsPerCluster;  				return;  			}  			if (!(r11 <= 2) && (r11 != 0x4) && (r11 != 0x8) && (r11 != 0x20) && (r11 != 0x40) && (r11 != 0x80)) {  				throw InvalidSectorsPerCluster;  			}  			r9 = 9;  			// 9 because 0x1000 / 8 = 0x200' 0x200 = sector size  			// Shift  			r11 = r11 << (int)r9;  			// cluster size  			long r31CC = r11;  			if (r11 == 0) {  				// what  				r11 = 0;  				//r30;  			}  			else// Usually branches here  			 {  				r11 = cntlzw ((uint)r11);  				r11 = 0x1F - r11;  			}  			long r31D1 = r11;  			if (r26 != 0)// Usually skips this  			 {  				r11 = r31CC;  				if (r11 != 0x4000) {  					throw InvalidBytesPerSector;  				}  			}  			r11 = PartitionID ();  			long r31160 = r11;  			r3 = SP50;  			// becomes pointer to FATX partition  			long r27 = RootDirectoryCluster ();  			// FscUnmapBuffer  			SP50 = r30;  			r11 = r31CC;  			if (r11 < r29) {  				throw TooSmallClusterSize;  			}  			r9 = (byte)r31D1;  			r11 = r28;  			r11 = (r11 >> (int)r9);  			r11++;  			// Entry size?  			if (r11 < 0x0000FFF0 && r26 == 0) {  				// Should branch here  				r10 = 1;  				r11 = ((long)r11 << 1);  			}  			else if (r11 >= 0x0000FFF0) {  				r10 = 2;  				r11 = ((long)r11 << 2);  			}  			r11 += r29;  			long r31D2 = r10;  			long r8 = r29 - 1;  			r10 = (long)r28;  			r11--;  			r10 = r10 - r25;  			// And with complement  			r11 = r11 & ~r8;  			r11 &= 0xFFFFFFFF;  			if (r11 >= r10) {  				throw VolumeTooSmall;  			}  			r10 -= r11;  			r9 &= 0xFFFFFFFFFFFFFF;  			r8 = 0x000000000FFFFFFF;  			r10 >>= (int)r9;  			long r31C8 = clusters = (uint)r10;  			if (r10 > r8) {  				throw TooManyClusters;  			}  			Console.WriteLine (Partition.Offset.ToString ("X") + " Clusters " + r10.ToString ("X"));  			fatsize = r11;  			Console.WriteLine ("r11 " + r11.ToString ("X"));  			r11 += r25;  			Console.WriteLine ("r11 " + r11.ToString ("X"));  			long r31D4 = r25;  			r10 = r25 & 0xFFF;  			Console.WriteLine ("r25 " + r25.ToString ("X") + "\r\nr10 " + r10.ToString ("X"));  			r11 &= 0xFFF;  			Console.WriteLine ("r11 " + r11.ToString ("X"));  			//fatsize = r11.UpToNearestCluster(r31CC);  			r11 = r31CC;  			Console.WriteLine ("r11 " + r11.ToString ("X"));  			r11 &= 0xFFF;  			Console.WriteLine ("r11 " + r11.ToString ("X"));  		}  	}  	else {  		// BRANCH  	}  }  
Magic Number,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ProcessBootSector,The following statement contains a magic number: if (r3 == 0) {  	r9 = 0x58544146;  	// FATX ("XTAF") magic  	r11 = Magic ();  	if ((uint)r9 == Magic ()) {  		// Read sectors per cluster  		r11 = SectorsPerCluster ();  		if (r11 == 0) {  			throw InvalidSectorsPerCluster;  			return;  		}  		if (!(r11 <= 2) && (r11 != 0x4) && (r11 != 0x8) && (r11 != 0x20) && (r11 != 0x40) && (r11 != 0x80)) {  			throw InvalidSectorsPerCluster;  		}  		r9 = 9;  		// 9 because 0x1000 / 8 = 0x200' 0x200 = sector size  		// Shift  		r11 = r11 << (int)r9;  		// cluster size  		long r31CC = r11;  		if (r11 == 0) {  			// what  			r11 = 0;  			//r30;  		}  		else// Usually branches here  		 {  			r11 = cntlzw ((uint)r11);  			r11 = 0x1F - r11;  		}  		long r31D1 = r11;  		if (r26 != 0)// Usually skips this  		 {  			r11 = r31CC;  			if (r11 != 0x4000) {  				throw InvalidBytesPerSector;  			}  		}  		r11 = PartitionID ();  		long r31160 = r11;  		r3 = SP50;  		// becomes pointer to FATX partition  		long r27 = RootDirectoryCluster ();  		// FscUnmapBuffer  		SP50 = r30;  		r11 = r31CC;  		if (r11 < r29) {  			throw TooSmallClusterSize;  		}  		r9 = (byte)r31D1;  		r11 = r28;  		r11 = (r11 >> (int)r9);  		r11++;  		// Entry size?  		if (r11 < 0x0000FFF0 && r26 == 0) {  			// Should branch here  			r10 = 1;  			r11 = ((long)r11 << 1);  		}  		else if (r11 >= 0x0000FFF0) {  			r10 = 2;  			r11 = ((long)r11 << 2);  		}  		r11 += r29;  		long r31D2 = r10;  		long r8 = r29 - 1;  		r10 = (long)r28;  		r11--;  		r10 = r10 - r25;  		// And with complement  		r11 = r11 & ~r8;  		r11 &= 0xFFFFFFFF;  		if (r11 >= r10) {  			throw VolumeTooSmall;  		}  		r10 -= r11;  		r9 &= 0xFFFFFFFFFFFFFF;  		r8 = 0x000000000FFFFFFF;  		r10 >>= (int)r9;  		long r31C8 = clusters = (uint)r10;  		if (r10 > r8) {  			throw TooManyClusters;  		}  		Console.WriteLine (Partition.Offset.ToString ("X") + " Clusters " + r10.ToString ("X"));  		fatsize = r11;  		Console.WriteLine ("r11 " + r11.ToString ("X"));  		r11 += r25;  		Console.WriteLine ("r11 " + r11.ToString ("X"));  		long r31D4 = r25;  		r10 = r25 & 0xFFF;  		Console.WriteLine ("r25 " + r25.ToString ("X") + "\r\nr10 " + r10.ToString ("X"));  		r11 &= 0xFFF;  		Console.WriteLine ("r11 " + r11.ToString ("X"));  		//fatsize = r11.UpToNearestCluster(r31CC);  		r11 = r31CC;  		Console.WriteLine ("r11 " + r11.ToString ("X"));  		r11 &= 0xFFF;  		Console.WriteLine ("r11 " + r11.ToString ("X"));  	}  }  else {  	// BRANCH  }  
Magic Number,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ProcessBootSector,The following statement contains a magic number: if (r3 == 0) {  	r9 = 0x58544146;  	// FATX ("XTAF") magic  	r11 = Magic ();  	if ((uint)r9 == Magic ()) {  		// Read sectors per cluster  		r11 = SectorsPerCluster ();  		if (r11 == 0) {  			throw InvalidSectorsPerCluster;  			return;  		}  		if (!(r11 <= 2) && (r11 != 0x4) && (r11 != 0x8) && (r11 != 0x20) && (r11 != 0x40) && (r11 != 0x80)) {  			throw InvalidSectorsPerCluster;  		}  		r9 = 9;  		// 9 because 0x1000 / 8 = 0x200' 0x200 = sector size  		// Shift  		r11 = r11 << (int)r9;  		// cluster size  		long r31CC = r11;  		if (r11 == 0) {  			// what  			r11 = 0;  			//r30;  		}  		else// Usually branches here  		 {  			r11 = cntlzw ((uint)r11);  			r11 = 0x1F - r11;  		}  		long r31D1 = r11;  		if (r26 != 0)// Usually skips this  		 {  			r11 = r31CC;  			if (r11 != 0x4000) {  				throw InvalidBytesPerSector;  			}  		}  		r11 = PartitionID ();  		long r31160 = r11;  		r3 = SP50;  		// becomes pointer to FATX partition  		long r27 = RootDirectoryCluster ();  		// FscUnmapBuffer  		SP50 = r30;  		r11 = r31CC;  		if (r11 < r29) {  			throw TooSmallClusterSize;  		}  		r9 = (byte)r31D1;  		r11 = r28;  		r11 = (r11 >> (int)r9);  		r11++;  		// Entry size?  		if (r11 < 0x0000FFF0 && r26 == 0) {  			// Should branch here  			r10 = 1;  			r11 = ((long)r11 << 1);  		}  		else if (r11 >= 0x0000FFF0) {  			r10 = 2;  			r11 = ((long)r11 << 2);  		}  		r11 += r29;  		long r31D2 = r10;  		long r8 = r29 - 1;  		r10 = (long)r28;  		r11--;  		r10 = r10 - r25;  		// And with complement  		r11 = r11 & ~r8;  		r11 &= 0xFFFFFFFF;  		if (r11 >= r10) {  			throw VolumeTooSmall;  		}  		r10 -= r11;  		r9 &= 0xFFFFFFFFFFFFFF;  		r8 = 0x000000000FFFFFFF;  		r10 >>= (int)r9;  		long r31C8 = clusters = (uint)r10;  		if (r10 > r8) {  			throw TooManyClusters;  		}  		Console.WriteLine (Partition.Offset.ToString ("X") + " Clusters " + r10.ToString ("X"));  		fatsize = r11;  		Console.WriteLine ("r11 " + r11.ToString ("X"));  		r11 += r25;  		Console.WriteLine ("r11 " + r11.ToString ("X"));  		long r31D4 = r25;  		r10 = r25 & 0xFFF;  		Console.WriteLine ("r25 " + r25.ToString ("X") + "\r\nr10 " + r10.ToString ("X"));  		r11 &= 0xFFF;  		Console.WriteLine ("r11 " + r11.ToString ("X"));  		//fatsize = r11.UpToNearestCluster(r31CC);  		r11 = r31CC;  		Console.WriteLine ("r11 " + r11.ToString ("X"));  		r11 &= 0xFFF;  		Console.WriteLine ("r11 " + r11.ToString ("X"));  	}  }  else {  	// BRANCH  }  
Magic Number,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ProcessBootSector,The following statement contains a magic number: if (r3 == 0) {  	r9 = 0x58544146;  	// FATX ("XTAF") magic  	r11 = Magic ();  	if ((uint)r9 == Magic ()) {  		// Read sectors per cluster  		r11 = SectorsPerCluster ();  		if (r11 == 0) {  			throw InvalidSectorsPerCluster;  			return;  		}  		if (!(r11 <= 2) && (r11 != 0x4) && (r11 != 0x8) && (r11 != 0x20) && (r11 != 0x40) && (r11 != 0x80)) {  			throw InvalidSectorsPerCluster;  		}  		r9 = 9;  		// 9 because 0x1000 / 8 = 0x200' 0x200 = sector size  		// Shift  		r11 = r11 << (int)r9;  		// cluster size  		long r31CC = r11;  		if (r11 == 0) {  			// what  			r11 = 0;  			//r30;  		}  		else// Usually branches here  		 {  			r11 = cntlzw ((uint)r11);  			r11 = 0x1F - r11;  		}  		long r31D1 = r11;  		if (r26 != 0)// Usually skips this  		 {  			r11 = r31CC;  			if (r11 != 0x4000) {  				throw InvalidBytesPerSector;  			}  		}  		r11 = PartitionID ();  		long r31160 = r11;  		r3 = SP50;  		// becomes pointer to FATX partition  		long r27 = RootDirectoryCluster ();  		// FscUnmapBuffer  		SP50 = r30;  		r11 = r31CC;  		if (r11 < r29) {  			throw TooSmallClusterSize;  		}  		r9 = (byte)r31D1;  		r11 = r28;  		r11 = (r11 >> (int)r9);  		r11++;  		// Entry size?  		if (r11 < 0x0000FFF0 && r26 == 0) {  			// Should branch here  			r10 = 1;  			r11 = ((long)r11 << 1);  		}  		else if (r11 >= 0x0000FFF0) {  			r10 = 2;  			r11 = ((long)r11 << 2);  		}  		r11 += r29;  		long r31D2 = r10;  		long r8 = r29 - 1;  		r10 = (long)r28;  		r11--;  		r10 = r10 - r25;  		// And with complement  		r11 = r11 & ~r8;  		r11 &= 0xFFFFFFFF;  		if (r11 >= r10) {  			throw VolumeTooSmall;  		}  		r10 -= r11;  		r9 &= 0xFFFFFFFFFFFFFF;  		r8 = 0x000000000FFFFFFF;  		r10 >>= (int)r9;  		long r31C8 = clusters = (uint)r10;  		if (r10 > r8) {  			throw TooManyClusters;  		}  		Console.WriteLine (Partition.Offset.ToString ("X") + " Clusters " + r10.ToString ("X"));  		fatsize = r11;  		Console.WriteLine ("r11 " + r11.ToString ("X"));  		r11 += r25;  		Console.WriteLine ("r11 " + r11.ToString ("X"));  		long r31D4 = r25;  		r10 = r25 & 0xFFF;  		Console.WriteLine ("r25 " + r25.ToString ("X") + "\r\nr10 " + r10.ToString ("X"));  		r11 &= 0xFFF;  		Console.WriteLine ("r11 " + r11.ToString ("X"));  		//fatsize = r11.UpToNearestCluster(r31CC);  		r11 = r31CC;  		Console.WriteLine ("r11 " + r11.ToString ("X"));  		r11 &= 0xFFF;  		Console.WriteLine ("r11 " + r11.ToString ("X"));  	}  }  else {  	// BRANCH  }  
Magic Number,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ProcessBootSector,The following statement contains a magic number: if (r3 == 0) {  	r9 = 0x58544146;  	// FATX ("XTAF") magic  	r11 = Magic ();  	if ((uint)r9 == Magic ()) {  		// Read sectors per cluster  		r11 = SectorsPerCluster ();  		if (r11 == 0) {  			throw InvalidSectorsPerCluster;  			return;  		}  		if (!(r11 <= 2) && (r11 != 0x4) && (r11 != 0x8) && (r11 != 0x20) && (r11 != 0x40) && (r11 != 0x80)) {  			throw InvalidSectorsPerCluster;  		}  		r9 = 9;  		// 9 because 0x1000 / 8 = 0x200' 0x200 = sector size  		// Shift  		r11 = r11 << (int)r9;  		// cluster size  		long r31CC = r11;  		if (r11 == 0) {  			// what  			r11 = 0;  			//r30;  		}  		else// Usually branches here  		 {  			r11 = cntlzw ((uint)r11);  			r11 = 0x1F - r11;  		}  		long r31D1 = r11;  		if (r26 != 0)// Usually skips this  		 {  			r11 = r31CC;  			if (r11 != 0x4000) {  				throw InvalidBytesPerSector;  			}  		}  		r11 = PartitionID ();  		long r31160 = r11;  		r3 = SP50;  		// becomes pointer to FATX partition  		long r27 = RootDirectoryCluster ();  		// FscUnmapBuffer  		SP50 = r30;  		r11 = r31CC;  		if (r11 < r29) {  			throw TooSmallClusterSize;  		}  		r9 = (byte)r31D1;  		r11 = r28;  		r11 = (r11 >> (int)r9);  		r11++;  		// Entry size?  		if (r11 < 0x0000FFF0 && r26 == 0) {  			// Should branch here  			r10 = 1;  			r11 = ((long)r11 << 1);  		}  		else if (r11 >= 0x0000FFF0) {  			r10 = 2;  			r11 = ((long)r11 << 2);  		}  		r11 += r29;  		long r31D2 = r10;  		long r8 = r29 - 1;  		r10 = (long)r28;  		r11--;  		r10 = r10 - r25;  		// And with complement  		r11 = r11 & ~r8;  		r11 &= 0xFFFFFFFF;  		if (r11 >= r10) {  			throw VolumeTooSmall;  		}  		r10 -= r11;  		r9 &= 0xFFFFFFFFFFFFFF;  		r8 = 0x000000000FFFFFFF;  		r10 >>= (int)r9;  		long r31C8 = clusters = (uint)r10;  		if (r10 > r8) {  			throw TooManyClusters;  		}  		Console.WriteLine (Partition.Offset.ToString ("X") + " Clusters " + r10.ToString ("X"));  		fatsize = r11;  		Console.WriteLine ("r11 " + r11.ToString ("X"));  		r11 += r25;  		Console.WriteLine ("r11 " + r11.ToString ("X"));  		long r31D4 = r25;  		r10 = r25 & 0xFFF;  		Console.WriteLine ("r25 " + r25.ToString ("X") + "\r\nr10 " + r10.ToString ("X"));  		r11 &= 0xFFF;  		Console.WriteLine ("r11 " + r11.ToString ("X"));  		//fatsize = r11.UpToNearestCluster(r31CC);  		r11 = r31CC;  		Console.WriteLine ("r11 " + r11.ToString ("X"));  		r11 &= 0xFFF;  		Console.WriteLine ("r11 " + r11.ToString ("X"));  	}  }  else {  	// BRANCH  }  
Magic Number,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ProcessBootSector,The following statement contains a magic number: if ((uint)r9 == Magic ()) {  	// Read sectors per cluster  	r11 = SectorsPerCluster ();  	if (r11 == 0) {  		throw InvalidSectorsPerCluster;  		return;  	}  	if (!(r11 <= 2) && (r11 != 0x4) && (r11 != 0x8) && (r11 != 0x20) && (r11 != 0x40) && (r11 != 0x80)) {  		throw InvalidSectorsPerCluster;  	}  	r9 = 9;  	// 9 because 0x1000 / 8 = 0x200' 0x200 = sector size  	// Shift  	r11 = r11 << (int)r9;  	// cluster size  	long r31CC = r11;  	if (r11 == 0) {  		// what  		r11 = 0;  		//r30;  	}  	else// Usually branches here  	 {  		r11 = cntlzw ((uint)r11);  		r11 = 0x1F - r11;  	}  	long r31D1 = r11;  	if (r26 != 0)// Usually skips this  	 {  		r11 = r31CC;  		if (r11 != 0x4000) {  			throw InvalidBytesPerSector;  		}  	}  	r11 = PartitionID ();  	long r31160 = r11;  	r3 = SP50;  	// becomes pointer to FATX partition  	long r27 = RootDirectoryCluster ();  	// FscUnmapBuffer  	SP50 = r30;  	r11 = r31CC;  	if (r11 < r29) {  		throw TooSmallClusterSize;  	}  	r9 = (byte)r31D1;  	r11 = r28;  	r11 = (r11 >> (int)r9);  	r11++;  	// Entry size?  	if (r11 < 0x0000FFF0 && r26 == 0) {  		// Should branch here  		r10 = 1;  		r11 = ((long)r11 << 1);  	}  	else if (r11 >= 0x0000FFF0) {  		r10 = 2;  		r11 = ((long)r11 << 2);  	}  	r11 += r29;  	long r31D2 = r10;  	long r8 = r29 - 1;  	r10 = (long)r28;  	r11--;  	r10 = r10 - r25;  	// And with complement  	r11 = r11 & ~r8;  	r11 &= 0xFFFFFFFF;  	if (r11 >= r10) {  		throw VolumeTooSmall;  	}  	r10 -= r11;  	r9 &= 0xFFFFFFFFFFFFFF;  	r8 = 0x000000000FFFFFFF;  	r10 >>= (int)r9;  	long r31C8 = clusters = (uint)r10;  	if (r10 > r8) {  		throw TooManyClusters;  	}  	Console.WriteLine (Partition.Offset.ToString ("X") + " Clusters " + r10.ToString ("X"));  	fatsize = r11;  	Console.WriteLine ("r11 " + r11.ToString ("X"));  	r11 += r25;  	Console.WriteLine ("r11 " + r11.ToString ("X"));  	long r31D4 = r25;  	r10 = r25 & 0xFFF;  	Console.WriteLine ("r25 " + r25.ToString ("X") + "\r\nr10 " + r10.ToString ("X"));  	r11 &= 0xFFF;  	Console.WriteLine ("r11 " + r11.ToString ("X"));  	//fatsize = r11.UpToNearestCluster(r31CC);  	r11 = r31CC;  	Console.WriteLine ("r11 " + r11.ToString ("X"));  	r11 &= 0xFFF;  	Console.WriteLine ("r11 " + r11.ToString ("X"));  }  
Magic Number,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ProcessBootSector,The following statement contains a magic number: if ((uint)r9 == Magic ()) {  	// Read sectors per cluster  	r11 = SectorsPerCluster ();  	if (r11 == 0) {  		throw InvalidSectorsPerCluster;  		return;  	}  	if (!(r11 <= 2) && (r11 != 0x4) && (r11 != 0x8) && (r11 != 0x20) && (r11 != 0x40) && (r11 != 0x80)) {  		throw InvalidSectorsPerCluster;  	}  	r9 = 9;  	// 9 because 0x1000 / 8 = 0x200' 0x200 = sector size  	// Shift  	r11 = r11 << (int)r9;  	// cluster size  	long r31CC = r11;  	if (r11 == 0) {  		// what  		r11 = 0;  		//r30;  	}  	else// Usually branches here  	 {  		r11 = cntlzw ((uint)r11);  		r11 = 0x1F - r11;  	}  	long r31D1 = r11;  	if (r26 != 0)// Usually skips this  	 {  		r11 = r31CC;  		if (r11 != 0x4000) {  			throw InvalidBytesPerSector;  		}  	}  	r11 = PartitionID ();  	long r31160 = r11;  	r3 = SP50;  	// becomes pointer to FATX partition  	long r27 = RootDirectoryCluster ();  	// FscUnmapBuffer  	SP50 = r30;  	r11 = r31CC;  	if (r11 < r29) {  		throw TooSmallClusterSize;  	}  	r9 = (byte)r31D1;  	r11 = r28;  	r11 = (r11 >> (int)r9);  	r11++;  	// Entry size?  	if (r11 < 0x0000FFF0 && r26 == 0) {  		// Should branch here  		r10 = 1;  		r11 = ((long)r11 << 1);  	}  	else if (r11 >= 0x0000FFF0) {  		r10 = 2;  		r11 = ((long)r11 << 2);  	}  	r11 += r29;  	long r31D2 = r10;  	long r8 = r29 - 1;  	r10 = (long)r28;  	r11--;  	r10 = r10 - r25;  	// And with complement  	r11 = r11 & ~r8;  	r11 &= 0xFFFFFFFF;  	if (r11 >= r10) {  		throw VolumeTooSmall;  	}  	r10 -= r11;  	r9 &= 0xFFFFFFFFFFFFFF;  	r8 = 0x000000000FFFFFFF;  	r10 >>= (int)r9;  	long r31C8 = clusters = (uint)r10;  	if (r10 > r8) {  		throw TooManyClusters;  	}  	Console.WriteLine (Partition.Offset.ToString ("X") + " Clusters " + r10.ToString ("X"));  	fatsize = r11;  	Console.WriteLine ("r11 " + r11.ToString ("X"));  	r11 += r25;  	Console.WriteLine ("r11 " + r11.ToString ("X"));  	long r31D4 = r25;  	r10 = r25 & 0xFFF;  	Console.WriteLine ("r25 " + r25.ToString ("X") + "\r\nr10 " + r10.ToString ("X"));  	r11 &= 0xFFF;  	Console.WriteLine ("r11 " + r11.ToString ("X"));  	//fatsize = r11.UpToNearestCluster(r31CC);  	r11 = r31CC;  	Console.WriteLine ("r11 " + r11.ToString ("X"));  	r11 &= 0xFFF;  	Console.WriteLine ("r11 " + r11.ToString ("X"));  }  
Magic Number,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ProcessBootSector,The following statement contains a magic number: if ((uint)r9 == Magic ()) {  	// Read sectors per cluster  	r11 = SectorsPerCluster ();  	if (r11 == 0) {  		throw InvalidSectorsPerCluster;  		return;  	}  	if (!(r11 <= 2) && (r11 != 0x4) && (r11 != 0x8) && (r11 != 0x20) && (r11 != 0x40) && (r11 != 0x80)) {  		throw InvalidSectorsPerCluster;  	}  	r9 = 9;  	// 9 because 0x1000 / 8 = 0x200' 0x200 = sector size  	// Shift  	r11 = r11 << (int)r9;  	// cluster size  	long r31CC = r11;  	if (r11 == 0) {  		// what  		r11 = 0;  		//r30;  	}  	else// Usually branches here  	 {  		r11 = cntlzw ((uint)r11);  		r11 = 0x1F - r11;  	}  	long r31D1 = r11;  	if (r26 != 0)// Usually skips this  	 {  		r11 = r31CC;  		if (r11 != 0x4000) {  			throw InvalidBytesPerSector;  		}  	}  	r11 = PartitionID ();  	long r31160 = r11;  	r3 = SP50;  	// becomes pointer to FATX partition  	long r27 = RootDirectoryCluster ();  	// FscUnmapBuffer  	SP50 = r30;  	r11 = r31CC;  	if (r11 < r29) {  		throw TooSmallClusterSize;  	}  	r9 = (byte)r31D1;  	r11 = r28;  	r11 = (r11 >> (int)r9);  	r11++;  	// Entry size?  	if (r11 < 0x0000FFF0 && r26 == 0) {  		// Should branch here  		r10 = 1;  		r11 = ((long)r11 << 1);  	}  	else if (r11 >= 0x0000FFF0) {  		r10 = 2;  		r11 = ((long)r11 << 2);  	}  	r11 += r29;  	long r31D2 = r10;  	long r8 = r29 - 1;  	r10 = (long)r28;  	r11--;  	r10 = r10 - r25;  	// And with complement  	r11 = r11 & ~r8;  	r11 &= 0xFFFFFFFF;  	if (r11 >= r10) {  		throw VolumeTooSmall;  	}  	r10 -= r11;  	r9 &= 0xFFFFFFFFFFFFFF;  	r8 = 0x000000000FFFFFFF;  	r10 >>= (int)r9;  	long r31C8 = clusters = (uint)r10;  	if (r10 > r8) {  		throw TooManyClusters;  	}  	Console.WriteLine (Partition.Offset.ToString ("X") + " Clusters " + r10.ToString ("X"));  	fatsize = r11;  	Console.WriteLine ("r11 " + r11.ToString ("X"));  	r11 += r25;  	Console.WriteLine ("r11 " + r11.ToString ("X"));  	long r31D4 = r25;  	r10 = r25 & 0xFFF;  	Console.WriteLine ("r25 " + r25.ToString ("X") + "\r\nr10 " + r10.ToString ("X"));  	r11 &= 0xFFF;  	Console.WriteLine ("r11 " + r11.ToString ("X"));  	//fatsize = r11.UpToNearestCluster(r31CC);  	r11 = r31CC;  	Console.WriteLine ("r11 " + r11.ToString ("X"));  	r11 &= 0xFFF;  	Console.WriteLine ("r11 " + r11.ToString ("X"));  }  
Magic Number,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ProcessBootSector,The following statement contains a magic number: if ((uint)r9 == Magic ()) {  	// Read sectors per cluster  	r11 = SectorsPerCluster ();  	if (r11 == 0) {  		throw InvalidSectorsPerCluster;  		return;  	}  	if (!(r11 <= 2) && (r11 != 0x4) && (r11 != 0x8) && (r11 != 0x20) && (r11 != 0x40) && (r11 != 0x80)) {  		throw InvalidSectorsPerCluster;  	}  	r9 = 9;  	// 9 because 0x1000 / 8 = 0x200' 0x200 = sector size  	// Shift  	r11 = r11 << (int)r9;  	// cluster size  	long r31CC = r11;  	if (r11 == 0) {  		// what  		r11 = 0;  		//r30;  	}  	else// Usually branches here  	 {  		r11 = cntlzw ((uint)r11);  		r11 = 0x1F - r11;  	}  	long r31D1 = r11;  	if (r26 != 0)// Usually skips this  	 {  		r11 = r31CC;  		if (r11 != 0x4000) {  			throw InvalidBytesPerSector;  		}  	}  	r11 = PartitionID ();  	long r31160 = r11;  	r3 = SP50;  	// becomes pointer to FATX partition  	long r27 = RootDirectoryCluster ();  	// FscUnmapBuffer  	SP50 = r30;  	r11 = r31CC;  	if (r11 < r29) {  		throw TooSmallClusterSize;  	}  	r9 = (byte)r31D1;  	r11 = r28;  	r11 = (r11 >> (int)r9);  	r11++;  	// Entry size?  	if (r11 < 0x0000FFF0 && r26 == 0) {  		// Should branch here  		r10 = 1;  		r11 = ((long)r11 << 1);  	}  	else if (r11 >= 0x0000FFF0) {  		r10 = 2;  		r11 = ((long)r11 << 2);  	}  	r11 += r29;  	long r31D2 = r10;  	long r8 = r29 - 1;  	r10 = (long)r28;  	r11--;  	r10 = r10 - r25;  	// And with complement  	r11 = r11 & ~r8;  	r11 &= 0xFFFFFFFF;  	if (r11 >= r10) {  		throw VolumeTooSmall;  	}  	r10 -= r11;  	r9 &= 0xFFFFFFFFFFFFFF;  	r8 = 0x000000000FFFFFFF;  	r10 >>= (int)r9;  	long r31C8 = clusters = (uint)r10;  	if (r10 > r8) {  		throw TooManyClusters;  	}  	Console.WriteLine (Partition.Offset.ToString ("X") + " Clusters " + r10.ToString ("X"));  	fatsize = r11;  	Console.WriteLine ("r11 " + r11.ToString ("X"));  	r11 += r25;  	Console.WriteLine ("r11 " + r11.ToString ("X"));  	long r31D4 = r25;  	r10 = r25 & 0xFFF;  	Console.WriteLine ("r25 " + r25.ToString ("X") + "\r\nr10 " + r10.ToString ("X"));  	r11 &= 0xFFF;  	Console.WriteLine ("r11 " + r11.ToString ("X"));  	//fatsize = r11.UpToNearestCluster(r31CC);  	r11 = r31CC;  	Console.WriteLine ("r11 " + r11.ToString ("X"));  	r11 &= 0xFFF;  	Console.WriteLine ("r11 " + r11.ToString ("X"));  }  
Magic Number,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ProcessBootSector,The following statement contains a magic number: if (!(r11 <= 2) && (r11 != 0x4) && (r11 != 0x8) && (r11 != 0x20) && (r11 != 0x40) && (r11 != 0x80)) {  	throw InvalidSectorsPerCluster;  }  
Magic Number,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ProcessBootSector,The following statement contains a magic number: r9 = 9;  
Magic Number,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ProcessBootSector,The following statement contains a magic number: if (r11 < 0x0000FFF0 && r26 == 0) {  	// Should branch here  	r10 = 1;  	r11 = ((long)r11 << 1);  }  else if (r11 >= 0x0000FFF0) {  	r10 = 2;  	r11 = ((long)r11 << 2);  }  
Magic Number,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ProcessBootSector,The following statement contains a magic number: if (r11 < 0x0000FFF0 && r26 == 0) {  	// Should branch here  	r10 = 1;  	r11 = ((long)r11 << 1);  }  else if (r11 >= 0x0000FFF0) {  	r10 = 2;  	r11 = ((long)r11 << 2);  }  
Magic Number,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ProcessBootSector,The following statement contains a magic number: if (r11 >= 0x0000FFF0) {  	r10 = 2;  	r11 = ((long)r11 << 2);  }  
Magic Number,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ProcessBootSector,The following statement contains a magic number: if (r11 >= 0x0000FFF0) {  	r10 = 2;  	r11 = ((long)r11 << 2);  }  
Magic Number,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ProcessBootSector,The following statement contains a magic number: r10 = 2;  
Magic Number,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ProcessBootSector,The following statement contains a magic number: r11 = ((long)r11 << 2);  
Magic Number,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,GetFreeSpace,The following statement contains a magic number: for (long dick = io.BaseStream.Position; dick < toBeLessThan; dick += 0x200) {  	bool BreakAndShit = false;  	// Set the position  	io.BaseStream.Position = dick;  	// Read our buffer  	byte[] Buffer = null;  	if ((dick - FATOffset).DownToNearest200 () == (toBeLessThan - FATOffset).DownToNearest200 ()) {  		byte[] Temp = io.ReadBytes (0x200);  		Buffer = new byte[(toBeLessThan - FATOffset) - (dick - FATOffset).DownToNearest200 ()];  		Array.Copy (Temp' 0' Buffer' 0' Buffer.Length);  	}  	else {  		Buffer = io.ReadBytes (0x200);  	}  	// Length to loop for (used for the end so we can read ONLY usable partitions)  	long Length = Buffer.Length;  	if (dick == VariousFunctions.DownToNearest200 (toBeLessThan)) {  		Length = toBeLessThan - VariousFunctions.DownToNearest200 (toBeLessThan);  		BreakAndShit = true;  	}  	// Check the values  	Streams.Reader ioya = new Streams.Reader (new System.IO.MemoryStream (Buffer));  	for (int i = 0; i < Length; i += EntrySize) {  		// This size will be off by a few megabytes' no big deal in my opinion  		if (EntrySize == 2) {  			ushort Value = ioya.ReadUInt16 ();  			if (Value == 0) {  				Return += ClusterSize;  			}  		}  		else {  			if (ioya.ReadUInt32 () == 0) {  				Return += ClusterSize;  			}  		}  	}  	ioya.Close ();  	if (BreakAndShit) {  		break;  	}  }  
Magic Number,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,GetFreeSpace,The following statement contains a magic number: for (int i = 0; i < Length; i += EntrySize) {  	// This size will be off by a few megabytes' no big deal in my opinion  	if (EntrySize == 2) {  		ushort Value = ioya.ReadUInt16 ();  		if (Value == 0) {  			Return += ClusterSize;  		}  	}  	else {  		if (ioya.ReadUInt32 () == 0) {  			Return += ClusterSize;  		}  	}  }  
Magic Number,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,GetFreeSpace,The following statement contains a magic number: if (EntrySize == 2) {  	ushort Value = ioya.ReadUInt16 ();  	if (Value == 0) {  		Return += ClusterSize;  	}  }  else {  	if (ioya.ReadUInt32 () == 0) {  		Return += ClusterSize;  	}  }  
Magic Number,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,GetEntries,The following statement contains a magic number: for (int i = 0; i < Entries.Length; i++) {  	EntryData newEdata = Entries [i];  	bool Deleted = false;  	if (newEdata.NameSize == 0xE5) {  		// Remove the question marks and shit  		try {  			newEdata.Name = newEdata.Name.Remove (newEdata.Name.IndexOf ('?'));  			newEdata.NameSize = (byte)newEdata.Name.Length;  		}  		catch {  			newEdata.NameSize = 0x2A;  		}  		Deleted = true;  	}  	List<Geometry.Flags> FL = new List<Geometry.Flags> ();  	// Read bit zero' mask the rest of that shit  	for (short s = 1' j = 0; s <= 80; s <<= 1' j++) {  		if (((newEdata.Flags & s) >> j) == 1) {  			FL.Add ((Geometry.Flags)Enum.Parse (typeof(Geometry.Flags)' Enum.GetName (typeof(Geometry.Flags)' j)));  		}  	}  	// Folder  	if (newEdata.StartingCluster != 0 && newEdata.Size == 0 && FL.Contains (Geometry.Flags.Directory)) {  		Folder f = new Folder (Parent.PartitionInfo' newEdata' Parent.Drive);  		f.FullPath = Parent.FullPath + "\\" + f.Name;  		f.Parent = Parent;  		if (Deleted) {  			f.IsDeleted = true;  			cachedDeletedFolders.Add (f);  		}  		else {  			cachedFolders.Add (f);  		}  	}  	// File  	else {  		File f = new File (Parent.PartitionInfo' newEdata' Parent.Drive);  		f.FullPath = Parent.FullPath + "\\" + f.Name;  		f.Parent = Parent;  		if (Deleted) {  			f.IsDeleted = true;  			cachedDeletedFiles.Add (f);  		}  		else {  			cachedFiles.Add (f);  		}  	}  }  
Magic Number,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,GetEntries,The following statement contains a magic number: for (short s = 1' j = 0; s <= 80; s <<= 1' j++) {  	if (((newEdata.Flags & s) >> j) == 1) {  		FL.Add ((Geometry.Flags)Enum.Parse (typeof(Geometry.Flags)' Enum.GetName (typeof(Geometry.Flags)' j)));  	}  }  
Magic Number,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,EntryDataFromBlock,The following statement contains a magic number: for (int j = 0; j < Parent.PartitionInfo.ClusterSize / 0x1000; j++) {  	// Increment our position  	// Open another reader using a memory stream  	long r1Position = r1.BaseStream.Position;  	Streams.Reader r = new CLKsFATXLib.Streams.Reader (new System.IO.MemoryStream (r1.ReadBytes (0x1000)));  	for (int k = 0; k < (0x1000 / 0x40); k++) {  		// Check to see if we've passed the last entry...  		uint val = r.ReadUInt32 ();  		if (val == 0x0 || val == 0xFFFFFFFF) {  			Break = true;  			break;  		}  		// Go back four bytes because we just checked the next four...  		r.BaseStream.Position -= 4;  		long StartOffset = r.BaseStream.Position;  		EntryData e = new EntryData ();  		e.EntryOffset = r.BaseStream.Position + r1Position;  		e.NameSize = r.ReadByte ();  		e.Flags = r.ReadByte ();  		/* Because some fucking smart guy decided to put the                      * deleted flag in the name size field' we have to check                      * if it's deleted or not...*/if (e.NameSize == 0xE5) {  			// Fuckers  			e.Name = Encoding.ASCII.GetString (r.ReadBytes (0x2A));  		}  		else {  			e.Name = Encoding.ASCII.GetString (r.ReadBytes (e.NameSize));  		}  		r.BaseStream.Position = StartOffset + 0x2C;  		e.StartingCluster = r.ReadUInt32 ();  		e.Size = r.ReadUInt32 ();  		e.CreationDate = r.ReadUInt16 ();  		e.CreationTime = r.ReadUInt16 ();  		e.AccessDate = r.ReadUInt16 ();  		e.AccessTime = r.ReadUInt16 ();  		e.ModifiedDate = r.ReadUInt16 ();  		e.ModifiedTime = r.ReadUInt16 ();  		eList.Add (e);  	}  	r.Close ();  	if (Break) {  		break;  	}  }  
Magic Number,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,EntryDataFromBlock,The following statement contains a magic number: for (int k = 0; k < (0x1000 / 0x40); k++) {  	// Check to see if we've passed the last entry...  	uint val = r.ReadUInt32 ();  	if (val == 0x0 || val == 0xFFFFFFFF) {  		Break = true;  		break;  	}  	// Go back four bytes because we just checked the next four...  	r.BaseStream.Position -= 4;  	long StartOffset = r.BaseStream.Position;  	EntryData e = new EntryData ();  	e.EntryOffset = r.BaseStream.Position + r1Position;  	e.NameSize = r.ReadByte ();  	e.Flags = r.ReadByte ();  	/* Because some fucking smart guy decided to put the                      * deleted flag in the name size field' we have to check                      * if it's deleted or not...*/if (e.NameSize == 0xE5) {  		// Fuckers  		e.Name = Encoding.ASCII.GetString (r.ReadBytes (0x2A));  	}  	else {  		e.Name = Encoding.ASCII.GetString (r.ReadBytes (e.NameSize));  	}  	r.BaseStream.Position = StartOffset + 0x2C;  	e.StartingCluster = r.ReadUInt32 ();  	e.Size = r.ReadUInt32 ();  	e.CreationDate = r.ReadUInt16 ();  	e.CreationTime = r.ReadUInt16 ();  	e.AccessDate = r.ReadUInt16 ();  	e.AccessTime = r.ReadUInt16 ();  	e.ModifiedDate = r.ReadUInt16 ();  	e.ModifiedTime = r.ReadUInt16 ();  	eList.Add (e);  }  
Magic Number,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,EntryDataFromBlock,The following statement contains a magic number: r.BaseStream.Position -= 4;  
Magic Number,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,GetBlocksOccupied,The following statement contains a magic number: for (int i = 0; i < Blocks.Count; i++) {  	r.BaseStream.Position = VariousFunctions.BlockToFATOffset (Blocks [i]' Parent).DownToNearestCluster (0x1000);  	// We use this so that we aren't reading the same buffer  	// a zillion times  	if (r.BaseStream.Position != lastoffset) {  		lastoffset = r.BaseStream.Position;  		Buffer = r.ReadBytes (buffersize);  	}  	Streams.Reader r1 = new CLKsFATXLib.Streams.Reader (new System.IO.MemoryStream (Buffer));  	int OffsetInBuffer = (int)(VariousFunctions.BlockToFATOffset (Blocks [i]' Parent) - VariousFunctions.BlockToFATOffset (Blocks [i]' Parent).DownToNearestCluster (0x1000));  	r1.BaseStream.Position = OffsetInBuffer;  	switch (Parent.PartitionInfo.EntrySize) {  	case 2:  		ushort Value = r1.ReadUInt16 ();  		if (Value != 0xFFFF && Value != 0xFFF8) {  			if (Value == 0) {  				throw new Exception ("Bad FAT chain in file or folder " + Parent.FullPath + "\r\nEntry Offset: 0x" + Parent.EntryOffset.ToString ("X"));  			}  			Blocks.Add (Value);  		}  		break;  	case 4:  		uint Value2 = r1.ReadUInt32 ();  		if (Value2 != 0xFFFFFFFF && Value2 != 0xFFFFFFF8) {  			if (Value2 == 0) {  				throw new Exception ("Bad FAT chain in file or folder " + Parent.FullPath + "\r\nEntry Offset: 0x" + Parent.EntryOffset.ToString ("X"));  			}  			Blocks.Add (Value2);  		}  		break;  	}  	r1.Close ();  }  
Magic Number,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,GetBlocksOccupied,The following statement contains a magic number: for (int i = 0; i < Blocks.Count; i++) {  	r.BaseStream.Position = VariousFunctions.BlockToFATOffset (Blocks [i]' Parent).DownToNearestCluster (0x1000);  	// We use this so that we aren't reading the same buffer  	// a zillion times  	if (r.BaseStream.Position != lastoffset) {  		lastoffset = r.BaseStream.Position;  		Buffer = r.ReadBytes (buffersize);  	}  	Streams.Reader r1 = new CLKsFATXLib.Streams.Reader (new System.IO.MemoryStream (Buffer));  	int OffsetInBuffer = (int)(VariousFunctions.BlockToFATOffset (Blocks [i]' Parent) - VariousFunctions.BlockToFATOffset (Blocks [i]' Parent).DownToNearestCluster (0x1000));  	r1.BaseStream.Position = OffsetInBuffer;  	switch (Parent.PartitionInfo.EntrySize) {  	case 2:  		ushort Value = r1.ReadUInt16 ();  		if (Value != 0xFFFF && Value != 0xFFF8) {  			if (Value == 0) {  				throw new Exception ("Bad FAT chain in file or folder " + Parent.FullPath + "\r\nEntry Offset: 0x" + Parent.EntryOffset.ToString ("X"));  			}  			Blocks.Add (Value);  		}  		break;  	case 4:  		uint Value2 = r1.ReadUInt32 ();  		if (Value2 != 0xFFFFFFFF && Value2 != 0xFFFFFFF8) {  			if (Value2 == 0) {  				throw new Exception ("Bad FAT chain in file or folder " + Parent.FullPath + "\r\nEntry Offset: 0x" + Parent.EntryOffset.ToString ("X"));  			}  			Blocks.Add (Value2);  		}  		break;  	}  	r1.Close ();  }  
Magic Number,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,GetBlocksOccupied,The following statement contains a magic number: switch (Parent.PartitionInfo.EntrySize) {  case 2:  	ushort Value = r1.ReadUInt16 ();  	if (Value != 0xFFFF && Value != 0xFFF8) {  		if (Value == 0) {  			throw new Exception ("Bad FAT chain in file or folder " + Parent.FullPath + "\r\nEntry Offset: 0x" + Parent.EntryOffset.ToString ("X"));  		}  		Blocks.Add (Value);  	}  	break;  case 4:  	uint Value2 = r1.ReadUInt32 ();  	if (Value2 != 0xFFFFFFFF && Value2 != 0xFFFFFFF8) {  		if (Value2 == 0) {  			throw new Exception ("Bad FAT chain in file or folder " + Parent.FullPath + "\r\nEntry Offset: 0x" + Parent.EntryOffset.ToString ("X"));  		}  		Blocks.Add (Value2);  	}  	break;  }  
Magic Number,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,GetBlocksOccupied,The following statement contains a magic number: switch (Parent.PartitionInfo.EntrySize) {  case 2:  	ushort Value = r1.ReadUInt16 ();  	if (Value != 0xFFFF && Value != 0xFFF8) {  		if (Value == 0) {  			throw new Exception ("Bad FAT chain in file or folder " + Parent.FullPath + "\r\nEntry Offset: 0x" + Parent.EntryOffset.ToString ("X"));  		}  		Blocks.Add (Value);  	}  	break;  case 4:  	uint Value2 = r1.ReadUInt32 ();  	if (Value2 != 0xFFFFFFFF && Value2 != 0xFFFFFFF8) {  		if (Value2 == 0) {  			throw new Exception ("Bad FAT chain in file or folder " + Parent.FullPath + "\r\nEntry Offset: 0x" + Parent.EntryOffset.ToString ("X"));  		}  		Blocks.Add (Value2);  	}  	break;  }  
Magic Number,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,WriteFATChain,The following statement contains a magic number: for (int i = 0; i < Chain.Length; i++) {  	// Read the chain buffer  	if (lastoffset != VariousFunctions.BlockToFATOffset (Chain [i]' Parent).DownToNearestCluster (0x1000)) {  		if (i != 0) {  			w.BaseStream.Position = lastoffset;  			w.Write (Buffer);  		}  		lastoffset = VariousFunctions.BlockToFATOffset (Chain [i]' Parent).DownToNearestCluster (0x1000);  		r.BaseStream.Position = lastoffset;  		Buffer = r.ReadBytes ((int)buffersize);  	}  	// Write the chain  	Streams.Writer mem = new CLKsFATXLib.Streams.Writer (new System.IO.MemoryStream (Buffer));  	mem.BaseStream.Position = VariousFunctions.BlockToFATOffset (Chain [i]' Parent) - VariousFunctions.BlockToFATOffset (Chain [i]' Parent).DownToNearestCluster (0x1000);  	byte[] writing = new byte[0];  	switch (Parent.PartitionInfo.EntrySize) {  	case 2:  		if (i != Chain.Length - 1) {  			writing = BitConverter.GetBytes ((ushort)Chain [i + 1]);  		}  		else {  			writing = BitConverter.GetBytes ((ushort)0xFFFF);  		}  		break;  	case 4:  		if (i != Chain.Length - 1) {  			writing = BitConverter.GetBytes (Chain [i + 1]);  		}  		else {  			writing = BitConverter.GetBytes (0xFFFFFFFF);  		}  		break;  	}  	Array.Reverse (writing);  	mem.Write (writing);  	mem.Close ();  	if (i == Chain.Length - 1) {  		w.BaseStream.Position = lastoffset;  		w.Write (Buffer);  	}  }  
Magic Number,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,WriteFATChain,The following statement contains a magic number: for (int i = 0; i < Chain.Length; i++) {  	// Read the chain buffer  	if (lastoffset != VariousFunctions.BlockToFATOffset (Chain [i]' Parent).DownToNearestCluster (0x1000)) {  		if (i != 0) {  			w.BaseStream.Position = lastoffset;  			w.Write (Buffer);  		}  		lastoffset = VariousFunctions.BlockToFATOffset (Chain [i]' Parent).DownToNearestCluster (0x1000);  		r.BaseStream.Position = lastoffset;  		Buffer = r.ReadBytes ((int)buffersize);  	}  	// Write the chain  	Streams.Writer mem = new CLKsFATXLib.Streams.Writer (new System.IO.MemoryStream (Buffer));  	mem.BaseStream.Position = VariousFunctions.BlockToFATOffset (Chain [i]' Parent) - VariousFunctions.BlockToFATOffset (Chain [i]' Parent).DownToNearestCluster (0x1000);  	byte[] writing = new byte[0];  	switch (Parent.PartitionInfo.EntrySize) {  	case 2:  		if (i != Chain.Length - 1) {  			writing = BitConverter.GetBytes ((ushort)Chain [i + 1]);  		}  		else {  			writing = BitConverter.GetBytes ((ushort)0xFFFF);  		}  		break;  	case 4:  		if (i != Chain.Length - 1) {  			writing = BitConverter.GetBytes (Chain [i + 1]);  		}  		else {  			writing = BitConverter.GetBytes (0xFFFFFFFF);  		}  		break;  	}  	Array.Reverse (writing);  	mem.Write (writing);  	mem.Close ();  	if (i == Chain.Length - 1) {  		w.BaseStream.Position = lastoffset;  		w.Write (Buffer);  	}  }  
Magic Number,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,WriteFATChain,The following statement contains a magic number: switch (Parent.PartitionInfo.EntrySize) {  case 2:  	if (i != Chain.Length - 1) {  		writing = BitConverter.GetBytes ((ushort)Chain [i + 1]);  	}  	else {  		writing = BitConverter.GetBytes ((ushort)0xFFFF);  	}  	break;  case 4:  	if (i != Chain.Length - 1) {  		writing = BitConverter.GetBytes (Chain [i + 1]);  	}  	else {  		writing = BitConverter.GetBytes (0xFFFFFFFF);  	}  	break;  }  
Magic Number,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,WriteFATChain,The following statement contains a magic number: switch (Parent.PartitionInfo.EntrySize) {  case 2:  	if (i != Chain.Length - 1) {  		writing = BitConverter.GetBytes ((ushort)Chain [i + 1]);  	}  	else {  		writing = BitConverter.GetBytes ((ushort)0xFFFF);  	}  	break;  case 4:  	if (i != Chain.Length - 1) {  		writing = BitConverter.GetBytes (Chain [i + 1]);  	}  	else {  		writing = BitConverter.GetBytes (0xFFFFFFFF);  	}  	break;  }  
Magic Number,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ClearFATChain,The following statement contains a magic number: for (int i = 0; i < Chain.Length; i++) {  	// Read the chain buffer  	if (lastoffset != VariousFunctions.BlockToFATOffset (Chain [i]' Parent).DownToNearestCluster (0x1000)) {  		if (i != 0) {  			w.BaseStream.Position = lastoffset;  			w.Write (Buffer);  		}  		lastoffset = VariousFunctions.BlockToFATOffset (Chain [i]' Parent).DownToNearestCluster (0x1000);  		r.BaseStream.Position = lastoffset;  		Buffer = r.ReadBytes ((int)buffersize);  	}  	// Write the chain  	Streams.Writer mem = new CLKsFATXLib.Streams.Writer (new System.IO.MemoryStream (Buffer));  	mem.BaseStream.Position = VariousFunctions.BlockToFATOffset (Chain [i]' Parent) - VariousFunctions.BlockToFATOffset (Chain [i]' Parent).DownToNearestCluster (0x1000);  	byte[] writing = new byte[0];  	switch (Parent.PartitionInfo.EntrySize) {  	case 2:  		writing = BitConverter.GetBytes ((ushort)0);  		break;  	case 4:  		writing = BitConverter.GetBytes (0);  		break;  	}  	mem.Write (writing);  	mem.Close ();  	if (i == Chain.Length - 1) {  		w.BaseStream.Position = lastoffset;  		w.Write (Buffer);  	}  }  
Magic Number,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ClearFATChain,The following statement contains a magic number: for (int i = 0; i < Chain.Length; i++) {  	// Read the chain buffer  	if (lastoffset != VariousFunctions.BlockToFATOffset (Chain [i]' Parent).DownToNearestCluster (0x1000)) {  		if (i != 0) {  			w.BaseStream.Position = lastoffset;  			w.Write (Buffer);  		}  		lastoffset = VariousFunctions.BlockToFATOffset (Chain [i]' Parent).DownToNearestCluster (0x1000);  		r.BaseStream.Position = lastoffset;  		Buffer = r.ReadBytes ((int)buffersize);  	}  	// Write the chain  	Streams.Writer mem = new CLKsFATXLib.Streams.Writer (new System.IO.MemoryStream (Buffer));  	mem.BaseStream.Position = VariousFunctions.BlockToFATOffset (Chain [i]' Parent) - VariousFunctions.BlockToFATOffset (Chain [i]' Parent).DownToNearestCluster (0x1000);  	byte[] writing = new byte[0];  	switch (Parent.PartitionInfo.EntrySize) {  	case 2:  		writing = BitConverter.GetBytes ((ushort)0);  		break;  	case 4:  		writing = BitConverter.GetBytes (0);  		break;  	}  	mem.Write (writing);  	mem.Close ();  	if (i == Chain.Length - 1) {  		w.BaseStream.Position = lastoffset;  		w.Write (Buffer);  	}  }  
Magic Number,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ClearFATChain,The following statement contains a magic number: switch (Parent.PartitionInfo.EntrySize) {  case 2:  	writing = BitConverter.GetBytes ((ushort)0);  	break;  case 4:  	writing = BitConverter.GetBytes (0);  	break;  }  
Magic Number,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ClearFATChain,The following statement contains a magic number: switch (Parent.PartitionInfo.EntrySize) {  case 2:  	writing = BitConverter.GetBytes ((ushort)0);  	break;  case 4:  	writing = BitConverter.GetBytes (0);  	break;  }  
Magic Number,CLKsFATXLib,StartHere,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,GetFATXDrives,The following statement contains a magic number: foreach (string s in Environment.GetLogicalDrives ().Where (drive => System.IO.Directory.Exists (drive + "\\Xbox360"))) {  	List<string> filePaths = new List<string> ();  	for (int i = 0; i < 10000; i++) {  		string extra = "";  		if (i < 10) {  			extra = "000";  		}  		else if (i < 100) {  			extra = "00";  		}  		else if (i < 1000) {  			extra = "0";  		}  		if (System.IO.File.Exists (s + "\\Xbox360\\Data" + extra + i.ToString ())) {  			filePaths.Add (s + "\\Xbox360\\Data" + extra + i.ToString ());  		}  		else {  			break;  		}  	}  	if (filePaths.Count >= 3 && !IsLocked (filePaths [0])) {  		Drive d = new Drive (filePaths.ToArray ());  		dL.Add (d);  	}  }  
Magic Number,CLKsFATXLib,StartHere,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,GetFATXDrives,The following statement contains a magic number: foreach (string s in Environment.GetLogicalDrives ().Where (drive => System.IO.Directory.Exists (drive + "\\Xbox360"))) {  	List<string> filePaths = new List<string> ();  	for (int i = 0; i < 10000; i++) {  		string extra = "";  		if (i < 10) {  			extra = "000";  		}  		else if (i < 100) {  			extra = "00";  		}  		else if (i < 1000) {  			extra = "0";  		}  		if (System.IO.File.Exists (s + "\\Xbox360\\Data" + extra + i.ToString ())) {  			filePaths.Add (s + "\\Xbox360\\Data" + extra + i.ToString ());  		}  		else {  			break;  		}  	}  	if (filePaths.Count >= 3 && !IsLocked (filePaths [0])) {  		Drive d = new Drive (filePaths.ToArray ());  		dL.Add (d);  	}  }  
Magic Number,CLKsFATXLib,StartHere,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,GetFATXDrives,The following statement contains a magic number: foreach (string s in Environment.GetLogicalDrives ().Where (drive => System.IO.Directory.Exists (drive + "\\Xbox360"))) {  	List<string> filePaths = new List<string> ();  	for (int i = 0; i < 10000; i++) {  		string extra = "";  		if (i < 10) {  			extra = "000";  		}  		else if (i < 100) {  			extra = "00";  		}  		else if (i < 1000) {  			extra = "0";  		}  		if (System.IO.File.Exists (s + "\\Xbox360\\Data" + extra + i.ToString ())) {  			filePaths.Add (s + "\\Xbox360\\Data" + extra + i.ToString ());  		}  		else {  			break;  		}  	}  	if (filePaths.Count >= 3 && !IsLocked (filePaths [0])) {  		Drive d = new Drive (filePaths.ToArray ());  		dL.Add (d);  	}  }  
Magic Number,CLKsFATXLib,StartHere,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,GetFATXDrives,The following statement contains a magic number: foreach (string s in Environment.GetLogicalDrives ().Where (drive => System.IO.Directory.Exists (drive + "\\Xbox360"))) {  	List<string> filePaths = new List<string> ();  	for (int i = 0; i < 10000; i++) {  		string extra = "";  		if (i < 10) {  			extra = "000";  		}  		else if (i < 100) {  			extra = "00";  		}  		else if (i < 1000) {  			extra = "0";  		}  		if (System.IO.File.Exists (s + "\\Xbox360\\Data" + extra + i.ToString ())) {  			filePaths.Add (s + "\\Xbox360\\Data" + extra + i.ToString ());  		}  		else {  			break;  		}  	}  	if (filePaths.Count >= 3 && !IsLocked (filePaths [0])) {  		Drive d = new Drive (filePaths.ToArray ());  		dL.Add (d);  	}  }  
Magic Number,CLKsFATXLib,StartHere,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,GetFATXDrives,The following statement contains a magic number: foreach (string s in Environment.GetLogicalDrives ().Where (drive => System.IO.Directory.Exists (drive + "\\Xbox360"))) {  	List<string> filePaths = new List<string> ();  	for (int i = 0; i < 10000; i++) {  		string extra = "";  		if (i < 10) {  			extra = "000";  		}  		else if (i < 100) {  			extra = "00";  		}  		else if (i < 1000) {  			extra = "0";  		}  		if (System.IO.File.Exists (s + "\\Xbox360\\Data" + extra + i.ToString ())) {  			filePaths.Add (s + "\\Xbox360\\Data" + extra + i.ToString ());  		}  		else {  			break;  		}  	}  	if (filePaths.Count >= 3 && !IsLocked (filePaths [0])) {  		Drive d = new Drive (filePaths.ToArray ());  		dL.Add (d);  	}  }  
Magic Number,CLKsFATXLib,StartHere,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,GetFATXDrives,The following statement contains a magic number: for (int i = 0; i < 10000; i++) {  	string extra = "";  	if (i < 10) {  		extra = "000";  	}  	else if (i < 100) {  		extra = "00";  	}  	else if (i < 1000) {  		extra = "0";  	}  	if (System.IO.File.Exists (s + "\\Xbox360\\Data" + extra + i.ToString ())) {  		filePaths.Add (s + "\\Xbox360\\Data" + extra + i.ToString ());  	}  	else {  		break;  	}  }  
Magic Number,CLKsFATXLib,StartHere,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,GetFATXDrives,The following statement contains a magic number: for (int i = 0; i < 10000; i++) {  	string extra = "";  	if (i < 10) {  		extra = "000";  	}  	else if (i < 100) {  		extra = "00";  	}  	else if (i < 1000) {  		extra = "0";  	}  	if (System.IO.File.Exists (s + "\\Xbox360\\Data" + extra + i.ToString ())) {  		filePaths.Add (s + "\\Xbox360\\Data" + extra + i.ToString ());  	}  	else {  		break;  	}  }  
Magic Number,CLKsFATXLib,StartHere,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,GetFATXDrives,The following statement contains a magic number: for (int i = 0; i < 10000; i++) {  	string extra = "";  	if (i < 10) {  		extra = "000";  	}  	else if (i < 100) {  		extra = "00";  	}  	else if (i < 1000) {  		extra = "0";  	}  	if (System.IO.File.Exists (s + "\\Xbox360\\Data" + extra + i.ToString ())) {  		filePaths.Add (s + "\\Xbox360\\Data" + extra + i.ToString ());  	}  	else {  		break;  	}  }  
Magic Number,CLKsFATXLib,StartHere,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,GetFATXDrives,The following statement contains a magic number: for (int i = 0; i < 10000; i++) {  	string extra = "";  	if (i < 10) {  		extra = "000";  	}  	else if (i < 100) {  		extra = "00";  	}  	else if (i < 1000) {  		extra = "0";  	}  	if (System.IO.File.Exists (s + "\\Xbox360\\Data" + extra + i.ToString ())) {  		filePaths.Add (s + "\\Xbox360\\Data" + extra + i.ToString ());  	}  	else {  		break;  	}  }  
Magic Number,CLKsFATXLib,StartHere,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,GetFATXDrives,The following statement contains a magic number: if (i < 10) {  	extra = "000";  }  else if (i < 100) {  	extra = "00";  }  else if (i < 1000) {  	extra = "0";  }  
Magic Number,CLKsFATXLib,StartHere,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,GetFATXDrives,The following statement contains a magic number: if (i < 10) {  	extra = "000";  }  else if (i < 100) {  	extra = "00";  }  else if (i < 1000) {  	extra = "0";  }  
Magic Number,CLKsFATXLib,StartHere,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,GetFATXDrives,The following statement contains a magic number: if (i < 10) {  	extra = "000";  }  else if (i < 100) {  	extra = "00";  }  else if (i < 1000) {  	extra = "0";  }  
Magic Number,CLKsFATXLib,StartHere,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,GetFATXDrives,The following statement contains a magic number: if (i < 100) {  	extra = "00";  }  else if (i < 1000) {  	extra = "0";  }  
Magic Number,CLKsFATXLib,StartHere,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,GetFATXDrives,The following statement contains a magic number: if (i < 100) {  	extra = "00";  }  else if (i < 1000) {  	extra = "0";  }  
Magic Number,CLKsFATXLib,StartHere,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,GetFATXDrives,The following statement contains a magic number: if (i < 1000) {  	extra = "0";  }  
Magic Number,CLKsFATXLib,StartHere,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,GetFATXDrives,The following statement contains a magic number: if (filePaths.Count >= 3 && !IsLocked (filePaths [0])) {  	Drive d = new Drive (filePaths.ToArray ());  	dL.Add (d);  }  
Magic Number,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,IsTitleIDFolder,The following statement contains a magic number: if (Name.Length != 8) {  	return false;  }  
Magic Number,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,UpToNearestGigabyte,The following statement contains a magic number: if (valToAdd == 1073741824) {  	return (int)(val / 1073741824);  }  
Magic Number,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,UpToNearestGigabyte,The following statement contains a magic number: if (valToAdd == 1073741824) {  	return (int)(val / 1073741824);  }  
Magic Number,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,UpToNearestGigabyte,The following statement contains a magic number: return (int)(val / 1073741824);  
Magic Number,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,UpToNearestGigabyte,The following statement contains a magic number: return (int)((val + valToAdd) / 1073741824);  
Magic Number,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,DateTimeToFATInt,The following statement contains a magic number: if (OurDateTime.Year < 1980) {  	OurDateTime = new DateTime (1980' OurDateTime.Month' OurDateTime.Day' OurDateTime.Hour' OurDateTime.Minute' OurDateTime.Second);  }  
Magic Number,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,DateTimeToFATInt,The following statement contains a magic number: if (OurDateTime.Year < 1980) {  	OurDateTime = new DateTime (1980' OurDateTime.Month' OurDateTime.Day' OurDateTime.Hour' OurDateTime.Minute' OurDateTime.Second);  }  
Magic Number,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,DateTimeToFATInt,The following statement contains a magic number: OurDateTime = new DateTime (1980' OurDateTime.Month' OurDateTime.Day' OurDateTime.Hour' OurDateTime.Minute' OurDateTime.Second);  
Magic Number,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,DateTimeToFATInt,The following statement contains a magic number: return ((Date << 16) | Time);  
Magic Number,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,DateTimeToFATShort,The following statement contains a magic number: if (OurDateTime.Year < 1980) {  	OurDateTime = new DateTime (1980' OurDateTime.Month' OurDateTime.Day' OurDateTime.Hour' OurDateTime.Minute' OurDateTime.Second);  }  
Magic Number,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,DateTimeToFATShort,The following statement contains a magic number: if (OurDateTime.Year < 1980) {  	OurDateTime = new DateTime (1980' OurDateTime.Month' OurDateTime.Day' OurDateTime.Hour' OurDateTime.Minute' OurDateTime.Second);  }  
Magic Number,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,DateTimeToFATShort,The following statement contains a magic number: OurDateTime = new DateTime (1980' OurDateTime.Month' OurDateTime.Day' OurDateTime.Hour' OurDateTime.Minute' OurDateTime.Second);  
Magic Number,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,DateTimeToFATShort,The following statement contains a magic number: if (Date) {  	return (ushort)((((ushort)OurDateTime.Year - 1980) << 9 | ((ushort)OurDateTime.Month << 5) | (ushort)OurDateTime.Day));  }  
Magic Number,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,DateTimeToFATShort,The following statement contains a magic number: if (Date) {  	return (ushort)((((ushort)OurDateTime.Year - 1980) << 9 | ((ushort)OurDateTime.Month << 5) | (ushort)OurDateTime.Day));  }  
Magic Number,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,DateTimeToFATShort,The following statement contains a magic number: if (Date) {  	return (ushort)((((ushort)OurDateTime.Year - 1980) << 9 | ((ushort)OurDateTime.Month << 5) | (ushort)OurDateTime.Day));  }  
Magic Number,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,DateTimeToFATShort,The following statement contains a magic number: return (ushort)((((ushort)OurDateTime.Year - 1980) << 9 | ((ushort)OurDateTime.Month << 5) | (ushort)OurDateTime.Day));  
Magic Number,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,DateTimeToFATShort,The following statement contains a magic number: return (ushort)((((ushort)OurDateTime.Year - 1980) << 9 | ((ushort)OurDateTime.Month << 5) | (ushort)OurDateTime.Day));  
Magic Number,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,DateTimeToFATShort,The following statement contains a magic number: return (ushort)((((ushort)OurDateTime.Year - 1980) << 9 | ((ushort)OurDateTime.Month << 5) | (ushort)OurDateTime.Day));  
Magic Number,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,DateTimeToFATShort,The following statement contains a magic number: return (ushort)((((ushort)OurDateTime.Hour << 11) | ((ushort)OurDateTime.Minute << 5) | ((ushort)OurDateTime.Second)));  
Magic Number,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,DateTimeToFATShort,The following statement contains a magic number: return (ushort)((((ushort)OurDateTime.Hour << 11) | ((ushort)OurDateTime.Minute << 5) | ((ushort)OurDateTime.Second)));  
Magic Number,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,DateTimeFromFATInt,The following statement contains a magic number: try {  	//If they're both zero' then we don't have a date.  	if (date == 0 && time == 0) {  		return DateTime.Now;  	}  	//We didn't return the date' so ye  	//We mask the upper 8 bits to get only bits 9-15' then shift them to the right 9 times to get the number  	//of years past 2000  	int year = ((date & 0xFE00) >> 9) + 1980;  	int month = (date & 0x1E0) >> 5;  	int day = (date & 0x1F);  	int hour = (time & 0xF800) >> 11;  	int minute = (time & 0x7E0) >> 5;  	int second = (time & 0x1F) * 2;  	return new DateTime (year' month' day' hour' minute' second);  }  catch {  	return DateTime.Now;  }  
Magic Number,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,DateTimeFromFATInt,The following statement contains a magic number: try {  	//If they're both zero' then we don't have a date.  	if (date == 0 && time == 0) {  		return DateTime.Now;  	}  	//We didn't return the date' so ye  	//We mask the upper 8 bits to get only bits 9-15' then shift them to the right 9 times to get the number  	//of years past 2000  	int year = ((date & 0xFE00) >> 9) + 1980;  	int month = (date & 0x1E0) >> 5;  	int day = (date & 0x1F);  	int hour = (time & 0xF800) >> 11;  	int minute = (time & 0x7E0) >> 5;  	int second = (time & 0x1F) * 2;  	return new DateTime (year' month' day' hour' minute' second);  }  catch {  	return DateTime.Now;  }  
Magic Number,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,DateTimeFromFATInt,The following statement contains a magic number: try {  	//If they're both zero' then we don't have a date.  	if (date == 0 && time == 0) {  		return DateTime.Now;  	}  	//We didn't return the date' so ye  	//We mask the upper 8 bits to get only bits 9-15' then shift them to the right 9 times to get the number  	//of years past 2000  	int year = ((date & 0xFE00) >> 9) + 1980;  	int month = (date & 0x1E0) >> 5;  	int day = (date & 0x1F);  	int hour = (time & 0xF800) >> 11;  	int minute = (time & 0x7E0) >> 5;  	int second = (time & 0x1F) * 2;  	return new DateTime (year' month' day' hour' minute' second);  }  catch {  	return DateTime.Now;  }  
Magic Number,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,DateTimeFromFATInt,The following statement contains a magic number: try {  	//If they're both zero' then we don't have a date.  	if (date == 0 && time == 0) {  		return DateTime.Now;  	}  	//We didn't return the date' so ye  	//We mask the upper 8 bits to get only bits 9-15' then shift them to the right 9 times to get the number  	//of years past 2000  	int year = ((date & 0xFE00) >> 9) + 1980;  	int month = (date & 0x1E0) >> 5;  	int day = (date & 0x1F);  	int hour = (time & 0xF800) >> 11;  	int minute = (time & 0x7E0) >> 5;  	int second = (time & 0x1F) * 2;  	return new DateTime (year' month' day' hour' minute' second);  }  catch {  	return DateTime.Now;  }  
Magic Number,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,DateTimeFromFATInt,The following statement contains a magic number: try {  	//If they're both zero' then we don't have a date.  	if (date == 0 && time == 0) {  		return DateTime.Now;  	}  	//We didn't return the date' so ye  	//We mask the upper 8 bits to get only bits 9-15' then shift them to the right 9 times to get the number  	//of years past 2000  	int year = ((date & 0xFE00) >> 9) + 1980;  	int month = (date & 0x1E0) >> 5;  	int day = (date & 0x1F);  	int hour = (time & 0xF800) >> 11;  	int minute = (time & 0x7E0) >> 5;  	int second = (time & 0x1F) * 2;  	return new DateTime (year' month' day' hour' minute' second);  }  catch {  	return DateTime.Now;  }  
Magic Number,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,DateTimeFromFATInt,The following statement contains a magic number: try {  	//If they're both zero' then we don't have a date.  	if (date == 0 && time == 0) {  		return DateTime.Now;  	}  	//We didn't return the date' so ye  	//We mask the upper 8 bits to get only bits 9-15' then shift them to the right 9 times to get the number  	//of years past 2000  	int year = ((date & 0xFE00) >> 9) + 1980;  	int month = (date & 0x1E0) >> 5;  	int day = (date & 0x1F);  	int hour = (time & 0xF800) >> 11;  	int minute = (time & 0x7E0) >> 5;  	int second = (time & 0x1F) * 2;  	return new DateTime (year' month' day' hour' minute' second);  }  catch {  	return DateTime.Now;  }  
Magic Number,CLKsFATXLib,VariousFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\VariousFunctions.cs,GetFATXPath,The following statement contains a magic number: if (io.BaseStream.Length > 4) {  	uint header = io.ReadUInt32 ();  	if (header == 0x434F4E20 || header == 0x4C495645 || header == 0x50495253) {  		// Get the type  		io.BaseStream.Position = 0x344;  		byte[] Type = io.ReadBytes (0x4);  		// Get the profile ID  		io.BaseStream.Position = 0x371;  		byte[] ID = io.ReadBytes (0x8);  		// Get the title ID  		io.BaseStream.Position = 0x360;  		byte[] TitleID = io.ReadBytes (0x4);  		// NOW LET'S DO THIS SHIT  		return string.Format ("Content\\{0}\\{1}\\{2}"' ID.ToHexString ()' TitleID.ToHexString ()' Type.ToHexString ());  	}  }  
Magic Number,CLKsFATXLib.Extensions,Extensions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\Extensions.cs,FriendlyNodeName,The following statement contains a magic number: if (n.Text.Contains ('|')) {  	return n.Text.Remove (0' n.RealNodeName ().Length + 3);  }  
Magic Number,CLKsFATXLib.Extensions,Extensions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\Extensions.cs,FriendlyNodeName,The following statement contains a magic number: return n.Text.Remove (0' n.RealNodeName ().Length + 3);  
Magic Number,CLKsFATXLib.Streams,Reader,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,ReadInt24,The following statement contains a magic number: if (!LittleEndian) {  	byte[] Buffer = ReadBytes (0x3);  	Buffer = new byte[] {  		Buffer [2]'  		Buffer [1]'  		Buffer [0]'  		0'  	};  	return (BitConverter.ToInt32 (Buffer' 0x0) >> 8);  }  else {  	byte[] Buffer = ReadBytes (0x3);  	Buffer = new byte[] {  		Buffer [2]'  		Buffer [1]'  		Buffer [0]'  		0'  	};  	Array.Reverse (Buffer);  	return (BitConverter.ToInt32 (Buffer' 0x0) << 8);  }  
Magic Number,CLKsFATXLib.Streams,Reader,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,ReadInt24,The following statement contains a magic number: if (!LittleEndian) {  	byte[] Buffer = ReadBytes (0x3);  	Buffer = new byte[] {  		Buffer [2]'  		Buffer [1]'  		Buffer [0]'  		0'  	};  	return (BitConverter.ToInt32 (Buffer' 0x0) >> 8);  }  else {  	byte[] Buffer = ReadBytes (0x3);  	Buffer = new byte[] {  		Buffer [2]'  		Buffer [1]'  		Buffer [0]'  		0'  	};  	Array.Reverse (Buffer);  	return (BitConverter.ToInt32 (Buffer' 0x0) << 8);  }  
Magic Number,CLKsFATXLib.Streams,Reader,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,ReadInt24,The following statement contains a magic number: if (!LittleEndian) {  	byte[] Buffer = ReadBytes (0x3);  	Buffer = new byte[] {  		Buffer [2]'  		Buffer [1]'  		Buffer [0]'  		0'  	};  	return (BitConverter.ToInt32 (Buffer' 0x0) >> 8);  }  else {  	byte[] Buffer = ReadBytes (0x3);  	Buffer = new byte[] {  		Buffer [2]'  		Buffer [1]'  		Buffer [0]'  		0'  	};  	Array.Reverse (Buffer);  	return (BitConverter.ToInt32 (Buffer' 0x0) << 8);  }  
Magic Number,CLKsFATXLib.Streams,Reader,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,ReadInt24,The following statement contains a magic number: if (!LittleEndian) {  	byte[] Buffer = ReadBytes (0x3);  	Buffer = new byte[] {  		Buffer [2]'  		Buffer [1]'  		Buffer [0]'  		0'  	};  	return (BitConverter.ToInt32 (Buffer' 0x0) >> 8);  }  else {  	byte[] Buffer = ReadBytes (0x3);  	Buffer = new byte[] {  		Buffer [2]'  		Buffer [1]'  		Buffer [0]'  		0'  	};  	Array.Reverse (Buffer);  	return (BitConverter.ToInt32 (Buffer' 0x0) << 8);  }  
Magic Number,CLKsFATXLib.Streams,Reader,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,ReadInt24,The following statement contains a magic number: Buffer = new byte[] {  	Buffer [2]'  	Buffer [1]'  	Buffer [0]'  	0'  };  
Magic Number,CLKsFATXLib.Streams,Reader,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,ReadInt24,The following statement contains a magic number: return (BitConverter.ToInt32 (Buffer' 0x0) >> 8);  
Magic Number,CLKsFATXLib.Streams,Reader,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,ReadInt24,The following statement contains a magic number: Buffer = new byte[] {  	Buffer [2]'  	Buffer [1]'  	Buffer [0]'  	0'  };  
Magic Number,CLKsFATXLib.Streams,Reader,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,ReadInt24,The following statement contains a magic number: return (BitConverter.ToInt32 (Buffer' 0x0) << 8);  
Magic Number,CLKsFATXLib.Streams,Reader,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,ReadInt24,The following statement contains a magic number: Buffer = new byte[] {  	Buffer [2]'  	Buffer [1]'  	Buffer [0]'  	0'  };  
Magic Number,CLKsFATXLib.Streams,Reader,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,ReadInt24,The following statement contains a magic number: return (BitConverter.ToInt32 (Buffer' 0x0) >> 8);  
Magic Number,CLKsFATXLib.Streams,Reader,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,ReadUnicodeString,The following statement contains a magic number: for (int i = 0; i < length; i += 2) {  	char c = (char)ReadUInt16 ();  	if (c != '\0') {  		ss += c;  	}  }  
Magic Number,CLKsFATXLib.Streams,Reader,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,ReadUnicodeString,The following statement contains a magic number: i += 2
Magic Number,CLKsFATXLib.Streams,Reader,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,ReadCString,The following statement contains a magic number: for (int i = 0; ; i += 2) {  	char c = (char)ReadUInt16 ();  	if (c != '\0') {  		ss += c;  	}  	else {  		break;  	}  }  
Magic Number,CLKsFATXLib.Streams,Reader,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\StreamsAndStuff.cs,ReadCString,The following statement contains a magic number: i += 2
Missing Default,CLKsFATXLib,Drive,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\Drive.cs,IsFATXDrive,The following switch statement is missing a default case: switch (DriveType) {  case DriveType.HardDisk:  	// Create our reader...  	try {  		Streams.Reader r = Reader ();  		// Seek to the data position  		r.BaseStream.Position = (long)Geometry.HDDOffsets.Data;  		// Read the magic  		if (r.ReadUInt32 () == 0x58544146/*XTAF*/) {  			return true;  		}  	}  	catch {  	}  	break;  case DriveType.USB:  	try {  		Streams.Reader r2 = Reader ();  		// Seek to the data offset  		r2.BaseStream.Position = (long)Geometry.USBOffsets.Data;  		if (r2.ReadUInt32 () == 0x58544146/*XTAF*/) {  			return true;  		}  	}  	catch {  	}  	break;  case DriveType.Backup:  	try {  		Streams.Reader r1 = Reader ();  		if (Length > (long)Geometry.HDDOffsets.Data) {  			// Seek to the data position  			r1.BaseStream.Position = (long)Geometry.HDDOffsets.Data;  		}  		// Read the magic  		if (r1.ReadUInt32 () == 0x58544146/*XTAF*/) {  			return true;  		}  	}  	catch {  	}  	break;  }  
Missing Default,CLKsFATXLib,Drive,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\Drive.cs,Stream,The following switch statement is missing a default case: switch (DriveType) {  case DriveType.Backup:  	thisStream = new System.IO.FileStream (FilePath' System.IO.FileMode.Open);  	break;  case DriveType.HardDisk:  	thisStream = new System.IO.FileStream (VariousFunctions.CreateHandle (DeviceIndex)' System.IO.FileAccess.ReadWrite);  	break;  case DriveType.USB:  	thisStream = new Streams.USBStream (USBPaths' System.IO.FileMode.Open);  	break;  }  
Missing Default,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,PartitionSize,The following switch statement is missing a default case: switch (Partition.Offset) {  case (long)Geometry.HDDOffsets.Compatibility:  	psize = (long)Geometry.HDDLengths.Compatibility;  	break;  case (long)Geometry.HDDOffsets.System_Cache:  	psize = (long)Geometry.HDDLengths.System_Cache;  	break;  case (long)Geometry.HDDOffsets.System_Extended:  	psize = (long)Geometry.HDDLengths.System_Extended;  	break;  case (long)Geometry.HDDOffsets.Data:  	if (FATXDrive.DriveType == DriveType.HardDisk) {  		psize = (FATXDrive.Length - Partition.Offset);  	}  	else {  		psize = (FATXDrive.Length - Partition.Offset);  	}  	break;  case (long)Geometry.HDDOffsets.GameCache:  	psize = (long)Geometry.HDDLengths.GameCache;  	break;  case (long)Geometry.HDDOffsets.SystemCache:  	psize = (long)Geometry.HDDLengths.SystemCache;  	break;  }  
Missing Default,CLKsFATXLib,PartitionFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,PartitionSize,The following switch statement is missing a default case: switch (Partition.Offset) {  case (long)Geometry.USBOffsets.Cache:  	psize = (long)Geometry.USBPartitionSizes.Cache;  	break;  case (long)Geometry.USBOffsets.aSystem_Aux:  	psize = (long)Geometry.USBPartitionSizes.System_Aux;  	break;  case (long)Geometry.USBOffsets.aSystem_Extended:  	psize = (long)Geometry.USBPartitionSizes.System_Extended;  	break;  case (long)Geometry.USBOffsets.Data:  	psize = FATXDrive.Length - (long)Geometry.USBOffsets.Data;  	break;  }  
Missing Default,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,GetBlocksOccupied,The following switch statement is missing a default case: switch (Parent.PartitionInfo.EntrySize) {  case 2:  	ushort Value = r1.ReadUInt16 ();  	if (Value != 0xFFFF && Value != 0xFFF8) {  		if (Value == 0) {  			throw new Exception ("Bad FAT chain in file or folder " + Parent.FullPath + "\r\nEntry Offset: 0x" + Parent.EntryOffset.ToString ("X"));  		}  		Blocks.Add (Value);  	}  	break;  case 4:  	uint Value2 = r1.ReadUInt32 ();  	if (Value2 != 0xFFFFFFFF && Value2 != 0xFFFFFFF8) {  		if (Value2 == 0) {  			throw new Exception ("Bad FAT chain in file or folder " + Parent.FullPath + "\r\nEntry Offset: 0x" + Parent.EntryOffset.ToString ("X"));  		}  		Blocks.Add (Value2);  	}  	break;  }  
Missing Default,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,WriteFATChain,The following switch statement is missing a default case: switch (Parent.PartitionInfo.EntrySize) {  case 2:  	if (i != Chain.Length - 1) {  		writing = BitConverter.GetBytes ((ushort)Chain [i + 1]);  	}  	else {  		writing = BitConverter.GetBytes ((ushort)0xFFFF);  	}  	break;  case 4:  	if (i != Chain.Length - 1) {  		writing = BitConverter.GetBytes (Chain [i + 1]);  	}  	else {  		writing = BitConverter.GetBytes (0xFFFFFFFF);  	}  	break;  }  
Missing Default,CLKsFATXLib,EntryFunctions,C:\repos\jkobrien_Xbox360ForensicsToolkit\Backup\CLKsFATXLib\FATX\PartitionFunctions.cs,ClearFATChain,The following switch statement is missing a default case: switch (Parent.PartitionInfo.EntrySize) {  case 2:  	writing = BitConverter.GetBytes ((ushort)0);  	break;  case 4:  	writing = BitConverter.GetBytes (0);  	break;  }  
