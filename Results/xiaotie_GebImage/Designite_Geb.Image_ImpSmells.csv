Implementation smell,Namespace,Class,File,Method,Description
Long Method,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,DrawLine,The method has 147 lines of code.
Long Method,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,ApplyConvolution,The method has 138 lines of code.
Long Method,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,DrawLine,The method has 147 lines of code.
Long Method,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,DrawLine,The method has 147 lines of code.
Long Method,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,DrawLine,The method has 147 lines of code.
Long Method,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ApplyConvolution,The method has 138 lines of code.
Long Method,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,DrawLine,The method has 147 lines of code.
Long Method,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,DrawLine,The method has 147 lines of code.
Long Method,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,DrawLine,The method has 147 lines of code.
Long Method,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DrawLine,The method has 147 lines of code.
Long Method,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyConvolution,The method has 138 lines of code.
Long Method,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,Thinning,The method has 142 lines of code.
Long Method,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyCannyEdgeDetector,The method has 173 lines of code.
Long Method,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,DrawLine,The method has 147 lines of code.
Long Method,Geb.Image.Hidden,ImageFilter_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__ImageFilter_Template.cs,ApplyConvolution,The method has 138 lines of code.
Complex Method,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,FloodFill,Cyclomatic complexity of the method is 9
Complex Method,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,ApplyModeFilter,Cyclomatic complexity of the method is 14
Complex Method,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,ApplyConvolution,Cyclomatic complexity of the method is 21
Complex Method,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,FloodFill,Cyclomatic complexity of the method is 9
Complex Method,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,ApplyModeFilter,Cyclomatic complexity of the method is 14
Complex Method,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,FloodFill,Cyclomatic complexity of the method is 9
Complex Method,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,ApplyModeFilter,Cyclomatic complexity of the method is 14
Complex Method,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,FloodFill,Cyclomatic complexity of the method is 9
Complex Method,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ApplyModeFilter,Cyclomatic complexity of the method is 14
Complex Method,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ApplyConvolution,Cyclomatic complexity of the method is 21
Complex Method,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,FloodFill,Cyclomatic complexity of the method is 9
Complex Method,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,ApplyModeFilter,Cyclomatic complexity of the method is 14
Complex Method,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,FloodFill,Cyclomatic complexity of the method is 9
Complex Method,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,ApplyModeFilter,Cyclomatic complexity of the method is 14
Complex Method,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,FloodFill,Cyclomatic complexity of the method is 9
Complex Method,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ApplyModeFilter,Cyclomatic complexity of the method is 14
Complex Method,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,FloodFill,Cyclomatic complexity of the method is 9
Complex Method,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyModeFilter,Cyclomatic complexity of the method is 14
Complex Method,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyConvolution,Cyclomatic complexity of the method is 21
Complex Method,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyCannyEdgeDetector,Cyclomatic complexity of the method is 16
Complex Method,Geb.Image,ConvolutionKernel,C:\repos\xiaotie_GebImage\src\Geb.Image\Common\ConvolutionKernel.cs,ConvolutionKernel,Cyclomatic complexity of the method is 8
Complex Method,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,FloodFill,Cyclomatic complexity of the method is 9
Complex Method,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,ApplyModeFilter,Cyclomatic complexity of the method is 14
Complex Method,Geb.Image.Hidden,ImageFilter_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__ImageFilter_Template.cs,ApplyConvolution,Cyclomatic complexity of the method is 21
Complex Method,Geb.Image.Sampling,ImageSamplingAlgorithm,C:\repos\xiaotie_GebImage\src\Geb.Image\Utils\ImageSamplingAlgorithm.cs,RandomUniformSampling,Cyclomatic complexity of the method is 10
Long Parameter List,Geb.Image,ClassHelper,C:\repos\xiaotie_GebImage\src\Geb.Image\Common\ClassHelper.cs,Fill,The method has 6 parameters. Parameters: bmp' p0' p1' p2' p3' color
Long Parameter List,Geb.Image,ClassHelper,C:\repos\xiaotie_GebImage\src\Geb.Image\Common\ClassHelper.cs,Resize,The method has 5 parameters. Parameters: bmp' width' height' mode' disposePolicy
Long Parameter List,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,ApplyMatrix,The method has 6 parameters. Parameters: a' b' c' d' e' f
Long Parameter List,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,SetColor,The method has 6 parameters. Parameters: x' y' color' radius' ww' hh
Long Parameter List,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,ApplyMatrix,The method has 6 parameters. Parameters: a' b' c' d' e' f
Long Parameter List,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,SetColor,The method has 6 parameters. Parameters: x' y' color' radius' ww' hh
Long Parameter List,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,ApplyMatrix,The method has 6 parameters. Parameters: a' b' c' d' e' f
Long Parameter List,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,SetColor,The method has 6 parameters. Parameters: x' y' color' radius' ww' hh
Long Parameter List,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ApplyMatrix,The method has 6 parameters. Parameters: a' b' c' d' e' f
Long Parameter List,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,SetColor,The method has 6 parameters. Parameters: x' y' color' radius' ww' hh
Long Parameter List,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ToHypsometricMap,The method has 5 parameters. Parameters: hueOfMinVal' hueOfMaxVal' useBgVal' bgVal' bgColor
Long Parameter List,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,ApplyMatrix,The method has 6 parameters. Parameters: a' b' c' d' e' f
Long Parameter List,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,SetColor,The method has 6 parameters. Parameters: x' y' color' radius' ww' hh
Long Parameter List,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,ApplyMatrix,The method has 6 parameters. Parameters: a' b' c' d' e' f
Long Parameter List,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,SetColor,The method has 6 parameters. Parameters: x' y' color' radius' ww' hh
Long Parameter List,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ApplyMatrix,The method has 6 parameters. Parameters: a' b' c' d' e' f
Long Parameter List,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,SetColor,The method has 6 parameters. Parameters: x' y' color' radius' ww' hh
Long Parameter List,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyMatrix,The method has 6 parameters. Parameters: a' b' c' d' e' f
Long Parameter List,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,SetColor,The method has 6 parameters. Parameters: x' y' color' radius' ww' hh
Long Parameter List,Geb.Image,AffineTransform,C:\repos\xiaotie_GebImage\src\Geb.Image\Utils\AffineTransform.cs,AffineTransform,The method has 12 parameters. Parameters: x1' y1' x2' y2' x3' y3' xx1' yy1' xx2' yy2' xx3' yy3
Long Parameter List,Geb.Image,Interpolate,C:\repos\xiaotie_GebImage\src\Geb.Image\Utils\Interpolate.cs,LinearInterpolate,The method has 6 parameters. Parameters: v00' v10' v01' v11' a' b
Long Parameter List,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,ApplyMatrix,The method has 6 parameters. Parameters: a' b' c' d' e' f
Long Parameter List,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,SetColor,The method has 6 parameters. Parameters: x' y' color' radius' ww' hh
Long Parameter List,Geb.Image.Utils,ProjectionTransform,C:\repos\xiaotie_GebImage\src\Geb.Image\Utils\ProjectionTransform.cs,ProjectionTransform,The method has 16 parameters. Parameters: x00' y00' x01' y01' x10' y10' x11' y11' xx00' yy00' xx01' yy01' xx10' yy10' xx11' yy11
Long Statement,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,CopyFrom,The length of the statement  "            return CopyFrom(src' new PointS(start.X' start.Y)' new Rect(region.X' region.Y' region.Width' region.Height)' new PointS(destAnchor.X' destAnchor.Y)); " is 150.
Long Statement,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,DrawRect,The length of the statement  "            DrawLine(new PointF(rect.X + rect.Width' rect.Y)' new PointF(rect.X + rect.Width' rect.Y + rect.Height)' color' radius); " is 120.
Long Statement,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,DrawRect,The length of the statement  "            DrawLine(new PointF(rect.X' rect.Y + rect.Height)' new PointF(rect.X + rect.Width' rect.Y + rect.Height)' color' radius); " is 121.
Long Statement,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,ApplyConvolution,The length of the statement  "            maskImage.CopyFrom(this' new System.Drawing.Point(0' 0)' new System.Drawing.Rectangle(0' 0' this.Width' this.Height)' new System.Drawing.Point(extend' extend)); " is 160.
Long Statement,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,CopyFrom,The length of the statement  "            return CopyFrom(src' new PointS(start.X' start.Y)' new Rect(region.X' region.Y' region.Width' region.Height)' new PointS(destAnchor.X' destAnchor.Y)); " is 150.
Long Statement,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,DrawRect,The length of the statement  "            DrawLine(new PointF(rect.X + rect.Width' rect.Y)' new PointF(rect.X + rect.Width' rect.Y + rect.Height)' color' radius); " is 120.
Long Statement,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,DrawRect,The length of the statement  "            DrawLine(new PointF(rect.X' rect.Y + rect.Height)' new PointF(rect.X + rect.Width' rect.Y + rect.Height)' color' radius); " is 121.
Long Statement,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,CopyFrom,The length of the statement  "            return CopyFrom(src' new PointS(start.X' start.Y)' new Rect(region.X' region.Y' region.Width' region.Height)' new PointS(destAnchor.X' destAnchor.Y)); " is 150.
Long Statement,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,DrawRect,The length of the statement  "            DrawLine(new PointF(rect.X + rect.Width' rect.Y)' new PointF(rect.X + rect.Width' rect.Y + rect.Height)' color' radius); " is 120.
Long Statement,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,DrawRect,The length of the statement  "            DrawLine(new PointF(rect.X' rect.Y + rect.Height)' new PointF(rect.X + rect.Width' rect.Y + rect.Height)' color' radius); " is 121.
Long Statement,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,CopyFrom,The length of the statement  "            return CopyFrom(src' new PointS(start.X' start.Y)' new Rect(region.X' region.Y' region.Width' region.Height)' new PointS(destAnchor.X' destAnchor.Y)); " is 150.
Long Statement,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,DrawRect,The length of the statement  "            DrawLine(new PointF(rect.X + rect.Width' rect.Y)' new PointF(rect.X + rect.Width' rect.Y + rect.Height)' color' radius); " is 120.
Long Statement,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,DrawRect,The length of the statement  "            DrawLine(new PointF(rect.X' rect.Y + rect.Height)' new PointF(rect.X + rect.Width' rect.Y + rect.Height)' color' radius); " is 121.
Long Statement,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ApplyConvolution,The length of the statement  "            maskImage.CopyFrom(this' new System.Drawing.Point(0' 0)' new System.Drawing.Rectangle(0' 0' this.Width' this.Height)' new System.Drawing.Point(extend' extend)); " is 160.
Long Statement,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,CopyFrom,The length of the statement  "            return CopyFrom(src' new PointS(start.X' start.Y)' new Rect(region.X' region.Y' region.Width' region.Height)' new PointS(destAnchor.X' destAnchor.Y)); " is 150.
Long Statement,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,DrawRect,The length of the statement  "            DrawLine(new PointF(rect.X + rect.Width' rect.Y)' new PointF(rect.X + rect.Width' rect.Y + rect.Height)' color' radius); " is 120.
Long Statement,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,DrawRect,The length of the statement  "            DrawLine(new PointF(rect.X' rect.Y + rect.Height)' new PointF(rect.X + rect.Width' rect.Y + rect.Height)' color' radius); " is 121.
Long Statement,Geb.Image,SignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,ToString,The length of the statement  "            return "SignedArgb64 [A=" + Alpha + "' R=" + Red.ToString() + "' G=" + Green.ToString() + "' B=" + Blue.ToString() + "]"; " is 121.
Long Statement,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,CopyFrom,The length of the statement  "            return CopyFrom(src' new PointS(start.X' start.Y)' new Rect(region.X' region.Y' region.Width' region.Height)' new PointS(destAnchor.X' destAnchor.Y)); " is 150.
Long Statement,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,DrawRect,The length of the statement  "            DrawLine(new PointF(rect.X + rect.Width' rect.Y)' new PointF(rect.X + rect.Width' rect.Y + rect.Height)' color' radius); " is 120.
Long Statement,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,DrawRect,The length of the statement  "            DrawLine(new PointF(rect.X' rect.Y + rect.Height)' new PointF(rect.X + rect.Width' rect.Y + rect.Height)' color' radius); " is 121.
Long Statement,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,CopyFrom,The length of the statement  "            return CopyFrom(src' new PointS(start.X' start.Y)' new Rect(region.X' region.Y' region.Width' region.Height)' new PointS(destAnchor.X' destAnchor.Y)); " is 150.
Long Statement,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,DrawRect,The length of the statement  "            DrawLine(new PointF(rect.X + rect.Width' rect.Y)' new PointF(rect.X + rect.Width' rect.Y + rect.Height)' color' radius); " is 120.
Long Statement,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,DrawRect,The length of the statement  "            DrawLine(new PointF(rect.X' rect.Y + rect.Height)' new PointF(rect.X + rect.Width' rect.Y + rect.Height)' color' radius); " is 121.
Long Statement,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,CopyFrom,The length of the statement  "            return CopyFrom(src' new PointS(start.X' start.Y)' new Rect(region.X' region.Y' region.Width' region.Height)' new PointS(destAnchor.X' destAnchor.Y)); " is 150.
Long Statement,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DrawRect,The length of the statement  "            DrawLine(new PointF(rect.X + rect.Width' rect.Y)' new PointF(rect.X + rect.Width' rect.Y + rect.Height)' color' radius); " is 120.
Long Statement,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DrawRect,The length of the statement  "            DrawLine(new PointF(rect.X' rect.Y + rect.Height)' new PointF(rect.X + rect.Width' rect.Y + rect.Height)' color' radius); " is 121.
Long Statement,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyConvolution,The length of the statement  "            maskImage.CopyFrom(this' new System.Drawing.Point(0' 0)' new System.Drawing.Rectangle(0' 0' this.Width' this.Height)' new System.Drawing.Point(extend' extend)); " is 160.
Long Statement,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyOtsuThreshold,The length of the statement  "                float betweenClassVariance = (float)((class1Probability) * (1.0 - class1Probability) * Math.Pow(class1Mean - class2Mean' 2)); " is 125.
Long Statement,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,CopyFrom,The length of the statement  "            return CopyFrom(src' new PointS(start.X' start.Y)' new Rect(region.X' region.Y' region.Width' region.Height)' new PointS(destAnchor.X' destAnchor.Y)); " is 150.
Long Statement,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,DrawRect,The length of the statement  "            DrawLine(new PointF(rect.X + rect.Width' rect.Y)' new PointF(rect.X + rect.Width' rect.Y + rect.Height)' color' radius); " is 120.
Long Statement,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,DrawRect,The length of the statement  "            DrawLine(new PointF(rect.X' rect.Y + rect.Height)' new PointF(rect.X + rect.Width' rect.Y + rect.Height)' color' radius); " is 121.
Long Statement,Geb.Image.Hidden,ImageFilter_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__ImageFilter_Template.cs,ApplyConvolution,The length of the statement  "            maskImage.CopyFrom(this' new System.Drawing.Point(0' 0)' new System.Drawing.Rectangle(0' 0' this.Width' this.Height)' new System.Drawing.Point(extend' extend)); " is 160.
Complex Conditional,Geb.Image,TriangleF,C:\repos\xiaotie_GebImage\src\Geb.Image\Common\Structs.cs,Contains,The conditional expression  "maxX < p.X || maxY < p.Y || minX > p.X || minY > p.Y"  is complex.
Complex Conditional,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,FloodFill,The conditional expression  "location.X < 0 || location.X >= width || location.Y < 0 || location.Y >= height"  is complex.
Complex Conditional,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,ApplyModeFilter,The conditional expression  "xx >= 0 && xx < width && yy >= 0 && yy < height"  is complex.
Complex Conditional,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,DrawLine,The conditional expression  "xMin >= Width || yMin >= Height || yMax < 0 || xMax < 0"  is complex.
Complex Conditional,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,DrawLine,The conditional expression  "xMin >= 0 && yMin >= 0 && yMax < (Height - 1) && xMax < Width"  is complex.
Complex Conditional,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,DrawLine,The conditional expression  "cy >= 0 && cy < width && cx >= 0 && cx < height"  is complex.
Complex Conditional,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,DrawLine,The conditional expression  "cy >= 0 && cy < width && cx >= 0 && cx < height"  is complex.
Complex Conditional,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,DrawLine,The conditional expression  "cx >= 0 && cx < width && cy >= 0 && cy < height"  is complex.
Complex Conditional,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,DrawLine,The conditional expression  "cx >= 0 && cx < width && cy >= 0 && cy < height"  is complex.
Complex Conditional,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,SetColor,The conditional expression  "xx < 0 || yy < 0 || xx > ww || yy > hh"  is complex.
Complex Conditional,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,FloodFill,The conditional expression  "location.X < 0 || location.X >= width || location.Y < 0 || location.Y >= height"  is complex.
Complex Conditional,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,ApplyModeFilter,The conditional expression  "xx >= 0 && xx < width && yy >= 0 && yy < height"  is complex.
Complex Conditional,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,DrawLine,The conditional expression  "xMin >= Width || yMin >= Height || yMax < 0 || xMax < 0"  is complex.
Complex Conditional,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,DrawLine,The conditional expression  "xMin >= 0 && yMin >= 0 && yMax < (Height - 1) && xMax < Width"  is complex.
Complex Conditional,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,DrawLine,The conditional expression  "cy >= 0 && cy < width && cx >= 0 && cx < height"  is complex.
Complex Conditional,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,DrawLine,The conditional expression  "cy >= 0 && cy < width && cx >= 0 && cx < height"  is complex.
Complex Conditional,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,DrawLine,The conditional expression  "cx >= 0 && cx < width && cy >= 0 && cy < height"  is complex.
Complex Conditional,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,DrawLine,The conditional expression  "cx >= 0 && cx < width && cy >= 0 && cy < height"  is complex.
Complex Conditional,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,SetColor,The conditional expression  "xx < 0 || yy < 0 || xx > ww || yy > hh"  is complex.
Complex Conditional,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The conditional expression  "hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3"  is complex.
Complex Conditional,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,FloodFill,The conditional expression  "location.X < 0 || location.X >= width || location.Y < 0 || location.Y >= height"  is complex.
Complex Conditional,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,ApplyModeFilter,The conditional expression  "xx >= 0 && xx < width && yy >= 0 && yy < height"  is complex.
Complex Conditional,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,DrawLine,The conditional expression  "xMin >= Width || yMin >= Height || yMax < 0 || xMax < 0"  is complex.
Complex Conditional,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,DrawLine,The conditional expression  "xMin >= 0 && yMin >= 0 && yMax < (Height - 1) && xMax < Width"  is complex.
Complex Conditional,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,DrawLine,The conditional expression  "cy >= 0 && cy < width && cx >= 0 && cx < height"  is complex.
Complex Conditional,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,DrawLine,The conditional expression  "cy >= 0 && cy < width && cx >= 0 && cx < height"  is complex.
Complex Conditional,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,DrawLine,The conditional expression  "cx >= 0 && cx < width && cy >= 0 && cy < height"  is complex.
Complex Conditional,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,DrawLine,The conditional expression  "cx >= 0 && cx < width && cy >= 0 && cy < height"  is complex.
Complex Conditional,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,SetColor,The conditional expression  "xx < 0 || yy < 0 || xx > ww || yy > hh"  is complex.
Complex Conditional,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,FloodFill,The conditional expression  "location.X < 0 || location.X >= width || location.Y < 0 || location.Y >= height"  is complex.
Complex Conditional,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ApplyModeFilter,The conditional expression  "xx >= 0 && xx < width && yy >= 0 && yy < height"  is complex.
Complex Conditional,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,DrawLine,The conditional expression  "xMin >= Width || yMin >= Height || yMax < 0 || xMax < 0"  is complex.
Complex Conditional,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,DrawLine,The conditional expression  "xMin >= 0 && yMin >= 0 && yMax < (Height - 1) && xMax < Width"  is complex.
Complex Conditional,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,DrawLine,The conditional expression  "cy >= 0 && cy < width && cx >= 0 && cx < height"  is complex.
Complex Conditional,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,DrawLine,The conditional expression  "cy >= 0 && cy < width && cx >= 0 && cx < height"  is complex.
Complex Conditional,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,DrawLine,The conditional expression  "cx >= 0 && cx < width && cy >= 0 && cy < height"  is complex.
Complex Conditional,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,DrawLine,The conditional expression  "cx >= 0 && cx < width && cy >= 0 && cy < height"  is complex.
Complex Conditional,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,SetColor,The conditional expression  "xx < 0 || yy < 0 || xx > ww || yy > hh"  is complex.
Complex Conditional,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The conditional expression  "hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3"  is complex.
Complex Conditional,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,FloodFill,The conditional expression  "location.X < 0 || location.X >= width || location.Y < 0 || location.Y >= height"  is complex.
Complex Conditional,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,ApplyModeFilter,The conditional expression  "xx >= 0 && xx < width && yy >= 0 && yy < height"  is complex.
Complex Conditional,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,DrawLine,The conditional expression  "xMin >= Width || yMin >= Height || yMax < 0 || xMax < 0"  is complex.
Complex Conditional,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,DrawLine,The conditional expression  "xMin >= 0 && yMin >= 0 && yMax < (Height - 1) && xMax < Width"  is complex.
Complex Conditional,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,DrawLine,The conditional expression  "cy >= 0 && cy < width && cx >= 0 && cx < height"  is complex.
Complex Conditional,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,DrawLine,The conditional expression  "cy >= 0 && cy < width && cx >= 0 && cx < height"  is complex.
Complex Conditional,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,DrawLine,The conditional expression  "cx >= 0 && cx < width && cy >= 0 && cy < height"  is complex.
Complex Conditional,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,DrawLine,The conditional expression  "cx >= 0 && cx < width && cy >= 0 && cy < height"  is complex.
Complex Conditional,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,SetColor,The conditional expression  "xx < 0 || yy < 0 || xx > ww || yy > hh"  is complex.
Complex Conditional,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,FloodFill,The conditional expression  "location.X < 0 || location.X >= width || location.Y < 0 || location.Y >= height"  is complex.
Complex Conditional,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,ApplyModeFilter,The conditional expression  "xx >= 0 && xx < width && yy >= 0 && yy < height"  is complex.
Complex Conditional,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,DrawLine,The conditional expression  "xMin >= Width || yMin >= Height || yMax < 0 || xMax < 0"  is complex.
Complex Conditional,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,DrawLine,The conditional expression  "xMin >= 0 && yMin >= 0 && yMax < (Height - 1) && xMax < Width"  is complex.
Complex Conditional,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,DrawLine,The conditional expression  "cy >= 0 && cy < width && cx >= 0 && cx < height"  is complex.
Complex Conditional,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,DrawLine,The conditional expression  "cy >= 0 && cy < width && cx >= 0 && cx < height"  is complex.
Complex Conditional,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,DrawLine,The conditional expression  "cx >= 0 && cx < width && cy >= 0 && cy < height"  is complex.
Complex Conditional,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,DrawLine,The conditional expression  "cx >= 0 && cx < width && cy >= 0 && cy < height"  is complex.
Complex Conditional,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,SetColor,The conditional expression  "xx < 0 || yy < 0 || xx > ww || yy > hh"  is complex.
Complex Conditional,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The conditional expression  "hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3"  is complex.
Complex Conditional,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,FloodFill,The conditional expression  "location.X < 0 || location.X >= width || location.Y < 0 || location.Y >= height"  is complex.
Complex Conditional,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ApplyModeFilter,The conditional expression  "xx >= 0 && xx < width && yy >= 0 && yy < height"  is complex.
Complex Conditional,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,DrawLine,The conditional expression  "xMin >= Width || yMin >= Height || yMax < 0 || xMax < 0"  is complex.
Complex Conditional,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,DrawLine,The conditional expression  "xMin >= 0 && yMin >= 0 && yMax < (Height - 1) && xMax < Width"  is complex.
Complex Conditional,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,DrawLine,The conditional expression  "cy >= 0 && cy < width && cx >= 0 && cx < height"  is complex.
Complex Conditional,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,DrawLine,The conditional expression  "cy >= 0 && cy < width && cx >= 0 && cx < height"  is complex.
Complex Conditional,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,DrawLine,The conditional expression  "cx >= 0 && cx < width && cy >= 0 && cy < height"  is complex.
Complex Conditional,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,DrawLine,The conditional expression  "cx >= 0 && cx < width && cy >= 0 && cy < height"  is complex.
Complex Conditional,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,SetColor,The conditional expression  "xx < 0 || yy < 0 || xx > ww || yy > hh"  is complex.
Complex Conditional,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ApplyMedianFilter,The conditional expression  "hh >= 0 && hh < height && ww >= 0 && ww < width"  is complex.
Complex Conditional,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ApplyMedianFilter,The conditional expression  "hh >= 0 && hh < height && ww >= 0 && ww < width"  is complex.
Complex Conditional,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,FloodFill,The conditional expression  "location.X < 0 || location.X >= width || location.Y < 0 || location.Y >= height"  is complex.
Complex Conditional,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyModeFilter,The conditional expression  "xx >= 0 && xx < width && yy >= 0 && yy < height"  is complex.
Complex Conditional,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DrawLine,The conditional expression  "xMin >= Width || yMin >= Height || yMax < 0 || xMax < 0"  is complex.
Complex Conditional,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DrawLine,The conditional expression  "xMin >= 0 && yMin >= 0 && yMax < (Height - 1) && xMax < Width"  is complex.
Complex Conditional,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DrawLine,The conditional expression  "cy >= 0 && cy < width && cx >= 0 && cx < height"  is complex.
Complex Conditional,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DrawLine,The conditional expression  "cy >= 0 && cy < width && cx >= 0 && cx < height"  is complex.
Complex Conditional,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DrawLine,The conditional expression  "cx >= 0 && cx < width && cy >= 0 && cy < height"  is complex.
Complex Conditional,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DrawLine,The conditional expression  "cx >= 0 && cx < width && cy >= 0 && cy < height"  is complex.
Complex Conditional,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,SetColor,The conditional expression  "xx < 0 || yy < 0 || xx > ww || yy > hh"  is complex.
Complex Conditional,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,Thinning,The conditional expression  "list[0] == 0 && list[2] == 0 && list[4] == 0 && list[6] == 0"  is complex.
Complex Conditional,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyCannyEdgeDetector,The conditional expression  "(p[-1] < highThreshold) &&                                  (p[1] < highThreshold) &&                                  (pUp[-1] < highThreshold) &&                                  (pUp[0] < highThreshold) &&                                  (pUp[1] < highThreshold) &&                                  (pDown[-1] < highThreshold) &&                                  (pDown[0] < highThreshold) &&                                  (pDown[1] < highThreshold)"  is complex.
Complex Conditional,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyMedianFilter,The conditional expression  "hh >= 0 && hh < height && ww >= 0 && ww < width"  is complex.
Complex Conditional,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The conditional expression  "hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3"  is complex.
Complex Conditional,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,FloodFill,The conditional expression  "location.X < 0 || location.X >= width || location.Y < 0 || location.Y >= height"  is complex.
Complex Conditional,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,ApplyModeFilter,The conditional expression  "xx >= 0 && xx < width && yy >= 0 && yy < height"  is complex.
Complex Conditional,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,DrawLine,The conditional expression  "xMin >= Width || yMin >= Height || yMax < 0 || xMax < 0"  is complex.
Complex Conditional,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,DrawLine,The conditional expression  "xMin >= 0 && yMin >= 0 && yMax < (Height - 1) && xMax < Width"  is complex.
Complex Conditional,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,DrawLine,The conditional expression  "cy >= 0 && cy < width && cx >= 0 && cx < height"  is complex.
Complex Conditional,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,DrawLine,The conditional expression  "cy >= 0 && cy < width && cx >= 0 && cx < height"  is complex.
Complex Conditional,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,DrawLine,The conditional expression  "cx >= 0 && cx < width && cy >= 0 && cy < height"  is complex.
Complex Conditional,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,DrawLine,The conditional expression  "cx >= 0 && cx < width && cy >= 0 && cy < height"  is complex.
Complex Conditional,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,SetColor,The conditional expression  "xx < 0 || yy < 0 || xx > ww || yy > hh"  is complex.
Virtual Method Call from Constructor,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,ImageFloat,The constructor "ImageFloat" calls a virtual method "CreateFromBitmap".
Virtual Method Call from Constructor,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,ImageFloat,The constructor "ImageFloat" calls a virtual method "CreateFromBitmap".
Virtual Method Call from Constructor,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,ImageArgb32,The constructor "ImageArgb32" calls a virtual method "CreateFromBitmap".
Virtual Method Call from Constructor,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,ImageArgb32,The constructor "ImageArgb32" calls a virtual method "CreateFromBitmap".
Virtual Method Call from Constructor,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,ImageGrad,The constructor "ImageGrad" calls a virtual method "CreateFromBitmap".
Virtual Method Call from Constructor,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,ImageGrad,The constructor "ImageGrad" calls a virtual method "CreateFromBitmap".
Virtual Method Call from Constructor,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ImageInt32,The constructor "ImageInt32" calls a virtual method "CreateFromBitmap".
Virtual Method Call from Constructor,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ImageInt32,The constructor "ImageInt32" calls a virtual method "CreateFromBitmap".
Virtual Method Call from Constructor,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,ImageLab24,The constructor "ImageLab24" calls a virtual method "CreateFromBitmap".
Virtual Method Call from Constructor,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,ImageLab24,The constructor "ImageLab24" calls a virtual method "CreateFromBitmap".
Virtual Method Call from Constructor,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,ImageSignedArgb64,The constructor "ImageSignedArgb64" calls a virtual method "CreateFromBitmap".
Virtual Method Call from Constructor,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,ImageSignedArgb64,The constructor "ImageSignedArgb64" calls a virtual method "CreateFromBitmap".
Virtual Method Call from Constructor,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ImageRgb24,The constructor "ImageRgb24" calls a virtual method "CreateFromBitmap".
Virtual Method Call from Constructor,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ImageRgb24,The constructor "ImageRgb24" calls a virtual method "CreateFromBitmap".
Virtual Method Call from Constructor,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ImageU8,The constructor "ImageU8" calls a virtual method "CreateFromBitmap".
Virtual Method Call from Constructor,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ImageU8,The constructor "ImageU8" calls a virtual method "CreateFromBitmap".
Virtual Method Call from Constructor,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,Image_Template,The constructor "Image_Template" calls a virtual method "CreateFromBitmap".
Virtual Method Call from Constructor,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,Image_Template,The constructor "Image_Template" calls a virtual method "CreateFromBitmap".
Magic Number,Geb.Image,ClassHelper,C:\repos\xiaotie_GebImage\src\Geb.Image\Common\ClassHelper.cs,InitGrayscalePalette,The following statement contains a magic number: for (int i = 0; i < 255; i++)              {                  palette.Entries[i] = Color.FromArgb(i' i' i);              }
Magic Number,Geb.Image,ClassHelper,C:\repos\xiaotie_GebImage\src\Geb.Image\Common\ClassHelper.cs,ToBitmap,The following statement contains a magic number: const int PixelFormat32bppCMYK = 8207;
Magic Number,Geb.Image,ClassHelper,C:\repos\xiaotie_GebImage\src\Geb.Image\Common\ClassHelper.cs,ToPolarPointD,The following statement contains a magic number: double angle = Math.Atan2(p.Y' p.X) * (180 / Math.PI);
Magic Number,Geb.Image,ClassHelper,C:\repos\xiaotie_GebImage\src\Geb.Image\Common\ClassHelper.cs,ToPolarPointD,The following statement contains a magic number: if (angle < 0) angle = 360 + angle;
Magic Number,Geb.Image,Cmyk,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageCmyk.cs,ToRgb24,The following statement contains a magic number: int R = (int)((1 - (MyC * (1 - MyK) + MyK)) * 255);
Magic Number,Geb.Image,Cmyk,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageCmyk.cs,ToRgb24,The following statement contains a magic number: int G = (int)((1 - (MyM * (1 - MyK) + MyK)) * 255);
Magic Number,Geb.Image,Cmyk,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageCmyk.cs,ToRgb24,The following statement contains a magic number: int B = (int)((1 - (MyY * (1 - MyK) + MyK)) * 255);
Magic Number,Geb.Image,Cmyk,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageCmyk.cs,ToRgb24,The following statement contains a magic number: if (R > 255) R = 255;
Magic Number,Geb.Image,Cmyk,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageCmyk.cs,ToRgb24,The following statement contains a magic number: if (R > 255) R = 255;
Magic Number,Geb.Image,Cmyk,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageCmyk.cs,ToRgb24,The following statement contains a magic number: if (G > 255) G = 255;
Magic Number,Geb.Image,Cmyk,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageCmyk.cs,ToRgb24,The following statement contains a magic number: if (G > 255) G = 255;
Magic Number,Geb.Image,Cmyk,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageCmyk.cs,ToRgb24,The following statement contains a magic number: if (B > 255) B = 255;
Magic Number,Geb.Image,Cmyk,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageCmyk.cs,ToRgb24,The following statement contains a magic number: if (B > 255) B = 255;
Magic Number,Geb.Image,Cmyk,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageCmyk.cs,CreateFrom,The following statement contains a magic number: cmyk.K = (byte)(Math.Min(Math.Min(255 - red' 255 - green)' 255 - blue) / 2.55);
Magic Number,Geb.Image,Cmyk,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageCmyk.cs,CreateFrom,The following statement contains a magic number: cmyk.K = (byte)(Math.Min(Math.Min(255 - red' 255 - green)' 255 - blue) / 2.55);
Magic Number,Geb.Image,Cmyk,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageCmyk.cs,CreateFrom,The following statement contains a magic number: cmyk.K = (byte)(Math.Min(Math.Min(255 - red' 255 - green)' 255 - blue) / 2.55);
Magic Number,Geb.Image,Cmyk,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageCmyk.cs,CreateFrom,The following statement contains a magic number: cmyk.K = (byte)(Math.Min(Math.Min(255 - red' 255 - green)' 255 - blue) / 2.55);
Magic Number,Geb.Image,Cmyk,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageCmyk.cs,CreateFrom,The following statement contains a magic number: int MyR = (int)(red / 2.55);
Magic Number,Geb.Image,Cmyk,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageCmyk.cs,CreateFrom,The following statement contains a magic number: int Div = 100 - cmyk.K;
Magic Number,Geb.Image,Cmyk,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageCmyk.cs,CreateFrom,The following statement contains a magic number: cmyk.C = (byte)(100 * (100 - MyR - cmyk.K) / Div);
Magic Number,Geb.Image,Cmyk,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageCmyk.cs,CreateFrom,The following statement contains a magic number: cmyk.C = (byte)(100 * (100 - MyR - cmyk.K) / Div);
Magic Number,Geb.Image,Cmyk,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageCmyk.cs,CreateFrom,The following statement contains a magic number: int MyG = (int)(green / 2.55);
Magic Number,Geb.Image,Cmyk,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageCmyk.cs,CreateFrom,The following statement contains a magic number: cmyk.M = (byte)(100 * (100 - MyG - cmyk.K) / Div);
Magic Number,Geb.Image,Cmyk,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageCmyk.cs,CreateFrom,The following statement contains a magic number: cmyk.M = (byte)(100 * (100 - MyG - cmyk.K) / Div);
Magic Number,Geb.Image,Cmyk,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageCmyk.cs,CreateFrom,The following statement contains a magic number: int MyB = (int)(blue / 2.55);
Magic Number,Geb.Image,Cmyk,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageCmyk.cs,CreateFrom,The following statement contains a magic number: cmyk.Y = (byte)(100 * (100 - MyB - cmyk.K) / Div);
Magic Number,Geb.Image,Cmyk,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageCmyk.cs,CreateFrom,The following statement contains a magic number: cmyk.Y = (byte)(100 * (100 - MyB - cmyk.K) / Div);
Magic Number,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,ToImageU8,The following statement contains a magic number: while (p < pEnd)              {                  val = *p * coeff;                  val = Math.Min(255'Math.Max(val' 0));                  *dst = (Byte)val;                  p++;                  dst++;              }
Magic Number,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,CreateFromBitmap,The following statement contains a magic number: const int PixelFormat32bppCMYK = 8207;
Magic Number,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,ApplyModeFilter,The following statement contains a magic number: if (size <= 1) throw new ArgumentOutOfRangeException("size 必须大于1.");              else if (size > 127) throw new ArgumentOutOfRangeException("size 最大为127.");              else if (size % 2 == 0) throw new ArgumentException("size 应该是奇数.");
Magic Number,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,ApplyModeFilter,The following statement contains a magic number: if (size <= 1) throw new ArgumentOutOfRangeException("size 必须大于1.");              else if (size > 127) throw new ArgumentOutOfRangeException("size 最大为127.");              else if (size % 2 == 0) throw new ArgumentException("size 应该是奇数.");
Magic Number,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,ApplyModeFilter,The following statement contains a magic number: int radius = size / 2;
Magic Number,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,DrawLine,The following statement contains a magic number: int n2dy = dy * 2;
Magic Number,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,DrawLine,The following statement contains a magic number: int n2dydx = (dy - dx) * 2;
Magic Number,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,DrawLine,The following statement contains a magic number: int d = dy * 2 - dx;
Magic Number,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,DrawLine,The following statement contains a magic number: if (Math.Abs(deltaX) < 0.0001)              {                  if (Math.Abs(deltaY) < 0.0001)                  {                      SetColor(start.X' start.Y' color' radius' ww' hh);                      return;                  };                    float yStart = start.Y;                  float yEnd = end.Y;                  float x = start.X;                    if (yEnd < yStart)                  {                      float tmp = yEnd;                      yEnd = yStart;                      yStart = tmp;                  }                    yStart = Math.Max(0' yStart);                  yEnd = Math.Min(hh' yEnd);                    for (float y = yStart; y <= yEnd; y++)                  {                      SetColor(x' y' color' radius' ww' hh);                  }              }              else              {                  float xStart = start.X;                  float xEnd = end.X;                  if (xEnd < xStart)                  {                      float tmp = xEnd;                      xEnd = xStart;                      xStart = tmp;                  }                    float step = 1;                  float grad = Math.Abs(deltaY / deltaX);                  if (grad > 1)                  {                      step = 1 / grad;                  }                    for (float x = xStart; x <= xEnd; x += step)                  {                      float deltaXX = start.X - x;                      float deltaYY = deltaY * (deltaXX / deltaX);                      float y = start.Y - deltaYY;                        SetColor(x' y' color' radius' ww' hh);                  }              }
Magic Number,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,DrawLine,The following statement contains a magic number: if (Math.Abs(deltaX) < 0.0001)              {                  if (Math.Abs(deltaY) < 0.0001)                  {                      SetColor(start.X' start.Y' color' radius' ww' hh);                      return;                  };                    float yStart = start.Y;                  float yEnd = end.Y;                  float x = start.X;                    if (yEnd < yStart)                  {                      float tmp = yEnd;                      yEnd = yStart;                      yStart = tmp;                  }                    yStart = Math.Max(0' yStart);                  yEnd = Math.Min(hh' yEnd);                    for (float y = yStart; y <= yEnd; y++)                  {                      SetColor(x' y' color' radius' ww' hh);                  }              }              else              {                  float xStart = start.X;                  float xEnd = end.X;                  if (xEnd < xStart)                  {                      float tmp = xEnd;                      xEnd = xStart;                      xStart = tmp;                  }                    float step = 1;                  float grad = Math.Abs(deltaY / deltaX);                  if (grad > 1)                  {                      step = 1 / grad;                  }                    for (float x = xStart; x <= xEnd; x += step)                  {                      float deltaXX = start.X - x;                      float deltaYY = deltaY * (deltaXX / deltaX);                      float y = start.Y - deltaYY;                        SetColor(x' y' color' radius' ww' hh);                  }              }
Magic Number,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,DrawText,The following statement contains a magic number: int base_line = +(ascii[0] & 15);
Magic Number,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,DrawText,The following statement contains a magic number: List<PointS> pts = new List<PointS>(1 << 10);
Magic Number,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,DrawText,The following statement contains a magic number: for (int i = 0; i < txt.Length; i++)              {                  Char c = txt[i];                  if (c >= 127 || c < ' ')                      c = '?';                  String fontData = faces[ascii[(c - ' ') + 1]];                    PointS p = new PointS();                  p.X = (short)(fontData[0] - 'R');                  p.Y = (short)(fontData[1] - 'R');                  double dx = p.Y * hscale;                  view_x -= p.X * hscale;                  pts.Clear();                  for (int k = 2; k <= fontData.Length; )                  {                      if (k == fontData.Length || fontData[k] == ' ')                      {                          // Draw Poly Line                          if (pts.Count > 1)                          {                              for (int j = 1; j < pts.Count; j++)                              {                                  DrawLine(pts[j - 1].ToPointF()' pts[j].ToPointF()' color);                              }                          }                          pts.Clear();                          k++;                      }                      else                      {                          p.X = (short)(fontData[k] - 'R');                          p.Y = (short)(fontData[k+1] - 'R');                          k += 2;                          pts.Add(new PointS((short)Math.Round(p.X * hscale + view_x)'                              (short)Math.Round(p.Y * vscale + view_y)));                      }                  }                    view_x += dx;              }
Magic Number,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,DrawText,The following statement contains a magic number: for (int i = 0; i < txt.Length; i++)              {                  Char c = txt[i];                  if (c >= 127 || c < ' ')                      c = '?';                  String fontData = faces[ascii[(c - ' ') + 1]];                    PointS p = new PointS();                  p.X = (short)(fontData[0] - 'R');                  p.Y = (short)(fontData[1] - 'R');                  double dx = p.Y * hscale;                  view_x -= p.X * hscale;                  pts.Clear();                  for (int k = 2; k <= fontData.Length; )                  {                      if (k == fontData.Length || fontData[k] == ' ')                      {                          // Draw Poly Line                          if (pts.Count > 1)                          {                              for (int j = 1; j < pts.Count; j++)                              {                                  DrawLine(pts[j - 1].ToPointF()' pts[j].ToPointF()' color);                              }                          }                          pts.Clear();                          k++;                      }                      else                      {                          p.X = (short)(fontData[k] - 'R');                          p.Y = (short)(fontData[k+1] - 'R');                          k += 2;                          pts.Add(new PointS((short)Math.Round(p.X * hscale + view_x)'                              (short)Math.Round(p.Y * vscale + view_y)));                      }                  }                    view_x += dx;              }
Magic Number,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,DrawText,The following statement contains a magic number: for (int i = 0; i < txt.Length; i++)              {                  Char c = txt[i];                  if (c >= 127 || c < ' ')                      c = '?';                  String fontData = faces[ascii[(c - ' ') + 1]];                    PointS p = new PointS();                  p.X = (short)(fontData[0] - 'R');                  p.Y = (short)(fontData[1] - 'R');                  double dx = p.Y * hscale;                  view_x -= p.X * hscale;                  pts.Clear();                  for (int k = 2; k <= fontData.Length; )                  {                      if (k == fontData.Length || fontData[k] == ' ')                      {                          // Draw Poly Line                          if (pts.Count > 1)                          {                              for (int j = 1; j < pts.Count; j++)                              {                                  DrawLine(pts[j - 1].ToPointF()' pts[j].ToPointF()' color);                              }                          }                          pts.Clear();                          k++;                      }                      else                      {                          p.X = (short)(fontData[k] - 'R');                          p.Y = (short)(fontData[k+1] - 'R');                          k += 2;                          pts.Add(new PointS((short)Math.Round(p.X * hscale + view_x)'                              (short)Math.Round(p.Y * vscale + view_y)));                      }                  }                    view_x += dx;              }
Magic Number,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,ApplyConvolution,The following statement contains a magic number: int extend = Math.Max(kernelWidth' kernelHeight) / 2;
Magic Number,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,ApplyConvolution,The following statement contains a magic number: TImage maskImage = new TImage(Width + extend * 2' Height + extend * 2);
Magic Number,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,ApplyConvolution,The following statement contains a magic number: TImage maskImage = new TImage(Width + extend * 2' Height + extend * 2);
Magic Number,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,ApplyConvolution,The following statement contains a magic number: int extendWidth = this.Width + extend * 2;
Magic Number,Geb.Image,ImageFloat,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageFloat.cs,ApplyConvolution,The following statement contains a magic number: int extendHeight = this.Height + extend * 2;
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,CreateFromBitmap,The following statement contains a magic number: const int PixelFormat32bppCMYK = 8207;
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,ApplyModeFilter,The following statement contains a magic number: if (size <= 1) throw new ArgumentOutOfRangeException("size 必须大于1.");              else if (size > 127) throw new ArgumentOutOfRangeException("size 最大为127.");              else if (size % 2 == 0) throw new ArgumentException("size 应该是奇数.");
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,ApplyModeFilter,The following statement contains a magic number: if (size <= 1) throw new ArgumentOutOfRangeException("size 必须大于1.");              else if (size > 127) throw new ArgumentOutOfRangeException("size 最大为127.");              else if (size % 2 == 0) throw new ArgumentException("size 应该是奇数.");
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,ApplyModeFilter,The following statement contains a magic number: int radius = size / 2;
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,DrawLine,The following statement contains a magic number: int n2dy = dy * 2;
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,DrawLine,The following statement contains a magic number: int n2dydx = (dy - dx) * 2;
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,DrawLine,The following statement contains a magic number: int d = dy * 2 - dx;
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,DrawLine,The following statement contains a magic number: if (Math.Abs(deltaX) < 0.0001)              {                  if (Math.Abs(deltaY) < 0.0001)                  {                      SetColor(start.X' start.Y' color' radius' ww' hh);                      return;                  };                    float yStart = start.Y;                  float yEnd = end.Y;                  float x = start.X;                    if (yEnd < yStart)                  {                      float tmp = yEnd;                      yEnd = yStart;                      yStart = tmp;                  }                    yStart = Math.Max(0' yStart);                  yEnd = Math.Min(hh' yEnd);                    for (float y = yStart; y <= yEnd; y++)                  {                      SetColor(x' y' color' radius' ww' hh);                  }              }              else              {                  float xStart = start.X;                  float xEnd = end.X;                  if (xEnd < xStart)                  {                      float tmp = xEnd;                      xEnd = xStart;                      xStart = tmp;                  }                    float step = 1;                  float grad = Math.Abs(deltaY / deltaX);                  if (grad > 1)                  {                      step = 1 / grad;                  }                    for (float x = xStart; x <= xEnd; x += step)                  {                      float deltaXX = start.X - x;                      float deltaYY = deltaY * (deltaXX / deltaX);                      float y = start.Y - deltaYY;                        SetColor(x' y' color' radius' ww' hh);                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,DrawLine,The following statement contains a magic number: if (Math.Abs(deltaX) < 0.0001)              {                  if (Math.Abs(deltaY) < 0.0001)                  {                      SetColor(start.X' start.Y' color' radius' ww' hh);                      return;                  };                    float yStart = start.Y;                  float yEnd = end.Y;                  float x = start.X;                    if (yEnd < yStart)                  {                      float tmp = yEnd;                      yEnd = yStart;                      yStart = tmp;                  }                    yStart = Math.Max(0' yStart);                  yEnd = Math.Min(hh' yEnd);                    for (float y = yStart; y <= yEnd; y++)                  {                      SetColor(x' y' color' radius' ww' hh);                  }              }              else              {                  float xStart = start.X;                  float xEnd = end.X;                  if (xEnd < xStart)                  {                      float tmp = xEnd;                      xEnd = xStart;                      xStart = tmp;                  }                    float step = 1;                  float grad = Math.Abs(deltaY / deltaX);                  if (grad > 1)                  {                      step = 1 / grad;                  }                    for (float x = xStart; x <= xEnd; x += step)                  {                      float deltaXX = start.X - x;                      float deltaYY = deltaY * (deltaXX / deltaX);                      float y = start.Y - deltaYY;                        SetColor(x' y' color' radius' ww' hh);                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,DrawText,The following statement contains a magic number: int base_line = +(ascii[0] & 15);
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,DrawText,The following statement contains a magic number: List<PointS> pts = new List<PointS>(1 << 10);
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,DrawText,The following statement contains a magic number: for (int i = 0; i < txt.Length; i++)              {                  Char c = txt[i];                  if (c >= 127 || c < ' ')                      c = '?';                  String fontData = faces[ascii[(c - ' ') + 1]];                    PointS p = new PointS();                  p.X = (short)(fontData[0] - 'R');                  p.Y = (short)(fontData[1] - 'R');                  double dx = p.Y * hscale;                  view_x -= p.X * hscale;                  pts.Clear();                  for (int k = 2; k <= fontData.Length; )                  {                      if (k == fontData.Length || fontData[k] == ' ')                      {                          // Draw Poly Line                          if (pts.Count > 1)                          {                              for (int j = 1; j < pts.Count; j++)                              {                                  DrawLine(pts[j - 1].ToPointF()' pts[j].ToPointF()' color);                              }                          }                          pts.Clear();                          k++;                      }                      else                      {                          p.X = (short)(fontData[k] - 'R');                          p.Y = (short)(fontData[k+1] - 'R');                          k += 2;                          pts.Add(new PointS((short)Math.Round(p.X * hscale + view_x)'                              (short)Math.Round(p.Y * vscale + view_y)));                      }                  }                    view_x += dx;              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,DrawText,The following statement contains a magic number: for (int i = 0; i < txt.Length; i++)              {                  Char c = txt[i];                  if (c >= 127 || c < ' ')                      c = '?';                  String fontData = faces[ascii[(c - ' ') + 1]];                    PointS p = new PointS();                  p.X = (short)(fontData[0] - 'R');                  p.Y = (short)(fontData[1] - 'R');                  double dx = p.Y * hscale;                  view_x -= p.X * hscale;                  pts.Clear();                  for (int k = 2; k <= fontData.Length; )                  {                      if (k == fontData.Length || fontData[k] == ' ')                      {                          // Draw Poly Line                          if (pts.Count > 1)                          {                              for (int j = 1; j < pts.Count; j++)                              {                                  DrawLine(pts[j - 1].ToPointF()' pts[j].ToPointF()' color);                              }                          }                          pts.Clear();                          k++;                      }                      else                      {                          p.X = (short)(fontData[k] - 'R');                          p.Y = (short)(fontData[k+1] - 'R');                          k += 2;                          pts.Add(new PointS((short)Math.Round(p.X * hscale + view_x)'                              (short)Math.Round(p.Y * vscale + view_y)));                      }                  }                    view_x += dx;              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,DrawText,The following statement contains a magic number: for (int i = 0; i < txt.Length; i++)              {                  Char c = txt[i];                  if (c >= 127 || c < ' ')                      c = '?';                  String fontData = faces[ascii[(c - ' ') + 1]];                    PointS p = new PointS();                  p.X = (short)(fontData[0] - 'R');                  p.Y = (short)(fontData[1] - 'R');                  double dx = p.Y * hscale;                  view_x -= p.X * hscale;                  pts.Clear();                  for (int k = 2; k <= fontData.Length; )                  {                      if (k == fontData.Length || fontData[k] == ' ')                      {                          // Draw Poly Line                          if (pts.Count > 1)                          {                              for (int j = 1; j < pts.Count; j++)                              {                                  DrawLine(pts[j - 1].ToPointF()' pts[j].ToPointF()' color);                              }                          }                          pts.Clear();                          k++;                      }                      else                      {                          p.X = (short)(fontData[k] - 'R');                          p.Y = (short)(fontData[k+1] - 'R');                          k += 2;                          pts.Add(new PointS((short)Math.Round(p.X * hscale + view_x)'                              (short)Math.Round(p.Y * vscale + view_y)));                      }                  }                    view_x += dx;              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: int ww = width / 2;
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: int hh = height / 2;
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidDown,The following statement contains a magic number: int ww = width * 2;
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidDown,The following statement contains a magic number: int hh = height * 2;
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 0; h < hh; h += 2)              {                  hSrc = h / 2;                  lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      lineDst[w] = lineSrc[wSrc];                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2'width-2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 0; h < hh; h += 2)              {                  hSrc = h / 2;                  lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      lineDst[w] = lineSrc[wSrc];                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2'width-2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 0; h < hh; h += 2)              {                  hSrc = h / 2;                  lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      lineDst[w] = lineSrc[wSrc];                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2'width-2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 0; h < hh; h += 2)              {                  hSrc = h / 2;                  lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      lineDst[w] = lineSrc[wSrc];                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2'width-2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 0; h < hh; h += 2)              {                  hSrc = h / 2;                  lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      lineDst[w] = lineSrc[wSrc];                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2'width-2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 0; h < hh; h += 2)              {                  hSrc = h / 2;                  lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      lineDst[w] = lineSrc[wSrc];                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2'width-2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 0; h < hh; h += 2)              {                  hSrc = h / 2;                  lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      lineDst[w] = lineSrc[wSrc];                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2'width-2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,FastPyramidUp4X,The following statement contains a magic number: int ww = width / 4;
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,FastPyramidUp4X,The following statement contains a magic number: int hh = height / 4;
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,FastPyramidUp4X,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  lineSrc = imgStart + 4 * h * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      lineDst[w] = lineSrc[4 * w];                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,FastPyramidUp4X,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  lineSrc = imgStart + 4 * h * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      lineDst[w] = lineSrc[4 * w];                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,FastPyramidUp3X,The following statement contains a magic number: int ww = width / 3;
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,FastPyramidUp3X,The following statement contains a magic number: int hh = height / 3;
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,FastPyramidUp3X,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  lineSrc = imgStart +  3 * h * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      lineDst[w] = lineSrc[3 * w];                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,FastPyramidUp3X,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  lineSrc = imgStart +  3 * h * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      lineDst[w] = lineSrc[3 * w];                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,FastPyramidUp2X,The following statement contains a magic number: int ww = width / 2;
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,FastPyramidUp2X,The following statement contains a magic number: int hh = height / 2;
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,FastPyramidUp2X,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  lineSrc = imgStart + 2 * h * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      lineDst[w] = lineSrc[2 * w];                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,FastPyramidUp2X,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  lineSrc = imgStart + 2 * h * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      lineDst[w] = lineSrc[2 * w];                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,Copy,The following statement contains a magic number: UnmanagedImageConverter.Copy((byte*)from' (byte*)to' 4 * length);
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,ToBitmapCore,The following statement contains a magic number: UnmanagedImageConverter.Copy(src' dst' width * 4);
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,ToGrayscaleImage,The following statement contains a magic number: return ToGrayscaleImage(0.299' 0.587' 0.114);
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,ToGrayscaleImage,The following statement contains a magic number: return ToGrayscaleImage(0.299' 0.587' 0.114);
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,ToGrayscaleImage,The following statement contains a magic number: return ToGrayscaleImage(0.299' 0.587' 0.114);
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,ToGrayscaleImage,The following statement contains a magic number: return ToGrayscaleImage(0.299' 0.587' 0.114' transparentColor);
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,ToGrayscaleImage,The following statement contains a magic number: return ToGrayscaleImage(0.299' 0.587' 0.114' transparentColor);
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,ToGrayscaleImage,The following statement contains a magic number: return ToGrayscaleImage(0.299' 0.587' 0.114' transparentColor);
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,ToGrayscaleImage,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1 << 10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)((bCache[p->Red] + gCache[p->Green] + rCache[p->Red]) >> 10);                        p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,ToGrayscaleImage,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1 << 10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)((bCache[p->Red] + gCache[p->Green] + rCache[p->Red]) >> 10);                        p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,ToGrayscaleImage,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1 << 10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)((bCache[p->Red] + gCache[p->Green] + rCache[p->Red]) >> 10);                        p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,ToGrayscaleImage,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1 << 10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)((bCache[p->Red] + gCache[p->Green] + rCache[p->Red]) >> 10);                        p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,ToGrayscaleImage,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1 << 10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)((bCache[p->Red] + gCache[p->Green] + rCache[p->Red]) >> 10);                        p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,ToGrayscaleImage,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1 << 10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)((bCache[p->Red] + gCache[p->Green] + rCache[p->Red]) >> 10);                        p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,ToGrayscaleImage,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1 << 10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)((bCache[p->Red] + gCache[p->Green] + rCache[p->Red]) >> 10);                        p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageArgb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,CombineAlpha,The following statement contains a magic number: while (srcLine < endSrcLine)              {                  Argb32* pSrc = srcLine;                  Argb32* endPSrc = pSrc + copyWidth;                  Argb32* pDst = dstLine;                  while (pSrc < endPSrc)                  {                      Argb32 p0 = *pSrc;                      Argb32 p1 = *pDst;                      switch (p0.Alpha)                      {                          case 255:                              *pDst = p0;                              break;                          case 0:                          default:                              break;                      }                      pSrc++;                      pDst++;                  }                  srcLine += srcWidth;                  dstLine += dstWidth;              }
Magic Number,Geb.Image,Argb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,ToGray,The following statement contains a magic number: return (Byte)(0.299 * Red + 0.587 * Green + 0.114 * Blue);
Magic Number,Geb.Image,Argb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,ToGray,The following statement contains a magic number: return (Byte)(0.299 * Red + 0.587 * Green + 0.114 * Blue);
Magic Number,Geb.Image,Argb32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageArgb32_Csmacro.cs,ToGray,The following statement contains a magic number: return (Byte)(0.299 * Red + 0.587 * Green + 0.114 * Blue);
Magic Number,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,ToImageU8,The following statement contains a magic number: float coeff = max > 255 ? 255f / max : 0;
Magic Number,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,CreateFromBitmap,The following statement contains a magic number: const int PixelFormat32bppCMYK = 8207;
Magic Number,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,ApplyModeFilter,The following statement contains a magic number: if (size <= 1) throw new ArgumentOutOfRangeException("size 必须大于1.");              else if (size > 127) throw new ArgumentOutOfRangeException("size 最大为127.");              else if (size % 2 == 0) throw new ArgumentException("size 应该是奇数.");
Magic Number,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,ApplyModeFilter,The following statement contains a magic number: if (size <= 1) throw new ArgumentOutOfRangeException("size 必须大于1.");              else if (size > 127) throw new ArgumentOutOfRangeException("size 最大为127.");              else if (size % 2 == 0) throw new ArgumentException("size 应该是奇数.");
Magic Number,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,ApplyModeFilter,The following statement contains a magic number: int radius = size / 2;
Magic Number,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,DrawLine,The following statement contains a magic number: int n2dy = dy * 2;
Magic Number,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,DrawLine,The following statement contains a magic number: int n2dydx = (dy - dx) * 2;
Magic Number,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,DrawLine,The following statement contains a magic number: int d = dy * 2 - dx;
Magic Number,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,DrawLine,The following statement contains a magic number: if (Math.Abs(deltaX) < 0.0001)              {                  if (Math.Abs(deltaY) < 0.0001)                  {                      SetColor(start.X' start.Y' color' radius' ww' hh);                      return;                  };                    float yStart = start.Y;                  float yEnd = end.Y;                  float x = start.X;                    if (yEnd < yStart)                  {                      float tmp = yEnd;                      yEnd = yStart;                      yStart = tmp;                  }                    yStart = Math.Max(0' yStart);                  yEnd = Math.Min(hh' yEnd);                    for (float y = yStart; y <= yEnd; y++)                  {                      SetColor(x' y' color' radius' ww' hh);                  }              }              else              {                  float xStart = start.X;                  float xEnd = end.X;                  if (xEnd < xStart)                  {                      float tmp = xEnd;                      xEnd = xStart;                      xStart = tmp;                  }                    float step = 1;                  float grad = Math.Abs(deltaY / deltaX);                  if (grad > 1)                  {                      step = 1 / grad;                  }                    for (float x = xStart; x <= xEnd; x += step)                  {                      float deltaXX = start.X - x;                      float deltaYY = deltaY * (deltaXX / deltaX);                      float y = start.Y - deltaYY;                        SetColor(x' y' color' radius' ww' hh);                  }              }
Magic Number,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,DrawLine,The following statement contains a magic number: if (Math.Abs(deltaX) < 0.0001)              {                  if (Math.Abs(deltaY) < 0.0001)                  {                      SetColor(start.X' start.Y' color' radius' ww' hh);                      return;                  };                    float yStart = start.Y;                  float yEnd = end.Y;                  float x = start.X;                    if (yEnd < yStart)                  {                      float tmp = yEnd;                      yEnd = yStart;                      yStart = tmp;                  }                    yStart = Math.Max(0' yStart);                  yEnd = Math.Min(hh' yEnd);                    for (float y = yStart; y <= yEnd; y++)                  {                      SetColor(x' y' color' radius' ww' hh);                  }              }              else              {                  float xStart = start.X;                  float xEnd = end.X;                  if (xEnd < xStart)                  {                      float tmp = xEnd;                      xEnd = xStart;                      xStart = tmp;                  }                    float step = 1;                  float grad = Math.Abs(deltaY / deltaX);                  if (grad > 1)                  {                      step = 1 / grad;                  }                    for (float x = xStart; x <= xEnd; x += step)                  {                      float deltaXX = start.X - x;                      float deltaYY = deltaY * (deltaXX / deltaX);                      float y = start.Y - deltaYY;                        SetColor(x' y' color' radius' ww' hh);                  }              }
Magic Number,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,DrawText,The following statement contains a magic number: int base_line = +(ascii[0] & 15);
Magic Number,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,DrawText,The following statement contains a magic number: List<PointS> pts = new List<PointS>(1 << 10);
Magic Number,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,DrawText,The following statement contains a magic number: for (int i = 0; i < txt.Length; i++)              {                  Char c = txt[i];                  if (c >= 127 || c < ' ')                      c = '?';                  String fontData = faces[ascii[(c - ' ') + 1]];                    PointS p = new PointS();                  p.X = (short)(fontData[0] - 'R');                  p.Y = (short)(fontData[1] - 'R');                  double dx = p.Y * hscale;                  view_x -= p.X * hscale;                  pts.Clear();                  for (int k = 2; k <= fontData.Length; )                  {                      if (k == fontData.Length || fontData[k] == ' ')                      {                          // Draw Poly Line                          if (pts.Count > 1)                          {                              for (int j = 1; j < pts.Count; j++)                              {                                  DrawLine(pts[j - 1].ToPointF()' pts[j].ToPointF()' color);                              }                          }                          pts.Clear();                          k++;                      }                      else                      {                          p.X = (short)(fontData[k] - 'R');                          p.Y = (short)(fontData[k+1] - 'R');                          k += 2;                          pts.Add(new PointS((short)Math.Round(p.X * hscale + view_x)'                              (short)Math.Round(p.Y * vscale + view_y)));                      }                  }                    view_x += dx;              }
Magic Number,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,DrawText,The following statement contains a magic number: for (int i = 0; i < txt.Length; i++)              {                  Char c = txt[i];                  if (c >= 127 || c < ' ')                      c = '?';                  String fontData = faces[ascii[(c - ' ') + 1]];                    PointS p = new PointS();                  p.X = (short)(fontData[0] - 'R');                  p.Y = (short)(fontData[1] - 'R');                  double dx = p.Y * hscale;                  view_x -= p.X * hscale;                  pts.Clear();                  for (int k = 2; k <= fontData.Length; )                  {                      if (k == fontData.Length || fontData[k] == ' ')                      {                          // Draw Poly Line                          if (pts.Count > 1)                          {                              for (int j = 1; j < pts.Count; j++)                              {                                  DrawLine(pts[j - 1].ToPointF()' pts[j].ToPointF()' color);                              }                          }                          pts.Clear();                          k++;                      }                      else                      {                          p.X = (short)(fontData[k] - 'R');                          p.Y = (short)(fontData[k+1] - 'R');                          k += 2;                          pts.Add(new PointS((short)Math.Round(p.X * hscale + view_x)'                              (short)Math.Round(p.Y * vscale + view_y)));                      }                  }                    view_x += dx;              }
Magic Number,Geb.Image,ImageGrad,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageGrad.cs,DrawText,The following statement contains a magic number: for (int i = 0; i < txt.Length; i++)              {                  Char c = txt[i];                  if (c >= 127 || c < ' ')                      c = '?';                  String fontData = faces[ascii[(c - ' ') + 1]];                    PointS p = new PointS();                  p.X = (short)(fontData[0] - 'R');                  p.Y = (short)(fontData[1] - 'R');                  double dx = p.Y * hscale;                  view_x -= p.X * hscale;                  pts.Clear();                  for (int k = 2; k <= fontData.Length; )                  {                      if (k == fontData.Length || fontData[k] == ' ')                      {                          // Draw Poly Line                          if (pts.Count > 1)                          {                              for (int j = 1; j < pts.Count; j++)                              {                                  DrawLine(pts[j - 1].ToPointF()' pts[j].ToPointF()' color);                              }                          }                          pts.Clear();                          k++;                      }                      else                      {                          p.X = (short)(fontData[k] - 'R');                          p.Y = (short)(fontData[k+1] - 'R');                          k += 2;                          pts.Add(new PointS((short)Math.Round(p.X * hscale + view_x)'                              (short)Math.Round(p.Y * vscale + view_y)));                      }                  }                    view_x += dx;              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,CreateFromBitmap,The following statement contains a magic number: const int PixelFormat32bppCMYK = 8207;
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ApplyModeFilter,The following statement contains a magic number: if (size <= 1) throw new ArgumentOutOfRangeException("size 必须大于1.");              else if (size > 127) throw new ArgumentOutOfRangeException("size 最大为127.");              else if (size % 2 == 0) throw new ArgumentException("size 应该是奇数.");
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ApplyModeFilter,The following statement contains a magic number: if (size <= 1) throw new ArgumentOutOfRangeException("size 必须大于1.");              else if (size > 127) throw new ArgumentOutOfRangeException("size 最大为127.");              else if (size % 2 == 0) throw new ArgumentException("size 应该是奇数.");
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ApplyModeFilter,The following statement contains a magic number: int radius = size / 2;
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,DrawLine,The following statement contains a magic number: int n2dy = dy * 2;
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,DrawLine,The following statement contains a magic number: int n2dydx = (dy - dx) * 2;
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,DrawLine,The following statement contains a magic number: int d = dy * 2 - dx;
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,DrawLine,The following statement contains a magic number: if (Math.Abs(deltaX) < 0.0001)              {                  if (Math.Abs(deltaY) < 0.0001)                  {                      SetColor(start.X' start.Y' color' radius' ww' hh);                      return;                  };                    float yStart = start.Y;                  float yEnd = end.Y;                  float x = start.X;                    if (yEnd < yStart)                  {                      float tmp = yEnd;                      yEnd = yStart;                      yStart = tmp;                  }                    yStart = Math.Max(0' yStart);                  yEnd = Math.Min(hh' yEnd);                    for (float y = yStart; y <= yEnd; y++)                  {                      SetColor(x' y' color' radius' ww' hh);                  }              }              else              {                  float xStart = start.X;                  float xEnd = end.X;                  if (xEnd < xStart)                  {                      float tmp = xEnd;                      xEnd = xStart;                      xStart = tmp;                  }                    float step = 1;                  float grad = Math.Abs(deltaY / deltaX);                  if (grad > 1)                  {                      step = 1 / grad;                  }                    for (float x = xStart; x <= xEnd; x += step)                  {                      float deltaXX = start.X - x;                      float deltaYY = deltaY * (deltaXX / deltaX);                      float y = start.Y - deltaYY;                        SetColor(x' y' color' radius' ww' hh);                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,DrawLine,The following statement contains a magic number: if (Math.Abs(deltaX) < 0.0001)              {                  if (Math.Abs(deltaY) < 0.0001)                  {                      SetColor(start.X' start.Y' color' radius' ww' hh);                      return;                  };                    float yStart = start.Y;                  float yEnd = end.Y;                  float x = start.X;                    if (yEnd < yStart)                  {                      float tmp = yEnd;                      yEnd = yStart;                      yStart = tmp;                  }                    yStart = Math.Max(0' yStart);                  yEnd = Math.Min(hh' yEnd);                    for (float y = yStart; y <= yEnd; y++)                  {                      SetColor(x' y' color' radius' ww' hh);                  }              }              else              {                  float xStart = start.X;                  float xEnd = end.X;                  if (xEnd < xStart)                  {                      float tmp = xEnd;                      xEnd = xStart;                      xStart = tmp;                  }                    float step = 1;                  float grad = Math.Abs(deltaY / deltaX);                  if (grad > 1)                  {                      step = 1 / grad;                  }                    for (float x = xStart; x <= xEnd; x += step)                  {                      float deltaXX = start.X - x;                      float deltaYY = deltaY * (deltaXX / deltaX);                      float y = start.Y - deltaYY;                        SetColor(x' y' color' radius' ww' hh);                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,DrawText,The following statement contains a magic number: int base_line = +(ascii[0] & 15);
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,DrawText,The following statement contains a magic number: List<PointS> pts = new List<PointS>(1 << 10);
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,DrawText,The following statement contains a magic number: for (int i = 0; i < txt.Length; i++)              {                  Char c = txt[i];                  if (c >= 127 || c < ' ')                      c = '?';                  String fontData = faces[ascii[(c - ' ') + 1]];                    PointS p = new PointS();                  p.X = (short)(fontData[0] - 'R');                  p.Y = (short)(fontData[1] - 'R');                  double dx = p.Y * hscale;                  view_x -= p.X * hscale;                  pts.Clear();                  for (int k = 2; k <= fontData.Length; )                  {                      if (k == fontData.Length || fontData[k] == ' ')                      {                          // Draw Poly Line                          if (pts.Count > 1)                          {                              for (int j = 1; j < pts.Count; j++)                              {                                  DrawLine(pts[j - 1].ToPointF()' pts[j].ToPointF()' color);                              }                          }                          pts.Clear();                          k++;                      }                      else                      {                          p.X = (short)(fontData[k] - 'R');                          p.Y = (short)(fontData[k+1] - 'R');                          k += 2;                          pts.Add(new PointS((short)Math.Round(p.X * hscale + view_x)'                              (short)Math.Round(p.Y * vscale + view_y)));                      }                  }                    view_x += dx;              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,DrawText,The following statement contains a magic number: for (int i = 0; i < txt.Length; i++)              {                  Char c = txt[i];                  if (c >= 127 || c < ' ')                      c = '?';                  String fontData = faces[ascii[(c - ' ') + 1]];                    PointS p = new PointS();                  p.X = (short)(fontData[0] - 'R');                  p.Y = (short)(fontData[1] - 'R');                  double dx = p.Y * hscale;                  view_x -= p.X * hscale;                  pts.Clear();                  for (int k = 2; k <= fontData.Length; )                  {                      if (k == fontData.Length || fontData[k] == ' ')                      {                          // Draw Poly Line                          if (pts.Count > 1)                          {                              for (int j = 1; j < pts.Count; j++)                              {                                  DrawLine(pts[j - 1].ToPointF()' pts[j].ToPointF()' color);                              }                          }                          pts.Clear();                          k++;                      }                      else                      {                          p.X = (short)(fontData[k] - 'R');                          p.Y = (short)(fontData[k+1] - 'R');                          k += 2;                          pts.Add(new PointS((short)Math.Round(p.X * hscale + view_x)'                              (short)Math.Round(p.Y * vscale + view_y)));                      }                  }                    view_x += dx;              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,DrawText,The following statement contains a magic number: for (int i = 0; i < txt.Length; i++)              {                  Char c = txt[i];                  if (c >= 127 || c < ' ')                      c = '?';                  String fontData = faces[ascii[(c - ' ') + 1]];                    PointS p = new PointS();                  p.X = (short)(fontData[0] - 'R');                  p.Y = (short)(fontData[1] - 'R');                  double dx = p.Y * hscale;                  view_x -= p.X * hscale;                  pts.Clear();                  for (int k = 2; k <= fontData.Length; )                  {                      if (k == fontData.Length || fontData[k] == ' ')                      {                          // Draw Poly Line                          if (pts.Count > 1)                          {                              for (int j = 1; j < pts.Count; j++)                              {                                  DrawLine(pts[j - 1].ToPointF()' pts[j].ToPointF()' color);                              }                          }                          pts.Clear();                          k++;                      }                      else                      {                          p.X = (short)(fontData[k] - 'R');                          p.Y = (short)(fontData[k+1] - 'R');                          k += 2;                          pts.Add(new PointS((short)Math.Round(p.X * hscale + view_x)'                              (short)Math.Round(p.Y * vscale + view_y)));                      }                  }                    view_x += dx;              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ApplyConvolution,The following statement contains a magic number: int extend = Math.Max(kernelWidth' kernelHeight) / 2;
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ApplyConvolution,The following statement contains a magic number: TImage maskImage = new TImage(Width + extend * 2' Height + extend * 2);
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ApplyConvolution,The following statement contains a magic number: TImage maskImage = new TImage(Width + extend * 2' Height + extend * 2);
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ApplyConvolution,The following statement contains a magic number: int extendWidth = this.Width + extend * 2;
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ApplyConvolution,The following statement contains a magic number: int extendHeight = this.Height + extend * 2;
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,Copy,The following statement contains a magic number: UnmanagedImageConverter.Copy((Byte*)from' (Byte*)to' length * 4);
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ToBitmapCore,The following statement contains a magic number: while (start != end)              {                  Int32 val = *start;                  val = val < 0 ? 0 : val > 255 ? 255 : val;                  *dst = (byte)val;                  start++;                  dst++;              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ToBitmapCore,The following statement contains a magic number: while (start != end)              {                  Int32 val = *start;                  val = val < 0 ? 0 : val > 255 ? 255 : val;                  *dst = (byte)val;                  start++;                  dst++;              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ToImageRgb24WithRamdomColorMap,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  int val = this[i];                  if (map.ContainsKey(val))                  {                      img[i] = map[val];                  }                  else                  {                      Rgb24 newRgb = new Rgb24();                      newRgb.Red = (byte)(r.Next(256));                      newRgb.Green = (byte)(r.Next(256));                      newRgb.Blue = (byte)(r.Next(256));                      img[i] = newRgb;                      map.Add(val' newRgb);                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ToImageRgb24WithRamdomColorMap,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  int val = this[i];                  if (map.ContainsKey(val))                  {                      img[i] = map[val];                  }                  else                  {                      Rgb24 newRgb = new Rgb24();                      newRgb.Red = (byte)(r.Next(256));                      newRgb.Green = (byte)(r.Next(256));                      newRgb.Blue = (byte)(r.Next(256));                      img[i] = newRgb;                      map.Add(val' newRgb);                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ToImageRgb24WithRamdomColorMap,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  int val = this[i];                  if (map.ContainsKey(val))                  {                      img[i] = map[val];                  }                  else                  {                      Rgb24 newRgb = new Rgb24();                      newRgb.Red = (byte)(r.Next(256));                      newRgb.Green = (byte)(r.Next(256));                      newRgb.Blue = (byte)(r.Next(256));                      img[i] = newRgb;                      map.Add(val' newRgb);                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ToHypsometricMap,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  Int32 val = start[i];                  if (useBgVal && bgVal == val)                  {                      rgb0[i] = bgColor;                  }                  else                  {                      // hsv => rgb                        double h = (val - min) * step + hueOfMinVal;                      double s = 1;                      double v = 1;                        while (h < 0) { h += 360; };                      while (h >= 360) { h -= 360; };                        double r' g' b;                      double hf = h / 60.0;                      int floor = (int)Math.Floor(hf);                      double f = hf - floor;                      double pv = v * (1 - s);                      double qv = v * (1 - s * f);                      double tv = v * (1 - s * (1 - f));                      switch (floor)                      {                          case 0:                              r = v;                              g = tv;                              b = pv;                              break;                          case 1:                              r = qv;                              g = v;                              b = pv;                              break;                          case 2:                              r = pv;                              g = v;                              b = tv;                              break;                          case 3:                              r = pv;                              g = qv;                              b = v;                              break;                          case 4:                              r = tv;                              g = pv;                              b = v;                              break;                          case 5:                              r = v;                              g = pv;                              b = qv;                              break;                          case 6:                              r = v;                              g = tv;                              b = pv;                              break;                          case -1:                              r = v;                              g = pv;                              b = qv;                              break;                          default:                              r = g = b = v; // Just pretend its black/white                              break;                      }                      int red = (int)(r * 255.0);                      int green = (int)(g * 255.0);                      int blue = (int)(b * 255.0);                      red = Math.Min(255' Math.Max(0' red));                      green = Math.Min(255' Math.Max(0' green));                      blue = Math.Min(255' Math.Max(0' blue));                      rgb0[i] = new Rgb24(red' green' blue);                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ToHypsometricMap,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  Int32 val = start[i];                  if (useBgVal && bgVal == val)                  {                      rgb0[i] = bgColor;                  }                  else                  {                      // hsv => rgb                        double h = (val - min) * step + hueOfMinVal;                      double s = 1;                      double v = 1;                        while (h < 0) { h += 360; };                      while (h >= 360) { h -= 360; };                        double r' g' b;                      double hf = h / 60.0;                      int floor = (int)Math.Floor(hf);                      double f = hf - floor;                      double pv = v * (1 - s);                      double qv = v * (1 - s * f);                      double tv = v * (1 - s * (1 - f));                      switch (floor)                      {                          case 0:                              r = v;                              g = tv;                              b = pv;                              break;                          case 1:                              r = qv;                              g = v;                              b = pv;                              break;                          case 2:                              r = pv;                              g = v;                              b = tv;                              break;                          case 3:                              r = pv;                              g = qv;                              b = v;                              break;                          case 4:                              r = tv;                              g = pv;                              b = v;                              break;                          case 5:                              r = v;                              g = pv;                              b = qv;                              break;                          case 6:                              r = v;                              g = tv;                              b = pv;                              break;                          case -1:                              r = v;                              g = pv;                              b = qv;                              break;                          default:                              r = g = b = v; // Just pretend its black/white                              break;                      }                      int red = (int)(r * 255.0);                      int green = (int)(g * 255.0);                      int blue = (int)(b * 255.0);                      red = Math.Min(255' Math.Max(0' red));                      green = Math.Min(255' Math.Max(0' green));                      blue = Math.Min(255' Math.Max(0' blue));                      rgb0[i] = new Rgb24(red' green' blue);                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ToHypsometricMap,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  Int32 val = start[i];                  if (useBgVal && bgVal == val)                  {                      rgb0[i] = bgColor;                  }                  else                  {                      // hsv => rgb                        double h = (val - min) * step + hueOfMinVal;                      double s = 1;                      double v = 1;                        while (h < 0) { h += 360; };                      while (h >= 360) { h -= 360; };                        double r' g' b;                      double hf = h / 60.0;                      int floor = (int)Math.Floor(hf);                      double f = hf - floor;                      double pv = v * (1 - s);                      double qv = v * (1 - s * f);                      double tv = v * (1 - s * (1 - f));                      switch (floor)                      {                          case 0:                              r = v;                              g = tv;                              b = pv;                              break;                          case 1:                              r = qv;                              g = v;                              b = pv;                              break;                          case 2:                              r = pv;                              g = v;                              b = tv;                              break;                          case 3:                              r = pv;                              g = qv;                              b = v;                              break;                          case 4:                              r = tv;                              g = pv;                              b = v;                              break;                          case 5:                              r = v;                              g = pv;                              b = qv;                              break;                          case 6:                              r = v;                              g = tv;                              b = pv;                              break;                          case -1:                              r = v;                              g = pv;                              b = qv;                              break;                          default:                              r = g = b = v; // Just pretend its black/white                              break;                      }                      int red = (int)(r * 255.0);                      int green = (int)(g * 255.0);                      int blue = (int)(b * 255.0);                      red = Math.Min(255' Math.Max(0' red));                      green = Math.Min(255' Math.Max(0' green));                      blue = Math.Min(255' Math.Max(0' blue));                      rgb0[i] = new Rgb24(red' green' blue);                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ToHypsometricMap,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  Int32 val = start[i];                  if (useBgVal && bgVal == val)                  {                      rgb0[i] = bgColor;                  }                  else                  {                      // hsv => rgb                        double h = (val - min) * step + hueOfMinVal;                      double s = 1;                      double v = 1;                        while (h < 0) { h += 360; };                      while (h >= 360) { h -= 360; };                        double r' g' b;                      double hf = h / 60.0;                      int floor = (int)Math.Floor(hf);                      double f = hf - floor;                      double pv = v * (1 - s);                      double qv = v * (1 - s * f);                      double tv = v * (1 - s * (1 - f));                      switch (floor)                      {                          case 0:                              r = v;                              g = tv;                              b = pv;                              break;                          case 1:                              r = qv;                              g = v;                              b = pv;                              break;                          case 2:                              r = pv;                              g = v;                              b = tv;                              break;                          case 3:                              r = pv;                              g = qv;                              b = v;                              break;                          case 4:                              r = tv;                              g = pv;                              b = v;                              break;                          case 5:                              r = v;                              g = pv;                              b = qv;                              break;                          case 6:                              r = v;                              g = tv;                              b = pv;                              break;                          case -1:                              r = v;                              g = pv;                              b = qv;                              break;                          default:                              r = g = b = v; // Just pretend its black/white                              break;                      }                      int red = (int)(r * 255.0);                      int green = (int)(g * 255.0);                      int blue = (int)(b * 255.0);                      red = Math.Min(255' Math.Max(0' red));                      green = Math.Min(255' Math.Max(0' green));                      blue = Math.Min(255' Math.Max(0' blue));                      rgb0[i] = new Rgb24(red' green' blue);                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ToHypsometricMap,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  Int32 val = start[i];                  if (useBgVal && bgVal == val)                  {                      rgb0[i] = bgColor;                  }                  else                  {                      // hsv => rgb                        double h = (val - min) * step + hueOfMinVal;                      double s = 1;                      double v = 1;                        while (h < 0) { h += 360; };                      while (h >= 360) { h -= 360; };                        double r' g' b;                      double hf = h / 60.0;                      int floor = (int)Math.Floor(hf);                      double f = hf - floor;                      double pv = v * (1 - s);                      double qv = v * (1 - s * f);                      double tv = v * (1 - s * (1 - f));                      switch (floor)                      {                          case 0:                              r = v;                              g = tv;                              b = pv;                              break;                          case 1:                              r = qv;                              g = v;                              b = pv;                              break;                          case 2:                              r = pv;                              g = v;                              b = tv;                              break;                          case 3:                              r = pv;                              g = qv;                              b = v;                              break;                          case 4:                              r = tv;                              g = pv;                              b = v;                              break;                          case 5:                              r = v;                              g = pv;                              b = qv;                              break;                          case 6:                              r = v;                              g = tv;                              b = pv;                              break;                          case -1:                              r = v;                              g = pv;                              b = qv;                              break;                          default:                              r = g = b = v; // Just pretend its black/white                              break;                      }                      int red = (int)(r * 255.0);                      int green = (int)(g * 255.0);                      int blue = (int)(b * 255.0);                      red = Math.Min(255' Math.Max(0' red));                      green = Math.Min(255' Math.Max(0' green));                      blue = Math.Min(255' Math.Max(0' blue));                      rgb0[i] = new Rgb24(red' green' blue);                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ToHypsometricMap,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  Int32 val = start[i];                  if (useBgVal && bgVal == val)                  {                      rgb0[i] = bgColor;                  }                  else                  {                      // hsv => rgb                        double h = (val - min) * step + hueOfMinVal;                      double s = 1;                      double v = 1;                        while (h < 0) { h += 360; };                      while (h >= 360) { h -= 360; };                        double r' g' b;                      double hf = h / 60.0;                      int floor = (int)Math.Floor(hf);                      double f = hf - floor;                      double pv = v * (1 - s);                      double qv = v * (1 - s * f);                      double tv = v * (1 - s * (1 - f));                      switch (floor)                      {                          case 0:                              r = v;                              g = tv;                              b = pv;                              break;                          case 1:                              r = qv;                              g = v;                              b = pv;                              break;                          case 2:                              r = pv;                              g = v;                              b = tv;                              break;                          case 3:                              r = pv;                              g = qv;                              b = v;                              break;                          case 4:                              r = tv;                              g = pv;                              b = v;                              break;                          case 5:                              r = v;                              g = pv;                              b = qv;                              break;                          case 6:                              r = v;                              g = tv;                              b = pv;                              break;                          case -1:                              r = v;                              g = pv;                              b = qv;                              break;                          default:                              r = g = b = v; // Just pretend its black/white                              break;                      }                      int red = (int)(r * 255.0);                      int green = (int)(g * 255.0);                      int blue = (int)(b * 255.0);                      red = Math.Min(255' Math.Max(0' red));                      green = Math.Min(255' Math.Max(0' green));                      blue = Math.Min(255' Math.Max(0' blue));                      rgb0[i] = new Rgb24(red' green' blue);                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ToHypsometricMap,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  Int32 val = start[i];                  if (useBgVal && bgVal == val)                  {                      rgb0[i] = bgColor;                  }                  else                  {                      // hsv => rgb                        double h = (val - min) * step + hueOfMinVal;                      double s = 1;                      double v = 1;                        while (h < 0) { h += 360; };                      while (h >= 360) { h -= 360; };                        double r' g' b;                      double hf = h / 60.0;                      int floor = (int)Math.Floor(hf);                      double f = hf - floor;                      double pv = v * (1 - s);                      double qv = v * (1 - s * f);                      double tv = v * (1 - s * (1 - f));                      switch (floor)                      {                          case 0:                              r = v;                              g = tv;                              b = pv;                              break;                          case 1:                              r = qv;                              g = v;                              b = pv;                              break;                          case 2:                              r = pv;                              g = v;                              b = tv;                              break;                          case 3:                              r = pv;                              g = qv;                              b = v;                              break;                          case 4:                              r = tv;                              g = pv;                              b = v;                              break;                          case 5:                              r = v;                              g = pv;                              b = qv;                              break;                          case 6:                              r = v;                              g = tv;                              b = pv;                              break;                          case -1:                              r = v;                              g = pv;                              b = qv;                              break;                          default:                              r = g = b = v; // Just pretend its black/white                              break;                      }                      int red = (int)(r * 255.0);                      int green = (int)(g * 255.0);                      int blue = (int)(b * 255.0);                      red = Math.Min(255' Math.Max(0' red));                      green = Math.Min(255' Math.Max(0' green));                      blue = Math.Min(255' Math.Max(0' blue));                      rgb0[i] = new Rgb24(red' green' blue);                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ToHypsometricMap,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  Int32 val = start[i];                  if (useBgVal && bgVal == val)                  {                      rgb0[i] = bgColor;                  }                  else                  {                      // hsv => rgb                        double h = (val - min) * step + hueOfMinVal;                      double s = 1;                      double v = 1;                        while (h < 0) { h += 360; };                      while (h >= 360) { h -= 360; };                        double r' g' b;                      double hf = h / 60.0;                      int floor = (int)Math.Floor(hf);                      double f = hf - floor;                      double pv = v * (1 - s);                      double qv = v * (1 - s * f);                      double tv = v * (1 - s * (1 - f));                      switch (floor)                      {                          case 0:                              r = v;                              g = tv;                              b = pv;                              break;                          case 1:                              r = qv;                              g = v;                              b = pv;                              break;                          case 2:                              r = pv;                              g = v;                              b = tv;                              break;                          case 3:                              r = pv;                              g = qv;                              b = v;                              break;                          case 4:                              r = tv;                              g = pv;                              b = v;                              break;                          case 5:                              r = v;                              g = pv;                              b = qv;                              break;                          case 6:                              r = v;                              g = tv;                              b = pv;                              break;                          case -1:                              r = v;                              g = pv;                              b = qv;                              break;                          default:                              r = g = b = v; // Just pretend its black/white                              break;                      }                      int red = (int)(r * 255.0);                      int green = (int)(g * 255.0);                      int blue = (int)(b * 255.0);                      red = Math.Min(255' Math.Max(0' red));                      green = Math.Min(255' Math.Max(0' green));                      blue = Math.Min(255' Math.Max(0' blue));                      rgb0[i] = new Rgb24(red' green' blue);                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ToHypsometricMap,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  Int32 val = start[i];                  if (useBgVal && bgVal == val)                  {                      rgb0[i] = bgColor;                  }                  else                  {                      // hsv => rgb                        double h = (val - min) * step + hueOfMinVal;                      double s = 1;                      double v = 1;                        while (h < 0) { h += 360; };                      while (h >= 360) { h -= 360; };                        double r' g' b;                      double hf = h / 60.0;                      int floor = (int)Math.Floor(hf);                      double f = hf - floor;                      double pv = v * (1 - s);                      double qv = v * (1 - s * f);                      double tv = v * (1 - s * (1 - f));                      switch (floor)                      {                          case 0:                              r = v;                              g = tv;                              b = pv;                              break;                          case 1:                              r = qv;                              g = v;                              b = pv;                              break;                          case 2:                              r = pv;                              g = v;                              b = tv;                              break;                          case 3:                              r = pv;                              g = qv;                              b = v;                              break;                          case 4:                              r = tv;                              g = pv;                              b = v;                              break;                          case 5:                              r = v;                              g = pv;                              b = qv;                              break;                          case 6:                              r = v;                              g = tv;                              b = pv;                              break;                          case -1:                              r = v;                              g = pv;                              b = qv;                              break;                          default:                              r = g = b = v; // Just pretend its black/white                              break;                      }                      int red = (int)(r * 255.0);                      int green = (int)(g * 255.0);                      int blue = (int)(b * 255.0);                      red = Math.Min(255' Math.Max(0' red));                      green = Math.Min(255' Math.Max(0' green));                      blue = Math.Min(255' Math.Max(0' blue));                      rgb0[i] = new Rgb24(red' green' blue);                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ToHypsometricMap,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  Int32 val = start[i];                  if (useBgVal && bgVal == val)                  {                      rgb0[i] = bgColor;                  }                  else                  {                      // hsv => rgb                        double h = (val - min) * step + hueOfMinVal;                      double s = 1;                      double v = 1;                        while (h < 0) { h += 360; };                      while (h >= 360) { h -= 360; };                        double r' g' b;                      double hf = h / 60.0;                      int floor = (int)Math.Floor(hf);                      double f = hf - floor;                      double pv = v * (1 - s);                      double qv = v * (1 - s * f);                      double tv = v * (1 - s * (1 - f));                      switch (floor)                      {                          case 0:                              r = v;                              g = tv;                              b = pv;                              break;                          case 1:                              r = qv;                              g = v;                              b = pv;                              break;                          case 2:                              r = pv;                              g = v;                              b = tv;                              break;                          case 3:                              r = pv;                              g = qv;                              b = v;                              break;                          case 4:                              r = tv;                              g = pv;                              b = v;                              break;                          case 5:                              r = v;                              g = pv;                              b = qv;                              break;                          case 6:                              r = v;                              g = tv;                              b = pv;                              break;                          case -1:                              r = v;                              g = pv;                              b = qv;                              break;                          default:                              r = g = b = v; // Just pretend its black/white                              break;                      }                      int red = (int)(r * 255.0);                      int green = (int)(g * 255.0);                      int blue = (int)(b * 255.0);                      red = Math.Min(255' Math.Max(0' red));                      green = Math.Min(255' Math.Max(0' green));                      blue = Math.Min(255' Math.Max(0' blue));                      rgb0[i] = new Rgb24(red' green' blue);                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ToHypsometricMap,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  Int32 val = start[i];                  if (useBgVal && bgVal == val)                  {                      rgb0[i] = bgColor;                  }                  else                  {                      // hsv => rgb                        double h = (val - min) * step + hueOfMinVal;                      double s = 1;                      double v = 1;                        while (h < 0) { h += 360; };                      while (h >= 360) { h -= 360; };                        double r' g' b;                      double hf = h / 60.0;                      int floor = (int)Math.Floor(hf);                      double f = hf - floor;                      double pv = v * (1 - s);                      double qv = v * (1 - s * f);                      double tv = v * (1 - s * (1 - f));                      switch (floor)                      {                          case 0:                              r = v;                              g = tv;                              b = pv;                              break;                          case 1:                              r = qv;                              g = v;                              b = pv;                              break;                          case 2:                              r = pv;                              g = v;                              b = tv;                              break;                          case 3:                              r = pv;                              g = qv;                              b = v;                              break;                          case 4:                              r = tv;                              g = pv;                              b = v;                              break;                          case 5:                              r = v;                              g = pv;                              b = qv;                              break;                          case 6:                              r = v;                              g = tv;                              b = pv;                              break;                          case -1:                              r = v;                              g = pv;                              b = qv;                              break;                          default:                              r = g = b = v; // Just pretend its black/white                              break;                      }                      int red = (int)(r * 255.0);                      int green = (int)(g * 255.0);                      int blue = (int)(b * 255.0);                      red = Math.Min(255' Math.Max(0' red));                      green = Math.Min(255' Math.Max(0' green));                      blue = Math.Min(255' Math.Max(0' blue));                      rgb0[i] = new Rgb24(red' green' blue);                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ToHypsometricMap,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  Int32 val = start[i];                  if (useBgVal && bgVal == val)                  {                      rgb0[i] = bgColor;                  }                  else                  {                      // hsv => rgb                        double h = (val - min) * step + hueOfMinVal;                      double s = 1;                      double v = 1;                        while (h < 0) { h += 360; };                      while (h >= 360) { h -= 360; };                        double r' g' b;                      double hf = h / 60.0;                      int floor = (int)Math.Floor(hf);                      double f = hf - floor;                      double pv = v * (1 - s);                      double qv = v * (1 - s * f);                      double tv = v * (1 - s * (1 - f));                      switch (floor)                      {                          case 0:                              r = v;                              g = tv;                              b = pv;                              break;                          case 1:                              r = qv;                              g = v;                              b = pv;                              break;                          case 2:                              r = pv;                              g = v;                              b = tv;                              break;                          case 3:                              r = pv;                              g = qv;                              b = v;                              break;                          case 4:                              r = tv;                              g = pv;                              b = v;                              break;                          case 5:                              r = v;                              g = pv;                              b = qv;                              break;                          case 6:                              r = v;                              g = tv;                              b = pv;                              break;                          case -1:                              r = v;                              g = pv;                              b = qv;                              break;                          default:                              r = g = b = v; // Just pretend its black/white                              break;                      }                      int red = (int)(r * 255.0);                      int green = (int)(g * 255.0);                      int blue = (int)(b * 255.0);                      red = Math.Min(255' Math.Max(0' red));                      green = Math.Min(255' Math.Max(0' green));                      blue = Math.Min(255' Math.Max(0' blue));                      rgb0[i] = new Rgb24(red' green' blue);                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ToHypsometricMap,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  Int32 val = start[i];                  if (useBgVal && bgVal == val)                  {                      rgb0[i] = bgColor;                  }                  else                  {                      // hsv => rgb                        double h = (val - min) * step + hueOfMinVal;                      double s = 1;                      double v = 1;                        while (h < 0) { h += 360; };                      while (h >= 360) { h -= 360; };                        double r' g' b;                      double hf = h / 60.0;                      int floor = (int)Math.Floor(hf);                      double f = hf - floor;                      double pv = v * (1 - s);                      double qv = v * (1 - s * f);                      double tv = v * (1 - s * (1 - f));                      switch (floor)                      {                          case 0:                              r = v;                              g = tv;                              b = pv;                              break;                          case 1:                              r = qv;                              g = v;                              b = pv;                              break;                          case 2:                              r = pv;                              g = v;                              b = tv;                              break;                          case 3:                              r = pv;                              g = qv;                              b = v;                              break;                          case 4:                              r = tv;                              g = pv;                              b = v;                              break;                          case 5:                              r = v;                              g = pv;                              b = qv;                              break;                          case 6:                              r = v;                              g = tv;                              b = pv;                              break;                          case -1:                              r = v;                              g = pv;                              b = qv;                              break;                          default:                              r = g = b = v; // Just pretend its black/white                              break;                      }                      int red = (int)(r * 255.0);                      int green = (int)(g * 255.0);                      int blue = (int)(b * 255.0);                      red = Math.Min(255' Math.Max(0' red));                      green = Math.Min(255' Math.Max(0' green));                      blue = Math.Min(255' Math.Max(0' blue));                      rgb0[i] = new Rgb24(red' green' blue);                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ToHypsometricMap,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  Int32 val = start[i];                  if (useBgVal && bgVal == val)                  {                      rgb0[i] = bgColor;                  }                  else                  {                      // hsv => rgb                        double h = (val - min) * step + hueOfMinVal;                      double s = 1;                      double v = 1;                        while (h < 0) { h += 360; };                      while (h >= 360) { h -= 360; };                        double r' g' b;                      double hf = h / 60.0;                      int floor = (int)Math.Floor(hf);                      double f = hf - floor;                      double pv = v * (1 - s);                      double qv = v * (1 - s * f);                      double tv = v * (1 - s * (1 - f));                      switch (floor)                      {                          case 0:                              r = v;                              g = tv;                              b = pv;                              break;                          case 1:                              r = qv;                              g = v;                              b = pv;                              break;                          case 2:                              r = pv;                              g = v;                              b = tv;                              break;                          case 3:                              r = pv;                              g = qv;                              b = v;                              break;                          case 4:                              r = tv;                              g = pv;                              b = v;                              break;                          case 5:                              r = v;                              g = pv;                              b = qv;                              break;                          case 6:                              r = v;                              g = tv;                              b = pv;                              break;                          case -1:                              r = v;                              g = pv;                              b = qv;                              break;                          default:                              r = g = b = v; // Just pretend its black/white                              break;                      }                      int red = (int)(r * 255.0);                      int green = (int)(g * 255.0);                      int blue = (int)(b * 255.0);                      red = Math.Min(255' Math.Max(0' red));                      green = Math.Min(255' Math.Max(0' green));                      blue = Math.Min(255' Math.Max(0' blue));                      rgb0[i] = new Rgb24(red' green' blue);                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ToHypsometricMap,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  Int32 val = start[i];                  if (useBgVal && bgVal == val)                  {                      rgb0[i] = bgColor;                  }                  else                  {                      // hsv => rgb                        double h = (val - min) * step + hueOfMinVal;                      double s = 1;                      double v = 1;                        while (h < 0) { h += 360; };                      while (h >= 360) { h -= 360; };                        double r' g' b;                      double hf = h / 60.0;                      int floor = (int)Math.Floor(hf);                      double f = hf - floor;                      double pv = v * (1 - s);                      double qv = v * (1 - s * f);                      double tv = v * (1 - s * (1 - f));                      switch (floor)                      {                          case 0:                              r = v;                              g = tv;                              b = pv;                              break;                          case 1:                              r = qv;                              g = v;                              b = pv;                              break;                          case 2:                              r = pv;                              g = v;                              b = tv;                              break;                          case 3:                              r = pv;                              g = qv;                              b = v;                              break;                          case 4:                              r = tv;                              g = pv;                              b = v;                              break;                          case 5:                              r = v;                              g = pv;                              b = qv;                              break;                          case 6:                              r = v;                              g = tv;                              b = pv;                              break;                          case -1:                              r = v;                              g = pv;                              b = qv;                              break;                          default:                              r = g = b = v; // Just pretend its black/white                              break;                      }                      int red = (int)(r * 255.0);                      int green = (int)(g * 255.0);                      int blue = (int)(b * 255.0);                      red = Math.Min(255' Math.Max(0' red));                      green = Math.Min(255' Math.Max(0' green));                      blue = Math.Min(255' Math.Max(0' blue));                      rgb0[i] = new Rgb24(red' green' blue);                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ToImageU8,The following statement contains a magic number: while (start != end)              {                  int val = *start;                  *dst = val < 0 ? (Byte)0 : (val > 255 ? (Byte)255 : (Byte)val);                  start++;                  dst++;              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ToImageU8,The following statement contains a magic number: while (start != end)              {                  int val = *start;                  *dst = val < 0 ? (Byte)0 : (val > 255 ? (Byte)255 : (Byte)val);                  start++;                  dst++;              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ApplyDistanceTransformFast,The following statement contains a magic number: for (int h = height - 2; h > 0; h--)              {                  Int32* line0 = start + (h - 1) * width;                  Int32* line1 = start + (h) * width;                  Int32* line2 = start + (h + 1) * width;                    for (int w = width - 2; w >= 0; w--)                  {                      if (line1[w] > 0)                      {                          val = Math.Min(line0[w + 1]' line1[w + 1]);                          val = Math.Min(val' line2[w + 1]);                          val = Math.Min(val' line2[w]);                          val = Math.Min(val + 1' line1[w]);                          line1[w] = val;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,ApplyDistanceTransformFast,The following statement contains a magic number: for (int h = height - 2; h > 0; h--)              {                  Int32* line0 = start + (h - 1) * width;                  Int32* line1 = start + (h) * width;                  Int32* line2 = start + (h + 1) * width;                    for (int w = width - 2; w >= 0; w--)                  {                      if (line1[w] > 0)                      {                          val = Math.Min(line0[w + 1]' line1[w + 1]);                          val = Math.Min(val' line2[w + 1]);                          val = Math.Min(val' line2[w]);                          val = Math.Min(val + 1' line1[w]);                          line1[w] = val;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: int ww = width / 2;
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: int hh = height / 2;
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,ImageInt32,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageInt32_Csmacro.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            Int32* p = lineSrc + wSrc - 2 * width;                            Int32 p00 = p[-2];                          Int32 p01 = p[-1];                          Int32 p02 = p[0];                          Int32 p03 = p[1];                          Int32 p04 = p[2];                            p += width;                          Int32 p10 = p[-2];                          Int32 p11 = p[-1];                          Int32 p12 = p[0];                          Int32 p13 = p[1];                          Int32 p14 = p[2];                            p += width;                          Int32 p20 = p[-2];                          Int32 p21 = p[-1];                          Int32 p22 = p[0];                          Int32 p23 = p[1];                          Int32 p24 = p[2];                            p += width;                          Int32 p30 = p[-2];                          Int32 p31 = p[-1];                          Int32 p32 = p[0];                          Int32 p33 = p[1];                          Int32 p34 = p[2];                            p += width;                          Int32 p40 = p[-2];                          Int32 p41 = p[-1];                          Int32 p42 = p[0];                          Int32 p43 = p[1];                          Int32 p44 = p[2];                            int val =                                1 * p00 + 04 * p01 + 06 * p02 + 04 * p03 + 1 * p04                              + 4 * p10 + 16 * p11 + 24 * p12 + 16 * p13 + 4 * p14                              + 6 * p20 + 24 * p21 + 36 * p22 + 24 * p23 + 6 * p24                              + 4 * p30 + 16 * p31 + 24 * p32 + 16 * p33 + 4 * p34                              + 1 * p40 + 04 * p41 + 06 * p42 + 04 * p43 + 1 * p44;                            lineDst[w] = val >> 8;                      }                  }              }
Magic Number,Geb.Image,Lab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,GetDistanceSquare,The following statement contains a magic number: return (int)(0.16 * deltaL * deltaL) + deltaA * deltaA + deltaB * deltaB;
Magic Number,Geb.Image,Lab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,ConvertTest,The following statement contains a magic number: for (int r = 0; r < 256; r += 2)              {                  for (int g = 0; g < 256; g += 2)                  {                      for (int b = 0; b < 256; b += 2)                      {                          Rgb24 src = new Rgb24(r' g' b);                          Lab24 dst = Lab24.CreateFrom(src);                          Rgb24 rvt = dst.ToRgb24();                          if (Math.Abs(src.Red - rvt.Red) + Math.Abs(src.Green - rvt.Green) + Math.Abs(src.Blue - rvt.Blue) > 16)                          {                              error = true;                          }                        }                  }              }
Magic Number,Geb.Image,Lab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,ConvertTest,The following statement contains a magic number: for (int r = 0; r < 256; r += 2)              {                  for (int g = 0; g < 256; g += 2)                  {                      for (int b = 0; b < 256; b += 2)                      {                          Rgb24 src = new Rgb24(r' g' b);                          Lab24 dst = Lab24.CreateFrom(src);                          Rgb24 rvt = dst.ToRgb24();                          if (Math.Abs(src.Red - rvt.Red) + Math.Abs(src.Green - rvt.Green) + Math.Abs(src.Blue - rvt.Blue) > 16)                          {                              error = true;                          }                        }                  }              }
Magic Number,Geb.Image,Lab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,ConvertTest,The following statement contains a magic number: for (int r = 0; r < 256; r += 2)              {                  for (int g = 0; g < 256; g += 2)                  {                      for (int b = 0; b < 256; b += 2)                      {                          Rgb24 src = new Rgb24(r' g' b);                          Lab24 dst = Lab24.CreateFrom(src);                          Rgb24 rvt = dst.ToRgb24();                          if (Math.Abs(src.Red - rvt.Red) + Math.Abs(src.Green - rvt.Green) + Math.Abs(src.Blue - rvt.Blue) > 16)                          {                              error = true;                          }                        }                  }              }
Magic Number,Geb.Image,Lab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,ConvertTest,The following statement contains a magic number: for (int r = 0; r < 256; r += 2)              {                  for (int g = 0; g < 256; g += 2)                  {                      for (int b = 0; b < 256; b += 2)                      {                          Rgb24 src = new Rgb24(r' g' b);                          Lab24 dst = Lab24.CreateFrom(src);                          Rgb24 rvt = dst.ToRgb24();                          if (Math.Abs(src.Red - rvt.Red) + Math.Abs(src.Green - rvt.Green) + Math.Abs(src.Blue - rvt.Blue) > 16)                          {                              error = true;                          }                        }                  }              }
Magic Number,Geb.Image,Lab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,ConvertTest,The following statement contains a magic number: for (int r = 0; r < 256; r += 2)              {                  for (int g = 0; g < 256; g += 2)                  {                      for (int b = 0; b < 256; b += 2)                      {                          Rgb24 src = new Rgb24(r' g' b);                          Lab24 dst = Lab24.CreateFrom(src);                          Rgb24 rvt = dst.ToRgb24();                          if (Math.Abs(src.Red - rvt.Red) + Math.Abs(src.Green - rvt.Green) + Math.Abs(src.Blue - rvt.Blue) > 16)                          {                              error = true;                          }                        }                  }              }
Magic Number,Geb.Image,Lab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,ConvertTest,The following statement contains a magic number: for (int r = 0; r < 256; r += 2)              {                  for (int g = 0; g < 256; g += 2)                  {                      for (int b = 0; b < 256; b += 2)                      {                          Rgb24 src = new Rgb24(r' g' b);                          Lab24 dst = Lab24.CreateFrom(src);                          Rgb24 rvt = dst.ToRgb24();                          if (Math.Abs(src.Red - rvt.Red) + Math.Abs(src.Green - rvt.Green) + Math.Abs(src.Blue - rvt.Blue) > 16)                          {                              error = true;                          }                        }                  }              }
Magic Number,Geb.Image,Lab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,ConvertTest,The following statement contains a magic number: for (int r = 0; r < 256; r += 2)              {                  for (int g = 0; g < 256; g += 2)                  {                      for (int b = 0; b < 256; b += 2)                      {                          Rgb24 src = new Rgb24(r' g' b);                          Lab24 dst = Lab24.CreateFrom(src);                          Rgb24 rvt = dst.ToRgb24();                          if (Math.Abs(src.Red - rvt.Red) + Math.Abs(src.Green - rvt.Green) + Math.Abs(src.Blue - rvt.Blue) > 16)                          {                              error = true;                          }                        }                  }              }
Magic Number,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,CreateFromBitmap,The following statement contains a magic number: const int PixelFormat32bppCMYK = 8207;
Magic Number,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,ApplyModeFilter,The following statement contains a magic number: if (size <= 1) throw new ArgumentOutOfRangeException("size 必须大于1.");              else if (size > 127) throw new ArgumentOutOfRangeException("size 最大为127.");              else if (size % 2 == 0) throw new ArgumentException("size 应该是奇数.");
Magic Number,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,ApplyModeFilter,The following statement contains a magic number: if (size <= 1) throw new ArgumentOutOfRangeException("size 必须大于1.");              else if (size > 127) throw new ArgumentOutOfRangeException("size 最大为127.");              else if (size % 2 == 0) throw new ArgumentException("size 应该是奇数.");
Magic Number,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,ApplyModeFilter,The following statement contains a magic number: int radius = size / 2;
Magic Number,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,DrawLine,The following statement contains a magic number: int n2dy = dy * 2;
Magic Number,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,DrawLine,The following statement contains a magic number: int n2dydx = (dy - dx) * 2;
Magic Number,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,DrawLine,The following statement contains a magic number: int d = dy * 2 - dx;
Magic Number,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,DrawLine,The following statement contains a magic number: if (Math.Abs(deltaX) < 0.0001)              {                  if (Math.Abs(deltaY) < 0.0001)                  {                      SetColor(start.X' start.Y' color' radius' ww' hh);                      return;                  };                    float yStart = start.Y;                  float yEnd = end.Y;                  float x = start.X;                    if (yEnd < yStart)                  {                      float tmp = yEnd;                      yEnd = yStart;                      yStart = tmp;                  }                    yStart = Math.Max(0' yStart);                  yEnd = Math.Min(hh' yEnd);                    for (float y = yStart; y <= yEnd; y++)                  {                      SetColor(x' y' color' radius' ww' hh);                  }              }              else              {                  float xStart = start.X;                  float xEnd = end.X;                  if (xEnd < xStart)                  {                      float tmp = xEnd;                      xEnd = xStart;                      xStart = tmp;                  }                    float step = 1;                  float grad = Math.Abs(deltaY / deltaX);                  if (grad > 1)                  {                      step = 1 / grad;                  }                    for (float x = xStart; x <= xEnd; x += step)                  {                      float deltaXX = start.X - x;                      float deltaYY = deltaY * (deltaXX / deltaX);                      float y = start.Y - deltaYY;                        SetColor(x' y' color' radius' ww' hh);                  }              }
Magic Number,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,DrawLine,The following statement contains a magic number: if (Math.Abs(deltaX) < 0.0001)              {                  if (Math.Abs(deltaY) < 0.0001)                  {                      SetColor(start.X' start.Y' color' radius' ww' hh);                      return;                  };                    float yStart = start.Y;                  float yEnd = end.Y;                  float x = start.X;                    if (yEnd < yStart)                  {                      float tmp = yEnd;                      yEnd = yStart;                      yStart = tmp;                  }                    yStart = Math.Max(0' yStart);                  yEnd = Math.Min(hh' yEnd);                    for (float y = yStart; y <= yEnd; y++)                  {                      SetColor(x' y' color' radius' ww' hh);                  }              }              else              {                  float xStart = start.X;                  float xEnd = end.X;                  if (xEnd < xStart)                  {                      float tmp = xEnd;                      xEnd = xStart;                      xStart = tmp;                  }                    float step = 1;                  float grad = Math.Abs(deltaY / deltaX);                  if (grad > 1)                  {                      step = 1 / grad;                  }                    for (float x = xStart; x <= xEnd; x += step)                  {                      float deltaXX = start.X - x;                      float deltaYY = deltaY * (deltaXX / deltaX);                      float y = start.Y - deltaYY;                        SetColor(x' y' color' radius' ww' hh);                  }              }
Magic Number,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,DrawText,The following statement contains a magic number: int base_line = +(ascii[0] & 15);
Magic Number,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,DrawText,The following statement contains a magic number: List<PointS> pts = new List<PointS>(1 << 10);
Magic Number,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,DrawText,The following statement contains a magic number: for (int i = 0; i < txt.Length; i++)              {                  Char c = txt[i];                  if (c >= 127 || c < ' ')                      c = '?';                  String fontData = faces[ascii[(c - ' ') + 1]];                    PointS p = new PointS();                  p.X = (short)(fontData[0] - 'R');                  p.Y = (short)(fontData[1] - 'R');                  double dx = p.Y * hscale;                  view_x -= p.X * hscale;                  pts.Clear();                  for (int k = 2; k <= fontData.Length; )                  {                      if (k == fontData.Length || fontData[k] == ' ')                      {                          // Draw Poly Line                          if (pts.Count > 1)                          {                              for (int j = 1; j < pts.Count; j++)                              {                                  DrawLine(pts[j - 1].ToPointF()' pts[j].ToPointF()' color);                              }                          }                          pts.Clear();                          k++;                      }                      else                      {                          p.X = (short)(fontData[k] - 'R');                          p.Y = (short)(fontData[k+1] - 'R');                          k += 2;                          pts.Add(new PointS((short)Math.Round(p.X * hscale + view_x)'                              (short)Math.Round(p.Y * vscale + view_y)));                      }                  }                    view_x += dx;              }
Magic Number,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,DrawText,The following statement contains a magic number: for (int i = 0; i < txt.Length; i++)              {                  Char c = txt[i];                  if (c >= 127 || c < ' ')                      c = '?';                  String fontData = faces[ascii[(c - ' ') + 1]];                    PointS p = new PointS();                  p.X = (short)(fontData[0] - 'R');                  p.Y = (short)(fontData[1] - 'R');                  double dx = p.Y * hscale;                  view_x -= p.X * hscale;                  pts.Clear();                  for (int k = 2; k <= fontData.Length; )                  {                      if (k == fontData.Length || fontData[k] == ' ')                      {                          // Draw Poly Line                          if (pts.Count > 1)                          {                              for (int j = 1; j < pts.Count; j++)                              {                                  DrawLine(pts[j - 1].ToPointF()' pts[j].ToPointF()' color);                              }                          }                          pts.Clear();                          k++;                      }                      else                      {                          p.X = (short)(fontData[k] - 'R');                          p.Y = (short)(fontData[k+1] - 'R');                          k += 2;                          pts.Add(new PointS((short)Math.Round(p.X * hscale + view_x)'                              (short)Math.Round(p.Y * vscale + view_y)));                      }                  }                    view_x += dx;              }
Magic Number,Geb.Image,ImageLab24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageLab24.cs,DrawText,The following statement contains a magic number: for (int i = 0; i < txt.Length; i++)              {                  Char c = txt[i];                  if (c >= 127 || c < ' ')                      c = '?';                  String fontData = faces[ascii[(c - ' ') + 1]];                    PointS p = new PointS();                  p.X = (short)(fontData[0] - 'R');                  p.Y = (short)(fontData[1] - 'R');                  double dx = p.Y * hscale;                  view_x -= p.X * hscale;                  pts.Clear();                  for (int k = 2; k <= fontData.Length; )                  {                      if (k == fontData.Length || fontData[k] == ' ')                      {                          // Draw Poly Line                          if (pts.Count > 1)                          {                              for (int j = 1; j < pts.Count; j++)                              {                                  DrawLine(pts[j - 1].ToPointF()' pts[j].ToPointF()' color);                              }                          }                          pts.Clear();                          k++;                      }                      else                      {                          p.X = (short)(fontData[k] - 'R');                          p.Y = (short)(fontData[k+1] - 'R');                          k += 2;                          pts.Add(new PointS((short)Math.Round(p.X * hscale + view_x)'                              (short)Math.Round(p.Y * vscale + view_y)));                      }                  }                    view_x += dx;              }
Magic Number,Geb.Image,SignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,ToGray,The following statement contains a magic number: return (Byte)(0.299 * Red + 0.587 * Green + 0.114 * Blue);
Magic Number,Geb.Image,SignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,ToGray,The following statement contains a magic number: return (Byte)(0.299 * Red + 0.587 * Green + 0.114 * Blue);
Magic Number,Geb.Image,SignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,ToGray,The following statement contains a magic number: return (Byte)(0.299 * Red + 0.587 * Green + 0.114 * Blue);
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,ToGrayscaleImage,The following statement contains a magic number: return ToGrayscaleImage(0.299' 0.587' 0.114);
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,ToGrayscaleImage,The following statement contains a magic number: return ToGrayscaleImage(0.299' 0.587' 0.114);
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,ToGrayscaleImage,The following statement contains a magic number: return ToGrayscaleImage(0.299' 0.587' 0.114);
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,ToGrayscaleImage,The following statement contains a magic number: return ToGrayscaleImage(0.299' 0.587' 0.114' transparentColor);
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,ToGrayscaleImage,The following statement contains a magic number: return ToGrayscaleImage(0.299' 0.587' 0.114' transparentColor);
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,ToGrayscaleImage,The following statement contains a magic number: return ToGrayscaleImage(0.299' 0.587' 0.114' transparentColor);
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,ToGrayscaleImage,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1 << 10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)((bCache[p->Red] + gCache[p->Green] + rCache[p->Red]) >> 10);                        p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,ToGrayscaleImage,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1 << 10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)((bCache[p->Red] + gCache[p->Green] + rCache[p->Red]) >> 10);                        p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,ToGrayscaleImage,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1 << 10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)((bCache[p->Red] + gCache[p->Green] + rCache[p->Red]) >> 10);                        p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,ToGrayscaleImage,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1 << 10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)((bCache[p->Red] + gCache[p->Green] + rCache[p->Red]) >> 10);                        p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,ToGrayscaleImage,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1 << 10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)((bCache[p->Red] + gCache[p->Green] + rCache[p->Red]) >> 10);                        p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,ToGrayscaleImage,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1 << 10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)((bCache[p->Red] + gCache[p->Green] + rCache[p->Red]) >> 10);                        p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,ToGrayscaleImage,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1 << 10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)((bCache[p->Red] + gCache[p->Green] + rCache[p->Red]) >> 10);                        p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,Mix,The following statement contains a magic number: while (p != end)              {                  p->Blue = (short)((p0->Blue + p1->Blue)/2);                  p->Green = (short)((p0->Green + p1->Green) / 2);                  p->Red = (short)((p0->Red + p1->Red)/2);                  p->Alpha = (short)((p0->Alpha + p1->Alpha)/2);                  p++;                  p0++;                  p1++;              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,Mix,The following statement contains a magic number: while (p != end)              {                  p->Blue = (short)((p0->Blue + p1->Blue)/2);                  p->Green = (short)((p0->Green + p1->Green) / 2);                  p->Red = (short)((p0->Red + p1->Red)/2);                  p->Alpha = (short)((p0->Alpha + p1->Alpha)/2);                  p++;                  p0++;                  p1++;              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,Mix,The following statement contains a magic number: while (p != end)              {                  p->Blue = (short)((p0->Blue + p1->Blue)/2);                  p->Green = (short)((p0->Green + p1->Green) / 2);                  p->Red = (short)((p0->Red + p1->Red)/2);                  p->Alpha = (short)((p0->Alpha + p1->Alpha)/2);                  p++;                  p0++;                  p1++;              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,Mix,The following statement contains a magic number: while (p != end)              {                  p->Blue = (short)((p0->Blue + p1->Blue)/2);                  p->Green = (short)((p0->Green + p1->Green) / 2);                  p->Red = (short)((p0->Red + p1->Red)/2);                  p->Alpha = (short)((p0->Alpha + p1->Alpha)/2);                  p++;                  p0++;                  p1++;              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,MixInPlace,The following statement contains a magic number: while (p0 != end)              {                  int coeff0 = *pMask;                  int coeff1 = 256 - coeff0;                    p0->Blue = (short)((p0->Blue * coeff0 + p1->Blue * coeff1) / 256);                  p0->Green = (short)((p0->Green * coeff0 + p1->Green * coeff1) / 256);                  p0->Red = (short)((p0->Red * coeff0 + p1->Red * coeff1) / 256);                    p0++;                  p1++;                  pMask++;              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,MixInPlace,The following statement contains a magic number: while (p0 != end)              {                  int coeff0 = *pMask;                  int coeff1 = 256 - coeff0;                    p0->Blue = (short)((p0->Blue * coeff0 + p1->Blue * coeff1) / 256);                  p0->Green = (short)((p0->Green * coeff0 + p1->Green * coeff1) / 256);                  p0->Red = (short)((p0->Red * coeff0 + p1->Red * coeff1) / 256);                    p0++;                  p1++;                  pMask++;              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,MixInPlace,The following statement contains a magic number: while (p0 != end)              {                  int coeff0 = *pMask;                  int coeff1 = 256 - coeff0;                    p0->Blue = (short)((p0->Blue * coeff0 + p1->Blue * coeff1) / 256);                  p0->Green = (short)((p0->Green * coeff0 + p1->Green * coeff1) / 256);                  p0->Red = (short)((p0->Red * coeff0 + p1->Red * coeff1) / 256);                    p0++;                  p1++;                  pMask++;              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,MixInPlace,The following statement contains a magic number: while (p0 != end)              {                  int coeff0 = *pMask;                  int coeff1 = 256 - coeff0;                    p0->Blue = (short)((p0->Blue * coeff0 + p1->Blue * coeff1) / 256);                  p0->Green = (short)((p0->Green * coeff0 + p1->Green * coeff1) / 256);                  p0->Red = (short)((p0->Red * coeff0 + p1->Red * coeff1) / 256);                    p0++;                  p1++;                  pMask++;              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,MixInPlace,The following statement contains a magic number: int coeff1 = 256 - frontRatio;
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,MixInPlace,The following statement contains a magic number: while (p0 != end)              {                  p0->Blue = (short)((p0->Blue * coeff0 + p1->Blue * coeff1) / 256);                  p0->Green = (short)((p0->Green * coeff0 + p1->Green * coeff1) / 256);                  p0->Red = (short)((p0->Red * coeff0 + p1->Red * coeff1) / 256);                  p0++;                  p1++;              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,MixInPlace,The following statement contains a magic number: while (p0 != end)              {                  p0->Blue = (short)((p0->Blue * coeff0 + p1->Blue * coeff1) / 256);                  p0->Green = (short)((p0->Green * coeff0 + p1->Green * coeff1) / 256);                  p0->Red = (short)((p0->Red * coeff0 + p1->Red * coeff1) / 256);                  p0++;                  p1++;              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,MixInPlace,The following statement contains a magic number: while (p0 != end)              {                  p0->Blue = (short)((p0->Blue * coeff0 + p1->Blue * coeff1) / 256);                  p0->Green = (short)((p0->Green * coeff0 + p1->Green * coeff1) / 256);                  p0->Red = (short)((p0->Red * coeff0 + p1->Red * coeff1) / 256);                  p0++;                  p1++;              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,CreateFromBitmap,The following statement contains a magic number: const int PixelFormat32bppCMYK = 8207;
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,ApplyModeFilter,The following statement contains a magic number: if (size <= 1) throw new ArgumentOutOfRangeException("size 必须大于1.");              else if (size > 127) throw new ArgumentOutOfRangeException("size 最大为127.");              else if (size % 2 == 0) throw new ArgumentException("size 应该是奇数.");
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,ApplyModeFilter,The following statement contains a magic number: if (size <= 1) throw new ArgumentOutOfRangeException("size 必须大于1.");              else if (size > 127) throw new ArgumentOutOfRangeException("size 最大为127.");              else if (size % 2 == 0) throw new ArgumentException("size 应该是奇数.");
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,ApplyModeFilter,The following statement contains a magic number: int radius = size / 2;
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,DrawLine,The following statement contains a magic number: int n2dy = dy * 2;
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,DrawLine,The following statement contains a magic number: int n2dydx = (dy - dx) * 2;
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,DrawLine,The following statement contains a magic number: int d = dy * 2 - dx;
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,DrawLine,The following statement contains a magic number: if (Math.Abs(deltaX) < 0.0001)              {                  if (Math.Abs(deltaY) < 0.0001)                  {                      SetColor(start.X' start.Y' color' radius' ww' hh);                      return;                  };                    float yStart = start.Y;                  float yEnd = end.Y;                  float x = start.X;                    if (yEnd < yStart)                  {                      float tmp = yEnd;                      yEnd = yStart;                      yStart = tmp;                  }                    yStart = Math.Max(0' yStart);                  yEnd = Math.Min(hh' yEnd);                    for (float y = yStart; y <= yEnd; y++)                  {                      SetColor(x' y' color' radius' ww' hh);                  }              }              else              {                  float xStart = start.X;                  float xEnd = end.X;                  if (xEnd < xStart)                  {                      float tmp = xEnd;                      xEnd = xStart;                      xStart = tmp;                  }                    float step = 1;                  float grad = Math.Abs(deltaY / deltaX);                  if (grad > 1)                  {                      step = 1 / grad;                  }                    for (float x = xStart; x <= xEnd; x += step)                  {                      float deltaXX = start.X - x;                      float deltaYY = deltaY * (deltaXX / deltaX);                      float y = start.Y - deltaYY;                        SetColor(x' y' color' radius' ww' hh);                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,DrawLine,The following statement contains a magic number: if (Math.Abs(deltaX) < 0.0001)              {                  if (Math.Abs(deltaY) < 0.0001)                  {                      SetColor(start.X' start.Y' color' radius' ww' hh);                      return;                  };                    float yStart = start.Y;                  float yEnd = end.Y;                  float x = start.X;                    if (yEnd < yStart)                  {                      float tmp = yEnd;                      yEnd = yStart;                      yStart = tmp;                  }                    yStart = Math.Max(0' yStart);                  yEnd = Math.Min(hh' yEnd);                    for (float y = yStart; y <= yEnd; y++)                  {                      SetColor(x' y' color' radius' ww' hh);                  }              }              else              {                  float xStart = start.X;                  float xEnd = end.X;                  if (xEnd < xStart)                  {                      float tmp = xEnd;                      xEnd = xStart;                      xStart = tmp;                  }                    float step = 1;                  float grad = Math.Abs(deltaY / deltaX);                  if (grad > 1)                  {                      step = 1 / grad;                  }                    for (float x = xStart; x <= xEnd; x += step)                  {                      float deltaXX = start.X - x;                      float deltaYY = deltaY * (deltaXX / deltaX);                      float y = start.Y - deltaYY;                        SetColor(x' y' color' radius' ww' hh);                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,DrawText,The following statement contains a magic number: int base_line = +(ascii[0] & 15);
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,DrawText,The following statement contains a magic number: List<PointS> pts = new List<PointS>(1 << 10);
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,DrawText,The following statement contains a magic number: for (int i = 0; i < txt.Length; i++)              {                  Char c = txt[i];                  if (c >= 127 || c < ' ')                      c = '?';                  String fontData = faces[ascii[(c - ' ') + 1]];                    PointS p = new PointS();                  p.X = (short)(fontData[0] - 'R');                  p.Y = (short)(fontData[1] - 'R');                  double dx = p.Y * hscale;                  view_x -= p.X * hscale;                  pts.Clear();                  for (int k = 2; k <= fontData.Length; )                  {                      if (k == fontData.Length || fontData[k] == ' ')                      {                          // Draw Poly Line                          if (pts.Count > 1)                          {                              for (int j = 1; j < pts.Count; j++)                              {                                  DrawLine(pts[j - 1].ToPointF()' pts[j].ToPointF()' color);                              }                          }                          pts.Clear();                          k++;                      }                      else                      {                          p.X = (short)(fontData[k] - 'R');                          p.Y = (short)(fontData[k+1] - 'R');                          k += 2;                          pts.Add(new PointS((short)Math.Round(p.X * hscale + view_x)'                              (short)Math.Round(p.Y * vscale + view_y)));                      }                  }                    view_x += dx;              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,DrawText,The following statement contains a magic number: for (int i = 0; i < txt.Length; i++)              {                  Char c = txt[i];                  if (c >= 127 || c < ' ')                      c = '?';                  String fontData = faces[ascii[(c - ' ') + 1]];                    PointS p = new PointS();                  p.X = (short)(fontData[0] - 'R');                  p.Y = (short)(fontData[1] - 'R');                  double dx = p.Y * hscale;                  view_x -= p.X * hscale;                  pts.Clear();                  for (int k = 2; k <= fontData.Length; )                  {                      if (k == fontData.Length || fontData[k] == ' ')                      {                          // Draw Poly Line                          if (pts.Count > 1)                          {                              for (int j = 1; j < pts.Count; j++)                              {                                  DrawLine(pts[j - 1].ToPointF()' pts[j].ToPointF()' color);                              }                          }                          pts.Clear();                          k++;                      }                      else                      {                          p.X = (short)(fontData[k] - 'R');                          p.Y = (short)(fontData[k+1] - 'R');                          k += 2;                          pts.Add(new PointS((short)Math.Round(p.X * hscale + view_x)'                              (short)Math.Round(p.Y * vscale + view_y)));                      }                  }                    view_x += dx;              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,DrawText,The following statement contains a magic number: for (int i = 0; i < txt.Length; i++)              {                  Char c = txt[i];                  if (c >= 127 || c < ' ')                      c = '?';                  String fontData = faces[ascii[(c - ' ') + 1]];                    PointS p = new PointS();                  p.X = (short)(fontData[0] - 'R');                  p.Y = (short)(fontData[1] - 'R');                  double dx = p.Y * hscale;                  view_x -= p.X * hscale;                  pts.Clear();                  for (int k = 2; k <= fontData.Length; )                  {                      if (k == fontData.Length || fontData[k] == ' ')                      {                          // Draw Poly Line                          if (pts.Count > 1)                          {                              for (int j = 1; j < pts.Count; j++)                              {                                  DrawLine(pts[j - 1].ToPointF()' pts[j].ToPointF()' color);                              }                          }                          pts.Clear();                          k++;                      }                      else                      {                          p.X = (short)(fontData[k] - 'R');                          p.Y = (short)(fontData[k+1] - 'R');                          k += 2;                          pts.Add(new PointS((short)Math.Round(p.X * hscale + view_x)'                              (short)Math.Round(p.Y * vscale + view_y)));                      }                  }                    view_x += dx;              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: int ww = width / 2;
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: int hh = height / 2;
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidDown,The following statement contains a magic number: int ww = width * 2;
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidDown,The following statement contains a magic number: int hh = height * 2;
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 0; h < hh; h += 2)              {                  hSrc = h / 2;                  lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      lineDst[w] = lineSrc[wSrc];                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2'width-2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 0; h < hh; h += 2)              {                  hSrc = h / 2;                  lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      lineDst[w] = lineSrc[wSrc];                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2'width-2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 0; h < hh; h += 2)              {                  hSrc = h / 2;                  lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      lineDst[w] = lineSrc[wSrc];                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2'width-2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 0; h < hh; h += 2)              {                  hSrc = h / 2;                  lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      lineDst[w] = lineSrc[wSrc];                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2'width-2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 0; h < hh; h += 2)              {                  hSrc = h / 2;                  lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      lineDst[w] = lineSrc[wSrc];                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2'width-2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 0; h < hh; h += 2)              {                  hSrc = h / 2;                  lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      lineDst[w] = lineSrc[wSrc];                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2'width-2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 0; h < hh; h += 2)              {                  hSrc = h / 2;                  lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      lineDst[w] = lineSrc[wSrc];                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2'width-2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,FastPyramidUp4X,The following statement contains a magic number: int ww = width / 4;
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,FastPyramidUp4X,The following statement contains a magic number: int hh = height / 4;
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,FastPyramidUp4X,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  lineSrc = imgStart + 4 * h * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      lineDst[w] = lineSrc[4 * w];                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,FastPyramidUp4X,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  lineSrc = imgStart + 4 * h * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      lineDst[w] = lineSrc[4 * w];                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,FastPyramidUp3X,The following statement contains a magic number: int ww = width / 3;
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,FastPyramidUp3X,The following statement contains a magic number: int hh = height / 3;
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,FastPyramidUp3X,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  lineSrc = imgStart +  3 * h * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      lineDst[w] = lineSrc[3 * w];                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,FastPyramidUp3X,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  lineSrc = imgStart +  3 * h * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      lineDst[w] = lineSrc[3 * w];                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,FastPyramidUp2X,The following statement contains a magic number: int ww = width / 2;
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,FastPyramidUp2X,The following statement contains a magic number: int hh = height / 2;
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,FastPyramidUp2X,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  lineSrc = imgStart + 2 * h * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      lineDst[w] = lineSrc[2 * w];                  }              }
Magic Number,Geb.Image,ImageSignedArgb64,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageSignedArgb64.cs,FastPyramidUp2X,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  lineSrc = imgStart + 2 * h * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      lineDst[w] = lineSrc[2 * w];                  }              }
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,CreateFromBitmap,The following statement contains a magic number: const int PixelFormat32bppCMYK = 8207;
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ApplyModeFilter,The following statement contains a magic number: if (size <= 1) throw new ArgumentOutOfRangeException("size 必须大于1.");              else if (size > 127) throw new ArgumentOutOfRangeException("size 最大为127.");              else if (size % 2 == 0) throw new ArgumentException("size 应该是奇数.");
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ApplyModeFilter,The following statement contains a magic number: if (size <= 1) throw new ArgumentOutOfRangeException("size 必须大于1.");              else if (size > 127) throw new ArgumentOutOfRangeException("size 最大为127.");              else if (size % 2 == 0) throw new ArgumentException("size 应该是奇数.");
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ApplyModeFilter,The following statement contains a magic number: int radius = size / 2;
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,DrawLine,The following statement contains a magic number: int n2dy = dy * 2;
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,DrawLine,The following statement contains a magic number: int n2dydx = (dy - dx) * 2;
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,DrawLine,The following statement contains a magic number: int d = dy * 2 - dx;
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,DrawLine,The following statement contains a magic number: if (Math.Abs(deltaX) < 0.0001)              {                  if (Math.Abs(deltaY) < 0.0001)                  {                      SetColor(start.X' start.Y' color' radius' ww' hh);                      return;                  };                    float yStart = start.Y;                  float yEnd = end.Y;                  float x = start.X;                    if (yEnd < yStart)                  {                      float tmp = yEnd;                      yEnd = yStart;                      yStart = tmp;                  }                    yStart = Math.Max(0' yStart);                  yEnd = Math.Min(hh' yEnd);                    for (float y = yStart; y <= yEnd; y++)                  {                      SetColor(x' y' color' radius' ww' hh);                  }              }              else              {                  float xStart = start.X;                  float xEnd = end.X;                  if (xEnd < xStart)                  {                      float tmp = xEnd;                      xEnd = xStart;                      xStart = tmp;                  }                    float step = 1;                  float grad = Math.Abs(deltaY / deltaX);                  if (grad > 1)                  {                      step = 1 / grad;                  }                    for (float x = xStart; x <= xEnd; x += step)                  {                      float deltaXX = start.X - x;                      float deltaYY = deltaY * (deltaXX / deltaX);                      float y = start.Y - deltaYY;                        SetColor(x' y' color' radius' ww' hh);                  }              }
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,DrawLine,The following statement contains a magic number: if (Math.Abs(deltaX) < 0.0001)              {                  if (Math.Abs(deltaY) < 0.0001)                  {                      SetColor(start.X' start.Y' color' radius' ww' hh);                      return;                  };                    float yStart = start.Y;                  float yEnd = end.Y;                  float x = start.X;                    if (yEnd < yStart)                  {                      float tmp = yEnd;                      yEnd = yStart;                      yStart = tmp;                  }                    yStart = Math.Max(0' yStart);                  yEnd = Math.Min(hh' yEnd);                    for (float y = yStart; y <= yEnd; y++)                  {                      SetColor(x' y' color' radius' ww' hh);                  }              }              else              {                  float xStart = start.X;                  float xEnd = end.X;                  if (xEnd < xStart)                  {                      float tmp = xEnd;                      xEnd = xStart;                      xStart = tmp;                  }                    float step = 1;                  float grad = Math.Abs(deltaY / deltaX);                  if (grad > 1)                  {                      step = 1 / grad;                  }                    for (float x = xStart; x <= xEnd; x += step)                  {                      float deltaXX = start.X - x;                      float deltaYY = deltaY * (deltaXX / deltaX);                      float y = start.Y - deltaYY;                        SetColor(x' y' color' radius' ww' hh);                  }              }
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,DrawText,The following statement contains a magic number: int base_line = +(ascii[0] & 15);
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,DrawText,The following statement contains a magic number: List<PointS> pts = new List<PointS>(1 << 10);
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,DrawText,The following statement contains a magic number: for (int i = 0; i < txt.Length; i++)              {                  Char c = txt[i];                  if (c >= 127 || c < ' ')                      c = '?';                  String fontData = faces[ascii[(c - ' ') + 1]];                    PointS p = new PointS();                  p.X = (short)(fontData[0] - 'R');                  p.Y = (short)(fontData[1] - 'R');                  double dx = p.Y * hscale;                  view_x -= p.X * hscale;                  pts.Clear();                  for (int k = 2; k <= fontData.Length; )                  {                      if (k == fontData.Length || fontData[k] == ' ')                      {                          // Draw Poly Line                          if (pts.Count > 1)                          {                              for (int j = 1; j < pts.Count; j++)                              {                                  DrawLine(pts[j - 1].ToPointF()' pts[j].ToPointF()' color);                              }                          }                          pts.Clear();                          k++;                      }                      else                      {                          p.X = (short)(fontData[k] - 'R');                          p.Y = (short)(fontData[k+1] - 'R');                          k += 2;                          pts.Add(new PointS((short)Math.Round(p.X * hscale + view_x)'                              (short)Math.Round(p.Y * vscale + view_y)));                      }                  }                    view_x += dx;              }
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,DrawText,The following statement contains a magic number: for (int i = 0; i < txt.Length; i++)              {                  Char c = txt[i];                  if (c >= 127 || c < ' ')                      c = '?';                  String fontData = faces[ascii[(c - ' ') + 1]];                    PointS p = new PointS();                  p.X = (short)(fontData[0] - 'R');                  p.Y = (short)(fontData[1] - 'R');                  double dx = p.Y * hscale;                  view_x -= p.X * hscale;                  pts.Clear();                  for (int k = 2; k <= fontData.Length; )                  {                      if (k == fontData.Length || fontData[k] == ' ')                      {                          // Draw Poly Line                          if (pts.Count > 1)                          {                              for (int j = 1; j < pts.Count; j++)                              {                                  DrawLine(pts[j - 1].ToPointF()' pts[j].ToPointF()' color);                              }                          }                          pts.Clear();                          k++;                      }                      else                      {                          p.X = (short)(fontData[k] - 'R');                          p.Y = (short)(fontData[k+1] - 'R');                          k += 2;                          pts.Add(new PointS((short)Math.Round(p.X * hscale + view_x)'                              (short)Math.Round(p.Y * vscale + view_y)));                      }                  }                    view_x += dx;              }
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,DrawText,The following statement contains a magic number: for (int i = 0; i < txt.Length; i++)              {                  Char c = txt[i];                  if (c >= 127 || c < ' ')                      c = '?';                  String fontData = faces[ascii[(c - ' ') + 1]];                    PointS p = new PointS();                  p.X = (short)(fontData[0] - 'R');                  p.Y = (short)(fontData[1] - 'R');                  double dx = p.Y * hscale;                  view_x -= p.X * hscale;                  pts.Clear();                  for (int k = 2; k <= fontData.Length; )                  {                      if (k == fontData.Length || fontData[k] == ' ')                      {                          // Draw Poly Line                          if (pts.Count > 1)                          {                              for (int j = 1; j < pts.Count; j++)                              {                                  DrawLine(pts[j - 1].ToPointF()' pts[j].ToPointF()' color);                              }                          }                          pts.Clear();                          k++;                      }                      else                      {                          p.X = (short)(fontData[k] - 'R');                          p.Y = (short)(fontData[k+1] - 'R');                          k += 2;                          pts.Add(new PointS((short)Math.Round(p.X * hscale + view_x)'                              (short)Math.Round(p.Y * vscale + view_y)));                      }                  }                    view_x += dx;              }
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,Copy,The following statement contains a magic number: UnmanagedImageConverter.Copy((byte*)from' (byte*)to' 3 * length);
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ToGrayscaleImage,The following statement contains a magic number: return ToGrayscaleImage(0.299' 0.587' 0.114);
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ToGrayscaleImage,The following statement contains a magic number: return ToGrayscaleImage(0.299' 0.587' 0.114);
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ToGrayscaleImage,The following statement contains a magic number: return ToGrayscaleImage(0.299' 0.587' 0.114);
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ToGrayscaleImageInt32,The following statement contains a magic number: return ToGrayscaleImageInt32(0.299' 0.587' 0.114);
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ToGrayscaleImageInt32,The following statement contains a magic number: return ToGrayscaleImageInt32(0.299' 0.587' 0.114);
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ToGrayscaleImageInt32,The following statement contains a magic number: return ToGrayscaleImageInt32(0.299' 0.587' 0.114);
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,CopyChannel,The following statement contains a magic number: if (channel < 0 && channel > 2) throw new ArgumentOutOfRangeException("channel");
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ToGrayscaleImage,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1<<10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)(( bCache[p->Red] + gCache[p->Green] + rCache[p->Red] ) >> 10);                      p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ToGrayscaleImage,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1<<10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)(( bCache[p->Red] + gCache[p->Green] + rCache[p->Red] ) >> 10);                      p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ToGrayscaleImage,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1<<10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)(( bCache[p->Red] + gCache[p->Green] + rCache[p->Red] ) >> 10);                      p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ToGrayscaleImage,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1<<10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)(( bCache[p->Red] + gCache[p->Green] + rCache[p->Red] ) >> 10);                      p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ToGrayscaleImage,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1<<10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)(( bCache[p->Red] + gCache[p->Green] + rCache[p->Red] ) >> 10);                      p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ToGrayscaleImage,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1<<10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)(( bCache[p->Red] + gCache[p->Green] + rCache[p->Red] ) >> 10);                      p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ToGrayscaleImage,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1<<10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)(( bCache[p->Red] + gCache[p->Green] + rCache[p->Red] ) >> 10);                      p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ToGrayscaleImageInt32,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1 << 10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)((bCache[p->Red] + gCache[p->Green] + rCache[p->Red]) >> 10);                      p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ToGrayscaleImageInt32,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1 << 10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)((bCache[p->Red] + gCache[p->Green] + rCache[p->Red]) >> 10);                      p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ToGrayscaleImageInt32,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1 << 10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)((bCache[p->Red] + gCache[p->Green] + rCache[p->Red]) >> 10);                      p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ToGrayscaleImageInt32,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1 << 10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)((bCache[p->Red] + gCache[p->Green] + rCache[p->Red]) >> 10);                      p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ToGrayscaleImageInt32,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1 << 10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)((bCache[p->Red] + gCache[p->Green] + rCache[p->Red]) >> 10);                      p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ToGrayscaleImageInt32,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1 << 10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)((bCache[p->Red] + gCache[p->Green] + rCache[p->Red]) >> 10);                      p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ToGrayscaleImageInt32,The following statement contains a magic number: if (Length < 1024)              {                  while (p != end)                  {                      *to = (Byte)(p->Red * rCoeff + p->Green * gCoeff + p->Blue * bCoeff);                      p++;                      to++;                  }              }              else              {                  int* bCache = stackalloc int[256];                  int* gCache = stackalloc int[256];                  int* rCache = stackalloc int[256];                    const int shift = 1 << 10;                  int rShift = (int)(rCoeff * shift);                  int gShift = (int)(gCoeff * shift);                  int bShift = shift - rShift - gShift;                    int r = 0' g = 0' b = 0;                  for (int i = 0; i < 256; i++)                  {                      bCache[i] = b;                      gCache[i] = g;                      rCache[i] = r;                      b += bShift;                      g += gShift;                      r += rShift;                  }                    while (p != end)                  {                      *to = (Byte)((bCache[p->Red] + gCache[p->Green] + rCache[p->Red]) >> 10);                      p++;                      to++;                  }              }
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ApplyMedianFilter,The following statement contains a magic number: if (medianRadius > 0)              {                  // 进行中值滤波                  using (ImageRgb24 copy = this.Clone() as ImageRgb24)                  {                      int size = medianRadius * 2 + 1;                      int count = 0;                      byte[] r = new byte[size * size];                      byte[] g = new byte[size * size];                      byte[] b = new byte[size * size];                      int height = this.Height;                      int width = this.Width;                      for (int y = 0; y < height; y++)                      {                          for (int x = 0; x < width; x++)                          {                              count = 0;                              for (int h = -medianRadius; h <= medianRadius; h++)                              {                                  for (int w = -medianRadius; w <= medianRadius; w++)                                  {                                      int hh = y + h;                                      int ww = x + w;                                      if (hh >= 0 && hh < height && ww >= 0 && ww < width)                                      {                                          Rgb24 c = copy[hh' ww];                                          r[count] = c.Red;                                          g[count] = c.Green;                                          b[count] = c.Blue;                                          count++;                                      }                                  }                              }                                Array.Sort(r' 0' count);                              Array.Sort(g' 0' count);                              Array.Sort(b' 0' count);                              int m = count >> 1;                              Rgb24 median = new Rgb24 { Red = r[m]' Green = g[m]' Blue = b[m] };                              this[y' x] = median;                          }                      }                  }              }
Magic Number,Geb.Image,ImageRgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ApplyMedianFilter,The following statement contains a magic number: int size = medianRadius * 2 + 1;
Magic Number,Geb.Image,Rgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,AdjustSaturation,The following statement contains a magic number: if (red > 255) red = 255;
Magic Number,Geb.Image,Rgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,AdjustSaturation,The following statement contains a magic number: if (red > 255) red = 255;
Magic Number,Geb.Image,Rgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,AdjustSaturation,The following statement contains a magic number: if (green > 255) green = 255;
Magic Number,Geb.Image,Rgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,AdjustSaturation,The following statement contains a magic number: if (green > 255) green = 255;
Magic Number,Geb.Image,Rgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,AdjustSaturation,The following statement contains a magic number: if (blue > 255) blue = 255;
Magic Number,Geb.Image,Rgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,AdjustSaturation,The following statement contains a magic number: if (blue > 255) blue = 255;
Magic Number,Geb.Image,Rgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ToGray,The following statement contains a magic number: return (Byte)(0.299 * Red + 0.587 * Green + 0.114 * Blue);
Magic Number,Geb.Image,Rgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ToGray,The following statement contains a magic number: return (Byte)(0.299 * Red + 0.587 * Green + 0.114 * Blue);
Magic Number,Geb.Image,Rgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,ToGray,The following statement contains a magic number: return (Byte)(0.299 * Red + 0.587 * Green + 0.114 * Blue);
Magic Number,Geb.Image,Rgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,GetHashCode,The following statement contains a magic number: return (Red << 16) + (Green << 8) + Blue;
Magic Number,Geb.Image,Rgb24,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageRgb24_Csmacro.cs,GetHashCode,The following statement contains a magic number: return (Red << 16) + (Green << 8) + Blue;
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,CreateFromBitmap,The following statement contains a magic number: const int PixelFormat32bppCMYK = 8207;
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyModeFilter,The following statement contains a magic number: if (size <= 1) throw new ArgumentOutOfRangeException("size 必须大于1.");              else if (size > 127) throw new ArgumentOutOfRangeException("size 最大为127.");              else if (size % 2 == 0) throw new ArgumentException("size 应该是奇数.");
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyModeFilter,The following statement contains a magic number: if (size <= 1) throw new ArgumentOutOfRangeException("size 必须大于1.");              else if (size > 127) throw new ArgumentOutOfRangeException("size 最大为127.");              else if (size % 2 == 0) throw new ArgumentException("size 应该是奇数.");
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyModeFilter,The following statement contains a magic number: int radius = size / 2;
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DrawLine,The following statement contains a magic number: int n2dy = dy * 2;
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DrawLine,The following statement contains a magic number: int n2dydx = (dy - dx) * 2;
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DrawLine,The following statement contains a magic number: int d = dy * 2 - dx;
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DrawLine,The following statement contains a magic number: if (Math.Abs(deltaX) < 0.0001)              {                  if (Math.Abs(deltaY) < 0.0001)                  {                      SetColor(start.X' start.Y' color' radius' ww' hh);                      return;                  };                    float yStart = start.Y;                  float yEnd = end.Y;                  float x = start.X;                    if (yEnd < yStart)                  {                      float tmp = yEnd;                      yEnd = yStart;                      yStart = tmp;                  }                    yStart = Math.Max(0' yStart);                  yEnd = Math.Min(hh' yEnd);                    for (float y = yStart; y <= yEnd; y++)                  {                      SetColor(x' y' color' radius' ww' hh);                  }              }              else              {                  float xStart = start.X;                  float xEnd = end.X;                  if (xEnd < xStart)                  {                      float tmp = xEnd;                      xEnd = xStart;                      xStart = tmp;                  }                    float step = 1;                  float grad = Math.Abs(deltaY / deltaX);                  if (grad > 1)                  {                      step = 1 / grad;                  }                    for (float x = xStart; x <= xEnd; x += step)                  {                      float deltaXX = start.X - x;                      float deltaYY = deltaY * (deltaXX / deltaX);                      float y = start.Y - deltaYY;                        SetColor(x' y' color' radius' ww' hh);                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DrawLine,The following statement contains a magic number: if (Math.Abs(deltaX) < 0.0001)              {                  if (Math.Abs(deltaY) < 0.0001)                  {                      SetColor(start.X' start.Y' color' radius' ww' hh);                      return;                  };                    float yStart = start.Y;                  float yEnd = end.Y;                  float x = start.X;                    if (yEnd < yStart)                  {                      float tmp = yEnd;                      yEnd = yStart;                      yStart = tmp;                  }                    yStart = Math.Max(0' yStart);                  yEnd = Math.Min(hh' yEnd);                    for (float y = yStart; y <= yEnd; y++)                  {                      SetColor(x' y' color' radius' ww' hh);                  }              }              else              {                  float xStart = start.X;                  float xEnd = end.X;                  if (xEnd < xStart)                  {                      float tmp = xEnd;                      xEnd = xStart;                      xStart = tmp;                  }                    float step = 1;                  float grad = Math.Abs(deltaY / deltaX);                  if (grad > 1)                  {                      step = 1 / grad;                  }                    for (float x = xStart; x <= xEnd; x += step)                  {                      float deltaXX = start.X - x;                      float deltaYY = deltaY * (deltaXX / deltaX);                      float y = start.Y - deltaYY;                        SetColor(x' y' color' radius' ww' hh);                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DrawText,The following statement contains a magic number: int base_line = +(ascii[0] & 15);
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DrawText,The following statement contains a magic number: List<PointS> pts = new List<PointS>(1 << 10);
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DrawText,The following statement contains a magic number: for (int i = 0; i < txt.Length; i++)              {                  Char c = txt[i];                  if (c >= 127 || c < ' ')                      c = '?';                  String fontData = faces[ascii[(c - ' ') + 1]];                    PointS p = new PointS();                  p.X = (short)(fontData[0] - 'R');                  p.Y = (short)(fontData[1] - 'R');                  double dx = p.Y * hscale;                  view_x -= p.X * hscale;                  pts.Clear();                  for (int k = 2; k <= fontData.Length; )                  {                      if (k == fontData.Length || fontData[k] == ' ')                      {                          // Draw Poly Line                          if (pts.Count > 1)                          {                              for (int j = 1; j < pts.Count; j++)                              {                                  DrawLine(pts[j - 1].ToPointF()' pts[j].ToPointF()' color);                              }                          }                          pts.Clear();                          k++;                      }                      else                      {                          p.X = (short)(fontData[k] - 'R');                          p.Y = (short)(fontData[k+1] - 'R');                          k += 2;                          pts.Add(new PointS((short)Math.Round(p.X * hscale + view_x)'                              (short)Math.Round(p.Y * vscale + view_y)));                      }                  }                    view_x += dx;              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DrawText,The following statement contains a magic number: for (int i = 0; i < txt.Length; i++)              {                  Char c = txt[i];                  if (c >= 127 || c < ' ')                      c = '?';                  String fontData = faces[ascii[(c - ' ') + 1]];                    PointS p = new PointS();                  p.X = (short)(fontData[0] - 'R');                  p.Y = (short)(fontData[1] - 'R');                  double dx = p.Y * hscale;                  view_x -= p.X * hscale;                  pts.Clear();                  for (int k = 2; k <= fontData.Length; )                  {                      if (k == fontData.Length || fontData[k] == ' ')                      {                          // Draw Poly Line                          if (pts.Count > 1)                          {                              for (int j = 1; j < pts.Count; j++)                              {                                  DrawLine(pts[j - 1].ToPointF()' pts[j].ToPointF()' color);                              }                          }                          pts.Clear();                          k++;                      }                      else                      {                          p.X = (short)(fontData[k] - 'R');                          p.Y = (short)(fontData[k+1] - 'R');                          k += 2;                          pts.Add(new PointS((short)Math.Round(p.X * hscale + view_x)'                              (short)Math.Round(p.Y * vscale + view_y)));                      }                  }                    view_x += dx;              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DrawText,The following statement contains a magic number: for (int i = 0; i < txt.Length; i++)              {                  Char c = txt[i];                  if (c >= 127 || c < ' ')                      c = '?';                  String fontData = faces[ascii[(c - ' ') + 1]];                    PointS p = new PointS();                  p.X = (short)(fontData[0] - 'R');                  p.Y = (short)(fontData[1] - 'R');                  double dx = p.Y * hscale;                  view_x -= p.X * hscale;                  pts.Clear();                  for (int k = 2; k <= fontData.Length; )                  {                      if (k == fontData.Length || fontData[k] == ' ')                      {                          // Draw Poly Line                          if (pts.Count > 1)                          {                              for (int j = 1; j < pts.Count; j++)                              {                                  DrawLine(pts[j - 1].ToPointF()' pts[j].ToPointF()' color);                              }                          }                          pts.Clear();                          k++;                      }                      else                      {                          p.X = (short)(fontData[k] - 'R');                          p.Y = (short)(fontData[k+1] - 'R');                          k += 2;                          pts.Add(new PointS((short)Math.Round(p.X * hscale + view_x)'                              (short)Math.Round(p.Y * vscale + view_y)));                      }                  }                    view_x += dx;              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyConvolution,The following statement contains a magic number: int extend = Math.Max(kernelWidth' kernelHeight) / 2;
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyConvolution,The following statement contains a magic number: TImage maskImage = new TImage(Width + extend * 2' Height + extend * 2);
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyConvolution,The following statement contains a magic number: TImage maskImage = new TImage(Width + extend * 2' Height + extend * 2);
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyConvolution,The following statement contains a magic number: int extendWidth = this.Width + extend * 2;
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyConvolution,The following statement contains a magic number: int extendHeight = this.Height + extend * 2;
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyInvert,The following statement contains a magic number: while (p != end)              {                  *p = (Byte)(255 - *p);                  p++;              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ToImageArgb32,The following statement contains a magic number: while (p != end)              {                  p->Alpha = 255;                  p->Red = *to;                  p->Green = *to;                  p->Blue = *to;                    p++;                  to++;              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DetectConnectivity,The following statement contains a magic number: Int32 count = list[6] - list[6] * list[7] * list[0];
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DetectConnectivity,The following statement contains a magic number: Int32 count = list[6] - list[6] * list[7] * list[0];
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DetectConnectivity,The following statement contains a magic number: Int32 count = list[6] - list[6] * list[7] * list[0];
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DetectConnectivity,The following statement contains a magic number: count += list[0] - list[0] * list[1] * list[2];
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DetectConnectivity,The following statement contains a magic number: count += list[2] - list[2] * list[3] * list[4];
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DetectConnectivity,The following statement contains a magic number: count += list[2] - list[2] * list[3] * list[4];
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DetectConnectivity,The following statement contains a magic number: count += list[2] - list[2] * list[3] * list[4];
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DetectConnectivity,The following statement contains a magic number: count += list[2] - list[2] * list[3] * list[4];
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DetectConnectivity,The following statement contains a magic number: count += list[4] - list[4] * list[5] * list[6];
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DetectConnectivity,The following statement contains a magic number: count += list[4] - list[4] * list[5] * list[6];
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DetectConnectivity,The following statement contains a magic number: count += list[4] - list[4] * list[5] * list[6];
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,DetectConnectivity,The following statement contains a magic number: count += list[4] - list[4] * list[5] * list[6];
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,FillNeighbors,The following statement contains a magic number: list[2] = p[-width] == foreground ? 0 : 1;
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,FillNeighbors,The following statement contains a magic number: list[3] = p[-1 - width] == foreground ? 0 : 1;
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,FillNeighbors,The following statement contains a magic number: list[4] = p[-1] == foreground ? 0 : 1;
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,FillNeighbors,The following statement contains a magic number: list[5] = p[-1 + width] == foreground ? 0 : 1;
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,FillNeighbors,The following statement contains a magic number: list[6] = p[width] == foreground ? 0 : 1;
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,FillNeighbors,The following statement contains a magic number: list[7] = p[1 + width] == foreground ? 0 : 1;
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,Thinning,The following statement contains a magic number: Int32* list = stackalloc Int32[8];
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,Thinning,The following statement contains a magic number: Byte background = (Byte)(255 - foreground);
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,Thinning,The following statement contains a magic number: using (ImageU8 mask = new ImageU8(this.Width' this.Height))              {                  mask.Fill(0);                    Boolean loop = true;                  while (loop == true)                  {                      loop = false;                      for (Int32 r = 1; r < height - 1; r++)                      {                          for (Int32 c = 1; c < width - 1; c++)                          {                              Byte* p = start + r * width + c;                                // 条件1：p 必须是前景点                              if (*p != foreground) continue;                                //  p3  p2  p1                              //  p4  p   p0                              //  p5  p6  p7                              // list 存储的是补集，即前景点为0，背景点为1，以方便联结数的计算                              FillNeighbors(p' list' width' foreground);                                // 条件2：p0'p2'p4'p6 不皆为前景点                              if (list[0] == 0 && list[2] == 0 && list[4] == 0 && list[6] == 0)                                  continue;                                // 条件3: p0~p7至少两个是前景点                              Int32 count = 0;                              for (int i = 0; i < 8; i++)                              {                                  count += list[i];                              }                                if (count > 6) continue;                                // 条件4：联结数等于1                              if (DetectConnectivity(list) != 1) continue;                                // 条件5: 假设p2已标记删除，则令p2为背景，不改变p的联结数                              if (mask[r - 1' c] == 1)                              {                                  list[2] = 1;                                  if (DetectConnectivity(list) != 1)                                      continue;                                  list[2] = 0;                              }                                // 条件6: 假设p4已标记删除，则令p4为背景，不改变p的联结数                              if (mask[r' c - 1] == 1)                              {                                  list[4] = 1;                                  if (DetectConnectivity(list) != 1)                                      continue;                              }                              mask[r' c] = 1; // 标记删除                              loop = true;                          }                      }                        for (int i = 0; i < length; i++)                      {                          if (mask[i] == 1)                          {                              this[i] = background;                          }                      }                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,Thinning,The following statement contains a magic number: using (ImageU8 mask = new ImageU8(this.Width' this.Height))              {                  mask.Fill(0);                    Boolean loop = true;                  while (loop == true)                  {                      loop = false;                      for (Int32 r = 1; r < height - 1; r++)                      {                          for (Int32 c = 1; c < width - 1; c++)                          {                              Byte* p = start + r * width + c;                                // 条件1：p 必须是前景点                              if (*p != foreground) continue;                                //  p3  p2  p1                              //  p4  p   p0                              //  p5  p6  p7                              // list 存储的是补集，即前景点为0，背景点为1，以方便联结数的计算                              FillNeighbors(p' list' width' foreground);                                // 条件2：p0'p2'p4'p6 不皆为前景点                              if (list[0] == 0 && list[2] == 0 && list[4] == 0 && list[6] == 0)                                  continue;                                // 条件3: p0~p7至少两个是前景点                              Int32 count = 0;                              for (int i = 0; i < 8; i++)                              {                                  count += list[i];                              }                                if (count > 6) continue;                                // 条件4：联结数等于1                              if (DetectConnectivity(list) != 1) continue;                                // 条件5: 假设p2已标记删除，则令p2为背景，不改变p的联结数                              if (mask[r - 1' c] == 1)                              {                                  list[2] = 1;                                  if (DetectConnectivity(list) != 1)                                      continue;                                  list[2] = 0;                              }                                // 条件6: 假设p4已标记删除，则令p4为背景，不改变p的联结数                              if (mask[r' c - 1] == 1)                              {                                  list[4] = 1;                                  if (DetectConnectivity(list) != 1)                                      continue;                              }                              mask[r' c] = 1; // 标记删除                              loop = true;                          }                      }                        for (int i = 0; i < length; i++)                      {                          if (mask[i] == 1)                          {                              this[i] = background;                          }                      }                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,Thinning,The following statement contains a magic number: using (ImageU8 mask = new ImageU8(this.Width' this.Height))              {                  mask.Fill(0);                    Boolean loop = true;                  while (loop == true)                  {                      loop = false;                      for (Int32 r = 1; r < height - 1; r++)                      {                          for (Int32 c = 1; c < width - 1; c++)                          {                              Byte* p = start + r * width + c;                                // 条件1：p 必须是前景点                              if (*p != foreground) continue;                                //  p3  p2  p1                              //  p4  p   p0                              //  p5  p6  p7                              // list 存储的是补集，即前景点为0，背景点为1，以方便联结数的计算                              FillNeighbors(p' list' width' foreground);                                // 条件2：p0'p2'p4'p6 不皆为前景点                              if (list[0] == 0 && list[2] == 0 && list[4] == 0 && list[6] == 0)                                  continue;                                // 条件3: p0~p7至少两个是前景点                              Int32 count = 0;                              for (int i = 0; i < 8; i++)                              {                                  count += list[i];                              }                                if (count > 6) continue;                                // 条件4：联结数等于1                              if (DetectConnectivity(list) != 1) continue;                                // 条件5: 假设p2已标记删除，则令p2为背景，不改变p的联结数                              if (mask[r - 1' c] == 1)                              {                                  list[2] = 1;                                  if (DetectConnectivity(list) != 1)                                      continue;                                  list[2] = 0;                              }                                // 条件6: 假设p4已标记删除，则令p4为背景，不改变p的联结数                              if (mask[r' c - 1] == 1)                              {                                  list[4] = 1;                                  if (DetectConnectivity(list) != 1)                                      continue;                              }                              mask[r' c] = 1; // 标记删除                              loop = true;                          }                      }                        for (int i = 0; i < length; i++)                      {                          if (mask[i] == 1)                          {                              this[i] = background;                          }                      }                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,Thinning,The following statement contains a magic number: using (ImageU8 mask = new ImageU8(this.Width' this.Height))              {                  mask.Fill(0);                    Boolean loop = true;                  while (loop == true)                  {                      loop = false;                      for (Int32 r = 1; r < height - 1; r++)                      {                          for (Int32 c = 1; c < width - 1; c++)                          {                              Byte* p = start + r * width + c;                                // 条件1：p 必须是前景点                              if (*p != foreground) continue;                                //  p3  p2  p1                              //  p4  p   p0                              //  p5  p6  p7                              // list 存储的是补集，即前景点为0，背景点为1，以方便联结数的计算                              FillNeighbors(p' list' width' foreground);                                // 条件2：p0'p2'p4'p6 不皆为前景点                              if (list[0] == 0 && list[2] == 0 && list[4] == 0 && list[6] == 0)                                  continue;                                // 条件3: p0~p7至少两个是前景点                              Int32 count = 0;                              for (int i = 0; i < 8; i++)                              {                                  count += list[i];                              }                                if (count > 6) continue;                                // 条件4：联结数等于1                              if (DetectConnectivity(list) != 1) continue;                                // 条件5: 假设p2已标记删除，则令p2为背景，不改变p的联结数                              if (mask[r - 1' c] == 1)                              {                                  list[2] = 1;                                  if (DetectConnectivity(list) != 1)                                      continue;                                  list[2] = 0;                              }                                // 条件6: 假设p4已标记删除，则令p4为背景，不改变p的联结数                              if (mask[r' c - 1] == 1)                              {                                  list[4] = 1;                                  if (DetectConnectivity(list) != 1)                                      continue;                              }                              mask[r' c] = 1; // 标记删除                              loop = true;                          }                      }                        for (int i = 0; i < length; i++)                      {                          if (mask[i] == 1)                          {                              this[i] = background;                          }                      }                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,Thinning,The following statement contains a magic number: using (ImageU8 mask = new ImageU8(this.Width' this.Height))              {                  mask.Fill(0);                    Boolean loop = true;                  while (loop == true)                  {                      loop = false;                      for (Int32 r = 1; r < height - 1; r++)                      {                          for (Int32 c = 1; c < width - 1; c++)                          {                              Byte* p = start + r * width + c;                                // 条件1：p 必须是前景点                              if (*p != foreground) continue;                                //  p3  p2  p1                              //  p4  p   p0                              //  p5  p6  p7                              // list 存储的是补集，即前景点为0，背景点为1，以方便联结数的计算                              FillNeighbors(p' list' width' foreground);                                // 条件2：p0'p2'p4'p6 不皆为前景点                              if (list[0] == 0 && list[2] == 0 && list[4] == 0 && list[6] == 0)                                  continue;                                // 条件3: p0~p7至少两个是前景点                              Int32 count = 0;                              for (int i = 0; i < 8; i++)                              {                                  count += list[i];                              }                                if (count > 6) continue;                                // 条件4：联结数等于1                              if (DetectConnectivity(list) != 1) continue;                                // 条件5: 假设p2已标记删除，则令p2为背景，不改变p的联结数                              if (mask[r - 1' c] == 1)                              {                                  list[2] = 1;                                  if (DetectConnectivity(list) != 1)                                      continue;                                  list[2] = 0;                              }                                // 条件6: 假设p4已标记删除，则令p4为背景，不改变p的联结数                              if (mask[r' c - 1] == 1)                              {                                  list[4] = 1;                                  if (DetectConnectivity(list) != 1)                                      continue;                              }                              mask[r' c] = 1; // 标记删除                              loop = true;                          }                      }                        for (int i = 0; i < length; i++)                      {                          if (mask[i] == 1)                          {                              this[i] = background;                          }                      }                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,Thinning,The following statement contains a magic number: using (ImageU8 mask = new ImageU8(this.Width' this.Height))              {                  mask.Fill(0);                    Boolean loop = true;                  while (loop == true)                  {                      loop = false;                      for (Int32 r = 1; r < height - 1; r++)                      {                          for (Int32 c = 1; c < width - 1; c++)                          {                              Byte* p = start + r * width + c;                                // 条件1：p 必须是前景点                              if (*p != foreground) continue;                                //  p3  p2  p1                              //  p4  p   p0                              //  p5  p6  p7                              // list 存储的是补集，即前景点为0，背景点为1，以方便联结数的计算                              FillNeighbors(p' list' width' foreground);                                // 条件2：p0'p2'p4'p6 不皆为前景点                              if (list[0] == 0 && list[2] == 0 && list[4] == 0 && list[6] == 0)                                  continue;                                // 条件3: p0~p7至少两个是前景点                              Int32 count = 0;                              for (int i = 0; i < 8; i++)                              {                                  count += list[i];                              }                                if (count > 6) continue;                                // 条件4：联结数等于1                              if (DetectConnectivity(list) != 1) continue;                                // 条件5: 假设p2已标记删除，则令p2为背景，不改变p的联结数                              if (mask[r - 1' c] == 1)                              {                                  list[2] = 1;                                  if (DetectConnectivity(list) != 1)                                      continue;                                  list[2] = 0;                              }                                // 条件6: 假设p4已标记删除，则令p4为背景，不改变p的联结数                              if (mask[r' c - 1] == 1)                              {                                  list[4] = 1;                                  if (DetectConnectivity(list) != 1)                                      continue;                              }                              mask[r' c] = 1; // 标记删除                              loop = true;                          }                      }                        for (int i = 0; i < length; i++)                      {                          if (mask[i] == 1)                          {                              this[i] = background;                          }                      }                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,Thinning,The following statement contains a magic number: using (ImageU8 mask = new ImageU8(this.Width' this.Height))              {                  mask.Fill(0);                    Boolean loop = true;                  while (loop == true)                  {                      loop = false;                      for (Int32 r = 1; r < height - 1; r++)                      {                          for (Int32 c = 1; c < width - 1; c++)                          {                              Byte* p = start + r * width + c;                                // 条件1：p 必须是前景点                              if (*p != foreground) continue;                                //  p3  p2  p1                              //  p4  p   p0                              //  p5  p6  p7                              // list 存储的是补集，即前景点为0，背景点为1，以方便联结数的计算                              FillNeighbors(p' list' width' foreground);                                // 条件2：p0'p2'p4'p6 不皆为前景点                              if (list[0] == 0 && list[2] == 0 && list[4] == 0 && list[6] == 0)                                  continue;                                // 条件3: p0~p7至少两个是前景点                              Int32 count = 0;                              for (int i = 0; i < 8; i++)                              {                                  count += list[i];                              }                                if (count > 6) continue;                                // 条件4：联结数等于1                              if (DetectConnectivity(list) != 1) continue;                                // 条件5: 假设p2已标记删除，则令p2为背景，不改变p的联结数                              if (mask[r - 1' c] == 1)                              {                                  list[2] = 1;                                  if (DetectConnectivity(list) != 1)                                      continue;                                  list[2] = 0;                              }                                // 条件6: 假设p4已标记删除，则令p4为背景，不改变p的联结数                              if (mask[r' c - 1] == 1)                              {                                  list[4] = 1;                                  if (DetectConnectivity(list) != 1)                                      continue;                              }                              mask[r' c] = 1; // 标记删除                              loop = true;                          }                      }                        for (int i = 0; i < length; i++)                      {                          if (mask[i] == 1)                          {                              this[i] = background;                          }                      }                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,Thinning,The following statement contains a magic number: using (ImageU8 mask = new ImageU8(this.Width' this.Height))              {                  mask.Fill(0);                    Boolean loop = true;                  while (loop == true)                  {                      loop = false;                      for (Int32 r = 1; r < height - 1; r++)                      {                          for (Int32 c = 1; c < width - 1; c++)                          {                              Byte* p = start + r * width + c;                                // 条件1：p 必须是前景点                              if (*p != foreground) continue;                                //  p3  p2  p1                              //  p4  p   p0                              //  p5  p6  p7                              // list 存储的是补集，即前景点为0，背景点为1，以方便联结数的计算                              FillNeighbors(p' list' width' foreground);                                // 条件2：p0'p2'p4'p6 不皆为前景点                              if (list[0] == 0 && list[2] == 0 && list[4] == 0 && list[6] == 0)                                  continue;                                // 条件3: p0~p7至少两个是前景点                              Int32 count = 0;                              for (int i = 0; i < 8; i++)                              {                                  count += list[i];                              }                                if (count > 6) continue;                                // 条件4：联结数等于1                              if (DetectConnectivity(list) != 1) continue;                                // 条件5: 假设p2已标记删除，则令p2为背景，不改变p的联结数                              if (mask[r - 1' c] == 1)                              {                                  list[2] = 1;                                  if (DetectConnectivity(list) != 1)                                      continue;                                  list[2] = 0;                              }                                // 条件6: 假设p4已标记删除，则令p4为背景，不改变p的联结数                              if (mask[r' c - 1] == 1)                              {                                  list[4] = 1;                                  if (DetectConnectivity(list) != 1)                                      continue;                              }                              mask[r' c] = 1; // 标记删除                              loop = true;                          }                      }                        for (int i = 0; i < length; i++)                      {                          if (mask[i] == 1)                          {                              this[i] = background;                          }                      }                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,SkeletonizeByMidPoint,The following statement contains a magic number: using (ImageU8 mask = new ImageU8(this.Width' this.Height))              {                  mask.Fill(0);                  Int32 width = this.Width;                  Int32 height = this.Height;                  for (Int32 r = 0; r < height; r++)                  {                      Int32 lineStart = -1;                      for (Int32 c = 0; c < width; c++)                      {                          if (this[r' c] == foreground)                          {                              if (lineStart == -1) lineStart = c;                          }                          else                          {                              if (lineStart != -1)                              {                                  mask[r' (lineStart + c) / 2] = 1;                                  lineStart = -1;                              }                          }                      }                  }                    for (Int32 c = 0; c < width; c++)                  {                      Int32 lineStart = -1;                      for (Int32 r = 0; r < height; r++)                      {                          if (this[r' c] == foreground)                          {                              if (lineStart == -1) lineStart = r;                          }                          else                          {                              if (lineStart != -1)                              {                                  mask[(lineStart + r) / 2' c] = 1;                                  lineStart = -1;                              }                          }                      }                  }                    Byte bg = (Byte)(255 - foreground);                  Int32 length = this.Length;                  for (int i = 0; i < length; i++)                  {                      if (mask[i] == 1)                      {                          this[i] = foreground;                      }                      else                      {                          this[i] = bg;                      }                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,SkeletonizeByMidPoint,The following statement contains a magic number: using (ImageU8 mask = new ImageU8(this.Width' this.Height))              {                  mask.Fill(0);                  Int32 width = this.Width;                  Int32 height = this.Height;                  for (Int32 r = 0; r < height; r++)                  {                      Int32 lineStart = -1;                      for (Int32 c = 0; c < width; c++)                      {                          if (this[r' c] == foreground)                          {                              if (lineStart == -1) lineStart = c;                          }                          else                          {                              if (lineStart != -1)                              {                                  mask[r' (lineStart + c) / 2] = 1;                                  lineStart = -1;                              }                          }                      }                  }                    for (Int32 c = 0; c < width; c++)                  {                      Int32 lineStart = -1;                      for (Int32 r = 0; r < height; r++)                      {                          if (this[r' c] == foreground)                          {                              if (lineStart == -1) lineStart = r;                          }                          else                          {                              if (lineStart != -1)                              {                                  mask[(lineStart + r) / 2' c] = 1;                                  lineStart = -1;                              }                          }                      }                  }                    Byte bg = (Byte)(255 - foreground);                  Int32 length = this.Length;                  for (int i = 0; i < length; i++)                  {                      if (mask[i] == 1)                      {                          this[i] = foreground;                      }                      else                      {                          this[i] = bg;                      }                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,SkeletonizeByMidPoint,The following statement contains a magic number: using (ImageU8 mask = new ImageU8(this.Width' this.Height))              {                  mask.Fill(0);                  Int32 width = this.Width;                  Int32 height = this.Height;                  for (Int32 r = 0; r < height; r++)                  {                      Int32 lineStart = -1;                      for (Int32 c = 0; c < width; c++)                      {                          if (this[r' c] == foreground)                          {                              if (lineStart == -1) lineStart = c;                          }                          else                          {                              if (lineStart != -1)                              {                                  mask[r' (lineStart + c) / 2] = 1;                                  lineStart = -1;                              }                          }                      }                  }                    for (Int32 c = 0; c < width; c++)                  {                      Int32 lineStart = -1;                      for (Int32 r = 0; r < height; r++)                      {                          if (this[r' c] == foreground)                          {                              if (lineStart == -1) lineStart = r;                          }                          else                          {                              if (lineStart != -1)                              {                                  mask[(lineStart + r) / 2' c] = 1;                                  lineStart = -1;                              }                          }                      }                  }                    Byte bg = (Byte)(255 - foreground);                  Int32 length = this.Length;                  for (int i = 0; i < length; i++)                  {                      if (mask[i] == 1)                      {                          this[i] = foreground;                      }                      else                      {                          this[i] = bg;                      }                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyCannyEdgeDetector,The following statement contains a magic number: int ww = width - 2;
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyCannyEdgeDetector,The following statement contains a magic number: int hh = height - 2;
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyCannyEdgeDetector,The following statement contains a magic number: double orientation' toAngle = 180.0 / System.Math.PI;
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyCannyEdgeDetector,The following statement contains a magic number: for (int y = startY; y < stopY; y++)              {                  p = start + y * width;                  for (int x = startX; x < stopX; x++' p++' o++)                  {                      gx = p[-width+1] + p[width+1]                           - p[-width-1] - p[width-1]                          + 2 * (p[1] - p[-1]);                      gy = p[-width - 1] + p[-width + 1]                          - p[width - 1] - p[width + 1]                          + 2 * (p[-width] - p[width]);                      gradients[x' y] = (float)Math.Sqrt(gx * gx + gy * gy);                      if (gradients[x' y] > maxGradient)                          maxGradient = gradients[x' y];                        // get orientation                      if (gx == 0)                      {                          orientation = (gy == 0) ? 0 : 90;                      }                      else                      {                          double div = gy / gx;                          // handle angles of the 2nd and 4th quads                          if (div < 0)                          {                              orientation = 180 - System.Math.Atan(-div) * toAngle;                          }                          // handle angles of the 1st and 3rd quads                          else                          {                              orientation = System.Math.Atan(div) * toAngle;                          }                            // get closest angle from 0' 45' 90' 135 set                          if (orientation < 22.5)                              orientation = 0;                          else if (orientation < 67.5)                              orientation = 45;                          else if (orientation < 112.5)                              orientation = 90;                          else if (orientation < 157.5)                              orientation = 135;                          else orientation = 0;                      }                        // save orientation                      orients[o] = (byte)orientation;                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyCannyEdgeDetector,The following statement contains a magic number: for (int y = startY; y < stopY; y++)              {                  p = start + y * width;                  for (int x = startX; x < stopX; x++' p++' o++)                  {                      gx = p[-width+1] + p[width+1]                           - p[-width-1] - p[width-1]                          + 2 * (p[1] - p[-1]);                      gy = p[-width - 1] + p[-width + 1]                          - p[width - 1] - p[width + 1]                          + 2 * (p[-width] - p[width]);                      gradients[x' y] = (float)Math.Sqrt(gx * gx + gy * gy);                      if (gradients[x' y] > maxGradient)                          maxGradient = gradients[x' y];                        // get orientation                      if (gx == 0)                      {                          orientation = (gy == 0) ? 0 : 90;                      }                      else                      {                          double div = gy / gx;                          // handle angles of the 2nd and 4th quads                          if (div < 0)                          {                              orientation = 180 - System.Math.Atan(-div) * toAngle;                          }                          // handle angles of the 1st and 3rd quads                          else                          {                              orientation = System.Math.Atan(div) * toAngle;                          }                            // get closest angle from 0' 45' 90' 135 set                          if (orientation < 22.5)                              orientation = 0;                          else if (orientation < 67.5)                              orientation = 45;                          else if (orientation < 112.5)                              orientation = 90;                          else if (orientation < 157.5)                              orientation = 135;                          else orientation = 0;                      }                        // save orientation                      orients[o] = (byte)orientation;                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyCannyEdgeDetector,The following statement contains a magic number: for (int y = startY; y < stopY; y++)              {                  p = start + y * width;                  for (int x = startX; x < stopX; x++' p++' o++)                  {                      gx = p[-width+1] + p[width+1]                           - p[-width-1] - p[width-1]                          + 2 * (p[1] - p[-1]);                      gy = p[-width - 1] + p[-width + 1]                          - p[width - 1] - p[width + 1]                          + 2 * (p[-width] - p[width]);                      gradients[x' y] = (float)Math.Sqrt(gx * gx + gy * gy);                      if (gradients[x' y] > maxGradient)                          maxGradient = gradients[x' y];                        // get orientation                      if (gx == 0)                      {                          orientation = (gy == 0) ? 0 : 90;                      }                      else                      {                          double div = gy / gx;                          // handle angles of the 2nd and 4th quads                          if (div < 0)                          {                              orientation = 180 - System.Math.Atan(-div) * toAngle;                          }                          // handle angles of the 1st and 3rd quads                          else                          {                              orientation = System.Math.Atan(div) * toAngle;                          }                            // get closest angle from 0' 45' 90' 135 set                          if (orientation < 22.5)                              orientation = 0;                          else if (orientation < 67.5)                              orientation = 45;                          else if (orientation < 112.5)                              orientation = 90;                          else if (orientation < 157.5)                              orientation = 135;                          else orientation = 0;                      }                        // save orientation                      orients[o] = (byte)orientation;                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyCannyEdgeDetector,The following statement contains a magic number: for (int y = startY; y < stopY; y++)              {                  p = start + y * width;                  for (int x = startX; x < stopX; x++' p++' o++)                  {                      gx = p[-width+1] + p[width+1]                           - p[-width-1] - p[width-1]                          + 2 * (p[1] - p[-1]);                      gy = p[-width - 1] + p[-width + 1]                          - p[width - 1] - p[width + 1]                          + 2 * (p[-width] - p[width]);                      gradients[x' y] = (float)Math.Sqrt(gx * gx + gy * gy);                      if (gradients[x' y] > maxGradient)                          maxGradient = gradients[x' y];                        // get orientation                      if (gx == 0)                      {                          orientation = (gy == 0) ? 0 : 90;                      }                      else                      {                          double div = gy / gx;                          // handle angles of the 2nd and 4th quads                          if (div < 0)                          {                              orientation = 180 - System.Math.Atan(-div) * toAngle;                          }                          // handle angles of the 1st and 3rd quads                          else                          {                              orientation = System.Math.Atan(div) * toAngle;                          }                            // get closest angle from 0' 45' 90' 135 set                          if (orientation < 22.5)                              orientation = 0;                          else if (orientation < 67.5)                              orientation = 45;                          else if (orientation < 112.5)                              orientation = 90;                          else if (orientation < 157.5)                              orientation = 135;                          else orientation = 0;                      }                        // save orientation                      orients[o] = (byte)orientation;                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyCannyEdgeDetector,The following statement contains a magic number: for (int y = startY; y < stopY; y++)              {                  p = start + y * width;                  for (int x = startX; x < stopX; x++' p++' o++)                  {                      gx = p[-width+1] + p[width+1]                           - p[-width-1] - p[width-1]                          + 2 * (p[1] - p[-1]);                      gy = p[-width - 1] + p[-width + 1]                          - p[width - 1] - p[width + 1]                          + 2 * (p[-width] - p[width]);                      gradients[x' y] = (float)Math.Sqrt(gx * gx + gy * gy);                      if (gradients[x' y] > maxGradient)                          maxGradient = gradients[x' y];                        // get orientation                      if (gx == 0)                      {                          orientation = (gy == 0) ? 0 : 90;                      }                      else                      {                          double div = gy / gx;                          // handle angles of the 2nd and 4th quads                          if (div < 0)                          {                              orientation = 180 - System.Math.Atan(-div) * toAngle;                          }                          // handle angles of the 1st and 3rd quads                          else                          {                              orientation = System.Math.Atan(div) * toAngle;                          }                            // get closest angle from 0' 45' 90' 135 set                          if (orientation < 22.5)                              orientation = 0;                          else if (orientation < 67.5)                              orientation = 45;                          else if (orientation < 112.5)                              orientation = 90;                          else if (orientation < 157.5)                              orientation = 135;                          else orientation = 0;                      }                        // save orientation                      orients[o] = (byte)orientation;                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyCannyEdgeDetector,The following statement contains a magic number: for (int y = startY; y < stopY; y++)              {                  p = start + y * width;                  for (int x = startX; x < stopX; x++' p++' o++)                  {                      gx = p[-width+1] + p[width+1]                           - p[-width-1] - p[width-1]                          + 2 * (p[1] - p[-1]);                      gy = p[-width - 1] + p[-width + 1]                          - p[width - 1] - p[width + 1]                          + 2 * (p[-width] - p[width]);                      gradients[x' y] = (float)Math.Sqrt(gx * gx + gy * gy);                      if (gradients[x' y] > maxGradient)                          maxGradient = gradients[x' y];                        // get orientation                      if (gx == 0)                      {                          orientation = (gy == 0) ? 0 : 90;                      }                      else                      {                          double div = gy / gx;                          // handle angles of the 2nd and 4th quads                          if (div < 0)                          {                              orientation = 180 - System.Math.Atan(-div) * toAngle;                          }                          // handle angles of the 1st and 3rd quads                          else                          {                              orientation = System.Math.Atan(div) * toAngle;                          }                            // get closest angle from 0' 45' 90' 135 set                          if (orientation < 22.5)                              orientation = 0;                          else if (orientation < 67.5)                              orientation = 45;                          else if (orientation < 112.5)                              orientation = 90;                          else if (orientation < 157.5)                              orientation = 135;                          else orientation = 0;                      }                        // save orientation                      orients[o] = (byte)orientation;                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyCannyEdgeDetector,The following statement contains a magic number: for (int y = startY; y < stopY; y++)              {                  p = start + y * width;                  for (int x = startX; x < stopX; x++' p++' o++)                  {                      gx = p[-width+1] + p[width+1]                           - p[-width-1] - p[width-1]                          + 2 * (p[1] - p[-1]);                      gy = p[-width - 1] + p[-width + 1]                          - p[width - 1] - p[width + 1]                          + 2 * (p[-width] - p[width]);                      gradients[x' y] = (float)Math.Sqrt(gx * gx + gy * gy);                      if (gradients[x' y] > maxGradient)                          maxGradient = gradients[x' y];                        // get orientation                      if (gx == 0)                      {                          orientation = (gy == 0) ? 0 : 90;                      }                      else                      {                          double div = gy / gx;                          // handle angles of the 2nd and 4th quads                          if (div < 0)                          {                              orientation = 180 - System.Math.Atan(-div) * toAngle;                          }                          // handle angles of the 1st and 3rd quads                          else                          {                              orientation = System.Math.Atan(div) * toAngle;                          }                            // get closest angle from 0' 45' 90' 135 set                          if (orientation < 22.5)                              orientation = 0;                          else if (orientation < 67.5)                              orientation = 45;                          else if (orientation < 112.5)                              orientation = 90;                          else if (orientation < 157.5)                              orientation = 135;                          else orientation = 0;                      }                        // save orientation                      orients[o] = (byte)orientation;                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyCannyEdgeDetector,The following statement contains a magic number: for (int y = startY; y < stopY; y++)              {                  p = start + y * width;                  for (int x = startX; x < stopX; x++' p++' o++)                  {                      gx = p[-width+1] + p[width+1]                           - p[-width-1] - p[width-1]                          + 2 * (p[1] - p[-1]);                      gy = p[-width - 1] + p[-width + 1]                          - p[width - 1] - p[width + 1]                          + 2 * (p[-width] - p[width]);                      gradients[x' y] = (float)Math.Sqrt(gx * gx + gy * gy);                      if (gradients[x' y] > maxGradient)                          maxGradient = gradients[x' y];                        // get orientation                      if (gx == 0)                      {                          orientation = (gy == 0) ? 0 : 90;                      }                      else                      {                          double div = gy / gx;                          // handle angles of the 2nd and 4th quads                          if (div < 0)                          {                              orientation = 180 - System.Math.Atan(-div) * toAngle;                          }                          // handle angles of the 1st and 3rd quads                          else                          {                              orientation = System.Math.Atan(div) * toAngle;                          }                            // get closest angle from 0' 45' 90' 135 set                          if (orientation < 22.5)                              orientation = 0;                          else if (orientation < 67.5)                              orientation = 45;                          else if (orientation < 112.5)                              orientation = 90;                          else if (orientation < 157.5)                              orientation = 135;                          else orientation = 0;                      }                        // save orientation                      orients[o] = (byte)orientation;                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyCannyEdgeDetector,The following statement contains a magic number: for (int y = startY; y < stopY; y++)              {                  p = start + y * width;                  for (int x = startX; x < stopX; x++' p++' o++)                  {                      gx = p[-width+1] + p[width+1]                           - p[-width-1] - p[width-1]                          + 2 * (p[1] - p[-1]);                      gy = p[-width - 1] + p[-width + 1]                          - p[width - 1] - p[width + 1]                          + 2 * (p[-width] - p[width]);                      gradients[x' y] = (float)Math.Sqrt(gx * gx + gy * gy);                      if (gradients[x' y] > maxGradient)                          maxGradient = gradients[x' y];                        // get orientation                      if (gx == 0)                      {                          orientation = (gy == 0) ? 0 : 90;                      }                      else                      {                          double div = gy / gx;                          // handle angles of the 2nd and 4th quads                          if (div < 0)                          {                              orientation = 180 - System.Math.Atan(-div) * toAngle;                          }                          // handle angles of the 1st and 3rd quads                          else                          {                              orientation = System.Math.Atan(div) * toAngle;                          }                            // get closest angle from 0' 45' 90' 135 set                          if (orientation < 22.5)                              orientation = 0;                          else if (orientation < 67.5)                              orientation = 45;                          else if (orientation < 112.5)                              orientation = 90;                          else if (orientation < 157.5)                              orientation = 135;                          else orientation = 0;                      }                        // save orientation                      orients[o] = (byte)orientation;                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyCannyEdgeDetector,The following statement contains a magic number: for (int y = startY; y < stopY; y++)              {                  p = start + y * width;                  for (int x = startX; x < stopX; x++' p++' o++)                  {                      gx = p[-width+1] + p[width+1]                           - p[-width-1] - p[width-1]                          + 2 * (p[1] - p[-1]);                      gy = p[-width - 1] + p[-width + 1]                          - p[width - 1] - p[width + 1]                          + 2 * (p[-width] - p[width]);                      gradients[x' y] = (float)Math.Sqrt(gx * gx + gy * gy);                      if (gradients[x' y] > maxGradient)                          maxGradient = gradients[x' y];                        // get orientation                      if (gx == 0)                      {                          orientation = (gy == 0) ? 0 : 90;                      }                      else                      {                          double div = gy / gx;                          // handle angles of the 2nd and 4th quads                          if (div < 0)                          {                              orientation = 180 - System.Math.Atan(-div) * toAngle;                          }                          // handle angles of the 1st and 3rd quads                          else                          {                              orientation = System.Math.Atan(div) * toAngle;                          }                            // get closest angle from 0' 45' 90' 135 set                          if (orientation < 22.5)                              orientation = 0;                          else if (orientation < 67.5)                              orientation = 45;                          else if (orientation < 112.5)                              orientation = 90;                          else if (orientation < 157.5)                              orientation = 135;                          else orientation = 0;                      }                        // save orientation                      orients[o] = (byte)orientation;                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyCannyEdgeDetector,The following statement contains a magic number: for (int y = startY; y < stopY; y++)              {                  p = start + y * width;                  for (int x = startX; x < stopX; x++' p++' o++)                  {                      gx = p[-width+1] + p[width+1]                           - p[-width-1] - p[width-1]                          + 2 * (p[1] - p[-1]);                      gy = p[-width - 1] + p[-width + 1]                          - p[width - 1] - p[width + 1]                          + 2 * (p[-width] - p[width]);                      gradients[x' y] = (float)Math.Sqrt(gx * gx + gy * gy);                      if (gradients[x' y] > maxGradient)                          maxGradient = gradients[x' y];                        // get orientation                      if (gx == 0)                      {                          orientation = (gy == 0) ? 0 : 90;                      }                      else                      {                          double div = gy / gx;                          // handle angles of the 2nd and 4th quads                          if (div < 0)                          {                              orientation = 180 - System.Math.Atan(-div) * toAngle;                          }                          // handle angles of the 1st and 3rd quads                          else                          {                              orientation = System.Math.Atan(div) * toAngle;                          }                            // get closest angle from 0' 45' 90' 135 set                          if (orientation < 22.5)                              orientation = 0;                          else if (orientation < 67.5)                              orientation = 45;                          else if (orientation < 112.5)                              orientation = 90;                          else if (orientation < 157.5)                              orientation = 135;                          else orientation = 0;                      }                        // save orientation                      orients[o] = (byte)orientation;                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyCannyEdgeDetector,The following statement contains a magic number: for (int y = startY; y < stopY; y++)              {                  p = start + y * width;                  // for each pixel                  for (int x = startX; x < stopX; x++' p++' o++)                  {                      // get two adjacent pixels                      switch (orients[o])                      {                          case 0:                              leftPixel = gradients[x - 1' y];                              rightPixel = gradients[x + 1' y];                              break;                          case 45:                              leftPixel = gradients[x - 1' y + 1];                              rightPixel = gradients[x + 1' y - 1];                              break;                          case 90:                              leftPixel = gradients[x' y + 1];                              rightPixel = gradients[x' y - 1];                              break;                          case 135:                              leftPixel = gradients[x + 1' y + 1];                              rightPixel = gradients[x - 1' y - 1];                              break;                      }                      // compare current pixels value with adjacent pixels                      if ((gradients[x' y] < leftPixel) || (gradients[x' y] < rightPixel))                      {                          *p = 0;                      }                      else                      {                          *p = (byte)(gradients[x' y] / maxGradient * 255);                      }                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyCannyEdgeDetector,The following statement contains a magic number: for (int y = startY; y < stopY; y++)              {                  p = start + y * width;                  // for each pixel                  for (int x = startX; x < stopX; x++' p++' o++)                  {                      // get two adjacent pixels                      switch (orients[o])                      {                          case 0:                              leftPixel = gradients[x - 1' y];                              rightPixel = gradients[x + 1' y];                              break;                          case 45:                              leftPixel = gradients[x - 1' y + 1];                              rightPixel = gradients[x + 1' y - 1];                              break;                          case 90:                              leftPixel = gradients[x' y + 1];                              rightPixel = gradients[x' y - 1];                              break;                          case 135:                              leftPixel = gradients[x + 1' y + 1];                              rightPixel = gradients[x - 1' y - 1];                              break;                      }                      // compare current pixels value with adjacent pixels                      if ((gradients[x' y] < leftPixel) || (gradients[x' y] < rightPixel))                      {                          *p = 0;                      }                      else                      {                          *p = (byte)(gradients[x' y] / maxGradient * 255);                      }                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyCannyEdgeDetector,The following statement contains a magic number: for (int y = startY; y < stopY; y++)              {                  p = start + y * width;                  // for each pixel                  for (int x = startX; x < stopX; x++' p++' o++)                  {                      // get two adjacent pixels                      switch (orients[o])                      {                          case 0:                              leftPixel = gradients[x - 1' y];                              rightPixel = gradients[x + 1' y];                              break;                          case 45:                              leftPixel = gradients[x - 1' y + 1];                              rightPixel = gradients[x + 1' y - 1];                              break;                          case 90:                              leftPixel = gradients[x' y + 1];                              rightPixel = gradients[x' y - 1];                              break;                          case 135:                              leftPixel = gradients[x + 1' y + 1];                              rightPixel = gradients[x - 1' y - 1];                              break;                      }                      // compare current pixels value with adjacent pixels                      if ((gradients[x' y] < leftPixel) || (gradients[x' y] < rightPixel))                      {                          *p = 0;                      }                      else                      {                          *p = (byte)(gradients[x' y] / maxGradient * 255);                      }                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyCannyEdgeDetector,The following statement contains a magic number: for (int y = startY; y < stopY; y++)              {                  p = start + y * width;                  // for each pixel                  for (int x = startX; x < stopX; x++' p++' o++)                  {                      // get two adjacent pixels                      switch (orients[o])                      {                          case 0:                              leftPixel = gradients[x - 1' y];                              rightPixel = gradients[x + 1' y];                              break;                          case 45:                              leftPixel = gradients[x - 1' y + 1];                              rightPixel = gradients[x + 1' y - 1];                              break;                          case 90:                              leftPixel = gradients[x' y + 1];                              rightPixel = gradients[x' y - 1];                              break;                          case 135:                              leftPixel = gradients[x + 1' y + 1];                              rightPixel = gradients[x - 1' y - 1];                              break;                      }                      // compare current pixels value with adjacent pixels                      if ((gradients[x' y] < leftPixel) || (gradients[x' y] < rightPixel))                      {                          *p = 0;                      }                      else                      {                          *p = (byte)(gradients[x' y] / maxGradient * 255);                      }                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyMedianFilter,The following statement contains a magic number: if (medianRadius > 0)              {                  // 进行中值滤波                  using (ImageU8 copy = this.Clone() as ImageU8)                  {                      int size = medianRadius * 2 + 1;                      int count = 0;                      byte[] data = new byte[size * size];                      int height = this.Height;                      int width = this.Width;                      for (int y = 0; y < height; y++)                      {                          for (int x = 0; x < width; x++)                          {                              count = 0;                              for (int h = -medianRadius; h <= medianRadius; h++)                              {                                  for (int w = -medianRadius; w <= medianRadius; w++)                                  {                                      int hh = y + h;                                      int ww = x + w;                                      if (hh >= 0 && hh < height && ww >= 0 && ww < width)                                      {                                          data[count] = copy[hh' ww];                                          count++;                                      }                                  }                              }                                Array.Sort(data' 0' count);                              int m = count >> 1;                              byte median = data[m];                              this[y' x] = median;                          }                      }                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyOtsuThreshold,The following statement contains a magic number: int[] integerHistogram = new int[256];
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyOtsuThreshold,The following statement contains a magic number: float[] histogram = new float[256];
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyOtsuThreshold,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  histogram[i] = (float)integerHistogram[i] / pixelCount;                  imageMean += histogram[i] * i;              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyOtsuThreshold,The following statement contains a magic number: for (int t = 0; t < 256; t++)              {                  // calculate class probabilities for the given threshold                  float class1Probability = class1ProbabiltyInit;                  float class2Probability = class2ProbabiltyInit;                    // calculate class means for the given threshold                  float class1Mean = class1MeanInit;                  float class2Mean = (imageMean - (class1Mean * class1Probability)) / class2Probability;                    // calculate between class variance                  float betweenClassVariance = (float)((class1Probability) * (1.0 - class1Probability) * Math.Pow(class1Mean - class2Mean' 2));                    // check if we found new threshold candidate                  if (betweenClassVariance > max)                  {                      max = betweenClassVariance;                      calculatedThreshold = t;                  }                    // update initial probabilities and mean value                  class1MeanInit *= class1ProbabiltyInit;                    class1ProbabiltyInit += histogram[t];                  class2ProbabiltyInit -= histogram[t];                    class1MeanInit += (float)t * (float)histogram[t];                    if (class1ProbabiltyInit != 0)                      class1MeanInit /= class1ProbabiltyInit;              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyOtsuThreshold,The following statement contains a magic number: for (int t = 0; t < 256; t++)              {                  // calculate class probabilities for the given threshold                  float class1Probability = class1ProbabiltyInit;                  float class2Probability = class2ProbabiltyInit;                    // calculate class means for the given threshold                  float class1Mean = class1MeanInit;                  float class2Mean = (imageMean - (class1Mean * class1Probability)) / class2Probability;                    // calculate between class variance                  float betweenClassVariance = (float)((class1Probability) * (1.0 - class1Probability) * Math.Pow(class1Mean - class2Mean' 2));                    // check if we found new threshold candidate                  if (betweenClassVariance > max)                  {                      max = betweenClassVariance;                      calculatedThreshold = t;                  }                    // update initial probabilities and mean value                  class1MeanInit *= class1ProbabiltyInit;                    class1ProbabiltyInit += histogram[t];                  class2ProbabiltyInit -= histogram[t];                    class1MeanInit += (float)t * (float)histogram[t];                    if (class1ProbabiltyInit != 0)                      class1MeanInit /= class1ProbabiltyInit;              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyDistanceTransformFast,The following statement contains a magic number: for (int h = 1; h < height - 1; h++)              {                  // 位于每行的头部                  Byte* line0 = start + (h - 1) * width;                  Byte* line1 = start + (h) * width;                  Byte* line2 = start + (h + 1) * width;                  for (int w = 1; w < width; w++)                  {                      if (line1[1] > 0) // 当前像素                      {                          val = Math.Min(line0[0]' line0[1]);                          val = Math.Min(val' line1[0]);                          val = Math.Min(val' line2[0]);                          val = Math.Min(val + 1' line1[1]);                          line1[1] = (byte)(Math.Min(val' 255));                      }                        line0++;                      line1++;                      line2++;                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyDistanceTransformFast,The following statement contains a magic number: for (int h = height - 2; h > 0; h--)              {                  Byte* line0 = start + (h - 1) * width;                  Byte* line1 = start + (h) * width;                  Byte* line2 = start + (h + 1) * width;                    for (int w = width - 2; w >= 0; w--)                  {                      if (line1[w] > 0)                      {                          val = Math.Min(line0[w + 1]' line1[w + 1]);                          val = Math.Min(val' line2[w + 1]);                          val = Math.Min(val' line2[w]);                          val = Math.Min(val + 1' line1[w]);                          line1[w] = (byte)(Math.Min(val' 255)); ;                      }                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyDistanceTransformFast,The following statement contains a magic number: for (int h = height - 2; h > 0; h--)              {                  Byte* line0 = start + (h - 1) * width;                  Byte* line1 = start + (h) * width;                  Byte* line2 = start + (h + 1) * width;                    for (int w = width - 2; w >= 0; w--)                  {                      if (line1[w] > 0)                      {                          val = Math.Min(line0[w + 1]' line1[w + 1]);                          val = Math.Min(val' line2[w + 1]);                          val = Math.Min(val' line2[w]);                          val = Math.Min(val + 1' line1[w]);                          line1[w] = (byte)(Math.Min(val' 255)); ;                      }                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyDistanceTransformFast,The following statement contains a magic number: for (int h = height - 2; h > 0; h--)              {                  Byte* line0 = start + (h - 1) * width;                  Byte* line1 = start + (h) * width;                  Byte* line2 = start + (h + 1) * width;                    for (int w = width - 2; w >= 0; w--)                  {                      if (line1[w] > 0)                      {                          val = Math.Min(line0[w + 1]' line1[w + 1]);                          val = Math.Min(val' line2[w + 1]);                          val = Math.Min(val' line2[w]);                          val = Math.Min(val + 1' line1[w]);                          line1[w] = (byte)(Math.Min(val' 255)); ;                      }                  }              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,SmoothByMorphology,The following statement contains a magic number: while (start < end)              {                  *start = (*start > distance0) ? (byte)0 : (byte)255;                  start++;              }
Magic Number,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,SmoothByMorphology,The following statement contains a magic number: while (start < end)              {                  *start = (*start > distance1) ? (byte)0 : (byte)255;                  start++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte red = from->Red;                  Byte green = from->Green;                  Byte blue = from->Blue;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    // 据Imageshop(http://www.cnblogs.com/Imageshop/) 测试，l不会超出[0'255]范围。                  // l = l > 255 ? 255 : l < 0 ? 0 : l;                    a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte red = from->Red;                  Byte green = from->Green;                  Byte blue = from->Blue;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    // 据Imageshop(http://www.cnblogs.com/Imageshop/) 测试，l不会超出[0'255]范围。                  // l = l > 255 ? 255 : l < 0 ? 0 : l;                    a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte red = from->Red;                  Byte green = from->Green;                  Byte blue = from->Blue;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    // 据Imageshop(http://www.cnblogs.com/Imageshop/) 测试，l不会超出[0'255]范围。                  // l = l > 255 ? 255 : l < 0 ? 0 : l;                    a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte red = from->Red;                  Byte green = from->Green;                  Byte blue = from->Blue;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    // 据Imageshop(http://www.cnblogs.com/Imageshop/) 测试，l不会超出[0'255]范围。                  // l = l > 255 ? 255 : l < 0 ? 0 : l;                    a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte red = from->Red;                  Byte green = from->Green;                  Byte blue = from->Blue;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    // 据Imageshop(http://www.cnblogs.com/Imageshop/) 测试，l不会超出[0'255]范围。                  // l = l > 255 ? 255 : l < 0 ? 0 : l;                    a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte red = from->Red;                  Byte green = from->Green;                  Byte blue = from->Blue;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    // 据Imageshop(http://www.cnblogs.com/Imageshop/) 测试，l不会超出[0'255]范围。                  // l = l > 255 ? 255 : l < 0 ? 0 : l;                    a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte red = from->Red;                  Byte green = from->Green;                  Byte blue = from->Blue;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    // 据Imageshop(http://www.cnblogs.com/Imageshop/) 测试，l不会超出[0'255]范围。                  // l = l > 255 ? 255 : l < 0 ? 0 : l;                    a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte red = from->Red;                  Byte green = from->Green;                  Byte blue = from->Blue;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    // 据Imageshop(http://www.cnblogs.com/Imageshop/) 测试，l不会超出[0'255]范围。                  // l = l > 255 ? 255 : l < 0 ? 0 : l;                    a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte red = from->Red;                  Byte green = from->Green;                  Byte blue = from->Blue;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    // 据Imageshop(http://www.cnblogs.com/Imageshop/) 测试，l不会超出[0'255]范围。                  // l = l > 255 ? 255 : l < 0 ? 0 : l;                    a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte red = from->Red;                  Byte green = from->Green;                  Byte blue = from->Blue;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    // 据Imageshop(http://www.cnblogs.com/Imageshop/) 测试，l不会超出[0'255]范围。                  // l = l > 255 ? 255 : l < 0 ? 0 : l;                    a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte red = from->Red;                  Byte green = from->Green;                  Byte blue = from->Blue;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    l = l > 255 ? 255 : l < 0 ? 0 : l;                  a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte red = from->Red;                  Byte green = from->Green;                  Byte blue = from->Blue;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    l = l > 255 ? 255 : l < 0 ? 0 : l;                  a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte red = from->Red;                  Byte green = from->Green;                  Byte blue = from->Blue;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    l = l > 255 ? 255 : l < 0 ? 0 : l;                  a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte red = from->Red;                  Byte green = from->Green;                  Byte blue = from->Blue;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    l = l > 255 ? 255 : l < 0 ? 0 : l;                  a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte red = from->Red;                  Byte green = from->Green;                  Byte blue = from->Blue;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    l = l > 255 ? 255 : l < 0 ? 0 : l;                  a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte red = from->Red;                  Byte green = from->Green;                  Byte blue = from->Blue;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    l = l > 255 ? 255 : l < 0 ? 0 : l;                  a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte red = from->Red;                  Byte green = from->Green;                  Byte blue = from->Blue;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    l = l > 255 ? 255 : l < 0 ? 0 : l;                  a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte red = from->Red;                  Byte green = from->Green;                  Byte blue = from->Blue;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    l = l > 255 ? 255 : l < 0 ? 0 : l;                  a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte red = from->Red;                  Byte green = from->Green;                  Byte blue = from->Blue;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    l = l > 255 ? 255 : l < 0 ? 0 : l;                  a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte red = from->Red;                  Byte green = from->Green;                  Byte blue = from->Blue;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    l = l > 255 ? 255 : l < 0 ? 0 : l;                  a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte red = from->Red;                  Byte green = from->Green;                  Byte blue = from->Blue;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    l = l > 255 ? 255 : l < 0 ? 0 : l;                  a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte red = from->Red;                  Byte green = from->Green;                  Byte blue = from->Blue;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    l = l > 255 ? 255 : l < 0 ? 0 : l;                  a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte val = *from;                  Byte red = val;                  Byte green = val;                  Byte blue = val;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    l = l > 255 ? 255 : l < 0 ? 0 : l;                  a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte val = *from;                  Byte red = val;                  Byte green = val;                  Byte blue = val;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    l = l > 255 ? 255 : l < 0 ? 0 : l;                  a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte val = *from;                  Byte red = val;                  Byte green = val;                  Byte blue = val;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    l = l > 255 ? 255 : l < 0 ? 0 : l;                  a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte val = *from;                  Byte red = val;                  Byte green = val;                  Byte blue = val;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    l = l > 255 ? 255 : l < 0 ? 0 : l;                  a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte val = *from;                  Byte red = val;                  Byte green = val;                  Byte blue = val;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    l = l > 255 ? 255 : l < 0 ? 0 : l;                  a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte val = *from;                  Byte red = val;                  Byte green = val;                  Byte blue = val;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    l = l > 255 ? 255 : l < 0 ? 0 : l;                  a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte val = *from;                  Byte red = val;                  Byte green = val;                  Byte blue = val;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    l = l > 255 ? 255 : l < 0 ? 0 : l;                  a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte val = *from;                  Byte red = val;                  Byte green = val;                  Byte blue = val;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    l = l > 255 ? 255 : l < 0 ? 0 : l;                  a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte val = *from;                  Byte red = val;                  Byte green = val;                  Byte blue = val;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    l = l > 255 ? 255 : l < 0 ? 0 : l;                  a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte val = *from;                  Byte red = val;                  Byte green = val;                  Byte blue = val;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    l = l > 255 ? 255 : l < 0 ? 0 : l;                  a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte val = *from;                  Byte red = val;                  Byte green = val;                  Byte blue = val;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    l = l > 255 ? 255 : l < 0 ? 0 : l;                  a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToLab24,The following statement contains a magic number: while (from != end)              {                  Byte val = *from;                  Byte red = val;                  Byte green = val;                  Byte blue = val;                    x = blue * labXb + green * labXg + red * labXr;                  y = blue * labYb + green * labYg + red * labYr;                  z = blue * labZb + green * labZg + red * labZr;                    flag = x > labT;                    x = (((x) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag)                      x = icvLabCubeRootTab[x];                  else                      x = (((x * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = z > labT;                  z = (((z) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                      z = icvLabCubeRootTab[z];                  else                      z = (((z * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    flag = y > labT;                  y = (((y) + (1 << ((lab_shift) - 1))) >> (lab_shift));                    if (flag == true)                  {                      y = icvLabCubeRootTab[y];                      l = (((y * labLScale - labLShift) + (1 << ((2 * lab_shift) - 1))) >> (2 * lab_shift));                  }                  else                  {                      l = (((y * labLScale2) + (1 << ((lab_shift) - 1))) >> (lab_shift));                      y = (((y * labSmallScale + labSmallShift) + (1 << ((lab_shift) - 1))) >> (lab_shift));                  }                    a = (((500 * (x - y)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 129;                  b = (((200 * (y - z)) + (1 << ((lab_shift) - 1))) >> (lab_shift)) + 128;                    l = l > 255 ? 255 : l < 0 ? 0 : l;                  a = a > 255 ? 255 : a < 0 ? 0 : a;                  b = b > 255 ? 255 : b < 0 ? 0 : b;                    to->L = (byte)l;                  to->A = (byte)a;                  to->B = (byte)b;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToRgb24,The following statement contains a magic number: while (from != end)              {                  l = from->L * coeff0 + coeff1;                  a = from->A * coeff2 + coeff3;                  b = from->B * coeff4 + coeff5;                    l = (l + labLShift_32f) * (1.0f / labLScale_32f);                  x = (l + a * 0.002f);                  z = (l - b * 0.005f);                    y = l * l * l;                  x = x * x * x;                  z = z * z * z;                    blue = (int)((x * labBx_32f + y * labBy_32f + z * labBz_32f) * 255 + 0.5);                  green = (int)((x * labGx_32f + y * labGy_32f + z * labGz_32f) * 255 + 0.5);                  red = (int)((x * labRx_32f + y * labRy_32f + z * labRz_32f) * 255 + 0.5);                    red = red < 0 ? 0 : red > 255 ? 255 : red;                  green = green < 0 ? 0 : green > 255 ? 255 : green;                  blue = blue < 0 ? 0 : blue > 255 ? 255 : blue;                    to->Red = (byte)red;                  to->Green = (byte)green;                  to->Blue = (byte)blue;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToRgb24,The following statement contains a magic number: while (from != end)              {                  l = from->L * coeff0 + coeff1;                  a = from->A * coeff2 + coeff3;                  b = from->B * coeff4 + coeff5;                    l = (l + labLShift_32f) * (1.0f / labLScale_32f);                  x = (l + a * 0.002f);                  z = (l - b * 0.005f);                    y = l * l * l;                  x = x * x * x;                  z = z * z * z;                    blue = (int)((x * labBx_32f + y * labBy_32f + z * labBz_32f) * 255 + 0.5);                  green = (int)((x * labGx_32f + y * labGy_32f + z * labGz_32f) * 255 + 0.5);                  red = (int)((x * labRx_32f + y * labRy_32f + z * labRz_32f) * 255 + 0.5);                    red = red < 0 ? 0 : red > 255 ? 255 : red;                  green = green < 0 ? 0 : green > 255 ? 255 : green;                  blue = blue < 0 ? 0 : blue > 255 ? 255 : blue;                    to->Red = (byte)red;                  to->Green = (byte)green;                  to->Blue = (byte)blue;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToRgb24,The following statement contains a magic number: while (from != end)              {                  l = from->L * coeff0 + coeff1;                  a = from->A * coeff2 + coeff3;                  b = from->B * coeff4 + coeff5;                    l = (l + labLShift_32f) * (1.0f / labLScale_32f);                  x = (l + a * 0.002f);                  z = (l - b * 0.005f);                    y = l * l * l;                  x = x * x * x;                  z = z * z * z;                    blue = (int)((x * labBx_32f + y * labBy_32f + z * labBz_32f) * 255 + 0.5);                  green = (int)((x * labGx_32f + y * labGy_32f + z * labGz_32f) * 255 + 0.5);                  red = (int)((x * labRx_32f + y * labRy_32f + z * labRz_32f) * 255 + 0.5);                    red = red < 0 ? 0 : red > 255 ? 255 : red;                  green = green < 0 ? 0 : green > 255 ? 255 : green;                  blue = blue < 0 ? 0 : blue > 255 ? 255 : blue;                    to->Red = (byte)red;                  to->Green = (byte)green;                  to->Blue = (byte)blue;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToRgb24,The following statement contains a magic number: while (from != end)              {                  l = from->L * coeff0 + coeff1;                  a = from->A * coeff2 + coeff3;                  b = from->B * coeff4 + coeff5;                    l = (l + labLShift_32f) * (1.0f / labLScale_32f);                  x = (l + a * 0.002f);                  z = (l - b * 0.005f);                    y = l * l * l;                  x = x * x * x;                  z = z * z * z;                    blue = (int)((x * labBx_32f + y * labBy_32f + z * labBz_32f) * 255 + 0.5);                  green = (int)((x * labGx_32f + y * labGy_32f + z * labGz_32f) * 255 + 0.5);                  red = (int)((x * labRx_32f + y * labRy_32f + z * labRz_32f) * 255 + 0.5);                    red = red < 0 ? 0 : red > 255 ? 255 : red;                  green = green < 0 ? 0 : green > 255 ? 255 : green;                  blue = blue < 0 ? 0 : blue > 255 ? 255 : blue;                    to->Red = (byte)red;                  to->Green = (byte)green;                  to->Blue = (byte)blue;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToRgb24,The following statement contains a magic number: while (from != end)              {                  l = from->L * coeff0 + coeff1;                  a = from->A * coeff2 + coeff3;                  b = from->B * coeff4 + coeff5;                    l = (l + labLShift_32f) * (1.0f / labLScale_32f);                  x = (l + a * 0.002f);                  z = (l - b * 0.005f);                    y = l * l * l;                  x = x * x * x;                  z = z * z * z;                    blue = (int)((x * labBx_32f + y * labBy_32f + z * labBz_32f) * 255 + 0.5);                  green = (int)((x * labGx_32f + y * labGy_32f + z * labGz_32f) * 255 + 0.5);                  red = (int)((x * labRx_32f + y * labRy_32f + z * labRz_32f) * 255 + 0.5);                    red = red < 0 ? 0 : red > 255 ? 255 : red;                  green = green < 0 ? 0 : green > 255 ? 255 : green;                  blue = blue < 0 ? 0 : blue > 255 ? 255 : blue;                    to->Red = (byte)red;                  to->Green = (byte)green;                  to->Blue = (byte)blue;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToRgb24,The following statement contains a magic number: while (from != end)              {                  l = from->L * coeff0 + coeff1;                  a = from->A * coeff2 + coeff3;                  b = from->B * coeff4 + coeff5;                    l = (l + labLShift_32f) * (1.0f / labLScale_32f);                  x = (l + a * 0.002f);                  z = (l - b * 0.005f);                    y = l * l * l;                  x = x * x * x;                  z = z * z * z;                    blue = (int)((x * labBx_32f + y * labBy_32f + z * labBz_32f) * 255 + 0.5);                  green = (int)((x * labGx_32f + y * labGy_32f + z * labGz_32f) * 255 + 0.5);                  red = (int)((x * labRx_32f + y * labRy_32f + z * labRz_32f) * 255 + 0.5);                    red = red < 0 ? 0 : red > 255 ? 255 : red;                  green = green < 0 ? 0 : green > 255 ? 255 : green;                  blue = blue < 0 ? 0 : blue > 255 ? 255 : blue;                    to->Red = (byte)red;                  to->Green = (byte)green;                  to->Blue = (byte)blue;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToRgb24,The following statement contains a magic number: while (from != end)              {                  l = from->L * coeff0 + coeff1;                  a = from->A * coeff2 + coeff3;                  b = from->B * coeff4 + coeff5;                    l = (l + labLShift_32f) * (1.0f / labLScale_32f);                  x = (l + a * 0.002f);                  z = (l - b * 0.005f);                    y = l * l * l;                  x = x * x * x;                  z = z * z * z;                    blue = (int)((x * labBx_32f + y * labBy_32f + z * labBz_32f) * 255 + 0.5);                  green = (int)((x * labGx_32f + y * labGy_32f + z * labGz_32f) * 255 + 0.5);                  red = (int)((x * labRx_32f + y * labRy_32f + z * labRz_32f) * 255 + 0.5);                    red = red < 0 ? 0 : red > 255 ? 255 : red;                  green = green < 0 ? 0 : green > 255 ? 255 : green;                  blue = blue < 0 ? 0 : blue > 255 ? 255 : blue;                    to->Red = (byte)red;                  to->Green = (byte)green;                  to->Blue = (byte)blue;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToRgb24,The following statement contains a magic number: while (from != end)              {                  l = from->L * coeff0 + coeff1;                  a = from->A * coeff2 + coeff3;                  b = from->B * coeff4 + coeff5;                    l = (l + labLShift_32f) * (1.0f / labLScale_32f);                  x = (l + a * 0.002f);                  z = (l - b * 0.005f);                    y = l * l * l;                  x = x * x * x;                  z = z * z * z;                    blue = (int)((x * labBx_32f + y * labBy_32f + z * labBz_32f) * 255 + 0.5);                  green = (int)((x * labGx_32f + y * labGy_32f + z * labGz_32f) * 255 + 0.5);                  red = (int)((x * labRx_32f + y * labRy_32f + z * labRz_32f) * 255 + 0.5);                    red = red < 0 ? 0 : red > 255 ? 255 : red;                  green = green < 0 ? 0 : green > 255 ? 255 : green;                  blue = blue < 0 ? 0 : blue > 255 ? 255 : blue;                    to->Red = (byte)red;                  to->Green = (byte)green;                  to->Blue = (byte)blue;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToRgb24,The following statement contains a magic number: while (from != end)              {                  l = from->L * coeff0 + coeff1;                  a = from->A * coeff2 + coeff3;                  b = from->B * coeff4 + coeff5;                    l = (l + labLShift_32f) * (1.0f / labLScale_32f);                  x = (l + a * 0.002f);                  z = (l - b * 0.005f);                    y = l * l * l;                  x = x * x * x;                  z = z * z * z;                    blue = (int)((x * labBx_32f + y * labBy_32f + z * labBz_32f) * 255 + 0.5);                  green = (int)((x * labGx_32f + y * labGy_32f + z * labGz_32f) * 255 + 0.5);                  red = (int)((x * labRx_32f + y * labRy_32f + z * labRz_32f) * 255 + 0.5);                    red = red < 0 ? 0 : red > 255 ? 255 : red;                  green = green < 0 ? 0 : green > 255 ? 255 : green;                  blue = blue < 0 ? 0 : blue > 255 ? 255 : blue;                    to->Red = (byte)red;                  to->Green = (byte)green;                  to->Blue = (byte)blue;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToRgb24,The following statement contains a magic number: while (from != end)              {                  l = from->L * coeff0 + coeff1;                  a = from->A * coeff2 + coeff3;                  b = from->B * coeff4 + coeff5;                    l = (l + labLShift_32f) * (1.0f / labLScale_32f);                  x = (l + a * 0.002f);                  z = (l - b * 0.005f);                    y = l * l * l;                  x = x * x * x;                  z = z * z * z;                    blue = (int)((x * labBx_32f + y * labBy_32f + z * labBz_32f) * 255 + 0.5);                  green = (int)((x * labGx_32f + y * labGy_32f + z * labGz_32f) * 255 + 0.5);                  red = (int)((x * labRx_32f + y * labRy_32f + z * labRz_32f) * 255 + 0.5);                    red = red < 0 ? 0 : red > 255 ? 255 : red;                  green = green < 0 ? 0 : green > 255 ? 255 : green;                  blue = blue < 0 ? 0 : blue > 255 ? 255 : blue;                    to->Red = (byte)red;                  to->Green = (byte)green;                  to->Blue = (byte)blue;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToRgb24,The following statement contains a magic number: while (from != end)              {                  l = from->L * coeff0 + coeff1;                  a = from->A * coeff2 + coeff3;                  b = from->B * coeff4 + coeff5;                    l = (l + labLShift_32f) * (1.0f / labLScale_32f);                  x = (l + a * 0.002f);                  z = (l - b * 0.005f);                    y = l * l * l;                  x = x * x * x;                  z = z * z * z;                    blue = (int)((x * labBx_32f + y * labBy_32f + z * labBz_32f) * 255 + 0.5);                  green = (int)((x * labGx_32f + y * labGy_32f + z * labGz_32f) * 255 + 0.5);                  red = (int)((x * labRx_32f + y * labRy_32f + z * labRz_32f) * 255 + 0.5);                    red = red < 0 ? 0 : red > 255 ? 255 : red;                  green = green < 0 ? 0 : green > 255 ? 255 : green;                  blue = blue < 0 ? 0 : blue > 255 ? 255 : blue;                    to->Red = (byte)red;                  to->Green = (byte)green;                  to->Blue = (byte)blue;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToRgb24,The following statement contains a magic number: while (from != end)              {                  l = from->L * coeff0 + coeff1;                  a = from->A * coeff2 + coeff3;                  b = from->B * coeff4 + coeff5;                    l = (l + labLShift_32f) * (1.0f / labLScale_32f);                  x = (l + a * 0.002f);                  z = (l - b * 0.005f);                    y = l * l * l;                  x = x * x * x;                  z = z * z * z;                    blue = (int)((x * labBx_32f + y * labBy_32f + z * labBz_32f) * 255 + 0.5);                  green = (int)((x * labGx_32f + y * labGy_32f + z * labGz_32f) * 255 + 0.5);                  red = (int)((x * labRx_32f + y * labRy_32f + z * labRz_32f) * 255 + 0.5);                    red = red < 0 ? 0 : red > 255 ? 255 : red;                  green = green < 0 ? 0 : green > 255 ? 255 : green;                  blue = blue < 0 ? 0 : blue > 255 ? 255 : blue;                    to->Red = (byte)red;                  to->Green = (byte)green;                  to->Blue = (byte)blue;                    from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToArgb32,The following statement contains a magic number: while (from != end)              {                  to->Blue = from->Blue;                  to->Green = from->Green;                  to->Red = from->Red;                  to->Alpha = 255;                  from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToSignedArgb64,The following statement contains a magic number: while (from != end)              {                  to->Blue = from->Blue;                  to->Green = from->Green;                  to->Red = from->Red;                  to->Alpha = 255;                  from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToByte,The following statement contains a magic number: while (from != end)              {                  *to = (Byte)(from->Blue * 0.114 + from->Green * 0.587 + from->Red * 0.299);                  from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToByte,The following statement contains a magic number: while (from != end)              {                  *to = (Byte)(from->Blue * 0.114 + from->Green * 0.587 + from->Red * 0.299);                  from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToByte,The following statement contains a magic number: while (from != end)              {                  *to = (Byte)(from->Blue * 0.114 + from->Green * 0.587 + from->Red * 0.299);                  from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToByte,The following statement contains a magic number: while (from != end)              {                  *to = (Byte)(from->Blue * 0.114 + from->Green * 0.587 + from->Red * 0.299);                  from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToByte,The following statement contains a magic number: while (from != end)              {                  *to = (Byte)(from->Blue * 0.114 + from->Green * 0.587 + from->Red * 0.299);                  from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToByte,The following statement contains a magic number: while (from != end)              {                  *to = (Byte)(from->Blue * 0.114 + from->Green * 0.587 + from->Red * 0.299);                  from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToArgb32,The following statement contains a magic number: while (from != end)              {                  Byte val = *from;                  to->Blue = val;                  to->Green = val;                  to->Red = val;                  to->Alpha = 255;                  from++;                  to++;              }
Magic Number,Geb.Image,UnmanagedImageConverter,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\ImageConverter.cs,ToSignedArgb64,The following statement contains a magic number: while (from != end)              {                  Byte val = *from;                  to->Blue = val;                  to->Green = val;                  to->Red = val;                  to->Alpha = 255;                  from++;                  to++;              }
Magic Number,Geb.Image,PixelHelper,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Utils\PixelHelper.cs,Invert,The following statement contains a magic number: return (byte)(255 - p);
Magic Number,Geb.Image,CieXyz,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageCieXyz.cs,ToCieLab,The following statement contains a magic number: float l = 116.0f * Transform(Y / D65.Y) - 16;
Magic Number,Geb.Image,CieXyz,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageCieXyz.cs,Transform,The following statement contains a magic number: return ((t > 0.008856) ? (float) Math.Pow(t' (1.0f / 3.0f)) : (7.787f * t + 16.0f / 116.0f));
Magic Number,Geb.Image,LAlaphaBeta,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageLAlphaBeta.cs,ToRgb24,The following statement contains a magic number: const double c00 = 0.57735;
Magic Number,Geb.Image,LAlaphaBeta,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageLAlphaBeta.cs,ToRgb24,The following statement contains a magic number: const double c01 = 0.408248;
Magic Number,Geb.Image,LAlaphaBeta,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageLAlphaBeta.cs,ToRgb24,The following statement contains a magic number: const double c02 = 0.707107;
Magic Number,Geb.Image,LAlaphaBeta,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageLAlphaBeta.cs,ToRgb24,The following statement contains a magic number: const double c10 = 0.57735;
Magic Number,Geb.Image,LAlaphaBeta,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageLAlphaBeta.cs,ToRgb24,The following statement contains a magic number: const double c11 = 0.408248;
Magic Number,Geb.Image,LAlaphaBeta,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageLAlphaBeta.cs,ToRgb24,The following statement contains a magic number: const double c12 = -0.707107;
Magic Number,Geb.Image,LAlaphaBeta,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageLAlphaBeta.cs,ToRgb24,The following statement contains a magic number: const double c20 = 0.57735;
Magic Number,Geb.Image,LAlaphaBeta,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageLAlphaBeta.cs,ToRgb24,The following statement contains a magic number: const double c21 = -0.8164965;
Magic Number,Geb.Image,LAlaphaBeta,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageLAlphaBeta.cs,ToRgb24,The following statement contains a magic number: l = Math.Pow(10' l);
Magic Number,Geb.Image,LAlaphaBeta,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageLAlphaBeta.cs,ToRgb24,The following statement contains a magic number: m = Math.Pow(10' m);
Magic Number,Geb.Image,LAlaphaBeta,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageLAlphaBeta.cs,ToRgb24,The following statement contains a magic number: s = Math.Pow(10' s);
Magic Number,Geb.Image,LAlaphaBeta,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageLAlphaBeta.cs,ToRgb24,The following statement contains a magic number: int r = (int)(4.4679 * l -3.5873 * m + 0.1193 * s);
Magic Number,Geb.Image,LAlaphaBeta,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageLAlphaBeta.cs,ToRgb24,The following statement contains a magic number: int r = (int)(4.4679 * l -3.5873 * m + 0.1193 * s);
Magic Number,Geb.Image,LAlaphaBeta,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageLAlphaBeta.cs,ToRgb24,The following statement contains a magic number: int r = (int)(4.4679 * l -3.5873 * m + 0.1193 * s);
Magic Number,Geb.Image,LAlaphaBeta,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageLAlphaBeta.cs,ToRgb24,The following statement contains a magic number: int g = (int)(-1.2186 * l + 2.3809 * m - 0.1624 * s);
Magic Number,Geb.Image,LAlaphaBeta,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageLAlphaBeta.cs,ToRgb24,The following statement contains a magic number: int g = (int)(-1.2186 * l + 2.3809 * m - 0.1624 * s);
Magic Number,Geb.Image,LAlaphaBeta,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageLAlphaBeta.cs,ToRgb24,The following statement contains a magic number: int g = (int)(-1.2186 * l + 2.3809 * m - 0.1624 * s);
Magic Number,Geb.Image,LAlaphaBeta,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageLAlphaBeta.cs,ToRgb24,The following statement contains a magic number: int b = (int)(0.0497 * l - 0.2439 * m + 1.2045 * s);
Magic Number,Geb.Image,LAlaphaBeta,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageLAlphaBeta.cs,ToRgb24,The following statement contains a magic number: int b = (int)(0.0497 * l - 0.2439 * m + 1.2045 * s);
Magic Number,Geb.Image,LAlaphaBeta,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageLAlphaBeta.cs,ToRgb24,The following statement contains a magic number: int b = (int)(0.0497 * l - 0.2439 * m + 1.2045 * s);
Magic Number,Geb.Image,LAlaphaBeta,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageLAlphaBeta.cs,ToRgb24,The following statement contains a magic number: if (r < 0) r = 0; else if (r > 255) r = 255;
Magic Number,Geb.Image,LAlaphaBeta,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageLAlphaBeta.cs,ToRgb24,The following statement contains a magic number: if (r < 0) r = 0; else if (r > 255) r = 255;
Magic Number,Geb.Image,LAlaphaBeta,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageLAlphaBeta.cs,ToRgb24,The following statement contains a magic number: if (g < 0) g = 0; else if (g > 255) g = 255;
Magic Number,Geb.Image,LAlaphaBeta,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageLAlphaBeta.cs,ToRgb24,The following statement contains a magic number: if (g < 0) g = 0; else if (g > 255) g = 255;
Magic Number,Geb.Image,LAlaphaBeta,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageLAlphaBeta.cs,ToRgb24,The following statement contains a magic number: if (b < 0) b = 0; else if (b > 255) b = 255;
Magic Number,Geb.Image,LAlaphaBeta,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\ImageLAlphaBeta.cs,ToRgb24,The following statement contains a magic number: if (b < 0) b = 0; else if (b > 255) b = 255;
Magic Number,Geb.Image,ConvolutionKernel,C:\repos\xiaotie_GebImage\src\Geb.Image\Common\ConvolutionKernel.cs,CreateGaussianKernel,The following statement contains a magic number: sigma = Math.Max(0.5' Math.Min(5.0' sigma));
Magic Number,Geb.Image,ConvolutionKernel,C:\repos\xiaotie_GebImage\src\Geb.Image\Common\ConvolutionKernel.cs,CreateGaussianKernel,The following statement contains a magic number: sigma = Math.Max(0.5' Math.Min(5.0' sigma));
Magic Number,Geb.Image,ConvolutionKernel,C:\repos\xiaotie_GebImage\src\Geb.Image\Common\ConvolutionKernel.cs,CreateGaussianKernel,The following statement contains a magic number: size = Math.Max(3' Math.Min(21' size | 1));
Magic Number,Geb.Image,ConvolutionKernel,C:\repos\xiaotie_GebImage\src\Geb.Image\Common\ConvolutionKernel.cs,CreateGaussianKernel,The following statement contains a magic number: size = Math.Max(3' Math.Min(21' size | 1));
Magic Number,Geb.Image,ConvolutionKernel,C:\repos\xiaotie_GebImage\src\Geb.Image\Common\ConvolutionKernel.cs,CreateGaussianKernel,The following statement contains a magic number: int r = size / 2;
Magic Number,Geb.Image,ConvolutionKernel,C:\repos\xiaotie_GebImage\src\Geb.Image\Common\ConvolutionKernel.cs,CreateGaussianKernel,The following statement contains a magic number: for (int y = -r' i = 0; i < size; y++' i++)              {                  for (int x = -r' j = 0; j < size; x++' j++)                  {                      double val = Math.Exp((x * x + y * y) / (-2 * sqrSigma));                      max = Math.Max(val' max);                      kernel[i + j * size] = val;                  }              }
Magic Number,Geb.Image,ConvolutionKernel,C:\repos\xiaotie_GebImage\src\Geb.Image\Common\ConvolutionKernel.cs,CreateGaussianKernel,The following statement contains a magic number: double min = max/(128*128);
Magic Number,Geb.Image,ConvolutionKernel,C:\repos\xiaotie_GebImage\src\Geb.Image\Common\ConvolutionKernel.cs,CreateGaussianKernel,The following statement contains a magic number: double min = max/(128*128);
Magic Number,Geb.Image,ConvolutionKernel,C:\repos\xiaotie_GebImage\src\Geb.Image\Common\ConvolutionKernel.cs,IsEvenNumber,The following statement contains a magic number: return number % 2 == 0;
Magic Number,Geb.Image,Interpolate,C:\repos\xiaotie_GebImage\src\Geb.Image\Utils\Interpolate.cs,LinearInterpolate,The following statement contains a magic number: if (val < 0) return 0;              else if (val > 255) return 255;              else return (Byte)val;
Magic Number,Geb.Image,Interpolate,C:\repos\xiaotie_GebImage\src\Geb.Image\Utils\Interpolate.cs,LinearInterpolate,The following statement contains a magic number: if (val < 0) return 0;              else if (val > 255) return 255;              else return (Byte)val;
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: int ww = width / 2;
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: int hh = height / 2;
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidUp,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  hSrc = 2 * h;                  lineSrc = imgStart + hSrc * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      wSrc = 2 * w;                        // 对于四边不够一个高斯核半径的地方，直接赋值                      if (hSrc < 2 || hSrc > height - 3 || wSrc < 2 || wSrc > width - 3)                      {                          lineDst[w] = lineSrc[wSrc];                      }                      else                      {                          // 计算高斯                            TPixel* p = lineSrc + wSrc - 2 * width;                            TPixel p00 = p[-2];                          TPixel p01 = p[-1];                          TPixel p02 = p[0];                          TPixel p03 = p[1];                          TPixel p04 = p[2];                            p += width;                          TPixel p10 = p[-2];                          TPixel p11 = p[-1];                          TPixel p12 = p[0];                          TPixel p13 = p[1];                          TPixel p14 = p[2];                            p += width;                          TPixel p20 = p[-2];                          TPixel p21 = p[-1];                          TPixel p22 = p[0];                          TPixel p23 = p[1];                          TPixel p24 = p[2];                            p += width;                          TPixel p30 = p[-2];                          TPixel p31 = p[-1];                          TPixel p32 = p[0];                          TPixel p33 = p[1];                          TPixel p34 = p[2];                            p += width;                          TPixel p40 = p[-2];                          TPixel p41 = p[-1];                          TPixel p42 = p[0];                          TPixel p43 = p[1];                          TPixel p44 = p[2];                            //int alpha =                          //      1 * p00.Alpha + 04 * p01.Alpha + 06 * p02.Alpha + 04 * p03.Alpha + 1 * p04.Alpha                          //    + 4 * p10.Alpha + 16 * p11.Alpha + 24 * p12.Alpha + 16 * p13.Alpha + 4 * p14.Alpha                          //    + 6 * p20.Alpha + 24 * p21.Alpha + 36 * p22.Alpha + 24 * p23.Alpha + 6 * p24.Alpha                          //    + 4 * p30.Alpha + 16 * p31.Alpha + 24 * p32.Alpha + 16 * p33.Alpha + 4 * p34.Alpha                          //    + 1 * p40.Alpha + 04 * p41.Alpha + 06 * p42.Alpha + 04 * p43.Alpha + 1 * p44.Alpha;                            int red =                                1 * p00.Red + 04 * p01.Red + 06 * p02.Red + 04 * p03.Red + 1 * p04.Red                              + 4 * p10.Red + 16 * p11.Red + 24 * p12.Red + 16 * p13.Red + 4 * p14.Red                              + 6 * p20.Red + 24 * p21.Red + 36 * p22.Red + 24 * p23.Red + 6 * p24.Red                              + 4 * p30.Red + 16 * p31.Red + 24 * p32.Red + 16 * p33.Red + 4 * p34.Red                              + 1 * p40.Red + 04 * p41.Red + 06 * p42.Red + 04 * p43.Red + 1 * p44.Red;                            int green =                                1 * p00.Green + 04 * p01.Green + 06 * p02.Green + 04 * p03.Green + 1 * p04.Green                              + 4 * p10.Green + 16 * p11.Green + 24 * p12.Green + 16 * p13.Green + 4 * p14.Green                              + 6 * p20.Green + 24 * p21.Green + 36 * p22.Green + 24 * p23.Green + 6 * p24.Green                              + 4 * p30.Green + 16 * p31.Green + 24 * p32.Green + 16 * p33.Green + 4 * p34.Green                              + 1 * p40.Green + 04 * p41.Green + 06 * p42.Green + 04 * p43.Green + 1 * p44.Green;                            int blue =                                1 * p00.Blue + 04 * p01.Blue + 06 * p02.Blue + 04 * p03.Blue + 1 * p04.Blue                              + 4 * p10.Blue + 16 * p11.Blue + 24 * p12.Blue + 16 * p13.Blue + 4 * p14.Blue                              + 6 * p20.Blue + 24 * p21.Blue + 36 * p22.Blue + 24 * p23.Blue + 6 * p24.Blue                              + 4 * p30.Blue + 16 * p31.Blue + 24 * p32.Blue + 16 * p33.Blue + 4 * p34.Blue                              + 1 * p40.Blue + 04 * p41.Blue + 06 * p42.Blue + 04 * p43.Blue + 1 * p44.Blue;                            lineDst[w] = new TPixel(red >> 8' green >> 8' blue >> 8' 255);                      }                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidDown,The following statement contains a magic number: int ww = width * 2;
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidDown,The following statement contains a magic number: int hh = height * 2;
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 0; h < hh; h += 2)              {                  hSrc = h / 2;                  lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      lineDst[w] = lineSrc[wSrc];                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2'width-2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 0; h < hh; h += 2)              {                  hSrc = h / 2;                  lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      lineDst[w] = lineSrc[wSrc];                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2'width-2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 0; h < hh; h += 2)              {                  hSrc = h / 2;                  lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      lineDst[w] = lineSrc[wSrc];                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2'width-2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 0; h < hh; h += 2)              {                  hSrc = h / 2;                  lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      lineDst[w] = lineSrc[wSrc];                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2'width-2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 0; h < hh; h += 2)              {                  hSrc = h / 2;                  lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      lineDst[w] = lineSrc[wSrc];                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2'width-2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 0; h < hh; h += 2)              {                  hSrc = h / 2;                  lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      lineDst[w] = lineSrc[wSrc];                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2'width-2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 0; h < hh; h += 2)              {                  hSrc = h / 2;                  lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      lineDst[w] = lineSrc[wSrc];                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2'width-2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,GaussPyramidDown,The following statement contains a magic number: for (int h = 1; h < hh; h += 2)              {                  // 防止取到最后一行                  hSrc = Math.Min(h / 2' height - 2);                    lineDst = imgPyDownStart + h * ww;                  lineSrc = imgStart + hSrc * width;                    // w 是偶数                  for (int w = 0; w < ww; w += 2)                  {                      wSrc = w / 2;                      p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + width];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red) >> 1)'                          (TChannel)((p0.Green + p1.Green) >> 1)'                          (TChannel)((p0.Blue + p1.Blue) >> 1)'                          (TChannel)((p0.Alpha + p1.Alpha) >> 1));                  }                    // w 是奇数                  for (int w = 1; w < ww; w += 2)                  {                      // 防止取到最后一列                      wSrc = Math.Min(w / 2' width - 2);                        p0 = lineSrc[wSrc];                      p1 = lineSrc[wSrc + 1];                      p2 = lineSrc[wSrc + width];                      p3 = lineSrc[wSrc + width + 1];                      lineDst[w] = new TPixel((TChannel)((p0.Red + p1.Red + p2.Red + p3.Red) >> 2)'                          (TChannel)((p0.Green + p1.Green + p2.Green + p3.Green) >> 2)'                          (TChannel)((p0.Blue + p1.Blue + p2.Blue + p3.Blue) >> 2)'                          (TChannel)((p0.Alpha + p1.Alpha + p2.Alpha + p3.Alpha) >> 2));                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,FastPyramidUp4X,The following statement contains a magic number: int ww = width / 4;
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,FastPyramidUp4X,The following statement contains a magic number: int hh = height / 4;
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,FastPyramidUp4X,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  lineSrc = imgStart + 4 * h * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      lineDst[w] = lineSrc[4 * w];                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,FastPyramidUp4X,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  lineSrc = imgStart + 4 * h * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      lineDst[w] = lineSrc[4 * w];                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,FastPyramidUp3X,The following statement contains a magic number: int ww = width / 3;
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,FastPyramidUp3X,The following statement contains a magic number: int hh = height / 3;
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,FastPyramidUp3X,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  lineSrc = imgStart +  3 * h * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      lineDst[w] = lineSrc[3 * w];                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,FastPyramidUp3X,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  lineSrc = imgStart +  3 * h * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      lineDst[w] = lineSrc[3 * w];                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,FastPyramidUp2X,The following statement contains a magic number: int ww = width / 2;
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,FastPyramidUp2X,The following statement contains a magic number: int hh = height / 2;
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,FastPyramidUp2X,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  lineSrc = imgStart + 2 * h * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      lineDst[w] = lineSrc[2 * w];                  }              }
Magic Number,Geb.Image.Hidden,Image_Paramid_Argb_Templete,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Paramid_Templete.cs,FastPyramidUp2X,The following statement contains a magic number: for (int h = 0; h < hh; h++)              {                  lineSrc = imgStart + 2 * h * width;                  lineDst = imgPyUpStart + h * ww;                  for (int w = 0; w < ww; w++)                  {                      lineDst[w] = lineSrc[2 * w];                  }              }
Magic Number,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,CreateFromBitmap,The following statement contains a magic number: const int PixelFormat32bppCMYK = 8207;
Magic Number,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,CopyFrom,The following statement contains a magic number: if (srcLine[0] is Argb32)              {                  int beta;                  while (srcLine < endSrcLine)                  {                      Argb32* pSrc = (Argb32*)srcLine;                      Argb32* endPSrc = pSrc + copyWidth;                      Argb32* pDst = (Argb32*)dstLine;                      while (pSrc < endPSrc)                      {                          if (pSrc->Alpha == 255 || pDst->Alpha == 0)                          {                              *pDst = *pSrc;                          }                          else if (pSrc->Alpha > 0)                          {                                 //BlendAlpha = A1 * A2 \ 255                                 //ImageData(Speed + 3) = A1 + A2 - BlendAlpha                // Alpha                                 //ImageData(Speed) = (B1 * A1 + B2 * A2 - BlendAlpha * (B1 + B2 - Blue)) \ 255                                 //ImageData(Speed + 1) = (G1 * A1 + G2 * A2 - BlendAlpha * (G1 + G2 - Green)) \ 255                                 //ImageData(Speed + 2) = (R1 * A1 + R2 * A2 - BlendAlpha * (R1 + R2 - Red)) \ 255                                //beta = 255 - pSrc->Alpha;                              //pDst->Blue = (Byte)((pSrc->Blue * pSrc->Alpha + pDst->Blue * beta) >> 8);                              //pDst->Green = (Byte)((pSrc->Green * pSrc->Alpha + pDst->Green * beta) >> 8);                              //pDst->Red = (Byte)((pSrc->Red * pSrc->Alpha + pDst->Red * beta) >> 8);                                alpha1 = pSrc->Alpha;                              alpha2 = pDst->Alpha;                              blendAlpha = alpha1 * alpha2 / 255;                              beta = 255 - pSrc->Alpha;                              pDst->Alpha = (Byte)(alpha1 + alpha2 - blendAlpha);                                // 严格来说，下面的转换算法只是近似算法，不是准确算法。准确算法太耗时间                              pDst->Blue = (Byte)((pSrc->Blue * alpha1 + pDst->Blue * beta) >> 8);                              pDst->Green = (Byte)((pSrc->Green * alpha1 + pDst->Green * beta) >> 8);                              pDst->Red = (Byte)((pSrc->Red * alpha1 + pDst->Red * beta) >> 8);                          }                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }              else              {                  while (srcLine < endSrcLine)                  {                      TPixel* pSrc = srcLine;                      TPixel* endPSrc = pSrc + copyWidth;                      TPixel* pDst = dstLine;                      while (pSrc < endPSrc)                      {                          *pDst = *pSrc;                          pSrc++;                          pDst++;                      }                      srcLine += srcWidth;                      dstLine += dstWidth;                  }              }
Magic Number,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,ApplyModeFilter,The following statement contains a magic number: if (size <= 1) throw new ArgumentOutOfRangeException("size 必须大于1.");              else if (size > 127) throw new ArgumentOutOfRangeException("size 最大为127.");              else if (size % 2 == 0) throw new ArgumentException("size 应该是奇数.");
Magic Number,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,ApplyModeFilter,The following statement contains a magic number: if (size <= 1) throw new ArgumentOutOfRangeException("size 必须大于1.");              else if (size > 127) throw new ArgumentOutOfRangeException("size 最大为127.");              else if (size % 2 == 0) throw new ArgumentException("size 应该是奇数.");
Magic Number,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,ApplyModeFilter,The following statement contains a magic number: int radius = size / 2;
Magic Number,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,DrawLine,The following statement contains a magic number: int n2dy = dy * 2;
Magic Number,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,DrawLine,The following statement contains a magic number: int n2dydx = (dy - dx) * 2;
Magic Number,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,DrawLine,The following statement contains a magic number: int d = dy * 2 - dx;
Magic Number,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,DrawLine,The following statement contains a magic number: if (Math.Abs(deltaX) < 0.0001)              {                  if (Math.Abs(deltaY) < 0.0001)                  {                      SetColor(start.X' start.Y' color' radius' ww' hh);                      return;                  };                    float yStart = start.Y;                  float yEnd = end.Y;                  float x = start.X;                    if (yEnd < yStart)                  {                      float tmp = yEnd;                      yEnd = yStart;                      yStart = tmp;                  }                    yStart = Math.Max(0' yStart);                  yEnd = Math.Min(hh' yEnd);                    for (float y = yStart; y <= yEnd; y++)                  {                      SetColor(x' y' color' radius' ww' hh);                  }              }              else              {                  float xStart = start.X;                  float xEnd = end.X;                  if (xEnd < xStart)                  {                      float tmp = xEnd;                      xEnd = xStart;                      xStart = tmp;                  }                    float step = 1;                  float grad = Math.Abs(deltaY / deltaX);                  if (grad > 1)                  {                      step = 1 / grad;                  }                    for (float x = xStart; x <= xEnd; x += step)                  {                      float deltaXX = start.X - x;                      float deltaYY = deltaY * (deltaXX / deltaX);                      float y = start.Y - deltaYY;                        SetColor(x' y' color' radius' ww' hh);                  }              }
Magic Number,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,DrawLine,The following statement contains a magic number: if (Math.Abs(deltaX) < 0.0001)              {                  if (Math.Abs(deltaY) < 0.0001)                  {                      SetColor(start.X' start.Y' color' radius' ww' hh);                      return;                  };                    float yStart = start.Y;                  float yEnd = end.Y;                  float x = start.X;                    if (yEnd < yStart)                  {                      float tmp = yEnd;                      yEnd = yStart;                      yStart = tmp;                  }                    yStart = Math.Max(0' yStart);                  yEnd = Math.Min(hh' yEnd);                    for (float y = yStart; y <= yEnd; y++)                  {                      SetColor(x' y' color' radius' ww' hh);                  }              }              else              {                  float xStart = start.X;                  float xEnd = end.X;                  if (xEnd < xStart)                  {                      float tmp = xEnd;                      xEnd = xStart;                      xStart = tmp;                  }                    float step = 1;                  float grad = Math.Abs(deltaY / deltaX);                  if (grad > 1)                  {                      step = 1 / grad;                  }                    for (float x = xStart; x <= xEnd; x += step)                  {                      float deltaXX = start.X - x;                      float deltaYY = deltaY * (deltaXX / deltaX);                      float y = start.Y - deltaYY;                        SetColor(x' y' color' radius' ww' hh);                  }              }
Magic Number,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,DrawText,The following statement contains a magic number: int base_line = +(ascii[0] & 15);
Magic Number,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,DrawText,The following statement contains a magic number: List<PointS> pts = new List<PointS>(1 << 10);
Magic Number,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,DrawText,The following statement contains a magic number: for (int i = 0; i < txt.Length; i++)              {                  Char c = txt[i];                  if (c >= 127 || c < ' ')                      c = '?';                  String fontData = faces[ascii[(c - ' ') + 1]];                    PointS p = new PointS();                  p.X = (short)(fontData[0] - 'R');                  p.Y = (short)(fontData[1] - 'R');                  double dx = p.Y * hscale;                  view_x -= p.X * hscale;                  pts.Clear();                  for (int k = 2; k <= fontData.Length; )                  {                      if (k == fontData.Length || fontData[k] == ' ')                      {                          // Draw Poly Line                          if (pts.Count > 1)                          {                              for (int j = 1; j < pts.Count; j++)                              {                                  DrawLine(pts[j - 1].ToPointF()' pts[j].ToPointF()' color);                              }                          }                          pts.Clear();                          k++;                      }                      else                      {                          p.X = (short)(fontData[k] - 'R');                          p.Y = (short)(fontData[k+1] - 'R');                          k += 2;                          pts.Add(new PointS((short)Math.Round(p.X * hscale + view_x)'                              (short)Math.Round(p.Y * vscale + view_y)));                      }                  }                    view_x += dx;              }
Magic Number,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,DrawText,The following statement contains a magic number: for (int i = 0; i < txt.Length; i++)              {                  Char c = txt[i];                  if (c >= 127 || c < ' ')                      c = '?';                  String fontData = faces[ascii[(c - ' ') + 1]];                    PointS p = new PointS();                  p.X = (short)(fontData[0] - 'R');                  p.Y = (short)(fontData[1] - 'R');                  double dx = p.Y * hscale;                  view_x -= p.X * hscale;                  pts.Clear();                  for (int k = 2; k <= fontData.Length; )                  {                      if (k == fontData.Length || fontData[k] == ' ')                      {                          // Draw Poly Line                          if (pts.Count > 1)                          {                              for (int j = 1; j < pts.Count; j++)                              {                                  DrawLine(pts[j - 1].ToPointF()' pts[j].ToPointF()' color);                              }                          }                          pts.Clear();                          k++;                      }                      else                      {                          p.X = (short)(fontData[k] - 'R');                          p.Y = (short)(fontData[k+1] - 'R');                          k += 2;                          pts.Add(new PointS((short)Math.Round(p.X * hscale + view_x)'                              (short)Math.Round(p.Y * vscale + view_y)));                      }                  }                    view_x += dx;              }
Magic Number,Geb.Image.Hidden,Image_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__Image_Template.cs,DrawText,The following statement contains a magic number: for (int i = 0; i < txt.Length; i++)              {                  Char c = txt[i];                  if (c >= 127 || c < ' ')                      c = '?';                  String fontData = faces[ascii[(c - ' ') + 1]];                    PointS p = new PointS();                  p.X = (short)(fontData[0] - 'R');                  p.Y = (short)(fontData[1] - 'R');                  double dx = p.Y * hscale;                  view_x -= p.X * hscale;                  pts.Clear();                  for (int k = 2; k <= fontData.Length; )                  {                      if (k == fontData.Length || fontData[k] == ' ')                      {                          // Draw Poly Line                          if (pts.Count > 1)                          {                              for (int j = 1; j < pts.Count; j++)                              {                                  DrawLine(pts[j - 1].ToPointF()' pts[j].ToPointF()' color);                              }                          }                          pts.Clear();                          k++;                      }                      else                      {                          p.X = (short)(fontData[k] - 'R');                          p.Y = (short)(fontData[k+1] - 'R');                          k += 2;                          pts.Add(new PointS((short)Math.Round(p.X * hscale + view_x)'                              (short)Math.Round(p.Y * vscale + view_y)));                      }                  }                    view_x += dx;              }
Magic Number,Geb.Image.Hidden,ImageFilter_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__ImageFilter_Template.cs,ApplyConvolution,The following statement contains a magic number: int extend = Math.Max(kernelWidth' kernelHeight) / 2;
Magic Number,Geb.Image.Hidden,ImageFilter_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__ImageFilter_Template.cs,ApplyConvolution,The following statement contains a magic number: TImage maskImage = new TImage(Width + extend * 2' Height + extend * 2);
Magic Number,Geb.Image.Hidden,ImageFilter_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__ImageFilter_Template.cs,ApplyConvolution,The following statement contains a magic number: TImage maskImage = new TImage(Width + extend * 2' Height + extend * 2);
Magic Number,Geb.Image.Hidden,ImageFilter_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__ImageFilter_Template.cs,ApplyConvolution,The following statement contains a magic number: int extendWidth = this.Width + extend * 2;
Magic Number,Geb.Image.Hidden,ImageFilter_Template,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\__ImageFilter_Template.cs,ApplyConvolution,The following statement contains a magic number: int extendHeight = this.Height + extend * 2;
Magic Number,Geb.Image.Sampling,ImageSamplingAlgorithm,C:\repos\xiaotie_GebImage\src\Geb.Image\Utils\ImageSamplingAlgorithm.cs,RandomUniformSampling,The following statement contains a magic number: if (srcList.Count > count * 3)              {                  srcList = srcList.GetRange(0' count * 3);                  numNeedRemoved = srcList.Count - count;              }
Magic Number,Geb.Image.Sampling,ImageSamplingAlgorithm,C:\repos\xiaotie_GebImage\src\Geb.Image\Utils\ImageSamplingAlgorithm.cs,RandomUniformSampling,The following statement contains a magic number: if (srcList.Count > count * 3)              {                  srcList = srcList.GetRange(0' count * 3);                  numNeedRemoved = srcList.Count - count;              }
Magic Number,Geb.Image.Sampling,ImageSamplingAlgorithm,C:\repos\xiaotie_GebImage\src\Geb.Image\Utils\ImageSamplingAlgorithm.cs,RandomUniformSampling,The following statement contains a magic number: List<PairDistance> list = new List<PairDistance>(srcList.Count * (1 + srcList.Count / 2));
Missing Default,Geb.Image,ImageU8,C:\repos\xiaotie_GebImage\src\Geb.Image\UnmanagedImage\Templates\_ImageU8_Csmacro.cs,ApplyCannyEdgeDetector,The following switch statement is missing a default case: switch (orients[o])                      {                          case 0:                              leftPixel = gradients[x - 1' y];                              rightPixel = gradients[x + 1' y];                              break;                          case 45:                              leftPixel = gradients[x - 1' y + 1];                              rightPixel = gradients[x + 1' y - 1];                              break;                          case 90:                              leftPixel = gradients[x' y + 1];                              rightPixel = gradients[x' y - 1];                              break;                          case 135:                              leftPixel = gradients[x + 1' y + 1];                              rightPixel = gradients[x - 1' y - 1];                              break;                      }
