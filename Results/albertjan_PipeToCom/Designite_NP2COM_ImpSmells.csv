Implementation smell,Namespace,Class,File,Method,Description
Long Method,NP2COM,Connection,C:\repos\albertjan_PipeToCom\NP2COM\Connection.cs,PortForwarder,The method has 104 lines of code.
Empty Catch Block,NP2COM,Connection,C:\repos\albertjan_PipeToCom\NP2COM\Connection.cs,PortForwarder,The method has an empty catch block.
Empty Catch Block,NP2COM,Connection,C:\repos\albertjan_PipeToCom\NP2COM\Connection.cs,PortForwarder,The method has an empty catch block.
Empty Catch Block,NP2COM,Connection,C:\repos\albertjan_PipeToCom\NP2COM\Connection.cs,PortForwarder,The method has an empty catch block.
Empty Catch Block,NP2COM,Connection,C:\repos\albertjan_PipeToCom\NP2COM\Connection.cs,PortForwarder,The method has an empty catch block.
Empty Catch Block,NP2COM,Connection,C:\repos\albertjan_PipeToCom\NP2COM\Connection.cs,PortForwarder,The method has an empty catch block.
Empty Catch Block,NP2COM,Connection,C:\repos\albertjan_PipeToCom\NP2COM\Connection.cs,PortForwarder,The method has an empty catch block.
Magic Number,NP2COM,Connection,C:\repos\albertjan_PipeToCom\NP2COM\Connection.cs,PortForwarder,The following statement contains a magic number: do              {                  if (pipeEvent.WaitOne(0))                  {                      pipeEvent.Reset();                        pipeReadResult = this.namedPipe.BeginRead(                          pipeBuffer'                          0'                          pipeBuffer.Length'                          delegate(IAsyncResult namedPipeAsyncResult)                          {                              try                              {                                  int actualLength = this.namedPipe.EndRead(namedPipeAsyncResult);                                    Logger.Debug("Read (NP): " + GetLogString(pipeBuffer' actualLength));                                    this.serialPort.BaseStream.BeginWrite(                                      pipeBuffer'                                      0'                                      actualLength'                                      delegate(IAsyncResult serialPortAsyncResult)                                      {                                          this.serialPort.BaseStream.EndWrite(serialPortAsyncResult);                                            Logger.Debug("Wrote (CP): " + GetLogString(pipeBuffer' actualLength));                                      }'                                      null);                              }                              catch (IOException)                              {                              }                              catch (ObjectDisposedException)                              {                                  // Aborted due to close                              }                              catch (InvalidOperationException)                              {                                  // Aborted due to close                              }                                 pipeEvent.Set();                          }'                          null);                  }                    if (serialEvent.WaitOne(0))                  {                      serialEvent.Reset();                        serialReadResult = this.serialPort.BaseStream.BeginRead(                          serialBuffer'                          0'                          serialBuffer.Length'                          delegate(IAsyncResult serialPortAsyncResult)                          {                              try                              {                                  int actualLength = this.serialPort.BaseStream.EndRead(serialPortAsyncResult);                                    Logger.Debug("Read (CP): " + GetLogString(serialBuffer' actualLength));                                    this.namedPipe.BeginWrite(                                      serialBuffer'                                      0'                                      actualLength'                                      delegate(IAsyncResult namedPipeAsyncResult)                                      {                                          this.namedPipe.EndWrite(namedPipeAsyncResult);                                            Logger.Debug("Wrote (NP): " + GetLogString(serialBuffer' actualLength));                                      }'                                      null);                              }                              catch (IOException)                              {                              }                              catch (ObjectDisposedException)                              {                                  // Aborted due to close                              }                              catch (InvalidOperationException)                              {                                  // Aborted due to close                              }                                 serialEvent.Set();                          }'                          null);                  }                    waitResult =                       WaitHandle.WaitAny(                          new WaitHandle[]                          {                              serialEvent'                              pipeEvent'                              stopEvent                          });                }              while (waitResult != 2);
