Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.Cci,OptionParsing,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,PrintOptions,The method has 121 lines of code.
Complex Method,Microsoft.Cci,OptionParsing,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,SplitLineWithQuotes,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci,OptionParsing,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,ProcessOptionWithMatchingField,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,ProbeAssemblyReference,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetTypeReferenceInterendIdIgnoringCustomModifiers,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Cci,MemberHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetFieldBitOffset,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,MemberHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetImplicitlyImplementedInterfaceMethods,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Cci,MemberHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetImplicitlyOverriddenBaseClassMethod,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci,SignatureFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetEventSignature,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,SignatureFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetFieldSignature,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Cci,SignatureFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetMethodSignature,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Cci,SignatureFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendMethodParameters,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,SignatureFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendMethodName,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,SignatureFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendPropertyName,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,DispatchAsReference,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,MetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,TraverseChildren,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,MetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,TraverseChildren,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,MetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,TraverseChildren,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci,MetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,TraverseChildren,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,MetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,TraverseChildren,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,MetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,TraverseChildren,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,MetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,TraverseChildren,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,CanAccess,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetDefiningUnit,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetDefiningUnitReference,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetField,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetMethod,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,MostDerivedCommonBaseClass,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SpecializeTypeReference,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SpecializeTypeReference,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.Cci,TypeNameFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,AddGenericParametersIfNeeded,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci,TypeNameFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,AppendArrayDimensions,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,TypeNameFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetTypeName,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci,TypeNameFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetGenericTypeInstanceName,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,AssemblyOneAllowsAssemblyTwoToAccessItsInternals,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,GetType,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,GetNestedType,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,Cyclomatic complexity of the method is 25
Complex Method,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.Cci.Immutable,GenericTypeInstance,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeMember,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.Immutable,GenericParameter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeTypeReference,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Immutable,SpecializedNestedTypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeMember,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReference,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci.Immutable,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,AssemblyOneAllowsAssemblyTwoToAccessItsInternals,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci.Immutable,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,GetType,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.Immutable,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,GetNestedType,Cyclomatic complexity of the method is 9
Long Parameter List,Microsoft.Cci,OptionParsing,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,FinishArgument,The method has 6 parameters. Parameters: line' start' args' currentArg' index' includeEmpty
Long Parameter List,Microsoft.Cci,OptionParsing,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,ParseValue,The method has 5 parameters. Parameters: parser' equalArgument' args' index' result
Long Parameter List,Microsoft.Cci,OptionParsing,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,ProcessOptionWithMatchingField,The method has 5 parameters. Parameters: arg' args' index' explicitArgument' fi
Long Parameter List,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,MetadataHostEnvironment,The method has 5 parameters. Parameters: nameTable' factory' pointerSize' searchPaths' searchInGAC
Long Parameter List,Microsoft.Cci,MetadataReaderHost,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,MetadataReaderHost,The method has 5 parameters. Parameters: nameTable' factory' pointerSize' searchPaths' searchInGAC
Long Parameter List,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetSignatureInternId,The method has 6 parameters. Parameters: callingConvention' parameters' extraArgumentTypes' returnValueCustomModifiers' returnValueIsByRef' returnType
Long Parameter List,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetFunctionPointerTypeReferenceInternId,The method has 6 parameters. Parameters: callingConvention' parameters' extraArgumentTypes' returnValueCustomModifiers' returnValueIsByRef' returnType
Long Parameter List,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetFunctionPointerTypeReferenceInternedKey,The method has 6 parameters. Parameters: callingConvention' parameters' extraArgumentTypes' returnValueCustomModifiers' returnValueIsByRef' returnType
Long Parameter List,Microsoft.Cci,SignatureStore,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,SignatureStore,The method has 8 parameters. Parameters: callingConvention' requiredParameterListInteredId' extraParameterListInteredId' returnValueIsByRef' returnValueCustomModifiersListInteredId' returnTypeReferenceInteredId' genericParameterCount' internedId
Long Parameter List,Microsoft.Cci,GlobalAssemblyCache,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\GlobalAssemblyCache.cs,CreateAssemblyEnum,The method has 5 parameters. Parameters: ppEnum' pAppCtx' pName' dwFlags' pvReserved
Long Parameter List,Microsoft.Cci,IAssemblyName,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\GlobalAssemblyCache.cs,BindToObject,The method has 8 parameters. Parameters: refIID' pAsmBindSink' pApplicationContext' szCodeBase' llFlags' pvReserved' cbReserved' ppv
Long Parameter List,Microsoft.Cci,MethodReference,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,MethodReference,The method has 7 parameters. Parameters: host' containingType' callingConvention' returnType' name' genericParameterCount' parameterTypes
Long Parameter List,Microsoft.Cci,MethodReference,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,MethodReference,The method has 8 parameters. Parameters: host' containingType' callingConvention' returnType' name' genericParameterCount' parameters' extraParameterTypes
Long Parameter List,Microsoft.Cci,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,GetType,The method has 5 parameters. Parameters: nameTable' namespaceDefinition' typeName' genericParameterCount' offset
Long Parameter List,Microsoft.Cci,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,GetNestedType,The method has 5 parameters. Parameters: nameTable' typeDefinition' typeName' genericParameterCount' offset
Long Parameter List,Microsoft.Cci,MemoryMappedFile,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnmanagedFileIO.cs,CreateFileMapping,The method has 6 parameters. Parameters: hFile' lpAttributes' flProtect' dwMaximumSizeHigh' dwMaximumSizeLow' lpName
Long Parameter List,Microsoft.Cci,MemoryMappedFile,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnmanagedFileIO.cs,MapViewOfFile,The method has 5 parameters. Parameters: hFileMappingObject' dwDesiredAccess' dwFileOffsetHigh' dwFileOffsetLow' dwNumberOfBytesToMap
Long Parameter List,Microsoft.Cci.Immutable,NamespaceTypeReference,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,NamespaceTypeReference,The method has 7 parameters. Parameters: host' containingUnitNamespace' name' genericParameterCount' isEnum' isValueType' typeCode
Long Parameter List,Microsoft.Cci.Immutable,PlatformType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,CreateReference,The method has 5 parameters. Parameters: assemblyReference' isValueType' genericParameterCount' typeCode' names
Long Parameter List,Microsoft.Cci.Immutable,FunctionPointerType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,FunctionPointerType,The method has 7 parameters. Parameters: callingConvention' returnValueIsByRef' type' returnValueCustomModifiers' parameters' extraArgumentTypes' internFactory
Long Parameter List,Microsoft.Cci.Immutable,Matrix,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,Matrix,The method has 5 parameters. Parameters: elementType' rank' lowerBounds' sizes' internFactory
Long Parameter List,Microsoft.Cci.Immutable,Matrix,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,GetMatrix,The method has 5 parameters. Parameters: elementType' rank' lowerBounds' sizes' internFactory
Long Parameter List,Microsoft.Cci.Immutable,SpecializedNestedTypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializedNestedTypeDefinition,The method has 5 parameters. Parameters: unspecializedVersion' partiallySpecializedVersion' containingTypeDefinition' containingGenericTypeInstance' internFactory
Long Parameter List,Microsoft.Cci.Immutable,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,GetType,The method has 5 parameters. Parameters: nameTable' namespaceDefinition' typeName' genericParameterCount' offset
Long Parameter List,Microsoft.Cci.Immutable,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,GetNestedType,The method has 5 parameters. Parameters: nameTable' typeDefinition' typeName' genericParameterCount' offset
Long Identifier,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,,The length of the parameter contractAssemblySymbolicIdentity is 32.
Long Identifier,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,,The length of the parameter systemCoreAssemblySymbolicIdentity is 34.
Long Identifier,Microsoft.Cci,MetadataReaderHost,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,,The length of the parameter disposableObjectAllocatedByThisHost is 35.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetNamespaceTypeReferenceInternId,The length of the parameter containingUnitNamespaceInteredId is 32.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetNestedTypeReferenceInternId,The length of the parameter containingTypeReferenceInteredId is 32.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetGenericMethodParameterReferenceInternId,The length of the parameter definingMethodReferenceInternId is 31.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetSignatureInternId,The length of the parameter requiredParameterTypesInternedId is 32.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetSignatureInternId,The length of the parameter returnValueCustomModifiersInternedId is 36.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetMethodReferenceInternedId,The length of the parameter containingTypeReferenceInternedId is 33.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetMethodReferenceInternedId,The length of the parameter requiredParameterTypesInternedId is 32.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetMethodReferenceInternedId,The length of the parameter returnValueCustomModifiersInternedId is 36.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetGenericMethodInstanceReferenceInternedKey,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetFieldReferenceInternedId,The length of the parameter containingTypeReferenceInternedId is 33.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetCustomModifierListInternId,The length of the parameter currentCustomModifierInternedId is 31.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetTypeReferenceInterendIdIgnoringCustomModifiers,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,,The length of the parameter CurrentCustomModifierInternValue is 32.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,,The length of the parameter CurrentCustomModifierListInternValue is 36.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,,The length of the parameter CurrentParameterTypeInternValue is 31.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,,The length of the parameter CurrentParameterTypeListInternValue is 35.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,,The length of the parameter CurrentMethodReferenceInternValue is 33.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,,The length of the parameter CurrentFieldReferenceInternValue is 32.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,,The length of the parameter GenericMethodInstanceHashtable is 30.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,,The length of the parameter GenericMethodTypeParameterHashTable is 35.
Long Identifier,Microsoft.Cci,SignatureStore,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,SignatureStore,The length of the parameter requiredParameterListInteredId is 30.
Long Identifier,Microsoft.Cci,SignatureStore,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,SignatureStore,The length of the parameter returnValueCustomModifiersListInteredId is 39.
Long Identifier,Microsoft.Cci,SignatureStore,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,,The length of the parameter RequiredParameterListInternedId is 31.
Long Identifier,Microsoft.Cci,SignatureStore,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,,The length of the parameter ReturnValueCustomModifiersListInteredId is 39.
Long Identifier,Microsoft.Cci,MemberHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,,The length of the parameter GenericMethodParameterEqualityComparer is 38.
Long Identifier,Microsoft.Cci,MemberHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,,The length of the parameter ResolvingGenericMethodParameterEqualityComparer is 47.
Long Identifier,Microsoft.Cci,MemberHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,,The length of the parameter ResolvingParameterInformationComparer is 37.
Long Identifier,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter operationExceptionInformations is 30.
Long Identifier,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter specializedNestedTypeDefinition is 31.
Long Identifier,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,DispatchAsReference,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci,BaseMetadataVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci,BaseMetadataVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci,BaseMetadataVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter specializedNestedTypeDefinition is 31.
Long Identifier,Microsoft.Cci,BaseMetadataVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci,MetadataVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci,MetadataVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci,MetadataVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter specializedNestedTypeDefinition is 31.
Long Identifier,Microsoft.Cci,MetadataVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci,MetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Traverse,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci,MetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Traverse,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci,MetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Traverse,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci,MetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Traverse,The length of the parameter operationExceptionInformations is 30.
Long Identifier,Microsoft.Cci,MetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,TraverseChildren,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci,MetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,TraverseChildren,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci,MetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,TraverseChildren,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci,MetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,,The length of the parameter objectsThatHaveAlreadyBeenTraversed is 35.
Long Identifier,Microsoft.Cci,Dispatcher,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci,Dispatcher,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci,Dispatcher,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter specializedNestedTypeDefinition is 31.
Long Identifier,Microsoft.Cci,Dispatcher,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetDefiningUnitReference,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci,UnitSetNamespace,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,,The length of the parameter nestedUnitNamespaceToNestedUnitSetNamespaceMap is 46.
Long Identifier,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the parameter specializedNestedTypeDefinition is 31.
Long Identifier,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci.Immutable,SpecializedEventDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,SpecializeIfConstructed,The length of the parameter partiallySpecializedTypeReference is 33.
Long Identifier,Microsoft.Cci.Immutable,SpecializedFieldDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the parameter partiallySpecializedTypeReference is 33.
Long Identifier,Microsoft.Cci.Immutable,SpecializedGenericMethodParameter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the parameter partiallySpecializedTypeReference is 33.
Long Identifier,Microsoft.Cci.Immutable,SpecializedMethodBody,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,MapBody,The length of the parameter specializedOperationExceptionInformation is 40.
Long Identifier,Microsoft.Cci.Immutable,SpecializedMethodBody,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,MapBody,The length of the parameter unspecializedOperationException is 31.
Long Identifier,Microsoft.Cci.Immutable,SpecializedMethodDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the parameter partiallySpecializedTypeReference is 33.
Long Identifier,Microsoft.Cci.Immutable,SpecializedPropertyDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the parameter partiallySpecializedTypeReference is 33.
Long Identifier,Microsoft.Cci.Immutable,PlatformType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,,The length of the parameter systemDiagnosticsContractsContract is 34.
Long Identifier,Microsoft.Cci.Immutable,PlatformType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,,The length of the parameter systemCollectionsGenericDictionary is 34.
Long Identifier,Microsoft.Cci.Immutable,PlatformType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,,The length of the parameter systemCollectionsGenericICollection is 35.
Long Identifier,Microsoft.Cci.Immutable,PlatformType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,,The length of the parameter systemCollectionsGenericIEnumerable is 35.
Long Identifier,Microsoft.Cci.Immutable,PlatformType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,,The length of the parameter systemCollectionsGenericIEnumerator is 35.
Long Identifier,Microsoft.Cci.Immutable,PlatformType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,,The length of the parameter systemCollectionsIStructuralComparable is 38.
Long Identifier,Microsoft.Cci.Immutable,PlatformType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,,The length of the parameter systemCollectionsIStructuralEquatable is 37.
Long Identifier,Microsoft.Cci.Immutable,PlatformType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,,The length of the parameter systemGlobalizationCultureInfo is 30.
Long Identifier,Microsoft.Cci.Immutable,PlatformType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,,The length of the parameter systemRuntimeCompilerServicesCallConvCdecl is 42.
Long Identifier,Microsoft.Cci.Immutable,PlatformType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,,The length of the parameter systemRuntimeCompilerServicesCompilerGeneratedAttribute is 55.
Long Identifier,Microsoft.Cci.Immutable,PlatformType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,,The length of the parameter systemRuntimeCompilerServicesExtensionAttribute is 47.
Long Identifier,Microsoft.Cci.Immutable,PlatformType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,,The length of the parameter systemRuntimeCompilerServicesInternalsVisibleToAttribute is 56.
Long Identifier,Microsoft.Cci.Immutable,PlatformType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,,The length of the parameter systemRuntimeCompilerServicesIsConst is 36.
Long Identifier,Microsoft.Cci.Immutable,PlatformType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,,The length of the parameter systemRuntimeCompilerServicesIsVolatile is 39.
Long Identifier,Microsoft.Cci.Immutable,PlatformType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,,The length of the parameter systemRuntimeCompilerServicesReferenceAssemblyAttribute is 55.
Long Identifier,Microsoft.Cci.Immutable,PlatformType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,,The length of the parameter systemRuntimeInteropServicesDllImportAttribute is 46.
Long Identifier,Microsoft.Cci.Immutable,PlatformType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,,The length of the parameter systemSecurityPermissionsSecurityAction is 39.
Long Identifier,Microsoft.Cci.Immutable,PlatformType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,,The length of the parameter systemSecuritySecurityCriticalAttribute is 39.
Long Identifier,Microsoft.Cci.Immutable,PlatformType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,,The length of the parameter systemSecuritySecuritySafeCriticalAttribute is 43.
Long Identifier,Microsoft.Cci.Immutable,PlatformType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,,The length of the parameter systemSecuritySuppressUnmanagedCodeSecurityAttribute is 52.
Long Identifier,Microsoft.Cci.Immutable,Scope<MemberType>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,,The length of the parameter caseSensitiveMemberNameToMemberListMap is 38.
Long Identifier,Microsoft.Cci.Immutable,Scope<MemberType>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,,The length of the parameter caseInsensitiveMemberNameToMemberListMap is 40.
Long Identifier,Microsoft.Cci.Immutable,SpecializedNestedTypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,CopyAndSpecialize,The length of the parameter partiallySpecializedTypeReference is 33.
Long Identifier,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReference,The length of the parameter partiallySpecializedTypeReference is 33.
Long Identifier,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the parameter partiallySpecializedTypeReference is 33.
Long Identifier,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the parameter partiallySpecializedTypeReference is 33.
Long Identifier,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the parameter partiallySpecializedTypeReference is 33.
Long Identifier,Microsoft.Cci.Immutable,UnitSetNamespace,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,,The length of the parameter nestedUnitNamespaceToNestedUnitSetNamespaceMap is 46.
Long Statement,Microsoft.Cci,OptionParsing,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,SplitLineWithQuotes,The length of the statement  "              AddError("Response file '{0}' line {1}' char {2} contains '\"' not starting or ending an argument"' responseFileName' lineNo' index); " is 133.
Long Statement,Microsoft.Cci,OptionParsing,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,GatherRequiredOptions,The length of the statement  "      foreach (var field in this.GetType().GetFields(System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public)) " is 128.
Long Statement,Microsoft.Cci,OptionParsing,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,ParseValue,The length of the statement  "          foreach (System.Reflection.FieldInfo enumConstant in type.GetFields(System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Public)) " is 147.
Long Statement,Microsoft.Cci,OptionParsing,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,FindOptionByReflection,The length of the statement  "      System.Reflection.FieldInfo fi = this.GetType().GetField(arg' System.Reflection.BindingFlags.IgnoreCase | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public); " is 187.
Long Statement,Microsoft.Cci,OptionParsing,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,FindOptionByReflection,The length of the statement  "        fi = this.GetType().GetField(arg' System.Reflection.BindingFlags.IgnoreCase | System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Public); " is 157.
Long Statement,Microsoft.Cci,OptionParsing,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,TryGetOptions,The length of the statement  "        System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.FlattenHierarchy | System.Reflection.BindingFlags.Public); " is 129.
Long Statement,Microsoft.Cci,OptionParsing,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,GetListField,The length of the statement  "      System.Collections.IList result = (System.Collections.IList)fi.FieldType.GetConstructor(new Type[] { }).Invoke(new object[] { }); " is 129.
Long Statement,Microsoft.Cci,OptionParsing,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,PrintOptions,The length of the statement  "      foreach (System.Reflection.FieldInfo f in this.GetType().GetFields(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance)) " is 148.
Long Statement,Microsoft.Cci,OptionParsing,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,PrintOptions,The length of the statement  "          foreach (System.Reflection.FieldInfo enumConstant in opttype.GetFields(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static)) " is 150.
Long Statement,Microsoft.Cci,OptionParsing,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,PrintDerivedOptions,The length of the statement  "      foreach (System.Reflection.FieldInfo f in this.GetType().GetFields(System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Public)) " is 146.
Long Statement,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetCoreAssemblySymbolicIdentity,The length of the statement  "          //The loaded assemblies have an opinion on the identity of the core assembly. By default' we are going to respect that opinion. " is 127.
Long Statement,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetCoreAssemblySymbolicIdentity,The length of the statement  "            //However' they do not know where to find it. (This will only be non empty if one of the loaded assemblies itself is the core assembly.) " is 136.
Long Statement,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetCoreAssemblySymbolicIdentity,The length of the statement  "              //We don't know where to find the core assembly that the loaded assemblies want' but we do know where to find the core assembly " is 127.
Long Statement,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetCoreAssemblySymbolicIdentity,The length of the statement  "              //that we are running on. Perhaps it is the same assembly as the one we've identified. In that case we know where it can be found. " is 130.
Long Statement,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetCoreAssemblySymbolicIdentity,The length of the statement  "              var myCore = new AssemblyIdentity(this.NameTable.GetNameFor(coreAssemblyName.Name)' ""' coreAssemblyName.Version' coreAssemblyName.GetPublicKeyToken()' loc); " is 157.
Long Statement,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetCoreAssemblySymbolicIdentity,The length of the statement  "      //In this case' we have little option but to choose the identity of the core assembly of the platform we are running on. " is 120.
Long Statement,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetCoreAssemblySymbolicIdentity,The length of the statement  "      return new AssemblyIdentity(this.NameTable.GetNameFor(coreAssemblyName.Name)' ""' coreAssemblyName.Version' coreAssemblyName.GetPublicKeyToken()' loc); " is 151.
Long Statement,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,LoadAssembly,The length of the statement  "        if (string.IsNullOrEmpty(assemblyIdentity.Location) || string.Equals(assemblyIdentity.Location' "unknown://location"' StringComparison.OrdinalIgnoreCase)) { " is 156.
Long Statement,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,ReportError,The length of the statement  "        Microsoft.Cci.ErrorEventArgs errorEventArguments = new Microsoft.Cci.ErrorEventArgs(error.ErrorReporter' error.Location' errors.AsReadOnly()); " is 142.
Long Statement,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,UnifyAssembly,The length of the statement  "      if (string.Equals(assemblyIdentity.Name.Value' "mscorlib"' StringComparison.OrdinalIgnoreCase) && assemblyIdentity.Version == new Version(255' 255' 255' 255)) " is 158.
Long Statement,Microsoft.Cci,MetadataReaderHost,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,OpenBinaryDocument,The length of the statement  "        IBinaryDocumentMemoryBlock binDocMemoryBlock = MemoryMappedFile.CreateMemoryMappedFile(sourceDocument.Location' sourceDocument); " is 128.
Long Statement,Microsoft.Cci,MetadataReaderHost,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,OpenBinaryDocument,The length of the statement  "        IBinaryDocumentMemoryBlock binDocMemoryBlock = UnmanagedBinaryMemoryBlock.CreateUnmanagedBinaryMemoryBlock(sourceDocument.Location' sourceDocument); " is 148.
Long Statement,Microsoft.Cci,MetadataReaderHost,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,OpenBinaryDocument,The length of the statement  "        IBinaryDocumentMemoryBlock binDocMemoryBlock = MemoryMappedFile.CreateMemoryMappedFile(newBinaryDocument.Location' newBinaryDocument); " is 134.
Long Statement,Microsoft.Cci,MetadataReaderHost,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,OpenBinaryDocument,The length of the statement  "        IBinaryDocumentMemoryBlock binDocMemoryBlock = UnmanagedBinaryMemoryBlock.CreateUnmanagedBinaryMemoryBlock(newBinaryDocument.Location' newBinaryDocument); " is 154.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetNestedNamespaceInternId,The length of the statement  "      uint value = this.NestedNamespaceHashtable.Find(parentNamespaceInternedId' (uint)nestedUnitNamespaceReference.Name.UniqueKey); " is 126.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetUnitNamespaceInternId,The length of the statement  "      INestedUnitNamespaceReference/*?*/ nestedUnitNamespaceReference = unitNamespaceReference as INestedUnitNamespaceReference; " is 122.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetNamespaceTypeReferenceInternId,The length of the statement  "      NamespaceTypeStore nsTypeStore1 = new NamespaceTypeStore(containingUnitNamespaceInteredId' genericParameterCount' this.CurrentTypeInternValue++); " is 145.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetNestedTypeReferenceInternId,The length of the statement  "      NestedTypeStore nstTypeStore1 = new NestedTypeStore(containingTypeReferenceInteredId' genericParameterCount' this.CurrentTypeInternValue++); " is 140.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetMatrixTypeReferenceInternId,The length of the statement  "      MatrixTypeStore matrixTypeStore1 = new MatrixTypeStore(rank' new List<int>(lowerBounds).ToArray()' new List<ulong>(sizes).ToArray()' this.CurrentTypeInternValue++); " is 164.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetGenericTypeParameterReferenceInternId,The length of the statement  "      uint definingTypeReferenceInternId = this.GetTypeReferenceInternId(GetUninstantiatedGenericType(definingTypeReference)); " is 120.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetParameterTypeInternId,The length of the statement  "      ParameterTypeStore parameterTypeStore1 = new ParameterTypeStore(parameterTypeInformation.IsByReference' customModifiersInternId' this.CurrentParameterTypeInternValue++); " is 169.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetSignatureInternId,The length of the statement  "      uint returnValueCustomModifiersInternedId = this.GetCustomModifierListInternId(returnValueCustomModifiers.GetEnumerator()); " is 123.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetSignatureInternId,The length of the statement  "      SignatureStore signatureStore1 = new SignatureStore(callingConvention' requiredParameterTypesInternedId' extraArgumentTypesInteredId' returnValueIsByRef' returnValueCustomModifiersInternedId' returnTypeReferenceInternedId' 0' this.CurrentSignatureInternValue++); " is 262.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetMethodReferenceInternedId,The length of the statement  "        returnValueCustomModifiersInternedId = this.GetCustomModifierListInternId(methodReference.ReturnValueCustomModifiers.GetEnumerator()); " is 134.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetMethodReferenceInternedId,The length of the statement  "      SignatureStore signatureStore1 = new SignatureStore(methodReference.CallingConvention' requiredParameterTypesInternedId' " is 120.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetMethodReferenceInternedId,The length of the statement  "        0' methodReference.ReturnValueIsByRef' returnValueCustomModifiersInternedId' returnTypeReferenceInternedId' genericParameterCount' " is 130.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetGenericMethodInstanceReferenceInternedKey,The length of the statement  "      uint genericArgumentsInternedId = this.GetTypeReferenceListInternedId(genericMethodInstanceReference.GenericArguments.GetEnumerator()); " is 135.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetTypeReferenceInterendIdIgnoringCustomModifiers,The length of the statement  "      IGenericMethodParameterReference/*?*/ genericMethodParameterReference = typeReference as IGenericMethodParameterReference; " is 122.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetTypeReferenceInterendIdIgnoringCustomModifiers,The length of the statement  "        return this.GetGenericMethodParameterReferenceInternId(genericMethodParameterReference.DefiningMethod' genericMethodParameterReference.Index); " is 142.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetTypeReferenceInterendIdIgnoringCustomModifiers,The length of the statement  "      //^ assume false; //It is an informal requirement that all classes implementing ITypeReference should produce a non null result for one of the calls above. " is 155.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetTypeReferenceInternId,The length of the statement  "        return this.GetModifiedTypeReferenceInternId(modifiedTypeReference.UnmodifiedType' modifiedTypeReference.CustomModifiers); " is 122.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetFunctionPointerTypeReferenceInternedKey,The length of the statement  "        return this.GetFunctionPointerTypeReferenceInternId(callingConvention' parameters' extraArgumentTypes' returnValueCustomModifiers' returnValueIsByRef' returnType); " is 163.
Long Statement,Microsoft.Cci,NameTable,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetNameFor,The length of the statement  "          //^ assume result.Value == name; //Only this routine ever adds entries to the table and it only ever adds entries for which this is true. TODO: it would be nice to be able express this as an invariant. " is 201.
Long Statement,Microsoft.Cci,NameTable,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetNameFor,The length of the statement  "        //string lowerCaseName = name.ToLower(CultureInfo.InvariantCulture); //REVIEW: is it safer to use ToUpperInvariant' or does it make no difference? " is 146.
Long Statement,Microsoft.Cci,GlobalAssemblyCache,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\GlobalAssemblyCache.cs,Contains,The length of the statement  "        var gacKey = Microsoft.Win32.Registry.LocalMachine.OpenSubKey(@"\Software\Microsoft\.NETCompactFramework\Installer\Assemblies\Global"); " is 135.
Long Statement,Microsoft.Cci,GlobalAssemblyCache,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\GlobalAssemblyCache.cs,GetLocation,The length of the statement  "        var gacKey = Microsoft.Win32.Registry.LocalMachine.OpenSubKey(@"\Software\Microsoft\.NETCompactFramework\Installer\Assemblies\Global"); " is 135.
Long Statement,Microsoft.Cci,GlobalAssemblyCache,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\GlobalAssemblyCache.cs,GetLocation,The length of the statement  "          if (assemblyIdentity.Equals(new AssemblyIdentity(metadataHost.NameTable.GetNameFor(cn.Name)' cn.Culture' cn.Version' cn.PublicKeyToken' ""))) { " is 143.
Long Statement,Microsoft.Cci,AssemblyName,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\GlobalAssemblyCache.cs,GetLocation,The length of the statement  "      assemblyCache.QueryAssemblyInfo(ASSEMBLYINFO_FLAG.VALIDATE | ASSEMBLYINFO_FLAG.GETSIZE' this.StrongName' ref assemblyInfo); " is 123.
Long Statement,Microsoft.Cci,AssemblyName,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\GlobalAssemblyCache.cs,GetLocation,The length of the statement  "      assemblyCache.QueryAssemblyInfo(ASSEMBLYINFO_FLAG.VALIDATE | ASSEMBLYINFO_FLAG.GETSIZE' this.StrongName' ref assemblyInfo); " is 123.
Long Statement,Microsoft.Cci,MemberHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The length of the statement  "        List<IFieldDefinition> fields = new List<IFieldDefinition>(IteratorHelper.GetFilterEnumerable<ITypeDefinitionMember' IFieldDefinition>(members)); " is 145.
Long Statement,Microsoft.Cci,MemberHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The length of the statement  "          if (f.Type.ResolvedType == item) continue; // in case we are calculating the offset of an anonymous type' skip the implicit field of that type " is 142.
Long Statement,Microsoft.Cci,MemberHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetExplicitlyOverriddenMethods,The length of the statement  "      foreach (IMethodImplementation methodImplementation in overridingMethod.ContainingTypeDefinition.ExplicitImplementationOverrides) { " is 131.
Long Statement,Microsoft.Cci,MemberHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetFieldBitOffset,The length of the statement  "        List<IFieldDefinition> fields = new List<IFieldDefinition>(IteratorHelper.GetFilterEnumerable<ITypeDefinitionMember' IFieldDefinition>(members)); " is 145.
Long Statement,Microsoft.Cci,MemberHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetImplicitlyImplementedInterfaceMethods,The length of the statement  "      foreach (IMethodImplementation methodImplementation in implementingMethod.ContainingTypeDefinition.ExplicitImplementationOverrides) { " is 133.
Long Statement,Microsoft.Cci,MemberHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetImplicitlyImplementedInterfaceMethods,The length of the statement  "        foreach (ITypeDefinitionMember interfaceMember in interfaceReference.ResolvedType.GetMembersNamed(implementingMethod.Name' false)) { " is 132.
Long Statement,Microsoft.Cci,MemberHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetImplicitlyOverriddenBaseClassMethod,The length of the statement  "        IMethodDefinition overriddenMethod = GetImplicitlyOverriddenBaseClassMethod(derivedClassMethod' baseClassReference.ResolvedType); " is 129.
Long Statement,Microsoft.Cci,MemberHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetImplicitlyOverriddenBaseClassMethod,The length of the statement  "        IMethodDefinition overriddenMethod = GetImplicitlyOverriddenBaseClassMethod(derivedClassMethod' baseClassReference.ResolvedType); " is 129.
Long Statement,Microsoft.Cci,MemberHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,IsVisibleOutsideAssembly,The length of the statement  "        return IsExplicitImplementationVisible(propertyDefinition.Getter' containingTypeDefinition) || IsExplicitImplementationVisible(propertyDefinition.Setter' containingTypeDefinition); " is 180.
Long Statement,Microsoft.Cci,MemberHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,IsVisibleOutsideAssembly,The length of the statement  "        return IsExplicitImplementationVisible(eventDefinition.Adder' containingTypeDefinition) || IsExplicitImplementationVisible(eventDefinition.Remover' containingTypeDefinition); " is 174.
Long Statement,Microsoft.Cci,MemberHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,IsExplicitImplementationVisible,The length of the statement  "          //If the method being implemented did not resolve it can only be because it is actually defined in another assembly' which implies that it is visible outside its assembly' " is 171.
Long Statement,Microsoft.Cci,MemberHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,IsExplicitImplementationVisible,The length of the statement  "          //at least in the case where the implemented method is public or internal. Since we can't know that without resolving the method' we'll err on the "safe" side. " is 159.
Long Statement,Microsoft.Cci,MemberHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GenericMethodSignaturesAreEqual,The length of the statement  "      if (!TypeHelper.TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch(method1.Type' method2.Type' resolveTypes)) return false; " is 154.
Long Statement,Microsoft.Cci,MethodReference,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ToString,The length of the statement  "      return MemberHelper.GetMethodSignature(this' NameFormattingOptions.ReturnType|NameFormattingOptions.TypeParameters|NameFormattingOptions.Signature); " is 148.
Long Statement,Microsoft.Cci,GenericMethodParameterInformationComparer,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,Equals,The length of the statement  "      return TypeHelper.TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch(x.Type' y.Type' this.resolveTypes); " is 135.
Long Statement,Microsoft.Cci,SignatureFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetEventSignature,The length of the statement  "        sb.Append(this.typeNameFormatter.GetTypeName(eventDef.ContainingType' formattingOptions & ~(NameFormattingOptions.MemberKind|NameFormattingOptions.DocumentationIdMemberKind))); " is 176.
Long Statement,Microsoft.Cci,SignatureFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetEventSignature,The length of the statement  "      if ((formattingOptions & NameFormattingOptions.EscapeKeyword) != 0) eventName = this.typeNameFormatter.EscapeKeyword(eventName); " is 128.
Long Statement,Microsoft.Cci,SignatureFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetFieldSignature,The length of the statement  "        sb.Append(this.typeNameFormatter.GetTypeName(field.ContainingType' formattingOptions & ~(NameFormattingOptions.MemberKind|NameFormattingOptions.DocumentationIdMemberKind))); " is 173.
Long Statement,Microsoft.Cci,SignatureFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetFieldSignature,The length of the statement  "      if ((formattingOptions & NameFormattingOptions.EscapeKeyword) != 0) fieldName = this.typeNameFormatter.EscapeKeyword(fieldName); " is 128.
Long Statement,Microsoft.Cci,SignatureFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetMemberSignature,The length of the statement  "      if ((formattingOptions & NameFormattingOptions.FormattingForDocumentationId) != 0) name = this.MapToDocumentationIdName(name); " is 126.
Long Statement,Microsoft.Cci,SignatureFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetMethodSignature,The length of the statement  "      if ((formattingOptions & NameFormattingOptions.FormattingForDocumentationId) != 0 && method.ResolvedMethod.IsSpecialName && (method.Name.Value.Contains("op_Explicit") || method.Name.Value.Contains("op_Implicit"))) { " is 215.
Long Statement,Microsoft.Cci,SignatureFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetMethodSignature,The length of the statement  "        sb.Append(this.typeNameFormatter.GetTypeName(method.Type' formattingOptions & ~(NameFormattingOptions.MemberKind|NameFormattingOptions.DocumentationIdMemberKind))); " is 164.
Long Statement,Microsoft.Cci,SignatureFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendMethodParameters,The length of the statement  "      if ((formattingOptions & NameFormattingOptions.Signature) == 0 || ((formattingOptions & NameFormattingOptions.FormattingForDocumentationId) != 0 && !IteratorHelper.EnumerableIsNotEmpty<IParameterTypeInformation>(parameters))) return; " is 233.
Long Statement,Microsoft.Cci,SignatureFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendMethodParameters,The length of the statement  "          if (!parameter.MustBeReferenceType && !parameter.MustBeValueType && !parameter.MustHaveDefaultConstructor && IteratorHelper.EnumerableIsEmpty(parameter.Constraints)) continue; " is 175.
Long Statement,Microsoft.Cci,SignatureFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendMethodName,The length of the statement  "          formattingOptions & ~(NameFormattingOptions.MemberKind|NameFormattingOptions.DocumentationIdMemberKind|NameFormattingOptions.TypeConstraints))); " is 144.
Long Statement,Microsoft.Cci,SignatureFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendMethodName,The length of the statement  "        if (dotPos > 0 && dotPos < methodName.Length-1) methodName = methodName.Substring(dotPos+1' methodName.Length-dotPos-1); " is 120.
Long Statement,Microsoft.Cci,SignatureFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendMethodName,The length of the statement  "      if ((formattingOptions & NameFormattingOptions.EscapeKeyword) != 0) methodName = this.typeNameFormatter.EscapeKeyword(methodName); " is 130.
Long Statement,Microsoft.Cci,SignatureFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendMethodName,The length of the statement  "      if ((formattingOptions & NameFormattingOptions.FormattingForDocumentationId) != 0) methodName = this.MapToDocumentationIdName(methodName); " is 138.
Long Statement,Microsoft.Cci,SignatureFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendParameter,The length of the statement  "      sb.Append(this.typeNameFormatter.GetTypeName(param.Type' formattingOptions & ~(NameFormattingOptions.MemberKind|NameFormattingOptions.DocumentationIdMemberKind))); " is 163.
Long Statement,Microsoft.Cci,SignatureFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendPropertyName,The length of the statement  "        sb.Append(this.typeNameFormatter.GetTypeName(property.ContainingType' formattingOptions & ~(NameFormattingOptions.MemberKind|NameFormattingOptions.DocumentationIdMemberKind))); " is 176.
Long Statement,Microsoft.Cci,SignatureFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendPropertyName,The length of the statement  "      if ((formattingOptions & NameFormattingOptions.EscapeKeyword) != 0) propertyName = this.typeNameFormatter.EscapeKeyword(propertyName); " is 134.
Long Statement,Microsoft.Cci,SignatureFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendPropertyName,The length of the statement  "        if (dotPos > 0 && dotPos < propertyName.Length-1) propertyName = propertyName.Substring(dotPos+1' propertyName.Length-dotPos-1); " is 128.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not to decrease this.path.Count. " is 136.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not to decrease this.path.Count. " is 136.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not to decrease this.path.Count. " is 138.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not to decrease this.path.Count. " is 138.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not to decrease this.path.Count.      this.path.Pop(); " is 160.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not to decrease this.path.Count. " is 138.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not to decrease this.path.Count. " is 138.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not to decrease this.path.Count. " is 138.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      IGenericMethodInstanceReference/*?*/ genericMethodInstanceReference = methodReference as IGenericMethodInstanceReference; " is 121.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "        //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "        this.Visit(typeMemberReference.Attributes); //In principle' refererences can have attributes that are distinct from the definitions they refer to. " is 146.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,DispatchAsReference,The length of the statement  "      IGenericMethodParameterReference/*?*/ genericMethodParameterReference = typeReference as IGenericMethodParameterReference; " is 122.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "      //^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,VisitMethodReturnAttributes,The length of the statement  "      //^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,MetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Traverse,The length of the statement  "      if (this.preorderVisitor != null) this.preorderVisitor.Visit(arrayTypeReference); //No need to dispatch. This call is already type specific. " is 140.
Long Statement,Microsoft.Cci,MetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,TraverseChildren,The length of the statement  "      //field reference attributes are distinct from field definition attributes. When a definition serves as a reference' the reference is assumed to be unattributed. " is 161.
Long Statement,Microsoft.Cci,MetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,TraverseChildren,The length of the statement  "      //method reference attributes are distinct from method definition attributes. When a definition serves as a reference' the reference is assumed to be unattributed. " is 163.
Long Statement,Microsoft.Cci,MetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,TraverseChildren,The length of the statement  "      if (operationExceptionInformation.HandlerKind == HandlerKind.Catch || operationExceptionInformation.HandlerKind == HandlerKind.Filter) " is 134.
Long Statement,Microsoft.Cci,MetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,TraverseChildren,The length of the statement  "      //type reference attributes are distinct from type definition attributes. When a definition serves as a reference' the reference is assumed to be unattributed. " is 159.
Long Statement,Microsoft.Cci,MetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,TraverseChildren,The length of the statement  "      //unit reference attributes are distinct from unit definition attributes. When a definition serves as a reference' the reference is assumed to be unattributed. " is 159.
Long Statement,Microsoft.Cci,ClrHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,ClrOperandStackTypeFor,The length of the statement  "      Contract.Ensures(Contract.Result<ClrOperandStackType>() >= ClrOperandStackType.Int32 && Contract.Result<ClrOperandStackType>() <= ClrOperandStackType.Invalid); " is 159.
Long Statement,Microsoft.Cci,ClrHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,ClrOperandStackTypeFor,The length of the statement  "      Contract.Ensures(Contract.Result<ClrOperandStackType>() >= ClrOperandStackType.Int32 && Contract.Result<ClrOperandStackType>() < ClrOperandStackType.Invalid); " is 158.
Long Statement,Microsoft.Cci,ClrHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,ConversionPossible,The length of the statement  "          return toType == PrimitiveTypeCode.Int64 || toType == PrimitiveTypeCode.UInt64 || toType == PrimitiveTypeCode.IntPtr || toType == PrimitiveTypeCode.UIntPtr; " is 156.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,CanAccess,The length of the statement  "      if (typeDefinition.IsGeneric && TypeHelper.TypesAreEquivalent(typeDefinition.InstanceType' member.ContainingTypeDefinition)) " is 124.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,CanAccess,The length of the statement  "          return TypeHelper.GetDefiningUnit(typeDefinition).UnitIdentity.Equals(TypeHelper.GetDefiningUnit(member.ContainingTypeDefinition).UnitIdentity); " is 144.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,CanAccess,The length of the statement  "          return TypeHelper.GetDefiningUnit(typeDefinition).UnitIdentity.Equals(TypeHelper.GetDefiningUnit(member.ContainingTypeDefinition).UnitIdentity) && " is 146.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,CanAccess,The length of the statement  "          return TypeHelper.GetDefiningUnit(typeDefinition).UnitIdentity.Equals(TypeHelper.GetDefiningUnit(member.ContainingTypeDefinition)) || " is 133.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,CanAccess,The length of the statement  "        return TypeHelper.GetDefiningUnit(nsTypeDef).Equals(TypeHelper.GetDefiningUnit(typeDefinition)); //TODO: worry about /addmodule " is 127.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,TypeVisibilityAsTypeMemberVisibility,The length of the statement  "      TypeMemberVisibility result = TypeMemberVisibility.Public; // supposedly the only thing that doesn't meet any of the below tests are type parameters and their "default" is public. " is 179.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,TypeVisibilityAsTypeMemberVisibility,The length of the statement  "            result = TypeHelper.GenericInstanceVisibilityAsTypeMemberVisibility(TypeVisibilityAsTypeMemberVisibility(genType.GenericType.ResolvedType)' genType.GenericArguments); " is 166.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetDefiningUnit,The length of the statement  "      if (genericMethodParameter != null) return TypeHelper.GetDefiningUnit(genericMethodParameter.DefiningMethod.ContainingType.ResolvedType); " is 137.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetDefiningUnitReference,The length of the statement  "      if (genericTypeInstanceReference != null) return TypeHelper.GetDefiningUnitReference(genericTypeInstanceReference.GenericType); " is 127.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetDefiningUnitReference,The length of the statement  "      if (managedPointerTypeReference != null) return TypeHelper.GetDefiningUnitReference(managedPointerTypeReference.TargetType); " is 124.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetDefiningUnitReference,The length of the statement  "      if (genericTypeParameterReference != null) return TypeHelper.GetDefiningUnitReference(genericTypeParameterReference.DefiningType); " is 130.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetDefiningUnitReference,The length of the statement  "      IGenericMethodParameterReference/*?*/ genericMethodParameterReference = typeReference as IGenericMethodParameterReference; " is 122.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetDefiningUnitReference,The length of the statement  "      if (genericMethodParameterReference != null) return TypeHelper.GetDefiningUnitReference(genericMethodParameterReference.DefiningMethod.ContainingType); " is 151.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetMethod,The length of the statement  "      IMethodDefinition result = TypeHelper.GetMethod(declaringType.GetMembersNamed(methodReference.Name' false)' methodReference' resolveTypes); " is 139.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetInvokeMethod,The length of the statement  "      return Dummy.Method; //Should get here only when the delegate type is obtained from a malformed or malicious referenced assembly. " is 129.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,TryGetFullyInstantiatedSpecializedTypeReference,The length of the statement  "        if (TryGetFullyInstantiatedSpecializedTypeReference(nestedType.ContainingTypeDefinition' out containingTypeReference)) { " is 120.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,MostDerivedCommonBaseClass,The length of the statement  "        Contract.Assume(type1 != null); //Because depth2 > 0 and we were able to call TypeHelper.BaseClass depth1 times before getting null. " is 132.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,MostDerivedCommonBaseClass,The length of the statement  "        Contract.Assume(type2 != null); //Because depth1 > 0 and we were able to call TypeHelper.BaseClass depth2 times before getting null. " is 132.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,MostDerivedCommonBaseClass,The length of the statement  "        //If type1 and type2 at method entry were both structs' depth1 == depth2 == 1 and neither type1 nor type2 is a class during the first iteration of the loop " is 155.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,MostDerivedCommonBaseClass,The length of the statement  "        Contract.Assume(type1 != null); //Because depth1 > 0 and we were able to call TypeHelper.BaseClass depth1 times before getting null. " is 132.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,MostDerivedCommonBaseClass,The length of the statement  "        Contract.Assume(type2 != null); //Because depth1 > 0 and we were able to call TypeHelper.BaseClass depth1 times before getting null. " is 132.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,ParametersAreEquivalent,The length of the statement  "      if (param1.IsByReference != param2.IsByReference || param1.IsModified != param1.IsModified || !TypeHelper.TypesAreEquivalent(param1.Type' param2.Type' resolveTypes)) " is 165.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,ParametersAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch,The length of the statement  "        !TypeHelper.TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch(param1.Type' param2.Type' resolveTypes)) " is 134.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,ParametersAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch,The length of the statement  "          if (!TypeHelper.TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch(customModifier1.Modifier' customModifier2.Modifier' resolveTypes)) " is 164.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,ParameterListsAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch,The length of the statement  "        if (!TypeHelper.ParametersAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch(parameter1' parameter2' resolveTypes)) " is 141.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SizeOfType,The length of the statement  "            List<IFieldDefinition> fields = new List<IFieldDefinition>(IteratorHelper.GetFilterEnumerable<ITypeDefinitionMember' IFieldDefinition>(members)); " is 145.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,FunctionPointerTypesAreEquivalent,The length of the statement  "      return TypeHelper.ParameterListsAreEquivalent(functionPointer1.ExtraArgumentTypes' functionPointer2.ExtraArgumentTypes' resolveTypes); " is 134.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,FunctionPointerTypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch,The length of the statement  "      if (!TypeHelper.TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch(functionPointer1.Type' functionPointer2.Type' resolveTypes)) " is 158.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,FunctionPointerTypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch,The length of the statement  "      return TypeHelper.ParameterListsAreEquivalent(functionPointer1.ExtraArgumentTypes' functionPointer2.ExtraArgumentTypes' resolveTypes); " is 134.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SpecializeTypeReference,The length of the statement  "      if (genericTypeInstance != null) return GenericTypeInstance.SpecializeTypeReference(genericTypeInstance' context' internFactory); " is 129.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SpecializeTypeReference,The length of the statement  "      if (managedPointerType != null) return ManagedPointerType.SpecializeTypeReference(managedPointerType' context' internFactory); " is 126.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SpecializeTypeReference,The length of the statement  "      if (modifiedPointer != null) return ModifiedPointerType.SpecializeTypeReference(modifiedPointer' context' internFactory); " is 121.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SpecializeTypeReference,The length of the statement  "      if (nestedType != null) return SpecializedNestedTypeDefinition.SpecializeTypeReference(nestedType' context' internFactory); " is 123.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SpecializeTypeReference,The length of the statement  "      if (genericMethodTypeParameter != null) return GenericParameter.SpecializeTypeReference(genericMethodTypeParameter' context' internFactory); " is 140.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SpecializeTypeReference,The length of the statement  "      if (genericTypeInstance != null) return GenericTypeInstance.SpecializeTypeReference(genericTypeInstance' context' internFactory); " is 129.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SpecializeTypeReference,The length of the statement  "      if (managedPointerType != null) return ManagedPointerType.SpecializeTypeReference(managedPointerType' context' internFactory); " is 126.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SpecializeTypeReference,The length of the statement  "      if (modifiedPointer != null) return ModifiedPointerType.SpecializeTypeReference(modifiedPointer' context' internFactory); " is 121.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SpecializeTypeReference,The length of the statement  "      if (nestedType != null) return SpecializedNestedTypeDefinition.SpecializeTypeReference(nestedType' context' internFactory); " is 123.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch,The length of the statement  "        if (!TypeHelper.TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch(inst1.GenericType' inst2.GenericType' resolveTypes)) return false; " is 164.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch,The length of the statement  "        return TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch(array1.ElementType' array2.ElementType' resolveTypes); " is 143.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch,The length of the statement  "        return TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch(pointer1.TargetType' pointer2.TargetType' resolveTypes); " is 145.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch,The length of the statement  "        return TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch(mpointer1.TargetType' mpointer2.TargetType' resolveTypes); " is 147.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch,The length of the statement  "        return TypeHelper.FunctionPointerTypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch(fpointer1' fpointer2' resolveTypes); " is 151.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,Type1IsCovariantWithType2,The length of the statement  "      return TypeHelper.TypesAreAssignmentCompatible(arrType1.ElementType.ResolvedType' arrType2.ElementType.ResolvedType' resolveTypes); " is 131.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,TypesAreAssignmentCompatible,The length of the statement  "      if (sourceType.IsReferenceType && TypeHelper.Type1DerivesFromOrIsTheSameAsType2(sourceType' targetType' resolveTypes)) return true; " is 131.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,TypesAreAssignmentCompatible,The length of the statement  "      if (sourceType.IsInterface && TypeHelper.TypesAreEquivalent(targetType' targetType.PlatformType.SystemObject' resolveTypes)) return true; " is 137.
Long Statement,Microsoft.Cci,RelaxedTypeEquivalenceComparer,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,Equals,The length of the statement  "        return TypeHelper.TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch(x' y' this.resolveTypes); " is 125.
Long Statement,Microsoft.Cci,TypeNameFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,AddGenericParametersIfNeeded,The length of the statement  "      if ((formattingOptions & NameFormattingOptions.TypeParameters) != 0 && (formattingOptions & NameFormattingOptions.FormattingForDocumentationId) == 0 && genericParameterCount > 0 && type.ResolvedType != Dummy.Type) { " is 215.
Long Statement,Microsoft.Cci,TypeNameFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,AddGenericParametersIfNeeded,The length of the statement  "            if (!parameter.MustBeReferenceType && !parameter.MustBeValueType && !parameter.MustHaveDefaultConstructor && IteratorHelper.EnumerableIsEmpty(parameter.Constraints)) continue; " is 175.
Long Statement,Microsoft.Cci,TypeNameFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetGenericMethodParameterName,The length of the statement  "      if ((formattingOptions & NameFormattingOptions.FormattingForDocumentationId) != 0) return "``" + genericMethodParameter.Index; " is 126.
Long Statement,Microsoft.Cci,TypeNameFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetGenericTypeParameterName,The length of the statement  "      if ((formattingOptions & NameFormattingOptions.FormattingForDocumentationId) != 0) return "`" + genericTypeParameter.Index; " is 123.
Long Statement,Microsoft.Cci,TypeNameFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetNamespaceTypeName,The length of the statement  "      if ((formattingOptions & NameFormattingOptions.OmitContainingNamespace) == 0 && !(nsType.ContainingUnitNamespace is IRootUnitNamespaceReference)) " is 145.
Long Statement,Microsoft.Cci,TypeNameFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetNamespaceName,The length of the statement  "        if (nestedUnitSetNamespace.ContainingNamespace.Name.Value.Length == 0 || (formattingOptions & NameFormattingOptions.OmitContainingNamespace) != 0) { " is 148.
Long Statement,Microsoft.Cci,TypeNameFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetNamespaceName,The length of the statement  "          return this.GetNamespaceName(nestedUnitSetNamespace.ContainingUnitSetNamespace' formattingOptions) + "." + nestedUnitSetNamespace.Name.Value; " is 141.
Long Statement,Microsoft.Cci,TypeNameFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetNamespaceName,The length of the statement  "        if (nestedUnitNamespace.ContainingUnitNamespace is IRootUnitNamespaceReference || (formattingOptions & NameFormattingOptions.OmitContainingNamespace) != 0) { " is 157.
Long Statement,Microsoft.Cci,TypeNameFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetNamespaceName,The length of the statement  "          return this.GetNamespaceName(nestedUnitNamespace.ContainingUnitNamespace' formattingOptions) + "." + nestedUnitNamespace.Name.Value; " is 132.
Long Statement,Microsoft.Cci,TypeNameFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetNestedTypeName,The length of the statement  "        tname = this.GetTypeName(nestedType.ContainingType' formattingOptions & ~(NameFormattingOptions.MemberKind|NameFormattingOptions.Visibility|NameFormattingOptions.TypeConstraints)) + delim + tname; " is 196.
Long Statement,Microsoft.Cci,TypeNameFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetTypeName,The length of the statement  "      if (type == Dummy.TypeReference || type == Dummy.Type || type.ResolvedType == Dummy.Type) return "Microsoft.Cci.DummyType"; " is 123.
Long Statement,Microsoft.Cci,TypeNameFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetGenericTypeInstanceName,The length of the statement  "        StringBuilder sb = new StringBuilder(this.GetTypeName(genericType' formattingOptions & ~(NameFormattingOptions.TypeParameters | ((formattingOptions & NameFormattingOptions.FormattingForDocumentationId) != 0 ? NameFormattingOptions.UseGenericTypeNameSuffix : NameFormattingOptions.None)))); " is 289.
Long Statement,Microsoft.Cci,TypeNameFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetGenericTypeInstanceName,The length of the statement  "          sb.Append(this.GetTypeName(argument' formattingOptions & ~(NameFormattingOptions.MemberKind|NameFormattingOptions.DocumentationIdMemberKind))); " is 143.
Long Statement,Microsoft.Cci,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,AssemblyOneAllowsAssemblyTwoToAccessItsInternals,The length of the statement  "        if (!TypeHelper.TypesAreEquivalent(attribute.Type' assembly1.PlatformType.SystemRuntimeCompilerServicesInternalsVisibleToAttribute)) continue; " is 142.
Long Statement,Microsoft.Cci,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,AssemblyOneAllowsAssemblyTwoToAccessItsInternals,The length of the statement  "          if (string.Compare(assemblyName' 0' assembly2.Name.Value' 0' name2Length' StringComparison.OrdinalIgnoreCase) == 0) return true; " is 128.
Long Statement,Microsoft.Cci,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,GetAssemblyIdentity,The length of the statement  "      string culture = assemblyName.CultureInfo == null || assemblyName.CultureInfo == System.Globalization.CultureInfo.InvariantCulture ? "neutral" : assemblyName.CultureInfo.ToString(); " is 181.
Long Statement,Microsoft.Cci,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,GetAssemblyIdentity,The length of the statement  "        return new AssemblyIdentity(assembly.Name' assembly.Culture' assembly.Version' UnitHelper.ComputePublicKeyToken(pKey)' assembly.Location); " is 138.
Long Statement,Microsoft.Cci,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,StrongName,The length of the statement  "      sb.AppendFormat(CultureInfo.InvariantCulture' "' Version={0}.{1}.{2}.{3}"' assemblyReference.Version.Major' assemblyReference.Version.Minor' assemblyReference.Version.Build' assemblyReference.Version.Revision); " is 210.
Long Statement,Microsoft.Cci,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,FindType,The length of the statement  "      INamedTypeDefinition/*?*/ result = GetType(nameTable' unit.UnitNamespaceRoot' typeName' genericParameterCount' ref offset); " is 123.
Long Statement,Microsoft.Cci,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,GetType,The length of the statement  "          var nt = GetNestedType(nameTable' namespaceType' typeName' genericParameterCount-namespaceType.GenericParameterCount' ref offset); " is 130.
Long Statement,Microsoft.Cci,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,GetNestedType,The length of the statement  "        var nt = GetNestedType(nameTable' nestedType' typeName' genericParameterCount-nestedType.GenericParameterCount' ref offset); " is 124.
Long Statement,Microsoft.Cci,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,UnitNamespacesAreEquivalent,The length of the statement  "          && UnitHelper.UnitNamespacesAreEquivalent(nstUnitNamespace1.ContainingUnitNamespace' nstUnitNamespace2.ContainingUnitNamespace); " is 128.
Long Statement,Microsoft.Cci,UnitSet,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,Contains,The length of the statement  "      //^ assume result == exists{IUnit u in this.Units; u == unit}; //TODO: Boogie: need a working postcodition on EnumerableContains " is 128.
Long Statement,Microsoft.Cci,MemoryMappedFile,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnmanagedFileIO.cs,OpenFileMemoryMap,The length of the statement  "        hmap = MemoryMappedFile.CreateFileMapping(safeHandle.DangerousGetHandle()' IntPtr.Zero' PageAccess.PAGE_READONLY' 0' length' null); " is 131.
Long Statement,Microsoft.Cci,MemoryMappedFile,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnmanagedFileIO.cs,OpenFileMemoryMap,The length of the statement  "          throw new IOException("Unable to create Memory map: " + filename + " - " + rc.ToString("X"' CultureInfo.InvariantCulture)); " is 123.
Long Statement,Microsoft.Cci,MemoryMappedFile,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnmanagedFileIO.cs,OpenFileMemoryMap,The length of the statement  "        throw new IOException("Unable to create Memory map: " + filename + " - " +rc.ToString("X"' CultureInfo.InvariantCulture)); " is 122.
Long Statement,Microsoft.Cci,UnmanagedBinaryMemoryBlock,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnmanagedFileIO.cs,CreateUnmanagedBinaryMemoryBlock,The length of the statement  "        if (pMainBuffer == endOfBuffer) throw new IOException("stream length != binaryDocument.Length: " + binaryDocument.Location); " is 124.
Long Statement,Microsoft.Cci,UnmanagedBinaryMemoryBlock,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnmanagedFileIO.cs,CreateUnmanagedBinaryMemoryBlock,The length of the statement  "      if (pMainBuffer != endOfBuffer) throw new IOException("stream length != binaryDocument.Length: " + binaryDocument.Location); " is 124.
Long Statement,Microsoft.Cci,ILLocation,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnmanagedFileIO.cs,ToString,The length of the statement  "      sb.AppendFormat(CultureInfo.InvariantCulture' "ILLocation({0}'0x{1})"' this.methodDefinition.ToString()' this.offset.ToString("X8"' CultureInfo.InvariantCulture)); " is 163.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "        if (assembly.Culture != string.Empty && validCultureNames.Find(x => string.Compare(assembly.Culture' x' StringComparison.OrdinalIgnoreCase) == 0) == null) " is 154.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "          foreach (var typeAlias in assembly.ExportedTypes) { //TODO: simplify this when type forwarders are put in their own collection. " is 127.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "        if (assemblyReference.Culture != string.Empty && validCultureNames.Find(x => string.Compare(assemblyReference.Culture' x' StringComparison.OrdinalIgnoreCase) == 0) == null) " is 172.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "            if (!IteratorHelper.EnumerableHasLength(customAttribute.Arguments' customAttribute.Constructor.ResolvedMethod.ParameterCount)) { " is 128.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "              if (this.validator.currentSecurityAttribute == null || customAttribute.Constructor.ResolvedMethod.ParameterCount != 1 || " is 120.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "          if (fieldDefinition.Type.TypeCode == PrimitiveTypeCode.NotPrimitive && (fieldDefinition.Offset % this.validator.host.PointerSize) != 0) " is 135.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "          if (!fieldDefinition.Type.IsValueType) //TODO: also check' recursively' that all fields are public and have types that do not reference heap objects. " is 149.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "              this.ReportError(MetadataError.ArraysMarshalledToFieldsCannotSpecifyElementCountParameter' fieldDefinition.MarshallingInformation' fieldDefinition); " is 148.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "              this.ReportError(MetadataError.MarshalledArraysMustHaveSizeKnownAtCompileTime' fieldDefinition.MarshallingInformation' fieldDefinition); " is 136.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "        if ((functionPointerTypeReference.CallingConvention & CallingConvention.ExplicitThis) != 0 && functionPointerTypeReference.IsStatic) " is 132.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,CheckUnmanagedType,The length of the statement  "        if (type < 0x02 || (0x0c < type && type < 0x13 && type != 0x0f) || type == 0x18 || type == 0x21 || type == 0x27 || type == 0x29 || " is 130.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "          !AttributeHelper.Contains(method.Attributes' this.validator.host.PlatformType.SystemSecuritySuppressUnmanagedCodeSecurityAttribute)) " is 132.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "          AttributeHelper.Contains(method.Attributes' this.validator.host.PlatformType.SystemSecuritySuppressUnmanagedCodeSecurityAttribute)) " is 131.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "          if (!resolvedImplementedMethod.IsVirtual || resolvedImplementedMethod.IsSealed || resolvedImplementedMethod.ContainingTypeDefinition.IsSealed) " is 142.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "          if (!(resolvedImplementedMethod.IsVirtual || resolvedImplementedMethod.IsAbstract || resolvedImplementedMethod.IsExternal)) " is 123.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "          if (!MemberHelper.GenericMethodSignaturesAreEqual(methodImplementation.ImplementedMethod' methodImplementation.ImplementingMethod)) " is 131.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "        if (!namespaceAliasForType.IsPublic && !(TypeHelper.GetDefiningUnitReference(namespaceAliasForType.AliasedType) is IAssemblyReference)) " is 135.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "        if (nestedAliasForType.Visibility != TypeMemberVisibility.Public && !(TypeHelper.GetDefiningUnitReference(nestedAliasForType.AliasedType) is IAssemblyReference)) " is 161.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "        } else if (!IteratorHelper.EnumerableContains(this.validator.currentModule.ContainingAssembly.ExportedTypes' nestedAliasForType.ContainingAlias)) " is 145.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "          this.ReportError(MetadataError.ContainingAliasNotListedInExportedTypes' nestedAliasForType.ContainingAlias' this.validator.currentModule.ContainingAssembly); " is 157.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "          if (parameterType.IsEnum && parameterType.ResolvedType != Dummy.Type) parameterType = parameterType.ResolvedType.UnderlyingType; " is 128.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "                this.ReportError(MetadataError.ParameterIndexIsInvalid' parameterDefinition.MarshallingInformation' parameterDefinition); " is 121.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "              //  this.ReportError(MetadataError.ParameterMarshalledArraysMustHaveSizeKnownAtCompileTime' parameterDefinition.MarshallingInformation' parameterDefinition); " is 157.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "          if (parameterDefinition.MarshallingInformation.UnmanagedType == System.Runtime.InteropServices.UnmanagedType.ByValArray) { " is 122.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "            this.ReportError(MetadataError.ParameterCannotBeMarshalledAsByValArray' parameterDefinition.MarshallingInformation' parameterDefinition); " is 137.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "          if (parameterDefinition.MarshallingInformation.UnmanagedType == System.Runtime.InteropServices.UnmanagedType.ByValTStr) { " is 121.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "              this.ReportError(MetadataError.ParameterMarshalledArraysMustHaveSizeKnownAtCompileTime' parameterDefinition.MarshallingInformation' parameterDefinition); " is 153.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "          if (propertyType.IsEnum && propertyType.ResolvedType != Dummy.Type) propertyType = propertyType.ResolvedType.UnderlyingType; " is 124.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "            //The attribute shall derive from System.Security.Permissions.SecurityAttribute' but shall not derive from System.Security.Permissions.CodeAccessSecurityAttribute " is 162.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The length of the statement  "          foreach (var baseClass in typeDefinition.BaseClasses) this.CheckLayoutConsistency(baseClass.ResolvedType' typeDefinition); " is 122.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,ReportError,The length of the statement  "        var message = new ErrorMessage() { Error = error' ErrorReporter = this' Location = new MetadataNode() { Document = this.validator.document' Node = node } }; " is 156.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,ReportError,The length of the statement  "          foreach (var relatedNode in relatedNodes) relatedLocations.Add(new MetadataNode() { Document = this.validator.document' Node = relatedNode }); " is 142.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,ReportError,The length of the statement  "        var message = new ErrorMessage() { Error = error' ErrorReporter = this' MessageParameter = messageParameter' Location = new MetadataNode() { Document = this.validator.document' Node = node } }; " is 193.
Long Statement,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,ReportError,The length of the statement  "          foreach (var relatedNode in relatedNodes) relatedLocations.Add(new MetadataNode() { Document = this.validator.document' Node = relatedNode }); " is 142.
Long Statement,Microsoft.Cci.Immutable,GenericMethodInstance,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,ToString,The length of the statement  "        NameFormattingOptions.ReturnType|NameFormattingOptions.Signature|NameFormattingOptions.ParameterModifiers|NameFormattingOptions.ParameterName); " is 143.
Long Statement,Microsoft.Cci.Immutable,GenericMethodInstanceReference,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,ToString,The length of the statement  "        NameFormattingOptions.ReturnType|NameFormattingOptions.Signature|NameFormattingOptions.ParameterModifiers|NameFormattingOptions.ParameterName); " is 143.
Long Statement,Microsoft.Cci.Immutable,SpecializedEventDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,SpecializeIfConstructed,The length of the statement  "        partiallySpecializedTypeReference = TypeDefinition.DeepCopyTypeReference(partiallySpecializedTypeReference' specializedParent' this.ContainingGenericTypeInstance.InternFactory); " is 177.
Long Statement,Microsoft.Cci.Immutable,SpecializedEventDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,SpecializeIfConstructed,The length of the statement  "      return TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(partiallySpecializedTypeReference' this.ContainingGenericTypeInstance' this.ContainingGenericTypeInstance.InternFactory); " is 194.
Long Statement,Microsoft.Cci.Immutable,SpecializedFieldDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "        partiallySpecializedTypeReference = TypeDefinition.DeepCopyTypeReference(partiallySpecializedTypeReference' specializedParent' this.ContainingGenericTypeInstance.InternFactory); " is 177.
Long Statement,Microsoft.Cci.Immutable,SpecializedFieldDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "      return TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(partiallySpecializedTypeReference' this.ContainingGenericTypeInstance' this.ContainingGenericTypeInstance.InternFactory); " is 194.
Long Statement,Microsoft.Cci.Immutable,SpecializedGenericMethodParameter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "      partiallySpecializedTypeReference = TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod(partiallySpecializedTypeReference' " is 127.
Long Statement,Microsoft.Cci.Immutable,SpecializedGenericMethodParameter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "      return TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(partiallySpecializedTypeReference' this.DefiningMethod.ContainingGenericTypeInstance' this.DefiningMethod.ContainingGenericTypeInstance.InternFactory); " is 224.
Long Statement,Microsoft.Cci.Immutable,SpecializedMethodBody,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,MapBody,The length of the statement  "        var specializedOperationExceptionInformation = new List<IOperationExceptionInformation>(this.unspecializedBody.OperationExceptionInformation); " is 142.
Long Statement,Microsoft.Cci.Immutable,SpecializedMethodBody,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,MapBody,The length of the statement  "            var specializedOperationException = new SpecializedOperationExceptionInformation(unspecializedOperationException' specializedType); " is 131.
Long Statement,Microsoft.Cci.Immutable,SpecializedMethodBody,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,Specialize,The length of the statement  "      ITypeReference specializedType = TypeHelper.SpecializeTypeReference(unspecializedType' this.containingMethod' this.internFactory); " is 130.
Long Statement,Microsoft.Cci.Immutable,SpecializedMethodBody,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,Specialize,The length of the statement  "          var specializedContainingType = TypeHelper.SpecializeTypeReference(fieldReference.ContainingType' this.containingMethod' this.internFactory); " is 141.
Long Statement,Microsoft.Cci.Immutable,SpecializedMethodBody,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,Specialize,The length of the statement  "            var specializedContainingType = TypeHelper.SpecializeTypeReference(fieldReference.ContainingType' this.containingMethod' this.internFactory); " is 141.
Long Statement,Microsoft.Cci.Immutable,SpecializedMethodDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,ToString,The length of the statement  "      return MemberHelper.GetMethodSignature(this' NameFormattingOptions.ReturnType|NameFormattingOptions.Signature|NameFormattingOptions.TypeParameters); " is 148.
Long Statement,Microsoft.Cci.Immutable,SpecializedMethodDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "      partiallySpecializedTypeReference = TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod(partiallySpecializedTypeReference' this' this.ContainingGenericTypeInstance.InternFactory); " is 184.
Long Statement,Microsoft.Cci.Immutable,SpecializedMethodDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "      return TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(partiallySpecializedTypeReference' this.ContainingGenericTypeInstance' this.ContainingGenericTypeInstance.InternFactory); " is 194.
Long Statement,Microsoft.Cci.Immutable,SpecializedMethodReference,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,ToString,The length of the statement  "        NameFormattingOptions.ReturnType|NameFormattingOptions.Signature|NameFormattingOptions.TypeParameters|NameFormattingOptions.TypeConstraints); " is 141.
Long Statement,Microsoft.Cci.Immutable,SpecializedParameterDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "        //Note that partiallySpecializedType is obtained from genericMethodInstance.GenericMethod which will have been specialized with respect " is 135.
Long Statement,Microsoft.Cci.Immutable,SpecializedParameterDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "        //to everything but the generic method parameters. Hence only the following call is necessary to specialize partiallySpecializedType. " is 133.
Long Statement,Microsoft.Cci.Immutable,SpecializedParameterDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "        return TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(partiallySpecializedType' genericMethodInstance' this.InternFactory); " is 142.
Long Statement,Microsoft.Cci.Immutable,SpecializedParameterDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "      //Since the containing signature is not a generic method instance' it must be a member of a type that has been specialized. " is 123.
Long Statement,Microsoft.Cci.Immutable,SpecializedParameterDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "      //The things that need to be specialized in partiallySpecializedType are defined by this containing type and/or its containing types. " is 133.
Long Statement,Microsoft.Cci.Immutable,SpecializedParameterDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "        partiallySpecializedType = TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod(partiallySpecializedType' specializedMethodDefinition' this.internFactory); " is 159.
Long Statement,Microsoft.Cci.Immutable,SpecializedParameterDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "        return TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(partiallySpecializedType' specializedMethodDefinition.ContainingGenericTypeInstance' this.InternFactory); " is 178.
Long Statement,Microsoft.Cci.Immutable,SpecializedParameterDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "      SpecializedNestedTypeDefinition snt = specializedPropertyDefinition.ContainingTypeDefinition as SpecializedNestedTypeDefinition; " is 128.
Long Statement,Microsoft.Cci.Immutable,SpecializedParameterDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "      return TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(partiallySpecializedType' specializedPropertyDefinition.ContainingGenericTypeInstance' this.InternFactory); " is 180.
Long Statement,Microsoft.Cci.Immutable,SpecializedParameterTypeInformation,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,SpecializeIfConstructed,The length of the statement  "      return TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(partiallySpecializedType' this.containingSignature' this.InternFactory); " is 145.
Long Statement,Microsoft.Cci.Immutable,SpecializedPropertyDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "      SpecializedNestedTypeDefinition specializedNestedParent = this.ContainingTypeDefinition as SpecializedNestedTypeDefinition; " is 123.
Long Statement,Microsoft.Cci.Immutable,SpecializedPropertyDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "        partiallySpecializedTypeReference = TypeDefinition.DeepCopyTypeReference(partiallySpecializedTypeReference' specializedNestedParent' this.ContainingGenericTypeInstance.InternFactory); " is 183.
Long Statement,Microsoft.Cci.Immutable,SpecializedPropertyDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "      return TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(partiallySpecializedTypeReference' this.ContainingGenericTypeInstance' this.ContainingGenericTypeInstance.InternFactory); " is 194.
Long Statement,Microsoft.Cci.Immutable,NamespaceTypeReference,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,GetResolvedType,The length of the statement  "      foreach (INamespaceMember member in this.ContainingUnitNamespace.ResolvedUnitNamespace.GetMembersNamed(this.name' false)) { " is 123.
Long Statement,Microsoft.Cci.Immutable,NamespaceTypeReference,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,GetResolvedType,The length of the statement  "          if (nsAlias != null && nsAlias.AliasedType.GenericParameterCount == this.GenericParameterCount) this.aliasForType = nsAlias; " is 124.
Long Statement,Microsoft.Cci.Immutable,PlatformType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,CreateReference,The length of the statement  "      return new NamespaceTypeReference(this.host' ns' this.host.NameTable.GetNameFor(names[names.Length-1])' genericParameterCount' false' isValueType' typeCode); " is 157.
Long Statement,Microsoft.Cci.Immutable,ArrayType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,GetMatchingMembersNamed,The length of the statement  "        if (name.UniqueKey != member.Name.UniqueKey || (ignoreCase && name.UniqueKeyIgnoringCase == member.Name.UniqueKeyIgnoringCase)) { " is 129.
Long Statement,Microsoft.Cci.Immutable,ArrayType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,GetMembersNamed,The length of the statement  "        if (name.UniqueKey != member.Name.UniqueKey || (ignoreCase && name.UniqueKeyIgnoringCase == member.Name.UniqueKeyIgnoringCase)) { " is 129.
Long Statement,Microsoft.Cci.Immutable,CustomModifier,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,CopyModifierToNewContainer,The length of the statement  "      ITypeReference copiedModifier = TypeDefinition.DeepCopyTypeReference(customModifier.Modifier' targetContainer' internFactory); " is 126.
Long Statement,Microsoft.Cci.Immutable,CustomModifier,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,Specialize,The length of the statement  "      ITypeReference copiedModifier = TypeHelper.SpecializeTypeReference(customModifier.Modifier' targetContainer' internFactory); " is 124.
Long Statement,Microsoft.Cci.Immutable,CustomModifier,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,Specialize,The length of the statement  "      ITypeReference copiedModifier = TypeHelper.SpecializeTypeReference(customModifier.Modifier' targetContainer' internFactory); " is 124.
Long Statement,Microsoft.Cci.Immutable,CustomModifier,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      ITypeReference copiedModifier = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(customModifier.Modifier' containingMethodInstance' internFactory); " is 164.
Long Statement,Microsoft.Cci.Immutable,CustomModifier,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      ITypeReference copiedModifier = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(customModifier.Modifier' containingTypeInstance' internFactory); " is 162.
Long Statement,Microsoft.Cci.Immutable,CustomModifier,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableMethodTypeParameter,The length of the statement  "      ITypeReference copiedModifier = TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod(customModifier.Modifier' specializedMethodReference' internFactory); " is 157.
Long Statement,Microsoft.Cci.Immutable,GenericTypeInstance,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,InitializeIfNecessary,The length of the statement  "          //^ assume unspecializedMember is IEventDefinition || unspecializedMember is IFieldDefinition || unspecializedMember is IMethodDefinition || " is 140.
Long Statement,Microsoft.Cci.Immutable,GenericTypeInstance,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,InitializeIfNecessary,The length of the statement  "          //^   unspecializedMember is IPropertyDefinition || unspecializedMember is INestedTypeDefinition; //follows from informal post condition on Members property. " is 157.
Long Statement,Microsoft.Cci.Immutable,GenericTypeInstance,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReference,The length of the statement  "      var copiedGenericType = (INamedTypeReference)TypeDefinition.DeepCopyTypeReference(genericTypeInstance.GenericType' targetContainer' internFactory); " is 147.
Long Statement,Microsoft.Cci.Immutable,GenericTypeInstance,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeTypeReference,The length of the statement  "      var copiedGenericType = (INamedTypeReference)TypeHelper.SpecializeTypeReference(genericTypeInstance.GenericType' targetContainer' internFactory); " is 145.
Long Statement,Microsoft.Cci.Immutable,GenericTypeInstance,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeTypeReference,The length of the statement  "      var copiedGenericType = (INamedTypeReference)TypeHelper.SpecializeTypeReference(genericTypeInstance.GenericType' targetContainer' internFactory); " is 145.
Long Statement,Microsoft.Cci.Immutable,GenericTypeInstance,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      var specializedGenericType = (INamedTypeReference)TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(genericTypeInstance.GenericType' containingMethodInstance' internFactory); " is 190.
Long Statement,Microsoft.Cci.Immutable,GenericTypeInstance,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "        ITypeReference specializedArgType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(argType' containingMethodInstance' internFactory); " is 152.
Long Statement,Microsoft.Cci.Immutable,GenericTypeInstance,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "          if (specializedArguments == null) specializedArguments = new List<ITypeReference>(genericTypeInstance.GenericArguments); " is 120.
Long Statement,Microsoft.Cci.Immutable,GenericTypeInstance,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      var specializedGenericType = (INamedTypeReference)TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(genericTypeInstance.GenericType' containingTypeInstance' internFactory); " is 188.
Long Statement,Microsoft.Cci.Immutable,GenericTypeInstance,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "        ITypeReference specializedArgType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(argType' containingTypeInstance' internFactory); " is 150.
Long Statement,Microsoft.Cci.Immutable,GenericTypeInstance,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "          if (specializedArguments == null) specializedArguments = new List<ITypeReference>(genericTypeInstance.GenericArguments); " is 120.
Long Statement,Microsoft.Cci.Immutable,GenericTypeInstance,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "      var specializedGenericType = (INamedTypeReference)TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod(genericTypeInstance.GenericType' specializedMethodReference' internFactory); " is 183.
Long Statement,Microsoft.Cci.Immutable,GenericTypeInstance,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "        ITypeReference specializedArgType = TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod(argType' specializedMethodReference' internFactory); " is 145.
Long Statement,Microsoft.Cci.Immutable,GenericTypeInstance,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "          if (specializedArguments == null) specializedArguments = new List<ITypeReference>(genericTypeInstance.GenericArguments); " is 120.
Long Statement,Microsoft.Cci.Immutable,GenericParameter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeTypeReference,The length of the statement  "        Contract.Assume(false); //The type parameter claims it is defined by genericTypeInstance.GenericType' so we should never get here legitimately. " is 143.
Long Statement,Microsoft.Cci.Immutable,GenericParameter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "      if (specializedMethodDefinition != null && genericMethodParameter.DefiningMethod.InternedKey == specializedMethodDefinition.PartiallySpecializedVersion.InternedKey) { " is 166.
Long Statement,Microsoft.Cci.Immutable,ManagedPointerType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReference,The length of the statement  "      ITypeReference specializedtargetType = TypeDefinition.DeepCopyTypeReference(targetType' targetContainer' internFactory); " is 120.
Long Statement,Microsoft.Cci.Immutable,ManagedPointerType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      ITypeReference specializedtargetType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(targetType' containingMethodInstance' internFactory); " is 158.
Long Statement,Microsoft.Cci.Immutable,ManagedPointerType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      ITypeReference specializedtargetType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(targetType' containingTypeInstance' internFactory); " is 156.
Long Statement,Microsoft.Cci.Immutable,ManagedPointerType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "      ITypeReference specializedtargetType = TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod(targetType' specializedMethodReference' internFactory); " is 151.
Long Statement,Microsoft.Cci.Immutable,Matrix,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReference,The length of the statement  "      ITypeReference specializedElementType = TypeDefinition.DeepCopyTypeReference(elementType' targetContainer' internFactory); " is 122.
Long Statement,Microsoft.Cci.Immutable,Matrix,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeTypeReference,The length of the statement  "      ITypeReference specializedElementType = TypeHelper.SpecializeTypeReference(elementType' targetContainer' internFactory); " is 120.
Long Statement,Microsoft.Cci.Immutable,Matrix,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeTypeReference,The length of the statement  "      ITypeReference specializedElementType = TypeHelper.SpecializeTypeReference(elementType' targetContainer' internFactory); " is 120.
Long Statement,Microsoft.Cci.Immutable,Matrix,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      ITypeReference specializedElementType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(elementType' containingMethodInstance' internFactory); " is 160.
Long Statement,Microsoft.Cci.Immutable,Matrix,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      ITypeReference specializedElementType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(elementType' containingTypeInstance' internFactory); " is 158.
Long Statement,Microsoft.Cci.Immutable,Matrix,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "      ITypeReference specializedElementType = TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod(elementType' specializedMethodReference' internFactory); " is 153.
Long Statement,Microsoft.Cci.Immutable,PointerType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReference,The length of the statement  "      ITypeReference specializedtargetType = TypeDefinition.DeepCopyTypeReference(targetType' targetContainer' internFactory); " is 120.
Long Statement,Microsoft.Cci.Immutable,PointerType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      ITypeReference specializedtargetType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(targetType' containingMethodInstance' internFactory); " is 158.
Long Statement,Microsoft.Cci.Immutable,PointerType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      ITypeReference specializedtargetType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(targetType' containingTypeInstance' internFactory); " is 156.
Long Statement,Microsoft.Cci.Immutable,PointerType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceReplacingGenericMethodParameter,The length of the statement  "      ITypeReference specializedtargetType = TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod(targetType' specializedMethodReference' internFactory); " is 151.
Long Statement,Microsoft.Cci.Immutable,ModifiedPointerType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReference,The length of the statement  "      var copiedTargetType = TypeDefinition.DeepCopyTypeReference(modifiedPointer.TargetType' targetContainer' internFactory); " is 120.
Long Statement,Microsoft.Cci.Immutable,ModifiedPointerType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      var copiedTargetType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(modifiedPointer.TargetType' containingMethodInstance' internFactory); " is 158.
Long Statement,Microsoft.Cci.Immutable,ModifiedPointerType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "        var copiedModifier = CustomModifier.SpecializeIfConstructedFromApplicableTypeParameter(modifier' containingMethodInstance' internFactory); " is 138.
Long Statement,Microsoft.Cci.Immutable,ModifiedPointerType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      var copiedTargetType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(modifiedPointer.TargetType' containingTypeInstance' internFactory); " is 156.
Long Statement,Microsoft.Cci.Immutable,ModifiedPointerType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "        var copiedModifier = CustomModifier.SpecializeIfConstructedFromApplicableTypeParameter(modifier' containingTypeInstance' internFactory); " is 136.
Long Statement,Microsoft.Cci.Immutable,ModifiedPointerType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "      var copiedTargetType = TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod(modifiedPointer.TargetType' specializedMethodReference' internFactory); " is 151.
Long Statement,Microsoft.Cci.Immutable,ModifiedPointerType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "        var copiedModifier = CustomModifier.SpecializeIfConstructedFromApplicableMethodTypeParameter(modifier' specializedMethodReference' internFactory); " is 146.
Long Statement,Microsoft.Cci.Immutable,ModifiedTypeReference,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReference,The length of the statement  "      ITypeReference copiedUnmodifiedType = TypeDefinition.DeepCopyTypeReference(modifiedTypeReference.UnmodifiedType' targetContainer' internFactory); " is 145.
Long Statement,Microsoft.Cci.Immutable,ModifiedTypeReference,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeTypeReference,The length of the statement  "      ITypeReference copiedUnmodifiedType = TypeHelper.SpecializeTypeReference(modifiedTypeReference.UnmodifiedType' targetContainer' internFactory); " is 143.
Long Statement,Microsoft.Cci.Immutable,ModifiedTypeReference,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeTypeReference,The length of the statement  "      ITypeReference copiedUnmodifiedType = TypeHelper.SpecializeTypeReference(modifiedTypeReference.UnmodifiedType' targetContainer' internFactory); " is 143.
Long Statement,Microsoft.Cci.Immutable,ModifiedTypeReference,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      ITypeReference copiedUnmodifiedType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(modifiedTypeReference.UnmodifiedType' containingMethodInstance' internFactory); " is 183.
Long Statement,Microsoft.Cci.Immutable,ModifiedTypeReference,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "        var copiedModifier = CustomModifier.SpecializeIfConstructedFromApplicableTypeParameter(modifier' containingMethodInstance' internFactory); " is 138.
Long Statement,Microsoft.Cci.Immutable,ModifiedTypeReference,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      ITypeReference copiedUnmodifiedType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(modifiedTypeReference.UnmodifiedType' containingTypeInstance' internFactory); " is 181.
Long Statement,Microsoft.Cci.Immutable,ModifiedTypeReference,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "        var copiedModifier = CustomModifier.SpecializeIfConstructedFromApplicableTypeParameter(modifier' containingTypeInstance' internFactory); " is 136.
Long Statement,Microsoft.Cci.Immutable,ModifiedTypeReference,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "      ITypeReference copiedUnmodifiedType = TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod(modifiedTypeReference.UnmodifiedType' specializedMethodReference' internFactory); " is 176.
Long Statement,Microsoft.Cci.Immutable,ModifiedTypeReference,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "        var copiedModifier = CustomModifier.SpecializeIfConstructedFromApplicableMethodTypeParameter(modifier' specializedMethodReference' internFactory); " is 146.
Long Statement,Microsoft.Cci.Immutable,Scope<MemberType>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,GetMembersNamed,The length of the statement  "      Dictionary<int' List<MemberType>> nameToMemberListMap = ignoreCase ? this.caseInsensitiveMemberNameToMemberListMap : this.caseSensitiveMemberNameToMemberListMap; " is 161.
Long Statement,Microsoft.Cci.Immutable,SpecializedNestedTypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "      var specializedParent = TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod(nestedType.ContainingType' specializedMethodReference' internFactory); " is 151.
Long Statement,Microsoft.Cci.Immutable,SpecializedNestedTypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      var specializedParent = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(nestedType.ContainingType' genericMethodInstance' internFactory); " is 155.
Long Statement,Microsoft.Cci.Immutable,SpecializedNestedTypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      var specializedParent = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(nestedType.ContainingType' containingTypeInstance' internFactory); " is 156.
Long Statement,Microsoft.Cci.Immutable,SpecializedNestedTypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,InitializeIfNecessary,The length of the statement  "          //^ assume unspecializedMember is IEventDefinition || unspecializedMember is IFieldDefinition || unspecializedMember is IMethodDefinition || " is 140.
Long Statement,Microsoft.Cci.Immutable,SpecializedNestedTypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,InitializeIfNecessary,The length of the statement  "          //^   unspecializedMember is IPropertyDefinition || unspecializedMember is INestedTypeDefinition; //follows from informal post condition on Members property. " is 157.
Long Statement,Microsoft.Cci.Immutable,SpecializedNestedTypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,CopyAndSpecialize,The length of the statement  "      partiallySpecializedTypeReference = TypeDefinition.DeepCopyTypeReference(partiallySpecializedTypeReference' this' this.InternFactory); " is 134.
Long Statement,Microsoft.Cci.Immutable,SpecializedNestedTypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,CopyAndSpecialize,The length of the statement  "      return TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(partiallySpecializedTypeReference' this.ContainingGenericTypeInstance' this.InternFactory); " is 164.
Long Statement,Microsoft.Cci.Immutable,SpecializedNestedTypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeMember,The length of the statement  "        return new SpecializedPropertyDefinition(unspecializedPropertyDef' propertyDef' this' this.ContainingGenericTypeInstance); " is 122.
Long Statement,Microsoft.Cci.Immutable,SpecializedNestedTypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeMember,The length of the statement  "      return new SpecializedNestedTypeDefinition(unspecializedTypeDef' nestedTypeDef' this' this.ContainingGenericTypeInstance' internFactory); " is 137.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReference,The length of the statement  "      if (genericTypeInstance != null) return GenericTypeInstance.DeepCopyTypeReference(genericTypeInstance' targetContainer' internFactory); " is 135.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReference,The length of the statement  "      if (managedPointerType != null) return ManagedPointerType.DeepCopyTypeReference(managedPointerType' targetContainer' internFactory); " is 132.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReference,The length of the statement  "      if (modifiedPointer != null) return ModifiedPointerType.DeepCopyTypeReference(modifiedPointer' targetContainer' internFactory); " is 127.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReference,The length of the statement  "      if (modifiedType != null) return ModifiedTypeReference.DeepCopyTypeReference(modifiedType' targetContainer' internFactory); " is 123.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReference,The length of the statement  "      if (nestedType != null) return SpecializedNestedTypeDefinition.DeepCopyTypeReference(nestedType' targetContainer' internFactory); " is 129.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "        if (arrayType.IsVector) return Vector.SpecializeIfConstructedFromApplicableTypeParameter(arrayType' containingMethodInstance' internFactory); " is 141.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      if (genericMethodParameter != null) return GenericParameter.SpecializeIfConstructedFromApplicableTypeParameter(genericMethodParameter' containingMethodInstance); " is 161.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      if (genericTypeInstance != null) return GenericTypeInstance.SpecializeIfConstructedFromApplicableTypeParameter(genericTypeInstance' containingMethodInstance' internFactory); " is 173.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      if (managedPointerType != null) return ManagedPointerType.SpecializeIfConstructedFromApplicableTypeParameter(managedPointerType' containingMethodInstance' internFactory); " is 170.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      if (modifiedPointer != null) return ModifiedPointerType.SpecializeIfConstructedFromApplicableTypeParameter(modifiedPointer' containingMethodInstance' internFactory); " is 165.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      if (modifiedType != null) return ModifiedTypeReference.SpecializeIfConstructedFromApplicableTypeParameter(modifiedType' containingMethodInstance' internFactory); " is 161.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      if (nestedType != null) return SpecializedNestedTypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(nestedType' containingMethodInstance' internFactory); " is 167.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      if (pointerType != null) return PointerType.SpecializeIfConstructedFromApplicableTypeParameter(pointerType' containingMethodInstance' internFactory); " is 149.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "        if (arrayType.IsVector) return Vector.SpecializeIfConstructedFromApplicableTypeParameter(arrayType' containingTypeInstance' internFactory); " is 139.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      if (genericTypeParameter != null) return GenericParameter.SpecializeIfConstructedFromApplicableTypeParameter(genericTypeParameter' containingTypeInstance); " is 155.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      if (genericTypeInstance != null) return GenericTypeInstance.SpecializeIfConstructedFromApplicableTypeParameter(genericTypeInstance' containingTypeInstance' internFactory); " is 171.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      if (managedPointerType != null) return ManagedPointerType.SpecializeIfConstructedFromApplicableTypeParameter(managedPointerType' containingTypeInstance' internFactory); " is 168.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      if (modifiedPointer != null) return ModifiedPointerType.SpecializeIfConstructedFromApplicableTypeParameter(modifiedPointer' containingTypeInstance' internFactory); " is 163.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      if (modifiedType != null) return ModifiedTypeReference.SpecializeIfConstructedFromApplicableTypeParameter(modifiedType' containingTypeInstance' internFactory); " is 159.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      if (nestedType != null) return SpecializedNestedTypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(nestedType' containingTypeInstance' internFactory); " is 165.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      if (pointerType != null) return PointerType.SpecializeIfConstructedFromApplicableTypeParameter(pointerType' containingTypeInstance' internFactory); " is 147.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "        if (arrayType.IsVector) return Vector.DeepCopyTypeReferenceWRTSpecializedMethod(arrayType' specializedMethodReference' internFactory); " is 134.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "      if (genericMethodParameter != null) return GenericParameter.DeepCopyTypeReferenceWRTSpecializedMethod(genericMethodParameter' specializedMethodReference); " is 154.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "      if (genericTypeParameter != null) return GenericParameter.DeepCopyTypeReferenceWRTSpecializedMethod(genericTypeParameter' specializedMethodReference); " is 150.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "      if (genericTypeInstance != null) return GenericTypeInstance.DeepCopyTypeReferenceWRTSpecializedMethod(genericTypeInstance' specializedMethodReference' internFactory); " is 166.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "      if (managedPointerType != null) return ManagedPointerType.DeepCopyTypeReferenceWRTSpecializedMethod(managedPointerType' specializedMethodReference' internFactory); " is 163.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "      if (modifiedPointer != null) return ModifiedPointerType.DeepCopyTypeReferenceWRTSpecializedMethod(modifiedPointer' specializedMethodReference' internFactory); " is 158.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "      if (modifiedType != null) return ModifiedTypeReference.DeepCopyTypeReferenceWRTSpecializedMethod(modifiedType' specializedMethodReference' internFactory); " is 154.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "      if (pointerType != null) return PointerType.DeepCopyTypeReferenceReplacingGenericMethodParameter(pointerType' specializedMethodReference' internFactory); " is 153.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "      if (nestedType != null) return SpecializedNestedTypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod(nestedType' specializedMethodReference' internFactory); " is 160.
Long Statement,Microsoft.Cci.Immutable,Vector,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,GetInterfaceList,The length of the statement  "        interfaces.Add(GenericTypeInstance.GetGenericTypeInstance(this.PlatformType.SystemCollectionsGenericIList' argTypes' this.InternFactory)); " is 138.
Long Statement,Microsoft.Cci.Immutable,Vector,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,GetInterfaceList,The length of the statement  "        interfaces.Add(GenericTypeInstance.GetGenericTypeInstance(this.PlatformType.SystemCollectionsGenericICollection' argTypes' this.InternFactory)); " is 144.
Long Statement,Microsoft.Cci.Immutable,Vector,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,GetInterfaceList,The length of the statement  "        interfaces.Add(GenericTypeInstance.GetGenericTypeInstance(this.PlatformType.SystemCollectionsGenericIEnumerable' argTypes' this.InternFactory)); " is 144.
Long Statement,Microsoft.Cci.Immutable,Vector,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReference,The length of the statement  "      ITypeReference specializedElementType = TypeDefinition.DeepCopyTypeReference(elementType' targetContainer' internFactory); " is 122.
Long Statement,Microsoft.Cci.Immutable,Vector,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeTypeReference,The length of the statement  "      ITypeReference specializedElementType = TypeHelper.SpecializeTypeReference(elementType' targetContainer' internFactory); " is 120.
Long Statement,Microsoft.Cci.Immutable,Vector,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeTypeReference,The length of the statement  "      ITypeReference specializedElementType = TypeHelper.SpecializeTypeReference(elementType' targetContainer' internFactory); " is 120.
Long Statement,Microsoft.Cci.Immutable,Vector,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      ITypeReference specializedElementType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(elementType' method' internFactory); " is 142.
Long Statement,Microsoft.Cci.Immutable,Vector,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "      ITypeReference specializedElementType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter(elementType' type' internFactory); " is 140.
Long Statement,Microsoft.Cci.Immutable,Vector,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "      ITypeReference specializedElementType = TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod(elementType' specializedMethodReference' internFactory); " is 153.
Long Statement,Microsoft.Cci.Immutable,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,AssemblyOneAllowsAssemblyTwoToAccessItsInternals,The length of the statement  "        if (!TypeHelper.TypesAreEquivalent(attribute.Type' assembly1.PlatformType.SystemRuntimeCompilerServicesInternalsVisibleToAttribute)) continue; " is 142.
Long Statement,Microsoft.Cci.Immutable,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,AssemblyOneAllowsAssemblyTwoToAccessItsInternals,The length of the statement  "          if (string.Compare(assemblyName' 0' assembly2.Name.Value' 0' name2Length' StringComparison.OrdinalIgnoreCase) == 0) return true; " is 128.
Long Statement,Microsoft.Cci.Immutable,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,GetAssemblyIdentity,The length of the statement  "      string culture = assemblyName.CultureInfo == null || assemblyName.CultureInfo == System.Globalization.CultureInfo.InvariantCulture ? "neutral" : assemblyName.CultureInfo.ToString(); " is 181.
Long Statement,Microsoft.Cci.Immutable,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,GetAssemblyIdentity,The length of the statement  "        return new AssemblyIdentity(assembly.Name' assembly.Culture' assembly.Version' UnitHelper.ComputePublicKeyToken(pKey)' assembly.Location); " is 138.
Long Statement,Microsoft.Cci.Immutable,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,StrongName,The length of the statement  "      sb.AppendFormat(CultureInfo.InvariantCulture' "' Version={0}.{1}.{2}.{3}"' assemblyReference.Version.Major' assemblyReference.Version.Minor' assemblyReference.Version.Build' assemblyReference.Version.Revision); " is 210.
Long Statement,Microsoft.Cci.Immutable,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,FindType,The length of the statement  "      INamedTypeDefinition/*?*/ result = GetType(nameTable' unit.UnitNamespaceRoot' typeName' genericParameterCount' ref offset); " is 123.
Long Statement,Microsoft.Cci.Immutable,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,GetType,The length of the statement  "          var nt = GetNestedType(nameTable' namespaceType' typeName' genericParameterCount-namespaceType.GenericParameterCount' ref offset); " is 130.
Long Statement,Microsoft.Cci.Immutable,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,GetNestedType,The length of the statement  "        var nt = GetNestedType(nameTable' nestedType' typeName' genericParameterCount-nestedType.GenericParameterCount' ref offset); " is 124.
Long Statement,Microsoft.Cci.Immutable,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,UnitNamespacesAreEquivalent,The length of the statement  "          && UnitHelper.UnitNamespacesAreEquivalent(nstUnitNamespace1.ContainingUnitNamespace' nstUnitNamespace2.ContainingUnitNamespace); " is 128.
Long Statement,Microsoft.Cci.Immutable,UnitSet,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,Contains,The length of the statement  "      //^ assume result == exists{IUnit u in this.Units; u == unit}; //TODO: Boogie: need a working postcodition on EnumerableContains " is 128.
Complex Conditional,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetCoreAssemblySymbolicIdentity,The conditional expression  "result == null || result.Version == dummyVersion ||                 (result.Version < coreId.Version && coreId.Version != dummyVersion) ||                  result.Version == coreId.Version && unit.UnitIdentity.Equals(coreId)"  is complex.
Complex Conditional,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetSignatureInternId,The conditional expression  "signatureStore.CallingConvention == callingConvention            && signatureStore.RequiredParameterListInternedId == requiredParameterTypesInternedId            && signatureStore.ExtraParameterListInternedId == extraArgumentTypesInteredId            && signatureStore.ReturnValueCustomModifiersListInteredId == returnValueCustomModifiersInternedId            && signatureStore.ReturnValueIsByRef == returnValueIsByRef            && signatureStore.ReturnTypeReferenceInternedId == returnTypeReferenceInternedId"  is complex.
Complex Conditional,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetMethodReferenceInternedId,The conditional expression  "signatureStore.CallingConvention == methodReference.CallingConvention            && signatureStore.RequiredParameterListInternedId == requiredParameterTypesInternedId            && signatureStore.ReturnValueCustomModifiersListInteredId == returnValueCustomModifiersInternedId            && signatureStore.ReturnValueIsByRef == methodReference.ReturnValueIsByRef            && signatureStore.ReturnTypeReferenceInternedId == returnTypeReferenceInternedId            && signatureStore.GenericParameterCount == genericParameterCount"  is complex.
Complex Conditional,Microsoft.Cci,SignatureFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetMethodSignature,The conditional expression  "(formattingOptions & NameFormattingOptions.FormattingForDocumentationId) != 0 && method.ResolvedMethod.IsSpecialName && (method.Name.Value.Contains("op_Explicit") || method.Name.Value.Contains("op_Implicit"))"  is complex.
Complex Conditional,Microsoft.Cci,SignatureFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendMethodParameters,The conditional expression  "!parameter.MustBeReferenceType && !parameter.MustBeValueType && !parameter.MustHaveDefaultConstructor && IteratorHelper.EnumerableIsEmpty(parameter.Constraints)"  is complex.
Complex Conditional,Microsoft.Cci,BaseMetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The conditional expression  "marshallingInformation.UnmanagedType == System.Runtime.InteropServices.UnmanagedType.SafeArray &&         (marshallingInformation.SafeArrayElementSubtype == System.Runtime.InteropServices.VarEnum.VT_DISPATCH ||        marshallingInformation.SafeArrayElementSubtype == System.Runtime.InteropServices.VarEnum.VT_UNKNOWN ||        marshallingInformation.SafeArrayElementSubtype == System.Runtime.InteropServices.VarEnum.VT_RECORD)"  is complex.
Complex Conditional,Microsoft.Cci,MetadataTraverser,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Visitors.cs,TraverseChildren,The conditional expression  "marshallingInformation.UnmanagedType == System.Runtime.InteropServices.UnmanagedType.SafeArray &&         (marshallingInformation.SafeArrayElementSubtype == System.Runtime.InteropServices.VarEnum.VT_DISPATCH ||        marshallingInformation.SafeArrayElementSubtype == System.Runtime.InteropServices.VarEnum.VT_UNKNOWN ||        marshallingInformation.SafeArrayElementSubtype == System.Runtime.InteropServices.VarEnum.VT_RECORD)"  is complex.
Complex Conditional,Microsoft.Cci,TypeNameFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,AddGenericParametersIfNeeded,The conditional expression  "(formattingOptions & NameFormattingOptions.TypeParameters) != 0 && (formattingOptions & NameFormattingOptions.FormattingForDocumentationId) == 0 && genericParameterCount > 0 && type.ResolvedType != Dummy.Type"  is complex.
Complex Conditional,Microsoft.Cci,TypeNameFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,AddGenericParametersIfNeeded,The conditional expression  "!parameter.MustBeReferenceType && !parameter.MustBeValueType && !parameter.MustHaveDefaultConstructor && IteratorHelper.EnumerableIsEmpty(parameter.Constraints)"  is complex.
Complex Conditional,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,CheckUnmanagedType,The conditional expression  "type < 0x02 || (0x0c < type && type < 0x13 && type != 0x0f) || type == 0x18 || type == 0x21 || type == 0x27 || type == 0x29 ||            (0x2d < type && type != 0x50)"  is complex.
Complex Conditional,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The conditional expression  "method.IsStatic && (method.IsSealed || method.IsVirtual || method.IsNewSlot)"  is complex.
Complex Conditional,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The conditional expression  "method.IsAbstract && (method.IsSealed || method.IsPlatformInvoke || method.IsForwardReference)"  is complex.
Complex Conditional,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The conditional expression  "(method.IsSealed || method.IsNewSlot || method.IsAccessCheckedOnOverride) && !method.IsVirtual"  is complex.
Empty Catch Block,Microsoft.Cci,OptionParsing,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,ParseValue,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci,OptionParsing,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,ParseValue,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci,GlobalAssemblyCache,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\GlobalAssemblyCache.cs,Contains,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci,GlobalAssemblyCache,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\GlobalAssemblyCache.cs,Contains,The method has an empty catch block.
Magic Number,Microsoft.Cci,OptionParsing,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,SplitLineWithQuotes,The following statement contains a magic number: for (var index = 0; index < line.Length; index++)        {          var current = line[index];            if (current == '\\')          {            // escape character            escaping++;            // swallow the escape character for now            // grab everything prior to prior escape character            if (index > start)            {              currentArg.Append(line.Substring(start' index - start));            }            start = index + 1;            continue;          }          if (escaping > 0)          {            if (current == '"')            {              var backslashes = escaping / 2;              for (int i = 0; i < backslashes; i++) { currentArg.Append('\\'); }              if (escaping % 2 == 1)              {                // escapes the "                currentArg.Append('"');                escaping = 0;                start = index + 1;                continue;              }            }            else            {              var backslashes = escaping;              for (int i = 0; i < backslashes; i++) { currentArg.Append('\\'); }            }            escaping = 0;          }          if (inDoubleQuotes)          {            if (current == '"')            {              // ending argument              FinishArgument(line' start' args' currentArg' index' true);              start = index + 1;              inDoubleQuotes = false;              continue;            }          }          else // not in quotes          {            if (Char.IsWhiteSpace(current))            {              // end previous' start new              FinishArgument(line' start' args' currentArg' index' false);              start = index + 1;              continue;            }            if (current == '"')            {              // starting double quote              if (index != start)              {                AddError("Response file '{0}' line {1}' char {2} contains '\"' not starting or ending an argument"' responseFileName' lineNo' index);              }              start = index + 1;              inDoubleQuotes = true;              continue;            }          }        }
Magic Number,Microsoft.Cci,OptionParsing,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,SplitLineWithQuotes,The following statement contains a magic number: for (var index = 0; index < line.Length; index++)        {          var current = line[index];            if (current == '\\')          {            // escape character            escaping++;            // swallow the escape character for now            // grab everything prior to prior escape character            if (index > start)            {              currentArg.Append(line.Substring(start' index - start));            }            start = index + 1;            continue;          }          if (escaping > 0)          {            if (current == '"')            {              var backslashes = escaping / 2;              for (int i = 0; i < backslashes; i++) { currentArg.Append('\\'); }              if (escaping % 2 == 1)              {                // escapes the "                currentArg.Append('"');                escaping = 0;                start = index + 1;                continue;              }            }            else            {              var backslashes = escaping;              for (int i = 0; i < backslashes; i++) { currentArg.Append('\\'); }            }            escaping = 0;          }          if (inDoubleQuotes)          {            if (current == '"')            {              // ending argument              FinishArgument(line' start' args' currentArg' index' true);              start = index + 1;              inDoubleQuotes = false;              continue;            }          }          else // not in quotes          {            if (Char.IsWhiteSpace(current))            {              // end previous' start new              FinishArgument(line' start' args' currentArg' index' false);              start = index + 1;              continue;            }            if (current == '"')            {              // starting double quote              if (index != start)              {                AddError("Response file '{0}' line {1}' char {2} contains '\"' not starting or ending an argument"' responseFileName' lineNo' index);              }              start = index + 1;              inDoubleQuotes = true;              continue;            }          }        }
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetCoreAssemblySymbolicIdentity,The following statement contains a magic number: if (this.unitCache.Count > 0) {          AssemblyIdentity/*?*/ result = null;          IUnit referringUnit = Dummy.Unit;          var dummyVersion = new Version(255' 255' 255' 255);          lock (GlobalLock.LockingObject) {            foreach (IUnit unit in this.unitCache.Values) {              AssemblyIdentity coreId = unit.CoreAssemblySymbolicIdentity;              if (coreId.Name.Value.Length == 0) continue;              if (result == null || result.Version == dummyVersion ||                 (result.Version < coreId.Version && coreId.Version != dummyVersion) ||                  result.Version == coreId.Version && unit.UnitIdentity.Equals(coreId)) {                result = coreId;                referringUnit = unit;              }            }          }          if (result != null) {            //The loaded assemblies have an opinion on the identity of the core assembly. By default' we are going to respect that opinion.            if (result.Location.Length == 0) {              //However' they do not know where to find it. (This will only be non empty if one of the loaded assemblies itself is the core assembly.)              if (loc.Length > 0) {                //We don't know where to find the core assembly that the loaded assemblies want' but we do know where to find the core assembly                //that we are running on. Perhaps it is the same assembly as the one we've identified. In that case we know where it can be found.                var myCore = new AssemblyIdentity(this.NameTable.GetNameFor(coreAssemblyName.Name)' ""' coreAssemblyName.Version' coreAssemblyName.GetPublicKeyToken()' loc);                if (myCore.Equals(result)) return myCore; //myCore is the same as result' but also has a non null location.              }              //Now use host specific heuristics for finding the assembly.              this.coreAssemblySymbolicIdentity = result; //in case ProbeAssemblyReference wants to know the core identity              return this.ProbeAssemblyReference(referringUnit' result);            }            return result;          }        }
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetCoreAssemblySymbolicIdentity,The following statement contains a magic number: if (this.unitCache.Count > 0) {          AssemblyIdentity/*?*/ result = null;          IUnit referringUnit = Dummy.Unit;          var dummyVersion = new Version(255' 255' 255' 255);          lock (GlobalLock.LockingObject) {            foreach (IUnit unit in this.unitCache.Values) {              AssemblyIdentity coreId = unit.CoreAssemblySymbolicIdentity;              if (coreId.Name.Value.Length == 0) continue;              if (result == null || result.Version == dummyVersion ||                 (result.Version < coreId.Version && coreId.Version != dummyVersion) ||                  result.Version == coreId.Version && unit.UnitIdentity.Equals(coreId)) {                result = coreId;                referringUnit = unit;              }            }          }          if (result != null) {            //The loaded assemblies have an opinion on the identity of the core assembly. By default' we are going to respect that opinion.            if (result.Location.Length == 0) {              //However' they do not know where to find it. (This will only be non empty if one of the loaded assemblies itself is the core assembly.)              if (loc.Length > 0) {                //We don't know where to find the core assembly that the loaded assemblies want' but we do know where to find the core assembly                //that we are running on. Perhaps it is the same assembly as the one we've identified. In that case we know where it can be found.                var myCore = new AssemblyIdentity(this.NameTable.GetNameFor(coreAssemblyName.Name)' ""' coreAssemblyName.Version' coreAssemblyName.GetPublicKeyToken()' loc);                if (myCore.Equals(result)) return myCore; //myCore is the same as result' but also has a non null location.              }              //Now use host specific heuristics for finding the assembly.              this.coreAssemblySymbolicIdentity = result; //in case ProbeAssemblyReference wants to know the core identity              return this.ProbeAssemblyReference(referringUnit' result);            }            return result;          }        }
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetCoreAssemblySymbolicIdentity,The following statement contains a magic number: if (this.unitCache.Count > 0) {          AssemblyIdentity/*?*/ result = null;          IUnit referringUnit = Dummy.Unit;          var dummyVersion = new Version(255' 255' 255' 255);          lock (GlobalLock.LockingObject) {            foreach (IUnit unit in this.unitCache.Values) {              AssemblyIdentity coreId = unit.CoreAssemblySymbolicIdentity;              if (coreId.Name.Value.Length == 0) continue;              if (result == null || result.Version == dummyVersion ||                 (result.Version < coreId.Version && coreId.Version != dummyVersion) ||                  result.Version == coreId.Version && unit.UnitIdentity.Equals(coreId)) {                result = coreId;                referringUnit = unit;              }            }          }          if (result != null) {            //The loaded assemblies have an opinion on the identity of the core assembly. By default' we are going to respect that opinion.            if (result.Location.Length == 0) {              //However' they do not know where to find it. (This will only be non empty if one of the loaded assemblies itself is the core assembly.)              if (loc.Length > 0) {                //We don't know where to find the core assembly that the loaded assemblies want' but we do know where to find the core assembly                //that we are running on. Perhaps it is the same assembly as the one we've identified. In that case we know where it can be found.                var myCore = new AssemblyIdentity(this.NameTable.GetNameFor(coreAssemblyName.Name)' ""' coreAssemblyName.Version' coreAssemblyName.GetPublicKeyToken()' loc);                if (myCore.Equals(result)) return myCore; //myCore is the same as result' but also has a non null location.              }              //Now use host specific heuristics for finding the assembly.              this.coreAssemblySymbolicIdentity = result; //in case ProbeAssemblyReference wants to know the core identity              return this.ProbeAssemblyReference(referringUnit' result);            }            return result;          }        }
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetCoreAssemblySymbolicIdentity,The following statement contains a magic number: if (this.unitCache.Count > 0) {          AssemblyIdentity/*?*/ result = null;          IUnit referringUnit = Dummy.Unit;          var dummyVersion = new Version(255' 255' 255' 255);          lock (GlobalLock.LockingObject) {            foreach (IUnit unit in this.unitCache.Values) {              AssemblyIdentity coreId = unit.CoreAssemblySymbolicIdentity;              if (coreId.Name.Value.Length == 0) continue;              if (result == null || result.Version == dummyVersion ||                 (result.Version < coreId.Version && coreId.Version != dummyVersion) ||                  result.Version == coreId.Version && unit.UnitIdentity.Equals(coreId)) {                result = coreId;                referringUnit = unit;              }            }          }          if (result != null) {            //The loaded assemblies have an opinion on the identity of the core assembly. By default' we are going to respect that opinion.            if (result.Location.Length == 0) {              //However' they do not know where to find it. (This will only be non empty if one of the loaded assemblies itself is the core assembly.)              if (loc.Length > 0) {                //We don't know where to find the core assembly that the loaded assemblies want' but we do know where to find the core assembly                //that we are running on. Perhaps it is the same assembly as the one we've identified. In that case we know where it can be found.                var myCore = new AssemblyIdentity(this.NameTable.GetNameFor(coreAssemblyName.Name)' ""' coreAssemblyName.Version' coreAssemblyName.GetPublicKeyToken()' loc);                if (myCore.Equals(result)) return myCore; //myCore is the same as result' but also has a non null location.              }              //Now use host specific heuristics for finding the assembly.              this.coreAssemblySymbolicIdentity = result; //in case ProbeAssemblyReference wants to know the core identity              return this.ProbeAssemblyReference(referringUnit' result);            }            return result;          }        }
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetSystemCoreAssemblySymbolicIdentity,The following statement contains a magic number: var version = new Version(3' 5' 0' 0);
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetSystemCoreAssemblySymbolicIdentity,The following statement contains a magic number: var version = new Version(3' 5' 0' 0);
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetTargetPlatformPointerSize,The following statement contains a magic number: lock (GlobalLock.LockingObject) {          if (this.unitCache.Count > 0) {            foreach (IUnit unit in this.unitCache.Values) {              IModule/*?*/ module = unit as IModule;              if (module == null) continue;              if (module.Requires32bits) return 4;              if (module.Requires64bits) return 8;            }          }        }
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetTargetPlatformPointerSize,The following statement contains a magic number: lock (GlobalLock.LockingObject) {          if (this.unitCache.Count > 0) {            foreach (IUnit unit in this.unitCache.Values) {              IModule/*?*/ module = unit as IModule;              if (module == null) continue;              if (module.Requires32bits) return 4;              if (module.Requires64bits) return 8;            }          }        }
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetTargetPlatformPointerSize,The following statement contains a magic number: return 4;
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,ProbeAssemblyReference,The following statement contains a magic number: if (coreVersion.Major == 1) {          if (coreVersion.Minor == 0)            platformDir = Path.Combine(Path.GetDirectoryName(platformDir)' "v1.0.3705");          else if (coreVersion.Minor == 1)            platformDir = Path.Combine(Path.GetDirectoryName(platformDir)' "v1.1.4322");        } else if (coreVersion.Major == 2) {          platformDir = Path.Combine(Path.GetDirectoryName(platformDir)' "v3.5");          result = this.Probe(platformDir' referencedAssembly);          if (result != null) return result;          platformDir = Path.Combine(Path.GetDirectoryName(platformDir)' "v3.0");          result = this.Probe(platformDir' referencedAssembly);          if (result != null) return result;          platformDir = Path.Combine(Path.GetDirectoryName(platformDir)' "v2.0.50727");        } else if (coreVersion.Major == 4) {          platformDir = Path.Combine(Path.GetDirectoryName(platformDir)' "v4.0.30319");        }
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,ProbeAssemblyReference,The following statement contains a magic number: if (coreVersion.Major == 1) {          if (coreVersion.Minor == 0)            platformDir = Path.Combine(Path.GetDirectoryName(platformDir)' "v1.0.3705");          else if (coreVersion.Minor == 1)            platformDir = Path.Combine(Path.GetDirectoryName(platformDir)' "v1.1.4322");        } else if (coreVersion.Major == 2) {          platformDir = Path.Combine(Path.GetDirectoryName(platformDir)' "v3.5");          result = this.Probe(platformDir' referencedAssembly);          if (result != null) return result;          platformDir = Path.Combine(Path.GetDirectoryName(platformDir)' "v3.0");          result = this.Probe(platformDir' referencedAssembly);          if (result != null) return result;          platformDir = Path.Combine(Path.GetDirectoryName(platformDir)' "v2.0.50727");        } else if (coreVersion.Major == 4) {          platformDir = Path.Combine(Path.GetDirectoryName(platformDir)' "v4.0.30319");        }
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,UnifyAssembly,The following statement contains a magic number: if (string.Equals(assemblyIdentity.Name.Value' "mscorlib"' StringComparison.OrdinalIgnoreCase) && assemblyIdentity.Version == new Version(255' 255' 255' 255))          return this.CoreAssemblySymbolicIdentity;
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,UnifyAssembly,The following statement contains a magic number: if (string.Equals(assemblyIdentity.Name.Value' "mscorlib"' StringComparison.OrdinalIgnoreCase) && assemblyIdentity.Version == new Version(255' 255' 255' 255))          return this.CoreAssemblySymbolicIdentity;
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,UnifyAssembly,The following statement contains a magic number: if (string.Equals(assemblyIdentity.Name.Value' "mscorlib"' StringComparison.OrdinalIgnoreCase) && assemblyIdentity.Version == new Version(255' 255' 255' 255))          return this.CoreAssemblySymbolicIdentity;
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,UnifyAssembly,The following statement contains a magic number: if (string.Equals(assemblyIdentity.Name.Value' "mscorlib"' StringComparison.OrdinalIgnoreCase) && assemblyIdentity.Version == new Version(255' 255' 255' 255))          return this.CoreAssemblySymbolicIdentity;
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: if (this.currentWildGuesses != null) {          var keys = new List<uint>(this.currentWildGuesses.Keys);          foreach (var key in keys) {            var oldValue = this.currentWildGuesses[key];            if (oldValue == 4)              this.currentWildGuesses[key] = 1;            else if (oldValue == 1)              this.currentWildGuesses[key] = 2;            else if (oldValue == 2)              this.currentWildGuesses[key] = 8;            else {              this.currentWildGuesses[key] = 4;              continue;            }            allPermutationsHaveBeenTried = false;            break;          }        }
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: if (this.currentWildGuesses != null) {          var keys = new List<uint>(this.currentWildGuesses.Keys);          foreach (var key in keys) {            var oldValue = this.currentWildGuesses[key];            if (oldValue == 4)              this.currentWildGuesses[key] = 1;            else if (oldValue == 1)              this.currentWildGuesses[key] = 2;            else if (oldValue == 2)              this.currentWildGuesses[key] = 8;            else {              this.currentWildGuesses[key] = 4;              continue;            }            allPermutationsHaveBeenTried = false;            break;          }        }
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: if (this.currentWildGuesses != null) {          var keys = new List<uint>(this.currentWildGuesses.Keys);          foreach (var key in keys) {            var oldValue = this.currentWildGuesses[key];            if (oldValue == 4)              this.currentWildGuesses[key] = 1;            else if (oldValue == 1)              this.currentWildGuesses[key] = 2;            else if (oldValue == 2)              this.currentWildGuesses[key] = 8;            else {              this.currentWildGuesses[key] = 4;              continue;            }            allPermutationsHaveBeenTried = false;            break;          }        }
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: if (this.currentWildGuesses != null) {          var keys = new List<uint>(this.currentWildGuesses.Keys);          foreach (var key in keys) {            var oldValue = this.currentWildGuesses[key];            if (oldValue == 4)              this.currentWildGuesses[key] = 1;            else if (oldValue == 1)              this.currentWildGuesses[key] = 2;            else if (oldValue == 2)              this.currentWildGuesses[key] = 8;            else {              this.currentWildGuesses[key] = 4;              continue;            }            allPermutationsHaveBeenTried = false;            break;          }        }
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: if (this.currentWildGuesses != null) {          var keys = new List<uint>(this.currentWildGuesses.Keys);          foreach (var key in keys) {            var oldValue = this.currentWildGuesses[key];            if (oldValue == 4)              this.currentWildGuesses[key] = 1;            else if (oldValue == 1)              this.currentWildGuesses[key] = 2;            else if (oldValue == 2)              this.currentWildGuesses[key] = 8;            else {              this.currentWildGuesses[key] = 4;              continue;            }            allPermutationsHaveBeenTried = false;            break;          }        }
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: if (allPermutationsHaveBeenTried && this.currentGoodGuesses != null) {          if (this.currentWildGuesses == null) this.currentWildGuesses = new Dictionary<uint' byte>();          foreach (var key in this.currentGoodGuesses.Keys) {            allPermutationsHaveBeenTried = false;            this.currentWildGuesses[key] = 4;          }          this.currentGoodGuesses = null;        }
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum,The following statement contains a magic number: this.currentWildGuesses[rkey] = 4;
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum,The following statement contains a magic number: return 4;
Magic Number,Microsoft.Cci,InternFactory,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetGenericMethodParameterReferenceInternId,The following statement contains a magic number: if (this.CurrentMethodReference != Dummy.MethodReference) {          //this happens when the defining method reference contains a type in its signature which either is' or contains'          //a reference to this generic method type parameter. In that case we break the cycle by just using the index of           //the generic parameter. Only method references that refer to their own type parameters will ever          //get this version of the interned id.          return index+1000000; //provide a big offset to minimize the chances of a structural type in the           //signature of the method interning onto some other type that is parameterized by a type whose intern key is index.        }
Magic Number,Microsoft.Cci,NameTable,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetNameFor,The following statement contains a magic number: lock (this.caseInsensitiveTable) {          IName/*?*/ result;          if (this.caseSensitiveTable.TryGetValue(name' out result)) {            //^ assume result != null; //Follows from the way Dictionary is instantiated' but the verifier is ignorant of this.            //^ assume result.Value == name; //Only this routine ever adds entries to the table and it only ever adds entries for which this is true. TODO: it would be nice to be able express this as an invariant.            return result;          }          //string lowerCaseName = name.ToLower(CultureInfo.InvariantCulture); //REVIEW: is it safer to use ToUpperInvariant' or does it make no difference?          int caseInsensitiveCounter;          if (!this.caseInsensitiveTable.TryGetValue(name' out caseInsensitiveCounter)) {            caseInsensitiveCounter = this.caseInsensitiveCounter;            caseInsensitiveCounter += 17;            if (caseInsensitiveCounter <= 0) {              caseInsensitiveCounter = (caseInsensitiveCounter - int.MinValue) + 1000000;            }            this.caseInsensitiveCounter = caseInsensitiveCounter;            this.caseInsensitiveTable.Add(name' caseInsensitiveCounter);          }          //^ assume caseInsensitiveCounter > 0; //Follows from the invariant' but this is beyond the verifier right now.          int caseSensitiveCounter = this.caseSensitiveCounter;          caseSensitiveCounter += 17;          if (caseSensitiveCounter <= 0) {            caseSensitiveCounter = (caseSensitiveCounter - int.MinValue) + 1000000;            //^ assume caseSensitiveCounter > 0;          }          result = new Name(caseInsensitiveCounter' caseSensitiveCounter' name);          //^ assume result.Value == name;          this.caseSensitiveCounter = caseSensitiveCounter;          this.caseSensitiveTable.Add(name' result);          return result;        }
Magic Number,Microsoft.Cci,NameTable,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetNameFor,The following statement contains a magic number: lock (this.caseInsensitiveTable) {          IName/*?*/ result;          if (this.caseSensitiveTable.TryGetValue(name' out result)) {            //^ assume result != null; //Follows from the way Dictionary is instantiated' but the verifier is ignorant of this.            //^ assume result.Value == name; //Only this routine ever adds entries to the table and it only ever adds entries for which this is true. TODO: it would be nice to be able express this as an invariant.            return result;          }          //string lowerCaseName = name.ToLower(CultureInfo.InvariantCulture); //REVIEW: is it safer to use ToUpperInvariant' or does it make no difference?          int caseInsensitiveCounter;          if (!this.caseInsensitiveTable.TryGetValue(name' out caseInsensitiveCounter)) {            caseInsensitiveCounter = this.caseInsensitiveCounter;            caseInsensitiveCounter += 17;            if (caseInsensitiveCounter <= 0) {              caseInsensitiveCounter = (caseInsensitiveCounter - int.MinValue) + 1000000;            }            this.caseInsensitiveCounter = caseInsensitiveCounter;            this.caseInsensitiveTable.Add(name' caseInsensitiveCounter);          }          //^ assume caseInsensitiveCounter > 0; //Follows from the invariant' but this is beyond the verifier right now.          int caseSensitiveCounter = this.caseSensitiveCounter;          caseSensitiveCounter += 17;          if (caseSensitiveCounter <= 0) {            caseSensitiveCounter = (caseSensitiveCounter - int.MinValue) + 1000000;            //^ assume caseSensitiveCounter > 0;          }          result = new Name(caseInsensitiveCounter' caseSensitiveCounter' name);          //^ assume result.Value == name;          this.caseSensitiveCounter = caseSensitiveCounter;          this.caseSensitiveTable.Add(name' result);          return result;        }
Magic Number,Microsoft.Cci,NameTable,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetNameFor,The following statement contains a magic number: lock (this.caseInsensitiveTable) {          IName/*?*/ result;          if (this.caseSensitiveTable.TryGetValue(name' out result)) {            //^ assume result != null; //Follows from the way Dictionary is instantiated' but the verifier is ignorant of this.            //^ assume result.Value == name; //Only this routine ever adds entries to the table and it only ever adds entries for which this is true. TODO: it would be nice to be able express this as an invariant.            return result;          }          //string lowerCaseName = name.ToLower(CultureInfo.InvariantCulture); //REVIEW: is it safer to use ToUpperInvariant' or does it make no difference?          int caseInsensitiveCounter;          if (!this.caseInsensitiveTable.TryGetValue(name' out caseInsensitiveCounter)) {            caseInsensitiveCounter = this.caseInsensitiveCounter;            caseInsensitiveCounter += 17;            if (caseInsensitiveCounter <= 0) {              caseInsensitiveCounter = (caseInsensitiveCounter - int.MinValue) + 1000000;            }            this.caseInsensitiveCounter = caseInsensitiveCounter;            this.caseInsensitiveTable.Add(name' caseInsensitiveCounter);          }          //^ assume caseInsensitiveCounter > 0; //Follows from the invariant' but this is beyond the verifier right now.          int caseSensitiveCounter = this.caseSensitiveCounter;          caseSensitiveCounter += 17;          if (caseSensitiveCounter <= 0) {            caseSensitiveCounter = (caseSensitiveCounter - int.MinValue) + 1000000;            //^ assume caseSensitiveCounter > 0;          }          result = new Name(caseInsensitiveCounter' caseSensitiveCounter' name);          //^ assume result.Value == name;          this.caseSensitiveCounter = caseSensitiveCounter;          this.caseSensitiveTable.Add(name' result);          return result;        }
Magic Number,Microsoft.Cci,NameTable,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Core.cs,GetNameFor,The following statement contains a magic number: lock (this.caseInsensitiveTable) {          IName/*?*/ result;          if (this.caseSensitiveTable.TryGetValue(name' out result)) {            //^ assume result != null; //Follows from the way Dictionary is instantiated' but the verifier is ignorant of this.            //^ assume result.Value == name; //Only this routine ever adds entries to the table and it only ever adds entries for which this is true. TODO: it would be nice to be able express this as an invariant.            return result;          }          //string lowerCaseName = name.ToLower(CultureInfo.InvariantCulture); //REVIEW: is it safer to use ToUpperInvariant' or does it make no difference?          int caseInsensitiveCounter;          if (!this.caseInsensitiveTable.TryGetValue(name' out caseInsensitiveCounter)) {            caseInsensitiveCounter = this.caseInsensitiveCounter;            caseInsensitiveCounter += 17;            if (caseInsensitiveCounter <= 0) {              caseInsensitiveCounter = (caseInsensitiveCounter - int.MinValue) + 1000000;            }            this.caseInsensitiveCounter = caseInsensitiveCounter;            this.caseInsensitiveTable.Add(name' caseInsensitiveCounter);          }          //^ assume caseInsensitiveCounter > 0; //Follows from the invariant' but this is beyond the verifier right now.          int caseSensitiveCounter = this.caseSensitiveCounter;          caseSensitiveCounter += 17;          if (caseSensitiveCounter <= 0) {            caseSensitiveCounter = (caseSensitiveCounter - int.MinValue) + 1000000;            //^ assume caseSensitiveCounter > 0;          }          result = new Name(caseInsensitiveCounter' caseSensitiveCounter' name);          //^ assume result.Value == name;          this.caseSensitiveCounter = caseSensitiveCounter;          this.caseSensitiveTable.Add(name' result);          return result;        }
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The following statement contains a magic number: foreach (ITypeDefinitionMember member in members) {          INestedTypeDefinition fieldAsTypeDef = member as INestedTypeDefinition;          if (fieldAsTypeDef != null && fieldAsTypeDef == item) {            ushort typeAlignment = (ushort)(TypeHelper.TypeAlignment(fieldAsTypeDef.ResolvedType) * 8);            return (((result + typeAlignment - 1) / typeAlignment) * typeAlignment) / 8;          } else {            IFieldDefinition/*?*/ f = member as IFieldDefinition;            if (f == null || f.IsStatic) continue;            if (f.Type.ResolvedType == item) continue; // in case we are calculating the offset of an anonymous type' skip the implicit field of that type            ushort fieldAlignment = (ushort)(TypeHelper.TypeAlignment(f.Type.ResolvedType) * 8);            if (f == item) {              if (f.IsBitField && bitOffset > 0 && bitOffset + f.BitLength <= bitFieldAlignment) return (result - bitOffset) / 8;              if (bitFieldAlignment > fieldAlignment) fieldAlignment = bitFieldAlignment;              return (((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment) / 8;            }            uint fieldSize;            if (f.IsBitField) {              bitFieldAlignment = fieldAlignment;              fieldSize = f.BitLength;              if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)                bitOffset = 0;              if (bitOffset == 0 || fieldSize == 0) {                result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;                bitOffset = 0;              }              bitOffset += fieldSize;            } else {              if (bitFieldAlignment > fieldAlignment) fieldAlignment = bitFieldAlignment;              bitFieldAlignment = 0; bitOffset = 0;              result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;              fieldSize = TypeHelper.SizeOfType(f.Type.ResolvedType) * 8;            }            result += fieldSize;          }        }
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The following statement contains a magic number: foreach (ITypeDefinitionMember member in members) {          INestedTypeDefinition fieldAsTypeDef = member as INestedTypeDefinition;          if (fieldAsTypeDef != null && fieldAsTypeDef == item) {            ushort typeAlignment = (ushort)(TypeHelper.TypeAlignment(fieldAsTypeDef.ResolvedType) * 8);            return (((result + typeAlignment - 1) / typeAlignment) * typeAlignment) / 8;          } else {            IFieldDefinition/*?*/ f = member as IFieldDefinition;            if (f == null || f.IsStatic) continue;            if (f.Type.ResolvedType == item) continue; // in case we are calculating the offset of an anonymous type' skip the implicit field of that type            ushort fieldAlignment = (ushort)(TypeHelper.TypeAlignment(f.Type.ResolvedType) * 8);            if (f == item) {              if (f.IsBitField && bitOffset > 0 && bitOffset + f.BitLength <= bitFieldAlignment) return (result - bitOffset) / 8;              if (bitFieldAlignment > fieldAlignment) fieldAlignment = bitFieldAlignment;              return (((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment) / 8;            }            uint fieldSize;            if (f.IsBitField) {              bitFieldAlignment = fieldAlignment;              fieldSize = f.BitLength;              if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)                bitOffset = 0;              if (bitOffset == 0 || fieldSize == 0) {                result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;                bitOffset = 0;              }              bitOffset += fieldSize;            } else {              if (bitFieldAlignment > fieldAlignment) fieldAlignment = bitFieldAlignment;              bitFieldAlignment = 0; bitOffset = 0;              result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;              fieldSize = TypeHelper.SizeOfType(f.Type.ResolvedType) * 8;            }            result += fieldSize;          }        }
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The following statement contains a magic number: foreach (ITypeDefinitionMember member in members) {          INestedTypeDefinition fieldAsTypeDef = member as INestedTypeDefinition;          if (fieldAsTypeDef != null && fieldAsTypeDef == item) {            ushort typeAlignment = (ushort)(TypeHelper.TypeAlignment(fieldAsTypeDef.ResolvedType) * 8);            return (((result + typeAlignment - 1) / typeAlignment) * typeAlignment) / 8;          } else {            IFieldDefinition/*?*/ f = member as IFieldDefinition;            if (f == null || f.IsStatic) continue;            if (f.Type.ResolvedType == item) continue; // in case we are calculating the offset of an anonymous type' skip the implicit field of that type            ushort fieldAlignment = (ushort)(TypeHelper.TypeAlignment(f.Type.ResolvedType) * 8);            if (f == item) {              if (f.IsBitField && bitOffset > 0 && bitOffset + f.BitLength <= bitFieldAlignment) return (result - bitOffset) / 8;              if (bitFieldAlignment > fieldAlignment) fieldAlignment = bitFieldAlignment;              return (((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment) / 8;            }            uint fieldSize;            if (f.IsBitField) {              bitFieldAlignment = fieldAlignment;              fieldSize = f.BitLength;              if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)                bitOffset = 0;              if (bitOffset == 0 || fieldSize == 0) {                result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;                bitOffset = 0;              }              bitOffset += fieldSize;            } else {              if (bitFieldAlignment > fieldAlignment) fieldAlignment = bitFieldAlignment;              bitFieldAlignment = 0; bitOffset = 0;              result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;              fieldSize = TypeHelper.SizeOfType(f.Type.ResolvedType) * 8;            }            result += fieldSize;          }        }
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The following statement contains a magic number: foreach (ITypeDefinitionMember member in members) {          INestedTypeDefinition fieldAsTypeDef = member as INestedTypeDefinition;          if (fieldAsTypeDef != null && fieldAsTypeDef == item) {            ushort typeAlignment = (ushort)(TypeHelper.TypeAlignment(fieldAsTypeDef.ResolvedType) * 8);            return (((result + typeAlignment - 1) / typeAlignment) * typeAlignment) / 8;          } else {            IFieldDefinition/*?*/ f = member as IFieldDefinition;            if (f == null || f.IsStatic) continue;            if (f.Type.ResolvedType == item) continue; // in case we are calculating the offset of an anonymous type' skip the implicit field of that type            ushort fieldAlignment = (ushort)(TypeHelper.TypeAlignment(f.Type.ResolvedType) * 8);            if (f == item) {              if (f.IsBitField && bitOffset > 0 && bitOffset + f.BitLength <= bitFieldAlignment) return (result - bitOffset) / 8;              if (bitFieldAlignment > fieldAlignment) fieldAlignment = bitFieldAlignment;              return (((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment) / 8;            }            uint fieldSize;            if (f.IsBitField) {              bitFieldAlignment = fieldAlignment;              fieldSize = f.BitLength;              if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)                bitOffset = 0;              if (bitOffset == 0 || fieldSize == 0) {                result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;                bitOffset = 0;              }              bitOffset += fieldSize;            } else {              if (bitFieldAlignment > fieldAlignment) fieldAlignment = bitFieldAlignment;              bitFieldAlignment = 0; bitOffset = 0;              result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;              fieldSize = TypeHelper.SizeOfType(f.Type.ResolvedType) * 8;            }            result += fieldSize;          }        }
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The following statement contains a magic number: foreach (ITypeDefinitionMember member in members) {          INestedTypeDefinition fieldAsTypeDef = member as INestedTypeDefinition;          if (fieldAsTypeDef != null && fieldAsTypeDef == item) {            ushort typeAlignment = (ushort)(TypeHelper.TypeAlignment(fieldAsTypeDef.ResolvedType) * 8);            return (((result + typeAlignment - 1) / typeAlignment) * typeAlignment) / 8;          } else {            IFieldDefinition/*?*/ f = member as IFieldDefinition;            if (f == null || f.IsStatic) continue;            if (f.Type.ResolvedType == item) continue; // in case we are calculating the offset of an anonymous type' skip the implicit field of that type            ushort fieldAlignment = (ushort)(TypeHelper.TypeAlignment(f.Type.ResolvedType) * 8);            if (f == item) {              if (f.IsBitField && bitOffset > 0 && bitOffset + f.BitLength <= bitFieldAlignment) return (result - bitOffset) / 8;              if (bitFieldAlignment > fieldAlignment) fieldAlignment = bitFieldAlignment;              return (((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment) / 8;            }            uint fieldSize;            if (f.IsBitField) {              bitFieldAlignment = fieldAlignment;              fieldSize = f.BitLength;              if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)                bitOffset = 0;              if (bitOffset == 0 || fieldSize == 0) {                result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;                bitOffset = 0;              }              bitOffset += fieldSize;            } else {              if (bitFieldAlignment > fieldAlignment) fieldAlignment = bitFieldAlignment;              bitFieldAlignment = 0; bitOffset = 0;              result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;              fieldSize = TypeHelper.SizeOfType(f.Type.ResolvedType) * 8;            }            result += fieldSize;          }        }
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The following statement contains a magic number: foreach (ITypeDefinitionMember member in members) {          INestedTypeDefinition fieldAsTypeDef = member as INestedTypeDefinition;          if (fieldAsTypeDef != null && fieldAsTypeDef == item) {            ushort typeAlignment = (ushort)(TypeHelper.TypeAlignment(fieldAsTypeDef.ResolvedType) * 8);            return (((result + typeAlignment - 1) / typeAlignment) * typeAlignment) / 8;          } else {            IFieldDefinition/*?*/ f = member as IFieldDefinition;            if (f == null || f.IsStatic) continue;            if (f.Type.ResolvedType == item) continue; // in case we are calculating the offset of an anonymous type' skip the implicit field of that type            ushort fieldAlignment = (ushort)(TypeHelper.TypeAlignment(f.Type.ResolvedType) * 8);            if (f == item) {              if (f.IsBitField && bitOffset > 0 && bitOffset + f.BitLength <= bitFieldAlignment) return (result - bitOffset) / 8;              if (bitFieldAlignment > fieldAlignment) fieldAlignment = bitFieldAlignment;              return (((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment) / 8;            }            uint fieldSize;            if (f.IsBitField) {              bitFieldAlignment = fieldAlignment;              fieldSize = f.BitLength;              if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)                bitOffset = 0;              if (bitOffset == 0 || fieldSize == 0) {                result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;                bitOffset = 0;              }              bitOffset += fieldSize;            } else {              if (bitFieldAlignment > fieldAlignment) fieldAlignment = bitFieldAlignment;              bitFieldAlignment = 0; bitOffset = 0;              result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;              fieldSize = TypeHelper.SizeOfType(f.Type.ResolvedType) * 8;            }            result += fieldSize;          }        }
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetFieldBitOffset,The following statement contains a magic number: foreach (ITypeDefinitionMember member in members) {          IFieldDefinition/*?*/ f = member as IFieldDefinition;          if (f == null || f.IsStatic) continue;          ushort fieldAlignment = (ushort)(TypeHelper.TypeAlignment(f.Type.ResolvedType)*8);          if (f == field) {            if (f.IsBitField) {              if (bitOffset > 0 && bitOffset+f.BitLength > bitFieldAlignment)                bitOffset = 0;              return bitOffset;            }            return 0;          }          uint fieldSize;          if (f.IsBitField) {            bitFieldAlignment = fieldAlignment;            fieldSize = f.BitLength;            if (bitOffset > 0 && bitOffset+fieldSize > fieldAlignment)              bitOffset = 0;            if (bitOffset == 0 || fieldSize == 0) {              result = ((result+fieldAlignment-1)/fieldAlignment) * fieldAlignment;              bitOffset = 0;            }            bitOffset += fieldSize;          } else {            if (bitFieldAlignment > fieldAlignment) fieldAlignment = bitFieldAlignment;            bitFieldAlignment = 0; bitOffset = 0;            result = ((result+fieldAlignment-1)/fieldAlignment) * fieldAlignment;            fieldSize = TypeHelper.SizeOfType(f.Type.ResolvedType)*8;          }          result += fieldSize;        }
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetFieldBitOffset,The following statement contains a magic number: foreach (ITypeDefinitionMember member in members) {          IFieldDefinition/*?*/ f = member as IFieldDefinition;          if (f == null || f.IsStatic) continue;          ushort fieldAlignment = (ushort)(TypeHelper.TypeAlignment(f.Type.ResolvedType)*8);          if (f == field) {            if (f.IsBitField) {              if (bitOffset > 0 && bitOffset+f.BitLength > bitFieldAlignment)                bitOffset = 0;              return bitOffset;            }            return 0;          }          uint fieldSize;          if (f.IsBitField) {            bitFieldAlignment = fieldAlignment;            fieldSize = f.BitLength;            if (bitOffset > 0 && bitOffset+fieldSize > fieldAlignment)              bitOffset = 0;            if (bitOffset == 0 || fieldSize == 0) {              result = ((result+fieldAlignment-1)/fieldAlignment) * fieldAlignment;              bitOffset = 0;            }            bitOffset += fieldSize;          } else {            if (bitFieldAlignment > fieldAlignment) fieldAlignment = bitFieldAlignment;            bitFieldAlignment = 0; bitOffset = 0;            result = ((result+fieldAlignment-1)/fieldAlignment) * fieldAlignment;            fieldSize = TypeHelper.SizeOfType(f.Type.ResolvedType)*8;          }          result += fieldSize;        }
Magic Number,Microsoft.Cci,SignatureFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendMethodName,The following statement contains a magic number: if (method.ResolvedMethod.IsSpecialName && (formattingOptions & NameFormattingOptions.PreserveSpecialNames) == 0) {          if (methodName.StartsWith("get_"' StringComparison.Ordinal)) {            //^ assume methodName.Length >= 4;            sb.Append(methodName.Substring(4));            sb.Append(".get");          } else if (methodName.StartsWith("set_"' StringComparison.Ordinal)) {            //^ assume methodName.Length >= 4;            sb.Append(methodName.Substring(4));            sb.Append(".set");          } else {            sb.Append(methodName);          }        } else          sb.Append(methodName);
Magic Number,Microsoft.Cci,SignatureFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendMethodName,The following statement contains a magic number: if (method.ResolvedMethod.IsSpecialName && (formattingOptions & NameFormattingOptions.PreserveSpecialNames) == 0) {          if (methodName.StartsWith("get_"' StringComparison.Ordinal)) {            //^ assume methodName.Length >= 4;            sb.Append(methodName.Substring(4));            sb.Append(".get");          } else if (methodName.StartsWith("set_"' StringComparison.Ordinal)) {            //^ assume methodName.Length >= 4;            sb.Append(methodName.Substring(4));            sb.Append(".set");          } else {            sb.Append(methodName);          }        } else          sb.Append(methodName);
Magic Number,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SizeOfType,The following statement contains a magic number: switch (type.TypeCode) {          case PrimitiveTypeCode.Boolean:            return sizeof(Boolean);          case PrimitiveTypeCode.Char:            return sizeof(Char);          case PrimitiveTypeCode.Int16:            return sizeof(Int16);          case PrimitiveTypeCode.Int32:            return sizeof(Int32);          case PrimitiveTypeCode.Int8:            return sizeof(SByte);          case PrimitiveTypeCode.UInt16:            return sizeof(UInt16);          case PrimitiveTypeCode.UInt32:            return sizeof(UInt32);          case PrimitiveTypeCode.UInt8:            return sizeof(Byte);          case PrimitiveTypeCode.Int64:            return sizeof(Int64);          case PrimitiveTypeCode.UInt64:            return sizeof(UInt64);          case PrimitiveTypeCode.IntPtr:            return type.PlatformType.PointerSize;          case PrimitiveTypeCode.UIntPtr:            return type.PlatformType.PointerSize;          case PrimitiveTypeCode.Float32:            return sizeof(Single);          case PrimitiveTypeCode.Float64:            return sizeof(Double);          case PrimitiveTypeCode.Pointer:            return type.PlatformType.PointerSize;          case PrimitiveTypeCode.Invalid:            return 1;          default:            if (type.IsEnum && type.ResolvedType.IsEnum) {              if (TypeHelper.TypesAreEquivalent(rootType' type.ResolvedType.UnderlyingType' true)) return 0;              return TypeHelper.SizeOfType(type.ResolvedType.UnderlyingType);            }            uint result = mayUseSizeOfProperty ? type.ResolvedType.SizeOf : 0;            if (result > 0) return result;            IEnumerable<ITypeDefinitionMember> members = type.ResolvedType.Members;            if (type.ResolvedType.Layout == LayoutKind.Sequential) {              List<IFieldDefinition> fields = new List<IFieldDefinition>(IteratorHelper.GetFilterEnumerable<ITypeDefinitionMember' IFieldDefinition>(members));              fields.Sort(delegate(IFieldDefinition f1' IFieldDefinition f2) { return f1.SequenceNumber - f2.SequenceNumber; });              members = IteratorHelper.GetConversionEnumerable<IFieldDefinition' ITypeDefinitionMember>(fields);              Contract.Assume(members != null);            }            //Sum up the bit sizes            result = 0;            uint bitOffset = 0;            ushort bitFieldAlignment = 0;            Contract.Assume(members != null);            foreach (ITypeDefinitionMember member in members) {              IFieldDefinition/*?*/ field = member as IFieldDefinition;              if (field == null || field.IsStatic) continue;              ITypeDefinition fieldType = field.Type.ResolvedType;              ushort fieldAlignment;              if (rootType == fieldType || fieldType.IsReferenceType)                fieldAlignment = type.PlatformType.PointerSize;              else                fieldAlignment = (ushort)(TypeHelper.TypeAlignment(fieldType)*8);              uint fieldSize;              if (field.IsBitField) {                bitFieldAlignment = fieldAlignment;                fieldSize = field.BitLength;                if (bitOffset > 0 && bitOffset+fieldSize > fieldAlignment)                  bitOffset = 0;                if (bitOffset == 0 || fieldSize == 0) {                  result = ((result+fieldAlignment-1)/fieldAlignment) * fieldAlignment;                  bitOffset = 0;                }                bitOffset += fieldSize;              } else {                if (bitFieldAlignment > fieldAlignment) fieldAlignment = bitFieldAlignment;                bitFieldAlignment = 0; bitOffset = 0;                result = ((result+fieldAlignment-1)/fieldAlignment) * fieldAlignment;                if (rootType == fieldType || fieldType.IsReferenceType)                  fieldSize = type.PlatformType.PointerSize*8u;                else                  fieldSize = TypeHelper.SizeOfType(fieldType' rootType' mayUseSizeOfProperty: true)*8;              }              result += fieldSize;            }            //Convert bit size to bytes and pad to be a multiple of the type alignment.            result = (result+7)/8;            uint typeAlignment = TypeHelper.TypeAlignment(type);            return ((result+typeAlignment-1)/typeAlignment) * typeAlignment;        }
Magic Number,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SizeOfType,The following statement contains a magic number: switch (type.TypeCode) {          case PrimitiveTypeCode.Boolean:            return sizeof(Boolean);          case PrimitiveTypeCode.Char:            return sizeof(Char);          case PrimitiveTypeCode.Int16:            return sizeof(Int16);          case PrimitiveTypeCode.Int32:            return sizeof(Int32);          case PrimitiveTypeCode.Int8:            return sizeof(SByte);          case PrimitiveTypeCode.UInt16:            return sizeof(UInt16);          case PrimitiveTypeCode.UInt32:            return sizeof(UInt32);          case PrimitiveTypeCode.UInt8:            return sizeof(Byte);          case PrimitiveTypeCode.Int64:            return sizeof(Int64);          case PrimitiveTypeCode.UInt64:            return sizeof(UInt64);          case PrimitiveTypeCode.IntPtr:            return type.PlatformType.PointerSize;          case PrimitiveTypeCode.UIntPtr:            return type.PlatformType.PointerSize;          case PrimitiveTypeCode.Float32:            return sizeof(Single);          case PrimitiveTypeCode.Float64:            return sizeof(Double);          case PrimitiveTypeCode.Pointer:            return type.PlatformType.PointerSize;          case PrimitiveTypeCode.Invalid:            return 1;          default:            if (type.IsEnum && type.ResolvedType.IsEnum) {              if (TypeHelper.TypesAreEquivalent(rootType' type.ResolvedType.UnderlyingType' true)) return 0;              return TypeHelper.SizeOfType(type.ResolvedType.UnderlyingType);            }            uint result = mayUseSizeOfProperty ? type.ResolvedType.SizeOf : 0;            if (result > 0) return result;            IEnumerable<ITypeDefinitionMember> members = type.ResolvedType.Members;            if (type.ResolvedType.Layout == LayoutKind.Sequential) {              List<IFieldDefinition> fields = new List<IFieldDefinition>(IteratorHelper.GetFilterEnumerable<ITypeDefinitionMember' IFieldDefinition>(members));              fields.Sort(delegate(IFieldDefinition f1' IFieldDefinition f2) { return f1.SequenceNumber - f2.SequenceNumber; });              members = IteratorHelper.GetConversionEnumerable<IFieldDefinition' ITypeDefinitionMember>(fields);              Contract.Assume(members != null);            }            //Sum up the bit sizes            result = 0;            uint bitOffset = 0;            ushort bitFieldAlignment = 0;            Contract.Assume(members != null);            foreach (ITypeDefinitionMember member in members) {              IFieldDefinition/*?*/ field = member as IFieldDefinition;              if (field == null || field.IsStatic) continue;              ITypeDefinition fieldType = field.Type.ResolvedType;              ushort fieldAlignment;              if (rootType == fieldType || fieldType.IsReferenceType)                fieldAlignment = type.PlatformType.PointerSize;              else                fieldAlignment = (ushort)(TypeHelper.TypeAlignment(fieldType)*8);              uint fieldSize;              if (field.IsBitField) {                bitFieldAlignment = fieldAlignment;                fieldSize = field.BitLength;                if (bitOffset > 0 && bitOffset+fieldSize > fieldAlignment)                  bitOffset = 0;                if (bitOffset == 0 || fieldSize == 0) {                  result = ((result+fieldAlignment-1)/fieldAlignment) * fieldAlignment;                  bitOffset = 0;                }                bitOffset += fieldSize;              } else {                if (bitFieldAlignment > fieldAlignment) fieldAlignment = bitFieldAlignment;                bitFieldAlignment = 0; bitOffset = 0;                result = ((result+fieldAlignment-1)/fieldAlignment) * fieldAlignment;                if (rootType == fieldType || fieldType.IsReferenceType)                  fieldSize = type.PlatformType.PointerSize*8u;                else                  fieldSize = TypeHelper.SizeOfType(fieldType' rootType' mayUseSizeOfProperty: true)*8;              }              result += fieldSize;            }            //Convert bit size to bytes and pad to be a multiple of the type alignment.            result = (result+7)/8;            uint typeAlignment = TypeHelper.TypeAlignment(type);            return ((result+typeAlignment-1)/typeAlignment) * typeAlignment;        }
Magic Number,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SizeOfType,The following statement contains a magic number: switch (type.TypeCode) {          case PrimitiveTypeCode.Boolean:            return sizeof(Boolean);          case PrimitiveTypeCode.Char:            return sizeof(Char);          case PrimitiveTypeCode.Int16:            return sizeof(Int16);          case PrimitiveTypeCode.Int32:            return sizeof(Int32);          case PrimitiveTypeCode.Int8:            return sizeof(SByte);          case PrimitiveTypeCode.UInt16:            return sizeof(UInt16);          case PrimitiveTypeCode.UInt32:            return sizeof(UInt32);          case PrimitiveTypeCode.UInt8:            return sizeof(Byte);          case PrimitiveTypeCode.Int64:            return sizeof(Int64);          case PrimitiveTypeCode.UInt64:            return sizeof(UInt64);          case PrimitiveTypeCode.IntPtr:            return type.PlatformType.PointerSize;          case PrimitiveTypeCode.UIntPtr:            return type.PlatformType.PointerSize;          case PrimitiveTypeCode.Float32:            return sizeof(Single);          case PrimitiveTypeCode.Float64:            return sizeof(Double);          case PrimitiveTypeCode.Pointer:            return type.PlatformType.PointerSize;          case PrimitiveTypeCode.Invalid:            return 1;          default:            if (type.IsEnum && type.ResolvedType.IsEnum) {              if (TypeHelper.TypesAreEquivalent(rootType' type.ResolvedType.UnderlyingType' true)) return 0;              return TypeHelper.SizeOfType(type.ResolvedType.UnderlyingType);            }            uint result = mayUseSizeOfProperty ? type.ResolvedType.SizeOf : 0;            if (result > 0) return result;            IEnumerable<ITypeDefinitionMember> members = type.ResolvedType.Members;            if (type.ResolvedType.Layout == LayoutKind.Sequential) {              List<IFieldDefinition> fields = new List<IFieldDefinition>(IteratorHelper.GetFilterEnumerable<ITypeDefinitionMember' IFieldDefinition>(members));              fields.Sort(delegate(IFieldDefinition f1' IFieldDefinition f2) { return f1.SequenceNumber - f2.SequenceNumber; });              members = IteratorHelper.GetConversionEnumerable<IFieldDefinition' ITypeDefinitionMember>(fields);              Contract.Assume(members != null);            }            //Sum up the bit sizes            result = 0;            uint bitOffset = 0;            ushort bitFieldAlignment = 0;            Contract.Assume(members != null);            foreach (ITypeDefinitionMember member in members) {              IFieldDefinition/*?*/ field = member as IFieldDefinition;              if (field == null || field.IsStatic) continue;              ITypeDefinition fieldType = field.Type.ResolvedType;              ushort fieldAlignment;              if (rootType == fieldType || fieldType.IsReferenceType)                fieldAlignment = type.PlatformType.PointerSize;              else                fieldAlignment = (ushort)(TypeHelper.TypeAlignment(fieldType)*8);              uint fieldSize;              if (field.IsBitField) {                bitFieldAlignment = fieldAlignment;                fieldSize = field.BitLength;                if (bitOffset > 0 && bitOffset+fieldSize > fieldAlignment)                  bitOffset = 0;                if (bitOffset == 0 || fieldSize == 0) {                  result = ((result+fieldAlignment-1)/fieldAlignment) * fieldAlignment;                  bitOffset = 0;                }                bitOffset += fieldSize;              } else {                if (bitFieldAlignment > fieldAlignment) fieldAlignment = bitFieldAlignment;                bitFieldAlignment = 0; bitOffset = 0;                result = ((result+fieldAlignment-1)/fieldAlignment) * fieldAlignment;                if (rootType == fieldType || fieldType.IsReferenceType)                  fieldSize = type.PlatformType.PointerSize*8u;                else                  fieldSize = TypeHelper.SizeOfType(fieldType' rootType' mayUseSizeOfProperty: true)*8;              }              result += fieldSize;            }            //Convert bit size to bytes and pad to be a multiple of the type alignment.            result = (result+7)/8;            uint typeAlignment = TypeHelper.TypeAlignment(type);            return ((result+typeAlignment-1)/typeAlignment) * typeAlignment;        }
Magic Number,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SizeOfType,The following statement contains a magic number: switch (type.TypeCode) {          case PrimitiveTypeCode.Boolean:            return sizeof(Boolean);          case PrimitiveTypeCode.Char:            return sizeof(Char);          case PrimitiveTypeCode.Int16:            return sizeof(Int16);          case PrimitiveTypeCode.Int32:            return sizeof(Int32);          case PrimitiveTypeCode.Int8:            return sizeof(SByte);          case PrimitiveTypeCode.UInt16:            return sizeof(UInt16);          case PrimitiveTypeCode.UInt32:            return sizeof(UInt32);          case PrimitiveTypeCode.UInt8:            return sizeof(Byte);          case PrimitiveTypeCode.Int64:            return sizeof(Int64);          case PrimitiveTypeCode.UInt64:            return sizeof(UInt64);          case PrimitiveTypeCode.IntPtr:            return type.PlatformType.PointerSize;          case PrimitiveTypeCode.UIntPtr:            return type.PlatformType.PointerSize;          case PrimitiveTypeCode.Float32:            return sizeof(Single);          case PrimitiveTypeCode.Float64:            return sizeof(Double);          case PrimitiveTypeCode.Pointer:            return type.PlatformType.PointerSize;          case PrimitiveTypeCode.Invalid:            return 1;          default:            if (type.IsEnum && type.ResolvedType.IsEnum) {              if (TypeHelper.TypesAreEquivalent(rootType' type.ResolvedType.UnderlyingType' true)) return 0;              return TypeHelper.SizeOfType(type.ResolvedType.UnderlyingType);            }            uint result = mayUseSizeOfProperty ? type.ResolvedType.SizeOf : 0;            if (result > 0) return result;            IEnumerable<ITypeDefinitionMember> members = type.ResolvedType.Members;            if (type.ResolvedType.Layout == LayoutKind.Sequential) {              List<IFieldDefinition> fields = new List<IFieldDefinition>(IteratorHelper.GetFilterEnumerable<ITypeDefinitionMember' IFieldDefinition>(members));              fields.Sort(delegate(IFieldDefinition f1' IFieldDefinition f2) { return f1.SequenceNumber - f2.SequenceNumber; });              members = IteratorHelper.GetConversionEnumerable<IFieldDefinition' ITypeDefinitionMember>(fields);              Contract.Assume(members != null);            }            //Sum up the bit sizes            result = 0;            uint bitOffset = 0;            ushort bitFieldAlignment = 0;            Contract.Assume(members != null);            foreach (ITypeDefinitionMember member in members) {              IFieldDefinition/*?*/ field = member as IFieldDefinition;              if (field == null || field.IsStatic) continue;              ITypeDefinition fieldType = field.Type.ResolvedType;              ushort fieldAlignment;              if (rootType == fieldType || fieldType.IsReferenceType)                fieldAlignment = type.PlatformType.PointerSize;              else                fieldAlignment = (ushort)(TypeHelper.TypeAlignment(fieldType)*8);              uint fieldSize;              if (field.IsBitField) {                bitFieldAlignment = fieldAlignment;                fieldSize = field.BitLength;                if (bitOffset > 0 && bitOffset+fieldSize > fieldAlignment)                  bitOffset = 0;                if (bitOffset == 0 || fieldSize == 0) {                  result = ((result+fieldAlignment-1)/fieldAlignment) * fieldAlignment;                  bitOffset = 0;                }                bitOffset += fieldSize;              } else {                if (bitFieldAlignment > fieldAlignment) fieldAlignment = bitFieldAlignment;                bitFieldAlignment = 0; bitOffset = 0;                result = ((result+fieldAlignment-1)/fieldAlignment) * fieldAlignment;                if (rootType == fieldType || fieldType.IsReferenceType)                  fieldSize = type.PlatformType.PointerSize*8u;                else                  fieldSize = TypeHelper.SizeOfType(fieldType' rootType' mayUseSizeOfProperty: true)*8;              }              result += fieldSize;            }            //Convert bit size to bytes and pad to be a multiple of the type alignment.            result = (result+7)/8;            uint typeAlignment = TypeHelper.TypeAlignment(type);            return ((result+typeAlignment-1)/typeAlignment) * typeAlignment;        }
Magic Number,Microsoft.Cci,TypeNameFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetNamespaceTypeName,The following statement contains a magic number: if ((formattingOptions & NameFormattingOptions.SupressAttributeSuffix) != 0 &&        AttributeHelper.IsAttributeType(nsType.ResolvedType) & tname.EndsWith("Attribute"))          tname = tname.Substring(0' tname.Length-9);
Magic Number,Microsoft.Cci,TypeNameFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetNestedTypeName,The following statement contains a magic number: if ((formattingOptions & NameFormattingOptions.SupressAttributeSuffix) != 0 &&        AttributeHelper.IsAttributeType(nestedType.ResolvedType) & tname.EndsWith("Attribute"))          tname = tname.Substring(0' tname.Length-9);
Magic Number,Microsoft.Cci,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,ComputePublicKeyToken,The following statement contains a magic number: byte[] publicKeyToken = new byte[8];
Magic Number,Microsoft.Cci,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,ComputePublicKeyToken,The following statement contains a magic number: int startIndex = hash.Length - 8;
Magic Number,Microsoft.Cci,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,ComputePublicKeyToken,The following statement contains a magic number: Contract.Assert(startIndex + 8 <= hash.GetLowerBound(0) + hash.Length);
Magic Number,Microsoft.Cci,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,ComputePublicKeyToken,The following statement contains a magic number: Array.Copy(hash' startIndex' publicKeyToken' 0' 8);
Magic Number,Microsoft.Cci,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,ComputePublicKeyToken,The following statement contains a magic number: Array.Reverse(publicKeyToken' 0' 8);
Magic Number,Microsoft.Cci,UnmanagedBinaryMemoryBlock,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnmanagedFileIO.cs,CreateUnmanagedBinaryMemoryBlock,The following statement contains a magic number: int copyBufferLength = 8096;
Magic Number,Microsoft.Cci.Immutable,ArrayType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,GetInterfaceList,The following statement contains a magic number: var version = coreAssembly == null ? new Version(4' 0) : coreAssembly.AssemblyIdentity.Version;
Magic Number,Microsoft.Cci.Immutable,ArrayType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,GetInterfaceList,The following statement contains a magic number: List<ITypeReference> interfaces = new List<ITypeReference>(6);
Magic Number,Microsoft.Cci.Immutable,ArrayType,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,GetInterfaceList,The following statement contains a magic number: if (version.Major >= 2) {          interfaces.Add(this.PlatformType.SystemCollectionsIStructuralComparable);          interfaces.Add(this.PlatformType.SystemCollectionsIStructuralEquatable);        }
Magic Number,Microsoft.Cci.Immutable,Vector,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,GetInterfaceList,The following statement contains a magic number: var version = coreAssembly == null ? new Version(4' 0) : coreAssembly.AssemblyIdentity.Version;
Magic Number,Microsoft.Cci.Immutable,Vector,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,GetInterfaceList,The following statement contains a magic number: List<ITypeReference> interfaces = new List<ITypeReference>(9);
Magic Number,Microsoft.Cci.Immutable,Vector,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,GetInterfaceList,The following statement contains a magic number: if (version.Major >= 4) {          interfaces.Add(this.PlatformType.SystemCollectionsIStructuralComparable);          interfaces.Add(this.PlatformType.SystemCollectionsIStructuralEquatable);        }
Magic Number,Microsoft.Cci.Immutable,Vector,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Types.cs,GetInterfaceList,The following statement contains a magic number: if (version.Major >= 2) {          var argTypes = IteratorHelper.GetSingletonEnumerable<ITypeReference>(this.ElementType);          interfaces.Add(GenericTypeInstance.GetGenericTypeInstance(this.PlatformType.SystemCollectionsGenericIList' argTypes' this.InternFactory));          interfaces.Add(GenericTypeInstance.GetGenericTypeInstance(this.PlatformType.SystemCollectionsGenericICollection' argTypes' this.InternFactory));          interfaces.Add(GenericTypeInstance.GetGenericTypeInstance(this.PlatformType.SystemCollectionsGenericIEnumerable' argTypes' this.InternFactory));        }
Magic Number,Microsoft.Cci.Immutable,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,ComputePublicKeyToken,The following statement contains a magic number: byte[] publicKeyToken = new byte[8];
Magic Number,Microsoft.Cci.Immutable,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,ComputePublicKeyToken,The following statement contains a magic number: int startIndex = hash.Length - 8;
Magic Number,Microsoft.Cci.Immutable,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,ComputePublicKeyToken,The following statement contains a magic number: Contract.Assert(startIndex + 8 <= hash.GetLowerBound(0) + hash.Length);
Magic Number,Microsoft.Cci.Immutable,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,ComputePublicKeyToken,The following statement contains a magic number: Array.Copy(hash' startIndex' publicKeyToken' 0' 8);
Magic Number,Microsoft.Cci.Immutable,UnitHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UnitHelper.cs,ComputePublicKeyToken,The following statement contains a magic number: Array.Reverse(publicKeyToken' 0' 8);
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: unchecked {          uint a = 0x9e3779b9 + key;          uint b = 0x9e3779b9;          uint c = 16777619;          a -= b; a -= c; a ^= (c >> 13);          b -= c; b -= a; b ^= (a << 8);          c -= a; c -= b; c ^= (b >> 13);          a -= b; a -= c; a ^= (c >> 12);          b -= c; b -= a; b ^= (a << 16);          c -= a; c -= b; c ^= (b >> 5);          a -= b; a -= c; a ^= (c >> 3);          b -= c; b -= a; b ^= (a << 10);          c -= a; c -= b; c ^= (b >> 15);          return c;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: unchecked {          uint a = 0x9e3779b9 + key;          uint b = 0x9e3779b9;          uint c = 16777619;          a -= b; a -= c; a ^= (c >> 13);          b -= c; b -= a; b ^= (a << 8);          c -= a; c -= b; c ^= (b >> 13);          a -= b; a -= c; a ^= (c >> 12);          b -= c; b -= a; b ^= (a << 16);          c -= a; c -= b; c ^= (b >> 5);          a -= b; a -= c; a ^= (c >> 3);          b -= c; b -= a; b ^= (a << 10);          c -= a; c -= b; c ^= (b >> 15);          return c;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: unchecked {          uint a = 0x9e3779b9 + key;          uint b = 0x9e3779b9;          uint c = 16777619;          a -= b; a -= c; a ^= (c >> 13);          b -= c; b -= a; b ^= (a << 8);          c -= a; c -= b; c ^= (b >> 13);          a -= b; a -= c; a ^= (c >> 12);          b -= c; b -= a; b ^= (a << 16);          c -= a; c -= b; c ^= (b >> 5);          a -= b; a -= c; a ^= (c >> 3);          b -= c; b -= a; b ^= (a << 10);          c -= a; c -= b; c ^= (b >> 15);          return c;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: unchecked {          uint a = 0x9e3779b9 + key;          uint b = 0x9e3779b9;          uint c = 16777619;          a -= b; a -= c; a ^= (c >> 13);          b -= c; b -= a; b ^= (a << 8);          c -= a; c -= b; c ^= (b >> 13);          a -= b; a -= c; a ^= (c >> 12);          b -= c; b -= a; b ^= (a << 16);          c -= a; c -= b; c ^= (b >> 5);          a -= b; a -= c; a ^= (c >> 3);          b -= c; b -= a; b ^= (a << 10);          c -= a; c -= b; c ^= (b >> 15);          return c;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: unchecked {          uint a = 0x9e3779b9 + key;          uint b = 0x9e3779b9;          uint c = 16777619;          a -= b; a -= c; a ^= (c >> 13);          b -= c; b -= a; b ^= (a << 8);          c -= a; c -= b; c ^= (b >> 13);          a -= b; a -= c; a ^= (c >> 12);          b -= c; b -= a; b ^= (a << 16);          c -= a; c -= b; c ^= (b >> 5);          a -= b; a -= c; a ^= (c >> 3);          b -= c; b -= a; b ^= (a << 10);          c -= a; c -= b; c ^= (b >> 15);          return c;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: unchecked {          uint a = 0x9e3779b9 + key;          uint b = 0x9e3779b9;          uint c = 16777619;          a -= b; a -= c; a ^= (c >> 13);          b -= c; b -= a; b ^= (a << 8);          c -= a; c -= b; c ^= (b >> 13);          a -= b; a -= c; a ^= (c >> 12);          b -= c; b -= a; b ^= (a << 16);          c -= a; c -= b; c ^= (b >> 5);          a -= b; a -= c; a ^= (c >> 3);          b -= c; b -= a; b ^= (a << 10);          c -= a; c -= b; c ^= (b >> 15);          return c;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: unchecked {          uint a = 0x9e3779b9 + key;          uint b = 0x9e3779b9;          uint c = 16777619;          a -= b; a -= c; a ^= (c >> 13);          b -= c; b -= a; b ^= (a << 8);          c -= a; c -= b; c ^= (b >> 13);          a -= b; a -= c; a ^= (c >> 12);          b -= c; b -= a; b ^= (a << 16);          c -= a; c -= b; c ^= (b >> 5);          a -= b; a -= c; a ^= (c >> 3);          b -= c; b -= a; b ^= (a << 10);          c -= a; c -= b; c ^= (b >> 15);          return c;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: unchecked {          uint a = 0x9e3779b9 + key;          uint b = 0x9e3779b9;          uint c = 16777619;          a -= b; a -= c; a ^= (c >> 13);          b -= c; b -= a; b ^= (a << 8);          c -= a; c -= b; c ^= (b >> 13);          a -= b; a -= c; a ^= (c >> 12);          b -= c; b -= a; b ^= (a << 16);          c -= a; c -= b; c ^= (b >> 5);          a -= b; a -= c; a ^= (c >> 3);          b -= c; b -= a; b ^= (a << 10);          c -= a; c -= b; c ^= (b >> 15);          return c;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: unchecked {          uint a = 0x9e3779b9 + key;          uint b = 0x9e3779b9;          uint c = 16777619;          a -= b; a -= c; a ^= (c >> 13);          b -= c; b -= a; b ^= (a << 8);          c -= a; c -= b; c ^= (b >> 13);          a -= b; a -= c; a ^= (c >> 12);          b -= c; b -= a; b ^= (a << 16);          c -= a; c -= b; c ^= (b >> 5);          a -= b; a -= c; a ^= (c >> 3);          b -= c; b -= a; b ^= (a << 10);          c -= a; c -= b; c ^= (b >> 15);          return c;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: unchecked {          uint a = 0x9e3779b9 + key;          uint b = 0x9e3779b9;          uint c = 16777619;          a -= b; a -= c; a ^= (c >> 13);          b -= c; b -= a; b ^= (a << 8);          c -= a; c -= b; c ^= (b >> 13);          a -= b; a -= c; a ^= (c >> 12);          b -= c; b -= a; b ^= (a << 16);          c -= a; c -= b; c ^= (b >> 5);          a -= b; a -= c; a ^= (c >> 3);          b -= c; b -= a; b ^= (a << 10);          c -= a; c -= b; c ^= (b >> 15);          return c;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt2,The following statement contains a magic number: unchecked {          uint hash = 0xB1635D64 + key;          hash += (hash << 3);          hash ^= (hash >> 11);          hash += (hash << 15);          hash |= 0x00000001; //  To make sure that this is relatively prime with power of 2          return hash;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt2,The following statement contains a magic number: unchecked {          uint hash = 0xB1635D64 + key;          hash += (hash << 3);          hash ^= (hash >> 11);          hash += (hash << 15);          hash |= 0x00000001; //  To make sure that this is relatively prime with power of 2          return hash;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt2,The following statement contains a magic number: unchecked {          uint hash = 0xB1635D64 + key;          hash += (hash << 3);          hash ^= (hash >> 11);          hash += (hash << 15);          hash |= 0x00000001; //  To make sure that this is relatively prime with power of 2          return hash;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: unchecked {          uint a = 0x9e3779b9 + key1;          uint b = 0x9e3779b9 + key2;          uint c = 16777619;          a -= b; a -= c; a ^= (c >> 13);          b -= c; b -= a; b ^= (a << 8);          c -= a; c -= b; c ^= (b >> 13);          a -= b; a -= c; a ^= (c >> 12);          b -= c; b -= a; b ^= (a << 16);          c -= a; c -= b; c ^= (b >> 5);          a -= b; a -= c; a ^= (c >> 3);          b -= c; b -= a; b ^= (a << 10);          c -= a; c -= b; c ^= (b >> 15);          return c;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: unchecked {          uint a = 0x9e3779b9 + key1;          uint b = 0x9e3779b9 + key2;          uint c = 16777619;          a -= b; a -= c; a ^= (c >> 13);          b -= c; b -= a; b ^= (a << 8);          c -= a; c -= b; c ^= (b >> 13);          a -= b; a -= c; a ^= (c >> 12);          b -= c; b -= a; b ^= (a << 16);          c -= a; c -= b; c ^= (b >> 5);          a -= b; a -= c; a ^= (c >> 3);          b -= c; b -= a; b ^= (a << 10);          c -= a; c -= b; c ^= (b >> 15);          return c;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: unchecked {          uint a = 0x9e3779b9 + key1;          uint b = 0x9e3779b9 + key2;          uint c = 16777619;          a -= b; a -= c; a ^= (c >> 13);          b -= c; b -= a; b ^= (a << 8);          c -= a; c -= b; c ^= (b >> 13);          a -= b; a -= c; a ^= (c >> 12);          b -= c; b -= a; b ^= (a << 16);          c -= a; c -= b; c ^= (b >> 5);          a -= b; a -= c; a ^= (c >> 3);          b -= c; b -= a; b ^= (a << 10);          c -= a; c -= b; c ^= (b >> 15);          return c;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: unchecked {          uint a = 0x9e3779b9 + key1;          uint b = 0x9e3779b9 + key2;          uint c = 16777619;          a -= b; a -= c; a ^= (c >> 13);          b -= c; b -= a; b ^= (a << 8);          c -= a; c -= b; c ^= (b >> 13);          a -= b; a -= c; a ^= (c >> 12);          b -= c; b -= a; b ^= (a << 16);          c -= a; c -= b; c ^= (b >> 5);          a -= b; a -= c; a ^= (c >> 3);          b -= c; b -= a; b ^= (a << 10);          c -= a; c -= b; c ^= (b >> 15);          return c;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: unchecked {          uint a = 0x9e3779b9 + key1;          uint b = 0x9e3779b9 + key2;          uint c = 16777619;          a -= b; a -= c; a ^= (c >> 13);          b -= c; b -= a; b ^= (a << 8);          c -= a; c -= b; c ^= (b >> 13);          a -= b; a -= c; a ^= (c >> 12);          b -= c; b -= a; b ^= (a << 16);          c -= a; c -= b; c ^= (b >> 5);          a -= b; a -= c; a ^= (c >> 3);          b -= c; b -= a; b ^= (a << 10);          c -= a; c -= b; c ^= (b >> 15);          return c;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: unchecked {          uint a = 0x9e3779b9 + key1;          uint b = 0x9e3779b9 + key2;          uint c = 16777619;          a -= b; a -= c; a ^= (c >> 13);          b -= c; b -= a; b ^= (a << 8);          c -= a; c -= b; c ^= (b >> 13);          a -= b; a -= c; a ^= (c >> 12);          b -= c; b -= a; b ^= (a << 16);          c -= a; c -= b; c ^= (b >> 5);          a -= b; a -= c; a ^= (c >> 3);          b -= c; b -= a; b ^= (a << 10);          c -= a; c -= b; c ^= (b >> 15);          return c;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: unchecked {          uint a = 0x9e3779b9 + key1;          uint b = 0x9e3779b9 + key2;          uint c = 16777619;          a -= b; a -= c; a ^= (c >> 13);          b -= c; b -= a; b ^= (a << 8);          c -= a; c -= b; c ^= (b >> 13);          a -= b; a -= c; a ^= (c >> 12);          b -= c; b -= a; b ^= (a << 16);          c -= a; c -= b; c ^= (b >> 5);          a -= b; a -= c; a ^= (c >> 3);          b -= c; b -= a; b ^= (a << 10);          c -= a; c -= b; c ^= (b >> 15);          return c;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: unchecked {          uint a = 0x9e3779b9 + key1;          uint b = 0x9e3779b9 + key2;          uint c = 16777619;          a -= b; a -= c; a ^= (c >> 13);          b -= c; b -= a; b ^= (a << 8);          c -= a; c -= b; c ^= (b >> 13);          a -= b; a -= c; a ^= (c >> 12);          b -= c; b -= a; b ^= (a << 16);          c -= a; c -= b; c ^= (b >> 5);          a -= b; a -= c; a ^= (c >> 3);          b -= c; b -= a; b ^= (a << 10);          c -= a; c -= b; c ^= (b >> 15);          return c;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: unchecked {          uint a = 0x9e3779b9 + key1;          uint b = 0x9e3779b9 + key2;          uint c = 16777619;          a -= b; a -= c; a ^= (c >> 13);          b -= c; b -= a; b ^= (a << 8);          c -= a; c -= b; c ^= (b >> 13);          a -= b; a -= c; a ^= (c >> 12);          b -= c; b -= a; b ^= (a << 16);          c -= a; c -= b; c ^= (b >> 5);          a -= b; a -= c; a ^= (c >> 3);          b -= c; b -= a; b ^= (a << 10);          c -= a; c -= b; c ^= (b >> 15);          return c;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: unchecked {          uint a = 0x9e3779b9 + key1;          uint b = 0x9e3779b9 + key2;          uint c = 16777619;          a -= b; a -= c; a ^= (c >> 13);          b -= c; b -= a; b ^= (a << 8);          c -= a; c -= b; c ^= (b >> 13);          a -= b; a -= c; a ^= (c >> 12);          b -= c; b -= a; b ^= (a << 16);          c -= a; c -= b; c ^= (b >> 5);          a -= b; a -= c; a ^= (c >> 3);          b -= c; b -= a; b ^= (a << 10);          c -= a; c -= b; c ^= (b >> 15);          return c;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt2,The following statement contains a magic number: unchecked {          uint hash = 0xB1635D64 + key1;          hash += (hash << 10);          hash ^= (hash >> 6);          hash += key2;          hash += (hash << 3);          hash ^= (hash >> 11);          hash += (hash << 15);          hash |= 0x00000001; //  To make sure that this is relatively prime with power of 2          return hash;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt2,The following statement contains a magic number: unchecked {          uint hash = 0xB1635D64 + key1;          hash += (hash << 10);          hash ^= (hash >> 6);          hash += key2;          hash += (hash << 3);          hash ^= (hash >> 11);          hash += (hash << 15);          hash |= 0x00000001; //  To make sure that this is relatively prime with power of 2          return hash;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt2,The following statement contains a magic number: unchecked {          uint hash = 0xB1635D64 + key1;          hash += (hash << 10);          hash ^= (hash >> 6);          hash += key2;          hash += (hash << 3);          hash ^= (hash >> 11);          hash += (hash << 15);          hash |= 0x00000001; //  To make sure that this is relatively prime with power of 2          return hash;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt2,The following statement contains a magic number: unchecked {          uint hash = 0xB1635D64 + key1;          hash += (hash << 10);          hash ^= (hash >> 6);          hash += key2;          hash += (hash << 3);          hash ^= (hash >> 11);          hash += (hash << 15);          hash |= 0x00000001; //  To make sure that this is relatively prime with power of 2          return hash;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt2,The following statement contains a magic number: unchecked {          uint hash = 0xB1635D64 + key1;          hash += (hash << 10);          hash ^= (hash >> 6);          hash += key2;          hash += (hash << 3);          hash ^= (hash >> 11);          hash += (hash << 15);          hash |= 0x00000001; //  To make sure that this is relatively prime with power of 2          return hash;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,StartHash,The following statement contains a magic number: hash += (hash << 3);
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,StartHash,The following statement contains a magic number: hash ^= (hash >> 11);
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,StartHash,The following statement contains a magic number: hash += (hash << 15);
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,ContinueHash,The following statement contains a magic number: unchecked {          uint hash = prevHash + key;          hash += (hash << 10);          hash ^= (hash >> 6);          return hash;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,ContinueHash,The following statement contains a magic number: unchecked {          uint hash = prevHash + key;          hash += (hash << 10);          hash ^= (hash >> 6);          return hash;        }
Magic Number,Microsoft.Cci.UtilityDataStructures,MultiHashtable<InternalT>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SizeFromExpectedEntries,The following statement contains a magic number: uint expectedSize = (expectedEntries * 10) / 6;
Magic Number,Microsoft.Cci.UtilityDataStructures,MultiHashtable<InternalT>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SizeFromExpectedEntries,The following statement contains a magic number: uint expectedSize = (expectedEntries * 10) / 6;
Magic Number,Microsoft.Cci.UtilityDataStructures,MultiHashtable<InternalT>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SizeFromExpectedEntries,The following statement contains a magic number: uint initialSize = 16;
Magic Number,Microsoft.Cci.UtilityDataStructures,MultiHashtable<InternalT>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,MultiHashtable,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,MultiHashtable<InternalT>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,MultiHashtable,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,MultiHashtable<InternalT>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.keyValueTable = new KeyValuePair[this.size*2];
Magic Number,Microsoft.Cci.UtilityDataStructures,MultiHashtable<InternalT>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,MultiHashtable<InternalT>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable<Key;Value>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SizeFromExpectedEntries,The following statement contains a magic number: uint expectedSize = (expectedEntries * 10) / 6;
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable<Key;Value>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SizeFromExpectedEntries,The following statement contains a magic number: uint expectedSize = (expectedEntries * 10) / 6;
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable<Key;Value>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SizeFromExpectedEntries,The following statement contains a magic number: uint initialSize = 16;
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable<Key;Value>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Hashtable,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable<Key;Value>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Hashtable,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable<Key;Value>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.keyValueTable = new KeyValuePair[this.size*2];
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable<Key;Value>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable<Key;Value>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,HashtableForUintValues<Key>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SizeFromExpectedEntries,The following statement contains a magic number: uint expectedSize = (expectedEntries * 10) / 6;
Magic Number,Microsoft.Cci.UtilityDataStructures,HashtableForUintValues<Key>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SizeFromExpectedEntries,The following statement contains a magic number: uint expectedSize = (expectedEntries * 10) / 6;
Magic Number,Microsoft.Cci.UtilityDataStructures,HashtableForUintValues<Key>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SizeFromExpectedEntries,The following statement contains a magic number: uint initialSize = 16;
Magic Number,Microsoft.Cci.UtilityDataStructures,HashtableForUintValues<Key>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashtableForUintValues,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,HashtableForUintValues<Key>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashtableForUintValues,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,HashtableForUintValues<Key>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.keyValueTable = new KeyValuePair[this.size*2];
Magic Number,Microsoft.Cci.UtilityDataStructures,HashtableForUintValues<Key>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,HashtableForUintValues<Key>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable<InternalT>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SizeFromExpectedEntries,The following statement contains a magic number: uint expectedSize = (expectedEntries * 10) / 6;
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable<InternalT>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SizeFromExpectedEntries,The following statement contains a magic number: uint expectedSize = (expectedEntries * 10) / 6;
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable<InternalT>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SizeFromExpectedEntries,The following statement contains a magic number: uint initialSize = 16;
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable<InternalT>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Hashtable,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable<InternalT>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Hashtable,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable<InternalT>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.keyValueTable = new KeyValuePair[this.size*2];
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable<InternalT>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable<InternalT>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SizeFromExpectedEntries,The following statement contains a magic number: uint expectedSize = (expectedEntries * 10) / 6;
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SizeFromExpectedEntries,The following statement contains a magic number: uint expectedSize = (expectedEntries * 10) / 6;
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SizeFromExpectedEntries,The following statement contains a magic number: uint initialSize = 16;
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Hashtable,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Hashtable,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.keyValueTable = new KeyValuePair[this.size*2];
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,DoubleHashtable,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SizeFromExpectedEntries,The following statement contains a magic number: uint expectedSize = (uint)(expectedEntries * 10) / 6;
Magic Number,Microsoft.Cci.UtilityDataStructures,DoubleHashtable,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SizeFromExpectedEntries,The following statement contains a magic number: uint expectedSize = (uint)(expectedEntries * 10) / 6;
Magic Number,Microsoft.Cci.UtilityDataStructures,DoubleHashtable,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SizeFromExpectedEntries,The following statement contains a magic number: uint initialSize = 16;
Magic Number,Microsoft.Cci.UtilityDataStructures,DoubleHashtable,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,DoubleHashtable,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,DoubleHashtable,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,DoubleHashtable,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,DoubleHashtable,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.keysValueTable = new Key1Key2ValueTriple[this.size*2];
Magic Number,Microsoft.Cci.UtilityDataStructures,DoubleHashtable,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,DoubleHashtable,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,DoubleHashtable<T>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SizeFromExpectedEntries,The following statement contains a magic number: uint expectedSize = (uint)(expectedEntries * 10) / 6;
Magic Number,Microsoft.Cci.UtilityDataStructures,DoubleHashtable<T>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SizeFromExpectedEntries,The following statement contains a magic number: uint expectedSize = (uint)(expectedEntries * 10) / 6;
Magic Number,Microsoft.Cci.UtilityDataStructures,DoubleHashtable<T>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SizeFromExpectedEntries,The following statement contains a magic number: uint initialSize = 16;
Magic Number,Microsoft.Cci.UtilityDataStructures,DoubleHashtable<T>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,DoubleHashtable,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,DoubleHashtable<T>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,DoubleHashtable,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,DoubleHashtable<T>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.keysValueTable = new Key1Key2ValueTriple[this.size*2];
Magic Number,Microsoft.Cci.UtilityDataStructures,DoubleHashtable<T>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,DoubleHashtable<T>,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,SetOfObjects,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SizeFromExpectedEntries,The following statement contains a magic number: uint expectedSize = (expectedEntries * 10) / 6;
Magic Number,Microsoft.Cci.UtilityDataStructures,SetOfObjects,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SizeFromExpectedEntries,The following statement contains a magic number: uint expectedSize = (expectedEntries * 10) / 6;
Magic Number,Microsoft.Cci.UtilityDataStructures,SetOfObjects,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SizeFromExpectedEntries,The following statement contains a magic number: uint initialSize = 16;
Magic Number,Microsoft.Cci.UtilityDataStructures,SetOfObjects,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SetOfObjects,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,SetOfObjects,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SetOfObjects,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,SetOfObjects,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.elements = new object[this.size*2];
Magic Number,Microsoft.Cci.UtilityDataStructures,SetOfObjects,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Magic Number,Microsoft.Cci.UtilityDataStructures,SetOfObjects,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;
Missing Default,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,IsVisibleOutsideAssembly,The following switch statement is missing a default case: switch (TypeHelper.TypeVisibilityAsTypeMemberVisibility(typeDefinition)) {          case TypeMemberVisibility.Public:          case TypeMemberVisibility.Family:          case TypeMemberVisibility.FamilyOrAssembly:            return true;        }
Missing Default,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,IsVisibleToFriendAssemblies,The following switch statement is missing a default case: switch (TypeHelper.TypeVisibilityAsTypeMemberVisibility(typeDefinition)) {          case TypeMemberVisibility.Public:          case TypeMemberVisibility.Family:          case TypeMemberVisibility.FamilyOrAssembly:          case TypeMemberVisibility.FamilyAndAssembly:          case TypeMemberVisibility.Assembly:            return true;        }
Missing Default,Microsoft.Cci,TypeHelper,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,StackType,The following switch statement is missing a default case: switch (type.TypeCode) {          case PrimitiveTypeCode.Boolean:          case PrimitiveTypeCode.Char:          case PrimitiveTypeCode.Int16:          case PrimitiveTypeCode.Int32:          case PrimitiveTypeCode.Int8:          case PrimitiveTypeCode.UInt16:          case PrimitiveTypeCode.UInt32:          case PrimitiveTypeCode.UInt8:            return type.PlatformType.SystemInt32;          case PrimitiveTypeCode.Int64:          case PrimitiveTypeCode.UInt64:            return type.PlatformType.SystemInt64;          case PrimitiveTypeCode.Float32:          case PrimitiveTypeCode.Float64:            return type.PlatformType.SystemFloat64;          case PrimitiveTypeCode.IntPtr:          case PrimitiveTypeCode.UIntPtr:            return type.PlatformType.SystemIntPtr;        }
Missing Default,Microsoft.Cci,TypeNameFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,EscapeKeyword,The following switch statement is missing a default case: switch (name) {          case "abstract": return "@abstract";          case "as": return "@as";          case "base": return "@base";          case "bool": return "@bool";          case "break": return "@break";          case "byte": return "@byte";          case "case": return "@case";          case "catch": return "@catch";          case "char": return "@char";          case "checked": return "@checked";          case "class": return "@class";          case "const": return "@const";          case "continue": return "@continue";          case "decimal": return "@decimal";          case "default": return "@default";          case "delegate": return "@delegate";          case "do": return "@do";          case "double": return "@double";          case "explicit": return "@explicit";          case "event": return "@event";          case "extern": return "@extern";          case "else": return "@else";          case "enum": return "@enum";          case "false": return "@false";          case "finally": return "@finally";          case "fixed": return "@fixed";          case "float": return "@float";          case "for": return "@for";          case "foreach": return "@foreach";          case "goto": return "@goto";          case "if": return "@if";          case "in": return "@in";          case "int": return "@int";          case "interface": return "@interface";          case "internal": return "@internal";          case "is": return "@is";          case "lock": return "@lock";          case "long": return "@long";          case "new": return "@new";          case "null": return "@null";          case "namespace": return "@namespace";          case "object": return "@object";          case "operator": return "@operator";          case "out": return "@out";          case "override": return "@override";          case "params": return "@params";          case "private": return "@private";          case "protected": return "@protected";          case "public": return "@public";          case "readonly": return "@readonly";          case "ref": return "@ref";          case "return": return "@return";          case "switch": return "@switch";          case "struct": return "@struct";          case "sbyte": return "@sbyte";          case "sealed": return "@sealed";          case "short": return "@short";          case "sizeof": return "@sizeof";          case "stackalloc": return "@stackalloc";          case "static": return "@static";          case "string": return "@string";          case "this": return "@this";          case "throw": return "@throw";          case "true": return "@true";          case "try": return "@try";          case "typeof": return "@typeof";          case "uint": return "@uint";          case "ulong": return "@ulong";          case "unchecked": return "@unchecked";          case "unsafe": return "@unsafe";          case "ushort": return "@ushort";          case "using": return "@using";          case "virtual": return "@virtual";          case "volatile": return "@volatile";          case "void": return "@void";          case "while": return "@while";        }
Missing Default,Microsoft.Cci,TypeNameFormatter,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetTypeName,The following switch statement is missing a default case: switch (type.TypeCode) {            case PrimitiveTypeCode.Boolean: return "bool";            case PrimitiveTypeCode.Char: return "char";            case PrimitiveTypeCode.Float32: return "float";            case PrimitiveTypeCode.Float64: return "double";            case PrimitiveTypeCode.Int16: return "short";            case PrimitiveTypeCode.Int32: return "int";            case PrimitiveTypeCode.Int64: return "long";            case PrimitiveTypeCode.Int8: return "sbyte";            case PrimitiveTypeCode.String: return "string";            case PrimitiveTypeCode.UInt16: return "ushort";            case PrimitiveTypeCode.UInt32: return "uint";            case PrimitiveTypeCode.UInt64: return "ulong";            case PrimitiveTypeCode.UInt8: return "byte";            case PrimitiveTypeCode.Void: return "void";            case PrimitiveTypeCode.NotPrimitive:              if (TypeHelper.TypesAreEquivalent(type' type.PlatformType.SystemDecimal)) return "decimal";              if (TypeHelper.TypesAreEquivalent(type' type.PlatformType.SystemObject)) return "object";              break;          }
Missing Default,Microsoft.Cci,ValidatingVisitor,C:\repos\vc3_Afterthought\Microsoft.CCI\MetadataHelper\Validator.cs,Visit,The following switch statement is missing a default case: switch (ctype.TypeCode) {            case PrimitiveTypeCode.Boolean:              validValue = constant.Value is bool; break;            case PrimitiveTypeCode.Char:              validValue = constant.Value is char; break;            case PrimitiveTypeCode.Int8:              validValue = constant.Value is sbyte; break;            case PrimitiveTypeCode.UInt8:              validValue = constant.Value is byte; break;            case PrimitiveTypeCode.Int16:              validValue = constant.Value is short; break;            case PrimitiveTypeCode.UInt16:              validValue = constant.Value is ushort; break;            case PrimitiveTypeCode.Int32:              validValue = constant.Value is int; break;            case PrimitiveTypeCode.UInt32:              validValue = constant.Value is uint; break;            case PrimitiveTypeCode.Int64:              validValue = constant.Value is long; break;            case PrimitiveTypeCode.UInt64:              validValue = constant.Value is ulong; break;            case PrimitiveTypeCode.Float32:              validValue = constant.Value is float; break;            case PrimitiveTypeCode.Float64:              validValue = constant.Value is double; break;            case PrimitiveTypeCode.String:              validValue = constant.Value is string || constant.Value == null; break;            case PrimitiveTypeCode.NotPrimitive:              validValue = constant.Value == null || rctype == Dummy.Type; break; //TODO: check that value can be enum val          }
