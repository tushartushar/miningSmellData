Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.Cci.Pdb,PdbFile,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The method has 129 lines of code.
Long Method,Microsoft.Cci.Pdb,PdbFunction,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFunction.cs,PdbFunction,The method has 116 lines of code.
Complex Method,Microsoft.Cci.Pdb,PdbFunction,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFunction.cs,PdbFunction,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,PdbReader,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\SourceLocationProvider.cs,MapMethodBodyLocationToSourceLocation,Cyclomatic complexity of the method is 9
Long Parameter List,Microsoft.Cci.Pdb,DataStream,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\DataStream.cs,Read,The method has 5 parameters. Parameters: reader' position' bytes' offset' data
Long Parameter List,Microsoft.Cci.Pdb,PdbFile,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The method has 7 parameters. Parameters: funcs' names' bits' dir' nameIndex' reader' limit
Long Parameter List,Microsoft.Cci.Pdb,PdbFile,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFile.cs,LoadFuncsFromDbiModule,The method has 8 parameters. Parameters: bits' info' names' funcList' readStrings' dir' nameIndex' reader
Long Parameter List,Microsoft.Cci.Pdb,PdbFunction,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFunction.cs,CountScopesAndSlots,The method has 6 parameters. Parameters: bits' limit' constants' scopes' slots' usedNamespaces
Long Parameter List,Microsoft.Cci.Pdb,PdbLine,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbLine.cs,PdbLine,The method has 5 parameters. Parameters: offset' lineBegin' colBegin' lineEnd' colEnd
Long Parameter List,Microsoft.Cci.Pdb,PdbScope,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbScope.cs,PdbScope,The method has 5 parameters. Parameters: address' length' slots' constants' usedNamespaces
Long Parameter List,Microsoft.Cci,PdbSourceLineLocation,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\SourceLocationProvider.cs,PdbSourceLineLocation,The method has 5 parameters. Parameters: primarySourceDocument' startLine' startColumn' endLine' endColumn
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt16,The following statement contains a magic number: value = (short)((buffer[offset + 0] & 0xFF) |                              (buffer[offset + 1] << 8));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt16,The following statement contains a magic number: offset += 2;
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt32,The following statement contains a magic number: value = (int)((buffer[offset + 0] & 0xFF) |                            (buffer[offset + 1] << 8) |                            (buffer[offset + 2] << 16) |                            (buffer[offset + 3] << 24));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt32,The following statement contains a magic number: value = (int)((buffer[offset + 0] & 0xFF) |                            (buffer[offset + 1] << 8) |                            (buffer[offset + 2] << 16) |                            (buffer[offset + 3] << 24));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt32,The following statement contains a magic number: value = (int)((buffer[offset + 0] & 0xFF) |                            (buffer[offset + 1] << 8) |                            (buffer[offset + 2] << 16) |                            (buffer[offset + 3] << 24));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt32,The following statement contains a magic number: value = (int)((buffer[offset + 0] & 0xFF) |                            (buffer[offset + 1] << 8) |                            (buffer[offset + 2] << 16) |                            (buffer[offset + 3] << 24));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt32,The following statement contains a magic number: value = (int)((buffer[offset + 0] & 0xFF) |                            (buffer[offset + 1] << 8) |                            (buffer[offset + 2] << 16) |                            (buffer[offset + 3] << 24));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt32,The following statement contains a magic number: offset += 4;
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: offset += 8;
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt16,The following statement contains a magic number: value = (ushort)((buffer[offset + 0] & 0xFF) |                               (buffer[offset + 1] << 8));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt16,The following statement contains a magic number: offset += 2;
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt32,The following statement contains a magic number: value = (uint)((buffer[offset + 0] & 0xFF) |                             (buffer[offset + 1] << 8) |                             (buffer[offset + 2] << 16) |                             (buffer[offset + 3] << 24));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt32,The following statement contains a magic number: value = (uint)((buffer[offset + 0] & 0xFF) |                             (buffer[offset + 1] << 8) |                             (buffer[offset + 2] << 16) |                             (buffer[offset + 3] << 24));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt32,The following statement contains a magic number: value = (uint)((buffer[offset + 0] & 0xFF) |                             (buffer[offset + 1] << 8) |                             (buffer[offset + 2] << 16) |                             (buffer[offset + 3] << 24));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt32,The following statement contains a magic number: value = (uint)((buffer[offset + 0] & 0xFF) |                             (buffer[offset + 1] << 8) |                             (buffer[offset + 2] << 16) |                             (buffer[offset + 3] << 24));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt32,The following statement contains a magic number: value = (uint)((buffer[offset + 0] & 0xFF) |                             (buffer[offset + 1] << 8) |                             (buffer[offset + 2] << 16) |                             (buffer[offset + 3] << 24));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt32,The following statement contains a magic number: offset += 4;
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer[offset + 0] & 0xFF) |                             ((ulong)buffer[offset + 1] << 8) |                             ((ulong)buffer[offset + 2] << 16) |                             ((ulong)buffer[offset + 3] << 24) |                             ((ulong)buffer[offset + 4] << 32) |                             ((ulong)buffer[offset + 5] << 40) |                             ((ulong)buffer[offset + 6] << 48) |                             ((ulong)buffer[offset + 7] << 56));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: offset += 8;
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadFloat,The following statement contains a magic number: offset += 4;
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadDouble,The following statement contains a magic number: offset += 8;
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadDecimal,The following statement contains a magic number: int[] bits = new int[4];
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadDecimal,The following statement contains a magic number: return new decimal(bits[2]' bits[3]' bits[1]' bits[0] < 0' (byte)((bits[0] & 0x00FF0000) >> 16));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadDecimal,The following statement contains a magic number: return new decimal(bits[2]' bits[3]' bits[1]' bits[0] < 0' (byte)((bits[0] & 0x00FF0000) >> 16));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadDecimal,The following statement contains a magic number: return new decimal(bits[2]' bits[3]' bits[1]' bits[0] < 0' (byte)((bits[0] & 0x00FF0000) >> 16));
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadString,The following statement contains a magic number: while (offset + len < buffer.Length && buffer[offset + len] != 0) {          len+=2;        }
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitAccess.cs,ReadString,The following statement contains a magic number: offset += len + 2;
Magic Number,Microsoft.Cci.Pdb,BitSet,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitSet.cs,IsSet,The following statement contains a magic number: int word = index / 32;
Magic Number,Microsoft.Cci.Pdb,BitSet,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\BitSet.cs,GetBit,The following statement contains a magic number: return ((uint)1 << (index % 32));
Magic Number,Microsoft.Cci.Pdb,DbiModuleInfo,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\DbiModuleInfo.cs,DbiModuleInfo,The following statement contains a magic number: bits.Align(4);
Magic Number,Microsoft.Cci.Pdb,IntHashTable,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\IntHashTable.cs,IntHashTable,The following statement contains a magic number: if (!(loadFactorPerc >= 10 && loadFactorPerc <= 100))          throw new ArgumentOutOfRangeException("loadFactorPerc"' String.Format("ArgumentOutOfRange_IntHashTableLoadFactor"' 10' 100));
Magic Number,Microsoft.Cci.Pdb,IntHashTable,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\IntHashTable.cs,IntHashTable,The following statement contains a magic number: if (!(loadFactorPerc >= 10 && loadFactorPerc <= 100))          throw new ArgumentOutOfRangeException("loadFactorPerc"' String.Format("ArgumentOutOfRange_IntHashTableLoadFactor"' 10' 100));
Magic Number,Microsoft.Cci.Pdb,IntHashTable,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\IntHashTable.cs,IntHashTable,The following statement contains a magic number: if (!(loadFactorPerc >= 10 && loadFactorPerc <= 100))          throw new ArgumentOutOfRangeException("loadFactorPerc"' String.Format("ArgumentOutOfRange_IntHashTableLoadFactor"' 10' 100));
Magic Number,Microsoft.Cci.Pdb,IntHashTable,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\IntHashTable.cs,IntHashTable,The following statement contains a magic number: if (!(loadFactorPerc >= 10 && loadFactorPerc <= 100))          throw new ArgumentOutOfRangeException("loadFactorPerc"' String.Format("ArgumentOutOfRange_IntHashTableLoadFactor"' 10' 100));
Magic Number,Microsoft.Cci.Pdb,IntHashTable,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\IntHashTable.cs,IntHashTable,The following statement contains a magic number: this.loadFactorPerc = (loadFactorPerc * 72) / 100;
Magic Number,Microsoft.Cci.Pdb,IntHashTable,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\IntHashTable.cs,IntHashTable,The following statement contains a magic number: this.loadFactorPerc = (loadFactorPerc * 72) / 100;
Magic Number,Microsoft.Cci.Pdb,IntHashTable,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\IntHashTable.cs,IntHashTable,The following statement contains a magic number: loadsize = (int)(this.loadFactorPerc * hashsize) / 100;
Magic Number,Microsoft.Cci.Pdb,IntHashTable,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\IntHashTable.cs,InitHash,The following statement contains a magic number: incr = (uint)(1 + (((seed >> 5) + 1) % ((uint)hashsize - 1)));
Magic Number,Microsoft.Cci.Pdb,IntHashTable,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\IntHashTable.cs,expand,The following statement contains a magic number: rehash(GetPrime(1+buckets.Length*2));
Magic Number,Microsoft.Cci.Pdb,IntHashTable,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\IntHashTable.cs,rehash,The following statement contains a magic number: loadsize = (int)(loadFactorPerc * newsize) / 100;
Magic Number,Microsoft.Cci.Pdb,IntHashTable,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\IntHashTable.cs,Insert,The following statement contains a magic number: if (count >= loadsize) {          expand();        } else if (occupancy > loadsize && count > 100) {          rehash();        }
Magic Number,Microsoft.Cci.Pdb,IntHashTable,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\IntHashTable.cs,putEntry,The following statement contains a magic number: uint incr = (uint)(1 + (((seed >> 5) + 1) % ((uint)newBuckets.Length - 1)));
Magic Number,Microsoft.Cci.Pdb,MsfDirectory,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\MsfDirectory.cs,MsfDirectory,The following statement contains a magic number: int pagesPerPage = head.pageSize / 4;
Magic Number,Microsoft.Cci.Pdb,MsfDirectory,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\MsfDirectory.cs,MsfDirectory,The following statement contains a magic number: for (int i = 0; i < directoryRootPages; i++) {          int pagesInThisPage = pagesToGo <= pagesPerPage ? pagesToGo : pagesPerPage;          reader.Seek(head.directoryRoot[i]' 0);          bits.Append(reader.reader' pagesInThisPage * 4);          pagesToGo -= pagesInThisPage;        }
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < limit) {          int sig;          int siz;          bits.ReadInt32(out sig);          bits.ReadInt32(out siz);          int place = bits.Position;          int endSym = bits.Position + siz;            switch ((DEBUG_S_SUBSECTION)sig) {            case DEBUG_S_SUBSECTION.FILECHKSMS:              while (bits.Position < endSym) {                CV_FileCheckSum chk;                  int ni = bits.Position - place;                bits.ReadUInt32(out chk.name);                bits.ReadUInt8(out chk.len);                bits.ReadUInt8(out chk.type);                  string name = (string)names[(int)chk.name];                int guidStream;                Guid doctypeGuid = SymDocumentType.Text;                Guid languageGuid = Guid.Empty;                Guid vendorGuid = Guid.Empty;                if (nameIndex.TryGetValue("/SRC/FILES/"+name.ToUpperInvariant()' out guidStream)) {                  var guidBits = new BitAccess(0x100);                  dir.streams[guidStream].Read(reader' guidBits);                  LoadGuidStream(guidBits' out doctypeGuid' out languageGuid' out vendorGuid);                }                  PdbSource src = new PdbSource(/*(uint)ni'*/ name' doctypeGuid' languageGuid' vendorGuid);                checks.Add(ni' src);                bits.Position += chk.len;                bits.Align(4);              }              bits.Position = endSym;              break;              default:              bits.Position = endSym;              break;          }        }
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < limit) {          int sig;          int siz;          bits.ReadInt32(out sig);          bits.ReadInt32(out siz);          int endSym = bits.Position + siz;            switch ((DEBUG_S_SUBSECTION)sig) {            case DEBUG_S_SUBSECTION.LINES: {                CV_LineSection sec;                  bits.ReadUInt32(out sec.off);                bits.ReadUInt16(out sec.sec);                bits.ReadUInt16(out sec.flags);                bits.ReadUInt32(out sec.cod);                int funcIndex = FindFunction(funcs' sec.sec' sec.off);                if (funcIndex < 0) break;                var func = funcs[funcIndex];                if (func.lines == null) {                  while (funcIndex > 0) {                    var f = funcs[funcIndex-1];                    if (f.lines != null || f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex--;                  }               } else {                  while (funcIndex < funcs.Length-1 && func.lines != null) {                    var f = funcs[funcIndex+1];                    if (f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex++;                  }                }                if (func.lines != null) break;                  // Count the line blocks.                int begSym = bits.Position;                int blocks = 0;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                  int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));                  bits.Position += linsiz;                  blocks++;                }                  func.lines = new PdbLines[blocks];                int block = 0;                  bits.Position = begSym;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                    PdbSource src = (PdbSource)checks[(int)file.index];                  PdbLines tmp = new PdbLines(src' file.count);                  func.lines[block++] = tmp;                  PdbLine[] lines = tmp.lines;                    int plin = bits.Position;                  int pcol = bits.Position + 8 * (int)file.count;                    for (int i = 0; i < file.count; i++) {                    CV_Line line;                    CV_Column column = new CV_Column();                      bits.Position = plin + 8 * i;                    bits.ReadUInt32(out line.offset);                    bits.ReadUInt32(out line.flags);                      uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;                    uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;                    //bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);                    if ((sec.flags & 1) != 0) {                      bits.Position = pcol + 4 * i;                      bits.ReadUInt16(out column.offColumnStart);                      bits.ReadUInt16(out column.offColumnEnd);                    }                      lines[i] = new PdbLine(line.offset'                                           lineBegin'                                           column.offColumnStart'                                           lineBegin+delta'                                           column.offColumnEnd);                  }                }                break;              }          }          bits.Position = endSym;        }
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < limit) {          int sig;          int siz;          bits.ReadInt32(out sig);          bits.ReadInt32(out siz);          int endSym = bits.Position + siz;            switch ((DEBUG_S_SUBSECTION)sig) {            case DEBUG_S_SUBSECTION.LINES: {                CV_LineSection sec;                  bits.ReadUInt32(out sec.off);                bits.ReadUInt16(out sec.sec);                bits.ReadUInt16(out sec.flags);                bits.ReadUInt32(out sec.cod);                int funcIndex = FindFunction(funcs' sec.sec' sec.off);                if (funcIndex < 0) break;                var func = funcs[funcIndex];                if (func.lines == null) {                  while (funcIndex > 0) {                    var f = funcs[funcIndex-1];                    if (f.lines != null || f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex--;                  }               } else {                  while (funcIndex < funcs.Length-1 && func.lines != null) {                    var f = funcs[funcIndex+1];                    if (f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex++;                  }                }                if (func.lines != null) break;                  // Count the line blocks.                int begSym = bits.Position;                int blocks = 0;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                  int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));                  bits.Position += linsiz;                  blocks++;                }                  func.lines = new PdbLines[blocks];                int block = 0;                  bits.Position = begSym;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                    PdbSource src = (PdbSource)checks[(int)file.index];                  PdbLines tmp = new PdbLines(src' file.count);                  func.lines[block++] = tmp;                  PdbLine[] lines = tmp.lines;                    int plin = bits.Position;                  int pcol = bits.Position + 8 * (int)file.count;                    for (int i = 0; i < file.count; i++) {                    CV_Line line;                    CV_Column column = new CV_Column();                      bits.Position = plin + 8 * i;                    bits.ReadUInt32(out line.offset);                    bits.ReadUInt32(out line.flags);                      uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;                    uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;                    //bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);                    if ((sec.flags & 1) != 0) {                      bits.Position = pcol + 4 * i;                      bits.ReadUInt16(out column.offColumnStart);                      bits.ReadUInt16(out column.offColumnEnd);                    }                      lines[i] = new PdbLine(line.offset'                                           lineBegin'                                           column.offColumnStart'                                           lineBegin+delta'                                           column.offColumnEnd);                  }                }                break;              }          }          bits.Position = endSym;        }
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < limit) {          int sig;          int siz;          bits.ReadInt32(out sig);          bits.ReadInt32(out siz);          int endSym = bits.Position + siz;            switch ((DEBUG_S_SUBSECTION)sig) {            case DEBUG_S_SUBSECTION.LINES: {                CV_LineSection sec;                  bits.ReadUInt32(out sec.off);                bits.ReadUInt16(out sec.sec);                bits.ReadUInt16(out sec.flags);                bits.ReadUInt32(out sec.cod);                int funcIndex = FindFunction(funcs' sec.sec' sec.off);                if (funcIndex < 0) break;                var func = funcs[funcIndex];                if (func.lines == null) {                  while (funcIndex > 0) {                    var f = funcs[funcIndex-1];                    if (f.lines != null || f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex--;                  }               } else {                  while (funcIndex < funcs.Length-1 && func.lines != null) {                    var f = funcs[funcIndex+1];                    if (f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex++;                  }                }                if (func.lines != null) break;                  // Count the line blocks.                int begSym = bits.Position;                int blocks = 0;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                  int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));                  bits.Position += linsiz;                  blocks++;                }                  func.lines = new PdbLines[blocks];                int block = 0;                  bits.Position = begSym;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                    PdbSource src = (PdbSource)checks[(int)file.index];                  PdbLines tmp = new PdbLines(src' file.count);                  func.lines[block++] = tmp;                  PdbLine[] lines = tmp.lines;                    int plin = bits.Position;                  int pcol = bits.Position + 8 * (int)file.count;                    for (int i = 0; i < file.count; i++) {                    CV_Line line;                    CV_Column column = new CV_Column();                      bits.Position = plin + 8 * i;                    bits.ReadUInt32(out line.offset);                    bits.ReadUInt32(out line.flags);                      uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;                    uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;                    //bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);                    if ((sec.flags & 1) != 0) {                      bits.Position = pcol + 4 * i;                      bits.ReadUInt16(out column.offColumnStart);                      bits.ReadUInt16(out column.offColumnEnd);                    }                      lines[i] = new PdbLine(line.offset'                                           lineBegin'                                           column.offColumnStart'                                           lineBegin+delta'                                           column.offColumnEnd);                  }                }                break;              }          }          bits.Position = endSym;        }
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < limit) {          int sig;          int siz;          bits.ReadInt32(out sig);          bits.ReadInt32(out siz);          int endSym = bits.Position + siz;            switch ((DEBUG_S_SUBSECTION)sig) {            case DEBUG_S_SUBSECTION.LINES: {                CV_LineSection sec;                  bits.ReadUInt32(out sec.off);                bits.ReadUInt16(out sec.sec);                bits.ReadUInt16(out sec.flags);                bits.ReadUInt32(out sec.cod);                int funcIndex = FindFunction(funcs' sec.sec' sec.off);                if (funcIndex < 0) break;                var func = funcs[funcIndex];                if (func.lines == null) {                  while (funcIndex > 0) {                    var f = funcs[funcIndex-1];                    if (f.lines != null || f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex--;                  }               } else {                  while (funcIndex < funcs.Length-1 && func.lines != null) {                    var f = funcs[funcIndex+1];                    if (f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex++;                  }                }                if (func.lines != null) break;                  // Count the line blocks.                int begSym = bits.Position;                int blocks = 0;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                  int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));                  bits.Position += linsiz;                  blocks++;                }                  func.lines = new PdbLines[blocks];                int block = 0;                  bits.Position = begSym;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                    PdbSource src = (PdbSource)checks[(int)file.index];                  PdbLines tmp = new PdbLines(src' file.count);                  func.lines[block++] = tmp;                  PdbLine[] lines = tmp.lines;                    int plin = bits.Position;                  int pcol = bits.Position + 8 * (int)file.count;                    for (int i = 0; i < file.count; i++) {                    CV_Line line;                    CV_Column column = new CV_Column();                      bits.Position = plin + 8 * i;                    bits.ReadUInt32(out line.offset);                    bits.ReadUInt32(out line.flags);                      uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;                    uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;                    //bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);                    if ((sec.flags & 1) != 0) {                      bits.Position = pcol + 4 * i;                      bits.ReadUInt16(out column.offColumnStart);                      bits.ReadUInt16(out column.offColumnEnd);                    }                      lines[i] = new PdbLine(line.offset'                                           lineBegin'                                           column.offColumnStart'                                           lineBegin+delta'                                           column.offColumnEnd);                  }                }                break;              }          }          bits.Position = endSym;        }
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < limit) {          int sig;          int siz;          bits.ReadInt32(out sig);          bits.ReadInt32(out siz);          int endSym = bits.Position + siz;            switch ((DEBUG_S_SUBSECTION)sig) {            case DEBUG_S_SUBSECTION.LINES: {                CV_LineSection sec;                  bits.ReadUInt32(out sec.off);                bits.ReadUInt16(out sec.sec);                bits.ReadUInt16(out sec.flags);                bits.ReadUInt32(out sec.cod);                int funcIndex = FindFunction(funcs' sec.sec' sec.off);                if (funcIndex < 0) break;                var func = funcs[funcIndex];                if (func.lines == null) {                  while (funcIndex > 0) {                    var f = funcs[funcIndex-1];                    if (f.lines != null || f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex--;                  }               } else {                  while (funcIndex < funcs.Length-1 && func.lines != null) {                    var f = funcs[funcIndex+1];                    if (f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex++;                  }                }                if (func.lines != null) break;                  // Count the line blocks.                int begSym = bits.Position;                int blocks = 0;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                  int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));                  bits.Position += linsiz;                  blocks++;                }                  func.lines = new PdbLines[blocks];                int block = 0;                  bits.Position = begSym;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                    PdbSource src = (PdbSource)checks[(int)file.index];                  PdbLines tmp = new PdbLines(src' file.count);                  func.lines[block++] = tmp;                  PdbLine[] lines = tmp.lines;                    int plin = bits.Position;                  int pcol = bits.Position + 8 * (int)file.count;                    for (int i = 0; i < file.count; i++) {                    CV_Line line;                    CV_Column column = new CV_Column();                      bits.Position = plin + 8 * i;                    bits.ReadUInt32(out line.offset);                    bits.ReadUInt32(out line.flags);                      uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;                    uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;                    //bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);                    if ((sec.flags & 1) != 0) {                      bits.Position = pcol + 4 * i;                      bits.ReadUInt16(out column.offColumnStart);                      bits.ReadUInt16(out column.offColumnEnd);                    }                      lines[i] = new PdbLine(line.offset'                                           lineBegin'                                           column.offColumnStart'                                           lineBegin+delta'                                           column.offColumnEnd);                  }                }                break;              }          }          bits.Position = endSym;        }
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < limit) {          int sig;          int siz;          bits.ReadInt32(out sig);          bits.ReadInt32(out siz);          int endSym = bits.Position + siz;            switch ((DEBUG_S_SUBSECTION)sig) {            case DEBUG_S_SUBSECTION.LINES: {                CV_LineSection sec;                  bits.ReadUInt32(out sec.off);                bits.ReadUInt16(out sec.sec);                bits.ReadUInt16(out sec.flags);                bits.ReadUInt32(out sec.cod);                int funcIndex = FindFunction(funcs' sec.sec' sec.off);                if (funcIndex < 0) break;                var func = funcs[funcIndex];                if (func.lines == null) {                  while (funcIndex > 0) {                    var f = funcs[funcIndex-1];                    if (f.lines != null || f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex--;                  }               } else {                  while (funcIndex < funcs.Length-1 && func.lines != null) {                    var f = funcs[funcIndex+1];                    if (f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex++;                  }                }                if (func.lines != null) break;                  // Count the line blocks.                int begSym = bits.Position;                int blocks = 0;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                  int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));                  bits.Position += linsiz;                  blocks++;                }                  func.lines = new PdbLines[blocks];                int block = 0;                  bits.Position = begSym;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                    PdbSource src = (PdbSource)checks[(int)file.index];                  PdbLines tmp = new PdbLines(src' file.count);                  func.lines[block++] = tmp;                  PdbLine[] lines = tmp.lines;                    int plin = bits.Position;                  int pcol = bits.Position + 8 * (int)file.count;                    for (int i = 0; i < file.count; i++) {                    CV_Line line;                    CV_Column column = new CV_Column();                      bits.Position = plin + 8 * i;                    bits.ReadUInt32(out line.offset);                    bits.ReadUInt32(out line.flags);                      uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;                    uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;                    //bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);                    if ((sec.flags & 1) != 0) {                      bits.Position = pcol + 4 * i;                      bits.ReadUInt16(out column.offColumnStart);                      bits.ReadUInt16(out column.offColumnEnd);                    }                      lines[i] = new PdbLine(line.offset'                                           lineBegin'                                           column.offColumnStart'                                           lineBegin+delta'                                           column.offColumnEnd);                  }                }                break;              }          }          bits.Position = endSym;        }
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFile.cs,LoadFuncsFromDbiModule,The following statement contains a magic number: if (sig != 4) {          throw new PdbDebugException("Invalid signature. (sig={0})"' sig);        }
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFile.cs,LoadFuncsFromDbiModule,The following statement contains a magic number: bits.Position = 4;
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFile.cs,LoadFunctions,The following statement contains a magic number: BitAccess bits = new BitAccess(512 * 1024);
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFile.cs,LoadFunctions,The following statement contains a magic number: BitAccess bits = new BitAccess(512 * 1024);
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFile.cs,LoadFunctions,The following statement contains a magic number: dir.streams[3].Read(reader' bits);
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFile.cs,LoadFunctions,The following statement contains a magic number: if (header.snTokenRidMap != 0 && header.snTokenRidMap != 0xffff) {          dir.streams[header.snTokenRidMap].Read(reader' bits);          uint[] ridMap = new uint[dir.streams[header.snTokenRidMap].Length / 4];          bits.ReadUInt32(ridMap);            foreach (PdbFunction func in funcs) {            func.token = 0x06000000 | ridMap[func.token & 0xffffff];          }        }
Magic Number,Microsoft.Cci.Pdb,PdbFileHeader,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFileHeader.cs,PdbFileHeader,The following statement contains a magic number: bits.MinCapacity(56);
Magic Number,Microsoft.Cci.Pdb,PdbFileHeader,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFileHeader.cs,PdbFileHeader,The following statement contains a magic number: bits.FillBuffer(reader' 52);
Magic Number,Microsoft.Cci.Pdb,PdbFileHeader,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFileHeader.cs,PdbFileHeader,The following statement contains a magic number: this.magic = new byte[32];
Magic Number,Microsoft.Cci.Pdb,PdbFileHeader,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFileHeader.cs,PdbFileHeader,The following statement contains a magic number: int directoryPages = ((((directorySize + pageSize - 1) / pageSize) * 4) + pageSize - 1) / pageSize;
Magic Number,Microsoft.Cci.Pdb,PdbFileHeader,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFileHeader.cs,PdbFileHeader,The following statement contains a magic number: bits.FillBuffer(reader' directoryPages * 4);
Magic Number,Microsoft.Cci.Pdb,PdbFunction,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFunction.cs,PdbFunction,The following statement contains a magic number: while (bits.Position < proc.end) {          ushort siz;          ushort rec;            bits.ReadUInt16(out siz);          int star = bits.Position;          int stop = bits.Position + siz;          bits.Position = star;          bits.ReadUInt16(out rec);            switch ((SYM)rec) {            case SYM.S_OEM: {          // 0x0404                OemSymbol oem;                  bits.ReadGuid(out oem.idOem);                bits.ReadUInt32(out oem.typind);                // internal byte[]   rgl;        // user data' force 4-byte alignment                  if (oem.idOem == msilMetaData) {                  string name = bits.ReadString();                  if (name == "MD2") {                    byte version;                    bits.ReadUInt8(out version);                    if (version == 4) {                      byte count;                      bits.ReadUInt8(out count);                      bits.Align(4);                      while (count-- > 0)                        this.ReadCustomMetadata(bits);                    }                  }                  bits.Position = stop;                  break;                } else {                  throw new PdbDebugException("OEM section: guid={0} ti={1}"'                                              oem.idOem' oem.typind);                  // bits.Position = stop;                }              }              case SYM.S_BLOCK32: {                BlockSym32 block = new BlockSym32();                  bits.ReadUInt32(out block.parent);                bits.ReadUInt32(out block.end);                bits.ReadUInt32(out block.len);                bits.ReadUInt32(out block.off);                bits.ReadUInt16(out block.seg);                bits.SkipCString(out block.name);                bits.Position = stop;                  scopes[scope++] = new PdbScope(this.address' block' bits' out slotToken);                bits.Position = (int)block.end;                break;              }              case SYM.S_MANSLOT:              uint typind;              slots[slot++] = new PdbSlot(bits' out typind);              bits.Position = stop;              break;              case SYM.S_MANCONSTANT:              constants[constant++] = new PdbConstant(bits);              bits.Position = stop;              break;              case SYM.S_UNAMESPACE:              bits.ReadCString(out usedNamespaces[usedNs++]);              bits.Position = stop;              break;              case SYM.S_END:              bits.Position = stop;              break;              default: {                //throw new PdbDebugException("Unknown SYM: {0}"' (SYM)rec);                bits.Position = stop;                break;              }          }        }
Magic Number,Microsoft.Cci.Pdb,PdbFunction,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFunction.cs,PdbFunction,The following statement contains a magic number: while (bits.Position < proc.end) {          ushort siz;          ushort rec;            bits.ReadUInt16(out siz);          int star = bits.Position;          int stop = bits.Position + siz;          bits.Position = star;          bits.ReadUInt16(out rec);            switch ((SYM)rec) {            case SYM.S_OEM: {          // 0x0404                OemSymbol oem;                  bits.ReadGuid(out oem.idOem);                bits.ReadUInt32(out oem.typind);                // internal byte[]   rgl;        // user data' force 4-byte alignment                  if (oem.idOem == msilMetaData) {                  string name = bits.ReadString();                  if (name == "MD2") {                    byte version;                    bits.ReadUInt8(out version);                    if (version == 4) {                      byte count;                      bits.ReadUInt8(out count);                      bits.Align(4);                      while (count-- > 0)                        this.ReadCustomMetadata(bits);                    }                  }                  bits.Position = stop;                  break;                } else {                  throw new PdbDebugException("OEM section: guid={0} ti={1}"'                                              oem.idOem' oem.typind);                  // bits.Position = stop;                }              }              case SYM.S_BLOCK32: {                BlockSym32 block = new BlockSym32();                  bits.ReadUInt32(out block.parent);                bits.ReadUInt32(out block.end);                bits.ReadUInt32(out block.len);                bits.ReadUInt32(out block.off);                bits.ReadUInt16(out block.seg);                bits.SkipCString(out block.name);                bits.Position = stop;                  scopes[scope++] = new PdbScope(this.address' block' bits' out slotToken);                bits.Position = (int)block.end;                break;              }              case SYM.S_MANSLOT:              uint typind;              slots[slot++] = new PdbSlot(bits' out typind);              bits.Position = stop;              break;              case SYM.S_MANCONSTANT:              constants[constant++] = new PdbConstant(bits);              bits.Position = stop;              break;              case SYM.S_UNAMESPACE:              bits.ReadCString(out usedNamespaces[usedNs++]);              bits.Position = stop;              break;              case SYM.S_END:              bits.Position = stop;              break;              default: {                //throw new PdbDebugException("Unknown SYM: {0}"' (SYM)rec);                bits.Position = stop;                break;              }          }        }
Magic Number,Microsoft.Cci.Pdb,PdbFunction,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFunction.cs,ReadCustomMetadata,The following statement contains a magic number: if (version != 4) {          throw new PdbDebugException("Unknown custom metadata item version: {0}"' version);        }
Magic Number,Microsoft.Cci.Pdb,PdbFunction,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFunction.cs,ReadCustomMetadata,The following statement contains a magic number: bits.Align(4);
Magic Number,Microsoft.Cci.Pdb,PdbFunction,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFunction.cs,ReadCustomMetadata,The following statement contains a magic number: switch (kind) {          case 0: this.ReadUsingInfo(bits); break;          case 1: break; // this.ReadForwardInfo(bits); break;          case 2: break; // this.ReadForwardedToModuleInfo(bits); break;          case 3: this.ReadIteratorLocals(bits); break;          case 4: this.ReadForwardIterator(bits); break;          default: throw new PdbDebugException("Unknown custom metadata item kind: {0}"' kind);        }
Magic Number,Microsoft.Cci.Pdb,PdbFunction,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFunction.cs,ReadCustomMetadata,The following statement contains a magic number: switch (kind) {          case 0: this.ReadUsingInfo(bits); break;          case 1: break; // this.ReadForwardInfo(bits); break;          case 2: break; // this.ReadForwardedToModuleInfo(bits); break;          case 3: this.ReadIteratorLocals(bits); break;          case 4: this.ReadForwardIterator(bits); break;          default: throw new PdbDebugException("Unknown custom metadata item kind: {0}"' kind);        }
Magic Number,Microsoft.Cci.Pdb,PdbFunction,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFunction.cs,ReadCustomMetadata,The following statement contains a magic number: switch (kind) {          case 0: this.ReadUsingInfo(bits); break;          case 1: break; // this.ReadForwardInfo(bits); break;          case 2: break; // this.ReadForwardedToModuleInfo(bits); break;          case 3: this.ReadIteratorLocals(bits); break;          case 4: this.ReadForwardIterator(bits); break;          default: throw new PdbDebugException("Unknown custom metadata item kind: {0}"' kind);        }
Magic Number,Microsoft.Cci,PdbReader,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\SourceLocationProvider.cs,GetUsedNamespace,The following statement contains a magic number: if (namespaceName.Length > 0 && namespaceName[0] == 'A') {          string[] parts = namespaceName.Split(' ');          if (parts.Length == 2) {            IName alias = this.host.NameTable.GetNameFor(parts[0].Substring(1));            IName nsName = this.host.NameTable.GetNameFor(parts[1].Substring(1));            return new UsedNamespace(alias' nsName);          }        } else if (namespaceName.Length > 0 && namespaceName[0] == 'U') {          IName nsName = this.host.NameTable.GetNameFor(namespaceName.Substring(1));          return new UsedNamespace(this.host.NameTable.EmptyName' nsName);        }
Missing Default,Microsoft.Cci.Pdb,PdbFile,C:\repos\vc3_Afterthought\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following switch statement is missing a default case: switch ((DEBUG_S_SUBSECTION)sig) {            case DEBUG_S_SUBSECTION.LINES: {                CV_LineSection sec;                  bits.ReadUInt32(out sec.off);                bits.ReadUInt16(out sec.sec);                bits.ReadUInt16(out sec.flags);                bits.ReadUInt32(out sec.cod);                int funcIndex = FindFunction(funcs' sec.sec' sec.off);                if (funcIndex < 0) break;                var func = funcs[funcIndex];                if (func.lines == null) {                  while (funcIndex > 0) {                    var f = funcs[funcIndex-1];                    if (f.lines != null || f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex--;                  }               } else {                  while (funcIndex < funcs.Length-1 && func.lines != null) {                    var f = funcs[funcIndex+1];                    if (f.segment != sec.sec || f.address != sec.off) break;                    func = f;                    funcIndex++;                  }                }                if (func.lines != null) break;                  // Count the line blocks.                int begSym = bits.Position;                int blocks = 0;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                  int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));                  bits.Position += linsiz;                  blocks++;                }                  func.lines = new PdbLines[blocks];                int block = 0;                  bits.Position = begSym;                while (bits.Position < endSym) {                  CV_SourceFile file;                  bits.ReadUInt32(out file.index);                  bits.ReadUInt32(out file.count);                  bits.ReadUInt32(out file.linsiz);   // Size of payload.                    PdbSource src = (PdbSource)checks[(int)file.index];                  PdbLines tmp = new PdbLines(src' file.count);                  func.lines[block++] = tmp;                  PdbLine[] lines = tmp.lines;                    int plin = bits.Position;                  int pcol = bits.Position + 8 * (int)file.count;                    for (int i = 0; i < file.count; i++) {                    CV_Line line;                    CV_Column column = new CV_Column();                      bits.Position = plin + 8 * i;                    bits.ReadUInt32(out line.offset);                    bits.ReadUInt32(out line.flags);                      uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;                    uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;                    //bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);                    if ((sec.flags & 1) != 0) {                      bits.Position = pcol + 4 * i;                      bits.ReadUInt16(out column.offColumnStart);                      bits.ReadUInt16(out column.offColumnEnd);                    }                      lines[i] = new PdbLine(line.offset'                                           lineBegin'                                           column.offColumnStart'                                           lineBegin+delta'                                           column.offColumnEnd);                  }                }                break;              }          }
