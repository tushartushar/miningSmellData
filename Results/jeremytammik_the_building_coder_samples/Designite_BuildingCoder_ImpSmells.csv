Implementation smell,Namespace,Class,File,Method,Description
Long Method,BuildingCoder,CmdColumnRound,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdColumnRound.cs,Execute,The method has 107 lines of code.
Long Method,BuildingCoder,CmdDimensionWallsFindRefs,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionWallsFindRefs.cs,Execute,The method has 235 lines of code.
Long Method,BuildingCoder,CmdExportImage,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdExportImage.cs,ExportToImage,The method has 106 lines of code.
Long Method,BuildingCoder,MepElementShapeV1,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdMepElementShape.cs,GetElementShape,The method has 138 lines of code.
Long Method,BuildingCoder,MepElementShapeVersion2,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdMepElementShape.cs,GetElementShape,The method has 124 lines of code.
Long Method,BuildingCoder,CmdMidCurve,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdMidCurve.cs,Execute,The method has 150 lines of code.
Long Method,BuildingCoder,CmdMirrorListAdded,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdMirror.cs,Execute,The method has 116 lines of code.
Long Method,BuildingCoder,CmdNewCrossFitting,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewCrossFitting.cs,Execute,The method has 145 lines of code.
Long Method,BuildingCoder,CmdNewTextNote,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewTextNote.cs,Execute,The method has 135 lines of code.
Long Method,BuildingCoder,CmdProjectParameterGuids,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdProjectParameterGuids.cs,Execute,The method has 205 lines of code.
Long Method,BuildingCoder,CmdRollingOffset,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdRollingOffset.cs,Execute,The method has 409 lines of code.
Long Method,BuildingCoder,NestedFamilyFunctions,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNestedFamilies.cs,GetFilteredNestedFamilyInstances,The method has 111 lines of code.
Long Method,BuildingCoder,CmdNestedInstanceGeo,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNestedInstanceGeo.cs,Execute,The method has 102 lines of code.
Long Method,BuildingCoder,CmdEditFloor,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdEditFloor.cs,Execute,The method has 106 lines of code.
Long Method,BuildingCoder,AssetPropertyPropertyDescriptor,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdGetMaterials.cs,GetTypeAndValue,The method has 131 lines of code.
Long Method,BuildingCoder,CmdNewLineLoad,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewLineLoad.cs,Execute,The method has 100 lines of code.
Long Method,BuildingCoder,CmdNewSpotElevation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewSpotElevation.cs,FindTopMostReference,The method has 128 lines of code.
Long Method,BuildingCoder,CmdNewSprinkler,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewSprinkler.cs,Execute,The method has 100 lines of code.
Long Method,BuildingCoder,CmdSheetSize,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSheetSize.cs,Execute,The method has 102 lines of code.
Long Method,BuildingCoder,CmdSheetToModel,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSheetToModel.cs,QTO_2_PlaceHoldersFromDWFMarkups,The method has 109 lines of code.
Long Method,BuildingCoder,CmdMiroTest2,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSheetToModel.cs,Execute,The method has 109 lines of code.
Long Method,BuildingCoder,CmdSlabBoundaryArea,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSlabBoundaryArea.cs,GetPlanarFaceOuterLoops,The method has 111 lines of code.
Long Method,BuildingCoder,CmdAlignTwoViews,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdViewsShowingElements.cs,Execute,The method has 134 lines of code.
Long Method,BuildingCoder,CmdWallOpeningProfiles,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallOpeningProfiles.cs,Execute,The method has 113 lines of code.
Long Method,BuildingCoder,CmdWallLayers,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallLayers.cs,Execute,The method has 103 lines of code.
Long Method,BuildingCoder,CmdWallTopFaces,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallTopFaces.cs,Execute,The method has 164 lines of code.
Long Method,BuildingCoder,CmdCropToRoom,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCropToRoom.cs,Execute,The method has 108 lines of code.
Long Method,BuildingCoder,CmdCopyWallType,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCopyWallType.cs,Execute,The method has 128 lines of code.
Complex Method,BuildingCoder,ScottWilsonVoodooMagic,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,GetInstanceEdgeFromSymbolRef,Cyclomatic complexity of the method is 9
Complex Method,BuildingCoder,ScottWilsonVoodooMagic,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,GetSpecialFamilyReference,Cyclomatic complexity of the method is 12
Complex Method,BuildingCoder,CmdDimensionWallsFindRefs,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionWallsFindRefs.cs,Execute,Cyclomatic complexity of the method is 10
Complex Method,BuildingCoder,MepElementShapeVersion2,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdMepElementShape.cs,ExtractSystemFromConnectors,Cyclomatic complexity of the method is 9
Complex Method,BuildingCoder,CmdMidCurve,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdMidCurve.cs,Execute,Cyclomatic complexity of the method is 8
Complex Method,BuildingCoder,CmdProjectParameterGuids,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdProjectParameterGuids.cs,AddProjectParameterBinding,Cyclomatic complexity of the method is 8
Complex Method,BuildingCoder,CmdProjectParameterGuids,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdProjectParameterGuids.cs,Execute,Cyclomatic complexity of the method is 8
Complex Method,BuildingCoder,NestedFamilyFunctions,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNestedFamilies.cs,GetFilteredNestedFamilyInstances,Cyclomatic complexity of the method is 10
Complex Method,BuildingCoder,AssetPropertyPropertyDescriptor,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdGetMaterials.cs,GetTypeAndValue,Cyclomatic complexity of the method is 8
Complex Method,BuildingCoder,CmdRemoveDwfLinks,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdRemoveDwfLinks.cs,RemoveDwfLinkUsingDelete,Cyclomatic complexity of the method is 9
Complex Method,BuildingCoder,CmdSetTangentLock,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSetTangentLock.cs,SetTangentLockInProfileSketch1,Cyclomatic complexity of the method is 10
Complex Method,BuildingCoder,CmdSetTangentLock,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSetTangentLock.cs,SetTangentLockInProfileSketch2,Cyclomatic complexity of the method is 12
Complex Method,BuildingCoder,CmdSlabBoundaryArea,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSlabBoundaryArea.cs,GetPlanarFaceOuterLoops,Cyclomatic complexity of the method is 11
Complex Method,BuildingCoder,CmdTransformedCoords,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdTransformedCoords.cs,Execute,Cyclomatic complexity of the method is 10
Complex Method,BuildingCoder,CmdWallOpeningProfiles,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallOpeningProfiles.cs,GetWallOpeningPlanarFaces,Cyclomatic complexity of the method is 9
Complex Method,BuildingCoder,CmdSlabBoundary,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSlabBoundary.cs,GetBoundary,Cyclomatic complexity of the method is 9
Complex Method,BuildingCoder,CmdWallProfile,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallProfile.cs,GetProfile,Cyclomatic complexity of the method is 9
Complex Method,BuildingCoder,CmdWallTopFaces,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallTopFaces.cs,Execute,Cyclomatic complexity of the method is 12
Complex Method,BuildingCoder,CmdCropToRoom,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCropToRoom.cs,SectionBox,Cyclomatic complexity of the method is 8
Complex Method,BuildingCoder,JtSelectorMulti<T>,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\JtSelectorMulti.cs,JtSelectorMulti,Cyclomatic complexity of the method is 8
Long Parameter List,BuildingCoder,CmdDimensionWallsIterateFaces,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionWallsIterateFaces.cs,CreateDimensionElement,The method has 5 parameters. Parameters: view' p1' r1' p2' r2
Long Parameter List,BuildingCoder,ElementData,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdLinkedFileElements.cs,ElementData,The method has 7 parameters. Parameters: path' elementName' id' x' y' z' uniqueId
Long Parameter List,BuildingCoder,CompatibilityMethods,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Util.cs,Create2,The method has 5 parameters. Parameters: definitions' doc' nome' tipo' visibilidade
Long Parameter List,BuildingCoder,CompatibilityMethods,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Util.cs,CreateWall2,The method has 8 parameters. Parameters: doc' curve' wallTypeId' levelId' height' offset' flip' structural
Long Identifier,BuildingCoder,CmdCategorySupportsTypeParameter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCategorySupportsTypeParameter.cs,,The length of the parameter _bicAllowsBoundParametersAsType is 31.
Long Identifier,BuildingCoder,CmdCategorySupportsTypeParameter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCategorySupportsTypeParameter.cs,,The length of the parameter _bicAllowsBoundParametersAsInstance is 35.
Long Identifier,BuildingCoder,CmdCategorySupportsTypeParameter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCategorySupportsTypeParameter.cs,,The length of the parameter _bicSupportsInstanceParameters is 30.
Long Identifier,BuildingCoder,CmdCollectorPerformance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,GetBeamsIntersectingTwoColumns,The length of the parameter intersectingStructuralFramingElements is 37.
Long Identifier,BuildingCoder,CmdFaceWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdFaceWall.cs,,The length of the parameter _conceptual_mass_template_path is 30.
Long Identifier,BuildingCoder,RenderAppearanceDescriptor,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdGetMaterials.cs,GetAssetProperties,The length of the parameter assetPropertyPropertyDescriptor is 31.
Long Identifier,BuildingCoder,CmdPlaceFamilyInstance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdPlaceFamilyInstance.cs,,The length of the parameter _place_one_single_instance_then_abort is 37.
Long Identifier,BuildingCoder,ParameterUnitConverter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\ParameterUnitConverter.cs,,The length of the parameter _map_parameter_type_to_unit_type is 32.
Long Identifier,BuildingCoder,SpellingErrorCorrector,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Util.cs,,The length of the parameter _external_definition_creation_options_type is 42.
Long Identifier,FilterPerformance,CmdCollectorPerformance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,GetBeamsIntersectingTwoColumns,The length of the parameter intersectingStructuralFramingElements is 37.
Long Statement,BuildingCoder,CmdCategorySupportsTypeParameter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCategorySupportsTypeParameter.cs,f,The length of the statement  "        if( BuiltInCategory.OST_MechanicalEquipment.Equals( (BuiltInCategory) BIC_AllowsBoundParametersAsType.OST_MechanicalEquipment ) ) " is 129.
Long Statement,BuildingCoder,ParamFilterTest,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,Execute,The length of the statement  "      //Parameter parameter = wall.get_Parameter( "Unconnected Height" ); // 2014' causes warning CS0618: 'Autodesk.Revit.DB.Element.get_Parameter(string)' is obsolete: 'This property is obsolete in Revit 2015' as more than one parameter can have the same name on a given element. Use Element.Parameters to obtain a complete list of parameters on this Element' or Element.GetParameters(String) to get a list of all parameters by name' or Element.LookupParameter(String) to return the first available parameter with the given name.' " is 525.
Long Statement,BuildingCoder,ParamFilterTest,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,Execute,The length of the statement  "      Parameter parameter = wall.get_Parameter( BuiltInParameter.WALL_USER_HEIGHT_PARAM ); // 2015' avoids warning' in language indepependent and more effective to look up " is 165.
Long Statement,BuildingCoder,CmdCoordsOfViewOnSheet,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCoordsOfViewOnSheet.cs,Execute,The length of the statement  "      //foreach( View v in currentSheet.Views ) // 2014 warning	'Autodesk.Revit.DB.ViewSheet.Views' is obsolete.  Use GetAllPlacedViews() instead. " is 140.
Long Statement,BuildingCoder,CmdDisallowJoin,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDisallowJoin.cs,Execute,The length of the statement  "        // wall.Location = lc; // Property or indexer 'Autodesk.Revit.Element.Location' cannot be assigned to -- it is read only " is 120.
Long Statement,BuildingCoder,CmdLibraryPaths,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdLibraryPaths.cs,Execute,The length of the statement  "      //string value = @"C:\Documents and Settings\All Users\Application Data\Autodesk\RAC 2010\Imperial Library\Detail Components"; // 2010 " is 134.
Long Statement,BuildingCoder,MepElementShapeV1,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdMepElementShape.cs,GetElementShape,The length of the statement  "              else if( size.Split( '/' ).Length == 3 ) // but if in imperial units size is in fractional inches format it has to be replaced by another regular expression " is 156.
Long Statement,BuildingCoder,CmdGetMaterials,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdGetMaterials.cs,ShowMaterialInfo,The length of the statement  "                                       // "Carpet (1)";// "Prism - Glass - Textured";// "Parking Stripe"; // "Prism 1";// "Brick' Common" ;// "Acoustic Ceiling Tile 24 x 48";  // "Aluminum" " is 150.
Long Statement,FilterPerformance,ParamFilterTest,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,Execute,The length of the statement  "      //Parameter parameter = wall.get_Parameter( "Unconnected Height" ); // 2014' causes warning CS0618: 'Autodesk.Revit.DB.Element.get_Parameter(string)' is obsolete: 'This property is obsolete in Revit 2015' as more than one parameter can have the same name on a given element. Use Element.Parameters to obtain a complete list of parameters on this Element' or Element.GetParameters(String) to get a list of all parameters by name' or Element.LookupParameter(String) to return the first available parameter with the given name.' " is 525.
Long Statement,FilterPerformance,ParamFilterTest,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,Execute,The length of the statement  "      Parameter parameter = wall.get_Parameter( BuiltInParameter.WALL_USER_HEIGHT_PARAM ); // 2015' avoids warning' in language indepependent and more effective to look up " is 165.
Complex Conditional,BuildingCoder,CmdCollectorPerformance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,IsElementHiddenInView,The conditional expression  "elBox.Min.X > viewBox.Max.X            || elBox.Max.X < viewBox.Min.X            || elBox.Min.Y > viewBox.Max.Y            || elBox.Max.Y < viewBox.Min.Y"  is complex.
Complex Conditional,BuildingCoder,MepElementShapeVersion2,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdMepElementShape.cs,GetElementShape,The conditional expression  "PartType.Tee == partType                || PartType.Cross == partType                || PartType.Pants == partType                || PartType.Wye == partType"  is complex.
Complex Conditional,BuildingCoder,CmdSetTangentLock,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSetTangentLock.cs,SetTangentLockInProfileSketch2,The conditional expression  "beforeId != null               && afterId != null               && ml.HasTangentJoin( 0' beforeId )               && ml.HasTangentJoin( 1' afterId )"  is complex.
Complex Conditional,FilterPerformance,CmdCollectorPerformance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,IsElementHiddenInView,The conditional expression  "elBox.Min.X > viewBox.Max.X            || elBox.Max.X < viewBox.Min.X            || elBox.Min.Y > viewBox.Max.Y            || elBox.Max.Y < viewBox.Min.Y"  is complex.
Empty Catch Block,BuildingCoder,CmdExportImage,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdExportImage.cs,ExportToImage,The method has an empty catch block.
Empty Catch Block,BuildingCoder,CmdInstallLocation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdInstallLocation.cs,Execute,The method has an empty catch block.
Empty Catch Block,BuildingCoder,CmdListSharedParams,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdListSharedParams.cs,SharedParamGuid,The method has an empty catch block.
Empty Catch Block,BuildingCoder,CmdDeleteUnusedRefPlanes,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDeleteUnusedRefPlanes.cs,Execute,The method has an empty catch block.
Empty Catch Block,BuildingCoder,CmdPickPoint3d,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdPickPoint3d.cs,PickFaceSetWorkPlaneAndPickPoint,The method has an empty catch block.
Empty Catch Block,BuildingCoder,CmdSlabBoundaryArea,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSlabBoundaryArea.cs,GetPlanarFaceOuterLoops,The method has an empty catch block.
Magic Number,BuildingCoder,CmdBoundingBox,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdBoundingBox.cs,Execute,The following statement contains a magic number: if( null == b )        {          Util.InfoMsg(            Util.ElementDescription( e )            + " has no bounding box." );        }        else        {          using( Transaction tx = new Transaction( doc ) )          {            tx.Start( "Draw Model Line Bounding Box Outline" );              Debug.Assert( b.Transform.IsIdentity'              "expected identity bounding box transform" );              string in_view = ( null == v )              ? "model space"              : "view " + v.Name;              Util.InfoMsg( string.Format(              "Element bounding box of {0} in "              + "{1} extends from {2} to {3}."'              Util.ElementDescription( e )'              in_view'              Util.PointString( b.Min )'              Util.PointString( b.Max ) ) );              Creator creator = new Creator( doc );              creator.DrawPolygon( new List<XYZ>(              Util.GetBottomCorners( b ) ) );              Transform rotation = Transform.CreateRotation(              XYZ.BasisZ' 60 * Math.PI / 180.0 );              b = RotateBoundingBox( b' rotation );              Util.InfoMsg( string.Format(              "Bounding box rotated by 60 degrees "              + "extends from {0} to {1}."'              Util.PointString( b.Min )'              Util.PointString( b.Max ) ) );              creator.DrawPolygon( new List<XYZ>(              Util.GetBottomCorners( b ) ) );              tx.Commit();          }        }
Magic Number,BuildingCoder,CmdBoundingBox,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdBoundingBox.cs,Execute,The following statement contains a magic number: if( null == b )        {          Util.InfoMsg(            Util.ElementDescription( e )            + " has no bounding box." );        }        else        {          using( Transaction tx = new Transaction( doc ) )          {            tx.Start( "Draw Model Line Bounding Box Outline" );              Debug.Assert( b.Transform.IsIdentity'              "expected identity bounding box transform" );              string in_view = ( null == v )              ? "model space"              : "view " + v.Name;              Util.InfoMsg( string.Format(              "Element bounding box of {0} in "              + "{1} extends from {2} to {3}."'              Util.ElementDescription( e )'              in_view'              Util.PointString( b.Min )'              Util.PointString( b.Max ) ) );              Creator creator = new Creator( doc );              creator.DrawPolygon( new List<XYZ>(              Util.GetBottomCorners( b ) ) );              Transform rotation = Transform.CreateRotation(              XYZ.BasisZ' 60 * Math.PI / 180.0 );              b = RotateBoundingBox( b' rotation );              Util.InfoMsg( string.Format(              "Bounding box rotated by 60 degrees "              + "extends from {0} to {1}."'              Util.PointString( b.Min )'              Util.PointString( b.Max ) ) );              creator.DrawPolygon( new List<XYZ>(              Util.GetBottomCorners( b ) ) );              tx.Commit();          }        }
Magic Number,BuildingCoder,ParamFilterTest,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,Execute,The following statement contains a magic number: FilterRule fRule          = new FilterDoubleRule( pvp' fnrv' 20' 1E-6 );
Magic Number,BuildingCoder,ParamFilterTest,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,Execute,The following statement contains a magic number: FilterRule fRule          = new FilterDoubleRule( pvp' fnrv' 20' 1E-6 );
Magic Number,BuildingCoder,CmdCollectorPerformance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,f3,The following statement contains a magic number: List<ElementFilter> a          = new List<ElementFilter>( 3 );
Magic Number,BuildingCoder,CmdCollectorPerformance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,f2,The following statement contains a magic number: Outline myOutLn = new Outline(          XYZ.Zero' new XYZ( 100' 100' 100 ) );
Magic Number,BuildingCoder,CmdCollectorPerformance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,f2,The following statement contains a magic number: Outline myOutLn = new Outline(          XYZ.Zero' new XYZ( 100' 100' 100 ) );
Magic Number,BuildingCoder,CmdCollectorPerformance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,f2,The following statement contains a magic number: Outline myOutLn = new Outline(          XYZ.Zero' new XYZ( 100' 100' 100 ) );
Magic Number,BuildingCoder,CmdCollectorPerformance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,f4,The following statement contains a magic number: ElementId ruleValId = new ElementId( 99 );
Magic Number,BuildingCoder,CmdCollectorPerformance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,f4,The following statement contains a magic number: double ruleValDb = 10;
Magic Number,BuildingCoder,CmdCollectorPerformance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,IsElementHiddenInView,The following statement contains a magic number: if( v.CropBoxActive )        {          BoundingBoxXYZ viewBox = v.CropBox;          BoundingBoxXYZ elBox = e.get_BoundingBox( v );            Transform transInv = v.CropBox.Transform.Inverse;            elBox.Max = transInv.OfPoint( elBox.Max );          elBox.Min = transInv.OfPoint( elBox.Min );            // The transform above might switch           // max and min values.            if( elBox.Min.X > elBox.Max.X )          {            XYZ tmpP = elBox.Min;            elBox.Min = new XYZ( elBox.Max.X' elBox.Min.Y' 0 );            elBox.Max = new XYZ( tmpP.X' elBox.Max.Y' 0 );          }            if( elBox.Min.Y > elBox.Max.Y )          {            XYZ tmpP = elBox.Min;            elBox.Min = new XYZ( elBox.Min.X' elBox.Max.Y' 0 );            elBox.Max = new XYZ( tmpP.X' elBox.Min.Y' 0 );          }            if( elBox.Min.X > viewBox.Max.X            || elBox.Max.X < viewBox.Min.X            || elBox.Min.Y > viewBox.Max.Y            || elBox.Max.Y < viewBox.Min.Y )          {            return true;          }          else          {            BoundingBoxXYZ inside = new BoundingBoxXYZ();              double x' y;              x = elBox.Max.X;              if( elBox.Max.X > viewBox.Max.X )              x = viewBox.Max.X;              y = elBox.Max.Y;              if( elBox.Max.Y > viewBox.Max.Y )              y = viewBox.Max.Y;              inside.Max = new XYZ( x' y' 0 );              x = elBox.Min.X;              if( elBox.Min.X < viewBox.Min.X )              x = viewBox.Min.X;              y = elBox.Min.Y;              if( elBox.Min.Y < viewBox.Min.Y )              y = viewBox.Min.Y;              inside.Min = new XYZ( x' y' 0 );              double eBBArea = ( elBox.Max.X - elBox.Min.X )              * ( elBox.Max.Y - elBox.Min.Y );              double einsideArea =              ( inside.Max.X - inside.Min.X )              * ( inside.Max.Y - inside.Min.Y );              double factor = einsideArea / eBBArea;              if( factor < 0.25 )              return true;          }        }
Magic Number,BuildingCoder,CmdCollectorPerformance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,RunBenchmark,The following statement contains a magic number: int maxLevel = 1000;
Magic Number,BuildingCoder,CmdCollectorPerformance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,RunBenchmark,The following statement contains a magic number: for( int i = 3; i < maxLevel; ++i )        {          CreateLevel( i );        }
Magic Number,BuildingCoder,CmdCollectorPerformance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,RunBenchmark,The following statement contains a magic number: int nRuns = 1000;
Magic Number,BuildingCoder,CmdCollectorPerformance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,RunBenchmark,The following statement contains a magic number: nRuns = 1000;
Magic Number,BuildingCoder,CmdCreateGableWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCreateGableWall.cs,Execute,The following statement contains a magic number: XYZ[] pts = new XYZ[] {          XYZ.Zero'          new XYZ( 20' 0' 0 )'          new XYZ( 20' 0' 15 )'          new XYZ( 10' 0' 30 )'          new XYZ( 0' 0' 15 )        };
Magic Number,BuildingCoder,CmdCreateGableWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCreateGableWall.cs,Execute,The following statement contains a magic number: XYZ[] pts = new XYZ[] {          XYZ.Zero'          new XYZ( 20' 0' 0 )'          new XYZ( 20' 0' 15 )'          new XYZ( 10' 0' 30 )'          new XYZ( 0' 0' 15 )        };
Magic Number,BuildingCoder,CmdCreateGableWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCreateGableWall.cs,Execute,The following statement contains a magic number: XYZ[] pts = new XYZ[] {          XYZ.Zero'          new XYZ( 20' 0' 0 )'          new XYZ( 20' 0' 15 )'          new XYZ( 10' 0' 30 )'          new XYZ( 0' 0' 15 )        };
Magic Number,BuildingCoder,CmdCreateGableWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCreateGableWall.cs,Execute,The following statement contains a magic number: XYZ[] pts = new XYZ[] {          XYZ.Zero'          new XYZ( 20' 0' 0 )'          new XYZ( 20' 0' 15 )'          new XYZ( 10' 0' 30 )'          new XYZ( 0' 0' 15 )        };
Magic Number,BuildingCoder,CmdCreateGableWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCreateGableWall.cs,Execute,The following statement contains a magic number: XYZ[] pts = new XYZ[] {          XYZ.Zero'          new XYZ( 20' 0' 0 )'          new XYZ( 20' 0' 15 )'          new XYZ( 10' 0' 30 )'          new XYZ( 0' 0' 15 )        };
Magic Number,BuildingCoder,CmdCreateGableWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCreateGableWall.cs,Execute,The following statement contains a magic number: XYZ[] pts = new XYZ[] {          XYZ.Zero'          new XYZ( 20' 0' 0 )'          new XYZ( 20' 0' 15 )'          new XYZ( 10' 0' 30 )'          new XYZ( 0' 0' 15 )        };
Magic Number,BuildingCoder,CmdCreateLineStyle,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCreateLineStyle.cs,CreateLineStyle,The following statement contains a magic number: using( Transaction t = new Transaction( doc ) )        {          t.Start( "Create LineStyle" );            // Add the new linestyle             Category newLineStyleCat = categories            .NewSubcategory( lineCat' "New LineStyle" );            doc.Regenerate();            // Set the linestyle properties           // (weight' color' pattern).            newLineStyleCat.SetLineWeight( 8'             GraphicsStyleType.Projection );            newLineStyleCat.LineColor = new Color(             0xFF' 0x00' 0x00 );            newLineStyleCat.SetLinePatternId(             linePatternElem.Id'             GraphicsStyleType.Projection );            t.Commit();        }
Magic Number,BuildingCoder,CmdDetailCurves,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDetailCurves.cs,Execute,The following statement contains a magic number: XYZ endPoint = new XYZ( 10' 10' 0 );
Magic Number,BuildingCoder,CmdDetailCurves,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDetailCurves.cs,Execute,The following statement contains a magic number: XYZ endPoint = new XYZ( 10' 10' 0 );
Magic Number,BuildingCoder,CmdDetailCurves,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDetailCurves.cs,Execute,The following statement contains a magic number: XYZ end1 = new XYZ( 10' 0' 0 );
Magic Number,BuildingCoder,CmdDetailCurves,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDetailCurves.cs,Execute,The following statement contains a magic number: XYZ pointOnCurve = new XYZ( 5' 5' 0 );
Magic Number,BuildingCoder,CmdDetailCurves,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDetailCurves.cs,Execute,The following statement contains a magic number: XYZ pointOnCurve = new XYZ( 5' 5' 0 );
Magic Number,BuildingCoder,CmdDetailCurves,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDetailCurves.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Create Detail Line and Arc" );            // Create a DetailLine element using the          // newly created geometry line and sketch plane            DetailLine line = creDoc.NewDetailCurve(            view' geomLine ) as DetailLine;            // Create a DetailArc element using the          // newly created geometry arc and sketch plane            DetailArc arc = creDoc.NewDetailCurve(            view' geomArc ) as DetailArc;            // Change detail curve colour.          // Initially' this only affects the newly          // created curves. However' when the view          // is refreshed' all detail curves will          // be updated.            GraphicsStyle gs = arc.LineStyle as GraphicsStyle;            gs.GraphicsStyleCategory.LineColor            = new Color( 250' 10' 10 );            tx.Commit();        }
Magic Number,BuildingCoder,CmdDetailCurves,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDetailCurves.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Create Detail Line and Arc" );            // Create a DetailLine element using the          // newly created geometry line and sketch plane            DetailLine line = creDoc.NewDetailCurve(            view' geomLine ) as DetailLine;            // Create a DetailArc element using the          // newly created geometry arc and sketch plane            DetailArc arc = creDoc.NewDetailCurve(            view' geomArc ) as DetailArc;            // Change detail curve colour.          // Initially' this only affects the newly          // created curves. However' when the view          // is refreshed' all detail curves will          // be updated.            GraphicsStyle gs = arc.LineStyle as GraphicsStyle;            gs.GraphicsStyleCategory.LineColor            = new Color( 250' 10' 10 );            tx.Commit();        }
Magic Number,BuildingCoder,CmdDetailCurves,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDetailCurves.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Create Detail Line and Arc" );            // Create a DetailLine element using the          // newly created geometry line and sketch plane            DetailLine line = creDoc.NewDetailCurve(            view' geomLine ) as DetailLine;            // Create a DetailArc element using the          // newly created geometry arc and sketch plane            DetailArc arc = creDoc.NewDetailCurve(            view' geomArc ) as DetailArc;            // Change detail curve colour.          // Initially' this only affects the newly          // created curves. However' when the view          // is refreshed' all detail curves will          // be updated.            GraphicsStyle gs = arc.LineStyle as GraphicsStyle;            gs.GraphicsStyleCategory.LineColor            = new Color( 250' 10' 10 );            tx.Commit();        }
Magic Number,BuildingCoder,ScottWilsonVoodooMagic,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,GetInstanceEdgeFromSymbolRef,The following statement contains a magic number: string stableRefInst = tokenList[3] + ":"          + tokenList[4] + ":" + tokenList[5];
Magic Number,BuildingCoder,ScottWilsonVoodooMagic,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,GetInstanceEdgeFromSymbolRef,The following statement contains a magic number: string stableRefInst = tokenList[3] + ":"          + tokenList[4] + ":" + tokenList[5];
Magic Number,BuildingCoder,ScottWilsonVoodooMagic,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,GetInstanceEdgeFromSymbolRef,The following statement contains a magic number: string stableRefInst = tokenList[3] + ":"          + tokenList[4] + ":" + tokenList[5];
Magic Number,BuildingCoder,ScottWilsonVoodooMagic,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,GetSpecialFamilyReference,The following statement contains a magic number: if( inst != null )      {        Document dbDoc = inst.Document;          Options geomOptions = dbDoc.Application.Create          .NewGeometryOptions();          if( geomOptions != null )        {          geomOptions.ComputeReferences = true;          geomOptions.DetailLevel = ViewDetailLevel.Undefined;          geomOptions.IncludeNonVisibleObjects = true;        }          GeometryElement gElement = inst.get_Geometry(          geomOptions );          GeometryInstance gInst = gElement.First()          as GeometryInstance;          String sampleStableRef = null;          if( gInst != null )        {          GeometryElement gSymbol = gInst            .GetSymbolGeometry();            if( gSymbol != null )          {            foreach( GeometryObject geomObj in gSymbol )            {              if( geomObj is Solid )              {                Solid solid = geomObj as Solid;                  if( solid.Faces.Size > 0 )                {                  Face face = solid.Faces.get_Item( 0 );                    sampleStableRef = face.Reference                    .ConvertToStableRepresentation(                      dbDoc );                    break;                }              }              else if( geomObj is Curve )              {                Curve curve = geomObj as Curve;                  sampleStableRef = curve.Reference                  .ConvertToStableRepresentation( dbDoc );                  break;              }              else if( geomObj is Point )              {                Point point = geomObj as Point;                  sampleStableRef = point.Reference                  .ConvertToStableRepresentation( dbDoc );                  break;              }            }          }            if( sampleStableRef != null )          {            String[] refTokens = sampleStableRef.Split(               new char[] { ':' } );              String customStableRef = refTokens[0] + ":"              + refTokens[1] + ":" + refTokens[2] + ":"              + refTokens[3] + ":" + idx.ToString();              indexRef = Reference              .ParseFromStableRepresentation(                 dbDoc' customStableRef );              GeometryObject geoObj = inst              .GetGeometryObjectFromReference(                 indexRef );              if( geoObj != null )            {              String finalToken = "";                if( geoObj is Edge )              {                finalToken = ":LINEAR";              }                if( geoObj is Face )              {                finalToken = ":SURFACE";              }                customStableRef += finalToken;                indexRef = Reference                .ParseFromStableRepresentation(                   dbDoc' customStableRef );            }            else            {              indexRef = null;            }          }        }        else        {          throw new Exception( "No Symbol Geometry found..." );        }      }
Magic Number,BuildingCoder,ScottWilsonVoodooMagic,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,GetSpecialFamilyReference,The following statement contains a magic number: if( inst != null )      {        Document dbDoc = inst.Document;          Options geomOptions = dbDoc.Application.Create          .NewGeometryOptions();          if( geomOptions != null )        {          geomOptions.ComputeReferences = true;          geomOptions.DetailLevel = ViewDetailLevel.Undefined;          geomOptions.IncludeNonVisibleObjects = true;        }          GeometryElement gElement = inst.get_Geometry(          geomOptions );          GeometryInstance gInst = gElement.First()          as GeometryInstance;          String sampleStableRef = null;          if( gInst != null )        {          GeometryElement gSymbol = gInst            .GetSymbolGeometry();            if( gSymbol != null )          {            foreach( GeometryObject geomObj in gSymbol )            {              if( geomObj is Solid )              {                Solid solid = geomObj as Solid;                  if( solid.Faces.Size > 0 )                {                  Face face = solid.Faces.get_Item( 0 );                    sampleStableRef = face.Reference                    .ConvertToStableRepresentation(                      dbDoc );                    break;                }              }              else if( geomObj is Curve )              {                Curve curve = geomObj as Curve;                  sampleStableRef = curve.Reference                  .ConvertToStableRepresentation( dbDoc );                  break;              }              else if( geomObj is Point )              {                Point point = geomObj as Point;                  sampleStableRef = point.Reference                  .ConvertToStableRepresentation( dbDoc );                  break;              }            }          }            if( sampleStableRef != null )          {            String[] refTokens = sampleStableRef.Split(               new char[] { ':' } );              String customStableRef = refTokens[0] + ":"              + refTokens[1] + ":" + refTokens[2] + ":"              + refTokens[3] + ":" + idx.ToString();              indexRef = Reference              .ParseFromStableRepresentation(                 dbDoc' customStableRef );              GeometryObject geoObj = inst              .GetGeometryObjectFromReference(                 indexRef );              if( geoObj != null )            {              String finalToken = "";                if( geoObj is Edge )              {                finalToken = ":LINEAR";              }                if( geoObj is Face )              {                finalToken = ":SURFACE";              }                customStableRef += finalToken;                indexRef = Reference                .ParseFromStableRepresentation(                   dbDoc' customStableRef );            }            else            {              indexRef = null;            }          }        }        else        {          throw new Exception( "No Symbol Geometry found..." );        }      }
Magic Number,BuildingCoder,Command,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,Execute,The following statement contains a magic number: WriteDimensionReferences( 161908 );
Magic Number,BuildingCoder,Command,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,Execute,The following statement contains a magic number: WriteElementGeometry( 161900 );
Magic Number,BuildingCoder,Command,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,WriteElementGeometry,The following statement contains a magic number: const double xReferenceLocation = 30;
Magic Number,BuildingCoder,Command,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,WriteElementGeometry,The following statement contains a magic number: Line vLine = Line.CreateBound( new XYZ( xReferenceLocation' 0' 0 )' new XYZ( xReferenceLocation' 20' 0 ) );
Magic Number,BuildingCoder,Command,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,WriteElementGeometry,The following statement contains a magic number: const double yReferenceLocation = -10;
Magic Number,BuildingCoder,Command,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,WriteElementGeometry,The following statement contains a magic number: Line hLine = Line.CreateBound( new XYZ( 0' yReferenceLocation' 0 )' new XYZ( 20' yReferenceLocation' 0 ) );
Magic Number,BuildingCoder,Command,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,WriteElementGeometry,The following statement contains a magic number: foreach( Curve curve in m_referencePlaneReferences )        {          DetailCurve targetLine = m_vLine;            Line line = (Line) curve;          XYZ lineStartPoint = line.GetEndPoint( 0 );          XYZ lineEndPoint = line.GetEndPoint( 1 );          XYZ direction = lineEndPoint - lineStartPoint;          Line dimensionLine = null;          if( Math.Abs( direction.Y ) < 0.0001 )          {            targetLine = m_hLine;            XYZ dimensionLineStart = new XYZ( lineStartPoint.X + 5' lineStartPoint.Y' 0 );            XYZ dimensionLineEnd = new XYZ( dimensionLineStart.X' dimensionLineStart.Y + 10' 0 );              dimensionLine = Line.CreateBound( dimensionLineStart' dimensionLineEnd );          }          else          {            targetLine = m_vLine;            XYZ dimensionLineStart = new XYZ( lineStartPoint.X' lineStartPoint.Y + 5' 0 );            XYZ dimensionLineEnd = new XYZ( dimensionLineStart.X + 10' dimensionLineStart.Y' 0 );            dimensionLine = Line.CreateBound( dimensionLineStart' dimensionLineEnd );          }            ReferenceArray references = new ReferenceArray();          references.Append( curve.Reference );          references.Append( targetLine.GeometryCurve.Reference );            Transaction t = new Transaction( m_doc' "Create dimension" );          t.Start();          m_doc.Create.NewDimension( m_targetView' dimensionLine' references );          t.Commit();        }
Magic Number,BuildingCoder,Command,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,WriteElementGeometry,The following statement contains a magic number: foreach( Curve curve in m_referencePlaneReferences )        {          DetailCurve targetLine = m_vLine;            Line line = (Line) curve;          XYZ lineStartPoint = line.GetEndPoint( 0 );          XYZ lineEndPoint = line.GetEndPoint( 1 );          XYZ direction = lineEndPoint - lineStartPoint;          Line dimensionLine = null;          if( Math.Abs( direction.Y ) < 0.0001 )          {            targetLine = m_hLine;            XYZ dimensionLineStart = new XYZ( lineStartPoint.X + 5' lineStartPoint.Y' 0 );            XYZ dimensionLineEnd = new XYZ( dimensionLineStart.X' dimensionLineStart.Y + 10' 0 );              dimensionLine = Line.CreateBound( dimensionLineStart' dimensionLineEnd );          }          else          {            targetLine = m_vLine;            XYZ dimensionLineStart = new XYZ( lineStartPoint.X' lineStartPoint.Y + 5' 0 );            XYZ dimensionLineEnd = new XYZ( dimensionLineStart.X + 10' dimensionLineStart.Y' 0 );            dimensionLine = Line.CreateBound( dimensionLineStart' dimensionLineEnd );          }            ReferenceArray references = new ReferenceArray();          references.Append( curve.Reference );          references.Append( targetLine.GeometryCurve.Reference );            Transaction t = new Transaction( m_doc' "Create dimension" );          t.Start();          m_doc.Create.NewDimension( m_targetView' dimensionLine' references );          t.Commit();        }
Magic Number,BuildingCoder,Command,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,WriteElementGeometry,The following statement contains a magic number: foreach( Curve curve in m_referencePlaneReferences )        {          DetailCurve targetLine = m_vLine;            Line line = (Line) curve;          XYZ lineStartPoint = line.GetEndPoint( 0 );          XYZ lineEndPoint = line.GetEndPoint( 1 );          XYZ direction = lineEndPoint - lineStartPoint;          Line dimensionLine = null;          if( Math.Abs( direction.Y ) < 0.0001 )          {            targetLine = m_hLine;            XYZ dimensionLineStart = new XYZ( lineStartPoint.X + 5' lineStartPoint.Y' 0 );            XYZ dimensionLineEnd = new XYZ( dimensionLineStart.X' dimensionLineStart.Y + 10' 0 );              dimensionLine = Line.CreateBound( dimensionLineStart' dimensionLineEnd );          }          else          {            targetLine = m_vLine;            XYZ dimensionLineStart = new XYZ( lineStartPoint.X' lineStartPoint.Y + 5' 0 );            XYZ dimensionLineEnd = new XYZ( dimensionLineStart.X + 10' dimensionLineStart.Y' 0 );            dimensionLine = Line.CreateBound( dimensionLineStart' dimensionLineEnd );          }            ReferenceArray references = new ReferenceArray();          references.Append( curve.Reference );          references.Append( targetLine.GeometryCurve.Reference );            Transaction t = new Transaction( m_doc' "Create dimension" );          t.Start();          m_doc.Create.NewDimension( m_targetView' dimensionLine' references );          t.Commit();        }
Magic Number,BuildingCoder,Command,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,WriteElementGeometry,The following statement contains a magic number: foreach( Curve curve in m_referencePlaneReferences )        {          DetailCurve targetLine = m_vLine;            Line line = (Line) curve;          XYZ lineStartPoint = line.GetEndPoint( 0 );          XYZ lineEndPoint = line.GetEndPoint( 1 );          XYZ direction = lineEndPoint - lineStartPoint;          Line dimensionLine = null;          if( Math.Abs( direction.Y ) < 0.0001 )          {            targetLine = m_hLine;            XYZ dimensionLineStart = new XYZ( lineStartPoint.X + 5' lineStartPoint.Y' 0 );            XYZ dimensionLineEnd = new XYZ( dimensionLineStart.X' dimensionLineStart.Y + 10' 0 );              dimensionLine = Line.CreateBound( dimensionLineStart' dimensionLineEnd );          }          else          {            targetLine = m_vLine;            XYZ dimensionLineStart = new XYZ( lineStartPoint.X' lineStartPoint.Y + 5' 0 );            XYZ dimensionLineEnd = new XYZ( dimensionLineStart.X + 10' dimensionLineStart.Y' 0 );            dimensionLine = Line.CreateBound( dimensionLineStart' dimensionLineEnd );          }            ReferenceArray references = new ReferenceArray();          references.Append( curve.Reference );          references.Append( targetLine.GeometryCurve.Reference );            Transaction t = new Transaction( m_doc' "Create dimension" );          t.Start();          m_doc.Create.NewDimension( m_targetView' dimensionLine' references );          t.Commit();        }
Magic Number,BuildingCoder,Command,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,WriteElementGeometry,The following statement contains a magic number: foreach( Curve curve in m_referencePlaneReferences )        {          DetailCurve targetLine = m_vLine;            Line line = (Line) curve;          XYZ lineStartPoint = line.GetEndPoint( 0 );          XYZ lineEndPoint = line.GetEndPoint( 1 );          XYZ direction = lineEndPoint - lineStartPoint;          Line dimensionLine = null;          if( Math.Abs( direction.Y ) < 0.0001 )          {            targetLine = m_hLine;            XYZ dimensionLineStart = new XYZ( lineStartPoint.X + 5' lineStartPoint.Y' 0 );            XYZ dimensionLineEnd = new XYZ( dimensionLineStart.X' dimensionLineStart.Y + 10' 0 );              dimensionLine = Line.CreateBound( dimensionLineStart' dimensionLineEnd );          }          else          {            targetLine = m_vLine;            XYZ dimensionLineStart = new XYZ( lineStartPoint.X' lineStartPoint.Y + 5' 0 );            XYZ dimensionLineEnd = new XYZ( dimensionLineStart.X + 10' dimensionLineStart.Y' 0 );            dimensionLine = Line.CreateBound( dimensionLineStart' dimensionLineEnd );          }            ReferenceArray references = new ReferenceArray();          references.Append( curve.Reference );          references.Append( targetLine.GeometryCurve.Reference );            Transaction t = new Transaction( m_doc' "Create dimension" );          t.Start();          m_doc.Create.NewDimension( m_targetView' dimensionLine' references );          t.Commit();        }
Magic Number,BuildingCoder,CmdDimensionInstanceOrigin,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,Execute,The following statement contains a magic number: if( Result.Failed == rc )        {          message = "We need at least two "            + "FamilyInstance elements in the model.";        }        else if( Result.Succeeded == rc )        {          IList<FamilyInstance> a = picker.Selected;            _opt = new Options();          _opt.ComputeReferences = true;          _opt.IncludeNonVisibleObjects = true;            XYZ[] pts = new XYZ[2];          Reference[] refs = new Reference[2];            pts[0] = ( a[0].Location as LocationPoint ).Point;          pts[1] = ( a[1].Location as LocationPoint ).Point;            refs[0] = GetFamilyInstancePointReference( a[0] );          refs[1] = GetFamilyInstancePointReference( a[1] );            CmdDimensionWallsIterateFaces            .CreateDimensionElement( doc.ActiveView'            pts[0]' refs[0]' pts[1]' refs[1] );        }
Magic Number,BuildingCoder,CmdDimensionInstanceOrigin,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,Execute,The following statement contains a magic number: if( Result.Failed == rc )        {          message = "We need at least two "            + "FamilyInstance elements in the model.";        }        else if( Result.Succeeded == rc )        {          IList<FamilyInstance> a = picker.Selected;            _opt = new Options();          _opt.ComputeReferences = true;          _opt.IncludeNonVisibleObjects = true;            XYZ[] pts = new XYZ[2];          Reference[] refs = new Reference[2];            pts[0] = ( a[0].Location as LocationPoint ).Point;          pts[1] = ( a[1].Location as LocationPoint ).Point;            refs[0] = GetFamilyInstancePointReference( a[0] );          refs[1] = GetFamilyInstancePointReference( a[1] );            CmdDimensionWallsIterateFaces            .CreateDimensionElement( doc.ActiveView'            pts[0]' refs[0]' pts[1]' refs[1] );        }
Magic Number,BuildingCoder,CmdDimensionInstanceOrigin,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,CreateVerticalDimensioning,The following statement contains a magic number: XYZ point3 = new XYZ( 417.8' 80.228' 46.8 );
Magic Number,BuildingCoder,CmdDimensionInstanceOrigin,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,CreateVerticalDimensioning,The following statement contains a magic number: XYZ point3 = new XYZ( 417.8' 80.228' 46.8 );
Magic Number,BuildingCoder,CmdDimensionInstanceOrigin,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,CreateVerticalDimensioning,The following statement contains a magic number: XYZ point3 = new XYZ( 417.8' 80.228' 46.8 );
Magic Number,BuildingCoder,CmdDimensionInstanceOrigin,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,CreateVerticalDimensioning,The following statement contains a magic number: XYZ point4 = new XYZ( 417.8' 80.811' 46.3 );
Magic Number,BuildingCoder,CmdDimensionInstanceOrigin,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,CreateVerticalDimensioning,The following statement contains a magic number: XYZ point4 = new XYZ( 417.8' 80.811' 46.3 );
Magic Number,BuildingCoder,CmdDimensionInstanceOrigin,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,CreateVerticalDimensioning,The following statement contains a magic number: XYZ point4 = new XYZ( 417.8' 80.811' 46.3 );
Magic Number,BuildingCoder,CmdDimensionInstanceOrigin,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,CreateVerticalDimensioning,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "tx" );            DetailLine line3 = doc.Create.NewDetailCurve(             viewSection' geomLine3 ) as DetailLine;            DetailLine dummy = doc.Create.NewDetailCurve(             viewSection' dummyLine ) as DetailLine;            ReferenceArray refArray = new ReferenceArray();          refArray.Append( dummy.GeometryCurve.Reference );          refArray.Append( line3.GeometryCurve.GetEndPointReference( 0 ) );          refArray.Append( line3.GeometryCurve.GetEndPointReference( 1 ) );          XYZ dimPoint1 = new XYZ( 417.8' 80.118' 46.8 );          XYZ dimPoint2 = new XYZ( 417.8' 80.118' 46.3 );          Line dimLine3 = Line.CreateBound( dimPoint1' dimPoint2 );            Dimension dim = doc.Create.NewDimension(             viewSection' dimLine3' refArray );            doc.Delete( dummy.Id );          tx.Commit();        }
Magic Number,BuildingCoder,CmdDimensionInstanceOrigin,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,CreateVerticalDimensioning,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "tx" );            DetailLine line3 = doc.Create.NewDetailCurve(             viewSection' geomLine3 ) as DetailLine;            DetailLine dummy = doc.Create.NewDetailCurve(             viewSection' dummyLine ) as DetailLine;            ReferenceArray refArray = new ReferenceArray();          refArray.Append( dummy.GeometryCurve.Reference );          refArray.Append( line3.GeometryCurve.GetEndPointReference( 0 ) );          refArray.Append( line3.GeometryCurve.GetEndPointReference( 1 ) );          XYZ dimPoint1 = new XYZ( 417.8' 80.118' 46.8 );          XYZ dimPoint2 = new XYZ( 417.8' 80.118' 46.3 );          Line dimLine3 = Line.CreateBound( dimPoint1' dimPoint2 );            Dimension dim = doc.Create.NewDimension(             viewSection' dimLine3' refArray );            doc.Delete( dummy.Id );          tx.Commit();        }
Magic Number,BuildingCoder,CmdDimensionInstanceOrigin,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,CreateVerticalDimensioning,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "tx" );            DetailLine line3 = doc.Create.NewDetailCurve(             viewSection' geomLine3 ) as DetailLine;            DetailLine dummy = doc.Create.NewDetailCurve(             viewSection' dummyLine ) as DetailLine;            ReferenceArray refArray = new ReferenceArray();          refArray.Append( dummy.GeometryCurve.Reference );          refArray.Append( line3.GeometryCurve.GetEndPointReference( 0 ) );          refArray.Append( line3.GeometryCurve.GetEndPointReference( 1 ) );          XYZ dimPoint1 = new XYZ( 417.8' 80.118' 46.8 );          XYZ dimPoint2 = new XYZ( 417.8' 80.118' 46.3 );          Line dimLine3 = Line.CreateBound( dimPoint1' dimPoint2 );            Dimension dim = doc.Create.NewDimension(             viewSection' dimLine3' refArray );            doc.Delete( dummy.Id );          tx.Commit();        }
Magic Number,BuildingCoder,CmdDimensionInstanceOrigin,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,CreateVerticalDimensioning,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "tx" );            DetailLine line3 = doc.Create.NewDetailCurve(             viewSection' geomLine3 ) as DetailLine;            DetailLine dummy = doc.Create.NewDetailCurve(             viewSection' dummyLine ) as DetailLine;            ReferenceArray refArray = new ReferenceArray();          refArray.Append( dummy.GeometryCurve.Reference );          refArray.Append( line3.GeometryCurve.GetEndPointReference( 0 ) );          refArray.Append( line3.GeometryCurve.GetEndPointReference( 1 ) );          XYZ dimPoint1 = new XYZ( 417.8' 80.118' 46.8 );          XYZ dimPoint2 = new XYZ( 417.8' 80.118' 46.3 );          Line dimLine3 = Line.CreateBound( dimPoint1' dimPoint2 );            Dimension dim = doc.Create.NewDimension(             viewSection' dimLine3' refArray );            doc.Delete( dummy.Id );          tx.Commit();        }
Magic Number,BuildingCoder,CmdDimensionInstanceOrigin,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,CreateVerticalDimensioning,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "tx" );            DetailLine line3 = doc.Create.NewDetailCurve(             viewSection' geomLine3 ) as DetailLine;            DetailLine dummy = doc.Create.NewDetailCurve(             viewSection' dummyLine ) as DetailLine;            ReferenceArray refArray = new ReferenceArray();          refArray.Append( dummy.GeometryCurve.Reference );          refArray.Append( line3.GeometryCurve.GetEndPointReference( 0 ) );          refArray.Append( line3.GeometryCurve.GetEndPointReference( 1 ) );          XYZ dimPoint1 = new XYZ( 417.8' 80.118' 46.8 );          XYZ dimPoint2 = new XYZ( 417.8' 80.118' 46.3 );          Line dimLine3 = Line.CreateBound( dimPoint1' dimPoint2 );            Dimension dim = doc.Create.NewDimension(             viewSection' dimLine3' refArray );            doc.Delete( dummy.Id );          tx.Commit();        }
Magic Number,BuildingCoder,CmdDimensionInstanceOrigin,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionInstanceOrigin.cs,CreateVerticalDimensioning,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "tx" );            DetailLine line3 = doc.Create.NewDetailCurve(             viewSection' geomLine3 ) as DetailLine;            DetailLine dummy = doc.Create.NewDetailCurve(             viewSection' dummyLine ) as DetailLine;            ReferenceArray refArray = new ReferenceArray();          refArray.Append( dummy.GeometryCurve.Reference );          refArray.Append( line3.GeometryCurve.GetEndPointReference( 0 ) );          refArray.Append( line3.GeometryCurve.GetEndPointReference( 1 ) );          XYZ dimPoint1 = new XYZ( 417.8' 80.118' 46.8 );          XYZ dimPoint2 = new XYZ( 417.8' 80.118' 46.3 );          Line dimLine3 = Line.CreateBound( dimPoint1' dimPoint2 );            Dimension dim = doc.Create.NewDimension(             viewSection' dimLine3' refArray );            doc.Delete( dummy.Id );          tx.Commit();        }
Magic Number,BuildingCoder,CmdDimensionWallsFindRefs,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionWallsFindRefs.cs,Execute,The following statement contains a magic number: Wall[] walls = new Wall[2];
Magic Number,BuildingCoder,CmdDimensionWallsFindRefs,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionWallsFindRefs.cs,Execute,The following statement contains a magic number: List<int> ids = new List<int>( 2 );
Magic Number,BuildingCoder,CmdDimensionWallsFindRefs,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionWallsFindRefs.cs,Execute,The following statement contains a magic number: XYZ[] pts = new XYZ[2];
Magic Number,BuildingCoder,CmdDimensionWallsFindRefs,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionWallsFindRefs.cs,Execute,The following statement contains a magic number: Line[] lines = new Line[2];
Magic Number,BuildingCoder,CmdDimensionWallsIterateFaces,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionWallsIterateFaces.cs,CreateLinearDimension,The following statement contains a magic number: XYZ pt1 = new XYZ( 5' 5' 0 );
Magic Number,BuildingCoder,CmdDimensionWallsIterateFaces,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionWallsIterateFaces.cs,CreateLinearDimension,The following statement contains a magic number: XYZ pt1 = new XYZ( 5' 5' 0 );
Magic Number,BuildingCoder,CmdDimensionWallsIterateFaces,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionWallsIterateFaces.cs,CreateLinearDimension,The following statement contains a magic number: XYZ pt2 = new XYZ( 5' 10' 0 );
Magic Number,BuildingCoder,CmdDimensionWallsIterateFaces,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionWallsIterateFaces.cs,CreateLinearDimension,The following statement contains a magic number: XYZ pt2 = new XYZ( 5' 10' 0 );
Magic Number,BuildingCoder,CmdDimensionWallsIterateFaces,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionWallsIterateFaces.cs,CreateLinearDimension,The following statement contains a magic number: pt1 = new XYZ( 10' 5' 0 );
Magic Number,BuildingCoder,CmdDimensionWallsIterateFaces,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionWallsIterateFaces.cs,CreateLinearDimension,The following statement contains a magic number: pt1 = new XYZ( 10' 5' 0 );
Magic Number,BuildingCoder,CmdDimensionWallsIterateFaces,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionWallsIterateFaces.cs,CreateLinearDimension,The following statement contains a magic number: pt2 = new XYZ( 10' 10' 0 );
Magic Number,BuildingCoder,CmdDimensionWallsIterateFaces,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionWallsIterateFaces.cs,CreateLinearDimension,The following statement contains a magic number: pt2 = new XYZ( 10' 10' 0 );
Magic Number,BuildingCoder,CmdDimensionWallsIterateFaces,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionWallsIterateFaces.cs,CreateLinearDimension,The following statement contains a magic number: pt1 = new XYZ( 5' 10' 0 );
Magic Number,BuildingCoder,CmdDimensionWallsIterateFaces,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionWallsIterateFaces.cs,CreateLinearDimension,The following statement contains a magic number: pt1 = new XYZ( 5' 10' 0 );
Magic Number,BuildingCoder,CmdDimensionWallsIterateFaces,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionWallsIterateFaces.cs,CreateLinearDimension,The following statement contains a magic number: pt2 = new XYZ( 10' 10' 0 );
Magic Number,BuildingCoder,CmdDimensionWallsIterateFaces,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionWallsIterateFaces.cs,CreateLinearDimension,The following statement contains a magic number: pt2 = new XYZ( 10' 10' 0 );
Magic Number,BuildingCoder,CmdDimensionWallsIterateFaces,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionWallsIterateFaces.cs,Execute,The following statement contains a magic number: List<Wall> walls = new List<Wall>( 2 );
Magic Number,BuildingCoder,CmdDimensionWallsIterateFaces,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionWallsIterateFaces.cs,Execute,The following statement contains a magic number: if( 2 != walls.Count )        {          message = _prompt;          return Result.Failed;        }
Magic Number,BuildingCoder,CmdDimensionWallsIterateFaces,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionWallsIterateFaces.cs,Execute,The following statement contains a magic number: List<Line> lines = new List<Line>( 2 );
Magic Number,BuildingCoder,CmdDimensionWallsIterateFaces,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionWallsIterateFaces.cs,Execute,The following statement contains a magic number: List<XYZ> midpoints = new List<XYZ>( 2 );
Magic Number,BuildingCoder,CmdDimensionWallsIterateFaces,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDimensionWallsIterateFaces.cs,Execute,The following statement contains a magic number: List<Face> faces = new List<Face>( 2 );
Magic Number,BuildingCoder,CmdDisallowJoin,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDisallowJoin.cs,Execute,The following statement contains a magic number: if( null == wall )        {          message = "Please select a wall.";        }        else        {          JoinType [] a1 = ( JoinType [] ) Enum.GetValues( typeof( JoinType ) );          List<JoinType> a = new List<JoinType>( (JoinType[]) Enum.GetValues( typeof( JoinType ) ) );          int n = a.Count;            LocationCurve lc = wall.Location as LocationCurve;            s = Util.ElementDescription( wall ) + ":\n";            /*for( int i = 0; i < 2; ++i )          {            JoinType jt = lc.get_JoinType( i );            int j = a.IndexOf( jt ) + 1;            JoinType jtnew = a[ j < n ? j : 0];            lc.set_JoinType( j' jtnew );            s += string.Format(              "\nChanged join type at {0} from {1} to {2}."'              ( 0 == i ? "start" : "end" )' jt' jtnew );          }          // wall.Location = lc; // Property or indexer 'Autodesk.Revit.Element.Location' cannot be assigned to -- it is read only          */            using ( Transaction t = new Transaction( doc ) )          {            t.Start( "Set Wall Join Type" );              for ( int i = 0; i < 2; ++i )            {              JoinType jt = ( (LocationCurve) wall.Location ).get_JoinType( i );              int j = a.IndexOf( jt ) + 1;              JoinType jtnew = a[j < n ? j : 0];              ( (LocationCurve) wall.Location ).set_JoinType( j' jtnew );              s += string.Format(                "\nChanged join type at {0} from {1} to {2}."'                ( 0 == i ? "start" : "end" )' jt' jtnew );            }            t.Commit();          }        }
Magic Number,BuildingCoder,CmdDuplicateElements,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDuplicateElements.cs,Execute,The following statement contains a magic number: XYZ newPoint = new XYZ( p.X' p.Y + 10' p.Z );
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: Debug.Assert( 2 == (int) DisplayUnitType.DUT_MILLIMETERS' _s );
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: Debug.Assert( 3 == (int) DisplayUnitType.DUT_DECIMAL_FEET' _s );
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: Debug.Assert( 4 == (int) DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES' _s );
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: Debug.Assert( 5 == (int) DisplayUnitType.DUT_FRACTIONAL_INCHES' _s );
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: Debug.Assert( 6 == (int) DisplayUnitType.DUT_DECIMAL_INCHES' _s );
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: Debug.Assert( 7 == (int) DisplayUnitType.DUT_ACRES' _s );
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: Debug.Assert( 8 == (int) DisplayUnitType.DUT_HECTARES' _s );
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: Debug.Assert( 9 == (int) DisplayUnitType.DUT_METERS_CENTIMETERS' _s );
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: Debug.Assert( 10 == (int) DisplayUnitType.DUT_CUBIC_YARDS' _s );
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: Debug.Assert( 11 == (int) DisplayUnitType.DUT_SQUARE_FEET' _s );
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: Debug.Assert( 12 == (int) DisplayUnitType.DUT_SQUARE_METERS' _s );
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: Debug.Assert( 13 == (int) DisplayUnitType.DUT_CUBIC_FEET' _s );
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: Debug.Assert( 14 == (int) DisplayUnitType.DUT_CUBIC_METERS' _s );
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: Debug.Assert( 15 == (int) DisplayUnitType.DUT_DECIMAL_DEGREES' _s );
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: Debug.Assert( 16 == (int) DisplayUnitType.DUT_DEGREES_AND_MINUTES' _s );
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: Debug.Assert( 17 == (int) DisplayUnitType.DUT_GENERAL' _s );
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: Debug.Assert( 18 == (int) DisplayUnitType.DUT_FIXED' _s );
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: Debug.Assert( 19 == (int) DisplayUnitType.DUT_PERCENTAGE' _s );
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: Debug.Assert( 20 == (int) DisplayUnitType.DUT_SQUARE_INCHES' _s );
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: Debug.Assert( 21 == (int) DisplayUnitType.DUT_SQUARE_CENTIMETERS' _s );
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: Debug.Assert( 22 == (int) DisplayUnitType.DUT_SQUARE_MILLIMETERS' _s );
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: Debug.Assert( 23 == (int) DisplayUnitType.DUT_CUBIC_INCHES' _s );
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: Debug.Assert( 24 == (int) DisplayUnitType.DUT_CUBIC_CENTIMETERS' _s );
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: Debug.Assert( 25 == (int) DisplayUnitType.DUT_CUBIC_MILLIMETERS' _s );
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: Debug.Assert( 26 == (int) DisplayUnitType.DUT_LITERS' _s );
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: for( DisplayUnitType i = DisplayUnitType          .DUT_METERS; i < n; ++i )        {          List<string> uts = new List<string>(            map_dut_to_ut[i]              .Select<UnitType' string>(                u => u.ToString().Substring( 3 ) ) );            int m = uts.Count;            unit_types = 4 > m            ? string.Join( "' "' uts )            : string.Format( "{0}' {1} and {2} more"'              uts[0]' uts[1]' m - 2 );            valid_unit_symbols = string.Join( "' "'            FormatOptions.GetValidUnitSymbols( i )              .Where( u => UnitSymbolType.UST_NONE != u )              .Select<UnitSymbolType' string>(                u => LabelUtils.GetLabelFor( u )                  + "/" + Util.UnitSymbolTypeString( u ) ) );            Debug.Print( "{0'6} - {1} - {2}: {3}"'            Util.DisplayUnitTypeAbbreviation[(int) i]'            LabelUtils.GetLabelFor( i )'            unit_types'            //i            //UnitFormatUtils.Format( UnitType. ???            //UnitUtils.ConvertFromInternalUnits( 1' i )'            valid_unit_symbols );        }
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: for( DisplayUnitType i = DisplayUnitType          .DUT_METERS; i < n; ++i )        {          List<string> uts = new List<string>(            map_dut_to_ut[i]              .Select<UnitType' string>(                u => u.ToString().Substring( 3 ) ) );            int m = uts.Count;            unit_types = 4 > m            ? string.Join( "' "' uts )            : string.Format( "{0}' {1} and {2} more"'              uts[0]' uts[1]' m - 2 );            valid_unit_symbols = string.Join( "' "'            FormatOptions.GetValidUnitSymbols( i )              .Where( u => UnitSymbolType.UST_NONE != u )              .Select<UnitSymbolType' string>(                u => LabelUtils.GetLabelFor( u )                  + "/" + Util.UnitSymbolTypeString( u ) ) );            Debug.Print( "{0'6} - {1} - {2}: {3}"'            Util.DisplayUnitTypeAbbreviation[(int) i]'            LabelUtils.GetLabelFor( i )'            unit_types'            //i            //UnitFormatUtils.Format( UnitType. ???            //UnitUtils.ConvertFromInternalUnits( 1' i )'            valid_unit_symbols );        }
Magic Number,BuildingCoder,CmdDutAbbreviation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdDutAbbreviation.cs,Execute,The following statement contains a magic number: for( DisplayUnitType i = DisplayUnitType          .DUT_METERS; i < n; ++i )        {          List<string> uts = new List<string>(            map_dut_to_ut[i]              .Select<UnitType' string>(                u => u.ToString().Substring( 3 ) ) );            int m = uts.Count;            unit_types = 4 > m            ? string.Join( "' "' uts )            : string.Format( "{0}' {1} and {2} more"'              uts[0]' uts[1]' m - 2 );            valid_unit_symbols = string.Join( "' "'            FormatOptions.GetValidUnitSymbols( i )              .Where( u => UnitSymbolType.UST_NONE != u )              .Select<UnitSymbolType' string>(                u => LabelUtils.GetLabelFor( u )                  + "/" + Util.UnitSymbolTypeString( u ) ) );            Debug.Print( "{0'6} - {1} - {2}: {3}"'            Util.DisplayUnitTypeAbbreviation[(int) i]'            LabelUtils.GetLabelFor( i )'            unit_types'            //i            //UnitFormatUtils.Format( UnitType. ???            //UnitUtils.ConvertFromInternalUnits( 1' i )'            valid_unit_symbols );        }
Magic Number,BuildingCoder,CmdEllipticalArc,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdEllipticalArc.cs,CreateEllipse,The following statement contains a magic number: double radX = 30;
Magic Number,BuildingCoder,CmdEllipticalArc,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdEllipticalArc.cs,CreateEllipse,The following statement contains a magic number: double radY = 50;
Magic Number,BuildingCoder,CmdEllipticalArc,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdEllipticalArc.cs,CreateEllipse,The following statement contains a magic number: double param1 = 2 * Math.PI;
Magic Number,BuildingCoder,CmdEllipticalArc,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdEllipticalArc.cs,CreateEllipse,The following statement contains a magic number: double targetAngle = Math.PI / 3.0;
Magic Number,BuildingCoder,CmdExportImage,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdExportImage.cs,SetWhiteRenderBackground,The following statement contains a magic number: cbs.Color = new Color( 255' 0' 0 );
Magic Number,BuildingCoder,CmdExportImage,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdExportImage.cs,ExportToImage,The following statement contains a magic number: try        {    #if !VERSION2014      var direction = new XYZ(-1' 1' -1);      var view3D = doc.IsFamilyDocument        ? doc.FamilyCreate.NewView3D(direction)        : doc.Create.NewView3D(direction);  #else          var collector = new FilteredElementCollector(            doc );            var viewFamilyType = collector            .OfClass( typeof( ViewFamilyType ) )            .OfType<ViewFamilyType>()            .FirstOrDefault( x =>              x.ViewFamily == ViewFamily.ThreeDimensional );            var view3D = ( viewFamilyType != null )          ? View3D.CreateIsometric( doc' viewFamilyType.Id )          : null;    #endif // VERSION2014            if( view3D != null )          {            // Ensure white background.              Color white = new Color( 255' 255' 255 );              view3D.SetBackground(              ViewDisplayBackground.CreateGradient(                white' white' white ) );              views.Add( view3D.Id );              var graphicDisplayOptions              = view3D.get_Parameter(                BuiltInParameter.MODEL_GRAPHICS_STYLE );              // Settings for best quality              graphicDisplayOptions.Set( 6 );          }        }        catch( Autodesk.Revit.Exceptions          .InvalidOperationException )        {        }
Magic Number,BuildingCoder,CmdExportImage,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdExportImage.cs,ExportToImage,The following statement contains a magic number: try        {    #if !VERSION2014      var direction = new XYZ(-1' 1' -1);      var view3D = doc.IsFamilyDocument        ? doc.FamilyCreate.NewView3D(direction)        : doc.Create.NewView3D(direction);  #else          var collector = new FilteredElementCollector(            doc );            var viewFamilyType = collector            .OfClass( typeof( ViewFamilyType ) )            .OfType<ViewFamilyType>()            .FirstOrDefault( x =>              x.ViewFamily == ViewFamily.ThreeDimensional );            var view3D = ( viewFamilyType != null )          ? View3D.CreateIsometric( doc' viewFamilyType.Id )          : null;    #endif // VERSION2014            if( view3D != null )          {            // Ensure white background.              Color white = new Color( 255' 255' 255 );              view3D.SetBackground(              ViewDisplayBackground.CreateGradient(                white' white' white ) );              views.Add( view3D.Id );              var graphicDisplayOptions              = view3D.get_Parameter(                BuiltInParameter.MODEL_GRAPHICS_STYLE );              // Settings for best quality              graphicDisplayOptions.Set( 6 );          }        }        catch( Autodesk.Revit.Exceptions          .InvalidOperationException )        {        }
Magic Number,BuildingCoder,CmdExportImage,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdExportImage.cs,ExportToImage,The following statement contains a magic number: try        {    #if !VERSION2014      var direction = new XYZ(-1' 1' -1);      var view3D = doc.IsFamilyDocument        ? doc.FamilyCreate.NewView3D(direction)        : doc.Create.NewView3D(direction);  #else          var collector = new FilteredElementCollector(            doc );            var viewFamilyType = collector            .OfClass( typeof( ViewFamilyType ) )            .OfType<ViewFamilyType>()            .FirstOrDefault( x =>              x.ViewFamily == ViewFamily.ThreeDimensional );            var view3D = ( viewFamilyType != null )          ? View3D.CreateIsometric( doc' viewFamilyType.Id )          : null;    #endif // VERSION2014            if( view3D != null )          {            // Ensure white background.              Color white = new Color( 255' 255' 255 );              view3D.SetBackground(              ViewDisplayBackground.CreateGradient(                white' white' white ) );              views.Add( view3D.Id );              var graphicDisplayOptions              = view3D.get_Parameter(                BuiltInParameter.MODEL_GRAPHICS_STYLE );              // Settings for best quality              graphicDisplayOptions.Set( 6 );          }        }        catch( Autodesk.Revit.Exceptions          .InvalidOperationException )        {        }
Magic Number,BuildingCoder,CmdExportImage,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdExportImage.cs,ExportToImage,The following statement contains a magic number: try        {    #if !VERSION2014      var direction = new XYZ(-1' 1' -1);      var view3D = doc.IsFamilyDocument        ? doc.FamilyCreate.NewView3D(direction)        : doc.Create.NewView3D(direction);  #else          var collector = new FilteredElementCollector(            doc );            var viewFamilyType = collector            .OfClass( typeof( ViewFamilyType ) )            .OfType<ViewFamilyType>()            .FirstOrDefault( x =>              x.ViewFamily == ViewFamily.ThreeDimensional );            var view3D = ( viewFamilyType != null )          ? View3D.CreateIsometric( doc' viewFamilyType.Id )          : null;    #endif // VERSION2014            if( view3D != null )          {            // Ensure white background.              Color white = new Color( 255' 255' 255 );              view3D.SetBackground(              ViewDisplayBackground.CreateGradient(                white' white' white ) );              views.Add( view3D.Id );              var graphicDisplayOptions              = view3D.get_Parameter(                BuiltInParameter.MODEL_GRAPHICS_STYLE );              // Settings for best quality              graphicDisplayOptions.Set( 6 );          }        }        catch( Autodesk.Revit.Exceptions          .InvalidOperationException )        {        }
Magic Number,BuildingCoder,CmdExportImage,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdExportImage.cs,ExportToImage3,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Export Image" );            string desktop_path = Environment.GetFolderPath(             Environment.SpecialFolder.Desktop );            View view = doc.ActiveView;            string filepath = Path.Combine( desktop_path'             view.Name );            ImageExportOptions img = new ImageExportOptions();            img.ZoomType = ZoomFitType.FitToPage;          img.PixelSize = 32;          img.ImageResolution = ImageResolution.DPI_600;          img.FitDirection = FitDirectionType.Horizontal;          img.ExportRange = ExportRange.CurrentView;          img.HLRandWFViewsFileType = ImageFileType.PNG;          img.FilePath = filepath;          img.ShadowViewsFileType = ImageFileType.PNG;            doc.ExportImage( img );            tx.RollBack();            filepath = Path.ChangeExtension(             filepath' "png" );            Process.Start( filepath );            r = Result.Succeeded;        }
Magic Number,BuildingCoder,CmdExportSolidToSat,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdExportSolidToSat.cs,Execute,The following statement contains a magic number: if( 2 != floors.Count )        {          message = "Please create two intersected floors";          return Result.Failed;        }
Magic Number,BuildingCoder,CreateWallsAutomaticallyCommand,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdFaceWall.cs,CreateDoor,The following statement contains a magic number: var position = locationCurve.Curve.Evaluate(          0.5' true );
Magic Number,BuildingCoder,CmdFaceWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdFaceWall.cs,CreateMassExtrusion,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Create Mass" );            // Create profile            ReferenceArray refar = new ReferenceArray();            XYZ[] pts = new XYZ[] {          new XYZ( -10' -10' 0 )'          new XYZ( +10' -10' 0 )'          new XYZ( +10' +10' 0 )'          new XYZ( -10' +10' 0 ) };            int j' n = pts.Length;            for( int i = 0; i < n; ++i )          {            j = i + 1;              if( j >= n ) { j = 0; }              // The Creator.CreateModelLine method creates             // pretty arbitrary sketch planes' which causes            // the NewExtrusionForm method to fail' saying             // "Cannot create extrude form."              //ModelCurve c = Creator.CreateModelLine( doc' pts[i]' pts[j] );              ModelCurve c = MakeLine( doc' pts[i]' pts[j] );              refar.Append( c.GeometryCurve.Reference );          }            //doc.Regenerate();            // The extrusion form direction and length.          // The direction must be perpendicular to the           // plane determined by profile. The length           // must be non-zero.            XYZ direction = new XYZ( /*-6*/ 0' 0' 20 );            Form form = doc.FamilyCreate.NewExtrusionForm( // Cannot create extrude form.            true' refar' direction );            tx.Commit();        }
Magic Number,BuildingCoder,CmdFaceWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdFaceWall.cs,CreateMassExtrusion,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Create Mass" );            // Create profile            ReferenceArray refar = new ReferenceArray();            XYZ[] pts = new XYZ[] {          new XYZ( -10' -10' 0 )'          new XYZ( +10' -10' 0 )'          new XYZ( +10' +10' 0 )'          new XYZ( -10' +10' 0 ) };            int j' n = pts.Length;            for( int i = 0; i < n; ++i )          {            j = i + 1;              if( j >= n ) { j = 0; }              // The Creator.CreateModelLine method creates             // pretty arbitrary sketch planes' which causes            // the NewExtrusionForm method to fail' saying             // "Cannot create extrude form."              //ModelCurve c = Creator.CreateModelLine( doc' pts[i]' pts[j] );              ModelCurve c = MakeLine( doc' pts[i]' pts[j] );              refar.Append( c.GeometryCurve.Reference );          }            //doc.Regenerate();            // The extrusion form direction and length.          // The direction must be perpendicular to the           // plane determined by profile. The length           // must be non-zero.            XYZ direction = new XYZ( /*-6*/ 0' 0' 20 );            Form form = doc.FamilyCreate.NewExtrusionForm( // Cannot create extrude form.            true' refar' direction );            tx.Commit();        }
Magic Number,BuildingCoder,CmdFaceWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdFaceWall.cs,CreateMassExtrusion,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Create Mass" );            // Create profile            ReferenceArray refar = new ReferenceArray();            XYZ[] pts = new XYZ[] {          new XYZ( -10' -10' 0 )'          new XYZ( +10' -10' 0 )'          new XYZ( +10' +10' 0 )'          new XYZ( -10' +10' 0 ) };            int j' n = pts.Length;            for( int i = 0; i < n; ++i )          {            j = i + 1;              if( j >= n ) { j = 0; }              // The Creator.CreateModelLine method creates             // pretty arbitrary sketch planes' which causes            // the NewExtrusionForm method to fail' saying             // "Cannot create extrude form."              //ModelCurve c = Creator.CreateModelLine( doc' pts[i]' pts[j] );              ModelCurve c = MakeLine( doc' pts[i]' pts[j] );              refar.Append( c.GeometryCurve.Reference );          }            //doc.Regenerate();            // The extrusion form direction and length.          // The direction must be perpendicular to the           // plane determined by profile. The length           // must be non-zero.            XYZ direction = new XYZ( /*-6*/ 0' 0' 20 );            Form form = doc.FamilyCreate.NewExtrusionForm( // Cannot create extrude form.            true' refar' direction );            tx.Commit();        }
Magic Number,BuildingCoder,CmdFaceWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdFaceWall.cs,CreateMassExtrusion,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Create Mass" );            // Create profile            ReferenceArray refar = new ReferenceArray();            XYZ[] pts = new XYZ[] {          new XYZ( -10' -10' 0 )'          new XYZ( +10' -10' 0 )'          new XYZ( +10' +10' 0 )'          new XYZ( -10' +10' 0 ) };            int j' n = pts.Length;            for( int i = 0; i < n; ++i )          {            j = i + 1;              if( j >= n ) { j = 0; }              // The Creator.CreateModelLine method creates             // pretty arbitrary sketch planes' which causes            // the NewExtrusionForm method to fail' saying             // "Cannot create extrude form."              //ModelCurve c = Creator.CreateModelLine( doc' pts[i]' pts[j] );              ModelCurve c = MakeLine( doc' pts[i]' pts[j] );              refar.Append( c.GeometryCurve.Reference );          }            //doc.Regenerate();            // The extrusion form direction and length.          // The direction must be perpendicular to the           // plane determined by profile. The length           // must be non-zero.            XYZ direction = new XYZ( /*-6*/ 0' 0' 20 );            Form form = doc.FamilyCreate.NewExtrusionForm( // Cannot create extrude form.            true' refar' direction );            tx.Commit();        }
Magic Number,BuildingCoder,CmdFaceWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdFaceWall.cs,CreateMassExtrusion,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Create Mass" );            // Create profile            ReferenceArray refar = new ReferenceArray();            XYZ[] pts = new XYZ[] {          new XYZ( -10' -10' 0 )'          new XYZ( +10' -10' 0 )'          new XYZ( +10' +10' 0 )'          new XYZ( -10' +10' 0 ) };            int j' n = pts.Length;            for( int i = 0; i < n; ++i )          {            j = i + 1;              if( j >= n ) { j = 0; }              // The Creator.CreateModelLine method creates             // pretty arbitrary sketch planes' which causes            // the NewExtrusionForm method to fail' saying             // "Cannot create extrude form."              //ModelCurve c = Creator.CreateModelLine( doc' pts[i]' pts[j] );              ModelCurve c = MakeLine( doc' pts[i]' pts[j] );              refar.Append( c.GeometryCurve.Reference );          }            //doc.Regenerate();            // The extrusion form direction and length.          // The direction must be perpendicular to the           // plane determined by profile. The length           // must be non-zero.            XYZ direction = new XYZ( /*-6*/ 0' 0' 20 );            Form form = doc.FamilyCreate.NewExtrusionForm( // Cannot create extrude form.            true' refar' direction );            tx.Commit();        }
Magic Number,BuildingCoder,CmdFaceWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdFaceWall.cs,CreateMassExtrusion,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Create Mass" );            // Create profile            ReferenceArray refar = new ReferenceArray();            XYZ[] pts = new XYZ[] {          new XYZ( -10' -10' 0 )'          new XYZ( +10' -10' 0 )'          new XYZ( +10' +10' 0 )'          new XYZ( -10' +10' 0 ) };            int j' n = pts.Length;            for( int i = 0; i < n; ++i )          {            j = i + 1;              if( j >= n ) { j = 0; }              // The Creator.CreateModelLine method creates             // pretty arbitrary sketch planes' which causes            // the NewExtrusionForm method to fail' saying             // "Cannot create extrude form."              //ModelCurve c = Creator.CreateModelLine( doc' pts[i]' pts[j] );              ModelCurve c = MakeLine( doc' pts[i]' pts[j] );              refar.Append( c.GeometryCurve.Reference );          }            //doc.Regenerate();            // The extrusion form direction and length.          // The direction must be perpendicular to the           // plane determined by profile. The length           // must be non-zero.            XYZ direction = new XYZ( /*-6*/ 0' 0' 20 );            Form form = doc.FamilyCreate.NewExtrusionForm( // Cannot create extrude form.            true' refar' direction );            tx.Commit();        }
Magic Number,BuildingCoder,CmdFaceWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdFaceWall.cs,CreateMassExtrusion,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Create Mass" );            // Create profile            ReferenceArray refar = new ReferenceArray();            XYZ[] pts = new XYZ[] {          new XYZ( -10' -10' 0 )'          new XYZ( +10' -10' 0 )'          new XYZ( +10' +10' 0 )'          new XYZ( -10' +10' 0 ) };            int j' n = pts.Length;            for( int i = 0; i < n; ++i )          {            j = i + 1;              if( j >= n ) { j = 0; }              // The Creator.CreateModelLine method creates             // pretty arbitrary sketch planes' which causes            // the NewExtrusionForm method to fail' saying             // "Cannot create extrude form."              //ModelCurve c = Creator.CreateModelLine( doc' pts[i]' pts[j] );              ModelCurve c = MakeLine( doc' pts[i]' pts[j] );              refar.Append( c.GeometryCurve.Reference );          }            //doc.Regenerate();            // The extrusion form direction and length.          // The direction must be perpendicular to the           // plane determined by profile. The length           // must be non-zero.            XYZ direction = new XYZ( /*-6*/ 0' 0' 20 );            Form form = doc.FamilyCreate.NewExtrusionForm( // Cannot create extrude form.            true' refar' direction );            tx.Commit();        }
Magic Number,BuildingCoder,CmdFaceWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdFaceWall.cs,CreateMassExtrusion,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Create Mass" );            // Create profile            ReferenceArray refar = new ReferenceArray();            XYZ[] pts = new XYZ[] {          new XYZ( -10' -10' 0 )'          new XYZ( +10' -10' 0 )'          new XYZ( +10' +10' 0 )'          new XYZ( -10' +10' 0 ) };            int j' n = pts.Length;            for( int i = 0; i < n; ++i )          {            j = i + 1;              if( j >= n ) { j = 0; }              // The Creator.CreateModelLine method creates             // pretty arbitrary sketch planes' which causes            // the NewExtrusionForm method to fail' saying             // "Cannot create extrude form."              //ModelCurve c = Creator.CreateModelLine( doc' pts[i]' pts[j] );              ModelCurve c = MakeLine( doc' pts[i]' pts[j] );              refar.Append( c.GeometryCurve.Reference );          }            //doc.Regenerate();            // The extrusion form direction and length.          // The direction must be perpendicular to the           // plane determined by profile. The length           // must be non-zero.            XYZ direction = new XYZ( /*-6*/ 0' 0' 20 );            Form form = doc.FamilyCreate.NewExtrusionForm( // Cannot create extrude form.            true' refar' direction );            tx.Commit();        }
Magic Number,BuildingCoder,CmdFaceWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdFaceWall.cs,CreateMassExtrusion,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Create Mass" );            // Create profile            ReferenceArray refar = new ReferenceArray();            XYZ[] pts = new XYZ[] {          new XYZ( -10' -10' 0 )'          new XYZ( +10' -10' 0 )'          new XYZ( +10' +10' 0 )'          new XYZ( -10' +10' 0 ) };            int j' n = pts.Length;            for( int i = 0; i < n; ++i )          {            j = i + 1;              if( j >= n ) { j = 0; }              // The Creator.CreateModelLine method creates             // pretty arbitrary sketch planes' which causes            // the NewExtrusionForm method to fail' saying             // "Cannot create extrude form."              //ModelCurve c = Creator.CreateModelLine( doc' pts[i]' pts[j] );              ModelCurve c = MakeLine( doc' pts[i]' pts[j] );              refar.Append( c.GeometryCurve.Reference );          }            //doc.Regenerate();            // The extrusion form direction and length.          // The direction must be perpendicular to the           // plane determined by profile. The length           // must be non-zero.            XYZ direction = new XYZ( /*-6*/ 0' 0' 20 );            Form form = doc.FamilyCreate.NewExtrusionForm( // Cannot create extrude form.            true' refar' direction );            tx.Commit();        }
Magic Number,BuildingCoder,CmdFamilyParamValue,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdFamilyParamValue.cs,SetFamilyParameterValueFails,The following statement contains a magic number: while( familyTypeItor.MoveNext() )        {          FamilyParameter familyParam            = mgr.get_Parameter( paramNameToAmend );            if( familyParam != null )          {            FamilyType familyType = familyTypeItor.Current as FamilyType;            Debug.Print( familyType.Name );            mgr.Set( familyParam' 2 );          }        }
Magic Number,BuildingCoder,CmdFamilyParamValue,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdFamilyParamValue.cs,SetFamilyParameterValueWorks,The following statement contains a magic number: if( familyParam != null )        {          foreach( FamilyType familyType in mgr.Types )          {            Debug.Print( familyType.Name );            mgr.CurrentType = familyType;            mgr.Set( familyParam' 2 );          }        }
Magic Number,BuildingCoder,CmdGetDimensionPoints,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdGetDimensionPoints.cs,GetDimensionPoints,The following statement contains a magic number: if( 0 == dim.Segments.Size )        {          XYZ v = 0.5 * (double) dim.Value * direction;          pts.Add( pStart - v );          pts.Add( pStart + v );        }        else        {          XYZ p = pStart;          foreach( DimensionSegment seg in dim.Segments )          {            XYZ v = (double) seg.Value * direction;            if( 0 == pts.Count )            {              pts.Add( p = ( pStart - 0.5 * v ) );            }            pts.Add( p = p.Add( v ) );          }        }
Magic Number,BuildingCoder,CmdGetDimensionPoints,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdGetDimensionPoints.cs,GetDimensionPoints,The following statement contains a magic number: if( 0 == dim.Segments.Size )        {          XYZ v = 0.5 * (double) dim.Value * direction;          pts.Add( pStart - v );          pts.Add( pStart + v );        }        else        {          XYZ p = pStart;          foreach( DimensionSegment seg in dim.Segments )          {            XYZ v = (double) seg.Value * direction;            if( 0 == pts.Count )            {              pts.Add( p = ( pStart - 0.5 * v ) );            }            pts.Add( p = p.Add( v ) );          }        }
Magic Number,BuildingCoder,CmdGetDimensionPoints,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdGetDimensionPoints.cs,DrawMarker,The following statement contains a magic number: size *= 0.5;
Magic Number,BuildingCoder,CmdGetDimensionPoints,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdGetDimensionPoints.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Draw Point Markers" );            SketchPlane sketchPlane = dim.View.SketchPlane;            double size = 0.3;          DrawMarker( p' size' sketchPlane );          pts.ForEach( q => DrawMarker( q' size' sketchPlane ) );            tx.Commit();        }
Magic Number,BuildingCoder,CmdImportsInFamilies,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdImportsInFamilies.cs,ListImportsAndSearchForMore,The following statement contains a magic number: string indent          = new string( ' '' 2 * recursionLevel );
Magic Number,BuildingCoder,CmdLandXml,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdLandXml.cs,Execute,The following statement contains a magic number: for( int k = 0; k < pnts.Count; ++k )        {          for( int i = 0;            i < pnts[k].ChildNodes.Count; ++i )          {            int j = 1;              string text = pnts[k].ChildNodes[i].InnerText;            string[] coords = text.Split( separator );              foreach( string coord in coords )            {              switch( j )              {                case 1:                  x = Double.Parse( coord );                  break;                case 2:                  y = Double.Parse( coord );                  break;                case 3:                  z = Double.Parse( coord );                  break;                default:                  break;              }              j++;            }            pts.Add( new XYZ( x' y' z ) );          }        }
Magic Number,BuildingCoder,CmdLandXml,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdLandXml.cs,Execute,The following statement contains a magic number: for( int k = 0; k < pnts.Count; ++k )        {          for( int i = 0;            i < pnts[k].ChildNodes.Count; ++i )          {            int j = 1;              string text = pnts[k].ChildNodes[i].InnerText;            string[] coords = text.Split( separator );              foreach( string coord in coords )            {              switch( j )              {                case 1:                  x = Double.Parse( coord );                  break;                case 2:                  y = Double.Parse( coord );                  break;                case 3:                  z = Double.Parse( coord );                  break;                default:                  break;              }              j++;            }            pts.Add( new XYZ( x' y' z ) );          }        }
Magic Number,BuildingCoder,CmdLinkedFileElements,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdLinkedFileElements.cs,AddFaceBasedFamilyToLinks,The following statement contains a magic number: ElementId alignedLinkId = new ElementId( 125929 );
Magic Number,BuildingCoder,CmdLinkedFileElements,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdLinkedFileElements.cs,AddFaceBasedFamilyToLinks,The following statement contains a magic number: ElementId symbolId = new ElementId( 126580 );
Magic Number,BuildingCoder,CmdLinkedFileElementsForm,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdLinkedFileElementsForm.cs,InitializeComponent,The following statement contains a magic number: this.dataGridView1.Size = new System.Drawing.Size( 729' 161 );
Magic Number,BuildingCoder,CmdLinkedFileElementsForm,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdLinkedFileElementsForm.cs,InitializeComponent,The following statement contains a magic number: this.dataGridView1.Size = new System.Drawing.Size( 729' 161 );
Magic Number,BuildingCoder,CmdLinkedFileElementsForm,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdLinkedFileElementsForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size( 729' 161 );
Magic Number,BuildingCoder,CmdLinkedFileElementsForm,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdLinkedFileElementsForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size( 729' 161 );
Magic Number,BuildingCoder,CmdLinq,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdLinq.cs,Execute,The following statement contains a magic number: int i = 42;
Magic Number,BuildingCoder,CmdListAllRooms,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdListAllRooms.cs,GetConvexHullOfRoomBoundary,The following statement contains a magic number: pts = new List<XYZ>(          pts.Distinct<XYZ>( new CmdWallTopFaces            .XyzEqualityComparer( 1.0e-4 ) ) );
Magic Number,BuildingCoder,CmdListPipeSizes,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdListPipeSizes.cs,FootToMmString,The following statement contains a magic number: return Util.FootToMm( a )          .ToString( "0.##" )          .PadLeft( 8 );
Magic Number,BuildingCoder,MepElementShapeV1,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdMepElementShape.cs,GetElementShape,The following statement contains a magic number: if( is_element_of_category( e'            BuiltInCategory.OST_DuctCurves ) )          {            // simple case' no need to use regular expression              //string size = e.get_Parameter( "Size" ) // 2014            //  .AsString();              Debug.Assert(              1 == e.GetParameters( "Size" ).Count'              "expected only one parameters named 'Size'" );              string size = e.LookupParameter( "Size" ) // 2015              .AsString();              if( size.Split( 'x' ).Length == 2 )              return "rectangular";            else if( size.Split( '/' ).Length == 2 )              return "oval";            else              return "round";          }          else if( is_element_of_category( e'            BuiltInCategory.OST_DuctFitting ) )          {            FamilyInstance fi = e as FamilyInstance;              if( fi != null && fi.MEPModel is MechanicalFitting )            {              //Parameter p = e.get_Parameter( "Size" ); // 2014                Parameter p = e.get_Parameter(                BuiltInParameter.RBS_CALCULATED_SIZE ); // 2015                string size = p.AsString();                PartType partType = ( fi.MEPModel as                MechanicalFitting ).PartType;                if( PartType.Elbow == partType                || PartType.Transition == partType )              {                // more complex case                  #region Metric only  #if METRIC_ONLY_BEFORE_REGEX_CACHE              if( size.Split( 'x' ).Length == 3 ) // could use a regex "[0-9]x[0-9]+-[0-9]+/[0-9]+" but splitting is less costly                return "rectangular2rectangular";              else if( size.Split( '/' ).Length == 3 )                return "oval2oval";              else if(                new Regex( @"[0-9]+x[0-9]+-[0-9]+/[0-9]+" )                  .IsMatch( size ) )                    return "rectangular2oval";              else if(                new Regex( @"[0-9]+/[0-9]+-[0-9]+x[0-9]+" )                  .IsMatch( size ) )                    return "oval2rectangular";              else if(                new Regex( @"[0-9]+[^0-9]-[0-9]+x[0-9]+" )                  .IsMatch( size ) )                    return "round2rectangular";              else if(                new Regex( @"[0-9]+x[0-9]+-[0-9]+[^0-9]" )                  .IsMatch( size ) )                    return "rectangular2round";              else if(                new Regex( @"[0-9]+[^0-9]-[0-9]+/[0-9]+" )                  .IsMatch( size ) )                    return "round2oval";              else if(                new Regex( @"[0-9]+/[0-9]+-[0-9]+[^0-9]" )                  .IsMatch( size ) )                    return "oval2round";              else if(                new Regex( @"[0-9]+[^0-9]-[0-9]+[^0-9]" )                  .IsMatch( size ) )                    return "round2round";              else { return "other case"; }  #endif // METRIC_ONLY_BEFORE_REGEX_CACHE    #if METRIC_ONLY              if( size.Split( 'x' ).Length == 3 ) // could use a regex "[0-9]x[0-9]+-[0-9]+/[0-9]+" but splitting is less costly                return "rectangular2rectangular";              else if( size.Split( '/' ).Length == 3 )                return "oval2oval";              else if( _regexCache.Match(                "[0-9]+x[0-9]+-[0-9]+/[0-9]+"' size ) )                  return "rectangular2oval";              else if( _regexCache.Match(                "[0-9]+/[0-9]+-[0-9]+x[0-9]+"' size ) )                  return "oval2rectangular";              else if( _regexCache.Match(                "[0-9]+[^0-9]-[0-9]+x[0-9]+"' size ) )                  return "round2rectangular";              else if( _regexCache.Match(                "[0-9]+x[0-9]+-[0-9]+[^0-9]"' size ) )                  return "rectangular2round";              else if( _regexCache.Match(                "[0-9]+[^0-9]-[0-9]+/[0-9]+"' size ) )                  return "round2oval";              else if( _regexCache.Match(                "[0-9]+/[0-9]+-[0-9]+[^0-9]"' size ) )                  return "oval2round";              else if( _regexCache.Match(                "[0-9]+[^0-9]-[0-9]+[^0-9]"' size ) )                  return "round2round";  #endif // METRIC_ONLY                #endregion // Metric only                  if( size.Split( 'x' ).Length == 3 ) // or use Regex("[0-9]x[0-9]+-[0-9]+/[0-9]+") but splitting is less costly                  return "rectangular2rectangular";                else if( size.Split( '/' ).Length == 3 ) // but if in imperial units size is in fractional inches format it has to be replaced by another regular expression                  return "oval2oval";                else if( _regexCache.Match(                  "[0-9]+\"?x[0-9]+\"?-[0-9]+\"?/[0-9]+\"?"' size ) )                  return "rectangular2oval";                else if( _regexCache.Match(                  "[0-9]+\"?/[0-9]+\"?-[0-9]+\"?x[0-9]+\"?"' size ) )                  return "oval2rectangular";                else if( _regexCache.Match(                  "[0-9]+\"?[^0-9]-[0-9]+\"?x[0-9]+\"?"' size ) )                  return "round2rectangular";                else if( _regexCache.Match(                  "[0-9]+\"?x[0-9]+\"?-[0-9]+\"?[^0-9]"' size ) )                  return "rectangular2round";                else if( _regexCache.Match(                  "[0-9]+\"?[^0-9]-[0-9]+\"?/[0-9]+\"?"' size ) )                  return "round2oval";                else if( _regexCache.Match(                  "[0-9]+\"?/[0-9]+\"?-[0-9]+\"?[^0-9]"' size ) )                  return "oval2round";                else if( _regexCache.Match(                  "[0-9]+\"?[^0-9]-[0-9]+\"?[^0-9]"' size ) )                  return "round2round";                else { return "other case"; }              }              // etc (for other part types)              else              {              }            }            // etc (for other categories)            else            {            }          }
Magic Number,BuildingCoder,MepElementShapeV1,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdMepElementShape.cs,GetElementShape,The following statement contains a magic number: if( is_element_of_category( e'            BuiltInCategory.OST_DuctCurves ) )          {            // simple case' no need to use regular expression              //string size = e.get_Parameter( "Size" ) // 2014            //  .AsString();              Debug.Assert(              1 == e.GetParameters( "Size" ).Count'              "expected only one parameters named 'Size'" );              string size = e.LookupParameter( "Size" ) // 2015              .AsString();              if( size.Split( 'x' ).Length == 2 )              return "rectangular";            else if( size.Split( '/' ).Length == 2 )              return "oval";            else              return "round";          }          else if( is_element_of_category( e'            BuiltInCategory.OST_DuctFitting ) )          {            FamilyInstance fi = e as FamilyInstance;              if( fi != null && fi.MEPModel is MechanicalFitting )            {              //Parameter p = e.get_Parameter( "Size" ); // 2014                Parameter p = e.get_Parameter(                BuiltInParameter.RBS_CALCULATED_SIZE ); // 2015                string size = p.AsString();                PartType partType = ( fi.MEPModel as                MechanicalFitting ).PartType;                if( PartType.Elbow == partType                || PartType.Transition == partType )              {                // more complex case                  #region Metric only  #if METRIC_ONLY_BEFORE_REGEX_CACHE              if( size.Split( 'x' ).Length == 3 ) // could use a regex "[0-9]x[0-9]+-[0-9]+/[0-9]+" but splitting is less costly                return "rectangular2rectangular";              else if( size.Split( '/' ).Length == 3 )                return "oval2oval";              else if(                new Regex( @"[0-9]+x[0-9]+-[0-9]+/[0-9]+" )                  .IsMatch( size ) )                    return "rectangular2oval";              else if(                new Regex( @"[0-9]+/[0-9]+-[0-9]+x[0-9]+" )                  .IsMatch( size ) )                    return "oval2rectangular";              else if(                new Regex( @"[0-9]+[^0-9]-[0-9]+x[0-9]+" )                  .IsMatch( size ) )                    return "round2rectangular";              else if(                new Regex( @"[0-9]+x[0-9]+-[0-9]+[^0-9]" )                  .IsMatch( size ) )                    return "rectangular2round";              else if(                new Regex( @"[0-9]+[^0-9]-[0-9]+/[0-9]+" )                  .IsMatch( size ) )                    return "round2oval";              else if(                new Regex( @"[0-9]+/[0-9]+-[0-9]+[^0-9]" )                  .IsMatch( size ) )                    return "oval2round";              else if(                new Regex( @"[0-9]+[^0-9]-[0-9]+[^0-9]" )                  .IsMatch( size ) )                    return "round2round";              else { return "other case"; }  #endif // METRIC_ONLY_BEFORE_REGEX_CACHE    #if METRIC_ONLY              if( size.Split( 'x' ).Length == 3 ) // could use a regex "[0-9]x[0-9]+-[0-9]+/[0-9]+" but splitting is less costly                return "rectangular2rectangular";              else if( size.Split( '/' ).Length == 3 )                return "oval2oval";              else if( _regexCache.Match(                "[0-9]+x[0-9]+-[0-9]+/[0-9]+"' size ) )                  return "rectangular2oval";              else if( _regexCache.Match(                "[0-9]+/[0-9]+-[0-9]+x[0-9]+"' size ) )                  return "oval2rectangular";              else if( _regexCache.Match(                "[0-9]+[^0-9]-[0-9]+x[0-9]+"' size ) )                  return "round2rectangular";              else if( _regexCache.Match(                "[0-9]+x[0-9]+-[0-9]+[^0-9]"' size ) )                  return "rectangular2round";              else if( _regexCache.Match(                "[0-9]+[^0-9]-[0-9]+/[0-9]+"' size ) )                  return "round2oval";              else if( _regexCache.Match(                "[0-9]+/[0-9]+-[0-9]+[^0-9]"' size ) )                  return "oval2round";              else if( _regexCache.Match(                "[0-9]+[^0-9]-[0-9]+[^0-9]"' size ) )                  return "round2round";  #endif // METRIC_ONLY                #endregion // Metric only                  if( size.Split( 'x' ).Length == 3 ) // or use Regex("[0-9]x[0-9]+-[0-9]+/[0-9]+") but splitting is less costly                  return "rectangular2rectangular";                else if( size.Split( '/' ).Length == 3 ) // but if in imperial units size is in fractional inches format it has to be replaced by another regular expression                  return "oval2oval";                else if( _regexCache.Match(                  "[0-9]+\"?x[0-9]+\"?-[0-9]+\"?/[0-9]+\"?"' size ) )                  return "rectangular2oval";                else if( _regexCache.Match(                  "[0-9]+\"?/[0-9]+\"?-[0-9]+\"?x[0-9]+\"?"' size ) )                  return "oval2rectangular";                else if( _regexCache.Match(                  "[0-9]+\"?[^0-9]-[0-9]+\"?x[0-9]+\"?"' size ) )                  return "round2rectangular";                else if( _regexCache.Match(                  "[0-9]+\"?x[0-9]+\"?-[0-9]+\"?[^0-9]"' size ) )                  return "rectangular2round";                else if( _regexCache.Match(                  "[0-9]+\"?[^0-9]-[0-9]+\"?/[0-9]+\"?"' size ) )                  return "round2oval";                else if( _regexCache.Match(                  "[0-9]+\"?/[0-9]+\"?-[0-9]+\"?[^0-9]"' size ) )                  return "oval2round";                else if( _regexCache.Match(                  "[0-9]+\"?[^0-9]-[0-9]+\"?[^0-9]"' size ) )                  return "round2round";                else { return "other case"; }              }              // etc (for other part types)              else              {              }            }            // etc (for other categories)            else            {            }          }
Magic Number,BuildingCoder,MepElementShapeV1,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdMepElementShape.cs,GetElementShape,The following statement contains a magic number: if( is_element_of_category( e'            BuiltInCategory.OST_DuctCurves ) )          {            // simple case' no need to use regular expression              //string size = e.get_Parameter( "Size" ) // 2014            //  .AsString();              Debug.Assert(              1 == e.GetParameters( "Size" ).Count'              "expected only one parameters named 'Size'" );              string size = e.LookupParameter( "Size" ) // 2015              .AsString();              if( size.Split( 'x' ).Length == 2 )              return "rectangular";            else if( size.Split( '/' ).Length == 2 )              return "oval";            else              return "round";          }          else if( is_element_of_category( e'            BuiltInCategory.OST_DuctFitting ) )          {            FamilyInstance fi = e as FamilyInstance;              if( fi != null && fi.MEPModel is MechanicalFitting )            {              //Parameter p = e.get_Parameter( "Size" ); // 2014                Parameter p = e.get_Parameter(                BuiltInParameter.RBS_CALCULATED_SIZE ); // 2015                string size = p.AsString();                PartType partType = ( fi.MEPModel as                MechanicalFitting ).PartType;                if( PartType.Elbow == partType                || PartType.Transition == partType )              {                // more complex case                  #region Metric only  #if METRIC_ONLY_BEFORE_REGEX_CACHE              if( size.Split( 'x' ).Length == 3 ) // could use a regex "[0-9]x[0-9]+-[0-9]+/[0-9]+" but splitting is less costly                return "rectangular2rectangular";              else if( size.Split( '/' ).Length == 3 )                return "oval2oval";              else if(                new Regex( @"[0-9]+x[0-9]+-[0-9]+/[0-9]+" )                  .IsMatch( size ) )                    return "rectangular2oval";              else if(                new Regex( @"[0-9]+/[0-9]+-[0-9]+x[0-9]+" )                  .IsMatch( size ) )                    return "oval2rectangular";              else if(                new Regex( @"[0-9]+[^0-9]-[0-9]+x[0-9]+" )                  .IsMatch( size ) )                    return "round2rectangular";              else if(                new Regex( @"[0-9]+x[0-9]+-[0-9]+[^0-9]" )                  .IsMatch( size ) )                    return "rectangular2round";              else if(                new Regex( @"[0-9]+[^0-9]-[0-9]+/[0-9]+" )                  .IsMatch( size ) )                    return "round2oval";              else if(                new Regex( @"[0-9]+/[0-9]+-[0-9]+[^0-9]" )                  .IsMatch( size ) )                    return "oval2round";              else if(                new Regex( @"[0-9]+[^0-9]-[0-9]+[^0-9]" )                  .IsMatch( size ) )                    return "round2round";              else { return "other case"; }  #endif // METRIC_ONLY_BEFORE_REGEX_CACHE    #if METRIC_ONLY              if( size.Split( 'x' ).Length == 3 ) // could use a regex "[0-9]x[0-9]+-[0-9]+/[0-9]+" but splitting is less costly                return "rectangular2rectangular";              else if( size.Split( '/' ).Length == 3 )                return "oval2oval";              else if( _regexCache.Match(                "[0-9]+x[0-9]+-[0-9]+/[0-9]+"' size ) )                  return "rectangular2oval";              else if( _regexCache.Match(                "[0-9]+/[0-9]+-[0-9]+x[0-9]+"' size ) )                  return "oval2rectangular";              else if( _regexCache.Match(                "[0-9]+[^0-9]-[0-9]+x[0-9]+"' size ) )                  return "round2rectangular";              else if( _regexCache.Match(                "[0-9]+x[0-9]+-[0-9]+[^0-9]"' size ) )                  return "rectangular2round";              else if( _regexCache.Match(                "[0-9]+[^0-9]-[0-9]+/[0-9]+"' size ) )                  return "round2oval";              else if( _regexCache.Match(                "[0-9]+/[0-9]+-[0-9]+[^0-9]"' size ) )                  return "oval2round";              else if( _regexCache.Match(                "[0-9]+[^0-9]-[0-9]+[^0-9]"' size ) )                  return "round2round";  #endif // METRIC_ONLY                #endregion // Metric only                  if( size.Split( 'x' ).Length == 3 ) // or use Regex("[0-9]x[0-9]+-[0-9]+/[0-9]+") but splitting is less costly                  return "rectangular2rectangular";                else if( size.Split( '/' ).Length == 3 ) // but if in imperial units size is in fractional inches format it has to be replaced by another regular expression                  return "oval2oval";                else if( _regexCache.Match(                  "[0-9]+\"?x[0-9]+\"?-[0-9]+\"?/[0-9]+\"?"' size ) )                  return "rectangular2oval";                else if( _regexCache.Match(                  "[0-9]+\"?/[0-9]+\"?-[0-9]+\"?x[0-9]+\"?"' size ) )                  return "oval2rectangular";                else if( _regexCache.Match(                  "[0-9]+\"?[^0-9]-[0-9]+\"?x[0-9]+\"?"' size ) )                  return "round2rectangular";                else if( _regexCache.Match(                  "[0-9]+\"?x[0-9]+\"?-[0-9]+\"?[^0-9]"' size ) )                  return "rectangular2round";                else if( _regexCache.Match(                  "[0-9]+\"?[^0-9]-[0-9]+\"?/[0-9]+\"?"' size ) )                  return "round2oval";                else if( _regexCache.Match(                  "[0-9]+\"?/[0-9]+\"?-[0-9]+\"?[^0-9]"' size ) )                  return "oval2round";                else if( _regexCache.Match(                  "[0-9]+\"?[^0-9]-[0-9]+\"?[^0-9]"' size ) )                  return "round2round";                else { return "other case"; }              }              // etc (for other part types)              else              {              }            }            // etc (for other categories)            else            {            }          }
Magic Number,BuildingCoder,MepElementShapeV1,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdMepElementShape.cs,GetElementShape,The following statement contains a magic number: if( is_element_of_category( e'            BuiltInCategory.OST_DuctCurves ) )          {            // simple case' no need to use regular expression              //string size = e.get_Parameter( "Size" ) // 2014            //  .AsString();              Debug.Assert(              1 == e.GetParameters( "Size" ).Count'              "expected only one parameters named 'Size'" );              string size = e.LookupParameter( "Size" ) // 2015              .AsString();              if( size.Split( 'x' ).Length == 2 )              return "rectangular";            else if( size.Split( '/' ).Length == 2 )              return "oval";            else              return "round";          }          else if( is_element_of_category( e'            BuiltInCategory.OST_DuctFitting ) )          {            FamilyInstance fi = e as FamilyInstance;              if( fi != null && fi.MEPModel is MechanicalFitting )            {              //Parameter p = e.get_Parameter( "Size" ); // 2014                Parameter p = e.get_Parameter(                BuiltInParameter.RBS_CALCULATED_SIZE ); // 2015                string size = p.AsString();                PartType partType = ( fi.MEPModel as                MechanicalFitting ).PartType;                if( PartType.Elbow == partType                || PartType.Transition == partType )              {                // more complex case                  #region Metric only  #if METRIC_ONLY_BEFORE_REGEX_CACHE              if( size.Split( 'x' ).Length == 3 ) // could use a regex "[0-9]x[0-9]+-[0-9]+/[0-9]+" but splitting is less costly                return "rectangular2rectangular";              else if( size.Split( '/' ).Length == 3 )                return "oval2oval";              else if(                new Regex( @"[0-9]+x[0-9]+-[0-9]+/[0-9]+" )                  .IsMatch( size ) )                    return "rectangular2oval";              else if(                new Regex( @"[0-9]+/[0-9]+-[0-9]+x[0-9]+" )                  .IsMatch( size ) )                    return "oval2rectangular";              else if(                new Regex( @"[0-9]+[^0-9]-[0-9]+x[0-9]+" )                  .IsMatch( size ) )                    return "round2rectangular";              else if(                new Regex( @"[0-9]+x[0-9]+-[0-9]+[^0-9]" )                  .IsMatch( size ) )                    return "rectangular2round";              else if(                new Regex( @"[0-9]+[^0-9]-[0-9]+/[0-9]+" )                  .IsMatch( size ) )                    return "round2oval";              else if(                new Regex( @"[0-9]+/[0-9]+-[0-9]+[^0-9]" )                  .IsMatch( size ) )                    return "oval2round";              else if(                new Regex( @"[0-9]+[^0-9]-[0-9]+[^0-9]" )                  .IsMatch( size ) )                    return "round2round";              else { return "other case"; }  #endif // METRIC_ONLY_BEFORE_REGEX_CACHE    #if METRIC_ONLY              if( size.Split( 'x' ).Length == 3 ) // could use a regex "[0-9]x[0-9]+-[0-9]+/[0-9]+" but splitting is less costly                return "rectangular2rectangular";              else if( size.Split( '/' ).Length == 3 )                return "oval2oval";              else if( _regexCache.Match(                "[0-9]+x[0-9]+-[0-9]+/[0-9]+"' size ) )                  return "rectangular2oval";              else if( _regexCache.Match(                "[0-9]+/[0-9]+-[0-9]+x[0-9]+"' size ) )                  return "oval2rectangular";              else if( _regexCache.Match(                "[0-9]+[^0-9]-[0-9]+x[0-9]+"' size ) )                  return "round2rectangular";              else if( _regexCache.Match(                "[0-9]+x[0-9]+-[0-9]+[^0-9]"' size ) )                  return "rectangular2round";              else if( _regexCache.Match(                "[0-9]+[^0-9]-[0-9]+/[0-9]+"' size ) )                  return "round2oval";              else if( _regexCache.Match(                "[0-9]+/[0-9]+-[0-9]+[^0-9]"' size ) )                  return "oval2round";              else if( _regexCache.Match(                "[0-9]+[^0-9]-[0-9]+[^0-9]"' size ) )                  return "round2round";  #endif // METRIC_ONLY                #endregion // Metric only                  if( size.Split( 'x' ).Length == 3 ) // or use Regex("[0-9]x[0-9]+-[0-9]+/[0-9]+") but splitting is less costly                  return "rectangular2rectangular";                else if( size.Split( '/' ).Length == 3 ) // but if in imperial units size is in fractional inches format it has to be replaced by another regular expression                  return "oval2oval";                else if( _regexCache.Match(                  "[0-9]+\"?x[0-9]+\"?-[0-9]+\"?/[0-9]+\"?"' size ) )                  return "rectangular2oval";                else if( _regexCache.Match(                  "[0-9]+\"?/[0-9]+\"?-[0-9]+\"?x[0-9]+\"?"' size ) )                  return "oval2rectangular";                else if( _regexCache.Match(                  "[0-9]+\"?[^0-9]-[0-9]+\"?x[0-9]+\"?"' size ) )                  return "round2rectangular";                else if( _regexCache.Match(                  "[0-9]+\"?x[0-9]+\"?-[0-9]+\"?[^0-9]"' size ) )                  return "rectangular2round";                else if( _regexCache.Match(                  "[0-9]+\"?[^0-9]-[0-9]+\"?/[0-9]+\"?"' size ) )                  return "round2oval";                else if( _regexCache.Match(                  "[0-9]+\"?/[0-9]+\"?-[0-9]+\"?[^0-9]"' size ) )                  return "oval2round";                else if( _regexCache.Match(                  "[0-9]+\"?[^0-9]-[0-9]+\"?[^0-9]"' size ) )                  return "round2round";                else { return "other case"; }              }              // etc (for other part types)              else              {              }            }            // etc (for other categories)            else            {            }          }
Magic Number,BuildingCoder,MepElementShapeVersion2,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdMepElementShape.cs,GetElementShape,The following statement contains a magic number: if( is_element_of_category( e'            BuiltInCategory.OST_DuctCurves ) )          {            // assuming that transition is using to change shape..              ConnectorManager cm = ( e as MEPCurve )              .ConnectorManager;              foreach( Connector c in cm.Connectors )              return c.Shape.ToString()                + " 2 " + c.Shape.ToString();          }          else if( is_element_of_category( e'            BuiltInCategory.OST_DuctFitting ) )          {            MEPSystem system              = ExtractMechanicalOrPipingSystem( e );              FamilyInstance fi = e as FamilyInstance;            MEPModel mm = fi.MEPModel;              ConnectorSet connectors              = mm.ConnectorManager.Connectors;              if( fi != null && mm is MechanicalFitting )            {              PartType partType                = ( mm as MechanicalFitting ).PartType;                if( PartType.Elbow == partType )              {                // assuming that transition is using to change shape..                  foreach( Connector c in connectors )                {                  return c.Shape.ToString()                    + " 2 " + c.Shape.ToString();                }              }              else if( PartType.Transition == partType )              {                string[] tmp = new string[2];                  if( system != null )                {                  foreach( Connector c in connectors )                  {                    if( c.Direction == FlowDirectionType.In )                      tmp[0] = c.Shape.ToString();                      if( c.Direction == FlowDirectionType.Out )                      tmp[1] = c.Shape.ToString();                  }                  return string.Join( " 2 "' tmp );                }                else                {                  int i = 0;                    foreach( Connector c in connectors )                  {                    if( pe != null )                    {                      if( is_connected_to( c' pe ) )                        tmp[0] = c.Shape.ToString();                      else                        tmp[1] = c.Shape.ToString();                    }                    else                    {                      tmp[i] = c.Shape.ToString();                    }                    ++i;                  }                    if( pe != null )                    return string.Join( " 2 "' tmp );                    return string.Join( "-"' tmp );                }              }              else if( PartType.Tee == partType                || PartType.Cross == partType                || PartType.Pants == partType                || PartType.Wye == partType )              {                string from' to;                from = to = null;                List<string> unk = new List<string>();                  if( system != null )                {                  foreach( Connector c in connectors )                  {                    if( c.Direction == FlowDirectionType.In )                      from = c.Shape.ToString();                    else                      unk.Add( c.Shape.ToString() );                      if( ne != null && is_connected_to( c' ne ) )                      to = c.Shape.ToString();                  }                    if( to != null )                    return from + " 2 " + to;                    return from + " 2 " + string.Join( "-"'                    unk.ToArray() );                }                else                {                  foreach( Connector c in connectors )                  {                    if( ne != null && is_connected_to(                      c' ne ) )                    {                      to = c.Shape.ToString();                      continue;                    }                      if( pe != null && is_connected_to(                      c' pe ) )                    {                      from = c.Shape.ToString();                      continue;                    }                      unk.Add( c.Shape.ToString() );                  }                    if( to != null )                    return from + " 2 " + to;                    if( from != null )                    return from + " 2 "                      + string.Join( "-"' unk.ToArray() );                    return string.Join( "-"' unk.ToArray() );                }              }            }          }
Magic Number,BuildingCoder,CmdMidCurve,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdMidCurve.cs,Execute,The following statement contains a magic number: if( 2 > n )        {          message = _prompt;          return Result.Failed;        }
Magic Number,BuildingCoder,CmdMidCurve,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdMidCurve.cs,Execute,The following statement contains a magic number: if( 2 < n )        {          // Else' check for a pre-selection.            curves.Clear();            Selection sel = uidoc.Selection;          ICollection<ElementId> ids = sel.GetElementIds();          n = ids.Count;            Debug.Print( "{0} pre-selected elements."'            n );            // If two or more model curves were pre-          // selected' use the first two encountered.            if( 1 < n )          {            foreach( ElementId id in ids )            {              CurveElement c = doc.GetElement( id )                 as CurveElement;                if( null != c )              {                curves.Add( c );                  if( 2 == curves.Count )                {                  Debug.Print( "Found two model curves' "                    + "ignoring everything else." );                    break;                }              }            }          }            // Else' prompt for an           // interactive post-selection.            if( 2 != curves.Count )          {            curves.Clear();              ISelectionFilter f              = new JtElementsOfClassSelectionFilter<CurveElement>();              try            {              Reference r = sel.PickObject(                ObjectType.Element' f'                "Please pick first model curve." );                curves.Add( doc.GetElement( r.ElementId )                as CurveElement );            }            catch( Autodesk.Revit.Exceptions              .OperationCanceledException )            {              return Result.Cancelled;            }              try            {              Reference r = sel.PickObject(                ObjectType.Element' f'                "Please pick second model curve." );                curves.Add( doc.GetElement( r.ElementId )                as CurveElement );            }            catch( Autodesk.Revit.Exceptions              .OperationCanceledException )            {              return Result.Cancelled;            }          }        }
Magic Number,BuildingCoder,CmdMidCurve,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdMidCurve.cs,Execute,The following statement contains a magic number: if( 2 < n )        {          // Else' check for a pre-selection.            curves.Clear();            Selection sel = uidoc.Selection;          ICollection<ElementId> ids = sel.GetElementIds();          n = ids.Count;            Debug.Print( "{0} pre-selected elements."'            n );            // If two or more model curves were pre-          // selected' use the first two encountered.            if( 1 < n )          {            foreach( ElementId id in ids )            {              CurveElement c = doc.GetElement( id )                 as CurveElement;                if( null != c )              {                curves.Add( c );                  if( 2 == curves.Count )                {                  Debug.Print( "Found two model curves' "                    + "ignoring everything else." );                    break;                }              }            }          }            // Else' prompt for an           // interactive post-selection.            if( 2 != curves.Count )          {            curves.Clear();              ISelectionFilter f              = new JtElementsOfClassSelectionFilter<CurveElement>();              try            {              Reference r = sel.PickObject(                ObjectType.Element' f'                "Please pick first model curve." );                curves.Add( doc.GetElement( r.ElementId )                as CurveElement );            }            catch( Autodesk.Revit.Exceptions              .OperationCanceledException )            {              return Result.Cancelled;            }              try            {              Reference r = sel.PickObject(                ObjectType.Element' f'                "Please pick second model curve." );                curves.Add( doc.GetElement( r.ElementId )                as CurveElement );            }            catch( Autodesk.Revit.Exceptions              .OperationCanceledException )            {              return Result.Cancelled;            }          }        }
Magic Number,BuildingCoder,CmdMidCurve,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdMidCurve.cs,Execute,The following statement contains a magic number: if( 2 < n )        {          // Else' check for a pre-selection.            curves.Clear();            Selection sel = uidoc.Selection;          ICollection<ElementId> ids = sel.GetElementIds();          n = ids.Count;            Debug.Print( "{0} pre-selected elements."'            n );            // If two or more model curves were pre-          // selected' use the first two encountered.            if( 1 < n )          {            foreach( ElementId id in ids )            {              CurveElement c = doc.GetElement( id )                 as CurveElement;                if( null != c )              {                curves.Add( c );                  if( 2 == curves.Count )                {                  Debug.Print( "Found two model curves' "                    + "ignoring everything else." );                    break;                }              }            }          }            // Else' prompt for an           // interactive post-selection.            if( 2 != curves.Count )          {            curves.Clear();              ISelectionFilter f              = new JtElementsOfClassSelectionFilter<CurveElement>();              try            {              Reference r = sel.PickObject(                ObjectType.Element' f'                "Please pick first model curve." );                curves.Add( doc.GetElement( r.ElementId )                as CurveElement );            }            catch( Autodesk.Revit.Exceptions              .OperationCanceledException )            {              return Result.Cancelled;            }              try            {              Reference r = sel.PickObject(                ObjectType.Element' f'                "Please pick second model curve." );                curves.Add( doc.GetElement( r.ElementId )                as CurveElement );            }            catch( Autodesk.Revit.Exceptions              .OperationCanceledException )            {              return Result.Cancelled;            }          }        }
Magic Number,BuildingCoder,CmdNewCrossFitting,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewCrossFitting.cs,IsPipeParallel,The following statement contains a magic number: return Math.Sin( c1.Direction.AngleTo(          c2.Direction ) ) < 0.01;
Magic Number,BuildingCoder,CmdNewCrossFitting,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewCrossFitting.cs,Execute,The following statement contains a magic number: while( n < 2 || 4 < n )        {          if( 0 != n )          {            Util.InfoMsg( string.Format(              "You picked {0} pipe{1}. "              + "Please only pick 2' 3 or 4."'              n' Util.PluralSuffix( n ) ) );          }            try          {            Selection sel = app.ActiveUIDocument.Selection;              pipes = sel.PickElementsByRectangle(              new JtElementsOfClassSelectionFilter<Pipe>()'              "Please pick some pipes." );          }          catch( Autodesk.Revit.Exceptions            .InvalidOperationException )          {            return Result.Cancelled;          }          n = pipes.Count;        }
Magic Number,BuildingCoder,CmdNewCrossFitting,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewCrossFitting.cs,Execute,The following statement contains a magic number: while( n < 2 || 4 < n )        {          if( 0 != n )          {            Util.InfoMsg( string.Format(              "You picked {0} pipe{1}. "              + "Please only pick 2' 3 or 4."'              n' Util.PluralSuffix( n ) ) );          }            try          {            Selection sel = app.ActiveUIDocument.Selection;              pipes = sel.PickElementsByRectangle(              new JtElementsOfClassSelectionFilter<Pipe>()'              "Please pick some pipes." );          }          catch( Autodesk.Revit.Exceptions            .InvalidOperationException )          {            return Result.Cancelled;          }          n = pipes.Count;        }
Magic Number,BuildingCoder,CmdNewCrossFitting,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewCrossFitting.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "CreateConnector" );          if( pipes.Count() <= 1 )            return Result.Cancelled;            Pipe pipe1 = pipes[0] as Pipe;          Pipe pipe2 = pipes[1] as Pipe;            Curve curve1 = pipe1.GetCurve();          Curve curve2 = pipe2.GetCurve();            XYZ p1 = curve1.GetEndPoint( 0 );          XYZ q1 = curve1.GetEndPoint( 1 );            XYZ p2 = curve2.GetEndPoint( 0 );          XYZ q2 = curve2.GetEndPoint( 1 );            if( q1.DistanceTo( p2 ) < 0.1 )          {            pt = ( q1 + p2 ) * 0.5;          }          else if( q1.DistanceTo( q2 ) < 0.1 )          {            pt = ( q1 + q2 ) * 0.5;          }          else if( p1.DistanceTo( p2 ) < 0.1 )          {            pt = ( p1 + p2 ) * 0.5;          }          else if( p1.DistanceTo( q2 ) < 0.1 )          {            pt = ( p1 + q2 ) * 0.5;          }          else          {            message = "Please select two pipes "              + "with near-by endpoints.";              return Result.Failed;          }            Connector c1 = Util.GetConnectorClosestTo(            pipe1' pt );            Connector c2 = Util.GetConnectorClosestTo(            pipe2' pt );            if( pipes.Count() == 2 )          {            if( IsPipeParallel( pipe1' pipe2 ) == true )            {              doc.Create.NewUnionFitting( c1' c2 );            }            else            {              doc.Create.NewElbowFitting( c1' c2 );            }          }          else if( pipes.Count() == 3 )          {            Pipe pipe3 = pipes[2] as Pipe;              XYZ v1 = GetPipeDirection( pipe1 );            XYZ v2 = GetPipeDirection( pipe2 );            XYZ v3 = GetPipeDirection( pipe3 );              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              if( Math.Sin( v1.AngleTo( v2 ) ) < 0.01 ) //平行            {              doc.Create.NewTeeFitting( c1' c2' c3 );            }            else //v1' 和v2 垂直.            {              if( Math.Sin( v3.AngleTo( v1 ) ) < 0.01 ) //v3' V1 平行              {                doc.Create.NewTeeFitting( c3' c1' c2 );              }              else //v3' v2 平行              {                doc.Create.NewTeeFitting( c3' c2' c1 );              }            }          }          else if( pipes.Count() == 4 )          {            Pipe pipe3 = pipes[2] as Pipe;            Pipe pipe4 = pipes[3] as Pipe;              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              Connector c4 = Util.GetConnectorClosestTo(              pipe4' pt );              //以从哪c1为入口.              // The required connection order for a cross             // fitting is main – main – side - side.              if( IsPipeParallel( pipe1' pipe2 ) )            {              doc.Create.NewCrossFitting(                c1' c2' c3' c4 );            }            else if( IsPipeParallel( pipe1' pipe3 ) )            {              try              {                doc.Create.NewCrossFitting(                  c1' c3' c2' c4 );              }              catch( Exception ex )              {                TaskDialog.Show(                  "Cannot insert cross fitting"'                  ex.Message );              }            }            else if( IsPipeParallel( pipe1' pipe4 ) )            {              doc.Create.NewCrossFitting(                c1' c4' c2' c3 );            }          }          tx.Commit();        }
Magic Number,BuildingCoder,CmdNewCrossFitting,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewCrossFitting.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "CreateConnector" );          if( pipes.Count() <= 1 )            return Result.Cancelled;            Pipe pipe1 = pipes[0] as Pipe;          Pipe pipe2 = pipes[1] as Pipe;            Curve curve1 = pipe1.GetCurve();          Curve curve2 = pipe2.GetCurve();            XYZ p1 = curve1.GetEndPoint( 0 );          XYZ q1 = curve1.GetEndPoint( 1 );            XYZ p2 = curve2.GetEndPoint( 0 );          XYZ q2 = curve2.GetEndPoint( 1 );            if( q1.DistanceTo( p2 ) < 0.1 )          {            pt = ( q1 + p2 ) * 0.5;          }          else if( q1.DistanceTo( q2 ) < 0.1 )          {            pt = ( q1 + q2 ) * 0.5;          }          else if( p1.DistanceTo( p2 ) < 0.1 )          {            pt = ( p1 + p2 ) * 0.5;          }          else if( p1.DistanceTo( q2 ) < 0.1 )          {            pt = ( p1 + q2 ) * 0.5;          }          else          {            message = "Please select two pipes "              + "with near-by endpoints.";              return Result.Failed;          }            Connector c1 = Util.GetConnectorClosestTo(            pipe1' pt );            Connector c2 = Util.GetConnectorClosestTo(            pipe2' pt );            if( pipes.Count() == 2 )          {            if( IsPipeParallel( pipe1' pipe2 ) == true )            {              doc.Create.NewUnionFitting( c1' c2 );            }            else            {              doc.Create.NewElbowFitting( c1' c2 );            }          }          else if( pipes.Count() == 3 )          {            Pipe pipe3 = pipes[2] as Pipe;              XYZ v1 = GetPipeDirection( pipe1 );            XYZ v2 = GetPipeDirection( pipe2 );            XYZ v3 = GetPipeDirection( pipe3 );              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              if( Math.Sin( v1.AngleTo( v2 ) ) < 0.01 ) //平行            {              doc.Create.NewTeeFitting( c1' c2' c3 );            }            else //v1' 和v2 垂直.            {              if( Math.Sin( v3.AngleTo( v1 ) ) < 0.01 ) //v3' V1 平行              {                doc.Create.NewTeeFitting( c3' c1' c2 );              }              else //v3' v2 平行              {                doc.Create.NewTeeFitting( c3' c2' c1 );              }            }          }          else if( pipes.Count() == 4 )          {            Pipe pipe3 = pipes[2] as Pipe;            Pipe pipe4 = pipes[3] as Pipe;              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              Connector c4 = Util.GetConnectorClosestTo(              pipe4' pt );              //以从哪c1为入口.              // The required connection order for a cross             // fitting is main – main – side - side.              if( IsPipeParallel( pipe1' pipe2 ) )            {              doc.Create.NewCrossFitting(                c1' c2' c3' c4 );            }            else if( IsPipeParallel( pipe1' pipe3 ) )            {              try              {                doc.Create.NewCrossFitting(                  c1' c3' c2' c4 );              }              catch( Exception ex )              {                TaskDialog.Show(                  "Cannot insert cross fitting"'                  ex.Message );              }            }            else if( IsPipeParallel( pipe1' pipe4 ) )            {              doc.Create.NewCrossFitting(                c1' c4' c2' c3 );            }          }          tx.Commit();        }
Magic Number,BuildingCoder,CmdNewCrossFitting,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewCrossFitting.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "CreateConnector" );          if( pipes.Count() <= 1 )            return Result.Cancelled;            Pipe pipe1 = pipes[0] as Pipe;          Pipe pipe2 = pipes[1] as Pipe;            Curve curve1 = pipe1.GetCurve();          Curve curve2 = pipe2.GetCurve();            XYZ p1 = curve1.GetEndPoint( 0 );          XYZ q1 = curve1.GetEndPoint( 1 );            XYZ p2 = curve2.GetEndPoint( 0 );          XYZ q2 = curve2.GetEndPoint( 1 );            if( q1.DistanceTo( p2 ) < 0.1 )          {            pt = ( q1 + p2 ) * 0.5;          }          else if( q1.DistanceTo( q2 ) < 0.1 )          {            pt = ( q1 + q2 ) * 0.5;          }          else if( p1.DistanceTo( p2 ) < 0.1 )          {            pt = ( p1 + p2 ) * 0.5;          }          else if( p1.DistanceTo( q2 ) < 0.1 )          {            pt = ( p1 + q2 ) * 0.5;          }          else          {            message = "Please select two pipes "              + "with near-by endpoints.";              return Result.Failed;          }            Connector c1 = Util.GetConnectorClosestTo(            pipe1' pt );            Connector c2 = Util.GetConnectorClosestTo(            pipe2' pt );            if( pipes.Count() == 2 )          {            if( IsPipeParallel( pipe1' pipe2 ) == true )            {              doc.Create.NewUnionFitting( c1' c2 );            }            else            {              doc.Create.NewElbowFitting( c1' c2 );            }          }          else if( pipes.Count() == 3 )          {            Pipe pipe3 = pipes[2] as Pipe;              XYZ v1 = GetPipeDirection( pipe1 );            XYZ v2 = GetPipeDirection( pipe2 );            XYZ v3 = GetPipeDirection( pipe3 );              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              if( Math.Sin( v1.AngleTo( v2 ) ) < 0.01 ) //平行            {              doc.Create.NewTeeFitting( c1' c2' c3 );            }            else //v1' 和v2 垂直.            {              if( Math.Sin( v3.AngleTo( v1 ) ) < 0.01 ) //v3' V1 平行              {                doc.Create.NewTeeFitting( c3' c1' c2 );              }              else //v3' v2 平行              {                doc.Create.NewTeeFitting( c3' c2' c1 );              }            }          }          else if( pipes.Count() == 4 )          {            Pipe pipe3 = pipes[2] as Pipe;            Pipe pipe4 = pipes[3] as Pipe;              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              Connector c4 = Util.GetConnectorClosestTo(              pipe4' pt );              //以从哪c1为入口.              // The required connection order for a cross             // fitting is main – main – side - side.              if( IsPipeParallel( pipe1' pipe2 ) )            {              doc.Create.NewCrossFitting(                c1' c2' c3' c4 );            }            else if( IsPipeParallel( pipe1' pipe3 ) )            {              try              {                doc.Create.NewCrossFitting(                  c1' c3' c2' c4 );              }              catch( Exception ex )              {                TaskDialog.Show(                  "Cannot insert cross fitting"'                  ex.Message );              }            }            else if( IsPipeParallel( pipe1' pipe4 ) )            {              doc.Create.NewCrossFitting(                c1' c4' c2' c3 );            }          }          tx.Commit();        }
Magic Number,BuildingCoder,CmdNewCrossFitting,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewCrossFitting.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "CreateConnector" );          if( pipes.Count() <= 1 )            return Result.Cancelled;            Pipe pipe1 = pipes[0] as Pipe;          Pipe pipe2 = pipes[1] as Pipe;            Curve curve1 = pipe1.GetCurve();          Curve curve2 = pipe2.GetCurve();            XYZ p1 = curve1.GetEndPoint( 0 );          XYZ q1 = curve1.GetEndPoint( 1 );            XYZ p2 = curve2.GetEndPoint( 0 );          XYZ q2 = curve2.GetEndPoint( 1 );            if( q1.DistanceTo( p2 ) < 0.1 )          {            pt = ( q1 + p2 ) * 0.5;          }          else if( q1.DistanceTo( q2 ) < 0.1 )          {            pt = ( q1 + q2 ) * 0.5;          }          else if( p1.DistanceTo( p2 ) < 0.1 )          {            pt = ( p1 + p2 ) * 0.5;          }          else if( p1.DistanceTo( q2 ) < 0.1 )          {            pt = ( p1 + q2 ) * 0.5;          }          else          {            message = "Please select two pipes "              + "with near-by endpoints.";              return Result.Failed;          }            Connector c1 = Util.GetConnectorClosestTo(            pipe1' pt );            Connector c2 = Util.GetConnectorClosestTo(            pipe2' pt );            if( pipes.Count() == 2 )          {            if( IsPipeParallel( pipe1' pipe2 ) == true )            {              doc.Create.NewUnionFitting( c1' c2 );            }            else            {              doc.Create.NewElbowFitting( c1' c2 );            }          }          else if( pipes.Count() == 3 )          {            Pipe pipe3 = pipes[2] as Pipe;              XYZ v1 = GetPipeDirection( pipe1 );            XYZ v2 = GetPipeDirection( pipe2 );            XYZ v3 = GetPipeDirection( pipe3 );              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              if( Math.Sin( v1.AngleTo( v2 ) ) < 0.01 ) //平行            {              doc.Create.NewTeeFitting( c1' c2' c3 );            }            else //v1' 和v2 垂直.            {              if( Math.Sin( v3.AngleTo( v1 ) ) < 0.01 ) //v3' V1 平行              {                doc.Create.NewTeeFitting( c3' c1' c2 );              }              else //v3' v2 平行              {                doc.Create.NewTeeFitting( c3' c2' c1 );              }            }          }          else if( pipes.Count() == 4 )          {            Pipe pipe3 = pipes[2] as Pipe;            Pipe pipe4 = pipes[3] as Pipe;              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              Connector c4 = Util.GetConnectorClosestTo(              pipe4' pt );              //以从哪c1为入口.              // The required connection order for a cross             // fitting is main – main – side - side.              if( IsPipeParallel( pipe1' pipe2 ) )            {              doc.Create.NewCrossFitting(                c1' c2' c3' c4 );            }            else if( IsPipeParallel( pipe1' pipe3 ) )            {              try              {                doc.Create.NewCrossFitting(                  c1' c3' c2' c4 );              }              catch( Exception ex )              {                TaskDialog.Show(                  "Cannot insert cross fitting"'                  ex.Message );              }            }            else if( IsPipeParallel( pipe1' pipe4 ) )            {              doc.Create.NewCrossFitting(                c1' c4' c2' c3 );            }          }          tx.Commit();        }
Magic Number,BuildingCoder,CmdNewCrossFitting,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewCrossFitting.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "CreateConnector" );          if( pipes.Count() <= 1 )            return Result.Cancelled;            Pipe pipe1 = pipes[0] as Pipe;          Pipe pipe2 = pipes[1] as Pipe;            Curve curve1 = pipe1.GetCurve();          Curve curve2 = pipe2.GetCurve();            XYZ p1 = curve1.GetEndPoint( 0 );          XYZ q1 = curve1.GetEndPoint( 1 );            XYZ p2 = curve2.GetEndPoint( 0 );          XYZ q2 = curve2.GetEndPoint( 1 );            if( q1.DistanceTo( p2 ) < 0.1 )          {            pt = ( q1 + p2 ) * 0.5;          }          else if( q1.DistanceTo( q2 ) < 0.1 )          {            pt = ( q1 + q2 ) * 0.5;          }          else if( p1.DistanceTo( p2 ) < 0.1 )          {            pt = ( p1 + p2 ) * 0.5;          }          else if( p1.DistanceTo( q2 ) < 0.1 )          {            pt = ( p1 + q2 ) * 0.5;          }          else          {            message = "Please select two pipes "              + "with near-by endpoints.";              return Result.Failed;          }            Connector c1 = Util.GetConnectorClosestTo(            pipe1' pt );            Connector c2 = Util.GetConnectorClosestTo(            pipe2' pt );            if( pipes.Count() == 2 )          {            if( IsPipeParallel( pipe1' pipe2 ) == true )            {              doc.Create.NewUnionFitting( c1' c2 );            }            else            {              doc.Create.NewElbowFitting( c1' c2 );            }          }          else if( pipes.Count() == 3 )          {            Pipe pipe3 = pipes[2] as Pipe;              XYZ v1 = GetPipeDirection( pipe1 );            XYZ v2 = GetPipeDirection( pipe2 );            XYZ v3 = GetPipeDirection( pipe3 );              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              if( Math.Sin( v1.AngleTo( v2 ) ) < 0.01 ) //平行            {              doc.Create.NewTeeFitting( c1' c2' c3 );            }            else //v1' 和v2 垂直.            {              if( Math.Sin( v3.AngleTo( v1 ) ) < 0.01 ) //v3' V1 平行              {                doc.Create.NewTeeFitting( c3' c1' c2 );              }              else //v3' v2 平行              {                doc.Create.NewTeeFitting( c3' c2' c1 );              }            }          }          else if( pipes.Count() == 4 )          {            Pipe pipe3 = pipes[2] as Pipe;            Pipe pipe4 = pipes[3] as Pipe;              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              Connector c4 = Util.GetConnectorClosestTo(              pipe4' pt );              //以从哪c1为入口.              // The required connection order for a cross             // fitting is main – main – side - side.              if( IsPipeParallel( pipe1' pipe2 ) )            {              doc.Create.NewCrossFitting(                c1' c2' c3' c4 );            }            else if( IsPipeParallel( pipe1' pipe3 ) )            {              try              {                doc.Create.NewCrossFitting(                  c1' c3' c2' c4 );              }              catch( Exception ex )              {                TaskDialog.Show(                  "Cannot insert cross fitting"'                  ex.Message );              }            }            else if( IsPipeParallel( pipe1' pipe4 ) )            {              doc.Create.NewCrossFitting(                c1' c4' c2' c3 );            }          }          tx.Commit();        }
Magic Number,BuildingCoder,CmdNewCrossFitting,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewCrossFitting.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "CreateConnector" );          if( pipes.Count() <= 1 )            return Result.Cancelled;            Pipe pipe1 = pipes[0] as Pipe;          Pipe pipe2 = pipes[1] as Pipe;            Curve curve1 = pipe1.GetCurve();          Curve curve2 = pipe2.GetCurve();            XYZ p1 = curve1.GetEndPoint( 0 );          XYZ q1 = curve1.GetEndPoint( 1 );            XYZ p2 = curve2.GetEndPoint( 0 );          XYZ q2 = curve2.GetEndPoint( 1 );            if( q1.DistanceTo( p2 ) < 0.1 )          {            pt = ( q1 + p2 ) * 0.5;          }          else if( q1.DistanceTo( q2 ) < 0.1 )          {            pt = ( q1 + q2 ) * 0.5;          }          else if( p1.DistanceTo( p2 ) < 0.1 )          {            pt = ( p1 + p2 ) * 0.5;          }          else if( p1.DistanceTo( q2 ) < 0.1 )          {            pt = ( p1 + q2 ) * 0.5;          }          else          {            message = "Please select two pipes "              + "with near-by endpoints.";              return Result.Failed;          }            Connector c1 = Util.GetConnectorClosestTo(            pipe1' pt );            Connector c2 = Util.GetConnectorClosestTo(            pipe2' pt );            if( pipes.Count() == 2 )          {            if( IsPipeParallel( pipe1' pipe2 ) == true )            {              doc.Create.NewUnionFitting( c1' c2 );            }            else            {              doc.Create.NewElbowFitting( c1' c2 );            }          }          else if( pipes.Count() == 3 )          {            Pipe pipe3 = pipes[2] as Pipe;              XYZ v1 = GetPipeDirection( pipe1 );            XYZ v2 = GetPipeDirection( pipe2 );            XYZ v3 = GetPipeDirection( pipe3 );              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              if( Math.Sin( v1.AngleTo( v2 ) ) < 0.01 ) //平行            {              doc.Create.NewTeeFitting( c1' c2' c3 );            }            else //v1' 和v2 垂直.            {              if( Math.Sin( v3.AngleTo( v1 ) ) < 0.01 ) //v3' V1 平行              {                doc.Create.NewTeeFitting( c3' c1' c2 );              }              else //v3' v2 平行              {                doc.Create.NewTeeFitting( c3' c2' c1 );              }            }          }          else if( pipes.Count() == 4 )          {            Pipe pipe3 = pipes[2] as Pipe;            Pipe pipe4 = pipes[3] as Pipe;              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              Connector c4 = Util.GetConnectorClosestTo(              pipe4' pt );              //以从哪c1为入口.              // The required connection order for a cross             // fitting is main – main – side - side.              if( IsPipeParallel( pipe1' pipe2 ) )            {              doc.Create.NewCrossFitting(                c1' c2' c3' c4 );            }            else if( IsPipeParallel( pipe1' pipe3 ) )            {              try              {                doc.Create.NewCrossFitting(                  c1' c3' c2' c4 );              }              catch( Exception ex )              {                TaskDialog.Show(                  "Cannot insert cross fitting"'                  ex.Message );              }            }            else if( IsPipeParallel( pipe1' pipe4 ) )            {              doc.Create.NewCrossFitting(                c1' c4' c2' c3 );            }          }          tx.Commit();        }
Magic Number,BuildingCoder,CmdNewCrossFitting,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewCrossFitting.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "CreateConnector" );          if( pipes.Count() <= 1 )            return Result.Cancelled;            Pipe pipe1 = pipes[0] as Pipe;          Pipe pipe2 = pipes[1] as Pipe;            Curve curve1 = pipe1.GetCurve();          Curve curve2 = pipe2.GetCurve();            XYZ p1 = curve1.GetEndPoint( 0 );          XYZ q1 = curve1.GetEndPoint( 1 );            XYZ p2 = curve2.GetEndPoint( 0 );          XYZ q2 = curve2.GetEndPoint( 1 );            if( q1.DistanceTo( p2 ) < 0.1 )          {            pt = ( q1 + p2 ) * 0.5;          }          else if( q1.DistanceTo( q2 ) < 0.1 )          {            pt = ( q1 + q2 ) * 0.5;          }          else if( p1.DistanceTo( p2 ) < 0.1 )          {            pt = ( p1 + p2 ) * 0.5;          }          else if( p1.DistanceTo( q2 ) < 0.1 )          {            pt = ( p1 + q2 ) * 0.5;          }          else          {            message = "Please select two pipes "              + "with near-by endpoints.";              return Result.Failed;          }            Connector c1 = Util.GetConnectorClosestTo(            pipe1' pt );            Connector c2 = Util.GetConnectorClosestTo(            pipe2' pt );            if( pipes.Count() == 2 )          {            if( IsPipeParallel( pipe1' pipe2 ) == true )            {              doc.Create.NewUnionFitting( c1' c2 );            }            else            {              doc.Create.NewElbowFitting( c1' c2 );            }          }          else if( pipes.Count() == 3 )          {            Pipe pipe3 = pipes[2] as Pipe;              XYZ v1 = GetPipeDirection( pipe1 );            XYZ v2 = GetPipeDirection( pipe2 );            XYZ v3 = GetPipeDirection( pipe3 );              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              if( Math.Sin( v1.AngleTo( v2 ) ) < 0.01 ) //平行            {              doc.Create.NewTeeFitting( c1' c2' c3 );            }            else //v1' 和v2 垂直.            {              if( Math.Sin( v3.AngleTo( v1 ) ) < 0.01 ) //v3' V1 平行              {                doc.Create.NewTeeFitting( c3' c1' c2 );              }              else //v3' v2 平行              {                doc.Create.NewTeeFitting( c3' c2' c1 );              }            }          }          else if( pipes.Count() == 4 )          {            Pipe pipe3 = pipes[2] as Pipe;            Pipe pipe4 = pipes[3] as Pipe;              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              Connector c4 = Util.GetConnectorClosestTo(              pipe4' pt );              //以从哪c1为入口.              // The required connection order for a cross             // fitting is main – main – side - side.              if( IsPipeParallel( pipe1' pipe2 ) )            {              doc.Create.NewCrossFitting(                c1' c2' c3' c4 );            }            else if( IsPipeParallel( pipe1' pipe3 ) )            {              try              {                doc.Create.NewCrossFitting(                  c1' c3' c2' c4 );              }              catch( Exception ex )              {                TaskDialog.Show(                  "Cannot insert cross fitting"'                  ex.Message );              }            }            else if( IsPipeParallel( pipe1' pipe4 ) )            {              doc.Create.NewCrossFitting(                c1' c4' c2' c3 );            }          }          tx.Commit();        }
Magic Number,BuildingCoder,CmdNewCrossFitting,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewCrossFitting.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "CreateConnector" );          if( pipes.Count() <= 1 )            return Result.Cancelled;            Pipe pipe1 = pipes[0] as Pipe;          Pipe pipe2 = pipes[1] as Pipe;            Curve curve1 = pipe1.GetCurve();          Curve curve2 = pipe2.GetCurve();            XYZ p1 = curve1.GetEndPoint( 0 );          XYZ q1 = curve1.GetEndPoint( 1 );            XYZ p2 = curve2.GetEndPoint( 0 );          XYZ q2 = curve2.GetEndPoint( 1 );            if( q1.DistanceTo( p2 ) < 0.1 )          {            pt = ( q1 + p2 ) * 0.5;          }          else if( q1.DistanceTo( q2 ) < 0.1 )          {            pt = ( q1 + q2 ) * 0.5;          }          else if( p1.DistanceTo( p2 ) < 0.1 )          {            pt = ( p1 + p2 ) * 0.5;          }          else if( p1.DistanceTo( q2 ) < 0.1 )          {            pt = ( p1 + q2 ) * 0.5;          }          else          {            message = "Please select two pipes "              + "with near-by endpoints.";              return Result.Failed;          }            Connector c1 = Util.GetConnectorClosestTo(            pipe1' pt );            Connector c2 = Util.GetConnectorClosestTo(            pipe2' pt );            if( pipes.Count() == 2 )          {            if( IsPipeParallel( pipe1' pipe2 ) == true )            {              doc.Create.NewUnionFitting( c1' c2 );            }            else            {              doc.Create.NewElbowFitting( c1' c2 );            }          }          else if( pipes.Count() == 3 )          {            Pipe pipe3 = pipes[2] as Pipe;              XYZ v1 = GetPipeDirection( pipe1 );            XYZ v2 = GetPipeDirection( pipe2 );            XYZ v3 = GetPipeDirection( pipe3 );              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              if( Math.Sin( v1.AngleTo( v2 ) ) < 0.01 ) //平行            {              doc.Create.NewTeeFitting( c1' c2' c3 );            }            else //v1' 和v2 垂直.            {              if( Math.Sin( v3.AngleTo( v1 ) ) < 0.01 ) //v3' V1 平行              {                doc.Create.NewTeeFitting( c3' c1' c2 );              }              else //v3' v2 平行              {                doc.Create.NewTeeFitting( c3' c2' c1 );              }            }          }          else if( pipes.Count() == 4 )          {            Pipe pipe3 = pipes[2] as Pipe;            Pipe pipe4 = pipes[3] as Pipe;              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              Connector c4 = Util.GetConnectorClosestTo(              pipe4' pt );              //以从哪c1为入口.              // The required connection order for a cross             // fitting is main – main – side - side.              if( IsPipeParallel( pipe1' pipe2 ) )            {              doc.Create.NewCrossFitting(                c1' c2' c3' c4 );            }            else if( IsPipeParallel( pipe1' pipe3 ) )            {              try              {                doc.Create.NewCrossFitting(                  c1' c3' c2' c4 );              }              catch( Exception ex )              {                TaskDialog.Show(                  "Cannot insert cross fitting"'                  ex.Message );              }            }            else if( IsPipeParallel( pipe1' pipe4 ) )            {              doc.Create.NewCrossFitting(                c1' c4' c2' c3 );            }          }          tx.Commit();        }
Magic Number,BuildingCoder,CmdNewCrossFitting,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewCrossFitting.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "CreateConnector" );          if( pipes.Count() <= 1 )            return Result.Cancelled;            Pipe pipe1 = pipes[0] as Pipe;          Pipe pipe2 = pipes[1] as Pipe;            Curve curve1 = pipe1.GetCurve();          Curve curve2 = pipe2.GetCurve();            XYZ p1 = curve1.GetEndPoint( 0 );          XYZ q1 = curve1.GetEndPoint( 1 );            XYZ p2 = curve2.GetEndPoint( 0 );          XYZ q2 = curve2.GetEndPoint( 1 );            if( q1.DistanceTo( p2 ) < 0.1 )          {            pt = ( q1 + p2 ) * 0.5;          }          else if( q1.DistanceTo( q2 ) < 0.1 )          {            pt = ( q1 + q2 ) * 0.5;          }          else if( p1.DistanceTo( p2 ) < 0.1 )          {            pt = ( p1 + p2 ) * 0.5;          }          else if( p1.DistanceTo( q2 ) < 0.1 )          {            pt = ( p1 + q2 ) * 0.5;          }          else          {            message = "Please select two pipes "              + "with near-by endpoints.";              return Result.Failed;          }            Connector c1 = Util.GetConnectorClosestTo(            pipe1' pt );            Connector c2 = Util.GetConnectorClosestTo(            pipe2' pt );            if( pipes.Count() == 2 )          {            if( IsPipeParallel( pipe1' pipe2 ) == true )            {              doc.Create.NewUnionFitting( c1' c2 );            }            else            {              doc.Create.NewElbowFitting( c1' c2 );            }          }          else if( pipes.Count() == 3 )          {            Pipe pipe3 = pipes[2] as Pipe;              XYZ v1 = GetPipeDirection( pipe1 );            XYZ v2 = GetPipeDirection( pipe2 );            XYZ v3 = GetPipeDirection( pipe3 );              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              if( Math.Sin( v1.AngleTo( v2 ) ) < 0.01 ) //平行            {              doc.Create.NewTeeFitting( c1' c2' c3 );            }            else //v1' 和v2 垂直.            {              if( Math.Sin( v3.AngleTo( v1 ) ) < 0.01 ) //v3' V1 平行              {                doc.Create.NewTeeFitting( c3' c1' c2 );              }              else //v3' v2 平行              {                doc.Create.NewTeeFitting( c3' c2' c1 );              }            }          }          else if( pipes.Count() == 4 )          {            Pipe pipe3 = pipes[2] as Pipe;            Pipe pipe4 = pipes[3] as Pipe;              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              Connector c4 = Util.GetConnectorClosestTo(              pipe4' pt );              //以从哪c1为入口.              // The required connection order for a cross             // fitting is main – main – side - side.              if( IsPipeParallel( pipe1' pipe2 ) )            {              doc.Create.NewCrossFitting(                c1' c2' c3' c4 );            }            else if( IsPipeParallel( pipe1' pipe3 ) )            {              try              {                doc.Create.NewCrossFitting(                  c1' c3' c2' c4 );              }              catch( Exception ex )              {                TaskDialog.Show(                  "Cannot insert cross fitting"'                  ex.Message );              }            }            else if( IsPipeParallel( pipe1' pipe4 ) )            {              doc.Create.NewCrossFitting(                c1' c4' c2' c3 );            }          }          tx.Commit();        }
Magic Number,BuildingCoder,CmdNewCrossFitting,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewCrossFitting.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "CreateConnector" );          if( pipes.Count() <= 1 )            return Result.Cancelled;            Pipe pipe1 = pipes[0] as Pipe;          Pipe pipe2 = pipes[1] as Pipe;            Curve curve1 = pipe1.GetCurve();          Curve curve2 = pipe2.GetCurve();            XYZ p1 = curve1.GetEndPoint( 0 );          XYZ q1 = curve1.GetEndPoint( 1 );            XYZ p2 = curve2.GetEndPoint( 0 );          XYZ q2 = curve2.GetEndPoint( 1 );            if( q1.DistanceTo( p2 ) < 0.1 )          {            pt = ( q1 + p2 ) * 0.5;          }          else if( q1.DistanceTo( q2 ) < 0.1 )          {            pt = ( q1 + q2 ) * 0.5;          }          else if( p1.DistanceTo( p2 ) < 0.1 )          {            pt = ( p1 + p2 ) * 0.5;          }          else if( p1.DistanceTo( q2 ) < 0.1 )          {            pt = ( p1 + q2 ) * 0.5;          }          else          {            message = "Please select two pipes "              + "with near-by endpoints.";              return Result.Failed;          }            Connector c1 = Util.GetConnectorClosestTo(            pipe1' pt );            Connector c2 = Util.GetConnectorClosestTo(            pipe2' pt );            if( pipes.Count() == 2 )          {            if( IsPipeParallel( pipe1' pipe2 ) == true )            {              doc.Create.NewUnionFitting( c1' c2 );            }            else            {              doc.Create.NewElbowFitting( c1' c2 );            }          }          else if( pipes.Count() == 3 )          {            Pipe pipe3 = pipes[2] as Pipe;              XYZ v1 = GetPipeDirection( pipe1 );            XYZ v2 = GetPipeDirection( pipe2 );            XYZ v3 = GetPipeDirection( pipe3 );              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              if( Math.Sin( v1.AngleTo( v2 ) ) < 0.01 ) //平行            {              doc.Create.NewTeeFitting( c1' c2' c3 );            }            else //v1' 和v2 垂直.            {              if( Math.Sin( v3.AngleTo( v1 ) ) < 0.01 ) //v3' V1 平行              {                doc.Create.NewTeeFitting( c3' c1' c2 );              }              else //v3' v2 平行              {                doc.Create.NewTeeFitting( c3' c2' c1 );              }            }          }          else if( pipes.Count() == 4 )          {            Pipe pipe3 = pipes[2] as Pipe;            Pipe pipe4 = pipes[3] as Pipe;              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              Connector c4 = Util.GetConnectorClosestTo(              pipe4' pt );              //以从哪c1为入口.              // The required connection order for a cross             // fitting is main – main – side - side.              if( IsPipeParallel( pipe1' pipe2 ) )            {              doc.Create.NewCrossFitting(                c1' c2' c3' c4 );            }            else if( IsPipeParallel( pipe1' pipe3 ) )            {              try              {                doc.Create.NewCrossFitting(                  c1' c3' c2' c4 );              }              catch( Exception ex )              {                TaskDialog.Show(                  "Cannot insert cross fitting"'                  ex.Message );              }            }            else if( IsPipeParallel( pipe1' pipe4 ) )            {              doc.Create.NewCrossFitting(                c1' c4' c2' c3 );            }          }          tx.Commit();        }
Magic Number,BuildingCoder,CmdNewCrossFitting,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewCrossFitting.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "CreateConnector" );          if( pipes.Count() <= 1 )            return Result.Cancelled;            Pipe pipe1 = pipes[0] as Pipe;          Pipe pipe2 = pipes[1] as Pipe;            Curve curve1 = pipe1.GetCurve();          Curve curve2 = pipe2.GetCurve();            XYZ p1 = curve1.GetEndPoint( 0 );          XYZ q1 = curve1.GetEndPoint( 1 );            XYZ p2 = curve2.GetEndPoint( 0 );          XYZ q2 = curve2.GetEndPoint( 1 );            if( q1.DistanceTo( p2 ) < 0.1 )          {            pt = ( q1 + p2 ) * 0.5;          }          else if( q1.DistanceTo( q2 ) < 0.1 )          {            pt = ( q1 + q2 ) * 0.5;          }          else if( p1.DistanceTo( p2 ) < 0.1 )          {            pt = ( p1 + p2 ) * 0.5;          }          else if( p1.DistanceTo( q2 ) < 0.1 )          {            pt = ( p1 + q2 ) * 0.5;          }          else          {            message = "Please select two pipes "              + "with near-by endpoints.";              return Result.Failed;          }            Connector c1 = Util.GetConnectorClosestTo(            pipe1' pt );            Connector c2 = Util.GetConnectorClosestTo(            pipe2' pt );            if( pipes.Count() == 2 )          {            if( IsPipeParallel( pipe1' pipe2 ) == true )            {              doc.Create.NewUnionFitting( c1' c2 );            }            else            {              doc.Create.NewElbowFitting( c1' c2 );            }          }          else if( pipes.Count() == 3 )          {            Pipe pipe3 = pipes[2] as Pipe;              XYZ v1 = GetPipeDirection( pipe1 );            XYZ v2 = GetPipeDirection( pipe2 );            XYZ v3 = GetPipeDirection( pipe3 );              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              if( Math.Sin( v1.AngleTo( v2 ) ) < 0.01 ) //平行            {              doc.Create.NewTeeFitting( c1' c2' c3 );            }            else //v1' 和v2 垂直.            {              if( Math.Sin( v3.AngleTo( v1 ) ) < 0.01 ) //v3' V1 平行              {                doc.Create.NewTeeFitting( c3' c1' c2 );              }              else //v3' v2 平行              {                doc.Create.NewTeeFitting( c3' c2' c1 );              }            }          }          else if( pipes.Count() == 4 )          {            Pipe pipe3 = pipes[2] as Pipe;            Pipe pipe4 = pipes[3] as Pipe;              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              Connector c4 = Util.GetConnectorClosestTo(              pipe4' pt );              //以从哪c1为入口.              // The required connection order for a cross             // fitting is main – main – side - side.              if( IsPipeParallel( pipe1' pipe2 ) )            {              doc.Create.NewCrossFitting(                c1' c2' c3' c4 );            }            else if( IsPipeParallel( pipe1' pipe3 ) )            {              try              {                doc.Create.NewCrossFitting(                  c1' c3' c2' c4 );              }              catch( Exception ex )              {                TaskDialog.Show(                  "Cannot insert cross fitting"'                  ex.Message );              }            }            else if( IsPipeParallel( pipe1' pipe4 ) )            {              doc.Create.NewCrossFitting(                c1' c4' c2' c3 );            }          }          tx.Commit();        }
Magic Number,BuildingCoder,CmdNewCrossFitting,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewCrossFitting.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "CreateConnector" );          if( pipes.Count() <= 1 )            return Result.Cancelled;            Pipe pipe1 = pipes[0] as Pipe;          Pipe pipe2 = pipes[1] as Pipe;            Curve curve1 = pipe1.GetCurve();          Curve curve2 = pipe2.GetCurve();            XYZ p1 = curve1.GetEndPoint( 0 );          XYZ q1 = curve1.GetEndPoint( 1 );            XYZ p2 = curve2.GetEndPoint( 0 );          XYZ q2 = curve2.GetEndPoint( 1 );            if( q1.DistanceTo( p2 ) < 0.1 )          {            pt = ( q1 + p2 ) * 0.5;          }          else if( q1.DistanceTo( q2 ) < 0.1 )          {            pt = ( q1 + q2 ) * 0.5;          }          else if( p1.DistanceTo( p2 ) < 0.1 )          {            pt = ( p1 + p2 ) * 0.5;          }          else if( p1.DistanceTo( q2 ) < 0.1 )          {            pt = ( p1 + q2 ) * 0.5;          }          else          {            message = "Please select two pipes "              + "with near-by endpoints.";              return Result.Failed;          }            Connector c1 = Util.GetConnectorClosestTo(            pipe1' pt );            Connector c2 = Util.GetConnectorClosestTo(            pipe2' pt );            if( pipes.Count() == 2 )          {            if( IsPipeParallel( pipe1' pipe2 ) == true )            {              doc.Create.NewUnionFitting( c1' c2 );            }            else            {              doc.Create.NewElbowFitting( c1' c2 );            }          }          else if( pipes.Count() == 3 )          {            Pipe pipe3 = pipes[2] as Pipe;              XYZ v1 = GetPipeDirection( pipe1 );            XYZ v2 = GetPipeDirection( pipe2 );            XYZ v3 = GetPipeDirection( pipe3 );              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              if( Math.Sin( v1.AngleTo( v2 ) ) < 0.01 ) //平行            {              doc.Create.NewTeeFitting( c1' c2' c3 );            }            else //v1' 和v2 垂直.            {              if( Math.Sin( v3.AngleTo( v1 ) ) < 0.01 ) //v3' V1 平行              {                doc.Create.NewTeeFitting( c3' c1' c2 );              }              else //v3' v2 平行              {                doc.Create.NewTeeFitting( c3' c2' c1 );              }            }          }          else if( pipes.Count() == 4 )          {            Pipe pipe3 = pipes[2] as Pipe;            Pipe pipe4 = pipes[3] as Pipe;              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              Connector c4 = Util.GetConnectorClosestTo(              pipe4' pt );              //以从哪c1为入口.              // The required connection order for a cross             // fitting is main – main – side - side.              if( IsPipeParallel( pipe1' pipe2 ) )            {              doc.Create.NewCrossFitting(                c1' c2' c3' c4 );            }            else if( IsPipeParallel( pipe1' pipe3 ) )            {              try              {                doc.Create.NewCrossFitting(                  c1' c3' c2' c4 );              }              catch( Exception ex )              {                TaskDialog.Show(                  "Cannot insert cross fitting"'                  ex.Message );              }            }            else if( IsPipeParallel( pipe1' pipe4 ) )            {              doc.Create.NewCrossFitting(                c1' c4' c2' c3 );            }          }          tx.Commit();        }
Magic Number,BuildingCoder,CmdNewCrossFitting,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewCrossFitting.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "CreateConnector" );          if( pipes.Count() <= 1 )            return Result.Cancelled;            Pipe pipe1 = pipes[0] as Pipe;          Pipe pipe2 = pipes[1] as Pipe;            Curve curve1 = pipe1.GetCurve();          Curve curve2 = pipe2.GetCurve();            XYZ p1 = curve1.GetEndPoint( 0 );          XYZ q1 = curve1.GetEndPoint( 1 );            XYZ p2 = curve2.GetEndPoint( 0 );          XYZ q2 = curve2.GetEndPoint( 1 );            if( q1.DistanceTo( p2 ) < 0.1 )          {            pt = ( q1 + p2 ) * 0.5;          }          else if( q1.DistanceTo( q2 ) < 0.1 )          {            pt = ( q1 + q2 ) * 0.5;          }          else if( p1.DistanceTo( p2 ) < 0.1 )          {            pt = ( p1 + p2 ) * 0.5;          }          else if( p1.DistanceTo( q2 ) < 0.1 )          {            pt = ( p1 + q2 ) * 0.5;          }          else          {            message = "Please select two pipes "              + "with near-by endpoints.";              return Result.Failed;          }            Connector c1 = Util.GetConnectorClosestTo(            pipe1' pt );            Connector c2 = Util.GetConnectorClosestTo(            pipe2' pt );            if( pipes.Count() == 2 )          {            if( IsPipeParallel( pipe1' pipe2 ) == true )            {              doc.Create.NewUnionFitting( c1' c2 );            }            else            {              doc.Create.NewElbowFitting( c1' c2 );            }          }          else if( pipes.Count() == 3 )          {            Pipe pipe3 = pipes[2] as Pipe;              XYZ v1 = GetPipeDirection( pipe1 );            XYZ v2 = GetPipeDirection( pipe2 );            XYZ v3 = GetPipeDirection( pipe3 );              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              if( Math.Sin( v1.AngleTo( v2 ) ) < 0.01 ) //平行            {              doc.Create.NewTeeFitting( c1' c2' c3 );            }            else //v1' 和v2 垂直.            {              if( Math.Sin( v3.AngleTo( v1 ) ) < 0.01 ) //v3' V1 平行              {                doc.Create.NewTeeFitting( c3' c1' c2 );              }              else //v3' v2 平行              {                doc.Create.NewTeeFitting( c3' c2' c1 );              }            }          }          else if( pipes.Count() == 4 )          {            Pipe pipe3 = pipes[2] as Pipe;            Pipe pipe4 = pipes[3] as Pipe;              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              Connector c4 = Util.GetConnectorClosestTo(              pipe4' pt );              //以从哪c1为入口.              // The required connection order for a cross             // fitting is main – main – side - side.              if( IsPipeParallel( pipe1' pipe2 ) )            {              doc.Create.NewCrossFitting(                c1' c2' c3' c4 );            }            else if( IsPipeParallel( pipe1' pipe3 ) )            {              try              {                doc.Create.NewCrossFitting(                  c1' c3' c2' c4 );              }              catch( Exception ex )              {                TaskDialog.Show(                  "Cannot insert cross fitting"'                  ex.Message );              }            }            else if( IsPipeParallel( pipe1' pipe4 ) )            {              doc.Create.NewCrossFitting(                c1' c4' c2' c3 );            }          }          tx.Commit();        }
Magic Number,BuildingCoder,CmdNewCrossFitting,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewCrossFitting.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "CreateConnector" );          if( pipes.Count() <= 1 )            return Result.Cancelled;            Pipe pipe1 = pipes[0] as Pipe;          Pipe pipe2 = pipes[1] as Pipe;            Curve curve1 = pipe1.GetCurve();          Curve curve2 = pipe2.GetCurve();            XYZ p1 = curve1.GetEndPoint( 0 );          XYZ q1 = curve1.GetEndPoint( 1 );            XYZ p2 = curve2.GetEndPoint( 0 );          XYZ q2 = curve2.GetEndPoint( 1 );            if( q1.DistanceTo( p2 ) < 0.1 )          {            pt = ( q1 + p2 ) * 0.5;          }          else if( q1.DistanceTo( q2 ) < 0.1 )          {            pt = ( q1 + q2 ) * 0.5;          }          else if( p1.DistanceTo( p2 ) < 0.1 )          {            pt = ( p1 + p2 ) * 0.5;          }          else if( p1.DistanceTo( q2 ) < 0.1 )          {            pt = ( p1 + q2 ) * 0.5;          }          else          {            message = "Please select two pipes "              + "with near-by endpoints.";              return Result.Failed;          }            Connector c1 = Util.GetConnectorClosestTo(            pipe1' pt );            Connector c2 = Util.GetConnectorClosestTo(            pipe2' pt );            if( pipes.Count() == 2 )          {            if( IsPipeParallel( pipe1' pipe2 ) == true )            {              doc.Create.NewUnionFitting( c1' c2 );            }            else            {              doc.Create.NewElbowFitting( c1' c2 );            }          }          else if( pipes.Count() == 3 )          {            Pipe pipe3 = pipes[2] as Pipe;              XYZ v1 = GetPipeDirection( pipe1 );            XYZ v2 = GetPipeDirection( pipe2 );            XYZ v3 = GetPipeDirection( pipe3 );              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              if( Math.Sin( v1.AngleTo( v2 ) ) < 0.01 ) //平行            {              doc.Create.NewTeeFitting( c1' c2' c3 );            }            else //v1' 和v2 垂直.            {              if( Math.Sin( v3.AngleTo( v1 ) ) < 0.01 ) //v3' V1 平行              {                doc.Create.NewTeeFitting( c3' c1' c2 );              }              else //v3' v2 平行              {                doc.Create.NewTeeFitting( c3' c2' c1 );              }            }          }          else if( pipes.Count() == 4 )          {            Pipe pipe3 = pipes[2] as Pipe;            Pipe pipe4 = pipes[3] as Pipe;              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              Connector c4 = Util.GetConnectorClosestTo(              pipe4' pt );              //以从哪c1为入口.              // The required connection order for a cross             // fitting is main – main – side - side.              if( IsPipeParallel( pipe1' pipe2 ) )            {              doc.Create.NewCrossFitting(                c1' c2' c3' c4 );            }            else if( IsPipeParallel( pipe1' pipe3 ) )            {              try              {                doc.Create.NewCrossFitting(                  c1' c3' c2' c4 );              }              catch( Exception ex )              {                TaskDialog.Show(                  "Cannot insert cross fitting"'                  ex.Message );              }            }            else if( IsPipeParallel( pipe1' pipe4 ) )            {              doc.Create.NewCrossFitting(                c1' c4' c2' c3 );            }          }          tx.Commit();        }
Magic Number,BuildingCoder,CmdNewCrossFitting,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewCrossFitting.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "CreateConnector" );          if( pipes.Count() <= 1 )            return Result.Cancelled;            Pipe pipe1 = pipes[0] as Pipe;          Pipe pipe2 = pipes[1] as Pipe;            Curve curve1 = pipe1.GetCurve();          Curve curve2 = pipe2.GetCurve();            XYZ p1 = curve1.GetEndPoint( 0 );          XYZ q1 = curve1.GetEndPoint( 1 );            XYZ p2 = curve2.GetEndPoint( 0 );          XYZ q2 = curve2.GetEndPoint( 1 );            if( q1.DistanceTo( p2 ) < 0.1 )          {            pt = ( q1 + p2 ) * 0.5;          }          else if( q1.DistanceTo( q2 ) < 0.1 )          {            pt = ( q1 + q2 ) * 0.5;          }          else if( p1.DistanceTo( p2 ) < 0.1 )          {            pt = ( p1 + p2 ) * 0.5;          }          else if( p1.DistanceTo( q2 ) < 0.1 )          {            pt = ( p1 + q2 ) * 0.5;          }          else          {            message = "Please select two pipes "              + "with near-by endpoints.";              return Result.Failed;          }            Connector c1 = Util.GetConnectorClosestTo(            pipe1' pt );            Connector c2 = Util.GetConnectorClosestTo(            pipe2' pt );            if( pipes.Count() == 2 )          {            if( IsPipeParallel( pipe1' pipe2 ) == true )            {              doc.Create.NewUnionFitting( c1' c2 );            }            else            {              doc.Create.NewElbowFitting( c1' c2 );            }          }          else if( pipes.Count() == 3 )          {            Pipe pipe3 = pipes[2] as Pipe;              XYZ v1 = GetPipeDirection( pipe1 );            XYZ v2 = GetPipeDirection( pipe2 );            XYZ v3 = GetPipeDirection( pipe3 );              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              if( Math.Sin( v1.AngleTo( v2 ) ) < 0.01 ) //平行            {              doc.Create.NewTeeFitting( c1' c2' c3 );            }            else //v1' 和v2 垂直.            {              if( Math.Sin( v3.AngleTo( v1 ) ) < 0.01 ) //v3' V1 平行              {                doc.Create.NewTeeFitting( c3' c1' c2 );              }              else //v3' v2 平行              {                doc.Create.NewTeeFitting( c3' c2' c1 );              }            }          }          else if( pipes.Count() == 4 )          {            Pipe pipe3 = pipes[2] as Pipe;            Pipe pipe4 = pipes[3] as Pipe;              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              Connector c4 = Util.GetConnectorClosestTo(              pipe4' pt );              //以从哪c1为入口.              // The required connection order for a cross             // fitting is main – main – side - side.              if( IsPipeParallel( pipe1' pipe2 ) )            {              doc.Create.NewCrossFitting(                c1' c2' c3' c4 );            }            else if( IsPipeParallel( pipe1' pipe3 ) )            {              try              {                doc.Create.NewCrossFitting(                  c1' c3' c2' c4 );              }              catch( Exception ex )              {                TaskDialog.Show(                  "Cannot insert cross fitting"'                  ex.Message );              }            }            else if( IsPipeParallel( pipe1' pipe4 ) )            {              doc.Create.NewCrossFitting(                c1' c4' c2' c3 );            }          }          tx.Commit();        }
Magic Number,BuildingCoder,CmdNewCrossFitting,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewCrossFitting.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "CreateConnector" );          if( pipes.Count() <= 1 )            return Result.Cancelled;            Pipe pipe1 = pipes[0] as Pipe;          Pipe pipe2 = pipes[1] as Pipe;            Curve curve1 = pipe1.GetCurve();          Curve curve2 = pipe2.GetCurve();            XYZ p1 = curve1.GetEndPoint( 0 );          XYZ q1 = curve1.GetEndPoint( 1 );            XYZ p2 = curve2.GetEndPoint( 0 );          XYZ q2 = curve2.GetEndPoint( 1 );            if( q1.DistanceTo( p2 ) < 0.1 )          {            pt = ( q1 + p2 ) * 0.5;          }          else if( q1.DistanceTo( q2 ) < 0.1 )          {            pt = ( q1 + q2 ) * 0.5;          }          else if( p1.DistanceTo( p2 ) < 0.1 )          {            pt = ( p1 + p2 ) * 0.5;          }          else if( p1.DistanceTo( q2 ) < 0.1 )          {            pt = ( p1 + q2 ) * 0.5;          }          else          {            message = "Please select two pipes "              + "with near-by endpoints.";              return Result.Failed;          }            Connector c1 = Util.GetConnectorClosestTo(            pipe1' pt );            Connector c2 = Util.GetConnectorClosestTo(            pipe2' pt );            if( pipes.Count() == 2 )          {            if( IsPipeParallel( pipe1' pipe2 ) == true )            {              doc.Create.NewUnionFitting( c1' c2 );            }            else            {              doc.Create.NewElbowFitting( c1' c2 );            }          }          else if( pipes.Count() == 3 )          {            Pipe pipe3 = pipes[2] as Pipe;              XYZ v1 = GetPipeDirection( pipe1 );            XYZ v2 = GetPipeDirection( pipe2 );            XYZ v3 = GetPipeDirection( pipe3 );              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              if( Math.Sin( v1.AngleTo( v2 ) ) < 0.01 ) //平行            {              doc.Create.NewTeeFitting( c1' c2' c3 );            }            else //v1' 和v2 垂直.            {              if( Math.Sin( v3.AngleTo( v1 ) ) < 0.01 ) //v3' V1 平行              {                doc.Create.NewTeeFitting( c3' c1' c2 );              }              else //v3' v2 平行              {                doc.Create.NewTeeFitting( c3' c2' c1 );              }            }          }          else if( pipes.Count() == 4 )          {            Pipe pipe3 = pipes[2] as Pipe;            Pipe pipe4 = pipes[3] as Pipe;              Connector c3 = Util.GetConnectorClosestTo(              pipe3' pt );              Connector c4 = Util.GetConnectorClosestTo(              pipe4' pt );              //以从哪c1为入口.              // The required connection order for a cross             // fitting is main – main – side - side.              if( IsPipeParallel( pipe1' pipe2 ) )            {              doc.Create.NewCrossFitting(                c1' c2' c3' c4 );            }            else if( IsPipeParallel( pipe1' pipe3 ) )            {              try              {                doc.Create.NewCrossFitting(                  c1' c3' c2' c4 );              }              catch( Exception ex )              {                TaskDialog.Show(                  "Cannot insert cross fitting"'                  ex.Message );              }            }            else if( IsPipeParallel( pipe1' pipe4 ) )            {              doc.Create.NewCrossFitting(                c1' c4' c2' c3 );            }          }          tx.Commit();        }
Magic Number,BuildingCoder,CmdNewExtrusionRoof,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewExtrusionRoof.cs,f,The following statement contains a magic number: while( iterator.MoveNext() )        {          ModelCurve modelCurve = iterator.Current as ModelCurve;          footprintRoof.set_DefinesSlope( modelCurve' true );          footprintRoof.set_SlopeAngle( modelCurve' 0.5 );        }
Magic Number,BuildingCoder,CmdNewExtrusionRoof,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewExtrusionRoof.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "NewExtrusionRoof" );            RoofType fs            = new FilteredElementCollector( doc )              .OfClass( typeof( RoofType ) )              .Cast<RoofType>()              .FirstOrDefault<RoofType>( a => null != a );            Level lvl            = new FilteredElementCollector( doc )              .OfClass( typeof( Level ) )              .Cast<Level>()              .FirstOrDefault<Level>( a => null != a );            double x = 1;            XYZ origin = new XYZ( x' 0' 0 );          XYZ vx = XYZ.BasisY;          XYZ vy = XYZ.BasisZ;            SketchPlane sp = SketchPlane.Create( doc'            //new Autodesk.Revit.DB.Plane( vx' vy' origin ) // 2016            Plane.CreateByOriginAndBasis( origin' vx' vy ) );// 2017            CurveArray ca = new CurveArray();            XYZ[] pts = new XYZ[] {            new XYZ( x' 1' 0 )'             new XYZ( x' 1' 1 )'             new XYZ( x' 2' 1 )'             new XYZ( x' 2' 2 )'             new XYZ( x' 3' 2 )'             new XYZ( x' 3' 3 )'             new XYZ( x' 4' 3 )'             new XYZ( x' 4' 4 ) };            int n = pts.Length;            for( int i = 1; i < n; ++i )          {            ca.Append( Line.CreateBound(              pts[i - 1]' pts[i] ) );          }            doc.Create.NewModelCurveArray( ca' sp );            View v = doc.ActiveView;            ReferencePlane rp            = doc.Create.NewReferencePlane2(              origin' origin + vx' origin + vy' v );            rp.Name = "MyRoofPlane";            ExtrusionRoof er            = doc.Create.NewExtrusionRoof(              ca' rp' lvl' fs' 0' 3 );            Debug.Print( "Extrusion roof element id: "            + er.Id.ToString() );            tx.Commit();        }
Magic Number,BuildingCoder,CmdNewExtrusionRoof,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewExtrusionRoof.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "NewExtrusionRoof" );            RoofType fs            = new FilteredElementCollector( doc )              .OfClass( typeof( RoofType ) )              .Cast<RoofType>()              .FirstOrDefault<RoofType>( a => null != a );            Level lvl            = new FilteredElementCollector( doc )              .OfClass( typeof( Level ) )              .Cast<Level>()              .FirstOrDefault<Level>( a => null != a );            double x = 1;            XYZ origin = new XYZ( x' 0' 0 );          XYZ vx = XYZ.BasisY;          XYZ vy = XYZ.BasisZ;            SketchPlane sp = SketchPlane.Create( doc'            //new Autodesk.Revit.DB.Plane( vx' vy' origin ) // 2016            Plane.CreateByOriginAndBasis( origin' vx' vy ) );// 2017            CurveArray ca = new CurveArray();            XYZ[] pts = new XYZ[] {            new XYZ( x' 1' 0 )'             new XYZ( x' 1' 1 )'             new XYZ( x' 2' 1 )'             new XYZ( x' 2' 2 )'             new XYZ( x' 3' 2 )'             new XYZ( x' 3' 3 )'             new XYZ( x' 4' 3 )'             new XYZ( x' 4' 4 ) };            int n = pts.Length;            for( int i = 1; i < n; ++i )          {            ca.Append( Line.CreateBound(              pts[i - 1]' pts[i] ) );          }            doc.Create.NewModelCurveArray( ca' sp );            View v = doc.ActiveView;            ReferencePlane rp            = doc.Create.NewReferencePlane2(              origin' origin + vx' origin + vy' v );            rp.Name = "MyRoofPlane";            ExtrusionRoof er            = doc.Create.NewExtrusionRoof(              ca' rp' lvl' fs' 0' 3 );            Debug.Print( "Extrusion roof element id: "            + er.Id.ToString() );            tx.Commit();        }
Magic Number,BuildingCoder,CmdNewExtrusionRoof,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewExtrusionRoof.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "NewExtrusionRoof" );            RoofType fs            = new FilteredElementCollector( doc )              .OfClass( typeof( RoofType ) )              .Cast<RoofType>()              .FirstOrDefault<RoofType>( a => null != a );            Level lvl            = new FilteredElementCollector( doc )              .OfClass( typeof( Level ) )              .Cast<Level>()              .FirstOrDefault<Level>( a => null != a );            double x = 1;            XYZ origin = new XYZ( x' 0' 0 );          XYZ vx = XYZ.BasisY;          XYZ vy = XYZ.BasisZ;            SketchPlane sp = SketchPlane.Create( doc'            //new Autodesk.Revit.DB.Plane( vx' vy' origin ) // 2016            Plane.CreateByOriginAndBasis( origin' vx' vy ) );// 2017            CurveArray ca = new CurveArray();            XYZ[] pts = new XYZ[] {            new XYZ( x' 1' 0 )'             new XYZ( x' 1' 1 )'             new XYZ( x' 2' 1 )'             new XYZ( x' 2' 2 )'             new XYZ( x' 3' 2 )'             new XYZ( x' 3' 3 )'             new XYZ( x' 4' 3 )'             new XYZ( x' 4' 4 ) };            int n = pts.Length;            for( int i = 1; i < n; ++i )          {            ca.Append( Line.CreateBound(              pts[i - 1]' pts[i] ) );          }            doc.Create.NewModelCurveArray( ca' sp );            View v = doc.ActiveView;            ReferencePlane rp            = doc.Create.NewReferencePlane2(              origin' origin + vx' origin + vy' v );            rp.Name = "MyRoofPlane";            ExtrusionRoof er            = doc.Create.NewExtrusionRoof(              ca' rp' lvl' fs' 0' 3 );            Debug.Print( "Extrusion roof element id: "            + er.Id.ToString() );            tx.Commit();        }
Magic Number,BuildingCoder,CmdNewExtrusionRoof,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewExtrusionRoof.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "NewExtrusionRoof" );            RoofType fs            = new FilteredElementCollector( doc )              .OfClass( typeof( RoofType ) )              .Cast<RoofType>()              .FirstOrDefault<RoofType>( a => null != a );            Level lvl            = new FilteredElementCollector( doc )              .OfClass( typeof( Level ) )              .Cast<Level>()              .FirstOrDefault<Level>( a => null != a );            double x = 1;            XYZ origin = new XYZ( x' 0' 0 );          XYZ vx = XYZ.BasisY;          XYZ vy = XYZ.BasisZ;            SketchPlane sp = SketchPlane.Create( doc'            //new Autodesk.Revit.DB.Plane( vx' vy' origin ) // 2016            Plane.CreateByOriginAndBasis( origin' vx' vy ) );// 2017            CurveArray ca = new CurveArray();            XYZ[] pts = new XYZ[] {            new XYZ( x' 1' 0 )'             new XYZ( x' 1' 1 )'             new XYZ( x' 2' 1 )'             new XYZ( x' 2' 2 )'             new XYZ( x' 3' 2 )'             new XYZ( x' 3' 3 )'             new XYZ( x' 4' 3 )'             new XYZ( x' 4' 4 ) };            int n = pts.Length;            for( int i = 1; i < n; ++i )          {            ca.Append( Line.CreateBound(              pts[i - 1]' pts[i] ) );          }            doc.Create.NewModelCurveArray( ca' sp );            View v = doc.ActiveView;            ReferencePlane rp            = doc.Create.NewReferencePlane2(              origin' origin + vx' origin + vy' v );            rp.Name = "MyRoofPlane";            ExtrusionRoof er            = doc.Create.NewExtrusionRoof(              ca' rp' lvl' fs' 0' 3 );            Debug.Print( "Extrusion roof element id: "            + er.Id.ToString() );            tx.Commit();        }
Magic Number,BuildingCoder,CmdNewExtrusionRoof,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewExtrusionRoof.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "NewExtrusionRoof" );            RoofType fs            = new FilteredElementCollector( doc )              .OfClass( typeof( RoofType ) )              .Cast<RoofType>()              .FirstOrDefault<RoofType>( a => null != a );            Level lvl            = new FilteredElementCollector( doc )              .OfClass( typeof( Level ) )              .Cast<Level>()              .FirstOrDefault<Level>( a => null != a );            double x = 1;            XYZ origin = new XYZ( x' 0' 0 );          XYZ vx = XYZ.BasisY;          XYZ vy = XYZ.BasisZ;            SketchPlane sp = SketchPlane.Create( doc'            //new Autodesk.Revit.DB.Plane( vx' vy' origin ) // 2016            Plane.CreateByOriginAndBasis( origin' vx' vy ) );// 2017            CurveArray ca = new CurveArray();            XYZ[] pts = new XYZ[] {            new XYZ( x' 1' 0 )'             new XYZ( x' 1' 1 )'             new XYZ( x' 2' 1 )'             new XYZ( x' 2' 2 )'             new XYZ( x' 3' 2 )'             new XYZ( x' 3' 3 )'             new XYZ( x' 4' 3 )'             new XYZ( x' 4' 4 ) };            int n = pts.Length;            for( int i = 1; i < n; ++i )          {            ca.Append( Line.CreateBound(              pts[i - 1]' pts[i] ) );          }            doc.Create.NewModelCurveArray( ca' sp );            View v = doc.ActiveView;            ReferencePlane rp            = doc.Create.NewReferencePlane2(              origin' origin + vx' origin + vy' v );            rp.Name = "MyRoofPlane";            ExtrusionRoof er            = doc.Create.NewExtrusionRoof(              ca' rp' lvl' fs' 0' 3 );            Debug.Print( "Extrusion roof element id: "            + er.Id.ToString() );            tx.Commit();        }
Magic Number,BuildingCoder,CmdNewExtrusionRoof,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewExtrusionRoof.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "NewExtrusionRoof" );            RoofType fs            = new FilteredElementCollector( doc )              .OfClass( typeof( RoofType ) )              .Cast<RoofType>()              .FirstOrDefault<RoofType>( a => null != a );            Level lvl            = new FilteredElementCollector( doc )              .OfClass( typeof( Level ) )              .Cast<Level>()              .FirstOrDefault<Level>( a => null != a );            double x = 1;            XYZ origin = new XYZ( x' 0' 0 );          XYZ vx = XYZ.BasisY;          XYZ vy = XYZ.BasisZ;            SketchPlane sp = SketchPlane.Create( doc'            //new Autodesk.Revit.DB.Plane( vx' vy' origin ) // 2016            Plane.CreateByOriginAndBasis( origin' vx' vy ) );// 2017            CurveArray ca = new CurveArray();            XYZ[] pts = new XYZ[] {            new XYZ( x' 1' 0 )'             new XYZ( x' 1' 1 )'             new XYZ( x' 2' 1 )'             new XYZ( x' 2' 2 )'             new XYZ( x' 3' 2 )'             new XYZ( x' 3' 3 )'             new XYZ( x' 4' 3 )'             new XYZ( x' 4' 4 ) };            int n = pts.Length;            for( int i = 1; i < n; ++i )          {            ca.Append( Line.CreateBound(              pts[i - 1]' pts[i] ) );          }            doc.Create.NewModelCurveArray( ca' sp );            View v = doc.ActiveView;            ReferencePlane rp            = doc.Create.NewReferencePlane2(              origin' origin + vx' origin + vy' v );            rp.Name = "MyRoofPlane";            ExtrusionRoof er            = doc.Create.NewExtrusionRoof(              ca' rp' lvl' fs' 0' 3 );            Debug.Print( "Extrusion roof element id: "            + er.Id.ToString() );            tx.Commit();        }
Magic Number,BuildingCoder,CmdNewExtrusionRoof,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewExtrusionRoof.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "NewExtrusionRoof" );            RoofType fs            = new FilteredElementCollector( doc )              .OfClass( typeof( RoofType ) )              .Cast<RoofType>()              .FirstOrDefault<RoofType>( a => null != a );            Level lvl            = new FilteredElementCollector( doc )              .OfClass( typeof( Level ) )              .Cast<Level>()              .FirstOrDefault<Level>( a => null != a );            double x = 1;            XYZ origin = new XYZ( x' 0' 0 );          XYZ vx = XYZ.BasisY;          XYZ vy = XYZ.BasisZ;            SketchPlane sp = SketchPlane.Create( doc'            //new Autodesk.Revit.DB.Plane( vx' vy' origin ) // 2016            Plane.CreateByOriginAndBasis( origin' vx' vy ) );// 2017            CurveArray ca = new CurveArray();            XYZ[] pts = new XYZ[] {            new XYZ( x' 1' 0 )'             new XYZ( x' 1' 1 )'             new XYZ( x' 2' 1 )'             new XYZ( x' 2' 2 )'             new XYZ( x' 3' 2 )'             new XYZ( x' 3' 3 )'             new XYZ( x' 4' 3 )'             new XYZ( x' 4' 4 ) };            int n = pts.Length;            for( int i = 1; i < n; ++i )          {            ca.Append( Line.CreateBound(              pts[i - 1]' pts[i] ) );          }            doc.Create.NewModelCurveArray( ca' sp );            View v = doc.ActiveView;            ReferencePlane rp            = doc.Create.NewReferencePlane2(              origin' origin + vx' origin + vy' v );            rp.Name = "MyRoofPlane";            ExtrusionRoof er            = doc.Create.NewExtrusionRoof(              ca' rp' lvl' fs' 0' 3 );            Debug.Print( "Extrusion roof element id: "            + er.Id.ToString() );            tx.Commit();        }
Magic Number,BuildingCoder,CmdNewExtrusionRoof,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewExtrusionRoof.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "NewExtrusionRoof" );            RoofType fs            = new FilteredElementCollector( doc )              .OfClass( typeof( RoofType ) )              .Cast<RoofType>()              .FirstOrDefault<RoofType>( a => null != a );            Level lvl            = new FilteredElementCollector( doc )              .OfClass( typeof( Level ) )              .Cast<Level>()              .FirstOrDefault<Level>( a => null != a );            double x = 1;            XYZ origin = new XYZ( x' 0' 0 );          XYZ vx = XYZ.BasisY;          XYZ vy = XYZ.BasisZ;            SketchPlane sp = SketchPlane.Create( doc'            //new Autodesk.Revit.DB.Plane( vx' vy' origin ) // 2016            Plane.CreateByOriginAndBasis( origin' vx' vy ) );// 2017            CurveArray ca = new CurveArray();            XYZ[] pts = new XYZ[] {            new XYZ( x' 1' 0 )'             new XYZ( x' 1' 1 )'             new XYZ( x' 2' 1 )'             new XYZ( x' 2' 2 )'             new XYZ( x' 3' 2 )'             new XYZ( x' 3' 3 )'             new XYZ( x' 4' 3 )'             new XYZ( x' 4' 4 ) };            int n = pts.Length;            for( int i = 1; i < n; ++i )          {            ca.Append( Line.CreateBound(              pts[i - 1]' pts[i] ) );          }            doc.Create.NewModelCurveArray( ca' sp );            View v = doc.ActiveView;            ReferencePlane rp            = doc.Create.NewReferencePlane2(              origin' origin + vx' origin + vy' v );            rp.Name = "MyRoofPlane";            ExtrusionRoof er            = doc.Create.NewExtrusionRoof(              ca' rp' lvl' fs' 0' 3 );            Debug.Print( "Extrusion roof element id: "            + er.Id.ToString() );            tx.Commit();        }
Magic Number,BuildingCoder,CmdNewExtrusionRoof,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewExtrusionRoof.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "NewExtrusionRoof" );            RoofType fs            = new FilteredElementCollector( doc )              .OfClass( typeof( RoofType ) )              .Cast<RoofType>()              .FirstOrDefault<RoofType>( a => null != a );            Level lvl            = new FilteredElementCollector( doc )              .OfClass( typeof( Level ) )              .Cast<Level>()              .FirstOrDefault<Level>( a => null != a );            double x = 1;            XYZ origin = new XYZ( x' 0' 0 );          XYZ vx = XYZ.BasisY;          XYZ vy = XYZ.BasisZ;            SketchPlane sp = SketchPlane.Create( doc'            //new Autodesk.Revit.DB.Plane( vx' vy' origin ) // 2016            Plane.CreateByOriginAndBasis( origin' vx' vy ) );// 2017            CurveArray ca = new CurveArray();            XYZ[] pts = new XYZ[] {            new XYZ( x' 1' 0 )'             new XYZ( x' 1' 1 )'             new XYZ( x' 2' 1 )'             new XYZ( x' 2' 2 )'             new XYZ( x' 3' 2 )'             new XYZ( x' 3' 3 )'             new XYZ( x' 4' 3 )'             new XYZ( x' 4' 4 ) };            int n = pts.Length;            for( int i = 1; i < n; ++i )          {            ca.Append( Line.CreateBound(              pts[i - 1]' pts[i] ) );          }            doc.Create.NewModelCurveArray( ca' sp );            View v = doc.ActiveView;            ReferencePlane rp            = doc.Create.NewReferencePlane2(              origin' origin + vx' origin + vy' v );            rp.Name = "MyRoofPlane";            ExtrusionRoof er            = doc.Create.NewExtrusionRoof(              ca' rp' lvl' fs' 0' 3 );            Debug.Print( "Extrusion roof element id: "            + er.Id.ToString() );            tx.Commit();        }
Magic Number,BuildingCoder,CmdNewExtrusionRoof,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewExtrusionRoof.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "NewExtrusionRoof" );            RoofType fs            = new FilteredElementCollector( doc )              .OfClass( typeof( RoofType ) )              .Cast<RoofType>()              .FirstOrDefault<RoofType>( a => null != a );            Level lvl            = new FilteredElementCollector( doc )              .OfClass( typeof( Level ) )              .Cast<Level>()              .FirstOrDefault<Level>( a => null != a );            double x = 1;            XYZ origin = new XYZ( x' 0' 0 );          XYZ vx = XYZ.BasisY;          XYZ vy = XYZ.BasisZ;            SketchPlane sp = SketchPlane.Create( doc'            //new Autodesk.Revit.DB.Plane( vx' vy' origin ) // 2016            Plane.CreateByOriginAndBasis( origin' vx' vy ) );// 2017            CurveArray ca = new CurveArray();            XYZ[] pts = new XYZ[] {            new XYZ( x' 1' 0 )'             new XYZ( x' 1' 1 )'             new XYZ( x' 2' 1 )'             new XYZ( x' 2' 2 )'             new XYZ( x' 3' 2 )'             new XYZ( x' 3' 3 )'             new XYZ( x' 4' 3 )'             new XYZ( x' 4' 4 ) };            int n = pts.Length;            for( int i = 1; i < n; ++i )          {            ca.Append( Line.CreateBound(              pts[i - 1]' pts[i] ) );          }            doc.Create.NewModelCurveArray( ca' sp );            View v = doc.ActiveView;            ReferencePlane rp            = doc.Create.NewReferencePlane2(              origin' origin + vx' origin + vy' v );            rp.Name = "MyRoofPlane";            ExtrusionRoof er            = doc.Create.NewExtrusionRoof(              ca' rp' lvl' fs' 0' 3 );            Debug.Print( "Extrusion roof element id: "            + er.Id.ToString() );            tx.Commit();        }
Magic Number,BuildingCoder,CmdNewExtrusionRoof,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewExtrusionRoof.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "NewExtrusionRoof" );            RoofType fs            = new FilteredElementCollector( doc )              .OfClass( typeof( RoofType ) )              .Cast<RoofType>()              .FirstOrDefault<RoofType>( a => null != a );            Level lvl            = new FilteredElementCollector( doc )              .OfClass( typeof( Level ) )              .Cast<Level>()              .FirstOrDefault<Level>( a => null != a );            double x = 1;            XYZ origin = new XYZ( x' 0' 0 );          XYZ vx = XYZ.BasisY;          XYZ vy = XYZ.BasisZ;            SketchPlane sp = SketchPlane.Create( doc'            //new Autodesk.Revit.DB.Plane( vx' vy' origin ) // 2016            Plane.CreateByOriginAndBasis( origin' vx' vy ) );// 2017            CurveArray ca = new CurveArray();            XYZ[] pts = new XYZ[] {            new XYZ( x' 1' 0 )'             new XYZ( x' 1' 1 )'             new XYZ( x' 2' 1 )'             new XYZ( x' 2' 2 )'             new XYZ( x' 3' 2 )'             new XYZ( x' 3' 3 )'             new XYZ( x' 4' 3 )'             new XYZ( x' 4' 4 ) };            int n = pts.Length;            for( int i = 1; i < n; ++i )          {            ca.Append( Line.CreateBound(              pts[i - 1]' pts[i] ) );          }            doc.Create.NewModelCurveArray( ca' sp );            View v = doc.ActiveView;            ReferencePlane rp            = doc.Create.NewReferencePlane2(              origin' origin + vx' origin + vy' v );            rp.Name = "MyRoofPlane";            ExtrusionRoof er            = doc.Create.NewExtrusionRoof(              ca' rp' lvl' fs' 0' 3 );            Debug.Print( "Extrusion roof element id: "            + er.Id.ToString() );            tx.Commit();        }
Magic Number,BuildingCoder,CmdNewExtrusionRoof,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewExtrusionRoof.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "NewExtrusionRoof" );            RoofType fs            = new FilteredElementCollector( doc )              .OfClass( typeof( RoofType ) )              .Cast<RoofType>()              .FirstOrDefault<RoofType>( a => null != a );            Level lvl            = new FilteredElementCollector( doc )              .OfClass( typeof( Level ) )              .Cast<Level>()              .FirstOrDefault<Level>( a => null != a );            double x = 1;            XYZ origin = new XYZ( x' 0' 0 );          XYZ vx = XYZ.BasisY;          XYZ vy = XYZ.BasisZ;            SketchPlane sp = SketchPlane.Create( doc'            //new Autodesk.Revit.DB.Plane( vx' vy' origin ) // 2016            Plane.CreateByOriginAndBasis( origin' vx' vy ) );// 2017            CurveArray ca = new CurveArray();            XYZ[] pts = new XYZ[] {            new XYZ( x' 1' 0 )'             new XYZ( x' 1' 1 )'             new XYZ( x' 2' 1 )'             new XYZ( x' 2' 2 )'             new XYZ( x' 3' 2 )'             new XYZ( x' 3' 3 )'             new XYZ( x' 4' 3 )'             new XYZ( x' 4' 4 ) };            int n = pts.Length;            for( int i = 1; i < n; ++i )          {            ca.Append( Line.CreateBound(              pts[i - 1]' pts[i] ) );          }            doc.Create.NewModelCurveArray( ca' sp );            View v = doc.ActiveView;            ReferencePlane rp            = doc.Create.NewReferencePlane2(              origin' origin + vx' origin + vy' v );            rp.Name = "MyRoofPlane";            ExtrusionRoof er            = doc.Create.NewExtrusionRoof(              ca' rp' lvl' fs' 0' 3 );            Debug.Print( "Extrusion roof element id: "            + er.Id.ToString() );            tx.Commit();        }
Magic Number,BuildingCoder,CmdNewTextNote,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewTextNote.cs,Execute_1,The following statement contains a magic number: float text_type_height_mm = 6;
Magic Number,BuildingCoder,CmdNewTextNote,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewTextNote.cs,Execute_1,The following statement contains a magic number: float points_per_inch = 96;
Magic Number,BuildingCoder,CmdNewTextNote,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewTextNote.cs,Execute_1,The following statement contains a magic number: using( Transaction t = new Transaction( doc ) )        {          t.Start( "Create TextNote" );            //string s = "TEST BOLD";            string s = "The quick brown fox jumps over the lazy dog";            Size txtBox = System.Windows.Forms.TextRenderer            .MeasureText( s' font );            double w_inch = txtBox.Width / DpiX;          double v_scale = view.Scale; // ratio of true model size to paper size            Debug.Print(            "Text box width in pixels {0} = {1} inch' "            + "view scale = {2}"'            txtBox.Width' w_inch' v_scale );            double newWidth = w_inch / 12;            //TextNote txNote = doc.Create.NewTextNote(          //  doc.ActiveView' p' XYZ.BasisX' XYZ.BasisY'          //  newWidth' TextAlignFlags.TEF_ALIGN_LEFT          //  | TextAlignFlags.TEF_ALIGN_BOTTOM' s ); // 2015          //txNote.TextNoteType = textType; // 2015            TextNote txNote = TextNote.Create( doc'            doc.ActiveView.Id' p' s' textType.Id ); // 2016            Debug.Print(            "NewTextNote lineWidth {0} times view scale "            + "{1} = {2} generated TextNote.Width {3}"'            Util.RealString( newWidth )'            Util.RealString( v_scale )'            Util.RealString( newWidth * v_scale )'            Util.RealString( txNote.Width ) );            // This fails.            //Debug.Assert(          //  Util.IsEqual( newWidth * v_scale' txNote.Width )'          //  "expected the NewTextNote lineWidth "          //  + "argument to determine the resulting "          //  + "text note width" );            txNote.Width = newWidth * v_scale;            //6mm Arial          //Text box width in pixels 668 = 6.95833349227905 inch' scale 100          //NewTextNote lineWidth 0.58 times view scale 100 = 57.99 generated TextNote.Width 59.32            t.Commit();        }
Magic Number,BuildingCoder,CmdNewTextNote,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewTextNote.cs,Execute,The following statement contains a magic number: try        {          UIApplication uiApp = commandData.Application;          UIDocument uiDoc = uiApp.ActiveUIDocument;          Document dbDoc = uiDoc.Document;          View view = uiDoc.ActiveGraphicalView;            XYZ pLoc = XYZ.Zero;            try          {            pLoc = uiDoc.Selection.PickPoint(              "Please pick text insertion point" );          }          catch( Autodesk.Revit.Exceptions.OperationCanceledException )          {            Debug.WriteLine( "Operation cancelled." );            message = "Operation cancelled.";              return Result.Succeeded;          }            List<TextNoteType> noteTypeList            = new FilteredElementCollector( dbDoc )              .OfClass( typeof( TextNoteType ) )              .Cast<TextNoteType>()              .ToList();            // Sort note types into ascending text size            BuiltInParameter bipTextSize            = BuiltInParameter.TEXT_SIZE;            noteTypeList.Sort( ( a' b )            => a.get_Parameter( bipTextSize ).AsDouble()              .CompareTo(                b.get_Parameter( bipTextSize ).AsDouble() ) );            foreach( TextNoteType textType in noteTypeList )          {            Debug.WriteLine( textType.Name );              Parameter paramTextFont              = textType.get_Parameter(                BuiltInParameter.TEXT_FONT );              Parameter paramTextSize              = textType.get_Parameter(                BuiltInParameter.TEXT_SIZE );              Parameter paramBorderSize              = textType.get_Parameter(                BuiltInParameter.LEADER_OFFSET_SHEET );              Parameter paramTextBold              = textType.get_Parameter(                BuiltInParameter.TEXT_STYLE_BOLD );              Parameter paramTextItalic              = textType.get_Parameter(                BuiltInParameter.TEXT_STYLE_ITALIC );              Parameter paramTextUnderline              = textType.get_Parameter(                BuiltInParameter.TEXT_STYLE_UNDERLINE );              Parameter paramTextWidthScale              = textType.get_Parameter(                BuiltInParameter.TEXT_WIDTH_SCALE );              string fontName = paramTextFont.AsString();              double textHeight = paramTextSize.AsDouble();              bool textBold = paramTextBold.AsInteger() == 1              ? true : false;              bool textItalic = paramTextItalic.AsInteger() == 1              ? true : false;              bool textUnderline = paramTextUnderline.AsInteger() == 1              ? true : false;              double textBorder = paramBorderSize.AsDouble();              double textWidthScale = paramTextWidthScale.AsDouble();              FontStyle textStyle = FontStyle.Regular;              if( textBold )            {              textStyle |= FontStyle.Bold;            }              if( textItalic )            {              textStyle |= FontStyle.Italic;            }              if( textUnderline )            {              textStyle |= FontStyle.Underline;            }              float fontHeightInch = (float) textHeight * 12.0f;            float displayDpiX = GetDpiX();              float fontDpi = 96.0f;            float pointSize = (float) ( textHeight * 12.0 * fontDpi );              Font font = new Font( fontName' pointSize' textStyle );              int viewScale = view.Scale;              using( Transaction t = new Transaction( dbDoc ) )            {              t.Start( "Test TextNote lineWidth calculation" );                string textString = textType.Name                + " (" + fontName + " "                + ( textHeight * 304.8 ).ToString( "0.##" ) + "mm' "                + textStyle.ToString() + "' "                + ( textWidthScale * 100.0 ).ToString( "0.##" )                + "%): The quick brown fox jumps over the lazy dog.";                double stringWidthPx = GetStringWidth( textString' font );                double stringWidthIn = stringWidthPx / displayDpiX;                Debug.WriteLine( "String Width in pixels: "                + stringWidthPx.ToString( "F3" ) );              Debug.WriteLine( ( stringWidthIn * 25.4 * viewScale ).ToString( "F3" )                + " mm at 1:" + viewScale.ToString() );                double stringWidthFt = stringWidthIn / 12.0;                double lineWidth = ( ( stringWidthFt * textWidthScale )                + ( textBorder * 2.0 ) ) * viewScale;                //TextNote textNote = dbDoc.Create.NewTextNote(              //  view' pLoc' XYZ.BasisX' XYZ.BasisY' 0.001'              //  TextAlignFlags.TEF_ALIGN_LEFT              //  | TextAlignFlags.TEF_ALIGN_TOP' textString ); // 2015              //textNote.TextNoteType = textType; // 2015                TextNote textNote = TextNote.Create( dbDoc'                view.Id' pLoc' textString' textType.Id); // 2016                textNote.Width = lineWidth;                t.Commit();            }              // Place next text note below this one with 5 mm gap              pLoc += view.UpDirection.Multiply(              ( textHeight + ( 5.0 / 304.8 ) )                * viewScale ).Negate();          }        }        catch( Autodesk.Revit.Exceptions.ExternalApplicationException e )        {          message = e.Message;          Debug.WriteLine( "Exception Encountered (Application)\n"            + e.Message + "\nStack Trace: " + e.StackTrace );            commandResult = Result.Failed;        }        catch( Exception e )        {          message = e.Message;          Debug.WriteLine( "Exception Encountered (General)\n"            + e.Message + "\nStack Trace: " + e.StackTrace );            commandResult = Result.Failed;        }
Magic Number,BuildingCoder,CmdNewTextNote,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewTextNote.cs,Execute,The following statement contains a magic number: try        {          UIApplication uiApp = commandData.Application;          UIDocument uiDoc = uiApp.ActiveUIDocument;          Document dbDoc = uiDoc.Document;          View view = uiDoc.ActiveGraphicalView;            XYZ pLoc = XYZ.Zero;            try          {            pLoc = uiDoc.Selection.PickPoint(              "Please pick text insertion point" );          }          catch( Autodesk.Revit.Exceptions.OperationCanceledException )          {            Debug.WriteLine( "Operation cancelled." );            message = "Operation cancelled.";              return Result.Succeeded;          }            List<TextNoteType> noteTypeList            = new FilteredElementCollector( dbDoc )              .OfClass( typeof( TextNoteType ) )              .Cast<TextNoteType>()              .ToList();            // Sort note types into ascending text size            BuiltInParameter bipTextSize            = BuiltInParameter.TEXT_SIZE;            noteTypeList.Sort( ( a' b )            => a.get_Parameter( bipTextSize ).AsDouble()              .CompareTo(                b.get_Parameter( bipTextSize ).AsDouble() ) );            foreach( TextNoteType textType in noteTypeList )          {            Debug.WriteLine( textType.Name );              Parameter paramTextFont              = textType.get_Parameter(                BuiltInParameter.TEXT_FONT );              Parameter paramTextSize              = textType.get_Parameter(                BuiltInParameter.TEXT_SIZE );              Parameter paramBorderSize              = textType.get_Parameter(                BuiltInParameter.LEADER_OFFSET_SHEET );              Parameter paramTextBold              = textType.get_Parameter(                BuiltInParameter.TEXT_STYLE_BOLD );              Parameter paramTextItalic              = textType.get_Parameter(                BuiltInParameter.TEXT_STYLE_ITALIC );              Parameter paramTextUnderline              = textType.get_Parameter(                BuiltInParameter.TEXT_STYLE_UNDERLINE );              Parameter paramTextWidthScale              = textType.get_Parameter(                BuiltInParameter.TEXT_WIDTH_SCALE );              string fontName = paramTextFont.AsString();              double textHeight = paramTextSize.AsDouble();              bool textBold = paramTextBold.AsInteger() == 1              ? true : false;              bool textItalic = paramTextItalic.AsInteger() == 1              ? true : false;              bool textUnderline = paramTextUnderline.AsInteger() == 1              ? true : false;              double textBorder = paramBorderSize.AsDouble();              double textWidthScale = paramTextWidthScale.AsDouble();              FontStyle textStyle = FontStyle.Regular;              if( textBold )            {              textStyle |= FontStyle.Bold;            }              if( textItalic )            {              textStyle |= FontStyle.Italic;            }              if( textUnderline )            {              textStyle |= FontStyle.Underline;            }              float fontHeightInch = (float) textHeight * 12.0f;            float displayDpiX = GetDpiX();              float fontDpi = 96.0f;            float pointSize = (float) ( textHeight * 12.0 * fontDpi );              Font font = new Font( fontName' pointSize' textStyle );              int viewScale = view.Scale;              using( Transaction t = new Transaction( dbDoc ) )            {              t.Start( "Test TextNote lineWidth calculation" );                string textString = textType.Name                + " (" + fontName + " "                + ( textHeight * 304.8 ).ToString( "0.##" ) + "mm' "                + textStyle.ToString() + "' "                + ( textWidthScale * 100.0 ).ToString( "0.##" )                + "%): The quick brown fox jumps over the lazy dog.";                double stringWidthPx = GetStringWidth( textString' font );                double stringWidthIn = stringWidthPx / displayDpiX;                Debug.WriteLine( "String Width in pixels: "                + stringWidthPx.ToString( "F3" ) );              Debug.WriteLine( ( stringWidthIn * 25.4 * viewScale ).ToString( "F3" )                + " mm at 1:" + viewScale.ToString() );                double stringWidthFt = stringWidthIn / 12.0;                double lineWidth = ( ( stringWidthFt * textWidthScale )                + ( textBorder * 2.0 ) ) * viewScale;                //TextNote textNote = dbDoc.Create.NewTextNote(              //  view' pLoc' XYZ.BasisX' XYZ.BasisY' 0.001'              //  TextAlignFlags.TEF_ALIGN_LEFT              //  | TextAlignFlags.TEF_ALIGN_TOP' textString ); // 2015              //textNote.TextNoteType = textType; // 2015                TextNote textNote = TextNote.Create( dbDoc'                view.Id' pLoc' textString' textType.Id); // 2016                textNote.Width = lineWidth;                t.Commit();            }              // Place next text note below this one with 5 mm gap              pLoc += view.UpDirection.Multiply(              ( textHeight + ( 5.0 / 304.8 ) )                * viewScale ).Negate();          }        }        catch( Autodesk.Revit.Exceptions.ExternalApplicationException e )        {          message = e.Message;          Debug.WriteLine( "Exception Encountered (Application)\n"            + e.Message + "\nStack Trace: " + e.StackTrace );            commandResult = Result.Failed;        }        catch( Exception e )        {          message = e.Message;          Debug.WriteLine( "Exception Encountered (General)\n"            + e.Message + "\nStack Trace: " + e.StackTrace );            commandResult = Result.Failed;        }
Magic Number,BuildingCoder,CmdNewTextNote,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewTextNote.cs,Execute,The following statement contains a magic number: try        {          UIApplication uiApp = commandData.Application;          UIDocument uiDoc = uiApp.ActiveUIDocument;          Document dbDoc = uiDoc.Document;          View view = uiDoc.ActiveGraphicalView;            XYZ pLoc = XYZ.Zero;            try          {            pLoc = uiDoc.Selection.PickPoint(              "Please pick text insertion point" );          }          catch( Autodesk.Revit.Exceptions.OperationCanceledException )          {            Debug.WriteLine( "Operation cancelled." );            message = "Operation cancelled.";              return Result.Succeeded;          }            List<TextNoteType> noteTypeList            = new FilteredElementCollector( dbDoc )              .OfClass( typeof( TextNoteType ) )              .Cast<TextNoteType>()              .ToList();            // Sort note types into ascending text size            BuiltInParameter bipTextSize            = BuiltInParameter.TEXT_SIZE;            noteTypeList.Sort( ( a' b )            => a.get_Parameter( bipTextSize ).AsDouble()              .CompareTo(                b.get_Parameter( bipTextSize ).AsDouble() ) );            foreach( TextNoteType textType in noteTypeList )          {            Debug.WriteLine( textType.Name );              Parameter paramTextFont              = textType.get_Parameter(                BuiltInParameter.TEXT_FONT );              Parameter paramTextSize              = textType.get_Parameter(                BuiltInParameter.TEXT_SIZE );              Parameter paramBorderSize              = textType.get_Parameter(                BuiltInParameter.LEADER_OFFSET_SHEET );              Parameter paramTextBold              = textType.get_Parameter(                BuiltInParameter.TEXT_STYLE_BOLD );              Parameter paramTextItalic              = textType.get_Parameter(                BuiltInParameter.TEXT_STYLE_ITALIC );              Parameter paramTextUnderline              = textType.get_Parameter(                BuiltInParameter.TEXT_STYLE_UNDERLINE );              Parameter paramTextWidthScale              = textType.get_Parameter(                BuiltInParameter.TEXT_WIDTH_SCALE );              string fontName = paramTextFont.AsString();              double textHeight = paramTextSize.AsDouble();              bool textBold = paramTextBold.AsInteger() == 1              ? true : false;              bool textItalic = paramTextItalic.AsInteger() == 1              ? true : false;              bool textUnderline = paramTextUnderline.AsInteger() == 1              ? true : false;              double textBorder = paramBorderSize.AsDouble();              double textWidthScale = paramTextWidthScale.AsDouble();              FontStyle textStyle = FontStyle.Regular;              if( textBold )            {              textStyle |= FontStyle.Bold;            }              if( textItalic )            {              textStyle |= FontStyle.Italic;            }              if( textUnderline )            {              textStyle |= FontStyle.Underline;            }              float fontHeightInch = (float) textHeight * 12.0f;            float displayDpiX = GetDpiX();              float fontDpi = 96.0f;            float pointSize = (float) ( textHeight * 12.0 * fontDpi );              Font font = new Font( fontName' pointSize' textStyle );              int viewScale = view.Scale;              using( Transaction t = new Transaction( dbDoc ) )            {              t.Start( "Test TextNote lineWidth calculation" );                string textString = textType.Name                + " (" + fontName + " "                + ( textHeight * 304.8 ).ToString( "0.##" ) + "mm' "                + textStyle.ToString() + "' "                + ( textWidthScale * 100.0 ).ToString( "0.##" )                + "%): The quick brown fox jumps over the lazy dog.";                double stringWidthPx = GetStringWidth( textString' font );                double stringWidthIn = stringWidthPx / displayDpiX;                Debug.WriteLine( "String Width in pixels: "                + stringWidthPx.ToString( "F3" ) );              Debug.WriteLine( ( stringWidthIn * 25.4 * viewScale ).ToString( "F3" )                + " mm at 1:" + viewScale.ToString() );                double stringWidthFt = stringWidthIn / 12.0;                double lineWidth = ( ( stringWidthFt * textWidthScale )                + ( textBorder * 2.0 ) ) * viewScale;                //TextNote textNote = dbDoc.Create.NewTextNote(              //  view' pLoc' XYZ.BasisX' XYZ.BasisY' 0.001'              //  TextAlignFlags.TEF_ALIGN_LEFT              //  | TextAlignFlags.TEF_ALIGN_TOP' textString ); // 2015              //textNote.TextNoteType = textType; // 2015                TextNote textNote = TextNote.Create( dbDoc'                view.Id' pLoc' textString' textType.Id); // 2016                textNote.Width = lineWidth;                t.Commit();            }              // Place next text note below this one with 5 mm gap              pLoc += view.UpDirection.Multiply(              ( textHeight + ( 5.0 / 304.8 ) )                * viewScale ).Negate();          }        }        catch( Autodesk.Revit.Exceptions.ExternalApplicationException e )        {          message = e.Message;          Debug.WriteLine( "Exception Encountered (Application)\n"            + e.Message + "\nStack Trace: " + e.StackTrace );            commandResult = Result.Failed;        }        catch( Exception e )        {          message = e.Message;          Debug.WriteLine( "Exception Encountered (General)\n"            + e.Message + "\nStack Trace: " + e.StackTrace );            commandResult = Result.Failed;        }
Magic Number,BuildingCoder,CmdNewTextNote,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewTextNote.cs,Execute,The following statement contains a magic number: try        {          UIApplication uiApp = commandData.Application;          UIDocument uiDoc = uiApp.ActiveUIDocument;          Document dbDoc = uiDoc.Document;          View view = uiDoc.ActiveGraphicalView;            XYZ pLoc = XYZ.Zero;            try          {            pLoc = uiDoc.Selection.PickPoint(              "Please pick text insertion point" );          }          catch( Autodesk.Revit.Exceptions.OperationCanceledException )          {            Debug.WriteLine( "Operation cancelled." );            message = "Operation cancelled.";              return Result.Succeeded;          }            List<TextNoteType> noteTypeList            = new FilteredElementCollector( dbDoc )              .OfClass( typeof( TextNoteType ) )              .Cast<TextNoteType>()              .ToList();            // Sort note types into ascending text size            BuiltInParameter bipTextSize            = BuiltInParameter.TEXT_SIZE;            noteTypeList.Sort( ( a' b )            => a.get_Parameter( bipTextSize ).AsDouble()              .CompareTo(                b.get_Parameter( bipTextSize ).AsDouble() ) );            foreach( TextNoteType textType in noteTypeList )          {            Debug.WriteLine( textType.Name );              Parameter paramTextFont              = textType.get_Parameter(                BuiltInParameter.TEXT_FONT );              Parameter paramTextSize              = textType.get_Parameter(                BuiltInParameter.TEXT_SIZE );              Parameter paramBorderSize              = textType.get_Parameter(                BuiltInParameter.LEADER_OFFSET_SHEET );              Parameter paramTextBold              = textType.get_Parameter(                BuiltInParameter.TEXT_STYLE_BOLD );              Parameter paramTextItalic              = textType.get_Parameter(                BuiltInParameter.TEXT_STYLE_ITALIC );              Parameter paramTextUnderline              = textType.get_Parameter(                BuiltInParameter.TEXT_STYLE_UNDERLINE );              Parameter paramTextWidthScale              = textType.get_Parameter(                BuiltInParameter.TEXT_WIDTH_SCALE );              string fontName = paramTextFont.AsString();              double textHeight = paramTextSize.AsDouble();              bool textBold = paramTextBold.AsInteger() == 1              ? true : false;              bool textItalic = paramTextItalic.AsInteger() == 1              ? true : false;              bool textUnderline = paramTextUnderline.AsInteger() == 1              ? true : false;              double textBorder = paramBorderSize.AsDouble();              double textWidthScale = paramTextWidthScale.AsDouble();              FontStyle textStyle = FontStyle.Regular;              if( textBold )            {              textStyle |= FontStyle.Bold;            }              if( textItalic )            {              textStyle |= FontStyle.Italic;            }              if( textUnderline )            {              textStyle |= FontStyle.Underline;            }              float fontHeightInch = (float) textHeight * 12.0f;            float displayDpiX = GetDpiX();              float fontDpi = 96.0f;            float pointSize = (float) ( textHeight * 12.0 * fontDpi );              Font font = new Font( fontName' pointSize' textStyle );              int viewScale = view.Scale;              using( Transaction t = new Transaction( dbDoc ) )            {              t.Start( "Test TextNote lineWidth calculation" );                string textString = textType.Name                + " (" + fontName + " "                + ( textHeight * 304.8 ).ToString( "0.##" ) + "mm' "                + textStyle.ToString() + "' "                + ( textWidthScale * 100.0 ).ToString( "0.##" )                + "%): The quick brown fox jumps over the lazy dog.";                double stringWidthPx = GetStringWidth( textString' font );                double stringWidthIn = stringWidthPx / displayDpiX;                Debug.WriteLine( "String Width in pixels: "                + stringWidthPx.ToString( "F3" ) );              Debug.WriteLine( ( stringWidthIn * 25.4 * viewScale ).ToString( "F3" )                + " mm at 1:" + viewScale.ToString() );                double stringWidthFt = stringWidthIn / 12.0;                double lineWidth = ( ( stringWidthFt * textWidthScale )                + ( textBorder * 2.0 ) ) * viewScale;                //TextNote textNote = dbDoc.Create.NewTextNote(              //  view' pLoc' XYZ.BasisX' XYZ.BasisY' 0.001'              //  TextAlignFlags.TEF_ALIGN_LEFT              //  | TextAlignFlags.TEF_ALIGN_TOP' textString ); // 2015              //textNote.TextNoteType = textType; // 2015                TextNote textNote = TextNote.Create( dbDoc'                view.Id' pLoc' textString' textType.Id); // 2016                textNote.Width = lineWidth;                t.Commit();            }              // Place next text note below this one with 5 mm gap              pLoc += view.UpDirection.Multiply(              ( textHeight + ( 5.0 / 304.8 ) )                * viewScale ).Negate();          }        }        catch( Autodesk.Revit.Exceptions.ExternalApplicationException e )        {          message = e.Message;          Debug.WriteLine( "Exception Encountered (Application)\n"            + e.Message + "\nStack Trace: " + e.StackTrace );            commandResult = Result.Failed;        }        catch( Exception e )        {          message = e.Message;          Debug.WriteLine( "Exception Encountered (General)\n"            + e.Message + "\nStack Trace: " + e.StackTrace );            commandResult = Result.Failed;        }
Magic Number,BuildingCoder,CmdNewTextNote,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewTextNote.cs,Execute,The following statement contains a magic number: try        {          UIApplication uiApp = commandData.Application;          UIDocument uiDoc = uiApp.ActiveUIDocument;          Document dbDoc = uiDoc.Document;          View view = uiDoc.ActiveGraphicalView;            XYZ pLoc = XYZ.Zero;            try          {            pLoc = uiDoc.Selection.PickPoint(              "Please pick text insertion point" );          }          catch( Autodesk.Revit.Exceptions.OperationCanceledException )          {            Debug.WriteLine( "Operation cancelled." );            message = "Operation cancelled.";              return Result.Succeeded;          }            List<TextNoteType> noteTypeList            = new FilteredElementCollector( dbDoc )              .OfClass( typeof( TextNoteType ) )              .Cast<TextNoteType>()              .ToList();            // Sort note types into ascending text size            BuiltInParameter bipTextSize            = BuiltInParameter.TEXT_SIZE;            noteTypeList.Sort( ( a' b )            => a.get_Parameter( bipTextSize ).AsDouble()              .CompareTo(                b.get_Parameter( bipTextSize ).AsDouble() ) );            foreach( TextNoteType textType in noteTypeList )          {            Debug.WriteLine( textType.Name );              Parameter paramTextFont              = textType.get_Parameter(                BuiltInParameter.TEXT_FONT );              Parameter paramTextSize              = textType.get_Parameter(                BuiltInParameter.TEXT_SIZE );              Parameter paramBorderSize              = textType.get_Parameter(                BuiltInParameter.LEADER_OFFSET_SHEET );              Parameter paramTextBold              = textType.get_Parameter(                BuiltInParameter.TEXT_STYLE_BOLD );              Parameter paramTextItalic              = textType.get_Parameter(                BuiltInParameter.TEXT_STYLE_ITALIC );              Parameter paramTextUnderline              = textType.get_Parameter(                BuiltInParameter.TEXT_STYLE_UNDERLINE );              Parameter paramTextWidthScale              = textType.get_Parameter(                BuiltInParameter.TEXT_WIDTH_SCALE );              string fontName = paramTextFont.AsString();              double textHeight = paramTextSize.AsDouble();              bool textBold = paramTextBold.AsInteger() == 1              ? true : false;              bool textItalic = paramTextItalic.AsInteger() == 1              ? true : false;              bool textUnderline = paramTextUnderline.AsInteger() == 1              ? true : false;              double textBorder = paramBorderSize.AsDouble();              double textWidthScale = paramTextWidthScale.AsDouble();              FontStyle textStyle = FontStyle.Regular;              if( textBold )            {              textStyle |= FontStyle.Bold;            }              if( textItalic )            {              textStyle |= FontStyle.Italic;            }              if( textUnderline )            {              textStyle |= FontStyle.Underline;            }              float fontHeightInch = (float) textHeight * 12.0f;            float displayDpiX = GetDpiX();              float fontDpi = 96.0f;            float pointSize = (float) ( textHeight * 12.0 * fontDpi );              Font font = new Font( fontName' pointSize' textStyle );              int viewScale = view.Scale;              using( Transaction t = new Transaction( dbDoc ) )            {              t.Start( "Test TextNote lineWidth calculation" );                string textString = textType.Name                + " (" + fontName + " "                + ( textHeight * 304.8 ).ToString( "0.##" ) + "mm' "                + textStyle.ToString() + "' "                + ( textWidthScale * 100.0 ).ToString( "0.##" )                + "%): The quick brown fox jumps over the lazy dog.";                double stringWidthPx = GetStringWidth( textString' font );                double stringWidthIn = stringWidthPx / displayDpiX;                Debug.WriteLine( "String Width in pixels: "                + stringWidthPx.ToString( "F3" ) );              Debug.WriteLine( ( stringWidthIn * 25.4 * viewScale ).ToString( "F3" )                + " mm at 1:" + viewScale.ToString() );                double stringWidthFt = stringWidthIn / 12.0;                double lineWidth = ( ( stringWidthFt * textWidthScale )                + ( textBorder * 2.0 ) ) * viewScale;                //TextNote textNote = dbDoc.Create.NewTextNote(              //  view' pLoc' XYZ.BasisX' XYZ.BasisY' 0.001'              //  TextAlignFlags.TEF_ALIGN_LEFT              //  | TextAlignFlags.TEF_ALIGN_TOP' textString ); // 2015              //textNote.TextNoteType = textType; // 2015                TextNote textNote = TextNote.Create( dbDoc'                view.Id' pLoc' textString' textType.Id); // 2016                textNote.Width = lineWidth;                t.Commit();            }              // Place next text note below this one with 5 mm gap              pLoc += view.UpDirection.Multiply(              ( textHeight + ( 5.0 / 304.8 ) )                * viewScale ).Negate();          }        }        catch( Autodesk.Revit.Exceptions.ExternalApplicationException e )        {          message = e.Message;          Debug.WriteLine( "Exception Encountered (Application)\n"            + e.Message + "\nStack Trace: " + e.StackTrace );            commandResult = Result.Failed;        }        catch( Exception e )        {          message = e.Message;          Debug.WriteLine( "Exception Encountered (General)\n"            + e.Message + "\nStack Trace: " + e.StackTrace );            commandResult = Result.Failed;        }
Magic Number,BuildingCoder,CmdNewTextNote,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewTextNote.cs,Execute,The following statement contains a magic number: try        {          UIApplication uiApp = commandData.Application;          UIDocument uiDoc = uiApp.ActiveUIDocument;          Document dbDoc = uiDoc.Document;          View view = uiDoc.ActiveGraphicalView;            XYZ pLoc = XYZ.Zero;            try          {            pLoc = uiDoc.Selection.PickPoint(              "Please pick text insertion point" );          }          catch( Autodesk.Revit.Exceptions.OperationCanceledException )          {            Debug.WriteLine( "Operation cancelled." );            message = "Operation cancelled.";              return Result.Succeeded;          }            List<TextNoteType> noteTypeList            = new FilteredElementCollector( dbDoc )              .OfClass( typeof( TextNoteType ) )              .Cast<TextNoteType>()              .ToList();            // Sort note types into ascending text size            BuiltInParameter bipTextSize            = BuiltInParameter.TEXT_SIZE;            noteTypeList.Sort( ( a' b )            => a.get_Parameter( bipTextSize ).AsDouble()              .CompareTo(                b.get_Parameter( bipTextSize ).AsDouble() ) );            foreach( TextNoteType textType in noteTypeList )          {            Debug.WriteLine( textType.Name );              Parameter paramTextFont              = textType.get_Parameter(                BuiltInParameter.TEXT_FONT );              Parameter paramTextSize              = textType.get_Parameter(                BuiltInParameter.TEXT_SIZE );              Parameter paramBorderSize              = textType.get_Parameter(                BuiltInParameter.LEADER_OFFSET_SHEET );              Parameter paramTextBold              = textType.get_Parameter(                BuiltInParameter.TEXT_STYLE_BOLD );              Parameter paramTextItalic              = textType.get_Parameter(                BuiltInParameter.TEXT_STYLE_ITALIC );              Parameter paramTextUnderline              = textType.get_Parameter(                BuiltInParameter.TEXT_STYLE_UNDERLINE );              Parameter paramTextWidthScale              = textType.get_Parameter(                BuiltInParameter.TEXT_WIDTH_SCALE );              string fontName = paramTextFont.AsString();              double textHeight = paramTextSize.AsDouble();              bool textBold = paramTextBold.AsInteger() == 1              ? true : false;              bool textItalic = paramTextItalic.AsInteger() == 1              ? true : false;              bool textUnderline = paramTextUnderline.AsInteger() == 1              ? true : false;              double textBorder = paramBorderSize.AsDouble();              double textWidthScale = paramTextWidthScale.AsDouble();              FontStyle textStyle = FontStyle.Regular;              if( textBold )            {              textStyle |= FontStyle.Bold;            }              if( textItalic )            {              textStyle |= FontStyle.Italic;            }              if( textUnderline )            {              textStyle |= FontStyle.Underline;            }              float fontHeightInch = (float) textHeight * 12.0f;            float displayDpiX = GetDpiX();              float fontDpi = 96.0f;            float pointSize = (float) ( textHeight * 12.0 * fontDpi );              Font font = new Font( fontName' pointSize' textStyle );              int viewScale = view.Scale;              using( Transaction t = new Transaction( dbDoc ) )            {              t.Start( "Test TextNote lineWidth calculation" );                string textString = textType.Name                + " (" + fontName + " "                + ( textHeight * 304.8 ).ToString( "0.##" ) + "mm' "                + textStyle.ToString() + "' "                + ( textWidthScale * 100.0 ).ToString( "0.##" )                + "%): The quick brown fox jumps over the lazy dog.";                double stringWidthPx = GetStringWidth( textString' font );                double stringWidthIn = stringWidthPx / displayDpiX;                Debug.WriteLine( "String Width in pixels: "                + stringWidthPx.ToString( "F3" ) );              Debug.WriteLine( ( stringWidthIn * 25.4 * viewScale ).ToString( "F3" )                + " mm at 1:" + viewScale.ToString() );                double stringWidthFt = stringWidthIn / 12.0;                double lineWidth = ( ( stringWidthFt * textWidthScale )                + ( textBorder * 2.0 ) ) * viewScale;                //TextNote textNote = dbDoc.Create.NewTextNote(              //  view' pLoc' XYZ.BasisX' XYZ.BasisY' 0.001'              //  TextAlignFlags.TEF_ALIGN_LEFT              //  | TextAlignFlags.TEF_ALIGN_TOP' textString ); // 2015              //textNote.TextNoteType = textType; // 2015                TextNote textNote = TextNote.Create( dbDoc'                view.Id' pLoc' textString' textType.Id); // 2016                textNote.Width = lineWidth;                t.Commit();            }              // Place next text note below this one with 5 mm gap              pLoc += view.UpDirection.Multiply(              ( textHeight + ( 5.0 / 304.8 ) )                * viewScale ).Negate();          }        }        catch( Autodesk.Revit.Exceptions.ExternalApplicationException e )        {          message = e.Message;          Debug.WriteLine( "Exception Encountered (Application)\n"            + e.Message + "\nStack Trace: " + e.StackTrace );            commandResult = Result.Failed;        }        catch( Exception e )        {          message = e.Message;          Debug.WriteLine( "Exception Encountered (General)\n"            + e.Message + "\nStack Trace: " + e.StackTrace );            commandResult = Result.Failed;        }
Magic Number,BuildingCoder,CmdNewTextNote,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewTextNote.cs,Execute,The following statement contains a magic number: try        {          UIApplication uiApp = commandData.Application;          UIDocument uiDoc = uiApp.ActiveUIDocument;          Document dbDoc = uiDoc.Document;          View view = uiDoc.ActiveGraphicalView;            XYZ pLoc = XYZ.Zero;            try          {            pLoc = uiDoc.Selection.PickPoint(              "Please pick text insertion point" );          }          catch( Autodesk.Revit.Exceptions.OperationCanceledException )          {            Debug.WriteLine( "Operation cancelled." );            message = "Operation cancelled.";              return Result.Succeeded;          }            List<TextNoteType> noteTypeList            = new FilteredElementCollector( dbDoc )              .OfClass( typeof( TextNoteType ) )              .Cast<TextNoteType>()              .ToList();            // Sort note types into ascending text size            BuiltInParameter bipTextSize            = BuiltInParameter.TEXT_SIZE;            noteTypeList.Sort( ( a' b )            => a.get_Parameter( bipTextSize ).AsDouble()              .CompareTo(                b.get_Parameter( bipTextSize ).AsDouble() ) );            foreach( TextNoteType textType in noteTypeList )          {            Debug.WriteLine( textType.Name );              Parameter paramTextFont              = textType.get_Parameter(                BuiltInParameter.TEXT_FONT );              Parameter paramTextSize              = textType.get_Parameter(                BuiltInParameter.TEXT_SIZE );              Parameter paramBorderSize              = textType.get_Parameter(                BuiltInParameter.LEADER_OFFSET_SHEET );              Parameter paramTextBold              = textType.get_Parameter(                BuiltInParameter.TEXT_STYLE_BOLD );              Parameter paramTextItalic              = textType.get_Parameter(                BuiltInParameter.TEXT_STYLE_ITALIC );              Parameter paramTextUnderline              = textType.get_Parameter(                BuiltInParameter.TEXT_STYLE_UNDERLINE );              Parameter paramTextWidthScale              = textType.get_Parameter(                BuiltInParameter.TEXT_WIDTH_SCALE );              string fontName = paramTextFont.AsString();              double textHeight = paramTextSize.AsDouble();              bool textBold = paramTextBold.AsInteger() == 1              ? true : false;              bool textItalic = paramTextItalic.AsInteger() == 1              ? true : false;              bool textUnderline = paramTextUnderline.AsInteger() == 1              ? true : false;              double textBorder = paramBorderSize.AsDouble();              double textWidthScale = paramTextWidthScale.AsDouble();              FontStyle textStyle = FontStyle.Regular;              if( textBold )            {              textStyle |= FontStyle.Bold;            }              if( textItalic )            {              textStyle |= FontStyle.Italic;            }              if( textUnderline )            {              textStyle |= FontStyle.Underline;            }              float fontHeightInch = (float) textHeight * 12.0f;            float displayDpiX = GetDpiX();              float fontDpi = 96.0f;            float pointSize = (float) ( textHeight * 12.0 * fontDpi );              Font font = new Font( fontName' pointSize' textStyle );              int viewScale = view.Scale;              using( Transaction t = new Transaction( dbDoc ) )            {              t.Start( "Test TextNote lineWidth calculation" );                string textString = textType.Name                + " (" + fontName + " "                + ( textHeight * 304.8 ).ToString( "0.##" ) + "mm' "                + textStyle.ToString() + "' "                + ( textWidthScale * 100.0 ).ToString( "0.##" )                + "%): The quick brown fox jumps over the lazy dog.";                double stringWidthPx = GetStringWidth( textString' font );                double stringWidthIn = stringWidthPx / displayDpiX;                Debug.WriteLine( "String Width in pixels: "                + stringWidthPx.ToString( "F3" ) );              Debug.WriteLine( ( stringWidthIn * 25.4 * viewScale ).ToString( "F3" )                + " mm at 1:" + viewScale.ToString() );                double stringWidthFt = stringWidthIn / 12.0;                double lineWidth = ( ( stringWidthFt * textWidthScale )                + ( textBorder * 2.0 ) ) * viewScale;                //TextNote textNote = dbDoc.Create.NewTextNote(              //  view' pLoc' XYZ.BasisX' XYZ.BasisY' 0.001'              //  TextAlignFlags.TEF_ALIGN_LEFT              //  | TextAlignFlags.TEF_ALIGN_TOP' textString ); // 2015              //textNote.TextNoteType = textType; // 2015                TextNote textNote = TextNote.Create( dbDoc'                view.Id' pLoc' textString' textType.Id); // 2016                textNote.Width = lineWidth;                t.Commit();            }              // Place next text note below this one with 5 mm gap              pLoc += view.UpDirection.Multiply(              ( textHeight + ( 5.0 / 304.8 ) )                * viewScale ).Negate();          }        }        catch( Autodesk.Revit.Exceptions.ExternalApplicationException e )        {          message = e.Message;          Debug.WriteLine( "Exception Encountered (Application)\n"            + e.Message + "\nStack Trace: " + e.StackTrace );            commandResult = Result.Failed;        }        catch( Exception e )        {          message = e.Message;          Debug.WriteLine( "Exception Encountered (General)\n"            + e.Message + "\nStack Trace: " + e.StackTrace );            commandResult = Result.Failed;        }
Magic Number,BuildingCoder,CmdNewTextNote,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewTextNote.cs,Execute,The following statement contains a magic number: try        {          UIApplication uiApp = commandData.Application;          UIDocument uiDoc = uiApp.ActiveUIDocument;          Document dbDoc = uiDoc.Document;          View view = uiDoc.ActiveGraphicalView;            XYZ pLoc = XYZ.Zero;            try          {            pLoc = uiDoc.Selection.PickPoint(              "Please pick text insertion point" );          }          catch( Autodesk.Revit.Exceptions.OperationCanceledException )          {            Debug.WriteLine( "Operation cancelled." );            message = "Operation cancelled.";              return Result.Succeeded;          }            List<TextNoteType> noteTypeList            = new FilteredElementCollector( dbDoc )              .OfClass( typeof( TextNoteType ) )              .Cast<TextNoteType>()              .ToList();            // Sort note types into ascending text size            BuiltInParameter bipTextSize            = BuiltInParameter.TEXT_SIZE;            noteTypeList.Sort( ( a' b )            => a.get_Parameter( bipTextSize ).AsDouble()              .CompareTo(                b.get_Parameter( bipTextSize ).AsDouble() ) );            foreach( TextNoteType textType in noteTypeList )          {            Debug.WriteLine( textType.Name );              Parameter paramTextFont              = textType.get_Parameter(                BuiltInParameter.TEXT_FONT );              Parameter paramTextSize              = textType.get_Parameter(                BuiltInParameter.TEXT_SIZE );              Parameter paramBorderSize              = textType.get_Parameter(                BuiltInParameter.LEADER_OFFSET_SHEET );              Parameter paramTextBold              = textType.get_Parameter(                BuiltInParameter.TEXT_STYLE_BOLD );              Parameter paramTextItalic              = textType.get_Parameter(                BuiltInParameter.TEXT_STYLE_ITALIC );              Parameter paramTextUnderline              = textType.get_Parameter(                BuiltInParameter.TEXT_STYLE_UNDERLINE );              Parameter paramTextWidthScale              = textType.get_Parameter(                BuiltInParameter.TEXT_WIDTH_SCALE );              string fontName = paramTextFont.AsString();              double textHeight = paramTextSize.AsDouble();              bool textBold = paramTextBold.AsInteger() == 1              ? true : false;              bool textItalic = paramTextItalic.AsInteger() == 1              ? true : false;              bool textUnderline = paramTextUnderline.AsInteger() == 1              ? true : false;              double textBorder = paramBorderSize.AsDouble();              double textWidthScale = paramTextWidthScale.AsDouble();              FontStyle textStyle = FontStyle.Regular;              if( textBold )            {              textStyle |= FontStyle.Bold;            }              if( textItalic )            {              textStyle |= FontStyle.Italic;            }              if( textUnderline )            {              textStyle |= FontStyle.Underline;            }              float fontHeightInch = (float) textHeight * 12.0f;            float displayDpiX = GetDpiX();              float fontDpi = 96.0f;            float pointSize = (float) ( textHeight * 12.0 * fontDpi );              Font font = new Font( fontName' pointSize' textStyle );              int viewScale = view.Scale;              using( Transaction t = new Transaction( dbDoc ) )            {              t.Start( "Test TextNote lineWidth calculation" );                string textString = textType.Name                + " (" + fontName + " "                + ( textHeight * 304.8 ).ToString( "0.##" ) + "mm' "                + textStyle.ToString() + "' "                + ( textWidthScale * 100.0 ).ToString( "0.##" )                + "%): The quick brown fox jumps over the lazy dog.";                double stringWidthPx = GetStringWidth( textString' font );                double stringWidthIn = stringWidthPx / displayDpiX;                Debug.WriteLine( "String Width in pixels: "                + stringWidthPx.ToString( "F3" ) );              Debug.WriteLine( ( stringWidthIn * 25.4 * viewScale ).ToString( "F3" )                + " mm at 1:" + viewScale.ToString() );                double stringWidthFt = stringWidthIn / 12.0;                double lineWidth = ( ( stringWidthFt * textWidthScale )                + ( textBorder * 2.0 ) ) * viewScale;                //TextNote textNote = dbDoc.Create.NewTextNote(              //  view' pLoc' XYZ.BasisX' XYZ.BasisY' 0.001'              //  TextAlignFlags.TEF_ALIGN_LEFT              //  | TextAlignFlags.TEF_ALIGN_TOP' textString ); // 2015              //textNote.TextNoteType = textType; // 2015                TextNote textNote = TextNote.Create( dbDoc'                view.Id' pLoc' textString' textType.Id); // 2016                textNote.Width = lineWidth;                t.Commit();            }              // Place next text note below this one with 5 mm gap              pLoc += view.UpDirection.Multiply(              ( textHeight + ( 5.0 / 304.8 ) )                * viewScale ).Negate();          }        }        catch( Autodesk.Revit.Exceptions.ExternalApplicationException e )        {          message = e.Message;          Debug.WriteLine( "Exception Encountered (Application)\n"            + e.Message + "\nStack Trace: " + e.StackTrace );            commandResult = Result.Failed;        }        catch( Exception e )        {          message = e.Message;          Debug.WriteLine( "Exception Encountered (General)\n"            + e.Message + "\nStack Trace: " + e.StackTrace );            commandResult = Result.Failed;        }
Magic Number,BuildingCoder,CmdRollingOffset,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdRollingOffset.cs,GetWallThickness,The following statement contains a magic number: return 0.5 * ( douter - dinner );
Magic Number,BuildingCoder,CmdRollingOffset,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdRollingOffset.cs,Execute,The following statement contains a magic number: XYZ pm = 0.5 * ( p0 + p1 );
Magic Number,BuildingCoder,CmdRollingOffset,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdRollingOffset.cs,Execute,The following statement contains a magic number: double angle = 45 * Math.PI / 180.0;
Magic Number,BuildingCoder,CmdRollingOffset,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdRollingOffset.cs,Execute,The following statement contains a magic number: double angle = 45 * Math.PI / 180.0;
Magic Number,BuildingCoder,CmdRollingOffset,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdRollingOffset.cs,Execute,The following statement contains a magic number: double angle2 = 0.5 * Math.PI - angle;
Magic Number,BuildingCoder,CmdRollingOffset,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdRollingOffset.cs,Execute,The following statement contains a magic number: double halfLength = 0.5 * length;
Magic Number,BuildingCoder,CmdRollingOffset,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdRollingOffset.cs,Execute,The following statement contains a magic number: double remainingPipeLength          = 0.5 * ( distanceAlong - length );
Magic Number,BuildingCoder,CmdRollingOffset,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdRollingOffset.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          // Determine pipe diameter for creating           // matching pipes and fittings            Pipe pipe = pipes[0];            double diameter = pipe            .get_Parameter( bipDiameter ) // "Diameter"            .AsDouble();            // Pipe type for calls to doc.Create.NewPipe            PipeType pipe_type_standard            = new FilteredElementCollector( doc )              .OfClass( typeof( PipeType ) )              .Cast<PipeType>()              .Where<PipeType>( e                => e.Name.Equals( "Standard" ) )              .FirstOrDefault<PipeType>();            Debug.Assert(            pipe_type_standard.Id.IntegerValue.Equals(              pipe.PipeType.Id.IntegerValue )'            "expected all pipes in this simple "            + "model to use the same pipe type" );            tx.Start( "Rolling Offset" );            if( _place_model_line )          {            // Trim or extend existing pipes              ( pipes[0].Location as LocationCurve ).Curve              = Line.CreateBound( p0' q0 );              ( pipes[1].Location as LocationCurve ).Curve              = Line.CreateBound( p1' q1 );              // Add a model line for the rolling offset pipe              Creator creator = new Creator( doc );              Line line = Line.CreateBound( q0' q1 );              creator.CreateModelCurve( line );              pipe = null;          }          else if( _place_fittings )          {            // Set active work plane to the rolling             // offset plane... removed again' since            // this has no effect at all on the             // fitting placement or rotation.            //            //Plane plane = new Plane( z' q0 );            //            //SketchPlane sp = SketchPlane.Create(             //  doc' plane );            //            //uidoc.ActiveView.SketchPlane = sp;            //uidoc.ActiveView.ShowActiveWorkPlane();              FamilySymbol symbol              = new FilteredElementCollector( doc )                .OfClass( typeof( FamilySymbol ) )                .OfCategory( BuiltInCategory.OST_PipeFitting )                .Cast<FamilySymbol>()                .Where<FamilySymbol>( e                  => e.Family.Name.Contains( "Elbow - Generic" ) )                .FirstOrDefault<FamilySymbol>();              // Set up first 45 degree elbow fitting              FamilyInstance fitting0 = doc.Create              .NewFamilyInstance( q0' symbol'                StructuralType.NonStructural );              fitting0.LookupParameter( "Angle" ).Set(              45.0 * Math.PI / 180.0 );              //fitting0.get_Parameter( bipDiameter ) // does not exist            //  .Set( diameter );              fitting0.LookupParameter( "Nominal Radius" )              .Set( 0.5 * diameter );              Line axis = Line.CreateBound( p0' q0 );            angle = z.AngleTo( XYZ.BasisZ );              ElementTransformUtils.RotateElement(              doc' fitting0.Id' axis' Math.PI - angle );              Connector con0 = Util.GetConnectorClosestTo(              fitting0' p0 );              // Trim or extend existing pipe              ( pipes[0].Location as LocationCurve ).Curve              = Line.CreateBound( p0' con0.Origin );              // Connect pipe to fitting              Util.Connect( con0.Origin' pipe' fitting0 );              // Set up second 45 degree elbow fitting              FamilyInstance fitting1 = doc.Create              .NewFamilyInstance( q1' symbol'                StructuralType.NonStructural );              //fitting1.get_Parameter( "Angle" ).Set( 45.0 * Math.PI / 180.0 ); // 2014            //fitting1.get_Parameter( "Nominal Radius" ).Set( 0.5 * diameter ); // 2014              fitting1.LookupParameter( "Angle" ).Set( 45.0 * Math.PI / 180.0 ); // 2015            fitting1.LookupParameter( "Nominal Radius" ).Set( 0.5 * diameter ); // 2015              axis = Line.CreateBound(              q1' q1 + XYZ.BasisZ );              ElementTransformUtils.RotateElement(              doc' fitting1.Id' axis' Math.PI );              axis = Line.CreateBound( q1' p1 );              ElementTransformUtils.RotateElement(              doc' fitting1.Id' axis' Math.PI - angle );              Connector con1 = Util.GetConnectorClosestTo(              fitting1' p1 );              ( pipes[1].Location as LocationCurve ).Curve              = Line.CreateBound( con1.Origin' p1 );              Util.Connect( con1.Origin' fitting1' pipes[1] );              con0 = Util.GetConnectorClosestTo(              fitting0' pm );              con1 = Util.GetConnectorClosestTo(              fitting1' pm );              // Connecting one fitting to the other does            // not insert a pipe in between. If the             // system is edited later' however' the two             // fittings snap together.            //            //con0.ConnectTo( con1 );              // Create rolling offset pipe segment              //pipe = doc.Create.NewPipe( con0.Origin' // 2014            //  con1.Origin' pipe_type_standard );              pipe = Pipe.Create( doc'               pipe_type_standard.Id' levelId' con0' con1 ); // 2015              pipe.get_Parameter( bipDiameter )              .Set( diameter );              // Connect rolling offset pipe segment            // with elbow fittings at each end              Util.Connect( con0.Origin' fitting0' pipe );            Util.Connect( con1.Origin' pipe' fitting1 );          }          else          {            if( _use_static_pipe_create )            {              // Element id arguments to Pipe.Create.                ElementId idSystem;              ElementId idType;              ElementId idLevel;                // All these values are invalid for idSystem:                ElementId idSystem1 = pipe.MEPSystem.Id;              ElementId idSystem2 = ElementId.InvalidElementId;              ElementId idSystem3 = PipingSystem.Create(                doc' pipe.MEPSystem.GetTypeId()' "Tbc" )                  .Id;                // This throws an argument exception saying              // The systemTypeId is not valid piping system type.              // Parameter name: systemTypeId                //pipe = Pipe.Create( doc' idSystem'              //  idType' idLevel' q0' q1 );                // Retrieve pipe system type' e.g.               // hydronic supply.                PipingSystemType pipingSystemType                = new FilteredElementCollector( doc )                  .OfClass( typeof( PipingSystemType ) )                  .OfType<PipingSystemType>()                  .FirstOrDefault( st                    => st.SystemClassification                      == MEPSystemClassification                        .SupplyHydronic );                if( null == pipingSystemType )              {                message = "Could not find hydronic supply piping system type";                return Result.Failed;              }                idSystem = pipingSystemType.Id;                Debug.Assert( pipe.get_Parameter(                BuiltInParameter.RBS_PIPING_SYSTEM_TYPE_PARAM )                  .AsElementId().IntegerValue.Equals(                    idSystem.IntegerValue )'                  "expected same piping system element id" );                // Retrieve the PipeType.                PipeType pipeType =                new FilteredElementCollector( doc )                  .OfClass( typeof( PipeType ) )                  .OfType<PipeType>()                  .FirstOrDefault();                if( null == pipeType )              {                message = "Could not find pipe type";                return Result.Failed;              }                idType = pipeType.Id;                Debug.Assert( pipe.get_Parameter(                BuiltInParameter.ELEM_TYPE_PARAM )                  .AsElementId().IntegerValue.Equals(                    idType.IntegerValue )'                "expected same pipe type element id" );                Debug.Assert( pipe.PipeType.Id.IntegerValue                .Equals( idType.IntegerValue )'                "expected same pipe type element id" );                // Retrieve the reference level.              // pipe.LevelId is not the correct source!                idLevel = pipe.get_Parameter(                BuiltInParameter.RBS_START_LEVEL_PARAM )                  .AsElementId();                // Create the rolling offset pipe.                pipe = Pipe.Create( doc'                idSystem' idType' idLevel' q0' q1 );            }            else            {              //pipe = doc.Create.NewPipe( q0' q1' pipe_type_standard ); // 2014                pipe = Pipe.Create( doc' systemTypeId'                 pipe_type_standard.Id' levelId' q0' q1 ); // 2015            }              pipe.get_Parameter( bipDiameter )              .Set( diameter );              // Connect rolling offset pipe segment            // directly with the neighbouring original            // pipes            //            //Util.Connect( q0' pipes[0]' pipe );            //Util.Connect( q1' pipe' pipes[1] );              // NewElbowFitting performs the following:            // - select appropriate fitting family and type            // - place and orient a family instance            // - set its parameters appropriately            // - connect it with its neighbours              Connector con0 = Util.GetConnectorClosestTo(              pipes[0]' q0 );              Connector con = Util.GetConnectorClosestTo(              pipe' q0 );              doc.Create.NewElbowFitting( con0' con );              Connector con1 = Util.GetConnectorClosestTo(              pipes[1]' q1 );              con = Util.GetConnectorClosestTo(              pipe' q1 );              doc.Create.NewElbowFitting( con' con1 );          }            tx.Commit();        }
Magic Number,BuildingCoder,CmdRollingOffset,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdRollingOffset.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          // Determine pipe diameter for creating           // matching pipes and fittings            Pipe pipe = pipes[0];            double diameter = pipe            .get_Parameter( bipDiameter ) // "Diameter"            .AsDouble();            // Pipe type for calls to doc.Create.NewPipe            PipeType pipe_type_standard            = new FilteredElementCollector( doc )              .OfClass( typeof( PipeType ) )              .Cast<PipeType>()              .Where<PipeType>( e                => e.Name.Equals( "Standard" ) )              .FirstOrDefault<PipeType>();            Debug.Assert(            pipe_type_standard.Id.IntegerValue.Equals(              pipe.PipeType.Id.IntegerValue )'            "expected all pipes in this simple "            + "model to use the same pipe type" );            tx.Start( "Rolling Offset" );            if( _place_model_line )          {            // Trim or extend existing pipes              ( pipes[0].Location as LocationCurve ).Curve              = Line.CreateBound( p0' q0 );              ( pipes[1].Location as LocationCurve ).Curve              = Line.CreateBound( p1' q1 );              // Add a model line for the rolling offset pipe              Creator creator = new Creator( doc );              Line line = Line.CreateBound( q0' q1 );              creator.CreateModelCurve( line );              pipe = null;          }          else if( _place_fittings )          {            // Set active work plane to the rolling             // offset plane... removed again' since            // this has no effect at all on the             // fitting placement or rotation.            //            //Plane plane = new Plane( z' q0 );            //            //SketchPlane sp = SketchPlane.Create(             //  doc' plane );            //            //uidoc.ActiveView.SketchPlane = sp;            //uidoc.ActiveView.ShowActiveWorkPlane();              FamilySymbol symbol              = new FilteredElementCollector( doc )                .OfClass( typeof( FamilySymbol ) )                .OfCategory( BuiltInCategory.OST_PipeFitting )                .Cast<FamilySymbol>()                .Where<FamilySymbol>( e                  => e.Family.Name.Contains( "Elbow - Generic" ) )                .FirstOrDefault<FamilySymbol>();              // Set up first 45 degree elbow fitting              FamilyInstance fitting0 = doc.Create              .NewFamilyInstance( q0' symbol'                StructuralType.NonStructural );              fitting0.LookupParameter( "Angle" ).Set(              45.0 * Math.PI / 180.0 );              //fitting0.get_Parameter( bipDiameter ) // does not exist            //  .Set( diameter );              fitting0.LookupParameter( "Nominal Radius" )              .Set( 0.5 * diameter );              Line axis = Line.CreateBound( p0' q0 );            angle = z.AngleTo( XYZ.BasisZ );              ElementTransformUtils.RotateElement(              doc' fitting0.Id' axis' Math.PI - angle );              Connector con0 = Util.GetConnectorClosestTo(              fitting0' p0 );              // Trim or extend existing pipe              ( pipes[0].Location as LocationCurve ).Curve              = Line.CreateBound( p0' con0.Origin );              // Connect pipe to fitting              Util.Connect( con0.Origin' pipe' fitting0 );              // Set up second 45 degree elbow fitting              FamilyInstance fitting1 = doc.Create              .NewFamilyInstance( q1' symbol'                StructuralType.NonStructural );              //fitting1.get_Parameter( "Angle" ).Set( 45.0 * Math.PI / 180.0 ); // 2014            //fitting1.get_Parameter( "Nominal Radius" ).Set( 0.5 * diameter ); // 2014              fitting1.LookupParameter( "Angle" ).Set( 45.0 * Math.PI / 180.0 ); // 2015            fitting1.LookupParameter( "Nominal Radius" ).Set( 0.5 * diameter ); // 2015              axis = Line.CreateBound(              q1' q1 + XYZ.BasisZ );              ElementTransformUtils.RotateElement(              doc' fitting1.Id' axis' Math.PI );              axis = Line.CreateBound( q1' p1 );              ElementTransformUtils.RotateElement(              doc' fitting1.Id' axis' Math.PI - angle );              Connector con1 = Util.GetConnectorClosestTo(              fitting1' p1 );              ( pipes[1].Location as LocationCurve ).Curve              = Line.CreateBound( con1.Origin' p1 );              Util.Connect( con1.Origin' fitting1' pipes[1] );              con0 = Util.GetConnectorClosestTo(              fitting0' pm );              con1 = Util.GetConnectorClosestTo(              fitting1' pm );              // Connecting one fitting to the other does            // not insert a pipe in between. If the             // system is edited later' however' the two             // fittings snap together.            //            //con0.ConnectTo( con1 );              // Create rolling offset pipe segment              //pipe = doc.Create.NewPipe( con0.Origin' // 2014            //  con1.Origin' pipe_type_standard );              pipe = Pipe.Create( doc'               pipe_type_standard.Id' levelId' con0' con1 ); // 2015              pipe.get_Parameter( bipDiameter )              .Set( diameter );              // Connect rolling offset pipe segment            // with elbow fittings at each end              Util.Connect( con0.Origin' fitting0' pipe );            Util.Connect( con1.Origin' pipe' fitting1 );          }          else          {            if( _use_static_pipe_create )            {              // Element id arguments to Pipe.Create.                ElementId idSystem;              ElementId idType;              ElementId idLevel;                // All these values are invalid for idSystem:                ElementId idSystem1 = pipe.MEPSystem.Id;              ElementId idSystem2 = ElementId.InvalidElementId;              ElementId idSystem3 = PipingSystem.Create(                doc' pipe.MEPSystem.GetTypeId()' "Tbc" )                  .Id;                // This throws an argument exception saying              // The systemTypeId is not valid piping system type.              // Parameter name: systemTypeId                //pipe = Pipe.Create( doc' idSystem'              //  idType' idLevel' q0' q1 );                // Retrieve pipe system type' e.g.               // hydronic supply.                PipingSystemType pipingSystemType                = new FilteredElementCollector( doc )                  .OfClass( typeof( PipingSystemType ) )                  .OfType<PipingSystemType>()                  .FirstOrDefault( st                    => st.SystemClassification                      == MEPSystemClassification                        .SupplyHydronic );                if( null == pipingSystemType )              {                message = "Could not find hydronic supply piping system type";                return Result.Failed;              }                idSystem = pipingSystemType.Id;                Debug.Assert( pipe.get_Parameter(                BuiltInParameter.RBS_PIPING_SYSTEM_TYPE_PARAM )                  .AsElementId().IntegerValue.Equals(                    idSystem.IntegerValue )'                  "expected same piping system element id" );                // Retrieve the PipeType.                PipeType pipeType =                new FilteredElementCollector( doc )                  .OfClass( typeof( PipeType ) )                  .OfType<PipeType>()                  .FirstOrDefault();                if( null == pipeType )              {                message = "Could not find pipe type";                return Result.Failed;              }                idType = pipeType.Id;                Debug.Assert( pipe.get_Parameter(                BuiltInParameter.ELEM_TYPE_PARAM )                  .AsElementId().IntegerValue.Equals(                    idType.IntegerValue )'                "expected same pipe type element id" );                Debug.Assert( pipe.PipeType.Id.IntegerValue                .Equals( idType.IntegerValue )'                "expected same pipe type element id" );                // Retrieve the reference level.              // pipe.LevelId is not the correct source!                idLevel = pipe.get_Parameter(                BuiltInParameter.RBS_START_LEVEL_PARAM )                  .AsElementId();                // Create the rolling offset pipe.                pipe = Pipe.Create( doc'                idSystem' idType' idLevel' q0' q1 );            }            else            {              //pipe = doc.Create.NewPipe( q0' q1' pipe_type_standard ); // 2014                pipe = Pipe.Create( doc' systemTypeId'                 pipe_type_standard.Id' levelId' q0' q1 ); // 2015            }              pipe.get_Parameter( bipDiameter )              .Set( diameter );              // Connect rolling offset pipe segment            // directly with the neighbouring original            // pipes            //            //Util.Connect( q0' pipes[0]' pipe );            //Util.Connect( q1' pipe' pipes[1] );              // NewElbowFitting performs the following:            // - select appropriate fitting family and type            // - place and orient a family instance            // - set its parameters appropriately            // - connect it with its neighbours              Connector con0 = Util.GetConnectorClosestTo(              pipes[0]' q0 );              Connector con = Util.GetConnectorClosestTo(              pipe' q0 );              doc.Create.NewElbowFitting( con0' con );              Connector con1 = Util.GetConnectorClosestTo(              pipes[1]' q1 );              con = Util.GetConnectorClosestTo(              pipe' q1 );              doc.Create.NewElbowFitting( con' con1 );          }            tx.Commit();        }
Magic Number,BuildingCoder,CmdRollingOffset,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdRollingOffset.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          // Determine pipe diameter for creating           // matching pipes and fittings            Pipe pipe = pipes[0];            double diameter = pipe            .get_Parameter( bipDiameter ) // "Diameter"            .AsDouble();            // Pipe type for calls to doc.Create.NewPipe            PipeType pipe_type_standard            = new FilteredElementCollector( doc )              .OfClass( typeof( PipeType ) )              .Cast<PipeType>()              .Where<PipeType>( e                => e.Name.Equals( "Standard" ) )              .FirstOrDefault<PipeType>();            Debug.Assert(            pipe_type_standard.Id.IntegerValue.Equals(              pipe.PipeType.Id.IntegerValue )'            "expected all pipes in this simple "            + "model to use the same pipe type" );            tx.Start( "Rolling Offset" );            if( _place_model_line )          {            // Trim or extend existing pipes              ( pipes[0].Location as LocationCurve ).Curve              = Line.CreateBound( p0' q0 );              ( pipes[1].Location as LocationCurve ).Curve              = Line.CreateBound( p1' q1 );              // Add a model line for the rolling offset pipe              Creator creator = new Creator( doc );              Line line = Line.CreateBound( q0' q1 );              creator.CreateModelCurve( line );              pipe = null;          }          else if( _place_fittings )          {            // Set active work plane to the rolling             // offset plane... removed again' since            // this has no effect at all on the             // fitting placement or rotation.            //            //Plane plane = new Plane( z' q0 );            //            //SketchPlane sp = SketchPlane.Create(             //  doc' plane );            //            //uidoc.ActiveView.SketchPlane = sp;            //uidoc.ActiveView.ShowActiveWorkPlane();              FamilySymbol symbol              = new FilteredElementCollector( doc )                .OfClass( typeof( FamilySymbol ) )                .OfCategory( BuiltInCategory.OST_PipeFitting )                .Cast<FamilySymbol>()                .Where<FamilySymbol>( e                  => e.Family.Name.Contains( "Elbow - Generic" ) )                .FirstOrDefault<FamilySymbol>();              // Set up first 45 degree elbow fitting              FamilyInstance fitting0 = doc.Create              .NewFamilyInstance( q0' symbol'                StructuralType.NonStructural );              fitting0.LookupParameter( "Angle" ).Set(              45.0 * Math.PI / 180.0 );              //fitting0.get_Parameter( bipDiameter ) // does not exist            //  .Set( diameter );              fitting0.LookupParameter( "Nominal Radius" )              .Set( 0.5 * diameter );              Line axis = Line.CreateBound( p0' q0 );            angle = z.AngleTo( XYZ.BasisZ );              ElementTransformUtils.RotateElement(              doc' fitting0.Id' axis' Math.PI - angle );              Connector con0 = Util.GetConnectorClosestTo(              fitting0' p0 );              // Trim or extend existing pipe              ( pipes[0].Location as LocationCurve ).Curve              = Line.CreateBound( p0' con0.Origin );              // Connect pipe to fitting              Util.Connect( con0.Origin' pipe' fitting0 );              // Set up second 45 degree elbow fitting              FamilyInstance fitting1 = doc.Create              .NewFamilyInstance( q1' symbol'                StructuralType.NonStructural );              //fitting1.get_Parameter( "Angle" ).Set( 45.0 * Math.PI / 180.0 ); // 2014            //fitting1.get_Parameter( "Nominal Radius" ).Set( 0.5 * diameter ); // 2014              fitting1.LookupParameter( "Angle" ).Set( 45.0 * Math.PI / 180.0 ); // 2015            fitting1.LookupParameter( "Nominal Radius" ).Set( 0.5 * diameter ); // 2015              axis = Line.CreateBound(              q1' q1 + XYZ.BasisZ );              ElementTransformUtils.RotateElement(              doc' fitting1.Id' axis' Math.PI );              axis = Line.CreateBound( q1' p1 );              ElementTransformUtils.RotateElement(              doc' fitting1.Id' axis' Math.PI - angle );              Connector con1 = Util.GetConnectorClosestTo(              fitting1' p1 );              ( pipes[1].Location as LocationCurve ).Curve              = Line.CreateBound( con1.Origin' p1 );              Util.Connect( con1.Origin' fitting1' pipes[1] );              con0 = Util.GetConnectorClosestTo(              fitting0' pm );              con1 = Util.GetConnectorClosestTo(              fitting1' pm );              // Connecting one fitting to the other does            // not insert a pipe in between. If the             // system is edited later' however' the two             // fittings snap together.            //            //con0.ConnectTo( con1 );              // Create rolling offset pipe segment              //pipe = doc.Create.NewPipe( con0.Origin' // 2014            //  con1.Origin' pipe_type_standard );              pipe = Pipe.Create( doc'               pipe_type_standard.Id' levelId' con0' con1 ); // 2015              pipe.get_Parameter( bipDiameter )              .Set( diameter );              // Connect rolling offset pipe segment            // with elbow fittings at each end              Util.Connect( con0.Origin' fitting0' pipe );            Util.Connect( con1.Origin' pipe' fitting1 );          }          else          {            if( _use_static_pipe_create )            {              // Element id arguments to Pipe.Create.                ElementId idSystem;              ElementId idType;              ElementId idLevel;                // All these values are invalid for idSystem:                ElementId idSystem1 = pipe.MEPSystem.Id;              ElementId idSystem2 = ElementId.InvalidElementId;              ElementId idSystem3 = PipingSystem.Create(                doc' pipe.MEPSystem.GetTypeId()' "Tbc" )                  .Id;                // This throws an argument exception saying              // The systemTypeId is not valid piping system type.              // Parameter name: systemTypeId                //pipe = Pipe.Create( doc' idSystem'              //  idType' idLevel' q0' q1 );                // Retrieve pipe system type' e.g.               // hydronic supply.                PipingSystemType pipingSystemType                = new FilteredElementCollector( doc )                  .OfClass( typeof( PipingSystemType ) )                  .OfType<PipingSystemType>()                  .FirstOrDefault( st                    => st.SystemClassification                      == MEPSystemClassification                        .SupplyHydronic );                if( null == pipingSystemType )              {                message = "Could not find hydronic supply piping system type";                return Result.Failed;              }                idSystem = pipingSystemType.Id;                Debug.Assert( pipe.get_Parameter(                BuiltInParameter.RBS_PIPING_SYSTEM_TYPE_PARAM )                  .AsElementId().IntegerValue.Equals(                    idSystem.IntegerValue )'                  "expected same piping system element id" );                // Retrieve the PipeType.                PipeType pipeType =                new FilteredElementCollector( doc )                  .OfClass( typeof( PipeType ) )                  .OfType<PipeType>()                  .FirstOrDefault();                if( null == pipeType )              {                message = "Could not find pipe type";                return Result.Failed;              }                idType = pipeType.Id;                Debug.Assert( pipe.get_Parameter(                BuiltInParameter.ELEM_TYPE_PARAM )                  .AsElementId().IntegerValue.Equals(                    idType.IntegerValue )'                "expected same pipe type element id" );                Debug.Assert( pipe.PipeType.Id.IntegerValue                .Equals( idType.IntegerValue )'                "expected same pipe type element id" );                // Retrieve the reference level.              // pipe.LevelId is not the correct source!                idLevel = pipe.get_Parameter(                BuiltInParameter.RBS_START_LEVEL_PARAM )                  .AsElementId();                // Create the rolling offset pipe.                pipe = Pipe.Create( doc'                idSystem' idType' idLevel' q0' q1 );            }            else            {              //pipe = doc.Create.NewPipe( q0' q1' pipe_type_standard ); // 2014                pipe = Pipe.Create( doc' systemTypeId'                 pipe_type_standard.Id' levelId' q0' q1 ); // 2015            }              pipe.get_Parameter( bipDiameter )              .Set( diameter );              // Connect rolling offset pipe segment            // directly with the neighbouring original            // pipes            //            //Util.Connect( q0' pipes[0]' pipe );            //Util.Connect( q1' pipe' pipes[1] );              // NewElbowFitting performs the following:            // - select appropriate fitting family and type            // - place and orient a family instance            // - set its parameters appropriately            // - connect it with its neighbours              Connector con0 = Util.GetConnectorClosestTo(              pipes[0]' q0 );              Connector con = Util.GetConnectorClosestTo(              pipe' q0 );              doc.Create.NewElbowFitting( con0' con );              Connector con1 = Util.GetConnectorClosestTo(              pipes[1]' q1 );              con = Util.GetConnectorClosestTo(              pipe' q1 );              doc.Create.NewElbowFitting( con' con1 );          }            tx.Commit();        }
Magic Number,BuildingCoder,CmdRollingOffset,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdRollingOffset.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          // Determine pipe diameter for creating           // matching pipes and fittings            Pipe pipe = pipes[0];            double diameter = pipe            .get_Parameter( bipDiameter ) // "Diameter"            .AsDouble();            // Pipe type for calls to doc.Create.NewPipe            PipeType pipe_type_standard            = new FilteredElementCollector( doc )              .OfClass( typeof( PipeType ) )              .Cast<PipeType>()              .Where<PipeType>( e                => e.Name.Equals( "Standard" ) )              .FirstOrDefault<PipeType>();            Debug.Assert(            pipe_type_standard.Id.IntegerValue.Equals(              pipe.PipeType.Id.IntegerValue )'            "expected all pipes in this simple "            + "model to use the same pipe type" );            tx.Start( "Rolling Offset" );            if( _place_model_line )          {            // Trim or extend existing pipes              ( pipes[0].Location as LocationCurve ).Curve              = Line.CreateBound( p0' q0 );              ( pipes[1].Location as LocationCurve ).Curve              = Line.CreateBound( p1' q1 );              // Add a model line for the rolling offset pipe              Creator creator = new Creator( doc );              Line line = Line.CreateBound( q0' q1 );              creator.CreateModelCurve( line );              pipe = null;          }          else if( _place_fittings )          {            // Set active work plane to the rolling             // offset plane... removed again' since            // this has no effect at all on the             // fitting placement or rotation.            //            //Plane plane = new Plane( z' q0 );            //            //SketchPlane sp = SketchPlane.Create(             //  doc' plane );            //            //uidoc.ActiveView.SketchPlane = sp;            //uidoc.ActiveView.ShowActiveWorkPlane();              FamilySymbol symbol              = new FilteredElementCollector( doc )                .OfClass( typeof( FamilySymbol ) )                .OfCategory( BuiltInCategory.OST_PipeFitting )                .Cast<FamilySymbol>()                .Where<FamilySymbol>( e                  => e.Family.Name.Contains( "Elbow - Generic" ) )                .FirstOrDefault<FamilySymbol>();              // Set up first 45 degree elbow fitting              FamilyInstance fitting0 = doc.Create              .NewFamilyInstance( q0' symbol'                StructuralType.NonStructural );              fitting0.LookupParameter( "Angle" ).Set(              45.0 * Math.PI / 180.0 );              //fitting0.get_Parameter( bipDiameter ) // does not exist            //  .Set( diameter );              fitting0.LookupParameter( "Nominal Radius" )              .Set( 0.5 * diameter );              Line axis = Line.CreateBound( p0' q0 );            angle = z.AngleTo( XYZ.BasisZ );              ElementTransformUtils.RotateElement(              doc' fitting0.Id' axis' Math.PI - angle );              Connector con0 = Util.GetConnectorClosestTo(              fitting0' p0 );              // Trim or extend existing pipe              ( pipes[0].Location as LocationCurve ).Curve              = Line.CreateBound( p0' con0.Origin );              // Connect pipe to fitting              Util.Connect( con0.Origin' pipe' fitting0 );              // Set up second 45 degree elbow fitting              FamilyInstance fitting1 = doc.Create              .NewFamilyInstance( q1' symbol'                StructuralType.NonStructural );              //fitting1.get_Parameter( "Angle" ).Set( 45.0 * Math.PI / 180.0 ); // 2014            //fitting1.get_Parameter( "Nominal Radius" ).Set( 0.5 * diameter ); // 2014              fitting1.LookupParameter( "Angle" ).Set( 45.0 * Math.PI / 180.0 ); // 2015            fitting1.LookupParameter( "Nominal Radius" ).Set( 0.5 * diameter ); // 2015              axis = Line.CreateBound(              q1' q1 + XYZ.BasisZ );              ElementTransformUtils.RotateElement(              doc' fitting1.Id' axis' Math.PI );              axis = Line.CreateBound( q1' p1 );              ElementTransformUtils.RotateElement(              doc' fitting1.Id' axis' Math.PI - angle );              Connector con1 = Util.GetConnectorClosestTo(              fitting1' p1 );              ( pipes[1].Location as LocationCurve ).Curve              = Line.CreateBound( con1.Origin' p1 );              Util.Connect( con1.Origin' fitting1' pipes[1] );              con0 = Util.GetConnectorClosestTo(              fitting0' pm );              con1 = Util.GetConnectorClosestTo(              fitting1' pm );              // Connecting one fitting to the other does            // not insert a pipe in between. If the             // system is edited later' however' the two             // fittings snap together.            //            //con0.ConnectTo( con1 );              // Create rolling offset pipe segment              //pipe = doc.Create.NewPipe( con0.Origin' // 2014            //  con1.Origin' pipe_type_standard );              pipe = Pipe.Create( doc'               pipe_type_standard.Id' levelId' con0' con1 ); // 2015              pipe.get_Parameter( bipDiameter )              .Set( diameter );              // Connect rolling offset pipe segment            // with elbow fittings at each end              Util.Connect( con0.Origin' fitting0' pipe );            Util.Connect( con1.Origin' pipe' fitting1 );          }          else          {            if( _use_static_pipe_create )            {              // Element id arguments to Pipe.Create.                ElementId idSystem;              ElementId idType;              ElementId idLevel;                // All these values are invalid for idSystem:                ElementId idSystem1 = pipe.MEPSystem.Id;              ElementId idSystem2 = ElementId.InvalidElementId;              ElementId idSystem3 = PipingSystem.Create(                doc' pipe.MEPSystem.GetTypeId()' "Tbc" )                  .Id;                // This throws an argument exception saying              // The systemTypeId is not valid piping system type.              // Parameter name: systemTypeId                //pipe = Pipe.Create( doc' idSystem'              //  idType' idLevel' q0' q1 );                // Retrieve pipe system type' e.g.               // hydronic supply.                PipingSystemType pipingSystemType                = new FilteredElementCollector( doc )                  .OfClass( typeof( PipingSystemType ) )                  .OfType<PipingSystemType>()                  .FirstOrDefault( st                    => st.SystemClassification                      == MEPSystemClassification                        .SupplyHydronic );                if( null == pipingSystemType )              {                message = "Could not find hydronic supply piping system type";                return Result.Failed;              }                idSystem = pipingSystemType.Id;                Debug.Assert( pipe.get_Parameter(                BuiltInParameter.RBS_PIPING_SYSTEM_TYPE_PARAM )                  .AsElementId().IntegerValue.Equals(                    idSystem.IntegerValue )'                  "expected same piping system element id" );                // Retrieve the PipeType.                PipeType pipeType =                new FilteredElementCollector( doc )                  .OfClass( typeof( PipeType ) )                  .OfType<PipeType>()                  .FirstOrDefault();                if( null == pipeType )              {                message = "Could not find pipe type";                return Result.Failed;              }                idType = pipeType.Id;                Debug.Assert( pipe.get_Parameter(                BuiltInParameter.ELEM_TYPE_PARAM )                  .AsElementId().IntegerValue.Equals(                    idType.IntegerValue )'                "expected same pipe type element id" );                Debug.Assert( pipe.PipeType.Id.IntegerValue                .Equals( idType.IntegerValue )'                "expected same pipe type element id" );                // Retrieve the reference level.              // pipe.LevelId is not the correct source!                idLevel = pipe.get_Parameter(                BuiltInParameter.RBS_START_LEVEL_PARAM )                  .AsElementId();                // Create the rolling offset pipe.                pipe = Pipe.Create( doc'                idSystem' idType' idLevel' q0' q1 );            }            else            {              //pipe = doc.Create.NewPipe( q0' q1' pipe_type_standard ); // 2014                pipe = Pipe.Create( doc' systemTypeId'                 pipe_type_standard.Id' levelId' q0' q1 ); // 2015            }              pipe.get_Parameter( bipDiameter )              .Set( diameter );              // Connect rolling offset pipe segment            // directly with the neighbouring original            // pipes            //            //Util.Connect( q0' pipes[0]' pipe );            //Util.Connect( q1' pipe' pipes[1] );              // NewElbowFitting performs the following:            // - select appropriate fitting family and type            // - place and orient a family instance            // - set its parameters appropriately            // - connect it with its neighbours              Connector con0 = Util.GetConnectorClosestTo(              pipes[0]' q0 );              Connector con = Util.GetConnectorClosestTo(              pipe' q0 );              doc.Create.NewElbowFitting( con0' con );              Connector con1 = Util.GetConnectorClosestTo(              pipes[1]' q1 );              con = Util.GetConnectorClosestTo(              pipe' q1 );              doc.Create.NewElbowFitting( con' con1 );          }            tx.Commit();        }
Magic Number,BuildingCoder,CmdRollingOffset,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdRollingOffset.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          // Determine pipe diameter for creating           // matching pipes and fittings            Pipe pipe = pipes[0];            double diameter = pipe            .get_Parameter( bipDiameter ) // "Diameter"            .AsDouble();            // Pipe type for calls to doc.Create.NewPipe            PipeType pipe_type_standard            = new FilteredElementCollector( doc )              .OfClass( typeof( PipeType ) )              .Cast<PipeType>()              .Where<PipeType>( e                => e.Name.Equals( "Standard" ) )              .FirstOrDefault<PipeType>();            Debug.Assert(            pipe_type_standard.Id.IntegerValue.Equals(              pipe.PipeType.Id.IntegerValue )'            "expected all pipes in this simple "            + "model to use the same pipe type" );            tx.Start( "Rolling Offset" );            if( _place_model_line )          {            // Trim or extend existing pipes              ( pipes[0].Location as LocationCurve ).Curve              = Line.CreateBound( p0' q0 );              ( pipes[1].Location as LocationCurve ).Curve              = Line.CreateBound( p1' q1 );              // Add a model line for the rolling offset pipe              Creator creator = new Creator( doc );              Line line = Line.CreateBound( q0' q1 );              creator.CreateModelCurve( line );              pipe = null;          }          else if( _place_fittings )          {            // Set active work plane to the rolling             // offset plane... removed again' since            // this has no effect at all on the             // fitting placement or rotation.            //            //Plane plane = new Plane( z' q0 );            //            //SketchPlane sp = SketchPlane.Create(             //  doc' plane );            //            //uidoc.ActiveView.SketchPlane = sp;            //uidoc.ActiveView.ShowActiveWorkPlane();              FamilySymbol symbol              = new FilteredElementCollector( doc )                .OfClass( typeof( FamilySymbol ) )                .OfCategory( BuiltInCategory.OST_PipeFitting )                .Cast<FamilySymbol>()                .Where<FamilySymbol>( e                  => e.Family.Name.Contains( "Elbow - Generic" ) )                .FirstOrDefault<FamilySymbol>();              // Set up first 45 degree elbow fitting              FamilyInstance fitting0 = doc.Create              .NewFamilyInstance( q0' symbol'                StructuralType.NonStructural );              fitting0.LookupParameter( "Angle" ).Set(              45.0 * Math.PI / 180.0 );              //fitting0.get_Parameter( bipDiameter ) // does not exist            //  .Set( diameter );              fitting0.LookupParameter( "Nominal Radius" )              .Set( 0.5 * diameter );              Line axis = Line.CreateBound( p0' q0 );            angle = z.AngleTo( XYZ.BasisZ );              ElementTransformUtils.RotateElement(              doc' fitting0.Id' axis' Math.PI - angle );              Connector con0 = Util.GetConnectorClosestTo(              fitting0' p0 );              // Trim or extend existing pipe              ( pipes[0].Location as LocationCurve ).Curve              = Line.CreateBound( p0' con0.Origin );              // Connect pipe to fitting              Util.Connect( con0.Origin' pipe' fitting0 );              // Set up second 45 degree elbow fitting              FamilyInstance fitting1 = doc.Create              .NewFamilyInstance( q1' symbol'                StructuralType.NonStructural );              //fitting1.get_Parameter( "Angle" ).Set( 45.0 * Math.PI / 180.0 ); // 2014            //fitting1.get_Parameter( "Nominal Radius" ).Set( 0.5 * diameter ); // 2014              fitting1.LookupParameter( "Angle" ).Set( 45.0 * Math.PI / 180.0 ); // 2015            fitting1.LookupParameter( "Nominal Radius" ).Set( 0.5 * diameter ); // 2015              axis = Line.CreateBound(              q1' q1 + XYZ.BasisZ );              ElementTransformUtils.RotateElement(              doc' fitting1.Id' axis' Math.PI );              axis = Line.CreateBound( q1' p1 );              ElementTransformUtils.RotateElement(              doc' fitting1.Id' axis' Math.PI - angle );              Connector con1 = Util.GetConnectorClosestTo(              fitting1' p1 );              ( pipes[1].Location as LocationCurve ).Curve              = Line.CreateBound( con1.Origin' p1 );              Util.Connect( con1.Origin' fitting1' pipes[1] );              con0 = Util.GetConnectorClosestTo(              fitting0' pm );              con1 = Util.GetConnectorClosestTo(              fitting1' pm );              // Connecting one fitting to the other does            // not insert a pipe in between. If the             // system is edited later' however' the two             // fittings snap together.            //            //con0.ConnectTo( con1 );              // Create rolling offset pipe segment              //pipe = doc.Create.NewPipe( con0.Origin' // 2014            //  con1.Origin' pipe_type_standard );              pipe = Pipe.Create( doc'               pipe_type_standard.Id' levelId' con0' con1 ); // 2015              pipe.get_Parameter( bipDiameter )              .Set( diameter );              // Connect rolling offset pipe segment            // with elbow fittings at each end              Util.Connect( con0.Origin' fitting0' pipe );            Util.Connect( con1.Origin' pipe' fitting1 );          }          else          {            if( _use_static_pipe_create )            {              // Element id arguments to Pipe.Create.                ElementId idSystem;              ElementId idType;              ElementId idLevel;                // All these values are invalid for idSystem:                ElementId idSystem1 = pipe.MEPSystem.Id;              ElementId idSystem2 = ElementId.InvalidElementId;              ElementId idSystem3 = PipingSystem.Create(                doc' pipe.MEPSystem.GetTypeId()' "Tbc" )                  .Id;                // This throws an argument exception saying              // The systemTypeId is not valid piping system type.              // Parameter name: systemTypeId                //pipe = Pipe.Create( doc' idSystem'              //  idType' idLevel' q0' q1 );                // Retrieve pipe system type' e.g.               // hydronic supply.                PipingSystemType pipingSystemType                = new FilteredElementCollector( doc )                  .OfClass( typeof( PipingSystemType ) )                  .OfType<PipingSystemType>()                  .FirstOrDefault( st                    => st.SystemClassification                      == MEPSystemClassification                        .SupplyHydronic );                if( null == pipingSystemType )              {                message = "Could not find hydronic supply piping system type";                return Result.Failed;              }                idSystem = pipingSystemType.Id;                Debug.Assert( pipe.get_Parameter(                BuiltInParameter.RBS_PIPING_SYSTEM_TYPE_PARAM )                  .AsElementId().IntegerValue.Equals(                    idSystem.IntegerValue )'                  "expected same piping system element id" );                // Retrieve the PipeType.                PipeType pipeType =                new FilteredElementCollector( doc )                  .OfClass( typeof( PipeType ) )                  .OfType<PipeType>()                  .FirstOrDefault();                if( null == pipeType )              {                message = "Could not find pipe type";                return Result.Failed;              }                idType = pipeType.Id;                Debug.Assert( pipe.get_Parameter(                BuiltInParameter.ELEM_TYPE_PARAM )                  .AsElementId().IntegerValue.Equals(                    idType.IntegerValue )'                "expected same pipe type element id" );                Debug.Assert( pipe.PipeType.Id.IntegerValue                .Equals( idType.IntegerValue )'                "expected same pipe type element id" );                // Retrieve the reference level.              // pipe.LevelId is not the correct source!                idLevel = pipe.get_Parameter(                BuiltInParameter.RBS_START_LEVEL_PARAM )                  .AsElementId();                // Create the rolling offset pipe.                pipe = Pipe.Create( doc'                idSystem' idType' idLevel' q0' q1 );            }            else            {              //pipe = doc.Create.NewPipe( q0' q1' pipe_type_standard ); // 2014                pipe = Pipe.Create( doc' systemTypeId'                 pipe_type_standard.Id' levelId' q0' q1 ); // 2015            }              pipe.get_Parameter( bipDiameter )              .Set( diameter );              // Connect rolling offset pipe segment            // directly with the neighbouring original            // pipes            //            //Util.Connect( q0' pipes[0]' pipe );            //Util.Connect( q1' pipe' pipes[1] );              // NewElbowFitting performs the following:            // - select appropriate fitting family and type            // - place and orient a family instance            // - set its parameters appropriately            // - connect it with its neighbours              Connector con0 = Util.GetConnectorClosestTo(              pipes[0]' q0 );              Connector con = Util.GetConnectorClosestTo(              pipe' q0 );              doc.Create.NewElbowFitting( con0' con );              Connector con1 = Util.GetConnectorClosestTo(              pipes[1]' q1 );              con = Util.GetConnectorClosestTo(              pipe' q1 );              doc.Create.NewElbowFitting( con' con1 );          }            tx.Commit();        }
Magic Number,BuildingCoder,CmdRollingOffset,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdRollingOffset.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          // Determine pipe diameter for creating           // matching pipes and fittings            Pipe pipe = pipes[0];            double diameter = pipe            .get_Parameter( bipDiameter ) // "Diameter"            .AsDouble();            // Pipe type for calls to doc.Create.NewPipe            PipeType pipe_type_standard            = new FilteredElementCollector( doc )              .OfClass( typeof( PipeType ) )              .Cast<PipeType>()              .Where<PipeType>( e                => e.Name.Equals( "Standard" ) )              .FirstOrDefault<PipeType>();            Debug.Assert(            pipe_type_standard.Id.IntegerValue.Equals(              pipe.PipeType.Id.IntegerValue )'            "expected all pipes in this simple "            + "model to use the same pipe type" );            tx.Start( "Rolling Offset" );            if( _place_model_line )          {            // Trim or extend existing pipes              ( pipes[0].Location as LocationCurve ).Curve              = Line.CreateBound( p0' q0 );              ( pipes[1].Location as LocationCurve ).Curve              = Line.CreateBound( p1' q1 );              // Add a model line for the rolling offset pipe              Creator creator = new Creator( doc );              Line line = Line.CreateBound( q0' q1 );              creator.CreateModelCurve( line );              pipe = null;          }          else if( _place_fittings )          {            // Set active work plane to the rolling             // offset plane... removed again' since            // this has no effect at all on the             // fitting placement or rotation.            //            //Plane plane = new Plane( z' q0 );            //            //SketchPlane sp = SketchPlane.Create(             //  doc' plane );            //            //uidoc.ActiveView.SketchPlane = sp;            //uidoc.ActiveView.ShowActiveWorkPlane();              FamilySymbol symbol              = new FilteredElementCollector( doc )                .OfClass( typeof( FamilySymbol ) )                .OfCategory( BuiltInCategory.OST_PipeFitting )                .Cast<FamilySymbol>()                .Where<FamilySymbol>( e                  => e.Family.Name.Contains( "Elbow - Generic" ) )                .FirstOrDefault<FamilySymbol>();              // Set up first 45 degree elbow fitting              FamilyInstance fitting0 = doc.Create              .NewFamilyInstance( q0' symbol'                StructuralType.NonStructural );              fitting0.LookupParameter( "Angle" ).Set(              45.0 * Math.PI / 180.0 );              //fitting0.get_Parameter( bipDiameter ) // does not exist            //  .Set( diameter );              fitting0.LookupParameter( "Nominal Radius" )              .Set( 0.5 * diameter );              Line axis = Line.CreateBound( p0' q0 );            angle = z.AngleTo( XYZ.BasisZ );              ElementTransformUtils.RotateElement(              doc' fitting0.Id' axis' Math.PI - angle );              Connector con0 = Util.GetConnectorClosestTo(              fitting0' p0 );              // Trim or extend existing pipe              ( pipes[0].Location as LocationCurve ).Curve              = Line.CreateBound( p0' con0.Origin );              // Connect pipe to fitting              Util.Connect( con0.Origin' pipe' fitting0 );              // Set up second 45 degree elbow fitting              FamilyInstance fitting1 = doc.Create              .NewFamilyInstance( q1' symbol'                StructuralType.NonStructural );              //fitting1.get_Parameter( "Angle" ).Set( 45.0 * Math.PI / 180.0 ); // 2014            //fitting1.get_Parameter( "Nominal Radius" ).Set( 0.5 * diameter ); // 2014              fitting1.LookupParameter( "Angle" ).Set( 45.0 * Math.PI / 180.0 ); // 2015            fitting1.LookupParameter( "Nominal Radius" ).Set( 0.5 * diameter ); // 2015              axis = Line.CreateBound(              q1' q1 + XYZ.BasisZ );              ElementTransformUtils.RotateElement(              doc' fitting1.Id' axis' Math.PI );              axis = Line.CreateBound( q1' p1 );              ElementTransformUtils.RotateElement(              doc' fitting1.Id' axis' Math.PI - angle );              Connector con1 = Util.GetConnectorClosestTo(              fitting1' p1 );              ( pipes[1].Location as LocationCurve ).Curve              = Line.CreateBound( con1.Origin' p1 );              Util.Connect( con1.Origin' fitting1' pipes[1] );              con0 = Util.GetConnectorClosestTo(              fitting0' pm );              con1 = Util.GetConnectorClosestTo(              fitting1' pm );              // Connecting one fitting to the other does            // not insert a pipe in between. If the             // system is edited later' however' the two             // fittings snap together.            //            //con0.ConnectTo( con1 );              // Create rolling offset pipe segment              //pipe = doc.Create.NewPipe( con0.Origin' // 2014            //  con1.Origin' pipe_type_standard );              pipe = Pipe.Create( doc'               pipe_type_standard.Id' levelId' con0' con1 ); // 2015              pipe.get_Parameter( bipDiameter )              .Set( diameter );              // Connect rolling offset pipe segment            // with elbow fittings at each end              Util.Connect( con0.Origin' fitting0' pipe );            Util.Connect( con1.Origin' pipe' fitting1 );          }          else          {            if( _use_static_pipe_create )            {              // Element id arguments to Pipe.Create.                ElementId idSystem;              ElementId idType;              ElementId idLevel;                // All these values are invalid for idSystem:                ElementId idSystem1 = pipe.MEPSystem.Id;              ElementId idSystem2 = ElementId.InvalidElementId;              ElementId idSystem3 = PipingSystem.Create(                doc' pipe.MEPSystem.GetTypeId()' "Tbc" )                  .Id;                // This throws an argument exception saying              // The systemTypeId is not valid piping system type.              // Parameter name: systemTypeId                //pipe = Pipe.Create( doc' idSystem'              //  idType' idLevel' q0' q1 );                // Retrieve pipe system type' e.g.               // hydronic supply.                PipingSystemType pipingSystemType                = new FilteredElementCollector( doc )                  .OfClass( typeof( PipingSystemType ) )                  .OfType<PipingSystemType>()                  .FirstOrDefault( st                    => st.SystemClassification                      == MEPSystemClassification                        .SupplyHydronic );                if( null == pipingSystemType )              {                message = "Could not find hydronic supply piping system type";                return Result.Failed;              }                idSystem = pipingSystemType.Id;                Debug.Assert( pipe.get_Parameter(                BuiltInParameter.RBS_PIPING_SYSTEM_TYPE_PARAM )                  .AsElementId().IntegerValue.Equals(                    idSystem.IntegerValue )'                  "expected same piping system element id" );                // Retrieve the PipeType.                PipeType pipeType =                new FilteredElementCollector( doc )                  .OfClass( typeof( PipeType ) )                  .OfType<PipeType>()                  .FirstOrDefault();                if( null == pipeType )              {                message = "Could not find pipe type";                return Result.Failed;              }                idType = pipeType.Id;                Debug.Assert( pipe.get_Parameter(                BuiltInParameter.ELEM_TYPE_PARAM )                  .AsElementId().IntegerValue.Equals(                    idType.IntegerValue )'                "expected same pipe type element id" );                Debug.Assert( pipe.PipeType.Id.IntegerValue                .Equals( idType.IntegerValue )'                "expected same pipe type element id" );                // Retrieve the reference level.              // pipe.LevelId is not the correct source!                idLevel = pipe.get_Parameter(                BuiltInParameter.RBS_START_LEVEL_PARAM )                  .AsElementId();                // Create the rolling offset pipe.                pipe = Pipe.Create( doc'                idSystem' idType' idLevel' q0' q1 );            }            else            {              //pipe = doc.Create.NewPipe( q0' q1' pipe_type_standard ); // 2014                pipe = Pipe.Create( doc' systemTypeId'                 pipe_type_standard.Id' levelId' q0' q1 ); // 2015            }              pipe.get_Parameter( bipDiameter )              .Set( diameter );              // Connect rolling offset pipe segment            // directly with the neighbouring original            // pipes            //            //Util.Connect( q0' pipes[0]' pipe );            //Util.Connect( q1' pipe' pipes[1] );              // NewElbowFitting performs the following:            // - select appropriate fitting family and type            // - place and orient a family instance            // - set its parameters appropriately            // - connect it with its neighbours              Connector con0 = Util.GetConnectorClosestTo(              pipes[0]' q0 );              Connector con = Util.GetConnectorClosestTo(              pipe' q0 );              doc.Create.NewElbowFitting( con0' con );              Connector con1 = Util.GetConnectorClosestTo(              pipes[1]' q1 );              con = Util.GetConnectorClosestTo(              pipe' q1 );              doc.Create.NewElbowFitting( con' con1 );          }            tx.Commit();        }
Magic Number,BuildingCoder,CmdRollingOffset,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdRollingOffset.cs,f,The following statement contains a magic number: var endPoint = new XYZ( 100' 0' 0 );
Magic Number,BuildingCoder,CmdRoomNeighbours,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdRoomNeighbours.cs,GetRoomNeighbourAt,The following statement contains a magic number: Transform derivatives = bs.GetCurve()          .ComputeDerivatives(  0.5' true );
Magic Number,BuildingCoder,CmdRoomNeighbours,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdRoomNeighbours.cs,GetRoomNeighbourAt,The following statement contains a magic number: Debug.Assert(           midPoint.IsAlmostEqualTo(            bs.GetCurve().Evaluate( 0.5' true ) )'          "expected same result from Evaluate and derivatives" );
Magic Number,BuildingCoder,NestedFamilyFunctions,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNestedFamilies.cs,GetFamilyParameter,The following statement contains a magic number: Debug.Assert( 2 > nestedFamilyInstance.GetParameters( parameterName ).Count'          "ascertain that there are not more than one parameter of the given name" );
Magic Number,BuildingCoder,NestedFamilyFunctions,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNestedFamilies.cs,GetFamilyParameter,The following statement contains a magic number: if( oResult == null )        {          //oResult = nestedFamilyInstance.Symbol.get_Parameter( parameterName ); // 2014            Debug.Assert( 2 > nestedFamilyInstance.Symbol.GetParameters( parameterName ).Count'            "ascertain that there are not more than one parameter of the given name" );            oResult = nestedFamilyInstance.Symbol.LookupParameter( parameterName ); // 2015        }
Magic Number,BuildingCoder,CmdNestedInstanceGeo,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNestedInstanceGeo.cs,GetVertices,The following statement contains a magic number: Debug.Assert( 8 == keys.Count'          "expected eight vertices for a rectangular column" );
Magic Number,BuildingCoder,CmdNestedInstanceGeo,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNestedInstanceGeo.cs,GetVertices,The following statement contains a magic number: foreach( XYZ p in keys )        {          Debug.Assert( 3 == a[p]'            "expected every vertex of solid to appear in exactly three faces" );            vertices.Add( p );        }
Magic Number,BuildingCoder,CmdNewBeamTypeInstance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewBeamTypeInstance.cs,Execute,The following statement contains a magic number: using ( Transaction t = new Transaction( doc ) )        {          t.Start( "Create Beam Type and Instance" );          // If the family was not already loaded' then do so:            if ( null == f )          {            if ( !doc.LoadFamily( _path' out f ) )            {              message = "Unable to load '" + _path + "'.";            }          }            if ( null != f )          {            Debug.Print( "Family name={0}"' f.Name );              // Pick a symbol for duplication' any one will do'            // we select the first:              FamilySymbol s = null;              //foreach( FamilySymbol s2 in f.Symbols ) // 2014              foreach ( ElementId id in f.GetFamilySymbolIds() ) // 2015            {              s = doc.GetElement( id ) as FamilySymbol;              break;            }              Debug.Assert( null != s' "expected at least one symbol to be defined in family" );              // Duplicate the existing symbol:              ElementType s1 = s.Duplicate( "Nuovo simbolo" );            s = s1 as FamilySymbol;              // Analyse the symbol parameters:              foreach ( Parameter param in s.Parameters )            {              Debug.Print( "Parameter name={0}' value={1}"' param.Definition.Name' param.AsValueString() );            }              // Define new dimensions for our new type;            // the specified parameter name is case sensitive:              //s.get_Parameter( "b" ).Set( Util.MmToFoot( 500 ) ); // 2014            //s.get_Parameter( "h" ).Set( Util.MmToFoot( 1000 ) ); // 2014              s.LookupParameter( "b" ).Set( Util.MmToFoot( 500 ) ); // 2015            s.LookupParameter( "h" ).Set( Util.MmToFoot( 1000 ) ); // 2015              // we can change the symbol name at any time:              s.Name = "Nuovo simbolo due";              // insert an instance of our new symbol:              Autodesk.Revit.Creation.Application creApp = app.Application.Create;            Autodesk.Revit.Creation.Document creDoc = doc.Create;              // It is possible to insert a beam'            // which normally uses a location line'            // by specifying only a location point:              //XYZ p = XYZ.Zero;            //doc.Create.NewFamilyInstance( p' s' nonStructural );              XYZ p = XYZ.Zero;            XYZ q = creApp.NewXYZ( 30' 20' 20 ); // feet            Line line = Line.CreateBound( p' q );              // Specifying a non-structural type here means no beam            // is created' and results in a null family instance:              FamilyInstance fi = creDoc.NewFamilyInstance(              line' s' null' stBeam );              // This creates a visible family instance'            // but the resulting beam has no location line            // and behaves strangely' e.g. cannot be selected:            //FamilyInstance fi = doc.Create.NewFamilyInstance(            //  p' s' q' null' nonStructural );              //List<Element> levels = new List<Element>();            //doc.get_Elements( typeof( Level )' levels );            //Debug.Assert( 0 < levels.Count'            //  "expected at least one level in model" );            //Level level = levels[0] as Level;            //fi = doc.Create.NewFamilyInstance(            //  line' s' level' nonStructural );              rc = Result.Succeeded;          }          t.Commit();        }
Magic Number,BuildingCoder,CmdNewBeamTypeInstance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewBeamTypeInstance.cs,Execute,The following statement contains a magic number: using ( Transaction t = new Transaction( doc ) )        {          t.Start( "Create Beam Type and Instance" );          // If the family was not already loaded' then do so:            if ( null == f )          {            if ( !doc.LoadFamily( _path' out f ) )            {              message = "Unable to load '" + _path + "'.";            }          }            if ( null != f )          {            Debug.Print( "Family name={0}"' f.Name );              // Pick a symbol for duplication' any one will do'            // we select the first:              FamilySymbol s = null;              //foreach( FamilySymbol s2 in f.Symbols ) // 2014              foreach ( ElementId id in f.GetFamilySymbolIds() ) // 2015            {              s = doc.GetElement( id ) as FamilySymbol;              break;            }              Debug.Assert( null != s' "expected at least one symbol to be defined in family" );              // Duplicate the existing symbol:              ElementType s1 = s.Duplicate( "Nuovo simbolo" );            s = s1 as FamilySymbol;              // Analyse the symbol parameters:              foreach ( Parameter param in s.Parameters )            {              Debug.Print( "Parameter name={0}' value={1}"' param.Definition.Name' param.AsValueString() );            }              // Define new dimensions for our new type;            // the specified parameter name is case sensitive:              //s.get_Parameter( "b" ).Set( Util.MmToFoot( 500 ) ); // 2014            //s.get_Parameter( "h" ).Set( Util.MmToFoot( 1000 ) ); // 2014              s.LookupParameter( "b" ).Set( Util.MmToFoot( 500 ) ); // 2015            s.LookupParameter( "h" ).Set( Util.MmToFoot( 1000 ) ); // 2015              // we can change the symbol name at any time:              s.Name = "Nuovo simbolo due";              // insert an instance of our new symbol:              Autodesk.Revit.Creation.Application creApp = app.Application.Create;            Autodesk.Revit.Creation.Document creDoc = doc.Create;              // It is possible to insert a beam'            // which normally uses a location line'            // by specifying only a location point:              //XYZ p = XYZ.Zero;            //doc.Create.NewFamilyInstance( p' s' nonStructural );              XYZ p = XYZ.Zero;            XYZ q = creApp.NewXYZ( 30' 20' 20 ); // feet            Line line = Line.CreateBound( p' q );              // Specifying a non-structural type here means no beam            // is created' and results in a null family instance:              FamilyInstance fi = creDoc.NewFamilyInstance(              line' s' null' stBeam );              // This creates a visible family instance'            // but the resulting beam has no location line            // and behaves strangely' e.g. cannot be selected:            //FamilyInstance fi = doc.Create.NewFamilyInstance(            //  p' s' q' null' nonStructural );              //List<Element> levels = new List<Element>();            //doc.get_Elements( typeof( Level )' levels );            //Debug.Assert( 0 < levels.Count'            //  "expected at least one level in model" );            //Level level = levels[0] as Level;            //fi = doc.Create.NewFamilyInstance(            //  line' s' level' nonStructural );              rc = Result.Succeeded;          }          t.Commit();        }
Magic Number,BuildingCoder,CmdNewBeamTypeInstance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewBeamTypeInstance.cs,Execute,The following statement contains a magic number: using ( Transaction t = new Transaction( doc ) )        {          t.Start( "Create Beam Type and Instance" );          // If the family was not already loaded' then do so:            if ( null == f )          {            if ( !doc.LoadFamily( _path' out f ) )            {              message = "Unable to load '" + _path + "'.";            }          }            if ( null != f )          {            Debug.Print( "Family name={0}"' f.Name );              // Pick a symbol for duplication' any one will do'            // we select the first:              FamilySymbol s = null;              //foreach( FamilySymbol s2 in f.Symbols ) // 2014              foreach ( ElementId id in f.GetFamilySymbolIds() ) // 2015            {              s = doc.GetElement( id ) as FamilySymbol;              break;            }              Debug.Assert( null != s' "expected at least one symbol to be defined in family" );              // Duplicate the existing symbol:              ElementType s1 = s.Duplicate( "Nuovo simbolo" );            s = s1 as FamilySymbol;              // Analyse the symbol parameters:              foreach ( Parameter param in s.Parameters )            {              Debug.Print( "Parameter name={0}' value={1}"' param.Definition.Name' param.AsValueString() );            }              // Define new dimensions for our new type;            // the specified parameter name is case sensitive:              //s.get_Parameter( "b" ).Set( Util.MmToFoot( 500 ) ); // 2014            //s.get_Parameter( "h" ).Set( Util.MmToFoot( 1000 ) ); // 2014              s.LookupParameter( "b" ).Set( Util.MmToFoot( 500 ) ); // 2015            s.LookupParameter( "h" ).Set( Util.MmToFoot( 1000 ) ); // 2015              // we can change the symbol name at any time:              s.Name = "Nuovo simbolo due";              // insert an instance of our new symbol:              Autodesk.Revit.Creation.Application creApp = app.Application.Create;            Autodesk.Revit.Creation.Document creDoc = doc.Create;              // It is possible to insert a beam'            // which normally uses a location line'            // by specifying only a location point:              //XYZ p = XYZ.Zero;            //doc.Create.NewFamilyInstance( p' s' nonStructural );              XYZ p = XYZ.Zero;            XYZ q = creApp.NewXYZ( 30' 20' 20 ); // feet            Line line = Line.CreateBound( p' q );              // Specifying a non-structural type here means no beam            // is created' and results in a null family instance:              FamilyInstance fi = creDoc.NewFamilyInstance(              line' s' null' stBeam );              // This creates a visible family instance'            // but the resulting beam has no location line            // and behaves strangely' e.g. cannot be selected:            //FamilyInstance fi = doc.Create.NewFamilyInstance(            //  p' s' q' null' nonStructural );              //List<Element> levels = new List<Element>();            //doc.get_Elements( typeof( Level )' levels );            //Debug.Assert( 0 < levels.Count'            //  "expected at least one level in model" );            //Level level = levels[0] as Level;            //fi = doc.Create.NewFamilyInstance(            //  line' s' level' nonStructural );              rc = Result.Succeeded;          }          t.Commit();        }
Magic Number,BuildingCoder,CmdNewBeamTypeInstance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewBeamTypeInstance.cs,Execute,The following statement contains a magic number: using ( Transaction t = new Transaction( doc ) )        {          t.Start( "Create Beam Type and Instance" );          // If the family was not already loaded' then do so:            if ( null == f )          {            if ( !doc.LoadFamily( _path' out f ) )            {              message = "Unable to load '" + _path + "'.";            }          }            if ( null != f )          {            Debug.Print( "Family name={0}"' f.Name );              // Pick a symbol for duplication' any one will do'            // we select the first:              FamilySymbol s = null;              //foreach( FamilySymbol s2 in f.Symbols ) // 2014              foreach ( ElementId id in f.GetFamilySymbolIds() ) // 2015            {              s = doc.GetElement( id ) as FamilySymbol;              break;            }              Debug.Assert( null != s' "expected at least one symbol to be defined in family" );              // Duplicate the existing symbol:              ElementType s1 = s.Duplicate( "Nuovo simbolo" );            s = s1 as FamilySymbol;              // Analyse the symbol parameters:              foreach ( Parameter param in s.Parameters )            {              Debug.Print( "Parameter name={0}' value={1}"' param.Definition.Name' param.AsValueString() );            }              // Define new dimensions for our new type;            // the specified parameter name is case sensitive:              //s.get_Parameter( "b" ).Set( Util.MmToFoot( 500 ) ); // 2014            //s.get_Parameter( "h" ).Set( Util.MmToFoot( 1000 ) ); // 2014              s.LookupParameter( "b" ).Set( Util.MmToFoot( 500 ) ); // 2015            s.LookupParameter( "h" ).Set( Util.MmToFoot( 1000 ) ); // 2015              // we can change the symbol name at any time:              s.Name = "Nuovo simbolo due";              // insert an instance of our new symbol:              Autodesk.Revit.Creation.Application creApp = app.Application.Create;            Autodesk.Revit.Creation.Document creDoc = doc.Create;              // It is possible to insert a beam'            // which normally uses a location line'            // by specifying only a location point:              //XYZ p = XYZ.Zero;            //doc.Create.NewFamilyInstance( p' s' nonStructural );              XYZ p = XYZ.Zero;            XYZ q = creApp.NewXYZ( 30' 20' 20 ); // feet            Line line = Line.CreateBound( p' q );              // Specifying a non-structural type here means no beam            // is created' and results in a null family instance:              FamilyInstance fi = creDoc.NewFamilyInstance(              line' s' null' stBeam );              // This creates a visible family instance'            // but the resulting beam has no location line            // and behaves strangely' e.g. cannot be selected:            //FamilyInstance fi = doc.Create.NewFamilyInstance(            //  p' s' q' null' nonStructural );              //List<Element> levels = new List<Element>();            //doc.get_Elements( typeof( Level )' levels );            //Debug.Assert( 0 < levels.Count'            //  "expected at least one level in model" );            //Level level = levels[0] as Level;            //fi = doc.Create.NewFamilyInstance(            //  line' s' level' nonStructural );              rc = Result.Succeeded;          }          t.Commit();        }
Magic Number,BuildingCoder,CmdNewBeamTypeInstance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewBeamTypeInstance.cs,Execute,The following statement contains a magic number: using ( Transaction t = new Transaction( doc ) )        {          t.Start( "Create Beam Type and Instance" );          // If the family was not already loaded' then do so:            if ( null == f )          {            if ( !doc.LoadFamily( _path' out f ) )            {              message = "Unable to load '" + _path + "'.";            }          }            if ( null != f )          {            Debug.Print( "Family name={0}"' f.Name );              // Pick a symbol for duplication' any one will do'            // we select the first:              FamilySymbol s = null;              //foreach( FamilySymbol s2 in f.Symbols ) // 2014              foreach ( ElementId id in f.GetFamilySymbolIds() ) // 2015            {              s = doc.GetElement( id ) as FamilySymbol;              break;            }              Debug.Assert( null != s' "expected at least one symbol to be defined in family" );              // Duplicate the existing symbol:              ElementType s1 = s.Duplicate( "Nuovo simbolo" );            s = s1 as FamilySymbol;              // Analyse the symbol parameters:              foreach ( Parameter param in s.Parameters )            {              Debug.Print( "Parameter name={0}' value={1}"' param.Definition.Name' param.AsValueString() );            }              // Define new dimensions for our new type;            // the specified parameter name is case sensitive:              //s.get_Parameter( "b" ).Set( Util.MmToFoot( 500 ) ); // 2014            //s.get_Parameter( "h" ).Set( Util.MmToFoot( 1000 ) ); // 2014              s.LookupParameter( "b" ).Set( Util.MmToFoot( 500 ) ); // 2015            s.LookupParameter( "h" ).Set( Util.MmToFoot( 1000 ) ); // 2015              // we can change the symbol name at any time:              s.Name = "Nuovo simbolo due";              // insert an instance of our new symbol:              Autodesk.Revit.Creation.Application creApp = app.Application.Create;            Autodesk.Revit.Creation.Document creDoc = doc.Create;              // It is possible to insert a beam'            // which normally uses a location line'            // by specifying only a location point:              //XYZ p = XYZ.Zero;            //doc.Create.NewFamilyInstance( p' s' nonStructural );              XYZ p = XYZ.Zero;            XYZ q = creApp.NewXYZ( 30' 20' 20 ); // feet            Line line = Line.CreateBound( p' q );              // Specifying a non-structural type here means no beam            // is created' and results in a null family instance:              FamilyInstance fi = creDoc.NewFamilyInstance(              line' s' null' stBeam );              // This creates a visible family instance'            // but the resulting beam has no location line            // and behaves strangely' e.g. cannot be selected:            //FamilyInstance fi = doc.Create.NewFamilyInstance(            //  p' s' q' null' nonStructural );              //List<Element> levels = new List<Element>();            //doc.get_Elements( typeof( Level )' levels );            //Debug.Assert( 0 < levels.Count'            //  "expected at least one level in model" );            //Level level = levels[0] as Level;            //fi = doc.Create.NewFamilyInstance(            //  line' s' level' nonStructural );              rc = Result.Succeeded;          }          t.Commit();        }
Magic Number,BuildingCoder,CmdNewBlend,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewBlend.cs,CreateBlend,The following statement contains a magic number: double endAngle = 2 * Math.PI;
Magic Number,BuildingCoder,CmdNewBlend,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewBlend.cs,CreateBlend,The following statement contains a magic number: double radius = 0.7579;
Magic Number,BuildingCoder,CmdNewBlend,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewBlend.cs,CreateBlend,The following statement contains a magic number: if( circular_top )        {          // create a circular top profile:            XYZ center2 = new XYZ( 0' 0' 1.27 );            //Arc arc3 = creApp.NewArc( center2' radius' startAngle' midAngle' xAxis' yAxis ); // 2013          //Arc arc4 = creApp.NewArc( center2' radius' midAngle' endAngle' xAxis' yAxis ); // 2013            Arc arc3 = Arc.Create( center2' radius' startAngle' midAngle' xAxis' yAxis ); // 2014          Arc arc4 = Arc.Create( center2' radius' midAngle' endAngle' xAxis' yAxis ); // 2014            topProfile.Append( arc3 );          topProfile.Append( arc4 );        }        else        {          // create a skewed rectangle top profile:            XYZ[] pts = new XYZ[] {            new XYZ(0'0'3)'            new XYZ(2'0'3)'            new XYZ(3'2'3)'            new XYZ(0'4'3)          };            for( int i = 0; i < 4; ++i )          {            //topProfile.Append( creApp.NewLineBound( // 2013              topProfile.Append( Line.CreateBound( // 2014              pts[0 == i ? 3 : i - 1]' pts[i] ) );          }        }
Magic Number,BuildingCoder,CmdNewBlend,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewBlend.cs,CreateBlend,The following statement contains a magic number: if( circular_top )        {          // create a circular top profile:            XYZ center2 = new XYZ( 0' 0' 1.27 );            //Arc arc3 = creApp.NewArc( center2' radius' startAngle' midAngle' xAxis' yAxis ); // 2013          //Arc arc4 = creApp.NewArc( center2' radius' midAngle' endAngle' xAxis' yAxis ); // 2013            Arc arc3 = Arc.Create( center2' radius' startAngle' midAngle' xAxis' yAxis ); // 2014          Arc arc4 = Arc.Create( center2' radius' midAngle' endAngle' xAxis' yAxis ); // 2014            topProfile.Append( arc3 );          topProfile.Append( arc4 );        }        else        {          // create a skewed rectangle top profile:            XYZ[] pts = new XYZ[] {            new XYZ(0'0'3)'            new XYZ(2'0'3)'            new XYZ(3'2'3)'            new XYZ(0'4'3)          };            for( int i = 0; i < 4; ++i )          {            //topProfile.Append( creApp.NewLineBound( // 2013              topProfile.Append( Line.CreateBound( // 2014              pts[0 == i ? 3 : i - 1]' pts[i] ) );          }        }
Magic Number,BuildingCoder,CmdNewBlend,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewBlend.cs,CreateBlend,The following statement contains a magic number: if( circular_top )        {          // create a circular top profile:            XYZ center2 = new XYZ( 0' 0' 1.27 );            //Arc arc3 = creApp.NewArc( center2' radius' startAngle' midAngle' xAxis' yAxis ); // 2013          //Arc arc4 = creApp.NewArc( center2' radius' midAngle' endAngle' xAxis' yAxis ); // 2013            Arc arc3 = Arc.Create( center2' radius' startAngle' midAngle' xAxis' yAxis ); // 2014          Arc arc4 = Arc.Create( center2' radius' midAngle' endAngle' xAxis' yAxis ); // 2014            topProfile.Append( arc3 );          topProfile.Append( arc4 );        }        else        {          // create a skewed rectangle top profile:            XYZ[] pts = new XYZ[] {            new XYZ(0'0'3)'            new XYZ(2'0'3)'            new XYZ(3'2'3)'            new XYZ(0'4'3)          };            for( int i = 0; i < 4; ++i )          {            //topProfile.Append( creApp.NewLineBound( // 2013              topProfile.Append( Line.CreateBound( // 2014              pts[0 == i ? 3 : i - 1]' pts[i] ) );          }        }
Magic Number,BuildingCoder,CmdNewBlend,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewBlend.cs,CreateBlend,The following statement contains a magic number: if( circular_top )        {          // create a circular top profile:            XYZ center2 = new XYZ( 0' 0' 1.27 );            //Arc arc3 = creApp.NewArc( center2' radius' startAngle' midAngle' xAxis' yAxis ); // 2013          //Arc arc4 = creApp.NewArc( center2' radius' midAngle' endAngle' xAxis' yAxis ); // 2013            Arc arc3 = Arc.Create( center2' radius' startAngle' midAngle' xAxis' yAxis ); // 2014          Arc arc4 = Arc.Create( center2' radius' midAngle' endAngle' xAxis' yAxis ); // 2014            topProfile.Append( arc3 );          topProfile.Append( arc4 );        }        else        {          // create a skewed rectangle top profile:            XYZ[] pts = new XYZ[] {            new XYZ(0'0'3)'            new XYZ(2'0'3)'            new XYZ(3'2'3)'            new XYZ(0'4'3)          };            for( int i = 0; i < 4; ++i )          {            //topProfile.Append( creApp.NewLineBound( // 2013              topProfile.Append( Line.CreateBound( // 2014              pts[0 == i ? 3 : i - 1]' pts[i] ) );          }        }
Magic Number,BuildingCoder,CmdNewBlend,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewBlend.cs,CreateBlend,The following statement contains a magic number: if( circular_top )        {          // create a circular top profile:            XYZ center2 = new XYZ( 0' 0' 1.27 );            //Arc arc3 = creApp.NewArc( center2' radius' startAngle' midAngle' xAxis' yAxis ); // 2013          //Arc arc4 = creApp.NewArc( center2' radius' midAngle' endAngle' xAxis' yAxis ); // 2013            Arc arc3 = Arc.Create( center2' radius' startAngle' midAngle' xAxis' yAxis ); // 2014          Arc arc4 = Arc.Create( center2' radius' midAngle' endAngle' xAxis' yAxis ); // 2014            topProfile.Append( arc3 );          topProfile.Append( arc4 );        }        else        {          // create a skewed rectangle top profile:            XYZ[] pts = new XYZ[] {            new XYZ(0'0'3)'            new XYZ(2'0'3)'            new XYZ(3'2'3)'            new XYZ(0'4'3)          };            for( int i = 0; i < 4; ++i )          {            //topProfile.Append( creApp.NewLineBound( // 2013              topProfile.Append( Line.CreateBound( // 2014              pts[0 == i ? 3 : i - 1]' pts[i] ) );          }        }
Magic Number,BuildingCoder,CmdNewBlend,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewBlend.cs,CreateBlend,The following statement contains a magic number: if( circular_top )        {          // create a circular top profile:            XYZ center2 = new XYZ( 0' 0' 1.27 );            //Arc arc3 = creApp.NewArc( center2' radius' startAngle' midAngle' xAxis' yAxis ); // 2013          //Arc arc4 = creApp.NewArc( center2' radius' midAngle' endAngle' xAxis' yAxis ); // 2013            Arc arc3 = Arc.Create( center2' radius' startAngle' midAngle' xAxis' yAxis ); // 2014          Arc arc4 = Arc.Create( center2' radius' midAngle' endAngle' xAxis' yAxis ); // 2014            topProfile.Append( arc3 );          topProfile.Append( arc4 );        }        else        {          // create a skewed rectangle top profile:            XYZ[] pts = new XYZ[] {            new XYZ(0'0'3)'            new XYZ(2'0'3)'            new XYZ(3'2'3)'            new XYZ(0'4'3)          };            for( int i = 0; i < 4; ++i )          {            //topProfile.Append( creApp.NewLineBound( // 2013              topProfile.Append( Line.CreateBound( // 2014              pts[0 == i ? 3 : i - 1]' pts[i] ) );          }        }
Magic Number,BuildingCoder,CmdNewBlend,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewBlend.cs,CreateBlend,The following statement contains a magic number: if( circular_top )        {          // create a circular top profile:            XYZ center2 = new XYZ( 0' 0' 1.27 );            //Arc arc3 = creApp.NewArc( center2' radius' startAngle' midAngle' xAxis' yAxis ); // 2013          //Arc arc4 = creApp.NewArc( center2' radius' midAngle' endAngle' xAxis' yAxis ); // 2013            Arc arc3 = Arc.Create( center2' radius' startAngle' midAngle' xAxis' yAxis ); // 2014          Arc arc4 = Arc.Create( center2' radius' midAngle' endAngle' xAxis' yAxis ); // 2014            topProfile.Append( arc3 );          topProfile.Append( arc4 );        }        else        {          // create a skewed rectangle top profile:            XYZ[] pts = new XYZ[] {            new XYZ(0'0'3)'            new XYZ(2'0'3)'            new XYZ(3'2'3)'            new XYZ(0'4'3)          };            for( int i = 0; i < 4; ++i )          {            //topProfile.Append( creApp.NewLineBound( // 2013              topProfile.Append( Line.CreateBound( // 2014              pts[0 == i ? 3 : i - 1]' pts[i] ) );          }        }
Magic Number,BuildingCoder,CmdNewBlend,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewBlend.cs,CreateBlend,The following statement contains a magic number: if( circular_top )        {          // create a circular top profile:            XYZ center2 = new XYZ( 0' 0' 1.27 );            //Arc arc3 = creApp.NewArc( center2' radius' startAngle' midAngle' xAxis' yAxis ); // 2013          //Arc arc4 = creApp.NewArc( center2' radius' midAngle' endAngle' xAxis' yAxis ); // 2013            Arc arc3 = Arc.Create( center2' radius' startAngle' midAngle' xAxis' yAxis ); // 2014          Arc arc4 = Arc.Create( center2' radius' midAngle' endAngle' xAxis' yAxis ); // 2014            topProfile.Append( arc3 );          topProfile.Append( arc4 );        }        else        {          // create a skewed rectangle top profile:            XYZ[] pts = new XYZ[] {            new XYZ(0'0'3)'            new XYZ(2'0'3)'            new XYZ(3'2'3)'            new XYZ(0'4'3)          };            for( int i = 0; i < 4; ++i )          {            //topProfile.Append( creApp.NewLineBound( // 2013              topProfile.Append( Line.CreateBound( // 2014              pts[0 == i ? 3 : i - 1]' pts[i] ) );          }        }
Magic Number,BuildingCoder,CmdNewBlend,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewBlend.cs,CreateBlend,The following statement contains a magic number: if( circular_top )        {          // create a circular top profile:            XYZ center2 = new XYZ( 0' 0' 1.27 );            //Arc arc3 = creApp.NewArc( center2' radius' startAngle' midAngle' xAxis' yAxis ); // 2013          //Arc arc4 = creApp.NewArc( center2' radius' midAngle' endAngle' xAxis' yAxis ); // 2013            Arc arc3 = Arc.Create( center2' radius' startAngle' midAngle' xAxis' yAxis ); // 2014          Arc arc4 = Arc.Create( center2' radius' midAngle' endAngle' xAxis' yAxis ); // 2014            topProfile.Append( arc3 );          topProfile.Append( arc4 );        }        else        {          // create a skewed rectangle top profile:            XYZ[] pts = new XYZ[] {            new XYZ(0'0'3)'            new XYZ(2'0'3)'            new XYZ(3'2'3)'            new XYZ(0'4'3)          };            for( int i = 0; i < 4; ++i )          {            //topProfile.Append( creApp.NewLineBound( // 2013              topProfile.Append( Line.CreateBound( // 2014              pts[0 == i ? 3 : i - 1]' pts[i] ) );          }        }
Magic Number,BuildingCoder,CmdNewBlend,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewBlend.cs,CreateBlend,The following statement contains a magic number: if( circular_top )        {          // create a circular top profile:            XYZ center2 = new XYZ( 0' 0' 1.27 );            //Arc arc3 = creApp.NewArc( center2' radius' startAngle' midAngle' xAxis' yAxis ); // 2013          //Arc arc4 = creApp.NewArc( center2' radius' midAngle' endAngle' xAxis' yAxis ); // 2013            Arc arc3 = Arc.Create( center2' radius' startAngle' midAngle' xAxis' yAxis ); // 2014          Arc arc4 = Arc.Create( center2' radius' midAngle' endAngle' xAxis' yAxis ); // 2014            topProfile.Append( arc3 );          topProfile.Append( arc4 );        }        else        {          // create a skewed rectangle top profile:            XYZ[] pts = new XYZ[] {            new XYZ(0'0'3)'            new XYZ(2'0'3)'            new XYZ(3'2'3)'            new XYZ(0'4'3)          };            for( int i = 0; i < 4; ++i )          {            //topProfile.Append( creApp.NewLineBound( // 2013              topProfile.Append( Line.CreateBound( // 2014              pts[0 == i ? 3 : i - 1]' pts[i] ) );          }        }
Magic Number,BuildingCoder,CmdNewBlend,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewBlend.cs,CreateBlend,The following statement contains a magic number: if( circular_top )        {          // create a circular top profile:            XYZ center2 = new XYZ( 0' 0' 1.27 );            //Arc arc3 = creApp.NewArc( center2' radius' startAngle' midAngle' xAxis' yAxis ); // 2013          //Arc arc4 = creApp.NewArc( center2' radius' midAngle' endAngle' xAxis' yAxis ); // 2013            Arc arc3 = Arc.Create( center2' radius' startAngle' midAngle' xAxis' yAxis ); // 2014          Arc arc4 = Arc.Create( center2' radius' midAngle' endAngle' xAxis' yAxis ); // 2014            topProfile.Append( arc3 );          topProfile.Append( arc4 );        }        else        {          // create a skewed rectangle top profile:            XYZ[] pts = new XYZ[] {            new XYZ(0'0'3)'            new XYZ(2'0'3)'            new XYZ(3'2'3)'            new XYZ(0'4'3)          };            for( int i = 0; i < 4; ++i )          {            //topProfile.Append( creApp.NewLineBound( // 2013              topProfile.Append( Line.CreateBound( // 2014              pts[0 == i ? 3 : i - 1]' pts[i] ) );          }        }
Magic Number,BuildingCoder,CmdNewColumnTypeInstance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewColumnTypeInstance.cs,Execute,The following statement contains a magic number: using ( Transaction t = new Transaction( doc ) )        {          t.Start( "Create New Column Type and Instance" );            // If the family was not already loaded' then do so:            if ( null == f )          {            if ( !doc.LoadFamily( _path' out f ) )            {              message = "Unable to load '" + _path + "'.";            }          }            if ( null != f )          {            Debug.Print( "Family name={0}"' f.Name );              // Pick a symbol for duplication' any one            // will do' we select the first:              FamilySymbol s = null;              //foreach( FamilySymbol s2 in f.Symbols ) // 2014              foreach ( ElementId id in f.GetFamilySymbolIds() ) // 2015            {              s = doc.GetElement( id ) as FamilySymbol;              break;            }              Debug.Assert( null != s'              "expected at least one symbol"              + " to be defined in family" );              // Duplicate the existing symbol:              ElementType s1 = s.Duplicate( "Nuovo simbolo" );            s = s1 as FamilySymbol;              // Analyse the symbol parameters:              foreach ( Parameter param in s.Parameters )            {              Debug.Print(                "Parameter name={0}' value={1}"'                param.Definition.Name'                param.AsValueString() );            }              // Define new dimensions for our new type;            // the specified parameter name is case sensitive:              //s.get_Parameter( "Width" ).Set( Util.MmToFoot( 500 ) ); // 2014            //s.get_Parameter( "Depth" ).Set( Util.MmToFoot( 1000 ) ); // 2014              s.LookupParameter( "Width" ).Set( Util.MmToFoot( 500 ) ); // 2015            s.LookupParameter( "Depth" ).Set( Util.MmToFoot( 1000 ) ); // 2015              // We can change the symbol name at any time:              s.Name = "Nuovo simbolo due";              // Insert an instance of our new symbol:              XYZ p = XYZ.Zero;            doc.Create.NewFamilyInstance(              p' s' nonStructural );              // For a column' the reference direction is ignored:              //XYZ normal = new XYZ( 1' 2' 3 );            //doc.Create.NewFamilyInstance(            //  p' s' normal' null' nonStructural );              rc = Result.Succeeded;          }          t.Commit();        }
Magic Number,BuildingCoder,CmdNewColumnTypeInstance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewColumnTypeInstance.cs,Execute,The following statement contains a magic number: using ( Transaction t = new Transaction( doc ) )        {          t.Start( "Create New Column Type and Instance" );            // If the family was not already loaded' then do so:            if ( null == f )          {            if ( !doc.LoadFamily( _path' out f ) )            {              message = "Unable to load '" + _path + "'.";            }          }            if ( null != f )          {            Debug.Print( "Family name={0}"' f.Name );              // Pick a symbol for duplication' any one            // will do' we select the first:              FamilySymbol s = null;              //foreach( FamilySymbol s2 in f.Symbols ) // 2014              foreach ( ElementId id in f.GetFamilySymbolIds() ) // 2015            {              s = doc.GetElement( id ) as FamilySymbol;              break;            }              Debug.Assert( null != s'              "expected at least one symbol"              + " to be defined in family" );              // Duplicate the existing symbol:              ElementType s1 = s.Duplicate( "Nuovo simbolo" );            s = s1 as FamilySymbol;              // Analyse the symbol parameters:              foreach ( Parameter param in s.Parameters )            {              Debug.Print(                "Parameter name={0}' value={1}"'                param.Definition.Name'                param.AsValueString() );            }              // Define new dimensions for our new type;            // the specified parameter name is case sensitive:              //s.get_Parameter( "Width" ).Set( Util.MmToFoot( 500 ) ); // 2014            //s.get_Parameter( "Depth" ).Set( Util.MmToFoot( 1000 ) ); // 2014              s.LookupParameter( "Width" ).Set( Util.MmToFoot( 500 ) ); // 2015            s.LookupParameter( "Depth" ).Set( Util.MmToFoot( 1000 ) ); // 2015              // We can change the symbol name at any time:              s.Name = "Nuovo simbolo due";              // Insert an instance of our new symbol:              XYZ p = XYZ.Zero;            doc.Create.NewFamilyInstance(              p' s' nonStructural );              // For a column' the reference direction is ignored:              //XYZ normal = new XYZ( 1' 2' 3 );            //doc.Create.NewFamilyInstance(            //  p' s' normal' null' nonStructural );              rc = Result.Succeeded;          }          t.Commit();        }
Magic Number,BuildingCoder,CmdEditFloor,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdEditFloor.cs,Execute2,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Create a Floor" );            int n = 4;          XYZ[] points = new XYZ[n];          points[0] = XYZ.Zero;          points[1] = new XYZ( 10.0' 0.0' 0.0 );          points[2] = new XYZ( 10.0' 10.0' 0.0 );          points[3] = new XYZ( 0.0' 10.0' 0.0 );            CurveArray curve = new CurveArray();            for( int i = 0; i < n; i++ )          {            Line line = Line.CreateBound( points[i]'              points[( i < n - 1 ) ? i + 1 : 0] );              curve.Append( line );          }            doc.Create.NewFloor( curve' true );            tx.Commit();        }
Magic Number,BuildingCoder,CmdEditFloor,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdEditFloor.cs,Execute2,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Create a Floor" );            int n = 4;          XYZ[] points = new XYZ[n];          points[0] = XYZ.Zero;          points[1] = new XYZ( 10.0' 0.0' 0.0 );          points[2] = new XYZ( 10.0' 10.0' 0.0 );          points[3] = new XYZ( 0.0' 10.0' 0.0 );            CurveArray curve = new CurveArray();            for( int i = 0; i < n; i++ )          {            Line line = Line.CreateBound( points[i]'              points[( i < n - 1 ) ? i + 1 : 0] );              curve.Append( line );          }            doc.Create.NewFloor( curve' true );            tx.Commit();        }
Magic Number,BuildingCoder,CmdEditFloor,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdEditFloor.cs,Execute2,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Create a Floor" );            int n = 4;          XYZ[] points = new XYZ[n];          points[0] = XYZ.Zero;          points[1] = new XYZ( 10.0' 0.0' 0.0 );          points[2] = new XYZ( 10.0' 10.0' 0.0 );          points[3] = new XYZ( 0.0' 10.0' 0.0 );            CurveArray curve = new CurveArray();            for( int i = 0; i < n; i++ )          {            Line line = Line.CreateBound( points[i]'              points[( i < n - 1 ) ? i + 1 : 0] );              curve.Append( line );          }            doc.Create.NewFloor( curve' true );            tx.Commit();        }
Magic Number,BuildingCoder,CmdEditFloor,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdEditFloor.cs,Execute2,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Create a Floor" );            int n = 4;          XYZ[] points = new XYZ[n];          points[0] = XYZ.Zero;          points[1] = new XYZ( 10.0' 0.0' 0.0 );          points[2] = new XYZ( 10.0' 10.0' 0.0 );          points[3] = new XYZ( 0.0' 10.0' 0.0 );            CurveArray curve = new CurveArray();            for( int i = 0; i < n; i++ )          {            Line line = Line.CreateBound( points[i]'              points[( i < n - 1 ) ? i + 1 : 0] );              curve.Append( line );          }            doc.Create.NewFloor( curve' true );            tx.Commit();        }
Magic Number,BuildingCoder,CmdEditFloor,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdEditFloor.cs,Execute2,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Create a Floor" );            int n = 4;          XYZ[] points = new XYZ[n];          points[0] = XYZ.Zero;          points[1] = new XYZ( 10.0' 0.0' 0.0 );          points[2] = new XYZ( 10.0' 10.0' 0.0 );          points[3] = new XYZ( 0.0' 10.0' 0.0 );            CurveArray curve = new CurveArray();            for( int i = 0; i < n; i++ )          {            Line line = Line.CreateBound( points[i]'              points[( i < n - 1 ) ? i + 1 : 0] );              curve.Append( line );          }            doc.Create.NewFloor( curve' true );            tx.Commit();        }
Magic Number,BuildingCoder,CmdEditFloor,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdEditFloor.cs,Execute2,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Create a Floor" );            int n = 4;          XYZ[] points = new XYZ[n];          points[0] = XYZ.Zero;          points[1] = new XYZ( 10.0' 0.0' 0.0 );          points[2] = new XYZ( 10.0' 10.0' 0.0 );          points[3] = new XYZ( 0.0' 10.0' 0.0 );            CurveArray curve = new CurveArray();            for( int i = 0; i < n; i++ )          {            Line line = Line.CreateBound( points[i]'              points[( i < n - 1 ) ? i + 1 : 0] );              curve.Append( line );          }            doc.Create.NewFloor( curve' true );            tx.Commit();        }
Magic Number,BuildingCoder,CmdEditFloor,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdEditFloor.cs,Execute2,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Create a Floor" );            int n = 4;          XYZ[] points = new XYZ[n];          points[0] = XYZ.Zero;          points[1] = new XYZ( 10.0' 0.0' 0.0 );          points[2] = new XYZ( 10.0' 10.0' 0.0 );          points[3] = new XYZ( 0.0' 10.0' 0.0 );            CurveArray curve = new CurveArray();            for( int i = 0; i < n; i++ )          {            Line line = Line.CreateBound( points[i]'              points[( i < n - 1 ) ? i + 1 : 0] );              curve.Append( line );          }            doc.Create.NewFloor( curve' true );            tx.Commit();        }
Magic Number,BuildingCoder,CmdEditFloor,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdEditFloor.cs,Execute,The following statement contains a magic number: using ( Transaction t = new Transaction( doc ) )        {          t.Start( "Create Model Lines and Floor" );            // Create new floors from the top faces found.          // Before creating the new floor' we would obviously          // apply whatever modifications are required to the          // new floor profile:            Autodesk.Revit.Creation.Application creApp = app.Application.Create;          Autodesk.Revit.Creation.Document creDoc = doc.Create;            int i = 0;          int n = topFaces.Count - nNullFaces;            Debug.Print(            "{0} top face{1} found."'            n' Util.PluralSuffix( n ) );            foreach ( Face f in topFaces )          {            Floor floor = floors[i++] as Floor;              if ( null != f )            {              EdgeArrayArray eaa = f.EdgeLoops;              CurveArray profile;                #region Attempt to include inner loops  #if ATTEMPT_TO_INCLUDE_INNER_LOOPS            bool use_original_loops = true;            if( use_original_loops )            {              profile = Convert( eaa );            }            else  #endif // ATTEMPT_TO_INCLUDE_INNER_LOOPS              #endregion // Attempt to include inner loops                {                profile = new CurveArray();                  // Only use first edge array'                // the outer boundary loop'                // skip the further items                // representing holes:                  EdgeArray ea = eaa.get_Item( 0 );                foreach ( Edge e in ea )                {                  IList<XYZ> pts = e.Tessellate();                  int m = pts.Count;                  XYZ p = pts[0];                  XYZ q = pts[m - 1];                  Line line = Line.CreateBound( p' q );                  profile.Append( line );                }              }              //Level level = floor.Level; // 2013                Level level = doc.GetElement( floor.LevelId )                as Level; // 2014                // In this case we have a valid floor type given.              // In general' not that NewFloor will only accept               // floor types whose IsFoundationSlab predicate              // is false.                floor = creDoc.NewFloor( profile'                floor.FloorType' level' true );                XYZ v = new XYZ( 5' 5' 0 );                //doc.Move( floor' v ); // 2011              ElementTransformUtils.MoveElement( doc' floor.Id' v ); // 2012            }          }          t.Commit();        }
Magic Number,BuildingCoder,CmdEditFloor,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdEditFloor.cs,Execute,The following statement contains a magic number: using ( Transaction t = new Transaction( doc ) )        {          t.Start( "Create Model Lines and Floor" );            // Create new floors from the top faces found.          // Before creating the new floor' we would obviously          // apply whatever modifications are required to the          // new floor profile:            Autodesk.Revit.Creation.Application creApp = app.Application.Create;          Autodesk.Revit.Creation.Document creDoc = doc.Create;            int i = 0;          int n = topFaces.Count - nNullFaces;            Debug.Print(            "{0} top face{1} found."'            n' Util.PluralSuffix( n ) );            foreach ( Face f in topFaces )          {            Floor floor = floors[i++] as Floor;              if ( null != f )            {              EdgeArrayArray eaa = f.EdgeLoops;              CurveArray profile;                #region Attempt to include inner loops  #if ATTEMPT_TO_INCLUDE_INNER_LOOPS            bool use_original_loops = true;            if( use_original_loops )            {              profile = Convert( eaa );            }            else  #endif // ATTEMPT_TO_INCLUDE_INNER_LOOPS              #endregion // Attempt to include inner loops                {                profile = new CurveArray();                  // Only use first edge array'                // the outer boundary loop'                // skip the further items                // representing holes:                  EdgeArray ea = eaa.get_Item( 0 );                foreach ( Edge e in ea )                {                  IList<XYZ> pts = e.Tessellate();                  int m = pts.Count;                  XYZ p = pts[0];                  XYZ q = pts[m - 1];                  Line line = Line.CreateBound( p' q );                  profile.Append( line );                }              }              //Level level = floor.Level; // 2013                Level level = doc.GetElement( floor.LevelId )                as Level; // 2014                // In this case we have a valid floor type given.              // In general' not that NewFloor will only accept               // floor types whose IsFoundationSlab predicate              // is false.                floor = creDoc.NewFloor( profile'                floor.FloorType' level' true );                XYZ v = new XYZ( 5' 5' 0 );                //doc.Move( floor' v ); // 2011              ElementTransformUtils.MoveElement( doc' floor.Id' v ); // 2012            }          }          t.Commit();        }
Magic Number,BuildingCoder,CmdGetMaterials,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdGetMaterials.cs,GetMaterial,The following statement contains a magic number: foreach( Parameter p in fi.Parameters )        {          Definition def = p.Definition;            // the material is stored as element id:            if( p.StorageType == StorageType.ElementId            && def.ParameterGroup == BuiltInParameterGroup.PG_MATERIALS            && def.ParameterType == ParameterType.Material )          {            ElementId materialId = p.AsElementId();              if( -1 == materialId.IntegerValue )            {              // invalid element id' so we assume              // the material is "By Category":                if( null != fi.Category )              {                material = fi.Category.Material;                  if( null == material )                {                  //MaterialOther mat                  //  = doc.Settings.Materials.AddOther(                  //    "GoodConditionMat" ); // 2011                    ElementId id = Material.Create( doc' "GoodConditionMat" ); // 2012                  Material mat = doc.GetElement( id ) as Material;                    mat.Color = new Color( 255' 0' 0 );                    fi.Category.Material = mat;                    material = fi.Category.Material;                }              }            }    #if BEFORE_REVIT_2013            else            {              material = doc.Settings.Materials.get_Item(                materialId );            }  #endif // BEFORE_REVIT_2013              break;          }        }
Magic Number,BuildingCoder,CmdNewDimensionLabel,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewDimensionLabel.cs,Execute,The following statement contains a magic number: using ( Transaction t = new Transaction( doc ) )        {          t.Start( "New Dimension Label" );              SketchPlane skplane = findSketchPlane( doc' XYZ.BasisZ );            if ( null == skplane )          {            //Plane geometryPlane = creApp.NewPlane( XYZ.BasisZ' XYZ.Zero ); // 2016            Plane geometryPlane = Plane.CreateByNormalAndOrigin( XYZ.BasisZ' XYZ.Zero ); // 2017              //skplane = doc.FamilyCreate.NewSketchPlane( geometryPlane ); // 2013              skplane = SketchPlane.Create( doc' geometryPlane ); // 2014          }            double length = 1.23;            XYZ start = XYZ.Zero;          XYZ end = creApp.NewXYZ( 0' length' 0 );            //Line line = creApp.NewLine( start' end' true ); // 2013            Line line = Line.CreateBound( start' end ); // 2014            ModelCurve modelCurve            = doc.FamilyCreate.NewModelCurve(              line' skplane );            ReferenceArray ra = new ReferenceArray();            ra.Append( modelCurve.GeometryCurve.Reference );            start = creApp.NewXYZ( length' 0' 0 );          end = creApp.NewXYZ( length' length' 0 );            line = Line.CreateBound( start' end );            modelCurve = doc.FamilyCreate.NewModelCurve(            line' skplane );            ra.Append( modelCurve.GeometryCurve.Reference );            start = creApp.NewXYZ( 0' 0.2 * length' 0 );          end = creApp.NewXYZ( length' 0.2 * length' 0 );            line = Line.CreateBound( start' end );            Dimension dim            = doc.FamilyCreate.NewLinearDimension(              doc.ActiveView' line' ra );            FamilyParameter familyParam            = doc.FamilyManager.AddParameter(              "length"'              BuiltInParameterGroup.PG_IDENTITY_DATA'              ParameterType.Length' false );            //dim.Label = familyParam; // 2013          dim.FamilyLabel = familyParam; // 2014            t.Commit();        }
Magic Number,BuildingCoder,CmdNewDimensionLabel,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewDimensionLabel.cs,Execute,The following statement contains a magic number: using ( Transaction t = new Transaction( doc ) )        {          t.Start( "New Dimension Label" );              SketchPlane skplane = findSketchPlane( doc' XYZ.BasisZ );            if ( null == skplane )          {            //Plane geometryPlane = creApp.NewPlane( XYZ.BasisZ' XYZ.Zero ); // 2016            Plane geometryPlane = Plane.CreateByNormalAndOrigin( XYZ.BasisZ' XYZ.Zero ); // 2017              //skplane = doc.FamilyCreate.NewSketchPlane( geometryPlane ); // 2013              skplane = SketchPlane.Create( doc' geometryPlane ); // 2014          }            double length = 1.23;            XYZ start = XYZ.Zero;          XYZ end = creApp.NewXYZ( 0' length' 0 );            //Line line = creApp.NewLine( start' end' true ); // 2013            Line line = Line.CreateBound( start' end ); // 2014            ModelCurve modelCurve            = doc.FamilyCreate.NewModelCurve(              line' skplane );            ReferenceArray ra = new ReferenceArray();            ra.Append( modelCurve.GeometryCurve.Reference );            start = creApp.NewXYZ( length' 0' 0 );          end = creApp.NewXYZ( length' length' 0 );            line = Line.CreateBound( start' end );            modelCurve = doc.FamilyCreate.NewModelCurve(            line' skplane );            ra.Append( modelCurve.GeometryCurve.Reference );            start = creApp.NewXYZ( 0' 0.2 * length' 0 );          end = creApp.NewXYZ( length' 0.2 * length' 0 );            line = Line.CreateBound( start' end );            Dimension dim            = doc.FamilyCreate.NewLinearDimension(              doc.ActiveView' line' ra );            FamilyParameter familyParam            = doc.FamilyManager.AddParameter(              "length"'              BuiltInParameterGroup.PG_IDENTITY_DATA'              ParameterType.Length' false );            //dim.Label = familyParam; // 2013          dim.FamilyLabel = familyParam; // 2014            t.Commit();        }
Magic Number,BuildingCoder,CmdNewDimensionLabel,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewDimensionLabel.cs,Execute,The following statement contains a magic number: using ( Transaction t = new Transaction( doc ) )        {          t.Start( "New Dimension Label" );              SketchPlane skplane = findSketchPlane( doc' XYZ.BasisZ );            if ( null == skplane )          {            //Plane geometryPlane = creApp.NewPlane( XYZ.BasisZ' XYZ.Zero ); // 2016            Plane geometryPlane = Plane.CreateByNormalAndOrigin( XYZ.BasisZ' XYZ.Zero ); // 2017              //skplane = doc.FamilyCreate.NewSketchPlane( geometryPlane ); // 2013              skplane = SketchPlane.Create( doc' geometryPlane ); // 2014          }            double length = 1.23;            XYZ start = XYZ.Zero;          XYZ end = creApp.NewXYZ( 0' length' 0 );            //Line line = creApp.NewLine( start' end' true ); // 2013            Line line = Line.CreateBound( start' end ); // 2014            ModelCurve modelCurve            = doc.FamilyCreate.NewModelCurve(              line' skplane );            ReferenceArray ra = new ReferenceArray();            ra.Append( modelCurve.GeometryCurve.Reference );            start = creApp.NewXYZ( length' 0' 0 );          end = creApp.NewXYZ( length' length' 0 );            line = Line.CreateBound( start' end );            modelCurve = doc.FamilyCreate.NewModelCurve(            line' skplane );            ra.Append( modelCurve.GeometryCurve.Reference );            start = creApp.NewXYZ( 0' 0.2 * length' 0 );          end = creApp.NewXYZ( length' 0.2 * length' 0 );            line = Line.CreateBound( start' end );            Dimension dim            = doc.FamilyCreate.NewLinearDimension(              doc.ActiveView' line' ra );            FamilyParameter familyParam            = doc.FamilyManager.AddParameter(              "length"'              BuiltInParameterGroup.PG_IDENTITY_DATA'              ParameterType.Length' false );            //dim.Label = familyParam; // 2013          dim.FamilyLabel = familyParam; // 2014            t.Commit();        }
Magic Number,BuildingCoder,CmdNewLightingFixture,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewLightingFixture.cs,Execute,The following statement contains a magic number: XYZ p = app.Create.NewXYZ( -43' 28' 0 );
Magic Number,BuildingCoder,CmdNewLightingFixture,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewLightingFixture.cs,Execute,The following statement contains a magic number: XYZ p = app.Create.NewXYZ( -43' 28' 0 );
Magic Number,BuildingCoder,CmdNewLineLoad,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewLineLoad.cs,Execute,The following statement contains a magic number: using( Transaction t = new Transaction( doc ) )        {          t.Start( "Create New Line Load" );            //SketchPlane skplane = cd.NewSketchPlane( plane ); // 2013            SketchPlane skplane = SketchPlane.Create( doc' plane ); // 2014            XYZ forceA = new XYZ( 0' 0' 5 );          XYZ forceB = new XYZ( 0' 0' 10 );          List<XYZ> forces = new List<XYZ>();          forces.Add( forceA );          forces.Add( forceB );            XYZ momentA = new XYZ( 0' 0' 0 );          XYZ momentB = new XYZ( 0' 0' 0 );          List<XYZ> moments = new List<XYZ>();          moments.Add( momentA );          moments.Add( momentB );            BuiltInCategory bic            = BuiltInCategory.OST_StructuralFraming;            FilteredElementCollector beams = Util.GetElementsOfType(            doc' typeof( FamilyInstance )' bic );            XYZ p1 = new XYZ( 0' 0' 0 );          XYZ p2 = new XYZ( 3' 0' 0 );          //List<XYZ> points = new List<XYZ>();          //points.Add( p1 );          //points.Add( p2 );            // create a new unhosted line load on points:            //LineLoad lineLoadNoHost = cd.NewLineLoad(          //  points' forces' moments'          //  false' false' false'          //  loadSymbol' skplane ); // 2015            LineLoad lineLoadNoHost = LineLoad.Create( doc'            p1' p2' forces[0]' moments[0]'            loadSymbol' skplane ); // 2016            Debug.Print( "Unhosted line load works." );            // create new line loads on beam:            foreach( Element e in beams )          {            try            {              //LineLoad lineLoad = cd.NewLineLoad(              //  e' forces' moments'              //  false' false' false'              //  loadSymbol' skplane ); // 2015                AnalyticalModelSurface amsurf = e.GetAnalyticalModel()                as AnalyticalModelSurface;                LineLoad lineLoad = LineLoad.Create( doc'                amsurf' 0' forces[0]' moments[0]' loadSymbol ); // 2016                Debug.Print( "Hosted line load on beam works." );            }            catch( Exception ex )            {              Debug.Print( "Hosted line load on beam fails: "                + ex.Message );            }              FamilyInstance i = e as FamilyInstance;              AnalyticalModel am = i.GetAnalyticalModel();              foreach( Curve curve in              am.GetCurves( AnalyticalCurveType.ActiveCurves ) )            {              try              {                //LineLoad lineLoad = cd.NewLineLoad(                //  curve.Reference' forces' moments'                //  false' false' false'                //  loadSymbol' skplane ); // 2015                  AnalyticalModelStick amstick = e.GetAnalyticalModel()                  as AnalyticalModelStick;                  LineLoad lineLoad = LineLoad.Create( doc'                  amstick' forces[0]' moments[0]' loadSymbol ); // 2016                  Debug.Print( "Hosted line load on "                  + "AnalyticalModelFrame curve works." );              }              catch( Exception ex )              {                Debug.Print( "Hosted line load on "                  + "AnalyticalModelFrame curve fails: "                  + ex.Message );              }            }          }          t.Commit();        }
Magic Number,BuildingCoder,CmdNewLineLoad,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewLineLoad.cs,Execute,The following statement contains a magic number: using( Transaction t = new Transaction( doc ) )        {          t.Start( "Create New Line Load" );            //SketchPlane skplane = cd.NewSketchPlane( plane ); // 2013            SketchPlane skplane = SketchPlane.Create( doc' plane ); // 2014            XYZ forceA = new XYZ( 0' 0' 5 );          XYZ forceB = new XYZ( 0' 0' 10 );          List<XYZ> forces = new List<XYZ>();          forces.Add( forceA );          forces.Add( forceB );            XYZ momentA = new XYZ( 0' 0' 0 );          XYZ momentB = new XYZ( 0' 0' 0 );          List<XYZ> moments = new List<XYZ>();          moments.Add( momentA );          moments.Add( momentB );            BuiltInCategory bic            = BuiltInCategory.OST_StructuralFraming;            FilteredElementCollector beams = Util.GetElementsOfType(            doc' typeof( FamilyInstance )' bic );            XYZ p1 = new XYZ( 0' 0' 0 );          XYZ p2 = new XYZ( 3' 0' 0 );          //List<XYZ> points = new List<XYZ>();          //points.Add( p1 );          //points.Add( p2 );            // create a new unhosted line load on points:            //LineLoad lineLoadNoHost = cd.NewLineLoad(          //  points' forces' moments'          //  false' false' false'          //  loadSymbol' skplane ); // 2015            LineLoad lineLoadNoHost = LineLoad.Create( doc'            p1' p2' forces[0]' moments[0]'            loadSymbol' skplane ); // 2016            Debug.Print( "Unhosted line load works." );            // create new line loads on beam:            foreach( Element e in beams )          {            try            {              //LineLoad lineLoad = cd.NewLineLoad(              //  e' forces' moments'              //  false' false' false'              //  loadSymbol' skplane ); // 2015                AnalyticalModelSurface amsurf = e.GetAnalyticalModel()                as AnalyticalModelSurface;                LineLoad lineLoad = LineLoad.Create( doc'                amsurf' 0' forces[0]' moments[0]' loadSymbol ); // 2016                Debug.Print( "Hosted line load on beam works." );            }            catch( Exception ex )            {              Debug.Print( "Hosted line load on beam fails: "                + ex.Message );            }              FamilyInstance i = e as FamilyInstance;              AnalyticalModel am = i.GetAnalyticalModel();              foreach( Curve curve in              am.GetCurves( AnalyticalCurveType.ActiveCurves ) )            {              try              {                //LineLoad lineLoad = cd.NewLineLoad(                //  curve.Reference' forces' moments'                //  false' false' false'                //  loadSymbol' skplane ); // 2015                  AnalyticalModelStick amstick = e.GetAnalyticalModel()                  as AnalyticalModelStick;                  LineLoad lineLoad = LineLoad.Create( doc'                  amstick' forces[0]' moments[0]' loadSymbol ); // 2016                  Debug.Print( "Hosted line load on "                  + "AnalyticalModelFrame curve works." );              }              catch( Exception ex )              {                Debug.Print( "Hosted line load on "                  + "AnalyticalModelFrame curve fails: "                  + ex.Message );              }            }          }          t.Commit();        }
Magic Number,BuildingCoder,CmdNewLineLoad,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewLineLoad.cs,Execute,The following statement contains a magic number: using( Transaction t = new Transaction( doc ) )        {          t.Start( "Create New Line Load" );            //SketchPlane skplane = cd.NewSketchPlane( plane ); // 2013            SketchPlane skplane = SketchPlane.Create( doc' plane ); // 2014            XYZ forceA = new XYZ( 0' 0' 5 );          XYZ forceB = new XYZ( 0' 0' 10 );          List<XYZ> forces = new List<XYZ>();          forces.Add( forceA );          forces.Add( forceB );            XYZ momentA = new XYZ( 0' 0' 0 );          XYZ momentB = new XYZ( 0' 0' 0 );          List<XYZ> moments = new List<XYZ>();          moments.Add( momentA );          moments.Add( momentB );            BuiltInCategory bic            = BuiltInCategory.OST_StructuralFraming;            FilteredElementCollector beams = Util.GetElementsOfType(            doc' typeof( FamilyInstance )' bic );            XYZ p1 = new XYZ( 0' 0' 0 );          XYZ p2 = new XYZ( 3' 0' 0 );          //List<XYZ> points = new List<XYZ>();          //points.Add( p1 );          //points.Add( p2 );            // create a new unhosted line load on points:            //LineLoad lineLoadNoHost = cd.NewLineLoad(          //  points' forces' moments'          //  false' false' false'          //  loadSymbol' skplane ); // 2015            LineLoad lineLoadNoHost = LineLoad.Create( doc'            p1' p2' forces[0]' moments[0]'            loadSymbol' skplane ); // 2016            Debug.Print( "Unhosted line load works." );            // create new line loads on beam:            foreach( Element e in beams )          {            try            {              //LineLoad lineLoad = cd.NewLineLoad(              //  e' forces' moments'              //  false' false' false'              //  loadSymbol' skplane ); // 2015                AnalyticalModelSurface amsurf = e.GetAnalyticalModel()                as AnalyticalModelSurface;                LineLoad lineLoad = LineLoad.Create( doc'                amsurf' 0' forces[0]' moments[0]' loadSymbol ); // 2016                Debug.Print( "Hosted line load on beam works." );            }            catch( Exception ex )            {              Debug.Print( "Hosted line load on beam fails: "                + ex.Message );            }              FamilyInstance i = e as FamilyInstance;              AnalyticalModel am = i.GetAnalyticalModel();              foreach( Curve curve in              am.GetCurves( AnalyticalCurveType.ActiveCurves ) )            {              try              {                //LineLoad lineLoad = cd.NewLineLoad(                //  curve.Reference' forces' moments'                //  false' false' false'                //  loadSymbol' skplane ); // 2015                  AnalyticalModelStick amstick = e.GetAnalyticalModel()                  as AnalyticalModelStick;                  LineLoad lineLoad = LineLoad.Create( doc'                  amstick' forces[0]' moments[0]' loadSymbol ); // 2016                  Debug.Print( "Hosted line load on "                  + "AnalyticalModelFrame curve works." );              }              catch( Exception ex )              {                Debug.Print( "Hosted line load on "                  + "AnalyticalModelFrame curve fails: "                  + ex.Message );              }            }          }          t.Commit();        }
Magic Number,BuildingCoder,CmdNewRailing,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewRailing.cs,Execute,The following statement contains a magic number: using ( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Create New Railing" );            XYZ p1 = new XYZ( 17' 0' 0 );          XYZ p2 = new XYZ( 33' 0' 0 );          Line line = Line.CreateBound( p1' p2 );            // we need a FamilySymbol instance here' but only have a Symbol:            FamilyInstance Railing1            = doc.Create.NewFamilyInstance(              line' sym' level' StructuralType.NonStructural );            tx.Commit();        }
Magic Number,BuildingCoder,CmdNewRailing,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewRailing.cs,Execute,The following statement contains a magic number: using ( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Create New Railing" );            XYZ p1 = new XYZ( 17' 0' 0 );          XYZ p2 = new XYZ( 33' 0' 0 );          Line line = Line.CreateBound( p1' p2 );            // we need a FamilySymbol instance here' but only have a Symbol:            FamilyInstance Railing1            = doc.Create.NewFamilyInstance(              line' sym' level' StructuralType.NonStructural );            tx.Commit();        }
Magic Number,BuildingCoder,CmdNewSpotElevation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewSpotElevation.cs,ViewApiCreateViewSample,The following statement contains a magic number: XYZ eyePosition = new XYZ( 10' 10' 10 );
Magic Number,BuildingCoder,CmdNewSpotElevation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewSpotElevation.cs,ViewApiCreateViewSample,The following statement contains a magic number: XYZ eyePosition = new XYZ( 10' 10' 10 );
Magic Number,BuildingCoder,CmdNewSpotElevation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewSpotElevation.cs,ViewApiCreateViewSample,The following statement contains a magic number: XYZ eyePosition = new XYZ( 10' 10' 10 );
Magic Number,BuildingCoder,CmdNewSpotElevation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewSpotElevation.cs,FindTopMostReference,The following statement contains a magic number: foreach( Face f in solid.Faces )        {          BoundingBoxUV b = f.GetBoundingBox();          UV p = b.Min;          UV q = b.Max;          UV midparam = p + 0.5 * ( q - p );          XYZ midpoint = f.Evaluate( midparam );          XYZ normal = f.ComputeNormal( midparam );            if( Util.PointsUpwards( normal ) )          {            if( midpoint.Z > z )            {              z = midpoint.Z;              ret = f.Reference;            }          }        }
Magic Number,BuildingCoder,CmdNewSpotElevation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewSpotElevation.cs,NewSpotElevation,The following statement contains a magic number: ElementId instanceId = new ElementId( 230298 );
Magic Number,BuildingCoder,CmdNewSpotElevation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewSpotElevation.cs,NewSpotElevation,The following statement contains a magic number: using( Transaction t = new Transaction( doc ) )        {          t.Start( "Create Spot Elevation" );            Reference topReference            = FindTopMostReference( beam );            LocationCurve lCurve = beam.Location            as LocationCurve;            for( int i = 0; i < 3; ++i )          {            XYZ lCurvePnt = lCurve.Curve.Evaluate(              0.5 * i' true );              XYZ bendPnt = lCurvePnt.Add(              Create.NewXYZ( 0' 1' 4 ) );              XYZ endPnt = lCurvePnt.Add(              Create.NewXYZ( 0' 2' 4 ) );              // NewSpotElevation arguments:            // View view' Reference reference'            // XYZ origin' XYZ bend' XYZ end' XYZ refPt'            // bool hasLeader              SpotDimension d = doc.Create.NewSpotElevation(              westView' topReference' lCurvePnt' bendPnt'              endPnt' lCurvePnt' true );          }            //doc.EndTransaction(); // for VSTA macro version            t.Commit();        }
Magic Number,BuildingCoder,CmdNewSpotElevation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewSpotElevation.cs,NewSpotElevation,The following statement contains a magic number: using( Transaction t = new Transaction( doc ) )        {          t.Start( "Create Spot Elevation" );            Reference topReference            = FindTopMostReference( beam );            LocationCurve lCurve = beam.Location            as LocationCurve;            for( int i = 0; i < 3; ++i )          {            XYZ lCurvePnt = lCurve.Curve.Evaluate(              0.5 * i' true );              XYZ bendPnt = lCurvePnt.Add(              Create.NewXYZ( 0' 1' 4 ) );              XYZ endPnt = lCurvePnt.Add(              Create.NewXYZ( 0' 2' 4 ) );              // NewSpotElevation arguments:            // View view' Reference reference'            // XYZ origin' XYZ bend' XYZ end' XYZ refPt'            // bool hasLeader              SpotDimension d = doc.Create.NewSpotElevation(              westView' topReference' lCurvePnt' bendPnt'              endPnt' lCurvePnt' true );          }            //doc.EndTransaction(); // for VSTA macro version            t.Commit();        }
Magic Number,BuildingCoder,CmdNewSpotElevation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewSpotElevation.cs,NewSpotElevation,The following statement contains a magic number: using( Transaction t = new Transaction( doc ) )        {          t.Start( "Create Spot Elevation" );            Reference topReference            = FindTopMostReference( beam );            LocationCurve lCurve = beam.Location            as LocationCurve;            for( int i = 0; i < 3; ++i )          {            XYZ lCurvePnt = lCurve.Curve.Evaluate(              0.5 * i' true );              XYZ bendPnt = lCurvePnt.Add(              Create.NewXYZ( 0' 1' 4 ) );              XYZ endPnt = lCurvePnt.Add(              Create.NewXYZ( 0' 2' 4 ) );              // NewSpotElevation arguments:            // View view' Reference reference'            // XYZ origin' XYZ bend' XYZ end' XYZ refPt'            // bool hasLeader              SpotDimension d = doc.Create.NewSpotElevation(              westView' topReference' lCurvePnt' bendPnt'              endPnt' lCurvePnt' true );          }            //doc.EndTransaction(); // for VSTA macro version            t.Commit();        }
Magic Number,BuildingCoder,CmdNewSpotElevation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewSpotElevation.cs,NewSpotElevation,The following statement contains a magic number: using( Transaction t = new Transaction( doc ) )        {          t.Start( "Create Spot Elevation" );            Reference topReference            = FindTopMostReference( beam );            LocationCurve lCurve = beam.Location            as LocationCurve;            for( int i = 0; i < 3; ++i )          {            XYZ lCurvePnt = lCurve.Curve.Evaluate(              0.5 * i' true );              XYZ bendPnt = lCurvePnt.Add(              Create.NewXYZ( 0' 1' 4 ) );              XYZ endPnt = lCurvePnt.Add(              Create.NewXYZ( 0' 2' 4 ) );              // NewSpotElevation arguments:            // View view' Reference reference'            // XYZ origin' XYZ bend' XYZ end' XYZ refPt'            // bool hasLeader              SpotDimension d = doc.Create.NewSpotElevation(              westView' topReference' lCurvePnt' bendPnt'              endPnt' lCurvePnt' true );          }            //doc.EndTransaction(); // for VSTA macro version            t.Commit();        }
Magic Number,BuildingCoder,CmdNewSpotElevation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewSpotElevation.cs,NewSpotElevation,The following statement contains a magic number: using( Transaction t = new Transaction( doc ) )        {          t.Start( "Create Spot Elevation" );            Reference topReference            = FindTopMostReference( beam );            LocationCurve lCurve = beam.Location            as LocationCurve;            for( int i = 0; i < 3; ++i )          {            XYZ lCurvePnt = lCurve.Curve.Evaluate(              0.5 * i' true );              XYZ bendPnt = lCurvePnt.Add(              Create.NewXYZ( 0' 1' 4 ) );              XYZ endPnt = lCurvePnt.Add(              Create.NewXYZ( 0' 2' 4 ) );              // NewSpotElevation arguments:            // View view' Reference reference'            // XYZ origin' XYZ bend' XYZ end' XYZ refPt'            // bool hasLeader              SpotDimension d = doc.Create.NewSpotElevation(              westView' topReference' lCurvePnt' bendPnt'              endPnt' lCurvePnt' true );          }            //doc.EndTransaction(); // for VSTA macro version            t.Commit();        }
Magic Number,BuildingCoder,CmdNewSprinkler,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewSprinkler.cs,PointOnFace,The following statement contains a magic number: for ( int i = 0; i < mesh.NumTriangles; )        {          MeshTriangle triangle = mesh.get_Triangle( i );          p += triangle.get_Vertex( 0 );          p += triangle.get_Vertex( 1 );          p += triangle.get_Vertex( 2 );          p *= 0.3333333333333333;          break;        }
Magic Number,BuildingCoder,CmdNewSprinkler,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewSprinkler.cs,PointOnFace,The following statement contains a magic number: for ( int i = 0; i < mesh.NumTriangles; )        {          MeshTriangle triangle = mesh.get_Triangle( i );          p += triangle.get_Vertex( 0 );          p += triangle.get_Vertex( 1 );          p += triangle.get_Vertex( 2 );          p *= 0.3333333333333333;          break;        }
Magic Number,BuildingCoder,CmdNewSweptBlend,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewSweptBlend.cs,CreateNewSweptBlend,The following statement contains a magic number: XYZ p00 = creapp.NewXYZ( 0' 7.5' 0 );
Magic Number,BuildingCoder,CmdNewSweptBlend,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewSweptBlend.cs,CreateNewSweptBlend,The following statement contains a magic number: XYZ p01 = creapp.NewXYZ( 0' 15' 0 );
Magic Number,BuildingCoder,CmdNewSweptBlend,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewSweptBlend.cs,CreateNewSweptBlend,The following statement contains a magic number: XYZ p02 = creapp.NewXYZ( -1' 10' 0 );
Magic Number,BuildingCoder,CmdNewSweptBlend,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewSweptBlend.cs,CreateNewSweptBlend,The following statement contains a magic number: XYZ p10 = creapp.NewXYZ( 7.5' 0' 0 );
Magic Number,BuildingCoder,CmdNewSweptBlend,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewSweptBlend.cs,CreateNewSweptBlend,The following statement contains a magic number: XYZ p11 = creapp.NewXYZ( 15' 0' 0 );
Magic Number,BuildingCoder,CmdNewSweptBlend,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewSweptBlend.cs,CreateNewSweptBlend,The following statement contains a magic number: XYZ p12 = creapp.NewXYZ( 10' -1' 0 );
Magic Number,BuildingCoder,CmdNewSweptBlend,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewSweptBlend.cs,CreateNewSweptBlend,The following statement contains a magic number: XYZ pnt10 = new XYZ( 5' 0' 0 );
Magic Number,BuildingCoder,CmdNewSweptBlend,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewSweptBlend.cs,CreateNewSweptBlend,The following statement contains a magic number: XYZ pnt11 = new XYZ( 0' 20' 0 );
Magic Number,BuildingCoder,CmdNewSweptBlend,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewSweptBlend.cs,CreateNewSweptBlendArc,The following statement contains a magic number: XYZ p5 = 5 * XYZ.BasisY;
Magic Number,BuildingCoder,CmdNewSweptBlend,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewSweptBlend.cs,CreateNewSweptBlendArc,The following statement contains a magic number: XYZ pmid = new XYZ( 2.5' 2.5' 0 );
Magic Number,BuildingCoder,CmdNewSweptBlend,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewSweptBlend.cs,CreateNewSweptBlendArc,The following statement contains a magic number: XYZ pmid = new XYZ( 2.5' 2.5' 0 );
Magic Number,BuildingCoder,CmdNewWallLayer,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdNewWallLayer.cs,Execute,The following statement contains a magic number: using ( Transaction t = new Transaction( doc ) )        {          t.Start( "Create New Wall Layer" );            //WallTypeSet wallTypes = doc.WallTypes; // 2013             FilteredElementCollector wallTypes            = new FilteredElementCollector( doc )              .OfClass( typeof( WallType ) ); // 2014            foreach ( WallType wallType in wallTypes )          {            if ( 0 < wallType.GetCompoundStructure().GetLayers().Count )            {              CompoundStructureLayer oldLayer                = wallType.GetCompoundStructure().GetLayers()[0];                WallType newWallType                = wallType.Duplicate( "NewWallType" ) as WallType;                CompoundStructure structure                = newWallType.GetCompoundStructure();                IList<CompoundStructureLayer> layers                = structure.GetLayers();                // in Revit 2012' we can create a new layer:                double width = 0.1;              MaterialFunctionAssignment function = oldLayer.Function;              ElementId materialId = oldLayer.MaterialId;                CompoundStructureLayer newLayer                = new CompoundStructureLayer( width' function' materialId );                layers.Add( newLayer );              structure.SetLayers( layers );              newWallType.SetCompoundStructure( structure );            }          }          t.Commit();        }
Magic Number,BuildingCoder,CmdPickPoint3d,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdPickPoint3d.cs,PickPointsForArea,The following statement contains a magic number: area = Math.Round( area' 2 );
Magic Number,BuildingCoder,CmdPlanTopology,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdPlanTopology.cs,CreateRoom,The following statement contains a magic number: XYZ pt1 = new XYZ( 0' -5' 0 );
Magic Number,BuildingCoder,CmdPlanTopology,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdPlanTopology.cs,CreateRoom,The following statement contains a magic number: XYZ pt2 = new XYZ( 0' 5' 0 );
Magic Number,BuildingCoder,CmdPlanTopology,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdPlanTopology.cs,CreateRoom,The following statement contains a magic number: XYZ pt3 = new XYZ( 8' 5' 0 );
Magic Number,BuildingCoder,CmdPlanTopology,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdPlanTopology.cs,CreateRoom,The following statement contains a magic number: XYZ pt3 = new XYZ( 8' 5' 0 );
Magic Number,BuildingCoder,CmdPlanTopology,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdPlanTopology.cs,CreateRoom,The following statement contains a magic number: XYZ pt4 = new XYZ( 8' -5' 0 );
Magic Number,BuildingCoder,CmdPlanTopology,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdPlanTopology.cs,CreateRoom,The following statement contains a magic number: XYZ pt4 = new XYZ( 8' -5' 0 );
Magic Number,BuildingCoder,CmdPlanTopology,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdPlanTopology.cs,CreateRoom,The following statement contains a magic number: UV tagPoint = new UV( 4' 0 );
Magic Number,BuildingCoder,Press,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdPressKeys.cs,OneKey,The following statement contains a magic number: uint keyDownCode = ( uint )          WH_KEYBOARD_LPARAM.KEYDOWN          | ( scanCode << 16 );
Magic Number,BuildingCoder,Press,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdPressKeys.cs,OneKey,The following statement contains a magic number: uint keyUpCode = ( uint )          WH_KEYBOARD_LPARAM.KEYUP          | ( scanCode << 16 );
Magic Number,BuildingCoder,CmdPressKeys,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdPressKeys.cs,Execute,The following statement contains a magic number: if( 0 == uidoc.Selection.GetElementIds().Count ) // 2015        {          // No wall with the correct wall type found            FilteredElementCollector collector            = new FilteredElementCollector( doc );            Level ll = collector            .OfClass( typeof( Level ) )            .FirstElement() as Level;            // place a new wall with the          // correct wall type in the project            //Line geomLine = app.Create.NewLineBound( XYZ.Zero' new XYZ( 2' 0' 0 ) ); // 2013          Line geomLine = Line.CreateBound( XYZ.Zero' new XYZ( 2' 0' 0 ) ); // 2014            Transaction t = new Transaction(            doc' "Create dummy wall" );            t.Start();            //Wall nw = doc.Create.NewWall( geomLine' // 2012          //  wallType' ll' 1' 0' false' false );            Wall nw = Wall.Create( doc' geomLine' // 2013            wallType.Id' ll.Id' 1' 0' false' false );            t.Commit();            // Select the new wall in the project            //uidoc.Selection.Elements.Add( nw ); // 2014            ids.Clear();          ids.Add( nw.Id );          uidoc.Selection.SetElementIds( ids ); // 2015            // Start command create similar. In the          // property menu' our wall type is set current            Press.Keys( "CS" );            // Select the new wall in the project'          // so we can delete it            //uidoc.Selection.Elements.Add( nw ); // 2014            ids.Clear();          ids.Add( nw.Id );          uidoc.Selection.SetElementIds( ids ); // 2015            // Erase the selected wall (remark:          // doc.delete(nw) may not be used'          // this command will undo)            Press.Keys( "DE" );            // Start up wall command            Press.Keys( "WA" );        }        else        {          // The correct wall is already selected:            Press.Keys( "CS" ); // Start "create similar"        }
Magic Number,BuildingCoder,CmdPreviewImage,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdPreviewImage.cs,Execute,The following statement contains a magic number: foreach( FamilyInstance fi in collector )        {          Debug.Assert( null != fi.Category'            "expected family instance to have a valid category" );            ElementId typeId = fi.GetTypeId();            ElementType type = doc.GetElement( typeId )            as ElementType;            Size imgSize = new Size( 200' 200 );            Bitmap image = type.GetPreviewImage( imgSize );            // encode image to jpeg for test display purposes:            JpegBitmapEncoder encoder            = new JpegBitmapEncoder();            encoder.Frames.Add( BitmapFrame.Create(            ConvertBitmapToBitmapSource( image ) ) );            encoder.QualityLevel = 25;            string filename = "a.jpg";            FileStream file = new FileStream(            filename' FileMode.Create' FileAccess.Write );            encoder.Save( file );          file.Close();            Process.Start( filename ); // test display        }
Magic Number,BuildingCoder,CmdPreviewImage,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdPreviewImage.cs,Execute,The following statement contains a magic number: foreach( FamilyInstance fi in collector )        {          Debug.Assert( null != fi.Category'            "expected family instance to have a valid category" );            ElementId typeId = fi.GetTypeId();            ElementType type = doc.GetElement( typeId )            as ElementType;            Size imgSize = new Size( 200' 200 );            Bitmap image = type.GetPreviewImage( imgSize );            // encode image to jpeg for test display purposes:            JpegBitmapEncoder encoder            = new JpegBitmapEncoder();            encoder.Frames.Add( BitmapFrame.Create(            ConvertBitmapToBitmapSource( image ) ) );            encoder.QualityLevel = 25;            string filename = "a.jpg";            FileStream file = new FileStream(            filename' FileMode.Create' FileAccess.Write );            encoder.Save( file );          file.Close();            Process.Start( filename ); // test display        }
Magic Number,BuildingCoder,CmdPreviewImage,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdPreviewImage.cs,Execute,The following statement contains a magic number: foreach( FamilyInstance fi in collector )        {          Debug.Assert( null != fi.Category'            "expected family instance to have a valid category" );            ElementId typeId = fi.GetTypeId();            ElementType type = doc.GetElement( typeId )            as ElementType;            Size imgSize = new Size( 200' 200 );            Bitmap image = type.GetPreviewImage( imgSize );            // encode image to jpeg for test display purposes:            JpegBitmapEncoder encoder            = new JpegBitmapEncoder();            encoder.Frames.Add( BitmapFrame.Create(            ConvertBitmapToBitmapSource( image ) ) );            encoder.QualityLevel = 25;            string filename = "a.jpg";            FileStream file = new FileStream(            filename' FileMode.Create' FileAccess.Write );            encoder.Save( file );          file.Close();            Process.Start( filename ); // test display        }
Magic Number,BuildingCoder,CmdPurgeTextNoteTypes,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdPurgeTextNoteTypes.cs,Execute,The following statement contains a magic number: int nLoop = 100;
Magic Number,BuildingCoder,CmdRectDuctCorners,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdRectDuctCorners.cs,Test1,The following statement contains a magic number: XYZ p = connector.CoordinateSystem.OfPoint(          new XYZ( connector.Width / 2'            connector.Height / 2' 0 ) );
Magic Number,BuildingCoder,CmdRectDuctCorners,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdRectDuctCorners.cs,Test1,The following statement contains a magic number: XYZ p = connector.CoordinateSystem.OfPoint(          new XYZ( connector.Width / 2'            connector.Height / 2' 0 ) );
Magic Number,BuildingCoder,CmdRectDuctCorners,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdRectDuctCorners.cs,Test2,The following statement contains a magic number: XYZ p = connector.CoordinateSystem.OfPoint(          new XYZ( connector.Height / 2'            connector.Width / 2' 0 ) );
Magic Number,BuildingCoder,CmdRectDuctCorners,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdRectDuctCorners.cs,Test2,The following statement contains a magic number: XYZ p = connector.CoordinateSystem.OfPoint(          new XYZ( connector.Height / 2'            connector.Width / 2' 0 ) );
Magic Number,BuildingCoder,CmdRectDuctCorners,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdRectDuctCorners.cs,FaceContainsConnector,The following statement contains a magic number: return null != result          && Math.Abs( result.Distance ) < 1e-9;
Magic Number,BuildingCoder,CmdRemoveImportedJpgs,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdRemoveImportedJpgs.cs,ElementNameEndsWithJpg,The following statement contains a magic number: return 3 < s.Length && s.EndsWith( ".jpg" );
Magic Number,BuildingCoder,CmdRotatedBeamLocation,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdRotatedBeamLocation.cs,Execute,The following statement contains a magic number: if( null == beam          || null == beam.Category          || !beam.Category.Id.IntegerValue.Equals( (int) bic ) )        {          message = "Please select a single beam element.";        }        else        {          LocationCurve curve            = beam.Location as LocationCurve;            if( null == curve )          {            message = "No curve available";            return Result.Failed;          }            XYZ p = curve.Curve.GetEndPoint( 0 );          XYZ q = curve.Curve.GetEndPoint( 1 );          XYZ v = 0.1 * (q - p);          p = p - v;          q = q + v;            //Creator creator = new Creator( doc );          //creator.CreateModelLine( p' q );            using ( Transaction t = new Transaction( doc ) )          {            t.Start( "Create Model Line" );              Creator.CreateModelLine( doc' p' q );              t.Commit();          }        }
Magic Number,BuildingCoder,CmdSetGridEndpoint,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSetGridEndpoint.cs,AlignOffAxisGrid,The following statement contains a magic number: double max_distance = 0.0001;
Magic Number,BuildingCoder,CmdSetGridEndpoint,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSetGridEndpoint.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Modify Grid Endpoints" );            foreach( Curve c in gridCurves )          {            XYZ start = c.GetEndPoint( 0 );            XYZ end = c.GetEndPoint( 1 );              XYZ newStart = start + 10 * XYZ.BasisY;            XYZ newEnd = end - 10 * XYZ.BasisY;              Line newLine = Line.CreateBound( newStart' newEnd );              grid.SetCurveInView(              DatumExtentType.Model' view' newLine );          }          tx.Commit();        }
Magic Number,BuildingCoder,CmdSetGridEndpoint,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSetGridEndpoint.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Modify Grid Endpoints" );            foreach( Curve c in gridCurves )          {            XYZ start = c.GetEndPoint( 0 );            XYZ end = c.GetEndPoint( 1 );              XYZ newStart = start + 10 * XYZ.BasisY;            XYZ newEnd = end - 10 * XYZ.BasisY;              Line newLine = Line.CreateBound( newStart' newEnd );              grid.SetCurveInView(              DatumExtentType.Model' view' newLine );          }          tx.Commit();        }
Magic Number,BuildingCoder,CmdSetTagType,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSetTagType.cs,Execute,The following statement contains a magic number: double length = 5 * MeterToFeet;
Magic Number,BuildingCoder,CmdSetTagType,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSetTagType.cs,Execute,The following statement contains a magic number: XYZ [] pts = new XYZ[2];
Magic Number,BuildingCoder,CmdSetTagType,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSetTagType.cs,Execute,The following statement contains a magic number: using ( Transaction t = new Transaction( doc ) )        {          t.Start( "Create Wall' Door and Tag" );            // Create a wall:            BuiltInParameter topLevelParam            = BuiltInParameter.WALL_HEIGHT_TYPE;            ElementId topLevelId = levelTop.Id;            //Line line = createApp.NewLineBound( pts[0]' pts[1] ); // 2013          Line line = Line.CreateBound( pts[0]' pts[1] ); // 2014            //Wall wall = createDoc.NewWall( // 2012          //  line' levelBottom' false );            Wall wall = Wall.Create( // 2013            doc' line' levelBottom.Id' false );            Parameter param = wall.get_Parameter(            topLevelParam );            param.Set( topLevelId );            // Determine wall thickness for tag          // offset and profile growth:            //double wallThickness = wall.WallType.CompoundStructure.Layers.get_Item( 0 ).Thickness; // 2011            double wallThickness = wall.WallType.GetCompoundStructure().GetLayers()[0].Width; // 2012            // Add door to wall;          // note that the NewFamilyInstance method          // does not automatically add a door tag'          // like the UI command does:            FamilySymbol doorSymbol = GetFirstFamilySymbol(            doc' BuiltInCategory.OST_Doors );            if ( null == doorSymbol )          {            message = "No door symbol found.";            return Result.Failed;          }            XYZ midpoint = Util.Midpoint( pts[0]' pts[1] );            FamilyInstance door = createDoc            .NewFamilyInstance(              midpoint' doorSymbol' wall' levelBottom'              StructuralType.NonStructural );            // Create door tag:            View view = doc.ActiveView;            double tagOffset = 3 * wallThickness;            midpoint += tagOffset * XYZ.BasisY;            // 2011: TagOrientation.TAG_HORIZONTAL            //IndependentTag tag = createDoc.NewTag(          //  view' door' false' TagMode.TM_ADDBY_CATEGORY'          //  TagOrientation.Horizontal' midpoint ); // 2012            IndependentTag tag = IndependentTag.Create(            doc' view.Id' new Reference( door )'            false' TagMode.TM_ADDBY_CATEGORY'            TagOrientation.Horizontal' midpoint ); // 2018            // Create and assign new door tag type:            FamilySymbol doorTagType            = GetFirstFamilySymbol(              doc' BuiltInCategory.OST_DoorTags );            doorTagType = doorTagType.Duplicate(            "New door tag type" ) as FamilySymbol;            tag.ChangeTypeId( doorTagType.Id );            // Demonstrate changing name of          // family instance and family symbol:            door.Name = door.Name + " modified";          door.Symbol.Name = door.Symbol.Name + " modified";            t.Commit();        }
Magic Number,BuildingCoder,CmdSetTangentLock,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSetTangentLock.cs,SetTangentLockInProfileSketch1,The following statement contains a magic number: for( int i = 0; i < enmIDs.Count; i++ )        {          Element ele = famdoc.GetElement( enmIDs[i] );          if( ele is ModelArc )          {            ModelArc ma = ele as ModelArc;            Curve c = ma.GeometryCurve;            Arc a = c as Arc;              if( Math.Round( r1' 6 ) == Math.Round( a.Radius' 6 ) )            {              mArcsR1.Add( ma );            }            if( Math.Round( r2' 6 ) == Math.Round( a.Radius' 6 ) )            {              mArcsR2.Add( ma );            }          }          if( ele is ModelLine )          {            ModelLine ml = ele as ModelLine;            Element before = null;            Element after = null;            ElementId beforeId = null;            ElementId afterId = null;              if( i > 0 )            {              before = famdoc.GetElement( enmIDs[i - 1] );              beforeId = enmIDs[i - 1];            }            else            {              before = famdoc.GetElement( enmIDs[enmIDs.Count - 1] );              beforeId = enmIDs[enmIDs.Count - 1];            }            if( i == enmIDs.Count - 1 )            {              after = famdoc.GetElement( enmIDs[0] );              afterId = enmIDs[0];            }            else            {              after = famdoc.GetElement( enmIDs[i + 1] );              afterId = enmIDs[i + 1];            }              if( before is ModelArc && after is ModelArc )            {              ml.SetTangentLock( 0' beforeId' true );              ml.SetTangentLock( 1' afterId' true );            }          }        }
Magic Number,BuildingCoder,CmdSetTangentLock,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSetTangentLock.cs,SetTangentLockInProfileSketch1,The following statement contains a magic number: for( int i = 0; i < enmIDs.Count; i++ )        {          Element ele = famdoc.GetElement( enmIDs[i] );          if( ele is ModelArc )          {            ModelArc ma = ele as ModelArc;            Curve c = ma.GeometryCurve;            Arc a = c as Arc;              if( Math.Round( r1' 6 ) == Math.Round( a.Radius' 6 ) )            {              mArcsR1.Add( ma );            }            if( Math.Round( r2' 6 ) == Math.Round( a.Radius' 6 ) )            {              mArcsR2.Add( ma );            }          }          if( ele is ModelLine )          {            ModelLine ml = ele as ModelLine;            Element before = null;            Element after = null;            ElementId beforeId = null;            ElementId afterId = null;              if( i > 0 )            {              before = famdoc.GetElement( enmIDs[i - 1] );              beforeId = enmIDs[i - 1];            }            else            {              before = famdoc.GetElement( enmIDs[enmIDs.Count - 1] );              beforeId = enmIDs[enmIDs.Count - 1];            }            if( i == enmIDs.Count - 1 )            {              after = famdoc.GetElement( enmIDs[0] );              afterId = enmIDs[0];            }            else            {              after = famdoc.GetElement( enmIDs[i + 1] );              afterId = enmIDs[i + 1];            }              if( before is ModelArc && after is ModelArc )            {              ml.SetTangentLock( 0' beforeId' true );              ml.SetTangentLock( 1' afterId' true );            }          }        }
Magic Number,BuildingCoder,CmdSetTangentLock,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSetTangentLock.cs,SetTangentLockInProfileSketch1,The following statement contains a magic number: for( int i = 0; i < enmIDs.Count; i++ )        {          Element ele = famdoc.GetElement( enmIDs[i] );          if( ele is ModelArc )          {            ModelArc ma = ele as ModelArc;            Curve c = ma.GeometryCurve;            Arc a = c as Arc;              if( Math.Round( r1' 6 ) == Math.Round( a.Radius' 6 ) )            {              mArcsR1.Add( ma );            }            if( Math.Round( r2' 6 ) == Math.Round( a.Radius' 6 ) )            {              mArcsR2.Add( ma );            }          }          if( ele is ModelLine )          {            ModelLine ml = ele as ModelLine;            Element before = null;            Element after = null;            ElementId beforeId = null;            ElementId afterId = null;              if( i > 0 )            {              before = famdoc.GetElement( enmIDs[i - 1] );              beforeId = enmIDs[i - 1];            }            else            {              before = famdoc.GetElement( enmIDs[enmIDs.Count - 1] );              beforeId = enmIDs[enmIDs.Count - 1];            }            if( i == enmIDs.Count - 1 )            {              after = famdoc.GetElement( enmIDs[0] );              afterId = enmIDs[0];            }            else            {              after = famdoc.GetElement( enmIDs[i + 1] );              afterId = enmIDs[i + 1];            }              if( before is ModelArc && after is ModelArc )            {              ml.SetTangentLock( 0' beforeId' true );              ml.SetTangentLock( 1' afterId' true );            }          }        }
Magic Number,BuildingCoder,CmdSetTangentLock,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSetTangentLock.cs,SetTangentLockInProfileSketch1,The following statement contains a magic number: for( int i = 0; i < enmIDs.Count; i++ )        {          Element ele = famdoc.GetElement( enmIDs[i] );          if( ele is ModelArc )          {            ModelArc ma = ele as ModelArc;            Curve c = ma.GeometryCurve;            Arc a = c as Arc;              if( Math.Round( r1' 6 ) == Math.Round( a.Radius' 6 ) )            {              mArcsR1.Add( ma );            }            if( Math.Round( r2' 6 ) == Math.Round( a.Radius' 6 ) )            {              mArcsR2.Add( ma );            }          }          if( ele is ModelLine )          {            ModelLine ml = ele as ModelLine;            Element before = null;            Element after = null;            ElementId beforeId = null;            ElementId afterId = null;              if( i > 0 )            {              before = famdoc.GetElement( enmIDs[i - 1] );              beforeId = enmIDs[i - 1];            }            else            {              before = famdoc.GetElement( enmIDs[enmIDs.Count - 1] );              beforeId = enmIDs[enmIDs.Count - 1];            }            if( i == enmIDs.Count - 1 )            {              after = famdoc.GetElement( enmIDs[0] );              afterId = enmIDs[0];            }            else            {              after = famdoc.GetElement( enmIDs[i + 1] );              afterId = enmIDs[i + 1];            }              if( before is ModelArc && after is ModelArc )            {              ml.SetTangentLock( 0' beforeId' true );              ml.SetTangentLock( 1' afterId' true );            }          }        }
Magic Number,BuildingCoder,CmdSetTangentLock,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSetTangentLock.cs,SetTangentLockInProfileSketch2,The following statement contains a magic number: for( int i = 0; i < enmIDs.Count; i++ )        {          Element ele = famdoc.GetElement( enmIDs[i] );          if( ele is ModelArc )          {            ModelArc ma = ele as ModelArc;            Curve c = ma.GeometryCurve;            Arc a = c as Arc;              if( Math.Round( r1' 6 ) == Math.Round( a.Radius' 6 ) )            {              mArcsR1.Add( ma );            }            if( Math.Round( r2' 6 ) == Math.Round( a.Radius' 6 ) )            {              mArcsR2.Add( ma );            }          }          if( ele is ModelLine )          {            ModelLine ml = ele as ModelLine;            ElementId beforeId = null;            ElementId afterId = null;              ISet<ElementId> joinedBefore = ml.GetAdjoinedCurveElements( 0 );            foreach( ElementId id in joinedBefore )            {              Element joinedEle = famdoc.GetElement( id );                if( joinedEle is ModelArc )              {                beforeId = id;                break;              }            }            ISet<ElementId> joinedAfter = ml.GetAdjoinedCurveElements( 1 );            foreach( ElementId id in joinedAfter )            {              Element joinedEle = famdoc.GetElement( id );                if( joinedEle is ModelArc )              {                afterId = id;                break;              }            }              if( beforeId != null               && afterId != null               && ml.HasTangentJoin( 0' beforeId )               && ml.HasTangentJoin( 1' afterId ) )            {              ml.SetTangentLock( 0' beforeId' true );              ml.SetTangentLock( 1' afterId' true );            }          }        }
Magic Number,BuildingCoder,CmdSetTangentLock,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSetTangentLock.cs,SetTangentLockInProfileSketch2,The following statement contains a magic number: for( int i = 0; i < enmIDs.Count; i++ )        {          Element ele = famdoc.GetElement( enmIDs[i] );          if( ele is ModelArc )          {            ModelArc ma = ele as ModelArc;            Curve c = ma.GeometryCurve;            Arc a = c as Arc;              if( Math.Round( r1' 6 ) == Math.Round( a.Radius' 6 ) )            {              mArcsR1.Add( ma );            }            if( Math.Round( r2' 6 ) == Math.Round( a.Radius' 6 ) )            {              mArcsR2.Add( ma );            }          }          if( ele is ModelLine )          {            ModelLine ml = ele as ModelLine;            ElementId beforeId = null;            ElementId afterId = null;              ISet<ElementId> joinedBefore = ml.GetAdjoinedCurveElements( 0 );            foreach( ElementId id in joinedBefore )            {              Element joinedEle = famdoc.GetElement( id );                if( joinedEle is ModelArc )              {                beforeId = id;                break;              }            }            ISet<ElementId> joinedAfter = ml.GetAdjoinedCurveElements( 1 );            foreach( ElementId id in joinedAfter )            {              Element joinedEle = famdoc.GetElement( id );                if( joinedEle is ModelArc )              {                afterId = id;                break;              }            }              if( beforeId != null               && afterId != null               && ml.HasTangentJoin( 0' beforeId )               && ml.HasTangentJoin( 1' afterId ) )            {              ml.SetTangentLock( 0' beforeId' true );              ml.SetTangentLock( 1' afterId' true );            }          }        }
Magic Number,BuildingCoder,CmdSetTangentLock,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSetTangentLock.cs,SetTangentLockInProfileSketch2,The following statement contains a magic number: for( int i = 0; i < enmIDs.Count; i++ )        {          Element ele = famdoc.GetElement( enmIDs[i] );          if( ele is ModelArc )          {            ModelArc ma = ele as ModelArc;            Curve c = ma.GeometryCurve;            Arc a = c as Arc;              if( Math.Round( r1' 6 ) == Math.Round( a.Radius' 6 ) )            {              mArcsR1.Add( ma );            }            if( Math.Round( r2' 6 ) == Math.Round( a.Radius' 6 ) )            {              mArcsR2.Add( ma );            }          }          if( ele is ModelLine )          {            ModelLine ml = ele as ModelLine;            ElementId beforeId = null;            ElementId afterId = null;              ISet<ElementId> joinedBefore = ml.GetAdjoinedCurveElements( 0 );            foreach( ElementId id in joinedBefore )            {              Element joinedEle = famdoc.GetElement( id );                if( joinedEle is ModelArc )              {                beforeId = id;                break;              }            }            ISet<ElementId> joinedAfter = ml.GetAdjoinedCurveElements( 1 );            foreach( ElementId id in joinedAfter )            {              Element joinedEle = famdoc.GetElement( id );                if( joinedEle is ModelArc )              {                afterId = id;                break;              }            }              if( beforeId != null               && afterId != null               && ml.HasTangentJoin( 0' beforeId )               && ml.HasTangentJoin( 1' afterId ) )            {              ml.SetTangentLock( 0' beforeId' true );              ml.SetTangentLock( 1' afterId' true );            }          }        }
Magic Number,BuildingCoder,CmdSetTangentLock,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSetTangentLock.cs,SetTangentLockInProfileSketch2,The following statement contains a magic number: for( int i = 0; i < enmIDs.Count; i++ )        {          Element ele = famdoc.GetElement( enmIDs[i] );          if( ele is ModelArc )          {            ModelArc ma = ele as ModelArc;            Curve c = ma.GeometryCurve;            Arc a = c as Arc;              if( Math.Round( r1' 6 ) == Math.Round( a.Radius' 6 ) )            {              mArcsR1.Add( ma );            }            if( Math.Round( r2' 6 ) == Math.Round( a.Radius' 6 ) )            {              mArcsR2.Add( ma );            }          }          if( ele is ModelLine )          {            ModelLine ml = ele as ModelLine;            ElementId beforeId = null;            ElementId afterId = null;              ISet<ElementId> joinedBefore = ml.GetAdjoinedCurveElements( 0 );            foreach( ElementId id in joinedBefore )            {              Element joinedEle = famdoc.GetElement( id );                if( joinedEle is ModelArc )              {                beforeId = id;                break;              }            }            ISet<ElementId> joinedAfter = ml.GetAdjoinedCurveElements( 1 );            foreach( ElementId id in joinedAfter )            {              Element joinedEle = famdoc.GetElement( id );                if( joinedEle is ModelArc )              {                afterId = id;                break;              }            }              if( beforeId != null               && afterId != null               && ml.HasTangentJoin( 0' beforeId )               && ml.HasTangentJoin( 1' afterId ) )            {              ml.SetTangentLock( 0' beforeId' true );              ml.SetTangentLock( 1' afterId' true );            }          }        }
Magic Number,BuildingCoder,CmdSetWallType,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSetWallType.cs,Execute,The following statement contains a magic number: ElementId wall_id = new ElementId( 25122 );
Magic Number,BuildingCoder,CmdSheetToModel,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSheetToModel.cs,QTO_2_PlaceHoldersFromDWFMarkups,The following statement contains a magic number: using( TransactionGroup tg = new TransactionGroup( doc ) )        {          tg.Start( "DWF markups placeholders" );            using( Transaction t = new Transaction( doc ) )          {            t.Start( "DWF Transfer" );              plan.Parameters.Cast<Parameter>()              .First( x => x.Id.IntegerValue.Equals(                (int) BuiltInParameter.VIEWER_CROP_REGION ) )              .Set( 1 );              XYZ VC = ( plan.CropBox.Min + plan.CropBox.Max ) / 2;              XYZ BC = vp.GetBoxCenter();              t.RollBack();              foreach( Element e in dwfMarkups )            {              GeometryElement GeoElem = e.get_Geometry( new Options() );                GeometryInstance gi = GeoElem.Cast<GeometryInstance>().First();                GeometryElement gei = gi.GetSymbolGeometry();                IList<GeometryObject> gos = new List<GeometryObject>();                if( gei.Cast<GeometryObject>().Count( x => x is Arc ) > 0 )              {                continue;              }                foreach( GeometryObject go in gei )              {                XYZ med = new XYZ();                  if( go is PolyLine )                {                  PolyLine pl = go as PolyLine;                    XYZ min = new XYZ( pl.GetCoordinates().Min( p => p.X )'                                  pl.GetCoordinates().Min( p => p.Y )'                                  pl.GetCoordinates().Min( p => p.Z ) );                    XYZ max = new XYZ( pl.GetCoordinates().Max( p => p.X )'                                  pl.GetCoordinates().Max( p => p.Y )'                                  pl.GetCoordinates().Max( p => p.Z ) );                    med = ( min + max ) / 2;                }                  med = med - BC;                  // Convert DWF sheet coordinates into model coordinates                  XYZ a = VC + new XYZ( med.X * scale' med.Y * scale' 0 );              }            }              t.Start( "DWF Transfer" );              foreach( Element e in dwfMarkups )            {              GeometryElement GeoElem = e.get_Geometry( new Options() );                GeometryInstance gi = GeoElem.Cast<GeometryInstance>().First();                GeometryElement gei = gi.GetSymbolGeometry();                IList<GeometryObject> gos = new List<GeometryObject>();                if( gei.Cast<GeometryObject>().Count( x => x is Arc ) == 0 )              {                continue;              }                foreach( GeometryObject go in gei )              {                if( go is Arc )                {                  Curve c = go as Curve;                    XYZ med = c.Evaluate( 0.5' true );                    med = med - BC;                    XYZ a = VC + new XYZ( med.X * scale' med.Y * scale' 0 );                    // Warning CS0618:                   // Autodesk.Revit.Creation.ItemFactoryBase.NewTextNote(                  //   View' XYZ' XYZ' XYZ' double' TextAlignFlags' string)                   // is obsolete:                   // This method is deprecated in Revit 2016.                   // Please use one of the TextNote.Create methods instead.                    //doc.Create.NewTextNote( plan'                  //                       a'                  //                       XYZ.BasisX'                  //                       XYZ.BasisY'                  //                       MMtoFeet( 5 )'                  //                       TextAlignFlags.TEF_ALIGN_CENTER'                  //                       activityId );                    ElementId textTypeId = new FilteredElementCollector( doc )                    .OfClass( typeof( TextNoteType ) )                    .FirstElementId();                    TextNote.Create( doc' plan.Id' a' activityId' textTypeId );                }              }                t.Commit();            }          }            tg.Assimilate();        }
Magic Number,BuildingCoder,CmdSheetToModel,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSheetToModel.cs,QTO_2_PlaceHoldersFromDWFMarkups,The following statement contains a magic number: using( TransactionGroup tg = new TransactionGroup( doc ) )        {          tg.Start( "DWF markups placeholders" );            using( Transaction t = new Transaction( doc ) )          {            t.Start( "DWF Transfer" );              plan.Parameters.Cast<Parameter>()              .First( x => x.Id.IntegerValue.Equals(                (int) BuiltInParameter.VIEWER_CROP_REGION ) )              .Set( 1 );              XYZ VC = ( plan.CropBox.Min + plan.CropBox.Max ) / 2;              XYZ BC = vp.GetBoxCenter();              t.RollBack();              foreach( Element e in dwfMarkups )            {              GeometryElement GeoElem = e.get_Geometry( new Options() );                GeometryInstance gi = GeoElem.Cast<GeometryInstance>().First();                GeometryElement gei = gi.GetSymbolGeometry();                IList<GeometryObject> gos = new List<GeometryObject>();                if( gei.Cast<GeometryObject>().Count( x => x is Arc ) > 0 )              {                continue;              }                foreach( GeometryObject go in gei )              {                XYZ med = new XYZ();                  if( go is PolyLine )                {                  PolyLine pl = go as PolyLine;                    XYZ min = new XYZ( pl.GetCoordinates().Min( p => p.X )'                                  pl.GetCoordinates().Min( p => p.Y )'                                  pl.GetCoordinates().Min( p => p.Z ) );                    XYZ max = new XYZ( pl.GetCoordinates().Max( p => p.X )'                                  pl.GetCoordinates().Max( p => p.Y )'                                  pl.GetCoordinates().Max( p => p.Z ) );                    med = ( min + max ) / 2;                }                  med = med - BC;                  // Convert DWF sheet coordinates into model coordinates                  XYZ a = VC + new XYZ( med.X * scale' med.Y * scale' 0 );              }            }              t.Start( "DWF Transfer" );              foreach( Element e in dwfMarkups )            {              GeometryElement GeoElem = e.get_Geometry( new Options() );                GeometryInstance gi = GeoElem.Cast<GeometryInstance>().First();                GeometryElement gei = gi.GetSymbolGeometry();                IList<GeometryObject> gos = new List<GeometryObject>();                if( gei.Cast<GeometryObject>().Count( x => x is Arc ) == 0 )              {                continue;              }                foreach( GeometryObject go in gei )              {                if( go is Arc )                {                  Curve c = go as Curve;                    XYZ med = c.Evaluate( 0.5' true );                    med = med - BC;                    XYZ a = VC + new XYZ( med.X * scale' med.Y * scale' 0 );                    // Warning CS0618:                   // Autodesk.Revit.Creation.ItemFactoryBase.NewTextNote(                  //   View' XYZ' XYZ' XYZ' double' TextAlignFlags' string)                   // is obsolete:                   // This method is deprecated in Revit 2016.                   // Please use one of the TextNote.Create methods instead.                    //doc.Create.NewTextNote( plan'                  //                       a'                  //                       XYZ.BasisX'                  //                       XYZ.BasisY'                  //                       MMtoFeet( 5 )'                  //                       TextAlignFlags.TEF_ALIGN_CENTER'                  //                       activityId );                    ElementId textTypeId = new FilteredElementCollector( doc )                    .OfClass( typeof( TextNoteType ) )                    .FirstElementId();                    TextNote.Create( doc' plan.Id' a' activityId' textTypeId );                }              }                t.Commit();            }          }            tg.Assimilate();        }
Magic Number,BuildingCoder,CmdSheetToModel,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSheetToModel.cs,QTO_2_PlaceHoldersFromDWFMarkups,The following statement contains a magic number: using( TransactionGroup tg = new TransactionGroup( doc ) )        {          tg.Start( "DWF markups placeholders" );            using( Transaction t = new Transaction( doc ) )          {            t.Start( "DWF Transfer" );              plan.Parameters.Cast<Parameter>()              .First( x => x.Id.IntegerValue.Equals(                (int) BuiltInParameter.VIEWER_CROP_REGION ) )              .Set( 1 );              XYZ VC = ( plan.CropBox.Min + plan.CropBox.Max ) / 2;              XYZ BC = vp.GetBoxCenter();              t.RollBack();              foreach( Element e in dwfMarkups )            {              GeometryElement GeoElem = e.get_Geometry( new Options() );                GeometryInstance gi = GeoElem.Cast<GeometryInstance>().First();                GeometryElement gei = gi.GetSymbolGeometry();                IList<GeometryObject> gos = new List<GeometryObject>();                if( gei.Cast<GeometryObject>().Count( x => x is Arc ) > 0 )              {                continue;              }                foreach( GeometryObject go in gei )              {                XYZ med = new XYZ();                  if( go is PolyLine )                {                  PolyLine pl = go as PolyLine;                    XYZ min = new XYZ( pl.GetCoordinates().Min( p => p.X )'                                  pl.GetCoordinates().Min( p => p.Y )'                                  pl.GetCoordinates().Min( p => p.Z ) );                    XYZ max = new XYZ( pl.GetCoordinates().Max( p => p.X )'                                  pl.GetCoordinates().Max( p => p.Y )'                                  pl.GetCoordinates().Max( p => p.Z ) );                    med = ( min + max ) / 2;                }                  med = med - BC;                  // Convert DWF sheet coordinates into model coordinates                  XYZ a = VC + new XYZ( med.X * scale' med.Y * scale' 0 );              }            }              t.Start( "DWF Transfer" );              foreach( Element e in dwfMarkups )            {              GeometryElement GeoElem = e.get_Geometry( new Options() );                GeometryInstance gi = GeoElem.Cast<GeometryInstance>().First();                GeometryElement gei = gi.GetSymbolGeometry();                IList<GeometryObject> gos = new List<GeometryObject>();                if( gei.Cast<GeometryObject>().Count( x => x is Arc ) == 0 )              {                continue;              }                foreach( GeometryObject go in gei )              {                if( go is Arc )                {                  Curve c = go as Curve;                    XYZ med = c.Evaluate( 0.5' true );                    med = med - BC;                    XYZ a = VC + new XYZ( med.X * scale' med.Y * scale' 0 );                    // Warning CS0618:                   // Autodesk.Revit.Creation.ItemFactoryBase.NewTextNote(                  //   View' XYZ' XYZ' XYZ' double' TextAlignFlags' string)                   // is obsolete:                   // This method is deprecated in Revit 2016.                   // Please use one of the TextNote.Create methods instead.                    //doc.Create.NewTextNote( plan'                  //                       a'                  //                       XYZ.BasisX'                  //                       XYZ.BasisY'                  //                       MMtoFeet( 5 )'                  //                       TextAlignFlags.TEF_ALIGN_CENTER'                  //                       activityId );                    ElementId textTypeId = new FilteredElementCollector( doc )                    .OfClass( typeof( TextNoteType ) )                    .FirstElementId();                    TextNote.Create( doc' plan.Id' a' activityId' textTypeId );                }              }                t.Commit();            }          }            tg.Assimilate();        }
Magic Number,BuildingCoder,CmdMiroTest2,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSheetToModel.cs,Execute,The following statement contains a magic number: try // generic        {          // Current View must be Sheet          ViewSheet sheet = _doc.ActiveView as ViewSheet;          if( null == sheet )          {            Util.ErrorMsg( "Current View is NOT a Sheet!" );            return Result.Cancelled;          }            // There must be a Floor Plan named "Level 0"           // which is the "master" to align to          Viewport vpMaster = null;          // There must be at least one more Floor Plan           // View to align (move)          List<Viewport> vpsSlave = new List<Viewport>();          // Find them:          foreach( ElementId idVp in sheet.GetAllViewports() )          {            Viewport vp = _doc.GetElement( idVp ) as Viewport;            ViewRvt v = _doc.GetElement( vp.ViewId ) as ViewRvt;            if( v.ViewType == ViewType.FloorPlan )            {              if( v.Name.Equals( "Level 0"' StringComparison                .CurrentCultureIgnoreCase ) )              {                vpMaster = vp;              }              else              {                vpsSlave.Add( vp );              }              } //if FloorPlan            } //foreeach idVp            // Check if got them all          if( null == vpMaster )          {            Util.ErrorMsg( "NO 'Level 0' Floor Plan on the Sheet!" );            return Result.Cancelled;          }          else if( vpsSlave.Count == 0 )          {            Util.ErrorMsg( "NO other Floor Plans to adjust on the Sheet!" );            return Result.Cancelled;          }              // Process Master            // --------------              XYZ ptMasterVpCenter = vpMaster.GetBoxCenter();          ViewRvt viewMaster = _doc.GetElement(            vpMaster.ViewId ) as ViewRvt;          double scaleMaster = viewMaster.Scale;            // Process Slaves          // --------------            using ( Transaction t = new Transaction( _doc ) )          {            t.Start( "Set Box Centres" );              foreach ( Viewport vpSlave in vpsSlave )            {              XYZ ptSlaveVpCenter = vpSlave.GetBoxCenter();              ViewRvt viewSlave = _doc.GetElement(                vpSlave.ViewId ) as ViewRvt;              double scaleSlave = viewSlave.Scale;              // MUST be the same scale' otherwise can't really overlap              if ( scaleSlave != scaleMaster ) continue;                // Work out how to move the center of Slave               // Viewport to coincide model-wise with Master              // (must use center as only Viewport.SetBoxCenter               // is provided in API)              // We can ignore View.Outline as Viewport.GetBoxOutline               // is ALWAYS the same dimensions enlarged by               // 0.01 ft in each direction.              // This guarantees that the center of View is               // also center of Viewport' BUT there is a               // problem when any Elevation Symbols outside               // the crop box are visible (can't work out why              // - BUG?' or how to calculate it all if BY-DESIGN)                BoundingBoxXYZ bbm = viewMaster.CropBox;              BoundingBoxXYZ bbs = viewSlave.CropBox;                // 0) Center points in WCS              XYZ wcsCenterMaster = 0.5 * bbm.Min.Add( bbm.Max );              XYZ wcsCenterSlave = 0.5 * bbs.Min.Add( bbs.Max );                // 1) Delta (in model's feet) of the slave center w.r.t master center              double deltaX = wcsCenterSlave.X - wcsCenterMaster.X;              double deltaY = wcsCenterSlave.Y - wcsCenterMaster.Y;                // 1a) Scale to Delta in Sheet's paper-space feet              deltaX *= 1.0 / (double) scaleMaster;              deltaY *= 1.0 / (double) scaleMaster;                // 2) New center point for the slave viewport' so *models* "overlap":              XYZ newCenter = new XYZ(                ptMasterVpCenter.X + deltaX'                ptMasterVpCenter.Y + deltaY'                ptSlaveVpCenter.Z );              vpSlave.SetBoxCenter( newCenter );            }            t.Commit();          }        }        catch( Exception ex )        {          Util.ErrorMsg( "Generic exception: " + ex.Message );          return Result.Failed;        }
Magic Number,BuildingCoder,CmdMiroTest2,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSheetToModel.cs,Execute,The following statement contains a magic number: try // generic        {          // Current View must be Sheet          ViewSheet sheet = _doc.ActiveView as ViewSheet;          if( null == sheet )          {            Util.ErrorMsg( "Current View is NOT a Sheet!" );            return Result.Cancelled;          }            // There must be a Floor Plan named "Level 0"           // which is the "master" to align to          Viewport vpMaster = null;          // There must be at least one more Floor Plan           // View to align (move)          List<Viewport> vpsSlave = new List<Viewport>();          // Find them:          foreach( ElementId idVp in sheet.GetAllViewports() )          {            Viewport vp = _doc.GetElement( idVp ) as Viewport;            ViewRvt v = _doc.GetElement( vp.ViewId ) as ViewRvt;            if( v.ViewType == ViewType.FloorPlan )            {              if( v.Name.Equals( "Level 0"' StringComparison                .CurrentCultureIgnoreCase ) )              {                vpMaster = vp;              }              else              {                vpsSlave.Add( vp );              }              } //if FloorPlan            } //foreeach idVp            // Check if got them all          if( null == vpMaster )          {            Util.ErrorMsg( "NO 'Level 0' Floor Plan on the Sheet!" );            return Result.Cancelled;          }          else if( vpsSlave.Count == 0 )          {            Util.ErrorMsg( "NO other Floor Plans to adjust on the Sheet!" );            return Result.Cancelled;          }              // Process Master            // --------------              XYZ ptMasterVpCenter = vpMaster.GetBoxCenter();          ViewRvt viewMaster = _doc.GetElement(            vpMaster.ViewId ) as ViewRvt;          double scaleMaster = viewMaster.Scale;            // Process Slaves          // --------------            using ( Transaction t = new Transaction( _doc ) )          {            t.Start( "Set Box Centres" );              foreach ( Viewport vpSlave in vpsSlave )            {              XYZ ptSlaveVpCenter = vpSlave.GetBoxCenter();              ViewRvt viewSlave = _doc.GetElement(                vpSlave.ViewId ) as ViewRvt;              double scaleSlave = viewSlave.Scale;              // MUST be the same scale' otherwise can't really overlap              if ( scaleSlave != scaleMaster ) continue;                // Work out how to move the center of Slave               // Viewport to coincide model-wise with Master              // (must use center as only Viewport.SetBoxCenter               // is provided in API)              // We can ignore View.Outline as Viewport.GetBoxOutline               // is ALWAYS the same dimensions enlarged by               // 0.01 ft in each direction.              // This guarantees that the center of View is               // also center of Viewport' BUT there is a               // problem when any Elevation Symbols outside               // the crop box are visible (can't work out why              // - BUG?' or how to calculate it all if BY-DESIGN)                BoundingBoxXYZ bbm = viewMaster.CropBox;              BoundingBoxXYZ bbs = viewSlave.CropBox;                // 0) Center points in WCS              XYZ wcsCenterMaster = 0.5 * bbm.Min.Add( bbm.Max );              XYZ wcsCenterSlave = 0.5 * bbs.Min.Add( bbs.Max );                // 1) Delta (in model's feet) of the slave center w.r.t master center              double deltaX = wcsCenterSlave.X - wcsCenterMaster.X;              double deltaY = wcsCenterSlave.Y - wcsCenterMaster.Y;                // 1a) Scale to Delta in Sheet's paper-space feet              deltaX *= 1.0 / (double) scaleMaster;              deltaY *= 1.0 / (double) scaleMaster;                // 2) New center point for the slave viewport' so *models* "overlap":              XYZ newCenter = new XYZ(                ptMasterVpCenter.X + deltaX'                ptMasterVpCenter.Y + deltaY'                ptSlaveVpCenter.Z );              vpSlave.SetBoxCenter( newCenter );            }            t.Commit();          }        }        catch( Exception ex )        {          Util.ErrorMsg( "Generic exception: " + ex.Message );          return Result.Failed;        }
Magic Number,BuildingCoder,CmdSlabBoundaryArea,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSlabBoundaryArea.cs,GetSignedPolygonArea,The following statement contains a magic number: sum += p[n - 1].U * ( p[0].V - p[n - 2].V );
Magic Number,BuildingCoder,CmdSlabBoundaryArea,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSlabBoundaryArea.cs,GetSignedPolygonArea,The following statement contains a magic number: return 0.5 * sum;
Magic Number,BuildingCoder,CmdCreateSlopedSlab,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCreateSlopedSlab.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Create Sloped Slab" );            double width = 19.685039400;          double length = 59.055118200;          double height = 9.84251968503937;            XYZ[] pts = new XYZ[] {            new XYZ( 0.0' 0.0' height )'            new XYZ( width' 0.0' height )'            new XYZ( width' length' height )'            new XYZ( 0' length' height )          };            CurveArray profile             = uiapp.Application.Create.NewCurveArray();            Line line = null;            int n = pts.GetLength( 0 );            XYZ q = pts[n - 1];            foreach( XYZ p in pts )          {            line = Line.CreateBound( q' p );            profile.Append( line );            q = p;          }            Level level            = new FilteredElementCollector( doc )              .OfClass( typeof( Level ) )              .Where<Element>(                e => e.Name.Equals( "CreateSlopedSlab" ) )                .FirstOrDefault<Element>() as Level;            if( null == level )          {            //level = doc.Create.NewLevel( height ); // 2015            level = Level.Create( doc' height ); // 2016            level.Name = "Sloped Slab";          }            Floor floor = doc.Create.NewSlab(            profile' level' line' 0.5' true );            tx.Commit();        }
Magic Number,BuildingCoder,CmdCreateSlopedSlab,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCreateSlopedSlab.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Create Sloped Slab" );            double width = 19.685039400;          double length = 59.055118200;          double height = 9.84251968503937;            XYZ[] pts = new XYZ[] {            new XYZ( 0.0' 0.0' height )'            new XYZ( width' 0.0' height )'            new XYZ( width' length' height )'            new XYZ( 0' length' height )          };            CurveArray profile             = uiapp.Application.Create.NewCurveArray();            Line line = null;            int n = pts.GetLength( 0 );            XYZ q = pts[n - 1];            foreach( XYZ p in pts )          {            line = Line.CreateBound( q' p );            profile.Append( line );            q = p;          }            Level level            = new FilteredElementCollector( doc )              .OfClass( typeof( Level ) )              .Where<Element>(                e => e.Name.Equals( "CreateSlopedSlab" ) )                .FirstOrDefault<Element>() as Level;            if( null == level )          {            //level = doc.Create.NewLevel( height ); // 2015            level = Level.Create( doc' height ); // 2016            level.Name = "Sloped Slab";          }            Floor floor = doc.Create.NewSlab(            profile' level' line' 0.5' true );            tx.Commit();        }
Magic Number,BuildingCoder,CmdCreateSlopedSlab,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCreateSlopedSlab.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Create Sloped Slab" );            double width = 19.685039400;          double length = 59.055118200;          double height = 9.84251968503937;            XYZ[] pts = new XYZ[] {            new XYZ( 0.0' 0.0' height )'            new XYZ( width' 0.0' height )'            new XYZ( width' length' height )'            new XYZ( 0' length' height )          };            CurveArray profile             = uiapp.Application.Create.NewCurveArray();            Line line = null;            int n = pts.GetLength( 0 );            XYZ q = pts[n - 1];            foreach( XYZ p in pts )          {            line = Line.CreateBound( q' p );            profile.Append( line );            q = p;          }            Level level            = new FilteredElementCollector( doc )              .OfClass( typeof( Level ) )              .Where<Element>(                e => e.Name.Equals( "CreateSlopedSlab" ) )                .FirstOrDefault<Element>() as Level;            if( null == level )          {            //level = doc.Create.NewLevel( height ); // 2015            level = Level.Create( doc' height ); // 2016            level.Name = "Sloped Slab";          }            Floor floor = doc.Create.NewSlab(            profile' level' line' 0.5' true );            tx.Commit();        }
Magic Number,BuildingCoder,CmdCreateSlopedSlab,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCreateSlopedSlab.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Create Sloped Slab" );            double width = 19.685039400;          double length = 59.055118200;          double height = 9.84251968503937;            XYZ[] pts = new XYZ[] {            new XYZ( 0.0' 0.0' height )'            new XYZ( width' 0.0' height )'            new XYZ( width' length' height )'            new XYZ( 0' length' height )          };            CurveArray profile             = uiapp.Application.Create.NewCurveArray();            Line line = null;            int n = pts.GetLength( 0 );            XYZ q = pts[n - 1];            foreach( XYZ p in pts )          {            line = Line.CreateBound( q' p );            profile.Append( line );            q = p;          }            Level level            = new FilteredElementCollector( doc )              .OfClass( typeof( Level ) )              .Where<Element>(                e => e.Name.Equals( "CreateSlopedSlab" ) )                .FirstOrDefault<Element>() as Level;            if( null == level )          {            //level = doc.Create.NewLevel( height ); // 2015            level = Level.Create( doc' height ); // 2016            level.Name = "Sloped Slab";          }            Floor floor = doc.Create.NewSlab(            profile' level' line' 0.5' true );            tx.Commit();        }
Magic Number,BuildingCoder,CmdChangeFloorSlope,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCreateSlopedSlab.cs,Execute,The following statement contains a magic number: if( null != ml )        {          using( Transaction tx = new Transaction( doc ) )          {            tx.Start( "Change Slope Angle" );              // This parameter is read only. Therefore'            // the change does not work and we cannot             // change the floor slope angle after the             // floor is created.              ml.get_Parameter(              BuiltInParameter.CURVE_IS_SLOPE_DEFINING )                .Set( 1 );              ml.get_Parameter(              BuiltInParameter.ROOF_SLOPE )                .Set( 1.2 );              tx.Commit();          }        }
Magic Number,BuildingCoder,CmdSlopedWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSlopedWall.cs,Execute,The following statement contains a magic number: List<Curve> profile = new List<Curve>( 4 );
Magic Number,BuildingCoder,CmdSlopedWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSlopedWall.cs,Execute,The following statement contains a magic number: double length = 10;
Magic Number,BuildingCoder,CmdSlopedWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSlopedWall.cs,Execute,The following statement contains a magic number: double heightStart = 5;
Magic Number,BuildingCoder,CmdSlopedWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSlopedWall.cs,Execute,The following statement contains a magic number: double heightEnd = 8;
Magic Number,BuildingCoder,TestWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSlopedWall.cs,Execute,The following statement contains a magic number: XYZ[] pts = new XYZ[] {            new XYZ(5.675844469' 8.769334161' -5.537348007)'            new XYZ(5.665137820' 8.771332255' 2.956630685)'            new XYZ(7.672569880' 8.396698044' 2.959412671)'          };
Magic Number,BuildingCoder,TestWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSlopedWall.cs,Execute,The following statement contains a magic number: XYZ[] pts = new XYZ[] {            new XYZ(5.675844469' 8.769334161' -5.537348007)'            new XYZ(5.665137820' 8.771332255' 2.956630685)'            new XYZ(7.672569880' 8.396698044' 2.959412671)'          };
Magic Number,BuildingCoder,TestWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSlopedWall.cs,Execute,The following statement contains a magic number: XYZ[] pts = new XYZ[] {            new XYZ(5.675844469' 8.769334161' -5.537348007)'            new XYZ(5.665137820' 8.771332255' 2.956630685)'            new XYZ(7.672569880' 8.396698044' 2.959412671)'          };
Magic Number,BuildingCoder,TestWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSlopedWall.cs,Execute,The following statement contains a magic number: XYZ[] pts = new XYZ[] {            new XYZ(5.675844469' 8.769334161' -5.537348007)'            new XYZ(5.665137820' 8.771332255' 2.956630685)'            new XYZ(7.672569880' 8.396698044' 2.959412671)'          };
Magic Number,BuildingCoder,TestWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSlopedWall.cs,Execute,The following statement contains a magic number: XYZ[] pts = new XYZ[] {            new XYZ(5.675844469' 8.769334161' -5.537348007)'            new XYZ(5.665137820' 8.771332255' 2.956630685)'            new XYZ(7.672569880' 8.396698044' 2.959412671)'          };
Magic Number,BuildingCoder,TestWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSlopedWall.cs,Execute,The following statement contains a magic number: XYZ[] pts = new XYZ[] {            new XYZ(5.675844469' 8.769334161' -5.537348007)'            new XYZ(5.665137820' 8.771332255' 2.956630685)'            new XYZ(7.672569880' 8.396698044' 2.959412671)'          };
Magic Number,BuildingCoder,TestWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSlopedWall.cs,Execute,The following statement contains a magic number: XYZ[] pts = new XYZ[] {            new XYZ(5.675844469' 8.769334161' -5.537348007)'            new XYZ(5.665137820' 8.771332255' 2.956630685)'            new XYZ(7.672569880' 8.396698044' 2.959412671)'          };
Magic Number,BuildingCoder,TestWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSlopedWall.cs,Execute,The following statement contains a magic number: XYZ[] pts = new XYZ[] {            new XYZ(5.675844469' 8.769334161' -5.537348007)'            new XYZ(5.665137820' 8.771332255' 2.956630685)'            new XYZ(7.672569880' 8.396698044' 2.959412671)'          };
Magic Number,BuildingCoder,TestWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSlopedWall.cs,Execute,The following statement contains a magic number: XYZ[] pts = new XYZ[] {            new XYZ(5.675844469' 8.769334161' -5.537348007)'            new XYZ(5.665137820' 8.771332255' 2.956630685)'            new XYZ(7.672569880' 8.396698044' 2.959412671)'          };
Magic Number,BuildingCoder,TestWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSlopedWall.cs,Execute,The following statement contains a magic number: XYZ t2 = pts[1] - pts[2];
Magic Number,BuildingCoder,TestWall,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSlopedWall.cs,IsVertical,The following statement contains a magic number: return 1e-9 > Math.Abs(          v1.X * v2.X + v1.Y * v2.Y + v1.Z * v2.Z );
Magic Number,BuildingCoder,SteelStairs,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSteelStairBeams.cs,Run,The following statement contains a magic number: XYZ pt1 = Util.MmToFoot( new XYZ( 0' 0' 1000 ) );
Magic Number,BuildingCoder,SteelStairs,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSteelStairBeams.cs,Run,The following statement contains a magic number: XYZ pt2 = Util.MmToFoot( new XYZ( 1000' 0' 1000 ) );
Magic Number,BuildingCoder,SteelStairs,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSteelStairBeams.cs,Run,The following statement contains a magic number: XYZ pt2 = Util.MmToFoot( new XYZ( 1000' 0' 1000 ) );
Magic Number,BuildingCoder,SteelStairs,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSteelStairBeams.cs,Run,The following statement contains a magic number: XYZ pt3 = Util.MmToFoot( new XYZ( 2000' 0' 2500 ) );
Magic Number,BuildingCoder,SteelStairs,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSteelStairBeams.cs,Run,The following statement contains a magic number: XYZ pt3 = Util.MmToFoot( new XYZ( 2000' 0' 2500 ) );
Magic Number,BuildingCoder,SteelStairs,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSteelStairBeams.cs,Run,The following statement contains a magic number: XYZ pt4 = Util.MmToFoot( new XYZ( 3000' 0' 2500 ) );
Magic Number,BuildingCoder,SteelStairs,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdSteelStairBeams.cs,Run,The following statement contains a magic number: XYZ pt4 = Util.MmToFoot( new XYZ( 3000' 0' 2500 ) );
Magic Number,BuildingCoder,CmdUpdateReferencingSheet,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdUpdateReferencingSheet.cs,UpdateReferencingSheet,The following statement contains a magic number: if( TransactionStatus.Started          == transaction.Start( "Updating the model" ) )        {          //switch( disciplineNo )          //{          //  case 1:          //    discipline.Set( 2 );          //    break;          //  default:          //    discipline.Set( 1 );          //    break;          //}          //discipline.Set( disciplineNo );            discipline.Set( 1 == disciplineNo ? 2 : 1 );          transaction.Commit();        }
Magic Number,BuildingCoder,CmdAlignTwoViews,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdViewsShowingElements.cs,Execute,The following statement contains a magic number: using( Transaction trans = new Transaction( doc ) )        {          trans.Start( "Place views" );            View frontView = doc.GetElement( new ElementId( 180041 ) ) as View;          View leftView = doc.GetElement( new ElementId( 180032 ) ) as View;            AssemblyInstance assemblyInst = doc.GetElement( new ElementId( 179915 ) ) as AssemblyInstance;            ViewSheet vSheet = doc.GetElement( new ElementId( 180049 ) ) as ViewSheet;            // Assume that the scale is the same for both views            int scale = frontView.Scale;          leftView.Scale = scale;            // Save current crop box values            BoundingBoxXYZ savedBoxFront = null' savedBoxLeft = null;          bool frontCropActive' frontCropVisible' leftCropActive' leftCropVisible;          double farClipFront = 0' farClipLeft = 0;          Parameter param;          Transform transformFront = frontView.CropBox.Transform;          Transform transformLeft = leftView.CropBox.Transform;            // Save old values. I have to store the farclip and reset it later            savedBoxFront = frontView.CropBox;          frontCropActive = frontView.CropBoxActive;          frontCropVisible = frontView.CropBoxVisible;          param = frontView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipFront = param.AsDouble();          }          savedBoxLeft = leftView.CropBox;          leftCropActive = leftView.CropBoxActive;          leftCropVisible = leftView.CropBoxVisible;          param = leftView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipLeft = param.AsDouble();          }            // Here my approach differs from yours.           // I'm starting from the old bounding box to           // ensure that I get the correct transformation.          // I tried to create a new Transformation but           // this didn't work.            BoundingBoxXYZ newBoxFront = frontView.CropBox;          newBoxFront.set_MinEnabled( 0' true );          newBoxFront.set_MinEnabled( 1' true );          newBoxFront.set_MinEnabled( 2' true );          newBoxFront.Min = new XYZ( -2000' -2000' 0 );          newBoxFront.set_MaxEnabled( 0' true );          newBoxFront.set_MaxEnabled( 1' true );          newBoxFront.set_MaxEnabled( 2' true );          newBoxFront.Max = new XYZ( 2000' 2000' 0 );            BoundingBoxXYZ newBoxLeft = leftView.CropBox;          newBoxLeft.set_MinEnabled( 0' true );          newBoxLeft.set_MinEnabled( 1' true );          newBoxLeft.set_MinEnabled( 2' true );          newBoxLeft.Min = new XYZ( -2000' -2000' 0 );          newBoxLeft.set_MaxEnabled( 0' true );          newBoxLeft.set_MaxEnabled( 1' true );          newBoxLeft.set_MaxEnabled( 2' true );          newBoxLeft.Max = new XYZ( 2000' 2000' 0 );            frontView.CropBox = newBoxFront;          leftView.CropBox = newBoxLeft;          doc.Regenerate();          frontView.CropBoxActive = true;          leftView.CropBoxActive = true;            doc.Regenerate();            ElementId vid = vSheet.Id;          XYZ p = XYZ.Zero;            var vpFront = Viewport.Create( doc' vid' frontView.Id' p );          var vpLeft = Viewport.Create( doc' vid' leftView.Id' p );            doc.Regenerate();            // Align lower left - works           // because crop boxes are same            Outline outline1 = vpFront.GetBoxOutline();          Outline outline2 = vpLeft.GetBoxOutline();          XYZ min1 = outline1.MinimumPoint;          XYZ min2 = outline2.MinimumPoint;          XYZ diffToMove = min1 - min2;          ElementTransformUtils.MoveElement( doc' vpLeft.Id' diffToMove );            // Tranform the view such that the origin           // of the assemblyInstance for each view is           // on the middle of the sheet          // 1) Move the views such that the assembly          // Origin lies on the same on the origin of sheet            p = assemblyInst.GetTransform().Origin;            XYZ v = transformFront.Origin - p;            XYZ translation = new XYZ(            v.DotProduct( transformFront.BasisX )'            v.DotProduct( transformFront.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpFront.Id' translation );            v = transformLeft.Origin - p;            translation = new XYZ(            v.DotProduct( transformLeft.BasisX )'            v.DotProduct( transformLeft.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            // 2) Move the views such that the assembly           // origin lies on the center of the sheet            double width = 840 * 0.0032808399;          double height = 594 * 0.0032808399;            XYZ sheetMidpoint = ( vSheet.Origin + XYZ.BasisX * width + XYZ.BasisY * height ) / 2.0;          ElementTransformUtils.MoveElement( doc' vpFront.Id' sheetMidpoint );          ElementTransformUtils.MoveElement( doc' vpLeft.Id' sheetMidpoint );            // Once the views are on the middle' move the           // left view to the left of the front view:          // Do the correct translations to suit the           // defined layout            translation = XYZ.BasisX * (            -( ( outline1.MinimumPoint.X - outline1.MinimumPoint.X )            / 2 + ( outline2.MinimumPoint.X - outline2.MinimumPoint.X ) + 1 ) );            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            doc.Regenerate();            // Restore view crop boxes            frontView.CropBox = savedBoxFront;          frontView.CropBoxActive = frontCropActive;          frontView.CropBoxVisible = frontCropVisible;            param = frontView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipFront );          }            leftView.CropBox = savedBoxLeft;          leftView.CropBoxActive = leftCropActive;          leftView.CropBoxVisible = leftCropVisible;            param = leftView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipLeft );          }            trans.Commit();        }
Magic Number,BuildingCoder,CmdAlignTwoViews,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdViewsShowingElements.cs,Execute,The following statement contains a magic number: using( Transaction trans = new Transaction( doc ) )        {          trans.Start( "Place views" );            View frontView = doc.GetElement( new ElementId( 180041 ) ) as View;          View leftView = doc.GetElement( new ElementId( 180032 ) ) as View;            AssemblyInstance assemblyInst = doc.GetElement( new ElementId( 179915 ) ) as AssemblyInstance;            ViewSheet vSheet = doc.GetElement( new ElementId( 180049 ) ) as ViewSheet;            // Assume that the scale is the same for both views            int scale = frontView.Scale;          leftView.Scale = scale;            // Save current crop box values            BoundingBoxXYZ savedBoxFront = null' savedBoxLeft = null;          bool frontCropActive' frontCropVisible' leftCropActive' leftCropVisible;          double farClipFront = 0' farClipLeft = 0;          Parameter param;          Transform transformFront = frontView.CropBox.Transform;          Transform transformLeft = leftView.CropBox.Transform;            // Save old values. I have to store the farclip and reset it later            savedBoxFront = frontView.CropBox;          frontCropActive = frontView.CropBoxActive;          frontCropVisible = frontView.CropBoxVisible;          param = frontView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipFront = param.AsDouble();          }          savedBoxLeft = leftView.CropBox;          leftCropActive = leftView.CropBoxActive;          leftCropVisible = leftView.CropBoxVisible;          param = leftView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipLeft = param.AsDouble();          }            // Here my approach differs from yours.           // I'm starting from the old bounding box to           // ensure that I get the correct transformation.          // I tried to create a new Transformation but           // this didn't work.            BoundingBoxXYZ newBoxFront = frontView.CropBox;          newBoxFront.set_MinEnabled( 0' true );          newBoxFront.set_MinEnabled( 1' true );          newBoxFront.set_MinEnabled( 2' true );          newBoxFront.Min = new XYZ( -2000' -2000' 0 );          newBoxFront.set_MaxEnabled( 0' true );          newBoxFront.set_MaxEnabled( 1' true );          newBoxFront.set_MaxEnabled( 2' true );          newBoxFront.Max = new XYZ( 2000' 2000' 0 );            BoundingBoxXYZ newBoxLeft = leftView.CropBox;          newBoxLeft.set_MinEnabled( 0' true );          newBoxLeft.set_MinEnabled( 1' true );          newBoxLeft.set_MinEnabled( 2' true );          newBoxLeft.Min = new XYZ( -2000' -2000' 0 );          newBoxLeft.set_MaxEnabled( 0' true );          newBoxLeft.set_MaxEnabled( 1' true );          newBoxLeft.set_MaxEnabled( 2' true );          newBoxLeft.Max = new XYZ( 2000' 2000' 0 );            frontView.CropBox = newBoxFront;          leftView.CropBox = newBoxLeft;          doc.Regenerate();          frontView.CropBoxActive = true;          leftView.CropBoxActive = true;            doc.Regenerate();            ElementId vid = vSheet.Id;          XYZ p = XYZ.Zero;            var vpFront = Viewport.Create( doc' vid' frontView.Id' p );          var vpLeft = Viewport.Create( doc' vid' leftView.Id' p );            doc.Regenerate();            // Align lower left - works           // because crop boxes are same            Outline outline1 = vpFront.GetBoxOutline();          Outline outline2 = vpLeft.GetBoxOutline();          XYZ min1 = outline1.MinimumPoint;          XYZ min2 = outline2.MinimumPoint;          XYZ diffToMove = min1 - min2;          ElementTransformUtils.MoveElement( doc' vpLeft.Id' diffToMove );            // Tranform the view such that the origin           // of the assemblyInstance for each view is           // on the middle of the sheet          // 1) Move the views such that the assembly          // Origin lies on the same on the origin of sheet            p = assemblyInst.GetTransform().Origin;            XYZ v = transformFront.Origin - p;            XYZ translation = new XYZ(            v.DotProduct( transformFront.BasisX )'            v.DotProduct( transformFront.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpFront.Id' translation );            v = transformLeft.Origin - p;            translation = new XYZ(            v.DotProduct( transformLeft.BasisX )'            v.DotProduct( transformLeft.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            // 2) Move the views such that the assembly           // origin lies on the center of the sheet            double width = 840 * 0.0032808399;          double height = 594 * 0.0032808399;            XYZ sheetMidpoint = ( vSheet.Origin + XYZ.BasisX * width + XYZ.BasisY * height ) / 2.0;          ElementTransformUtils.MoveElement( doc' vpFront.Id' sheetMidpoint );          ElementTransformUtils.MoveElement( doc' vpLeft.Id' sheetMidpoint );            // Once the views are on the middle' move the           // left view to the left of the front view:          // Do the correct translations to suit the           // defined layout            translation = XYZ.BasisX * (            -( ( outline1.MinimumPoint.X - outline1.MinimumPoint.X )            / 2 + ( outline2.MinimumPoint.X - outline2.MinimumPoint.X ) + 1 ) );            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            doc.Regenerate();            // Restore view crop boxes            frontView.CropBox = savedBoxFront;          frontView.CropBoxActive = frontCropActive;          frontView.CropBoxVisible = frontCropVisible;            param = frontView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipFront );          }            leftView.CropBox = savedBoxLeft;          leftView.CropBoxActive = leftCropActive;          leftView.CropBoxVisible = leftCropVisible;            param = leftView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipLeft );          }            trans.Commit();        }
Magic Number,BuildingCoder,CmdAlignTwoViews,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdViewsShowingElements.cs,Execute,The following statement contains a magic number: using( Transaction trans = new Transaction( doc ) )        {          trans.Start( "Place views" );            View frontView = doc.GetElement( new ElementId( 180041 ) ) as View;          View leftView = doc.GetElement( new ElementId( 180032 ) ) as View;            AssemblyInstance assemblyInst = doc.GetElement( new ElementId( 179915 ) ) as AssemblyInstance;            ViewSheet vSheet = doc.GetElement( new ElementId( 180049 ) ) as ViewSheet;            // Assume that the scale is the same for both views            int scale = frontView.Scale;          leftView.Scale = scale;            // Save current crop box values            BoundingBoxXYZ savedBoxFront = null' savedBoxLeft = null;          bool frontCropActive' frontCropVisible' leftCropActive' leftCropVisible;          double farClipFront = 0' farClipLeft = 0;          Parameter param;          Transform transformFront = frontView.CropBox.Transform;          Transform transformLeft = leftView.CropBox.Transform;            // Save old values. I have to store the farclip and reset it later            savedBoxFront = frontView.CropBox;          frontCropActive = frontView.CropBoxActive;          frontCropVisible = frontView.CropBoxVisible;          param = frontView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipFront = param.AsDouble();          }          savedBoxLeft = leftView.CropBox;          leftCropActive = leftView.CropBoxActive;          leftCropVisible = leftView.CropBoxVisible;          param = leftView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipLeft = param.AsDouble();          }            // Here my approach differs from yours.           // I'm starting from the old bounding box to           // ensure that I get the correct transformation.          // I tried to create a new Transformation but           // this didn't work.            BoundingBoxXYZ newBoxFront = frontView.CropBox;          newBoxFront.set_MinEnabled( 0' true );          newBoxFront.set_MinEnabled( 1' true );          newBoxFront.set_MinEnabled( 2' true );          newBoxFront.Min = new XYZ( -2000' -2000' 0 );          newBoxFront.set_MaxEnabled( 0' true );          newBoxFront.set_MaxEnabled( 1' true );          newBoxFront.set_MaxEnabled( 2' true );          newBoxFront.Max = new XYZ( 2000' 2000' 0 );            BoundingBoxXYZ newBoxLeft = leftView.CropBox;          newBoxLeft.set_MinEnabled( 0' true );          newBoxLeft.set_MinEnabled( 1' true );          newBoxLeft.set_MinEnabled( 2' true );          newBoxLeft.Min = new XYZ( -2000' -2000' 0 );          newBoxLeft.set_MaxEnabled( 0' true );          newBoxLeft.set_MaxEnabled( 1' true );          newBoxLeft.set_MaxEnabled( 2' true );          newBoxLeft.Max = new XYZ( 2000' 2000' 0 );            frontView.CropBox = newBoxFront;          leftView.CropBox = newBoxLeft;          doc.Regenerate();          frontView.CropBoxActive = true;          leftView.CropBoxActive = true;            doc.Regenerate();            ElementId vid = vSheet.Id;          XYZ p = XYZ.Zero;            var vpFront = Viewport.Create( doc' vid' frontView.Id' p );          var vpLeft = Viewport.Create( doc' vid' leftView.Id' p );            doc.Regenerate();            // Align lower left - works           // because crop boxes are same            Outline outline1 = vpFront.GetBoxOutline();          Outline outline2 = vpLeft.GetBoxOutline();          XYZ min1 = outline1.MinimumPoint;          XYZ min2 = outline2.MinimumPoint;          XYZ diffToMove = min1 - min2;          ElementTransformUtils.MoveElement( doc' vpLeft.Id' diffToMove );            // Tranform the view such that the origin           // of the assemblyInstance for each view is           // on the middle of the sheet          // 1) Move the views such that the assembly          // Origin lies on the same on the origin of sheet            p = assemblyInst.GetTransform().Origin;            XYZ v = transformFront.Origin - p;            XYZ translation = new XYZ(            v.DotProduct( transformFront.BasisX )'            v.DotProduct( transformFront.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpFront.Id' translation );            v = transformLeft.Origin - p;            translation = new XYZ(            v.DotProduct( transformLeft.BasisX )'            v.DotProduct( transformLeft.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            // 2) Move the views such that the assembly           // origin lies on the center of the sheet            double width = 840 * 0.0032808399;          double height = 594 * 0.0032808399;            XYZ sheetMidpoint = ( vSheet.Origin + XYZ.BasisX * width + XYZ.BasisY * height ) / 2.0;          ElementTransformUtils.MoveElement( doc' vpFront.Id' sheetMidpoint );          ElementTransformUtils.MoveElement( doc' vpLeft.Id' sheetMidpoint );            // Once the views are on the middle' move the           // left view to the left of the front view:          // Do the correct translations to suit the           // defined layout            translation = XYZ.BasisX * (            -( ( outline1.MinimumPoint.X - outline1.MinimumPoint.X )            / 2 + ( outline2.MinimumPoint.X - outline2.MinimumPoint.X ) + 1 ) );            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            doc.Regenerate();            // Restore view crop boxes            frontView.CropBox = savedBoxFront;          frontView.CropBoxActive = frontCropActive;          frontView.CropBoxVisible = frontCropVisible;            param = frontView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipFront );          }            leftView.CropBox = savedBoxLeft;          leftView.CropBoxActive = leftCropActive;          leftView.CropBoxVisible = leftCropVisible;            param = leftView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipLeft );          }            trans.Commit();        }
Magic Number,BuildingCoder,CmdAlignTwoViews,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdViewsShowingElements.cs,Execute,The following statement contains a magic number: using( Transaction trans = new Transaction( doc ) )        {          trans.Start( "Place views" );            View frontView = doc.GetElement( new ElementId( 180041 ) ) as View;          View leftView = doc.GetElement( new ElementId( 180032 ) ) as View;            AssemblyInstance assemblyInst = doc.GetElement( new ElementId( 179915 ) ) as AssemblyInstance;            ViewSheet vSheet = doc.GetElement( new ElementId( 180049 ) ) as ViewSheet;            // Assume that the scale is the same for both views            int scale = frontView.Scale;          leftView.Scale = scale;            // Save current crop box values            BoundingBoxXYZ savedBoxFront = null' savedBoxLeft = null;          bool frontCropActive' frontCropVisible' leftCropActive' leftCropVisible;          double farClipFront = 0' farClipLeft = 0;          Parameter param;          Transform transformFront = frontView.CropBox.Transform;          Transform transformLeft = leftView.CropBox.Transform;            // Save old values. I have to store the farclip and reset it later            savedBoxFront = frontView.CropBox;          frontCropActive = frontView.CropBoxActive;          frontCropVisible = frontView.CropBoxVisible;          param = frontView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipFront = param.AsDouble();          }          savedBoxLeft = leftView.CropBox;          leftCropActive = leftView.CropBoxActive;          leftCropVisible = leftView.CropBoxVisible;          param = leftView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipLeft = param.AsDouble();          }            // Here my approach differs from yours.           // I'm starting from the old bounding box to           // ensure that I get the correct transformation.          // I tried to create a new Transformation but           // this didn't work.            BoundingBoxXYZ newBoxFront = frontView.CropBox;          newBoxFront.set_MinEnabled( 0' true );          newBoxFront.set_MinEnabled( 1' true );          newBoxFront.set_MinEnabled( 2' true );          newBoxFront.Min = new XYZ( -2000' -2000' 0 );          newBoxFront.set_MaxEnabled( 0' true );          newBoxFront.set_MaxEnabled( 1' true );          newBoxFront.set_MaxEnabled( 2' true );          newBoxFront.Max = new XYZ( 2000' 2000' 0 );            BoundingBoxXYZ newBoxLeft = leftView.CropBox;          newBoxLeft.set_MinEnabled( 0' true );          newBoxLeft.set_MinEnabled( 1' true );          newBoxLeft.set_MinEnabled( 2' true );          newBoxLeft.Min = new XYZ( -2000' -2000' 0 );          newBoxLeft.set_MaxEnabled( 0' true );          newBoxLeft.set_MaxEnabled( 1' true );          newBoxLeft.set_MaxEnabled( 2' true );          newBoxLeft.Max = new XYZ( 2000' 2000' 0 );            frontView.CropBox = newBoxFront;          leftView.CropBox = newBoxLeft;          doc.Regenerate();          frontView.CropBoxActive = true;          leftView.CropBoxActive = true;            doc.Regenerate();            ElementId vid = vSheet.Id;          XYZ p = XYZ.Zero;            var vpFront = Viewport.Create( doc' vid' frontView.Id' p );          var vpLeft = Viewport.Create( doc' vid' leftView.Id' p );            doc.Regenerate();            // Align lower left - works           // because crop boxes are same            Outline outline1 = vpFront.GetBoxOutline();          Outline outline2 = vpLeft.GetBoxOutline();          XYZ min1 = outline1.MinimumPoint;          XYZ min2 = outline2.MinimumPoint;          XYZ diffToMove = min1 - min2;          ElementTransformUtils.MoveElement( doc' vpLeft.Id' diffToMove );            // Tranform the view such that the origin           // of the assemblyInstance for each view is           // on the middle of the sheet          // 1) Move the views such that the assembly          // Origin lies on the same on the origin of sheet            p = assemblyInst.GetTransform().Origin;            XYZ v = transformFront.Origin - p;            XYZ translation = new XYZ(            v.DotProduct( transformFront.BasisX )'            v.DotProduct( transformFront.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpFront.Id' translation );            v = transformLeft.Origin - p;            translation = new XYZ(            v.DotProduct( transformLeft.BasisX )'            v.DotProduct( transformLeft.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            // 2) Move the views such that the assembly           // origin lies on the center of the sheet            double width = 840 * 0.0032808399;          double height = 594 * 0.0032808399;            XYZ sheetMidpoint = ( vSheet.Origin + XYZ.BasisX * width + XYZ.BasisY * height ) / 2.0;          ElementTransformUtils.MoveElement( doc' vpFront.Id' sheetMidpoint );          ElementTransformUtils.MoveElement( doc' vpLeft.Id' sheetMidpoint );            // Once the views are on the middle' move the           // left view to the left of the front view:          // Do the correct translations to suit the           // defined layout            translation = XYZ.BasisX * (            -( ( outline1.MinimumPoint.X - outline1.MinimumPoint.X )            / 2 + ( outline2.MinimumPoint.X - outline2.MinimumPoint.X ) + 1 ) );            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            doc.Regenerate();            // Restore view crop boxes            frontView.CropBox = savedBoxFront;          frontView.CropBoxActive = frontCropActive;          frontView.CropBoxVisible = frontCropVisible;            param = frontView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipFront );          }            leftView.CropBox = savedBoxLeft;          leftView.CropBoxActive = leftCropActive;          leftView.CropBoxVisible = leftCropVisible;            param = leftView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipLeft );          }            trans.Commit();        }
Magic Number,BuildingCoder,CmdAlignTwoViews,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdViewsShowingElements.cs,Execute,The following statement contains a magic number: using( Transaction trans = new Transaction( doc ) )        {          trans.Start( "Place views" );            View frontView = doc.GetElement( new ElementId( 180041 ) ) as View;          View leftView = doc.GetElement( new ElementId( 180032 ) ) as View;            AssemblyInstance assemblyInst = doc.GetElement( new ElementId( 179915 ) ) as AssemblyInstance;            ViewSheet vSheet = doc.GetElement( new ElementId( 180049 ) ) as ViewSheet;            // Assume that the scale is the same for both views            int scale = frontView.Scale;          leftView.Scale = scale;            // Save current crop box values            BoundingBoxXYZ savedBoxFront = null' savedBoxLeft = null;          bool frontCropActive' frontCropVisible' leftCropActive' leftCropVisible;          double farClipFront = 0' farClipLeft = 0;          Parameter param;          Transform transformFront = frontView.CropBox.Transform;          Transform transformLeft = leftView.CropBox.Transform;            // Save old values. I have to store the farclip and reset it later            savedBoxFront = frontView.CropBox;          frontCropActive = frontView.CropBoxActive;          frontCropVisible = frontView.CropBoxVisible;          param = frontView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipFront = param.AsDouble();          }          savedBoxLeft = leftView.CropBox;          leftCropActive = leftView.CropBoxActive;          leftCropVisible = leftView.CropBoxVisible;          param = leftView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipLeft = param.AsDouble();          }            // Here my approach differs from yours.           // I'm starting from the old bounding box to           // ensure that I get the correct transformation.          // I tried to create a new Transformation but           // this didn't work.            BoundingBoxXYZ newBoxFront = frontView.CropBox;          newBoxFront.set_MinEnabled( 0' true );          newBoxFront.set_MinEnabled( 1' true );          newBoxFront.set_MinEnabled( 2' true );          newBoxFront.Min = new XYZ( -2000' -2000' 0 );          newBoxFront.set_MaxEnabled( 0' true );          newBoxFront.set_MaxEnabled( 1' true );          newBoxFront.set_MaxEnabled( 2' true );          newBoxFront.Max = new XYZ( 2000' 2000' 0 );            BoundingBoxXYZ newBoxLeft = leftView.CropBox;          newBoxLeft.set_MinEnabled( 0' true );          newBoxLeft.set_MinEnabled( 1' true );          newBoxLeft.set_MinEnabled( 2' true );          newBoxLeft.Min = new XYZ( -2000' -2000' 0 );          newBoxLeft.set_MaxEnabled( 0' true );          newBoxLeft.set_MaxEnabled( 1' true );          newBoxLeft.set_MaxEnabled( 2' true );          newBoxLeft.Max = new XYZ( 2000' 2000' 0 );            frontView.CropBox = newBoxFront;          leftView.CropBox = newBoxLeft;          doc.Regenerate();          frontView.CropBoxActive = true;          leftView.CropBoxActive = true;            doc.Regenerate();            ElementId vid = vSheet.Id;          XYZ p = XYZ.Zero;            var vpFront = Viewport.Create( doc' vid' frontView.Id' p );          var vpLeft = Viewport.Create( doc' vid' leftView.Id' p );            doc.Regenerate();            // Align lower left - works           // because crop boxes are same            Outline outline1 = vpFront.GetBoxOutline();          Outline outline2 = vpLeft.GetBoxOutline();          XYZ min1 = outline1.MinimumPoint;          XYZ min2 = outline2.MinimumPoint;          XYZ diffToMove = min1 - min2;          ElementTransformUtils.MoveElement( doc' vpLeft.Id' diffToMove );            // Tranform the view such that the origin           // of the assemblyInstance for each view is           // on the middle of the sheet          // 1) Move the views such that the assembly          // Origin lies on the same on the origin of sheet            p = assemblyInst.GetTransform().Origin;            XYZ v = transformFront.Origin - p;            XYZ translation = new XYZ(            v.DotProduct( transformFront.BasisX )'            v.DotProduct( transformFront.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpFront.Id' translation );            v = transformLeft.Origin - p;            translation = new XYZ(            v.DotProduct( transformLeft.BasisX )'            v.DotProduct( transformLeft.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            // 2) Move the views such that the assembly           // origin lies on the center of the sheet            double width = 840 * 0.0032808399;          double height = 594 * 0.0032808399;            XYZ sheetMidpoint = ( vSheet.Origin + XYZ.BasisX * width + XYZ.BasisY * height ) / 2.0;          ElementTransformUtils.MoveElement( doc' vpFront.Id' sheetMidpoint );          ElementTransformUtils.MoveElement( doc' vpLeft.Id' sheetMidpoint );            // Once the views are on the middle' move the           // left view to the left of the front view:          // Do the correct translations to suit the           // defined layout            translation = XYZ.BasisX * (            -( ( outline1.MinimumPoint.X - outline1.MinimumPoint.X )            / 2 + ( outline2.MinimumPoint.X - outline2.MinimumPoint.X ) + 1 ) );            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            doc.Regenerate();            // Restore view crop boxes            frontView.CropBox = savedBoxFront;          frontView.CropBoxActive = frontCropActive;          frontView.CropBoxVisible = frontCropVisible;            param = frontView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipFront );          }            leftView.CropBox = savedBoxLeft;          leftView.CropBoxActive = leftCropActive;          leftView.CropBoxVisible = leftCropVisible;            param = leftView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipLeft );          }            trans.Commit();        }
Magic Number,BuildingCoder,CmdAlignTwoViews,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdViewsShowingElements.cs,Execute,The following statement contains a magic number: using( Transaction trans = new Transaction( doc ) )        {          trans.Start( "Place views" );            View frontView = doc.GetElement( new ElementId( 180041 ) ) as View;          View leftView = doc.GetElement( new ElementId( 180032 ) ) as View;            AssemblyInstance assemblyInst = doc.GetElement( new ElementId( 179915 ) ) as AssemblyInstance;            ViewSheet vSheet = doc.GetElement( new ElementId( 180049 ) ) as ViewSheet;            // Assume that the scale is the same for both views            int scale = frontView.Scale;          leftView.Scale = scale;            // Save current crop box values            BoundingBoxXYZ savedBoxFront = null' savedBoxLeft = null;          bool frontCropActive' frontCropVisible' leftCropActive' leftCropVisible;          double farClipFront = 0' farClipLeft = 0;          Parameter param;          Transform transformFront = frontView.CropBox.Transform;          Transform transformLeft = leftView.CropBox.Transform;            // Save old values. I have to store the farclip and reset it later            savedBoxFront = frontView.CropBox;          frontCropActive = frontView.CropBoxActive;          frontCropVisible = frontView.CropBoxVisible;          param = frontView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipFront = param.AsDouble();          }          savedBoxLeft = leftView.CropBox;          leftCropActive = leftView.CropBoxActive;          leftCropVisible = leftView.CropBoxVisible;          param = leftView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipLeft = param.AsDouble();          }            // Here my approach differs from yours.           // I'm starting from the old bounding box to           // ensure that I get the correct transformation.          // I tried to create a new Transformation but           // this didn't work.            BoundingBoxXYZ newBoxFront = frontView.CropBox;          newBoxFront.set_MinEnabled( 0' true );          newBoxFront.set_MinEnabled( 1' true );          newBoxFront.set_MinEnabled( 2' true );          newBoxFront.Min = new XYZ( -2000' -2000' 0 );          newBoxFront.set_MaxEnabled( 0' true );          newBoxFront.set_MaxEnabled( 1' true );          newBoxFront.set_MaxEnabled( 2' true );          newBoxFront.Max = new XYZ( 2000' 2000' 0 );            BoundingBoxXYZ newBoxLeft = leftView.CropBox;          newBoxLeft.set_MinEnabled( 0' true );          newBoxLeft.set_MinEnabled( 1' true );          newBoxLeft.set_MinEnabled( 2' true );          newBoxLeft.Min = new XYZ( -2000' -2000' 0 );          newBoxLeft.set_MaxEnabled( 0' true );          newBoxLeft.set_MaxEnabled( 1' true );          newBoxLeft.set_MaxEnabled( 2' true );          newBoxLeft.Max = new XYZ( 2000' 2000' 0 );            frontView.CropBox = newBoxFront;          leftView.CropBox = newBoxLeft;          doc.Regenerate();          frontView.CropBoxActive = true;          leftView.CropBoxActive = true;            doc.Regenerate();            ElementId vid = vSheet.Id;          XYZ p = XYZ.Zero;            var vpFront = Viewport.Create( doc' vid' frontView.Id' p );          var vpLeft = Viewport.Create( doc' vid' leftView.Id' p );            doc.Regenerate();            // Align lower left - works           // because crop boxes are same            Outline outline1 = vpFront.GetBoxOutline();          Outline outline2 = vpLeft.GetBoxOutline();          XYZ min1 = outline1.MinimumPoint;          XYZ min2 = outline2.MinimumPoint;          XYZ diffToMove = min1 - min2;          ElementTransformUtils.MoveElement( doc' vpLeft.Id' diffToMove );            // Tranform the view such that the origin           // of the assemblyInstance for each view is           // on the middle of the sheet          // 1) Move the views such that the assembly          // Origin lies on the same on the origin of sheet            p = assemblyInst.GetTransform().Origin;            XYZ v = transformFront.Origin - p;            XYZ translation = new XYZ(            v.DotProduct( transformFront.BasisX )'            v.DotProduct( transformFront.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpFront.Id' translation );            v = transformLeft.Origin - p;            translation = new XYZ(            v.DotProduct( transformLeft.BasisX )'            v.DotProduct( transformLeft.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            // 2) Move the views such that the assembly           // origin lies on the center of the sheet            double width = 840 * 0.0032808399;          double height = 594 * 0.0032808399;            XYZ sheetMidpoint = ( vSheet.Origin + XYZ.BasisX * width + XYZ.BasisY * height ) / 2.0;          ElementTransformUtils.MoveElement( doc' vpFront.Id' sheetMidpoint );          ElementTransformUtils.MoveElement( doc' vpLeft.Id' sheetMidpoint );            // Once the views are on the middle' move the           // left view to the left of the front view:          // Do the correct translations to suit the           // defined layout            translation = XYZ.BasisX * (            -( ( outline1.MinimumPoint.X - outline1.MinimumPoint.X )            / 2 + ( outline2.MinimumPoint.X - outline2.MinimumPoint.X ) + 1 ) );            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            doc.Regenerate();            // Restore view crop boxes            frontView.CropBox = savedBoxFront;          frontView.CropBoxActive = frontCropActive;          frontView.CropBoxVisible = frontCropVisible;            param = frontView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipFront );          }            leftView.CropBox = savedBoxLeft;          leftView.CropBoxActive = leftCropActive;          leftView.CropBoxVisible = leftCropVisible;            param = leftView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipLeft );          }            trans.Commit();        }
Magic Number,BuildingCoder,CmdAlignTwoViews,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdViewsShowingElements.cs,Execute,The following statement contains a magic number: using( Transaction trans = new Transaction( doc ) )        {          trans.Start( "Place views" );            View frontView = doc.GetElement( new ElementId( 180041 ) ) as View;          View leftView = doc.GetElement( new ElementId( 180032 ) ) as View;            AssemblyInstance assemblyInst = doc.GetElement( new ElementId( 179915 ) ) as AssemblyInstance;            ViewSheet vSheet = doc.GetElement( new ElementId( 180049 ) ) as ViewSheet;            // Assume that the scale is the same for both views            int scale = frontView.Scale;          leftView.Scale = scale;            // Save current crop box values            BoundingBoxXYZ savedBoxFront = null' savedBoxLeft = null;          bool frontCropActive' frontCropVisible' leftCropActive' leftCropVisible;          double farClipFront = 0' farClipLeft = 0;          Parameter param;          Transform transformFront = frontView.CropBox.Transform;          Transform transformLeft = leftView.CropBox.Transform;            // Save old values. I have to store the farclip and reset it later            savedBoxFront = frontView.CropBox;          frontCropActive = frontView.CropBoxActive;          frontCropVisible = frontView.CropBoxVisible;          param = frontView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipFront = param.AsDouble();          }          savedBoxLeft = leftView.CropBox;          leftCropActive = leftView.CropBoxActive;          leftCropVisible = leftView.CropBoxVisible;          param = leftView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipLeft = param.AsDouble();          }            // Here my approach differs from yours.           // I'm starting from the old bounding box to           // ensure that I get the correct transformation.          // I tried to create a new Transformation but           // this didn't work.            BoundingBoxXYZ newBoxFront = frontView.CropBox;          newBoxFront.set_MinEnabled( 0' true );          newBoxFront.set_MinEnabled( 1' true );          newBoxFront.set_MinEnabled( 2' true );          newBoxFront.Min = new XYZ( -2000' -2000' 0 );          newBoxFront.set_MaxEnabled( 0' true );          newBoxFront.set_MaxEnabled( 1' true );          newBoxFront.set_MaxEnabled( 2' true );          newBoxFront.Max = new XYZ( 2000' 2000' 0 );            BoundingBoxXYZ newBoxLeft = leftView.CropBox;          newBoxLeft.set_MinEnabled( 0' true );          newBoxLeft.set_MinEnabled( 1' true );          newBoxLeft.set_MinEnabled( 2' true );          newBoxLeft.Min = new XYZ( -2000' -2000' 0 );          newBoxLeft.set_MaxEnabled( 0' true );          newBoxLeft.set_MaxEnabled( 1' true );          newBoxLeft.set_MaxEnabled( 2' true );          newBoxLeft.Max = new XYZ( 2000' 2000' 0 );            frontView.CropBox = newBoxFront;          leftView.CropBox = newBoxLeft;          doc.Regenerate();          frontView.CropBoxActive = true;          leftView.CropBoxActive = true;            doc.Regenerate();            ElementId vid = vSheet.Id;          XYZ p = XYZ.Zero;            var vpFront = Viewport.Create( doc' vid' frontView.Id' p );          var vpLeft = Viewport.Create( doc' vid' leftView.Id' p );            doc.Regenerate();            // Align lower left - works           // because crop boxes are same            Outline outline1 = vpFront.GetBoxOutline();          Outline outline2 = vpLeft.GetBoxOutline();          XYZ min1 = outline1.MinimumPoint;          XYZ min2 = outline2.MinimumPoint;          XYZ diffToMove = min1 - min2;          ElementTransformUtils.MoveElement( doc' vpLeft.Id' diffToMove );            // Tranform the view such that the origin           // of the assemblyInstance for each view is           // on the middle of the sheet          // 1) Move the views such that the assembly          // Origin lies on the same on the origin of sheet            p = assemblyInst.GetTransform().Origin;            XYZ v = transformFront.Origin - p;            XYZ translation = new XYZ(            v.DotProduct( transformFront.BasisX )'            v.DotProduct( transformFront.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpFront.Id' translation );            v = transformLeft.Origin - p;            translation = new XYZ(            v.DotProduct( transformLeft.BasisX )'            v.DotProduct( transformLeft.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            // 2) Move the views such that the assembly           // origin lies on the center of the sheet            double width = 840 * 0.0032808399;          double height = 594 * 0.0032808399;            XYZ sheetMidpoint = ( vSheet.Origin + XYZ.BasisX * width + XYZ.BasisY * height ) / 2.0;          ElementTransformUtils.MoveElement( doc' vpFront.Id' sheetMidpoint );          ElementTransformUtils.MoveElement( doc' vpLeft.Id' sheetMidpoint );            // Once the views are on the middle' move the           // left view to the left of the front view:          // Do the correct translations to suit the           // defined layout            translation = XYZ.BasisX * (            -( ( outline1.MinimumPoint.X - outline1.MinimumPoint.X )            / 2 + ( outline2.MinimumPoint.X - outline2.MinimumPoint.X ) + 1 ) );            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            doc.Regenerate();            // Restore view crop boxes            frontView.CropBox = savedBoxFront;          frontView.CropBoxActive = frontCropActive;          frontView.CropBoxVisible = frontCropVisible;            param = frontView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipFront );          }            leftView.CropBox = savedBoxLeft;          leftView.CropBoxActive = leftCropActive;          leftView.CropBoxVisible = leftCropVisible;            param = leftView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipLeft );          }            trans.Commit();        }
Magic Number,BuildingCoder,CmdAlignTwoViews,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdViewsShowingElements.cs,Execute,The following statement contains a magic number: using( Transaction trans = new Transaction( doc ) )        {          trans.Start( "Place views" );            View frontView = doc.GetElement( new ElementId( 180041 ) ) as View;          View leftView = doc.GetElement( new ElementId( 180032 ) ) as View;            AssemblyInstance assemblyInst = doc.GetElement( new ElementId( 179915 ) ) as AssemblyInstance;            ViewSheet vSheet = doc.GetElement( new ElementId( 180049 ) ) as ViewSheet;            // Assume that the scale is the same for both views            int scale = frontView.Scale;          leftView.Scale = scale;            // Save current crop box values            BoundingBoxXYZ savedBoxFront = null' savedBoxLeft = null;          bool frontCropActive' frontCropVisible' leftCropActive' leftCropVisible;          double farClipFront = 0' farClipLeft = 0;          Parameter param;          Transform transformFront = frontView.CropBox.Transform;          Transform transformLeft = leftView.CropBox.Transform;            // Save old values. I have to store the farclip and reset it later            savedBoxFront = frontView.CropBox;          frontCropActive = frontView.CropBoxActive;          frontCropVisible = frontView.CropBoxVisible;          param = frontView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipFront = param.AsDouble();          }          savedBoxLeft = leftView.CropBox;          leftCropActive = leftView.CropBoxActive;          leftCropVisible = leftView.CropBoxVisible;          param = leftView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipLeft = param.AsDouble();          }            // Here my approach differs from yours.           // I'm starting from the old bounding box to           // ensure that I get the correct transformation.          // I tried to create a new Transformation but           // this didn't work.            BoundingBoxXYZ newBoxFront = frontView.CropBox;          newBoxFront.set_MinEnabled( 0' true );          newBoxFront.set_MinEnabled( 1' true );          newBoxFront.set_MinEnabled( 2' true );          newBoxFront.Min = new XYZ( -2000' -2000' 0 );          newBoxFront.set_MaxEnabled( 0' true );          newBoxFront.set_MaxEnabled( 1' true );          newBoxFront.set_MaxEnabled( 2' true );          newBoxFront.Max = new XYZ( 2000' 2000' 0 );            BoundingBoxXYZ newBoxLeft = leftView.CropBox;          newBoxLeft.set_MinEnabled( 0' true );          newBoxLeft.set_MinEnabled( 1' true );          newBoxLeft.set_MinEnabled( 2' true );          newBoxLeft.Min = new XYZ( -2000' -2000' 0 );          newBoxLeft.set_MaxEnabled( 0' true );          newBoxLeft.set_MaxEnabled( 1' true );          newBoxLeft.set_MaxEnabled( 2' true );          newBoxLeft.Max = new XYZ( 2000' 2000' 0 );            frontView.CropBox = newBoxFront;          leftView.CropBox = newBoxLeft;          doc.Regenerate();          frontView.CropBoxActive = true;          leftView.CropBoxActive = true;            doc.Regenerate();            ElementId vid = vSheet.Id;          XYZ p = XYZ.Zero;            var vpFront = Viewport.Create( doc' vid' frontView.Id' p );          var vpLeft = Viewport.Create( doc' vid' leftView.Id' p );            doc.Regenerate();            // Align lower left - works           // because crop boxes are same            Outline outline1 = vpFront.GetBoxOutline();          Outline outline2 = vpLeft.GetBoxOutline();          XYZ min1 = outline1.MinimumPoint;          XYZ min2 = outline2.MinimumPoint;          XYZ diffToMove = min1 - min2;          ElementTransformUtils.MoveElement( doc' vpLeft.Id' diffToMove );            // Tranform the view such that the origin           // of the assemblyInstance for each view is           // on the middle of the sheet          // 1) Move the views such that the assembly          // Origin lies on the same on the origin of sheet            p = assemblyInst.GetTransform().Origin;            XYZ v = transformFront.Origin - p;            XYZ translation = new XYZ(            v.DotProduct( transformFront.BasisX )'            v.DotProduct( transformFront.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpFront.Id' translation );            v = transformLeft.Origin - p;            translation = new XYZ(            v.DotProduct( transformLeft.BasisX )'            v.DotProduct( transformLeft.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            // 2) Move the views such that the assembly           // origin lies on the center of the sheet            double width = 840 * 0.0032808399;          double height = 594 * 0.0032808399;            XYZ sheetMidpoint = ( vSheet.Origin + XYZ.BasisX * width + XYZ.BasisY * height ) / 2.0;          ElementTransformUtils.MoveElement( doc' vpFront.Id' sheetMidpoint );          ElementTransformUtils.MoveElement( doc' vpLeft.Id' sheetMidpoint );            // Once the views are on the middle' move the           // left view to the left of the front view:          // Do the correct translations to suit the           // defined layout            translation = XYZ.BasisX * (            -( ( outline1.MinimumPoint.X - outline1.MinimumPoint.X )            / 2 + ( outline2.MinimumPoint.X - outline2.MinimumPoint.X ) + 1 ) );            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            doc.Regenerate();            // Restore view crop boxes            frontView.CropBox = savedBoxFront;          frontView.CropBoxActive = frontCropActive;          frontView.CropBoxVisible = frontCropVisible;            param = frontView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipFront );          }            leftView.CropBox = savedBoxLeft;          leftView.CropBoxActive = leftCropActive;          leftView.CropBoxVisible = leftCropVisible;            param = leftView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipLeft );          }            trans.Commit();        }
Magic Number,BuildingCoder,CmdAlignTwoViews,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdViewsShowingElements.cs,Execute,The following statement contains a magic number: using( Transaction trans = new Transaction( doc ) )        {          trans.Start( "Place views" );            View frontView = doc.GetElement( new ElementId( 180041 ) ) as View;          View leftView = doc.GetElement( new ElementId( 180032 ) ) as View;            AssemblyInstance assemblyInst = doc.GetElement( new ElementId( 179915 ) ) as AssemblyInstance;            ViewSheet vSheet = doc.GetElement( new ElementId( 180049 ) ) as ViewSheet;            // Assume that the scale is the same for both views            int scale = frontView.Scale;          leftView.Scale = scale;            // Save current crop box values            BoundingBoxXYZ savedBoxFront = null' savedBoxLeft = null;          bool frontCropActive' frontCropVisible' leftCropActive' leftCropVisible;          double farClipFront = 0' farClipLeft = 0;          Parameter param;          Transform transformFront = frontView.CropBox.Transform;          Transform transformLeft = leftView.CropBox.Transform;            // Save old values. I have to store the farclip and reset it later            savedBoxFront = frontView.CropBox;          frontCropActive = frontView.CropBoxActive;          frontCropVisible = frontView.CropBoxVisible;          param = frontView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipFront = param.AsDouble();          }          savedBoxLeft = leftView.CropBox;          leftCropActive = leftView.CropBoxActive;          leftCropVisible = leftView.CropBoxVisible;          param = leftView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipLeft = param.AsDouble();          }            // Here my approach differs from yours.           // I'm starting from the old bounding box to           // ensure that I get the correct transformation.          // I tried to create a new Transformation but           // this didn't work.            BoundingBoxXYZ newBoxFront = frontView.CropBox;          newBoxFront.set_MinEnabled( 0' true );          newBoxFront.set_MinEnabled( 1' true );          newBoxFront.set_MinEnabled( 2' true );          newBoxFront.Min = new XYZ( -2000' -2000' 0 );          newBoxFront.set_MaxEnabled( 0' true );          newBoxFront.set_MaxEnabled( 1' true );          newBoxFront.set_MaxEnabled( 2' true );          newBoxFront.Max = new XYZ( 2000' 2000' 0 );            BoundingBoxXYZ newBoxLeft = leftView.CropBox;          newBoxLeft.set_MinEnabled( 0' true );          newBoxLeft.set_MinEnabled( 1' true );          newBoxLeft.set_MinEnabled( 2' true );          newBoxLeft.Min = new XYZ( -2000' -2000' 0 );          newBoxLeft.set_MaxEnabled( 0' true );          newBoxLeft.set_MaxEnabled( 1' true );          newBoxLeft.set_MaxEnabled( 2' true );          newBoxLeft.Max = new XYZ( 2000' 2000' 0 );            frontView.CropBox = newBoxFront;          leftView.CropBox = newBoxLeft;          doc.Regenerate();          frontView.CropBoxActive = true;          leftView.CropBoxActive = true;            doc.Regenerate();            ElementId vid = vSheet.Id;          XYZ p = XYZ.Zero;            var vpFront = Viewport.Create( doc' vid' frontView.Id' p );          var vpLeft = Viewport.Create( doc' vid' leftView.Id' p );            doc.Regenerate();            // Align lower left - works           // because crop boxes are same            Outline outline1 = vpFront.GetBoxOutline();          Outline outline2 = vpLeft.GetBoxOutline();          XYZ min1 = outline1.MinimumPoint;          XYZ min2 = outline2.MinimumPoint;          XYZ diffToMove = min1 - min2;          ElementTransformUtils.MoveElement( doc' vpLeft.Id' diffToMove );            // Tranform the view such that the origin           // of the assemblyInstance for each view is           // on the middle of the sheet          // 1) Move the views such that the assembly          // Origin lies on the same on the origin of sheet            p = assemblyInst.GetTransform().Origin;            XYZ v = transformFront.Origin - p;            XYZ translation = new XYZ(            v.DotProduct( transformFront.BasisX )'            v.DotProduct( transformFront.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpFront.Id' translation );            v = transformLeft.Origin - p;            translation = new XYZ(            v.DotProduct( transformLeft.BasisX )'            v.DotProduct( transformLeft.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            // 2) Move the views such that the assembly           // origin lies on the center of the sheet            double width = 840 * 0.0032808399;          double height = 594 * 0.0032808399;            XYZ sheetMidpoint = ( vSheet.Origin + XYZ.BasisX * width + XYZ.BasisY * height ) / 2.0;          ElementTransformUtils.MoveElement( doc' vpFront.Id' sheetMidpoint );          ElementTransformUtils.MoveElement( doc' vpLeft.Id' sheetMidpoint );            // Once the views are on the middle' move the           // left view to the left of the front view:          // Do the correct translations to suit the           // defined layout            translation = XYZ.BasisX * (            -( ( outline1.MinimumPoint.X - outline1.MinimumPoint.X )            / 2 + ( outline2.MinimumPoint.X - outline2.MinimumPoint.X ) + 1 ) );            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            doc.Regenerate();            // Restore view crop boxes            frontView.CropBox = savedBoxFront;          frontView.CropBoxActive = frontCropActive;          frontView.CropBoxVisible = frontCropVisible;            param = frontView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipFront );          }            leftView.CropBox = savedBoxLeft;          leftView.CropBoxActive = leftCropActive;          leftView.CropBoxVisible = leftCropVisible;            param = leftView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipLeft );          }            trans.Commit();        }
Magic Number,BuildingCoder,CmdAlignTwoViews,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdViewsShowingElements.cs,Execute,The following statement contains a magic number: using( Transaction trans = new Transaction( doc ) )        {          trans.Start( "Place views" );            View frontView = doc.GetElement( new ElementId( 180041 ) ) as View;          View leftView = doc.GetElement( new ElementId( 180032 ) ) as View;            AssemblyInstance assemblyInst = doc.GetElement( new ElementId( 179915 ) ) as AssemblyInstance;            ViewSheet vSheet = doc.GetElement( new ElementId( 180049 ) ) as ViewSheet;            // Assume that the scale is the same for both views            int scale = frontView.Scale;          leftView.Scale = scale;            // Save current crop box values            BoundingBoxXYZ savedBoxFront = null' savedBoxLeft = null;          bool frontCropActive' frontCropVisible' leftCropActive' leftCropVisible;          double farClipFront = 0' farClipLeft = 0;          Parameter param;          Transform transformFront = frontView.CropBox.Transform;          Transform transformLeft = leftView.CropBox.Transform;            // Save old values. I have to store the farclip and reset it later            savedBoxFront = frontView.CropBox;          frontCropActive = frontView.CropBoxActive;          frontCropVisible = frontView.CropBoxVisible;          param = frontView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipFront = param.AsDouble();          }          savedBoxLeft = leftView.CropBox;          leftCropActive = leftView.CropBoxActive;          leftCropVisible = leftView.CropBoxVisible;          param = leftView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipLeft = param.AsDouble();          }            // Here my approach differs from yours.           // I'm starting from the old bounding box to           // ensure that I get the correct transformation.          // I tried to create a new Transformation but           // this didn't work.            BoundingBoxXYZ newBoxFront = frontView.CropBox;          newBoxFront.set_MinEnabled( 0' true );          newBoxFront.set_MinEnabled( 1' true );          newBoxFront.set_MinEnabled( 2' true );          newBoxFront.Min = new XYZ( -2000' -2000' 0 );          newBoxFront.set_MaxEnabled( 0' true );          newBoxFront.set_MaxEnabled( 1' true );          newBoxFront.set_MaxEnabled( 2' true );          newBoxFront.Max = new XYZ( 2000' 2000' 0 );            BoundingBoxXYZ newBoxLeft = leftView.CropBox;          newBoxLeft.set_MinEnabled( 0' true );          newBoxLeft.set_MinEnabled( 1' true );          newBoxLeft.set_MinEnabled( 2' true );          newBoxLeft.Min = new XYZ( -2000' -2000' 0 );          newBoxLeft.set_MaxEnabled( 0' true );          newBoxLeft.set_MaxEnabled( 1' true );          newBoxLeft.set_MaxEnabled( 2' true );          newBoxLeft.Max = new XYZ( 2000' 2000' 0 );            frontView.CropBox = newBoxFront;          leftView.CropBox = newBoxLeft;          doc.Regenerate();          frontView.CropBoxActive = true;          leftView.CropBoxActive = true;            doc.Regenerate();            ElementId vid = vSheet.Id;          XYZ p = XYZ.Zero;            var vpFront = Viewport.Create( doc' vid' frontView.Id' p );          var vpLeft = Viewport.Create( doc' vid' leftView.Id' p );            doc.Regenerate();            // Align lower left - works           // because crop boxes are same            Outline outline1 = vpFront.GetBoxOutline();          Outline outline2 = vpLeft.GetBoxOutline();          XYZ min1 = outline1.MinimumPoint;          XYZ min2 = outline2.MinimumPoint;          XYZ diffToMove = min1 - min2;          ElementTransformUtils.MoveElement( doc' vpLeft.Id' diffToMove );            // Tranform the view such that the origin           // of the assemblyInstance for each view is           // on the middle of the sheet          // 1) Move the views such that the assembly          // Origin lies on the same on the origin of sheet            p = assemblyInst.GetTransform().Origin;            XYZ v = transformFront.Origin - p;            XYZ translation = new XYZ(            v.DotProduct( transformFront.BasisX )'            v.DotProduct( transformFront.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpFront.Id' translation );            v = transformLeft.Origin - p;            translation = new XYZ(            v.DotProduct( transformLeft.BasisX )'            v.DotProduct( transformLeft.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            // 2) Move the views such that the assembly           // origin lies on the center of the sheet            double width = 840 * 0.0032808399;          double height = 594 * 0.0032808399;            XYZ sheetMidpoint = ( vSheet.Origin + XYZ.BasisX * width + XYZ.BasisY * height ) / 2.0;          ElementTransformUtils.MoveElement( doc' vpFront.Id' sheetMidpoint );          ElementTransformUtils.MoveElement( doc' vpLeft.Id' sheetMidpoint );            // Once the views are on the middle' move the           // left view to the left of the front view:          // Do the correct translations to suit the           // defined layout            translation = XYZ.BasisX * (            -( ( outline1.MinimumPoint.X - outline1.MinimumPoint.X )            / 2 + ( outline2.MinimumPoint.X - outline2.MinimumPoint.X ) + 1 ) );            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            doc.Regenerate();            // Restore view crop boxes            frontView.CropBox = savedBoxFront;          frontView.CropBoxActive = frontCropActive;          frontView.CropBoxVisible = frontCropVisible;            param = frontView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipFront );          }            leftView.CropBox = savedBoxLeft;          leftView.CropBoxActive = leftCropActive;          leftView.CropBoxVisible = leftCropVisible;            param = leftView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipLeft );          }            trans.Commit();        }
Magic Number,BuildingCoder,CmdAlignTwoViews,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdViewsShowingElements.cs,Execute,The following statement contains a magic number: using( Transaction trans = new Transaction( doc ) )        {          trans.Start( "Place views" );            View frontView = doc.GetElement( new ElementId( 180041 ) ) as View;          View leftView = doc.GetElement( new ElementId( 180032 ) ) as View;            AssemblyInstance assemblyInst = doc.GetElement( new ElementId( 179915 ) ) as AssemblyInstance;            ViewSheet vSheet = doc.GetElement( new ElementId( 180049 ) ) as ViewSheet;            // Assume that the scale is the same for both views            int scale = frontView.Scale;          leftView.Scale = scale;            // Save current crop box values            BoundingBoxXYZ savedBoxFront = null' savedBoxLeft = null;          bool frontCropActive' frontCropVisible' leftCropActive' leftCropVisible;          double farClipFront = 0' farClipLeft = 0;          Parameter param;          Transform transformFront = frontView.CropBox.Transform;          Transform transformLeft = leftView.CropBox.Transform;            // Save old values. I have to store the farclip and reset it later            savedBoxFront = frontView.CropBox;          frontCropActive = frontView.CropBoxActive;          frontCropVisible = frontView.CropBoxVisible;          param = frontView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipFront = param.AsDouble();          }          savedBoxLeft = leftView.CropBox;          leftCropActive = leftView.CropBoxActive;          leftCropVisible = leftView.CropBoxVisible;          param = leftView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipLeft = param.AsDouble();          }            // Here my approach differs from yours.           // I'm starting from the old bounding box to           // ensure that I get the correct transformation.          // I tried to create a new Transformation but           // this didn't work.            BoundingBoxXYZ newBoxFront = frontView.CropBox;          newBoxFront.set_MinEnabled( 0' true );          newBoxFront.set_MinEnabled( 1' true );          newBoxFront.set_MinEnabled( 2' true );          newBoxFront.Min = new XYZ( -2000' -2000' 0 );          newBoxFront.set_MaxEnabled( 0' true );          newBoxFront.set_MaxEnabled( 1' true );          newBoxFront.set_MaxEnabled( 2' true );          newBoxFront.Max = new XYZ( 2000' 2000' 0 );            BoundingBoxXYZ newBoxLeft = leftView.CropBox;          newBoxLeft.set_MinEnabled( 0' true );          newBoxLeft.set_MinEnabled( 1' true );          newBoxLeft.set_MinEnabled( 2' true );          newBoxLeft.Min = new XYZ( -2000' -2000' 0 );          newBoxLeft.set_MaxEnabled( 0' true );          newBoxLeft.set_MaxEnabled( 1' true );          newBoxLeft.set_MaxEnabled( 2' true );          newBoxLeft.Max = new XYZ( 2000' 2000' 0 );            frontView.CropBox = newBoxFront;          leftView.CropBox = newBoxLeft;          doc.Regenerate();          frontView.CropBoxActive = true;          leftView.CropBoxActive = true;            doc.Regenerate();            ElementId vid = vSheet.Id;          XYZ p = XYZ.Zero;            var vpFront = Viewport.Create( doc' vid' frontView.Id' p );          var vpLeft = Viewport.Create( doc' vid' leftView.Id' p );            doc.Regenerate();            // Align lower left - works           // because crop boxes are same            Outline outline1 = vpFront.GetBoxOutline();          Outline outline2 = vpLeft.GetBoxOutline();          XYZ min1 = outline1.MinimumPoint;          XYZ min2 = outline2.MinimumPoint;          XYZ diffToMove = min1 - min2;          ElementTransformUtils.MoveElement( doc' vpLeft.Id' diffToMove );            // Tranform the view such that the origin           // of the assemblyInstance for each view is           // on the middle of the sheet          // 1) Move the views such that the assembly          // Origin lies on the same on the origin of sheet            p = assemblyInst.GetTransform().Origin;            XYZ v = transformFront.Origin - p;            XYZ translation = new XYZ(            v.DotProduct( transformFront.BasisX )'            v.DotProduct( transformFront.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpFront.Id' translation );            v = transformLeft.Origin - p;            translation = new XYZ(            v.DotProduct( transformLeft.BasisX )'            v.DotProduct( transformLeft.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            // 2) Move the views such that the assembly           // origin lies on the center of the sheet            double width = 840 * 0.0032808399;          double height = 594 * 0.0032808399;            XYZ sheetMidpoint = ( vSheet.Origin + XYZ.BasisX * width + XYZ.BasisY * height ) / 2.0;          ElementTransformUtils.MoveElement( doc' vpFront.Id' sheetMidpoint );          ElementTransformUtils.MoveElement( doc' vpLeft.Id' sheetMidpoint );            // Once the views are on the middle' move the           // left view to the left of the front view:          // Do the correct translations to suit the           // defined layout            translation = XYZ.BasisX * (            -( ( outline1.MinimumPoint.X - outline1.MinimumPoint.X )            / 2 + ( outline2.MinimumPoint.X - outline2.MinimumPoint.X ) + 1 ) );            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            doc.Regenerate();            // Restore view crop boxes            frontView.CropBox = savedBoxFront;          frontView.CropBoxActive = frontCropActive;          frontView.CropBoxVisible = frontCropVisible;            param = frontView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipFront );          }            leftView.CropBox = savedBoxLeft;          leftView.CropBoxActive = leftCropActive;          leftView.CropBoxVisible = leftCropVisible;            param = leftView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipLeft );          }            trans.Commit();        }
Magic Number,BuildingCoder,CmdAlignTwoViews,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdViewsShowingElements.cs,Execute,The following statement contains a magic number: using( Transaction trans = new Transaction( doc ) )        {          trans.Start( "Place views" );            View frontView = doc.GetElement( new ElementId( 180041 ) ) as View;          View leftView = doc.GetElement( new ElementId( 180032 ) ) as View;            AssemblyInstance assemblyInst = doc.GetElement( new ElementId( 179915 ) ) as AssemblyInstance;            ViewSheet vSheet = doc.GetElement( new ElementId( 180049 ) ) as ViewSheet;            // Assume that the scale is the same for both views            int scale = frontView.Scale;          leftView.Scale = scale;            // Save current crop box values            BoundingBoxXYZ savedBoxFront = null' savedBoxLeft = null;          bool frontCropActive' frontCropVisible' leftCropActive' leftCropVisible;          double farClipFront = 0' farClipLeft = 0;          Parameter param;          Transform transformFront = frontView.CropBox.Transform;          Transform transformLeft = leftView.CropBox.Transform;            // Save old values. I have to store the farclip and reset it later            savedBoxFront = frontView.CropBox;          frontCropActive = frontView.CropBoxActive;          frontCropVisible = frontView.CropBoxVisible;          param = frontView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipFront = param.AsDouble();          }          savedBoxLeft = leftView.CropBox;          leftCropActive = leftView.CropBoxActive;          leftCropVisible = leftView.CropBoxVisible;          param = leftView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipLeft = param.AsDouble();          }            // Here my approach differs from yours.           // I'm starting from the old bounding box to           // ensure that I get the correct transformation.          // I tried to create a new Transformation but           // this didn't work.            BoundingBoxXYZ newBoxFront = frontView.CropBox;          newBoxFront.set_MinEnabled( 0' true );          newBoxFront.set_MinEnabled( 1' true );          newBoxFront.set_MinEnabled( 2' true );          newBoxFront.Min = new XYZ( -2000' -2000' 0 );          newBoxFront.set_MaxEnabled( 0' true );          newBoxFront.set_MaxEnabled( 1' true );          newBoxFront.set_MaxEnabled( 2' true );          newBoxFront.Max = new XYZ( 2000' 2000' 0 );            BoundingBoxXYZ newBoxLeft = leftView.CropBox;          newBoxLeft.set_MinEnabled( 0' true );          newBoxLeft.set_MinEnabled( 1' true );          newBoxLeft.set_MinEnabled( 2' true );          newBoxLeft.Min = new XYZ( -2000' -2000' 0 );          newBoxLeft.set_MaxEnabled( 0' true );          newBoxLeft.set_MaxEnabled( 1' true );          newBoxLeft.set_MaxEnabled( 2' true );          newBoxLeft.Max = new XYZ( 2000' 2000' 0 );            frontView.CropBox = newBoxFront;          leftView.CropBox = newBoxLeft;          doc.Regenerate();          frontView.CropBoxActive = true;          leftView.CropBoxActive = true;            doc.Regenerate();            ElementId vid = vSheet.Id;          XYZ p = XYZ.Zero;            var vpFront = Viewport.Create( doc' vid' frontView.Id' p );          var vpLeft = Viewport.Create( doc' vid' leftView.Id' p );            doc.Regenerate();            // Align lower left - works           // because crop boxes are same            Outline outline1 = vpFront.GetBoxOutline();          Outline outline2 = vpLeft.GetBoxOutline();          XYZ min1 = outline1.MinimumPoint;          XYZ min2 = outline2.MinimumPoint;          XYZ diffToMove = min1 - min2;          ElementTransformUtils.MoveElement( doc' vpLeft.Id' diffToMove );            // Tranform the view such that the origin           // of the assemblyInstance for each view is           // on the middle of the sheet          // 1) Move the views such that the assembly          // Origin lies on the same on the origin of sheet            p = assemblyInst.GetTransform().Origin;            XYZ v = transformFront.Origin - p;            XYZ translation = new XYZ(            v.DotProduct( transformFront.BasisX )'            v.DotProduct( transformFront.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpFront.Id' translation );            v = transformLeft.Origin - p;            translation = new XYZ(            v.DotProduct( transformLeft.BasisX )'            v.DotProduct( transformLeft.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            // 2) Move the views such that the assembly           // origin lies on the center of the sheet            double width = 840 * 0.0032808399;          double height = 594 * 0.0032808399;            XYZ sheetMidpoint = ( vSheet.Origin + XYZ.BasisX * width + XYZ.BasisY * height ) / 2.0;          ElementTransformUtils.MoveElement( doc' vpFront.Id' sheetMidpoint );          ElementTransformUtils.MoveElement( doc' vpLeft.Id' sheetMidpoint );            // Once the views are on the middle' move the           // left view to the left of the front view:          // Do the correct translations to suit the           // defined layout            translation = XYZ.BasisX * (            -( ( outline1.MinimumPoint.X - outline1.MinimumPoint.X )            / 2 + ( outline2.MinimumPoint.X - outline2.MinimumPoint.X ) + 1 ) );            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            doc.Regenerate();            // Restore view crop boxes            frontView.CropBox = savedBoxFront;          frontView.CropBoxActive = frontCropActive;          frontView.CropBoxVisible = frontCropVisible;            param = frontView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipFront );          }            leftView.CropBox = savedBoxLeft;          leftView.CropBoxActive = leftCropActive;          leftView.CropBoxVisible = leftCropVisible;            param = leftView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipLeft );          }            trans.Commit();        }
Magic Number,BuildingCoder,CmdAlignTwoViews,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdViewsShowingElements.cs,Execute,The following statement contains a magic number: using( Transaction trans = new Transaction( doc ) )        {          trans.Start( "Place views" );            View frontView = doc.GetElement( new ElementId( 180041 ) ) as View;          View leftView = doc.GetElement( new ElementId( 180032 ) ) as View;            AssemblyInstance assemblyInst = doc.GetElement( new ElementId( 179915 ) ) as AssemblyInstance;            ViewSheet vSheet = doc.GetElement( new ElementId( 180049 ) ) as ViewSheet;            // Assume that the scale is the same for both views            int scale = frontView.Scale;          leftView.Scale = scale;            // Save current crop box values            BoundingBoxXYZ savedBoxFront = null' savedBoxLeft = null;          bool frontCropActive' frontCropVisible' leftCropActive' leftCropVisible;          double farClipFront = 0' farClipLeft = 0;          Parameter param;          Transform transformFront = frontView.CropBox.Transform;          Transform transformLeft = leftView.CropBox.Transform;            // Save old values. I have to store the farclip and reset it later            savedBoxFront = frontView.CropBox;          frontCropActive = frontView.CropBoxActive;          frontCropVisible = frontView.CropBoxVisible;          param = frontView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipFront = param.AsDouble();          }          savedBoxLeft = leftView.CropBox;          leftCropActive = leftView.CropBoxActive;          leftCropVisible = leftView.CropBoxVisible;          param = leftView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipLeft = param.AsDouble();          }            // Here my approach differs from yours.           // I'm starting from the old bounding box to           // ensure that I get the correct transformation.          // I tried to create a new Transformation but           // this didn't work.            BoundingBoxXYZ newBoxFront = frontView.CropBox;          newBoxFront.set_MinEnabled( 0' true );          newBoxFront.set_MinEnabled( 1' true );          newBoxFront.set_MinEnabled( 2' true );          newBoxFront.Min = new XYZ( -2000' -2000' 0 );          newBoxFront.set_MaxEnabled( 0' true );          newBoxFront.set_MaxEnabled( 1' true );          newBoxFront.set_MaxEnabled( 2' true );          newBoxFront.Max = new XYZ( 2000' 2000' 0 );            BoundingBoxXYZ newBoxLeft = leftView.CropBox;          newBoxLeft.set_MinEnabled( 0' true );          newBoxLeft.set_MinEnabled( 1' true );          newBoxLeft.set_MinEnabled( 2' true );          newBoxLeft.Min = new XYZ( -2000' -2000' 0 );          newBoxLeft.set_MaxEnabled( 0' true );          newBoxLeft.set_MaxEnabled( 1' true );          newBoxLeft.set_MaxEnabled( 2' true );          newBoxLeft.Max = new XYZ( 2000' 2000' 0 );            frontView.CropBox = newBoxFront;          leftView.CropBox = newBoxLeft;          doc.Regenerate();          frontView.CropBoxActive = true;          leftView.CropBoxActive = true;            doc.Regenerate();            ElementId vid = vSheet.Id;          XYZ p = XYZ.Zero;            var vpFront = Viewport.Create( doc' vid' frontView.Id' p );          var vpLeft = Viewport.Create( doc' vid' leftView.Id' p );            doc.Regenerate();            // Align lower left - works           // because crop boxes are same            Outline outline1 = vpFront.GetBoxOutline();          Outline outline2 = vpLeft.GetBoxOutline();          XYZ min1 = outline1.MinimumPoint;          XYZ min2 = outline2.MinimumPoint;          XYZ diffToMove = min1 - min2;          ElementTransformUtils.MoveElement( doc' vpLeft.Id' diffToMove );            // Tranform the view such that the origin           // of the assemblyInstance for each view is           // on the middle of the sheet          // 1) Move the views such that the assembly          // Origin lies on the same on the origin of sheet            p = assemblyInst.GetTransform().Origin;            XYZ v = transformFront.Origin - p;            XYZ translation = new XYZ(            v.DotProduct( transformFront.BasisX )'            v.DotProduct( transformFront.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpFront.Id' translation );            v = transformLeft.Origin - p;            translation = new XYZ(            v.DotProduct( transformLeft.BasisX )'            v.DotProduct( transformLeft.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            // 2) Move the views such that the assembly           // origin lies on the center of the sheet            double width = 840 * 0.0032808399;          double height = 594 * 0.0032808399;            XYZ sheetMidpoint = ( vSheet.Origin + XYZ.BasisX * width + XYZ.BasisY * height ) / 2.0;          ElementTransformUtils.MoveElement( doc' vpFront.Id' sheetMidpoint );          ElementTransformUtils.MoveElement( doc' vpLeft.Id' sheetMidpoint );            // Once the views are on the middle' move the           // left view to the left of the front view:          // Do the correct translations to suit the           // defined layout            translation = XYZ.BasisX * (            -( ( outline1.MinimumPoint.X - outline1.MinimumPoint.X )            / 2 + ( outline2.MinimumPoint.X - outline2.MinimumPoint.X ) + 1 ) );            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            doc.Regenerate();            // Restore view crop boxes            frontView.CropBox = savedBoxFront;          frontView.CropBoxActive = frontCropActive;          frontView.CropBoxVisible = frontCropVisible;            param = frontView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipFront );          }            leftView.CropBox = savedBoxLeft;          leftView.CropBoxActive = leftCropActive;          leftView.CropBoxVisible = leftCropVisible;            param = leftView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipLeft );          }            trans.Commit();        }
Magic Number,BuildingCoder,CmdAlignTwoViews,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdViewsShowingElements.cs,Execute,The following statement contains a magic number: using( Transaction trans = new Transaction( doc ) )        {          trans.Start( "Place views" );            View frontView = doc.GetElement( new ElementId( 180041 ) ) as View;          View leftView = doc.GetElement( new ElementId( 180032 ) ) as View;            AssemblyInstance assemblyInst = doc.GetElement( new ElementId( 179915 ) ) as AssemblyInstance;            ViewSheet vSheet = doc.GetElement( new ElementId( 180049 ) ) as ViewSheet;            // Assume that the scale is the same for both views            int scale = frontView.Scale;          leftView.Scale = scale;            // Save current crop box values            BoundingBoxXYZ savedBoxFront = null' savedBoxLeft = null;          bool frontCropActive' frontCropVisible' leftCropActive' leftCropVisible;          double farClipFront = 0' farClipLeft = 0;          Parameter param;          Transform transformFront = frontView.CropBox.Transform;          Transform transformLeft = leftView.CropBox.Transform;            // Save old values. I have to store the farclip and reset it later            savedBoxFront = frontView.CropBox;          frontCropActive = frontView.CropBoxActive;          frontCropVisible = frontView.CropBoxVisible;          param = frontView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipFront = param.AsDouble();          }          savedBoxLeft = leftView.CropBox;          leftCropActive = leftView.CropBoxActive;          leftCropVisible = leftView.CropBoxVisible;          param = leftView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipLeft = param.AsDouble();          }            // Here my approach differs from yours.           // I'm starting from the old bounding box to           // ensure that I get the correct transformation.          // I tried to create a new Transformation but           // this didn't work.            BoundingBoxXYZ newBoxFront = frontView.CropBox;          newBoxFront.set_MinEnabled( 0' true );          newBoxFront.set_MinEnabled( 1' true );          newBoxFront.set_MinEnabled( 2' true );          newBoxFront.Min = new XYZ( -2000' -2000' 0 );          newBoxFront.set_MaxEnabled( 0' true );          newBoxFront.set_MaxEnabled( 1' true );          newBoxFront.set_MaxEnabled( 2' true );          newBoxFront.Max = new XYZ( 2000' 2000' 0 );            BoundingBoxXYZ newBoxLeft = leftView.CropBox;          newBoxLeft.set_MinEnabled( 0' true );          newBoxLeft.set_MinEnabled( 1' true );          newBoxLeft.set_MinEnabled( 2' true );          newBoxLeft.Min = new XYZ( -2000' -2000' 0 );          newBoxLeft.set_MaxEnabled( 0' true );          newBoxLeft.set_MaxEnabled( 1' true );          newBoxLeft.set_MaxEnabled( 2' true );          newBoxLeft.Max = new XYZ( 2000' 2000' 0 );            frontView.CropBox = newBoxFront;          leftView.CropBox = newBoxLeft;          doc.Regenerate();          frontView.CropBoxActive = true;          leftView.CropBoxActive = true;            doc.Regenerate();            ElementId vid = vSheet.Id;          XYZ p = XYZ.Zero;            var vpFront = Viewport.Create( doc' vid' frontView.Id' p );          var vpLeft = Viewport.Create( doc' vid' leftView.Id' p );            doc.Regenerate();            // Align lower left - works           // because crop boxes are same            Outline outline1 = vpFront.GetBoxOutline();          Outline outline2 = vpLeft.GetBoxOutline();          XYZ min1 = outline1.MinimumPoint;          XYZ min2 = outline2.MinimumPoint;          XYZ diffToMove = min1 - min2;          ElementTransformUtils.MoveElement( doc' vpLeft.Id' diffToMove );            // Tranform the view such that the origin           // of the assemblyInstance for each view is           // on the middle of the sheet          // 1) Move the views such that the assembly          // Origin lies on the same on the origin of sheet            p = assemblyInst.GetTransform().Origin;            XYZ v = transformFront.Origin - p;            XYZ translation = new XYZ(            v.DotProduct( transformFront.BasisX )'            v.DotProduct( transformFront.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpFront.Id' translation );            v = transformLeft.Origin - p;            translation = new XYZ(            v.DotProduct( transformLeft.BasisX )'            v.DotProduct( transformLeft.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            // 2) Move the views such that the assembly           // origin lies on the center of the sheet            double width = 840 * 0.0032808399;          double height = 594 * 0.0032808399;            XYZ sheetMidpoint = ( vSheet.Origin + XYZ.BasisX * width + XYZ.BasisY * height ) / 2.0;          ElementTransformUtils.MoveElement( doc' vpFront.Id' sheetMidpoint );          ElementTransformUtils.MoveElement( doc' vpLeft.Id' sheetMidpoint );            // Once the views are on the middle' move the           // left view to the left of the front view:          // Do the correct translations to suit the           // defined layout            translation = XYZ.BasisX * (            -( ( outline1.MinimumPoint.X - outline1.MinimumPoint.X )            / 2 + ( outline2.MinimumPoint.X - outline2.MinimumPoint.X ) + 1 ) );            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            doc.Regenerate();            // Restore view crop boxes            frontView.CropBox = savedBoxFront;          frontView.CropBoxActive = frontCropActive;          frontView.CropBoxVisible = frontCropVisible;            param = frontView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipFront );          }            leftView.CropBox = savedBoxLeft;          leftView.CropBoxActive = leftCropActive;          leftView.CropBoxVisible = leftCropVisible;            param = leftView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipLeft );          }            trans.Commit();        }
Magic Number,BuildingCoder,CmdAlignTwoViews,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdViewsShowingElements.cs,Execute,The following statement contains a magic number: using( Transaction trans = new Transaction( doc ) )        {          trans.Start( "Place views" );            View frontView = doc.GetElement( new ElementId( 180041 ) ) as View;          View leftView = doc.GetElement( new ElementId( 180032 ) ) as View;            AssemblyInstance assemblyInst = doc.GetElement( new ElementId( 179915 ) ) as AssemblyInstance;            ViewSheet vSheet = doc.GetElement( new ElementId( 180049 ) ) as ViewSheet;            // Assume that the scale is the same for both views            int scale = frontView.Scale;          leftView.Scale = scale;            // Save current crop box values            BoundingBoxXYZ savedBoxFront = null' savedBoxLeft = null;          bool frontCropActive' frontCropVisible' leftCropActive' leftCropVisible;          double farClipFront = 0' farClipLeft = 0;          Parameter param;          Transform transformFront = frontView.CropBox.Transform;          Transform transformLeft = leftView.CropBox.Transform;            // Save old values. I have to store the farclip and reset it later            savedBoxFront = frontView.CropBox;          frontCropActive = frontView.CropBoxActive;          frontCropVisible = frontView.CropBoxVisible;          param = frontView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipFront = param.AsDouble();          }          savedBoxLeft = leftView.CropBox;          leftCropActive = leftView.CropBoxActive;          leftCropVisible = leftView.CropBoxVisible;          param = leftView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipLeft = param.AsDouble();          }            // Here my approach differs from yours.           // I'm starting from the old bounding box to           // ensure that I get the correct transformation.          // I tried to create a new Transformation but           // this didn't work.            BoundingBoxXYZ newBoxFront = frontView.CropBox;          newBoxFront.set_MinEnabled( 0' true );          newBoxFront.set_MinEnabled( 1' true );          newBoxFront.set_MinEnabled( 2' true );          newBoxFront.Min = new XYZ( -2000' -2000' 0 );          newBoxFront.set_MaxEnabled( 0' true );          newBoxFront.set_MaxEnabled( 1' true );          newBoxFront.set_MaxEnabled( 2' true );          newBoxFront.Max = new XYZ( 2000' 2000' 0 );            BoundingBoxXYZ newBoxLeft = leftView.CropBox;          newBoxLeft.set_MinEnabled( 0' true );          newBoxLeft.set_MinEnabled( 1' true );          newBoxLeft.set_MinEnabled( 2' true );          newBoxLeft.Min = new XYZ( -2000' -2000' 0 );          newBoxLeft.set_MaxEnabled( 0' true );          newBoxLeft.set_MaxEnabled( 1' true );          newBoxLeft.set_MaxEnabled( 2' true );          newBoxLeft.Max = new XYZ( 2000' 2000' 0 );            frontView.CropBox = newBoxFront;          leftView.CropBox = newBoxLeft;          doc.Regenerate();          frontView.CropBoxActive = true;          leftView.CropBoxActive = true;            doc.Regenerate();            ElementId vid = vSheet.Id;          XYZ p = XYZ.Zero;            var vpFront = Viewport.Create( doc' vid' frontView.Id' p );          var vpLeft = Viewport.Create( doc' vid' leftView.Id' p );            doc.Regenerate();            // Align lower left - works           // because crop boxes are same            Outline outline1 = vpFront.GetBoxOutline();          Outline outline2 = vpLeft.GetBoxOutline();          XYZ min1 = outline1.MinimumPoint;          XYZ min2 = outline2.MinimumPoint;          XYZ diffToMove = min1 - min2;          ElementTransformUtils.MoveElement( doc' vpLeft.Id' diffToMove );            // Tranform the view such that the origin           // of the assemblyInstance for each view is           // on the middle of the sheet          // 1) Move the views such that the assembly          // Origin lies on the same on the origin of sheet            p = assemblyInst.GetTransform().Origin;            XYZ v = transformFront.Origin - p;            XYZ translation = new XYZ(            v.DotProduct( transformFront.BasisX )'            v.DotProduct( transformFront.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpFront.Id' translation );            v = transformLeft.Origin - p;            translation = new XYZ(            v.DotProduct( transformLeft.BasisX )'            v.DotProduct( transformLeft.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            // 2) Move the views such that the assembly           // origin lies on the center of the sheet            double width = 840 * 0.0032808399;          double height = 594 * 0.0032808399;            XYZ sheetMidpoint = ( vSheet.Origin + XYZ.BasisX * width + XYZ.BasisY * height ) / 2.0;          ElementTransformUtils.MoveElement( doc' vpFront.Id' sheetMidpoint );          ElementTransformUtils.MoveElement( doc' vpLeft.Id' sheetMidpoint );            // Once the views are on the middle' move the           // left view to the left of the front view:          // Do the correct translations to suit the           // defined layout            translation = XYZ.BasisX * (            -( ( outline1.MinimumPoint.X - outline1.MinimumPoint.X )            / 2 + ( outline2.MinimumPoint.X - outline2.MinimumPoint.X ) + 1 ) );            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            doc.Regenerate();            // Restore view crop boxes            frontView.CropBox = savedBoxFront;          frontView.CropBoxActive = frontCropActive;          frontView.CropBoxVisible = frontCropVisible;            param = frontView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipFront );          }            leftView.CropBox = savedBoxLeft;          leftView.CropBoxActive = leftCropActive;          leftView.CropBoxVisible = leftCropVisible;            param = leftView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipLeft );          }            trans.Commit();        }
Magic Number,BuildingCoder,CmdAlignTwoViews,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdViewsShowingElements.cs,Execute,The following statement contains a magic number: using( Transaction trans = new Transaction( doc ) )        {          trans.Start( "Place views" );            View frontView = doc.GetElement( new ElementId( 180041 ) ) as View;          View leftView = doc.GetElement( new ElementId( 180032 ) ) as View;            AssemblyInstance assemblyInst = doc.GetElement( new ElementId( 179915 ) ) as AssemblyInstance;            ViewSheet vSheet = doc.GetElement( new ElementId( 180049 ) ) as ViewSheet;            // Assume that the scale is the same for both views            int scale = frontView.Scale;          leftView.Scale = scale;            // Save current crop box values            BoundingBoxXYZ savedBoxFront = null' savedBoxLeft = null;          bool frontCropActive' frontCropVisible' leftCropActive' leftCropVisible;          double farClipFront = 0' farClipLeft = 0;          Parameter param;          Transform transformFront = frontView.CropBox.Transform;          Transform transformLeft = leftView.CropBox.Transform;            // Save old values. I have to store the farclip and reset it later            savedBoxFront = frontView.CropBox;          frontCropActive = frontView.CropBoxActive;          frontCropVisible = frontView.CropBoxVisible;          param = frontView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipFront = param.AsDouble();          }          savedBoxLeft = leftView.CropBox;          leftCropActive = leftView.CropBoxActive;          leftCropVisible = leftView.CropBoxVisible;          param = leftView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipLeft = param.AsDouble();          }            // Here my approach differs from yours.           // I'm starting from the old bounding box to           // ensure that I get the correct transformation.          // I tried to create a new Transformation but           // this didn't work.            BoundingBoxXYZ newBoxFront = frontView.CropBox;          newBoxFront.set_MinEnabled( 0' true );          newBoxFront.set_MinEnabled( 1' true );          newBoxFront.set_MinEnabled( 2' true );          newBoxFront.Min = new XYZ( -2000' -2000' 0 );          newBoxFront.set_MaxEnabled( 0' true );          newBoxFront.set_MaxEnabled( 1' true );          newBoxFront.set_MaxEnabled( 2' true );          newBoxFront.Max = new XYZ( 2000' 2000' 0 );            BoundingBoxXYZ newBoxLeft = leftView.CropBox;          newBoxLeft.set_MinEnabled( 0' true );          newBoxLeft.set_MinEnabled( 1' true );          newBoxLeft.set_MinEnabled( 2' true );          newBoxLeft.Min = new XYZ( -2000' -2000' 0 );          newBoxLeft.set_MaxEnabled( 0' true );          newBoxLeft.set_MaxEnabled( 1' true );          newBoxLeft.set_MaxEnabled( 2' true );          newBoxLeft.Max = new XYZ( 2000' 2000' 0 );            frontView.CropBox = newBoxFront;          leftView.CropBox = newBoxLeft;          doc.Regenerate();          frontView.CropBoxActive = true;          leftView.CropBoxActive = true;            doc.Regenerate();            ElementId vid = vSheet.Id;          XYZ p = XYZ.Zero;            var vpFront = Viewport.Create( doc' vid' frontView.Id' p );          var vpLeft = Viewport.Create( doc' vid' leftView.Id' p );            doc.Regenerate();            // Align lower left - works           // because crop boxes are same            Outline outline1 = vpFront.GetBoxOutline();          Outline outline2 = vpLeft.GetBoxOutline();          XYZ min1 = outline1.MinimumPoint;          XYZ min2 = outline2.MinimumPoint;          XYZ diffToMove = min1 - min2;          ElementTransformUtils.MoveElement( doc' vpLeft.Id' diffToMove );            // Tranform the view such that the origin           // of the assemblyInstance for each view is           // on the middle of the sheet          // 1) Move the views such that the assembly          // Origin lies on the same on the origin of sheet            p = assemblyInst.GetTransform().Origin;            XYZ v = transformFront.Origin - p;            XYZ translation = new XYZ(            v.DotProduct( transformFront.BasisX )'            v.DotProduct( transformFront.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpFront.Id' translation );            v = transformLeft.Origin - p;            translation = new XYZ(            v.DotProduct( transformLeft.BasisX )'            v.DotProduct( transformLeft.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            // 2) Move the views such that the assembly           // origin lies on the center of the sheet            double width = 840 * 0.0032808399;          double height = 594 * 0.0032808399;            XYZ sheetMidpoint = ( vSheet.Origin + XYZ.BasisX * width + XYZ.BasisY * height ) / 2.0;          ElementTransformUtils.MoveElement( doc' vpFront.Id' sheetMidpoint );          ElementTransformUtils.MoveElement( doc' vpLeft.Id' sheetMidpoint );            // Once the views are on the middle' move the           // left view to the left of the front view:          // Do the correct translations to suit the           // defined layout            translation = XYZ.BasisX * (            -( ( outline1.MinimumPoint.X - outline1.MinimumPoint.X )            / 2 + ( outline2.MinimumPoint.X - outline2.MinimumPoint.X ) + 1 ) );            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            doc.Regenerate();            // Restore view crop boxes            frontView.CropBox = savedBoxFront;          frontView.CropBoxActive = frontCropActive;          frontView.CropBoxVisible = frontCropVisible;            param = frontView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipFront );          }            leftView.CropBox = savedBoxLeft;          leftView.CropBoxActive = leftCropActive;          leftView.CropBoxVisible = leftCropVisible;            param = leftView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipLeft );          }            trans.Commit();        }
Magic Number,BuildingCoder,CmdAlignTwoViews,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdViewsShowingElements.cs,Execute,The following statement contains a magic number: using( Transaction trans = new Transaction( doc ) )        {          trans.Start( "Place views" );            View frontView = doc.GetElement( new ElementId( 180041 ) ) as View;          View leftView = doc.GetElement( new ElementId( 180032 ) ) as View;            AssemblyInstance assemblyInst = doc.GetElement( new ElementId( 179915 ) ) as AssemblyInstance;            ViewSheet vSheet = doc.GetElement( new ElementId( 180049 ) ) as ViewSheet;            // Assume that the scale is the same for both views            int scale = frontView.Scale;          leftView.Scale = scale;            // Save current crop box values            BoundingBoxXYZ savedBoxFront = null' savedBoxLeft = null;          bool frontCropActive' frontCropVisible' leftCropActive' leftCropVisible;          double farClipFront = 0' farClipLeft = 0;          Parameter param;          Transform transformFront = frontView.CropBox.Transform;          Transform transformLeft = leftView.CropBox.Transform;            // Save old values. I have to store the farclip and reset it later            savedBoxFront = frontView.CropBox;          frontCropActive = frontView.CropBoxActive;          frontCropVisible = frontView.CropBoxVisible;          param = frontView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipFront = param.AsDouble();          }          savedBoxLeft = leftView.CropBox;          leftCropActive = leftView.CropBoxActive;          leftCropVisible = leftView.CropBoxVisible;          param = leftView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipLeft = param.AsDouble();          }            // Here my approach differs from yours.           // I'm starting from the old bounding box to           // ensure that I get the correct transformation.          // I tried to create a new Transformation but           // this didn't work.            BoundingBoxXYZ newBoxFront = frontView.CropBox;          newBoxFront.set_MinEnabled( 0' true );          newBoxFront.set_MinEnabled( 1' true );          newBoxFront.set_MinEnabled( 2' true );          newBoxFront.Min = new XYZ( -2000' -2000' 0 );          newBoxFront.set_MaxEnabled( 0' true );          newBoxFront.set_MaxEnabled( 1' true );          newBoxFront.set_MaxEnabled( 2' true );          newBoxFront.Max = new XYZ( 2000' 2000' 0 );            BoundingBoxXYZ newBoxLeft = leftView.CropBox;          newBoxLeft.set_MinEnabled( 0' true );          newBoxLeft.set_MinEnabled( 1' true );          newBoxLeft.set_MinEnabled( 2' true );          newBoxLeft.Min = new XYZ( -2000' -2000' 0 );          newBoxLeft.set_MaxEnabled( 0' true );          newBoxLeft.set_MaxEnabled( 1' true );          newBoxLeft.set_MaxEnabled( 2' true );          newBoxLeft.Max = new XYZ( 2000' 2000' 0 );            frontView.CropBox = newBoxFront;          leftView.CropBox = newBoxLeft;          doc.Regenerate();          frontView.CropBoxActive = true;          leftView.CropBoxActive = true;            doc.Regenerate();            ElementId vid = vSheet.Id;          XYZ p = XYZ.Zero;            var vpFront = Viewport.Create( doc' vid' frontView.Id' p );          var vpLeft = Viewport.Create( doc' vid' leftView.Id' p );            doc.Regenerate();            // Align lower left - works           // because crop boxes are same            Outline outline1 = vpFront.GetBoxOutline();          Outline outline2 = vpLeft.GetBoxOutline();          XYZ min1 = outline1.MinimumPoint;          XYZ min2 = outline2.MinimumPoint;          XYZ diffToMove = min1 - min2;          ElementTransformUtils.MoveElement( doc' vpLeft.Id' diffToMove );            // Tranform the view such that the origin           // of the assemblyInstance for each view is           // on the middle of the sheet          // 1) Move the views such that the assembly          // Origin lies on the same on the origin of sheet            p = assemblyInst.GetTransform().Origin;            XYZ v = transformFront.Origin - p;            XYZ translation = new XYZ(            v.DotProduct( transformFront.BasisX )'            v.DotProduct( transformFront.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpFront.Id' translation );            v = transformLeft.Origin - p;            translation = new XYZ(            v.DotProduct( transformLeft.BasisX )'            v.DotProduct( transformLeft.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            // 2) Move the views such that the assembly           // origin lies on the center of the sheet            double width = 840 * 0.0032808399;          double height = 594 * 0.0032808399;            XYZ sheetMidpoint = ( vSheet.Origin + XYZ.BasisX * width + XYZ.BasisY * height ) / 2.0;          ElementTransformUtils.MoveElement( doc' vpFront.Id' sheetMidpoint );          ElementTransformUtils.MoveElement( doc' vpLeft.Id' sheetMidpoint );            // Once the views are on the middle' move the           // left view to the left of the front view:          // Do the correct translations to suit the           // defined layout            translation = XYZ.BasisX * (            -( ( outline1.MinimumPoint.X - outline1.MinimumPoint.X )            / 2 + ( outline2.MinimumPoint.X - outline2.MinimumPoint.X ) + 1 ) );            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            doc.Regenerate();            // Restore view crop boxes            frontView.CropBox = savedBoxFront;          frontView.CropBoxActive = frontCropActive;          frontView.CropBoxVisible = frontCropVisible;            param = frontView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipFront );          }            leftView.CropBox = savedBoxLeft;          leftView.CropBoxActive = leftCropActive;          leftView.CropBoxVisible = leftCropVisible;            param = leftView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipLeft );          }            trans.Commit();        }
Magic Number,BuildingCoder,CmdAlignTwoViews,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdViewsShowingElements.cs,Execute,The following statement contains a magic number: using( Transaction trans = new Transaction( doc ) )        {          trans.Start( "Place views" );            View frontView = doc.GetElement( new ElementId( 180041 ) ) as View;          View leftView = doc.GetElement( new ElementId( 180032 ) ) as View;            AssemblyInstance assemblyInst = doc.GetElement( new ElementId( 179915 ) ) as AssemblyInstance;            ViewSheet vSheet = doc.GetElement( new ElementId( 180049 ) ) as ViewSheet;            // Assume that the scale is the same for both views            int scale = frontView.Scale;          leftView.Scale = scale;            // Save current crop box values            BoundingBoxXYZ savedBoxFront = null' savedBoxLeft = null;          bool frontCropActive' frontCropVisible' leftCropActive' leftCropVisible;          double farClipFront = 0' farClipLeft = 0;          Parameter param;          Transform transformFront = frontView.CropBox.Transform;          Transform transformLeft = leftView.CropBox.Transform;            // Save old values. I have to store the farclip and reset it later            savedBoxFront = frontView.CropBox;          frontCropActive = frontView.CropBoxActive;          frontCropVisible = frontView.CropBoxVisible;          param = frontView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipFront = param.AsDouble();          }          savedBoxLeft = leftView.CropBox;          leftCropActive = leftView.CropBoxActive;          leftCropVisible = leftView.CropBoxVisible;          param = leftView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipLeft = param.AsDouble();          }            // Here my approach differs from yours.           // I'm starting from the old bounding box to           // ensure that I get the correct transformation.          // I tried to create a new Transformation but           // this didn't work.            BoundingBoxXYZ newBoxFront = frontView.CropBox;          newBoxFront.set_MinEnabled( 0' true );          newBoxFront.set_MinEnabled( 1' true );          newBoxFront.set_MinEnabled( 2' true );          newBoxFront.Min = new XYZ( -2000' -2000' 0 );          newBoxFront.set_MaxEnabled( 0' true );          newBoxFront.set_MaxEnabled( 1' true );          newBoxFront.set_MaxEnabled( 2' true );          newBoxFront.Max = new XYZ( 2000' 2000' 0 );            BoundingBoxXYZ newBoxLeft = leftView.CropBox;          newBoxLeft.set_MinEnabled( 0' true );          newBoxLeft.set_MinEnabled( 1' true );          newBoxLeft.set_MinEnabled( 2' true );          newBoxLeft.Min = new XYZ( -2000' -2000' 0 );          newBoxLeft.set_MaxEnabled( 0' true );          newBoxLeft.set_MaxEnabled( 1' true );          newBoxLeft.set_MaxEnabled( 2' true );          newBoxLeft.Max = new XYZ( 2000' 2000' 0 );            frontView.CropBox = newBoxFront;          leftView.CropBox = newBoxLeft;          doc.Regenerate();          frontView.CropBoxActive = true;          leftView.CropBoxActive = true;            doc.Regenerate();            ElementId vid = vSheet.Id;          XYZ p = XYZ.Zero;            var vpFront = Viewport.Create( doc' vid' frontView.Id' p );          var vpLeft = Viewport.Create( doc' vid' leftView.Id' p );            doc.Regenerate();            // Align lower left - works           // because crop boxes are same            Outline outline1 = vpFront.GetBoxOutline();          Outline outline2 = vpLeft.GetBoxOutline();          XYZ min1 = outline1.MinimumPoint;          XYZ min2 = outline2.MinimumPoint;          XYZ diffToMove = min1 - min2;          ElementTransformUtils.MoveElement( doc' vpLeft.Id' diffToMove );            // Tranform the view such that the origin           // of the assemblyInstance for each view is           // on the middle of the sheet          // 1) Move the views such that the assembly          // Origin lies on the same on the origin of sheet            p = assemblyInst.GetTransform().Origin;            XYZ v = transformFront.Origin - p;            XYZ translation = new XYZ(            v.DotProduct( transformFront.BasisX )'            v.DotProduct( transformFront.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpFront.Id' translation );            v = transformLeft.Origin - p;            translation = new XYZ(            v.DotProduct( transformLeft.BasisX )'            v.DotProduct( transformLeft.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            // 2) Move the views such that the assembly           // origin lies on the center of the sheet            double width = 840 * 0.0032808399;          double height = 594 * 0.0032808399;            XYZ sheetMidpoint = ( vSheet.Origin + XYZ.BasisX * width + XYZ.BasisY * height ) / 2.0;          ElementTransformUtils.MoveElement( doc' vpFront.Id' sheetMidpoint );          ElementTransformUtils.MoveElement( doc' vpLeft.Id' sheetMidpoint );            // Once the views are on the middle' move the           // left view to the left of the front view:          // Do the correct translations to suit the           // defined layout            translation = XYZ.BasisX * (            -( ( outline1.MinimumPoint.X - outline1.MinimumPoint.X )            / 2 + ( outline2.MinimumPoint.X - outline2.MinimumPoint.X ) + 1 ) );            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            doc.Regenerate();            // Restore view crop boxes            frontView.CropBox = savedBoxFront;          frontView.CropBoxActive = frontCropActive;          frontView.CropBoxVisible = frontCropVisible;            param = frontView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipFront );          }            leftView.CropBox = savedBoxLeft;          leftView.CropBoxActive = leftCropActive;          leftView.CropBoxVisible = leftCropVisible;            param = leftView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipLeft );          }            trans.Commit();        }
Magic Number,BuildingCoder,CmdAlignTwoViews,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdViewsShowingElements.cs,Execute,The following statement contains a magic number: using( Transaction trans = new Transaction( doc ) )        {          trans.Start( "Place views" );            View frontView = doc.GetElement( new ElementId( 180041 ) ) as View;          View leftView = doc.GetElement( new ElementId( 180032 ) ) as View;            AssemblyInstance assemblyInst = doc.GetElement( new ElementId( 179915 ) ) as AssemblyInstance;            ViewSheet vSheet = doc.GetElement( new ElementId( 180049 ) ) as ViewSheet;            // Assume that the scale is the same for both views            int scale = frontView.Scale;          leftView.Scale = scale;            // Save current crop box values            BoundingBoxXYZ savedBoxFront = null' savedBoxLeft = null;          bool frontCropActive' frontCropVisible' leftCropActive' leftCropVisible;          double farClipFront = 0' farClipLeft = 0;          Parameter param;          Transform transformFront = frontView.CropBox.Transform;          Transform transformLeft = leftView.CropBox.Transform;            // Save old values. I have to store the farclip and reset it later            savedBoxFront = frontView.CropBox;          frontCropActive = frontView.CropBoxActive;          frontCropVisible = frontView.CropBoxVisible;          param = frontView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipFront = param.AsDouble();          }          savedBoxLeft = leftView.CropBox;          leftCropActive = leftView.CropBoxActive;          leftCropVisible = leftView.CropBoxVisible;          param = leftView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipLeft = param.AsDouble();          }            // Here my approach differs from yours.           // I'm starting from the old bounding box to           // ensure that I get the correct transformation.          // I tried to create a new Transformation but           // this didn't work.            BoundingBoxXYZ newBoxFront = frontView.CropBox;          newBoxFront.set_MinEnabled( 0' true );          newBoxFront.set_MinEnabled( 1' true );          newBoxFront.set_MinEnabled( 2' true );          newBoxFront.Min = new XYZ( -2000' -2000' 0 );          newBoxFront.set_MaxEnabled( 0' true );          newBoxFront.set_MaxEnabled( 1' true );          newBoxFront.set_MaxEnabled( 2' true );          newBoxFront.Max = new XYZ( 2000' 2000' 0 );            BoundingBoxXYZ newBoxLeft = leftView.CropBox;          newBoxLeft.set_MinEnabled( 0' true );          newBoxLeft.set_MinEnabled( 1' true );          newBoxLeft.set_MinEnabled( 2' true );          newBoxLeft.Min = new XYZ( -2000' -2000' 0 );          newBoxLeft.set_MaxEnabled( 0' true );          newBoxLeft.set_MaxEnabled( 1' true );          newBoxLeft.set_MaxEnabled( 2' true );          newBoxLeft.Max = new XYZ( 2000' 2000' 0 );            frontView.CropBox = newBoxFront;          leftView.CropBox = newBoxLeft;          doc.Regenerate();          frontView.CropBoxActive = true;          leftView.CropBoxActive = true;            doc.Regenerate();            ElementId vid = vSheet.Id;          XYZ p = XYZ.Zero;            var vpFront = Viewport.Create( doc' vid' frontView.Id' p );          var vpLeft = Viewport.Create( doc' vid' leftView.Id' p );            doc.Regenerate();            // Align lower left - works           // because crop boxes are same            Outline outline1 = vpFront.GetBoxOutline();          Outline outline2 = vpLeft.GetBoxOutline();          XYZ min1 = outline1.MinimumPoint;          XYZ min2 = outline2.MinimumPoint;          XYZ diffToMove = min1 - min2;          ElementTransformUtils.MoveElement( doc' vpLeft.Id' diffToMove );            // Tranform the view such that the origin           // of the assemblyInstance for each view is           // on the middle of the sheet          // 1) Move the views such that the assembly          // Origin lies on the same on the origin of sheet            p = assemblyInst.GetTransform().Origin;            XYZ v = transformFront.Origin - p;            XYZ translation = new XYZ(            v.DotProduct( transformFront.BasisX )'            v.DotProduct( transformFront.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpFront.Id' translation );            v = transformLeft.Origin - p;            translation = new XYZ(            v.DotProduct( transformLeft.BasisX )'            v.DotProduct( transformLeft.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            // 2) Move the views such that the assembly           // origin lies on the center of the sheet            double width = 840 * 0.0032808399;          double height = 594 * 0.0032808399;            XYZ sheetMidpoint = ( vSheet.Origin + XYZ.BasisX * width + XYZ.BasisY * height ) / 2.0;          ElementTransformUtils.MoveElement( doc' vpFront.Id' sheetMidpoint );          ElementTransformUtils.MoveElement( doc' vpLeft.Id' sheetMidpoint );            // Once the views are on the middle' move the           // left view to the left of the front view:          // Do the correct translations to suit the           // defined layout            translation = XYZ.BasisX * (            -( ( outline1.MinimumPoint.X - outline1.MinimumPoint.X )            / 2 + ( outline2.MinimumPoint.X - outline2.MinimumPoint.X ) + 1 ) );            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            doc.Regenerate();            // Restore view crop boxes            frontView.CropBox = savedBoxFront;          frontView.CropBoxActive = frontCropActive;          frontView.CropBoxVisible = frontCropVisible;            param = frontView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipFront );          }            leftView.CropBox = savedBoxLeft;          leftView.CropBoxActive = leftCropActive;          leftView.CropBoxVisible = leftCropVisible;            param = leftView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipLeft );          }            trans.Commit();        }
Magic Number,BuildingCoder,CmdAlignTwoViews,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdViewsShowingElements.cs,Execute,The following statement contains a magic number: using( Transaction trans = new Transaction( doc ) )        {          trans.Start( "Place views" );            View frontView = doc.GetElement( new ElementId( 180041 ) ) as View;          View leftView = doc.GetElement( new ElementId( 180032 ) ) as View;            AssemblyInstance assemblyInst = doc.GetElement( new ElementId( 179915 ) ) as AssemblyInstance;            ViewSheet vSheet = doc.GetElement( new ElementId( 180049 ) ) as ViewSheet;            // Assume that the scale is the same for both views            int scale = frontView.Scale;          leftView.Scale = scale;            // Save current crop box values            BoundingBoxXYZ savedBoxFront = null' savedBoxLeft = null;          bool frontCropActive' frontCropVisible' leftCropActive' leftCropVisible;          double farClipFront = 0' farClipLeft = 0;          Parameter param;          Transform transformFront = frontView.CropBox.Transform;          Transform transformLeft = leftView.CropBox.Transform;            // Save old values. I have to store the farclip and reset it later            savedBoxFront = frontView.CropBox;          frontCropActive = frontView.CropBoxActive;          frontCropVisible = frontView.CropBoxVisible;          param = frontView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipFront = param.AsDouble();          }          savedBoxLeft = leftView.CropBox;          leftCropActive = leftView.CropBoxActive;          leftCropVisible = leftView.CropBoxVisible;          param = leftView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipLeft = param.AsDouble();          }            // Here my approach differs from yours.           // I'm starting from the old bounding box to           // ensure that I get the correct transformation.          // I tried to create a new Transformation but           // this didn't work.            BoundingBoxXYZ newBoxFront = frontView.CropBox;          newBoxFront.set_MinEnabled( 0' true );          newBoxFront.set_MinEnabled( 1' true );          newBoxFront.set_MinEnabled( 2' true );          newBoxFront.Min = new XYZ( -2000' -2000' 0 );          newBoxFront.set_MaxEnabled( 0' true );          newBoxFront.set_MaxEnabled( 1' true );          newBoxFront.set_MaxEnabled( 2' true );          newBoxFront.Max = new XYZ( 2000' 2000' 0 );            BoundingBoxXYZ newBoxLeft = leftView.CropBox;          newBoxLeft.set_MinEnabled( 0' true );          newBoxLeft.set_MinEnabled( 1' true );          newBoxLeft.set_MinEnabled( 2' true );          newBoxLeft.Min = new XYZ( -2000' -2000' 0 );          newBoxLeft.set_MaxEnabled( 0' true );          newBoxLeft.set_MaxEnabled( 1' true );          newBoxLeft.set_MaxEnabled( 2' true );          newBoxLeft.Max = new XYZ( 2000' 2000' 0 );            frontView.CropBox = newBoxFront;          leftView.CropBox = newBoxLeft;          doc.Regenerate();          frontView.CropBoxActive = true;          leftView.CropBoxActive = true;            doc.Regenerate();            ElementId vid = vSheet.Id;          XYZ p = XYZ.Zero;            var vpFront = Viewport.Create( doc' vid' frontView.Id' p );          var vpLeft = Viewport.Create( doc' vid' leftView.Id' p );            doc.Regenerate();            // Align lower left - works           // because crop boxes are same            Outline outline1 = vpFront.GetBoxOutline();          Outline outline2 = vpLeft.GetBoxOutline();          XYZ min1 = outline1.MinimumPoint;          XYZ min2 = outline2.MinimumPoint;          XYZ diffToMove = min1 - min2;          ElementTransformUtils.MoveElement( doc' vpLeft.Id' diffToMove );            // Tranform the view such that the origin           // of the assemblyInstance for each view is           // on the middle of the sheet          // 1) Move the views such that the assembly          // Origin lies on the same on the origin of sheet            p = assemblyInst.GetTransform().Origin;            XYZ v = transformFront.Origin - p;            XYZ translation = new XYZ(            v.DotProduct( transformFront.BasisX )'            v.DotProduct( transformFront.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpFront.Id' translation );            v = transformLeft.Origin - p;            translation = new XYZ(            v.DotProduct( transformLeft.BasisX )'            v.DotProduct( transformLeft.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            // 2) Move the views such that the assembly           // origin lies on the center of the sheet            double width = 840 * 0.0032808399;          double height = 594 * 0.0032808399;            XYZ sheetMidpoint = ( vSheet.Origin + XYZ.BasisX * width + XYZ.BasisY * height ) / 2.0;          ElementTransformUtils.MoveElement( doc' vpFront.Id' sheetMidpoint );          ElementTransformUtils.MoveElement( doc' vpLeft.Id' sheetMidpoint );            // Once the views are on the middle' move the           // left view to the left of the front view:          // Do the correct translations to suit the           // defined layout            translation = XYZ.BasisX * (            -( ( outline1.MinimumPoint.X - outline1.MinimumPoint.X )            / 2 + ( outline2.MinimumPoint.X - outline2.MinimumPoint.X ) + 1 ) );            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            doc.Regenerate();            // Restore view crop boxes            frontView.CropBox = savedBoxFront;          frontView.CropBoxActive = frontCropActive;          frontView.CropBoxVisible = frontCropVisible;            param = frontView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipFront );          }            leftView.CropBox = savedBoxLeft;          leftView.CropBoxActive = leftCropActive;          leftView.CropBoxVisible = leftCropVisible;            param = leftView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipLeft );          }            trans.Commit();        }
Magic Number,BuildingCoder,CmdAlignTwoViews,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdViewsShowingElements.cs,Execute,The following statement contains a magic number: using( Transaction trans = new Transaction( doc ) )        {          trans.Start( "Place views" );            View frontView = doc.GetElement( new ElementId( 180041 ) ) as View;          View leftView = doc.GetElement( new ElementId( 180032 ) ) as View;            AssemblyInstance assemblyInst = doc.GetElement( new ElementId( 179915 ) ) as AssemblyInstance;            ViewSheet vSheet = doc.GetElement( new ElementId( 180049 ) ) as ViewSheet;            // Assume that the scale is the same for both views            int scale = frontView.Scale;          leftView.Scale = scale;            // Save current crop box values            BoundingBoxXYZ savedBoxFront = null' savedBoxLeft = null;          bool frontCropActive' frontCropVisible' leftCropActive' leftCropVisible;          double farClipFront = 0' farClipLeft = 0;          Parameter param;          Transform transformFront = frontView.CropBox.Transform;          Transform transformLeft = leftView.CropBox.Transform;            // Save old values. I have to store the farclip and reset it later            savedBoxFront = frontView.CropBox;          frontCropActive = frontView.CropBoxActive;          frontCropVisible = frontView.CropBoxVisible;          param = frontView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipFront = param.AsDouble();          }          savedBoxLeft = leftView.CropBox;          leftCropActive = leftView.CropBoxActive;          leftCropVisible = leftView.CropBoxVisible;          param = leftView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipLeft = param.AsDouble();          }            // Here my approach differs from yours.           // I'm starting from the old bounding box to           // ensure that I get the correct transformation.          // I tried to create a new Transformation but           // this didn't work.            BoundingBoxXYZ newBoxFront = frontView.CropBox;          newBoxFront.set_MinEnabled( 0' true );          newBoxFront.set_MinEnabled( 1' true );          newBoxFront.set_MinEnabled( 2' true );          newBoxFront.Min = new XYZ( -2000' -2000' 0 );          newBoxFront.set_MaxEnabled( 0' true );          newBoxFront.set_MaxEnabled( 1' true );          newBoxFront.set_MaxEnabled( 2' true );          newBoxFront.Max = new XYZ( 2000' 2000' 0 );            BoundingBoxXYZ newBoxLeft = leftView.CropBox;          newBoxLeft.set_MinEnabled( 0' true );          newBoxLeft.set_MinEnabled( 1' true );          newBoxLeft.set_MinEnabled( 2' true );          newBoxLeft.Min = new XYZ( -2000' -2000' 0 );          newBoxLeft.set_MaxEnabled( 0' true );          newBoxLeft.set_MaxEnabled( 1' true );          newBoxLeft.set_MaxEnabled( 2' true );          newBoxLeft.Max = new XYZ( 2000' 2000' 0 );            frontView.CropBox = newBoxFront;          leftView.CropBox = newBoxLeft;          doc.Regenerate();          frontView.CropBoxActive = true;          leftView.CropBoxActive = true;            doc.Regenerate();            ElementId vid = vSheet.Id;          XYZ p = XYZ.Zero;            var vpFront = Viewport.Create( doc' vid' frontView.Id' p );          var vpLeft = Viewport.Create( doc' vid' leftView.Id' p );            doc.Regenerate();            // Align lower left - works           // because crop boxes are same            Outline outline1 = vpFront.GetBoxOutline();          Outline outline2 = vpLeft.GetBoxOutline();          XYZ min1 = outline1.MinimumPoint;          XYZ min2 = outline2.MinimumPoint;          XYZ diffToMove = min1 - min2;          ElementTransformUtils.MoveElement( doc' vpLeft.Id' diffToMove );            // Tranform the view such that the origin           // of the assemblyInstance for each view is           // on the middle of the sheet          // 1) Move the views such that the assembly          // Origin lies on the same on the origin of sheet            p = assemblyInst.GetTransform().Origin;            XYZ v = transformFront.Origin - p;            XYZ translation = new XYZ(            v.DotProduct( transformFront.BasisX )'            v.DotProduct( transformFront.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpFront.Id' translation );            v = transformLeft.Origin - p;            translation = new XYZ(            v.DotProduct( transformLeft.BasisX )'            v.DotProduct( transformLeft.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            // 2) Move the views such that the assembly           // origin lies on the center of the sheet            double width = 840 * 0.0032808399;          double height = 594 * 0.0032808399;            XYZ sheetMidpoint = ( vSheet.Origin + XYZ.BasisX * width + XYZ.BasisY * height ) / 2.0;          ElementTransformUtils.MoveElement( doc' vpFront.Id' sheetMidpoint );          ElementTransformUtils.MoveElement( doc' vpLeft.Id' sheetMidpoint );            // Once the views are on the middle' move the           // left view to the left of the front view:          // Do the correct translations to suit the           // defined layout            translation = XYZ.BasisX * (            -( ( outline1.MinimumPoint.X - outline1.MinimumPoint.X )            / 2 + ( outline2.MinimumPoint.X - outline2.MinimumPoint.X ) + 1 ) );            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            doc.Regenerate();            // Restore view crop boxes            frontView.CropBox = savedBoxFront;          frontView.CropBoxActive = frontCropActive;          frontView.CropBoxVisible = frontCropVisible;            param = frontView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipFront );          }            leftView.CropBox = savedBoxLeft;          leftView.CropBoxActive = leftCropActive;          leftView.CropBoxVisible = leftCropVisible;            param = leftView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipLeft );          }            trans.Commit();        }
Magic Number,BuildingCoder,CmdAlignTwoViews,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdViewsShowingElements.cs,Execute,The following statement contains a magic number: using( Transaction trans = new Transaction( doc ) )        {          trans.Start( "Place views" );            View frontView = doc.GetElement( new ElementId( 180041 ) ) as View;          View leftView = doc.GetElement( new ElementId( 180032 ) ) as View;            AssemblyInstance assemblyInst = doc.GetElement( new ElementId( 179915 ) ) as AssemblyInstance;            ViewSheet vSheet = doc.GetElement( new ElementId( 180049 ) ) as ViewSheet;            // Assume that the scale is the same for both views            int scale = frontView.Scale;          leftView.Scale = scale;            // Save current crop box values            BoundingBoxXYZ savedBoxFront = null' savedBoxLeft = null;          bool frontCropActive' frontCropVisible' leftCropActive' leftCropVisible;          double farClipFront = 0' farClipLeft = 0;          Parameter param;          Transform transformFront = frontView.CropBox.Transform;          Transform transformLeft = leftView.CropBox.Transform;            // Save old values. I have to store the farclip and reset it later            savedBoxFront = frontView.CropBox;          frontCropActive = frontView.CropBoxActive;          frontCropVisible = frontView.CropBoxVisible;          param = frontView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipFront = param.AsDouble();          }          savedBoxLeft = leftView.CropBox;          leftCropActive = leftView.CropBoxActive;          leftCropVisible = leftView.CropBoxVisible;          param = leftView.get_Parameter( _bipFarOffset );          if( param != null )          {            farClipLeft = param.AsDouble();          }            // Here my approach differs from yours.           // I'm starting from the old bounding box to           // ensure that I get the correct transformation.          // I tried to create a new Transformation but           // this didn't work.            BoundingBoxXYZ newBoxFront = frontView.CropBox;          newBoxFront.set_MinEnabled( 0' true );          newBoxFront.set_MinEnabled( 1' true );          newBoxFront.set_MinEnabled( 2' true );          newBoxFront.Min = new XYZ( -2000' -2000' 0 );          newBoxFront.set_MaxEnabled( 0' true );          newBoxFront.set_MaxEnabled( 1' true );          newBoxFront.set_MaxEnabled( 2' true );          newBoxFront.Max = new XYZ( 2000' 2000' 0 );            BoundingBoxXYZ newBoxLeft = leftView.CropBox;          newBoxLeft.set_MinEnabled( 0' true );          newBoxLeft.set_MinEnabled( 1' true );          newBoxLeft.set_MinEnabled( 2' true );          newBoxLeft.Min = new XYZ( -2000' -2000' 0 );          newBoxLeft.set_MaxEnabled( 0' true );          newBoxLeft.set_MaxEnabled( 1' true );          newBoxLeft.set_MaxEnabled( 2' true );          newBoxLeft.Max = new XYZ( 2000' 2000' 0 );            frontView.CropBox = newBoxFront;          leftView.CropBox = newBoxLeft;          doc.Regenerate();          frontView.CropBoxActive = true;          leftView.CropBoxActive = true;            doc.Regenerate();            ElementId vid = vSheet.Id;          XYZ p = XYZ.Zero;            var vpFront = Viewport.Create( doc' vid' frontView.Id' p );          var vpLeft = Viewport.Create( doc' vid' leftView.Id' p );            doc.Regenerate();            // Align lower left - works           // because crop boxes are same            Outline outline1 = vpFront.GetBoxOutline();          Outline outline2 = vpLeft.GetBoxOutline();          XYZ min1 = outline1.MinimumPoint;          XYZ min2 = outline2.MinimumPoint;          XYZ diffToMove = min1 - min2;          ElementTransformUtils.MoveElement( doc' vpLeft.Id' diffToMove );            // Tranform the view such that the origin           // of the assemblyInstance for each view is           // on the middle of the sheet          // 1) Move the views such that the assembly          // Origin lies on the same on the origin of sheet            p = assemblyInst.GetTransform().Origin;            XYZ v = transformFront.Origin - p;            XYZ translation = new XYZ(            v.DotProduct( transformFront.BasisX )'            v.DotProduct( transformFront.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpFront.Id' translation );            v = transformLeft.Origin - p;            translation = new XYZ(            v.DotProduct( transformLeft.BasisX )'            v.DotProduct( transformLeft.BasisY )' 0 )              / scale;            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            // 2) Move the views such that the assembly           // origin lies on the center of the sheet            double width = 840 * 0.0032808399;          double height = 594 * 0.0032808399;            XYZ sheetMidpoint = ( vSheet.Origin + XYZ.BasisX * width + XYZ.BasisY * height ) / 2.0;          ElementTransformUtils.MoveElement( doc' vpFront.Id' sheetMidpoint );          ElementTransformUtils.MoveElement( doc' vpLeft.Id' sheetMidpoint );            // Once the views are on the middle' move the           // left view to the left of the front view:          // Do the correct translations to suit the           // defined layout            translation = XYZ.BasisX * (            -( ( outline1.MinimumPoint.X - outline1.MinimumPoint.X )            / 2 + ( outline2.MinimumPoint.X - outline2.MinimumPoint.X ) + 1 ) );            ElementTransformUtils.MoveElement( doc' vpLeft.Id' translation );            doc.Regenerate();            // Restore view crop boxes            frontView.CropBox = savedBoxFront;          frontView.CropBoxActive = frontCropActive;          frontView.CropBoxVisible = frontCropVisible;            param = frontView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipFront );          }            leftView.CropBox = savedBoxLeft;          leftView.CropBoxActive = leftCropActive;          leftView.CropBoxVisible = leftCropVisible;            param = leftView.get_Parameter( _bipFarOffset );            if( param != null )          {            param.Set( farClipLeft );          }            trans.Commit();        }
Magic Number,BuildingCoder,CmdWallOpeningProfiles,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallOpeningProfiles.cs,testTwo,The following statement contains a magic number: using( Transaction t = new Transaction( doc ) )        {          t.Start( "Trans" );            // Get Floorplan for Level1 and copy its           // properties for ouw newly to create ViewPlan.            View existingView = doc.GetElement(            new ElementId( 312 ) ) as View;            // Create new Floorplan.            newView = doc.GetElement( existingView.Duplicate(            ViewDuplicateOption.Duplicate ) ) as View;            t.Commit();            // Important to set new view as active view.            uidoc.ActiveView = newView;            t.Start( "Trans 2" );            // Try to isolate a Wall. Fails.            newView.IsolateElementTemporary( new ElementId( 317443 ) );            t.Commit();        }
Magic Number,BuildingCoder,CmdWallOpeningProfiles,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallOpeningProfiles.cs,testTwo,The following statement contains a magic number: using( Transaction t = new Transaction( doc ) )        {          t.Start( "Trans" );            // Get Floorplan for Level1 and copy its           // properties for ouw newly to create ViewPlan.            View existingView = doc.GetElement(            new ElementId( 312 ) ) as View;            // Create new Floorplan.            newView = doc.GetElement( existingView.Duplicate(            ViewDuplicateOption.Duplicate ) ) as View;            t.Commit();            // Important to set new view as active view.            uidoc.ActiveView = newView;            t.Start( "Trans 2" );            // Try to isolate a Wall. Fails.            newView.IsolateElementTemporary( new ElementId( 317443 ) );            t.Commit();        }
Magic Number,BuildingCoder,CmdWallOpenings,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallOpenings.cs,IsEven,The following statement contains a magic number: return 0 == i % 2;
Magic Number,BuildingCoder,CmdWallOpenings,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallOpenings.cs,GetWallOpenings,The following statement contains a magic number: var wallOpenings = new List<WallOpening2d>(          n / 2 );
Magic Number,BuildingCoder,CmdWallOpenings,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallOpenings.cs,GetWallOpenings,The following statement contains a magic number: for( int i = 0; i < n; i += 2 )        {          wallOpenings.Add( new WallOpening2d          {            Start = pointList[i]'            End = pointList[i + 1]          } );        }
Magic Number,BuildingCoder,CmdWallProfileArea,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallProfileArea.cs,GetPolygonPlane,The following statement contains a magic number: bool rc = ( 2 < n );
Magic Number,BuildingCoder,CmdWallProfileArea,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallProfileArea.cs,GetPolygonPlane,The following statement contains a magic number: if( 3 == n )        {            // the general case returns a wrong result for the triangle          // ((-1 -1 -1) (1 -1 -1) (-1 -1 1))' so implement specific          // code for triangle:            XYZ a = polygon[0];          XYZ b = polygon[1];          XYZ c = polygon[2];          XYZ v = b - a;          normal = v.CrossProduct( c - a );          dist = normal.DotProduct( a );        }        else if( 4 == n )        {            // more efficient code for 4-sided polygons            XYZ a = polygon[0];          XYZ b = polygon[1];          XYZ c = polygon[2];          XYZ d = polygon[3];            normal = new XYZ(            ( c.Y - a.Y ) * ( d.Z - b.Z ) + ( c.Z - a.Z ) * ( b.Y - d.Y )'            ( c.Z - a.Z ) * ( d.X - b.X ) + ( c.X - a.X ) * ( b.Z - d.Z )'            ( c.X - a.X ) * ( d.Y - b.Y ) + ( c.Y - a.Y ) * ( b.X - d.X ) );            dist = 0.25 *            ( normal.X * ( a.X + b.X + c.X + d.X )            + normal.Y * ( a.Y + b.Y + c.Y + d.Y )            + normal.Z * ( a.Z + b.Z + c.Z + d.Z ) );        }        else if( 4 < n )        {            // general case for n-sided polygons            XYZ a;          XYZ b = polygon[n - 2];          XYZ c = polygon[n - 1];          XYZ s = XYZ.Zero;            for( int i = 0; i < n; ++i )          {            a = b;            b = c;            c = polygon[i];              normal = new XYZ(              normal.X + b.Y * ( c.Z - a.Z )'              normal.Y + b.Z * ( c.X - a.X )'              normal.Z + b.X * ( c.Y - a.Y ) );              s += c;          }          dist = s.DotProduct( normal ) / n;        }
Magic Number,BuildingCoder,CmdWallProfileArea,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallProfileArea.cs,GetPolygonPlane,The following statement contains a magic number: if( 3 == n )        {            // the general case returns a wrong result for the triangle          // ((-1 -1 -1) (1 -1 -1) (-1 -1 1))' so implement specific          // code for triangle:            XYZ a = polygon[0];          XYZ b = polygon[1];          XYZ c = polygon[2];          XYZ v = b - a;          normal = v.CrossProduct( c - a );          dist = normal.DotProduct( a );        }        else if( 4 == n )        {            // more efficient code for 4-sided polygons            XYZ a = polygon[0];          XYZ b = polygon[1];          XYZ c = polygon[2];          XYZ d = polygon[3];            normal = new XYZ(            ( c.Y - a.Y ) * ( d.Z - b.Z ) + ( c.Z - a.Z ) * ( b.Y - d.Y )'            ( c.Z - a.Z ) * ( d.X - b.X ) + ( c.X - a.X ) * ( b.Z - d.Z )'            ( c.X - a.X ) * ( d.Y - b.Y ) + ( c.Y - a.Y ) * ( b.X - d.X ) );            dist = 0.25 *            ( normal.X * ( a.X + b.X + c.X + d.X )            + normal.Y * ( a.Y + b.Y + c.Y + d.Y )            + normal.Z * ( a.Z + b.Z + c.Z + d.Z ) );        }        else if( 4 < n )        {            // general case for n-sided polygons            XYZ a;          XYZ b = polygon[n - 2];          XYZ c = polygon[n - 1];          XYZ s = XYZ.Zero;            for( int i = 0; i < n; ++i )          {            a = b;            b = c;            c = polygon[i];              normal = new XYZ(              normal.X + b.Y * ( c.Z - a.Z )'              normal.Y + b.Z * ( c.X - a.X )'              normal.Z + b.X * ( c.Y - a.Y ) );              s += c;          }          dist = s.DotProduct( normal ) / n;        }
Magic Number,BuildingCoder,CmdWallProfileArea,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallProfileArea.cs,GetPolygonPlane,The following statement contains a magic number: if( 3 == n )        {            // the general case returns a wrong result for the triangle          // ((-1 -1 -1) (1 -1 -1) (-1 -1 1))' so implement specific          // code for triangle:            XYZ a = polygon[0];          XYZ b = polygon[1];          XYZ c = polygon[2];          XYZ v = b - a;          normal = v.CrossProduct( c - a );          dist = normal.DotProduct( a );        }        else if( 4 == n )        {            // more efficient code for 4-sided polygons            XYZ a = polygon[0];          XYZ b = polygon[1];          XYZ c = polygon[2];          XYZ d = polygon[3];            normal = new XYZ(            ( c.Y - a.Y ) * ( d.Z - b.Z ) + ( c.Z - a.Z ) * ( b.Y - d.Y )'            ( c.Z - a.Z ) * ( d.X - b.X ) + ( c.X - a.X ) * ( b.Z - d.Z )'            ( c.X - a.X ) * ( d.Y - b.Y ) + ( c.Y - a.Y ) * ( b.X - d.X ) );            dist = 0.25 *            ( normal.X * ( a.X + b.X + c.X + d.X )            + normal.Y * ( a.Y + b.Y + c.Y + d.Y )            + normal.Z * ( a.Z + b.Z + c.Z + d.Z ) );        }        else if( 4 < n )        {            // general case for n-sided polygons            XYZ a;          XYZ b = polygon[n - 2];          XYZ c = polygon[n - 1];          XYZ s = XYZ.Zero;            for( int i = 0; i < n; ++i )          {            a = b;            b = c;            c = polygon[i];              normal = new XYZ(              normal.X + b.Y * ( c.Z - a.Z )'              normal.Y + b.Z * ( c.X - a.X )'              normal.Z + b.X * ( c.Y - a.Y ) );              s += c;          }          dist = s.DotProduct( normal ) / n;        }
Magic Number,BuildingCoder,CmdWallProfileArea,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallProfileArea.cs,GetPolygonPlane,The following statement contains a magic number: if( 3 == n )        {            // the general case returns a wrong result for the triangle          // ((-1 -1 -1) (1 -1 -1) (-1 -1 1))' so implement specific          // code for triangle:            XYZ a = polygon[0];          XYZ b = polygon[1];          XYZ c = polygon[2];          XYZ v = b - a;          normal = v.CrossProduct( c - a );          dist = normal.DotProduct( a );        }        else if( 4 == n )        {            // more efficient code for 4-sided polygons            XYZ a = polygon[0];          XYZ b = polygon[1];          XYZ c = polygon[2];          XYZ d = polygon[3];            normal = new XYZ(            ( c.Y - a.Y ) * ( d.Z - b.Z ) + ( c.Z - a.Z ) * ( b.Y - d.Y )'            ( c.Z - a.Z ) * ( d.X - b.X ) + ( c.X - a.X ) * ( b.Z - d.Z )'            ( c.X - a.X ) * ( d.Y - b.Y ) + ( c.Y - a.Y ) * ( b.X - d.X ) );            dist = 0.25 *            ( normal.X * ( a.X + b.X + c.X + d.X )            + normal.Y * ( a.Y + b.Y + c.Y + d.Y )            + normal.Z * ( a.Z + b.Z + c.Z + d.Z ) );        }        else if( 4 < n )        {            // general case for n-sided polygons            XYZ a;          XYZ b = polygon[n - 2];          XYZ c = polygon[n - 1];          XYZ s = XYZ.Zero;            for( int i = 0; i < n; ++i )          {            a = b;            b = c;            c = polygon[i];              normal = new XYZ(              normal.X + b.Y * ( c.Z - a.Z )'              normal.Y + b.Z * ( c.X - a.X )'              normal.Z + b.X * ( c.Y - a.Y ) );              s += c;          }          dist = s.DotProduct( normal ) / n;        }
Magic Number,BuildingCoder,CmdWallProfileArea,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallProfileArea.cs,GetPolygonPlane,The following statement contains a magic number: if( 3 == n )        {            // the general case returns a wrong result for the triangle          // ((-1 -1 -1) (1 -1 -1) (-1 -1 1))' so implement specific          // code for triangle:            XYZ a = polygon[0];          XYZ b = polygon[1];          XYZ c = polygon[2];          XYZ v = b - a;          normal = v.CrossProduct( c - a );          dist = normal.DotProduct( a );        }        else if( 4 == n )        {            // more efficient code for 4-sided polygons            XYZ a = polygon[0];          XYZ b = polygon[1];          XYZ c = polygon[2];          XYZ d = polygon[3];            normal = new XYZ(            ( c.Y - a.Y ) * ( d.Z - b.Z ) + ( c.Z - a.Z ) * ( b.Y - d.Y )'            ( c.Z - a.Z ) * ( d.X - b.X ) + ( c.X - a.X ) * ( b.Z - d.Z )'            ( c.X - a.X ) * ( d.Y - b.Y ) + ( c.Y - a.Y ) * ( b.X - d.X ) );            dist = 0.25 *            ( normal.X * ( a.X + b.X + c.X + d.X )            + normal.Y * ( a.Y + b.Y + c.Y + d.Y )            + normal.Z * ( a.Z + b.Z + c.Z + d.Z ) );        }        else if( 4 < n )        {            // general case for n-sided polygons            XYZ a;          XYZ b = polygon[n - 2];          XYZ c = polygon[n - 1];          XYZ s = XYZ.Zero;            for( int i = 0; i < n; ++i )          {            a = b;            b = c;            c = polygon[i];              normal = new XYZ(              normal.X + b.Y * ( c.Z - a.Z )'              normal.Y + b.Z * ( c.X - a.X )'              normal.Z + b.X * ( c.Y - a.Y ) );              s += c;          }          dist = s.DotProduct( normal ) / n;        }
Magic Number,BuildingCoder,CmdWallProfileArea,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallProfileArea.cs,GetPolygonPlane,The following statement contains a magic number: if( 3 == n )        {            // the general case returns a wrong result for the triangle          // ((-1 -1 -1) (1 -1 -1) (-1 -1 1))' so implement specific          // code for triangle:            XYZ a = polygon[0];          XYZ b = polygon[1];          XYZ c = polygon[2];          XYZ v = b - a;          normal = v.CrossProduct( c - a );          dist = normal.DotProduct( a );        }        else if( 4 == n )        {            // more efficient code for 4-sided polygons            XYZ a = polygon[0];          XYZ b = polygon[1];          XYZ c = polygon[2];          XYZ d = polygon[3];            normal = new XYZ(            ( c.Y - a.Y ) * ( d.Z - b.Z ) + ( c.Z - a.Z ) * ( b.Y - d.Y )'            ( c.Z - a.Z ) * ( d.X - b.X ) + ( c.X - a.X ) * ( b.Z - d.Z )'            ( c.X - a.X ) * ( d.Y - b.Y ) + ( c.Y - a.Y ) * ( b.X - d.X ) );            dist = 0.25 *            ( normal.X * ( a.X + b.X + c.X + d.X )            + normal.Y * ( a.Y + b.Y + c.Y + d.Y )            + normal.Z * ( a.Z + b.Z + c.Z + d.Z ) );        }        else if( 4 < n )        {            // general case for n-sided polygons            XYZ a;          XYZ b = polygon[n - 2];          XYZ c = polygon[n - 1];          XYZ s = XYZ.Zero;            for( int i = 0; i < n; ++i )          {            a = b;            b = c;            c = polygon[i];              normal = new XYZ(              normal.X + b.Y * ( c.Z - a.Z )'              normal.Y + b.Z * ( c.X - a.X )'              normal.Z + b.X * ( c.Y - a.Y ) );              s += c;          }          dist = s.DotProduct( normal ) / n;        }
Magic Number,BuildingCoder,CmdWallProfileArea,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallProfileArea.cs,GetPolygonPlane,The following statement contains a magic number: if( 3 == n )        {            // the general case returns a wrong result for the triangle          // ((-1 -1 -1) (1 -1 -1) (-1 -1 1))' so implement specific          // code for triangle:            XYZ a = polygon[0];          XYZ b = polygon[1];          XYZ c = polygon[2];          XYZ v = b - a;          normal = v.CrossProduct( c - a );          dist = normal.DotProduct( a );        }        else if( 4 == n )        {            // more efficient code for 4-sided polygons            XYZ a = polygon[0];          XYZ b = polygon[1];          XYZ c = polygon[2];          XYZ d = polygon[3];            normal = new XYZ(            ( c.Y - a.Y ) * ( d.Z - b.Z ) + ( c.Z - a.Z ) * ( b.Y - d.Y )'            ( c.Z - a.Z ) * ( d.X - b.X ) + ( c.X - a.X ) * ( b.Z - d.Z )'            ( c.X - a.X ) * ( d.Y - b.Y ) + ( c.Y - a.Y ) * ( b.X - d.X ) );            dist = 0.25 *            ( normal.X * ( a.X + b.X + c.X + d.X )            + normal.Y * ( a.Y + b.Y + c.Y + d.Y )            + normal.Z * ( a.Z + b.Z + c.Z + d.Z ) );        }        else if( 4 < n )        {            // general case for n-sided polygons            XYZ a;          XYZ b = polygon[n - 2];          XYZ c = polygon[n - 1];          XYZ s = XYZ.Zero;            for( int i = 0; i < n; ++i )          {            a = b;            b = c;            c = polygon[i];              normal = new XYZ(              normal.X + b.Y * ( c.Z - a.Z )'              normal.Y + b.Z * ( c.X - a.X )'              normal.Z + b.X * ( c.Y - a.Y ) );              s += c;          }          dist = s.DotProduct( normal ) / n;        }
Magic Number,BuildingCoder,CmdWallProfileArea,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallProfileArea.cs,GetPolygonPlane,The following statement contains a magic number: if( 3 == n )        {            // the general case returns a wrong result for the triangle          // ((-1 -1 -1) (1 -1 -1) (-1 -1 1))' so implement specific          // code for triangle:            XYZ a = polygon[0];          XYZ b = polygon[1];          XYZ c = polygon[2];          XYZ v = b - a;          normal = v.CrossProduct( c - a );          dist = normal.DotProduct( a );        }        else if( 4 == n )        {            // more efficient code for 4-sided polygons            XYZ a = polygon[0];          XYZ b = polygon[1];          XYZ c = polygon[2];          XYZ d = polygon[3];            normal = new XYZ(            ( c.Y - a.Y ) * ( d.Z - b.Z ) + ( c.Z - a.Z ) * ( b.Y - d.Y )'            ( c.Z - a.Z ) * ( d.X - b.X ) + ( c.X - a.X ) * ( b.Z - d.Z )'            ( c.X - a.X ) * ( d.Y - b.Y ) + ( c.Y - a.Y ) * ( b.X - d.X ) );            dist = 0.25 *            ( normal.X * ( a.X + b.X + c.X + d.X )            + normal.Y * ( a.Y + b.Y + c.Y + d.Y )            + normal.Z * ( a.Z + b.Z + c.Z + d.Z ) );        }        else if( 4 < n )        {            // general case for n-sided polygons            XYZ a;          XYZ b = polygon[n - 2];          XYZ c = polygon[n - 1];          XYZ s = XYZ.Zero;            for( int i = 0; i < n; ++i )          {            a = b;            b = c;            c = polygon[i];              normal = new XYZ(              normal.X + b.Y * ( c.Z - a.Z )'              normal.Y + b.Z * ( c.X - a.X )'              normal.Z + b.X * ( c.Y - a.Y ) );              s += c;          }          dist = s.DotProduct( normal ) / n;        }
Magic Number,BuildingCoder,CmdWallProfileArea,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallProfileArea.cs,GetPolygonPlane,The following statement contains a magic number: if( rc )        {            // the polygon area is half of the length          // of the non-normalized normal vector of the plane:            double length = normal.GetLength();          rc = !Util.IsZero( length );          Debug.Assert( rc );            if( rc )          {            normal /= length;            dist /= length;            area = 0.5 * length;          }        }
Magic Number,BuildingCoder,CmdWallLayers,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallLayers.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Draw wall layer sepearation lines" );            foreach( Wall wall in walls )          {            string desc = Util.ElementDescription( wall );              LocationCurve curve              = wall.Location as LocationCurve;              if( null == curve )            {              message = desc + ": No wall curve found.";              return Result.Failed;            }              // Wall centre line and thickness:              lcstart = curve.Curve.GetEndPoint( 0 );            lcend = curve.Curve.GetEndPoint( 1 );            halfThickness = 0.5 * wall.WallType.Width;            v = lcend - lcstart;            v = v.Normalize(); // one foot long            w = XYZ.BasisZ.CrossProduct( v ).Normalize();            if( wall.Flipped ) { w = -w; }              p = lcstart - 2 * v;            q = lcend + 2 * v;            Creator.CreateModelLine( doc' p' q );              q = p + halfThickness * w;            Creator.CreateModelLine( doc' p' q );              // Exterior edge              p = lcstart - v + halfThickness * w;            q = lcend + v + halfThickness * w;            Creator.CreateModelLine( doc' p' q );              //CompoundStructure structure = wall.WallType.CompoundStructure; // 2011            CompoundStructure structure = wall.WallType.GetCompoundStructure(); // 2012              if( null == structure )            {              message = desc + ": No compound structure "                + "found. Is this a stacked wall?";                return Result.Failed;            }              //CompoundStructureLayerArray layers = structure.Layers; // 2011            IList<CompoundStructureLayer> layers = structure.GetLayers(); // 2012              //i = 0; // 2011            //n = layers.Size; // 2011            n = layers.Count; // 2012              Debug.Print(              "{0} with thickness {1}"              + " has {2} layer{3}{4}"'              desc'              Util.MmString( 2 * halfThickness )'              n' Util.PluralSuffix( n )'              Util.DotOrColon( n ) );              if( 0 == n )            {              // Interior edge                p = lcstart - v - halfThickness * w;              q = lcend + v - halfThickness * w;              Creator.CreateModelLine( doc' p' q );            }            else            {              layerOffset = halfThickness;              foreach( CompoundStructureLayer layer                in layers )              {                Debug.Print(                  "  Layer {0}: function {1}' "                  + "thickness {2}"'                  //++i' // 2011                  layers.IndexOf( layer )' // 2012                  layer.Function'                  Util.MmString( layer.Width ) );                  //layerOffset -= layer.Thickness; // 2011                layerOffset -= layer.Width; // 2012                  p = lcstart - v + layerOffset * w;                q = lcend + v + layerOffset * w;                Creator.CreateModelLine( doc' p' q );              }            }            tx.Commit();          }        }
Magic Number,BuildingCoder,CmdWallLayers,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallLayers.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Draw wall layer sepearation lines" );            foreach( Wall wall in walls )          {            string desc = Util.ElementDescription( wall );              LocationCurve curve              = wall.Location as LocationCurve;              if( null == curve )            {              message = desc + ": No wall curve found.";              return Result.Failed;            }              // Wall centre line and thickness:              lcstart = curve.Curve.GetEndPoint( 0 );            lcend = curve.Curve.GetEndPoint( 1 );            halfThickness = 0.5 * wall.WallType.Width;            v = lcend - lcstart;            v = v.Normalize(); // one foot long            w = XYZ.BasisZ.CrossProduct( v ).Normalize();            if( wall.Flipped ) { w = -w; }              p = lcstart - 2 * v;            q = lcend + 2 * v;            Creator.CreateModelLine( doc' p' q );              q = p + halfThickness * w;            Creator.CreateModelLine( doc' p' q );              // Exterior edge              p = lcstart - v + halfThickness * w;            q = lcend + v + halfThickness * w;            Creator.CreateModelLine( doc' p' q );              //CompoundStructure structure = wall.WallType.CompoundStructure; // 2011            CompoundStructure structure = wall.WallType.GetCompoundStructure(); // 2012              if( null == structure )            {              message = desc + ": No compound structure "                + "found. Is this a stacked wall?";                return Result.Failed;            }              //CompoundStructureLayerArray layers = structure.Layers; // 2011            IList<CompoundStructureLayer> layers = structure.GetLayers(); // 2012              //i = 0; // 2011            //n = layers.Size; // 2011            n = layers.Count; // 2012              Debug.Print(              "{0} with thickness {1}"              + " has {2} layer{3}{4}"'              desc'              Util.MmString( 2 * halfThickness )'              n' Util.PluralSuffix( n )'              Util.DotOrColon( n ) );              if( 0 == n )            {              // Interior edge                p = lcstart - v - halfThickness * w;              q = lcend + v - halfThickness * w;              Creator.CreateModelLine( doc' p' q );            }            else            {              layerOffset = halfThickness;              foreach( CompoundStructureLayer layer                in layers )              {                Debug.Print(                  "  Layer {0}: function {1}' "                  + "thickness {2}"'                  //++i' // 2011                  layers.IndexOf( layer )' // 2012                  layer.Function'                  Util.MmString( layer.Width ) );                  //layerOffset -= layer.Thickness; // 2011                layerOffset -= layer.Width; // 2012                  p = lcstart - v + layerOffset * w;                q = lcend + v + layerOffset * w;                Creator.CreateModelLine( doc' p' q );              }            }            tx.Commit();          }        }
Magic Number,BuildingCoder,CmdWallLayers,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallLayers.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Draw wall layer sepearation lines" );            foreach( Wall wall in walls )          {            string desc = Util.ElementDescription( wall );              LocationCurve curve              = wall.Location as LocationCurve;              if( null == curve )            {              message = desc + ": No wall curve found.";              return Result.Failed;            }              // Wall centre line and thickness:              lcstart = curve.Curve.GetEndPoint( 0 );            lcend = curve.Curve.GetEndPoint( 1 );            halfThickness = 0.5 * wall.WallType.Width;            v = lcend - lcstart;            v = v.Normalize(); // one foot long            w = XYZ.BasisZ.CrossProduct( v ).Normalize();            if( wall.Flipped ) { w = -w; }              p = lcstart - 2 * v;            q = lcend + 2 * v;            Creator.CreateModelLine( doc' p' q );              q = p + halfThickness * w;            Creator.CreateModelLine( doc' p' q );              // Exterior edge              p = lcstart - v + halfThickness * w;            q = lcend + v + halfThickness * w;            Creator.CreateModelLine( doc' p' q );              //CompoundStructure structure = wall.WallType.CompoundStructure; // 2011            CompoundStructure structure = wall.WallType.GetCompoundStructure(); // 2012              if( null == structure )            {              message = desc + ": No compound structure "                + "found. Is this a stacked wall?";                return Result.Failed;            }              //CompoundStructureLayerArray layers = structure.Layers; // 2011            IList<CompoundStructureLayer> layers = structure.GetLayers(); // 2012              //i = 0; // 2011            //n = layers.Size; // 2011            n = layers.Count; // 2012              Debug.Print(              "{0} with thickness {1}"              + " has {2} layer{3}{4}"'              desc'              Util.MmString( 2 * halfThickness )'              n' Util.PluralSuffix( n )'              Util.DotOrColon( n ) );              if( 0 == n )            {              // Interior edge                p = lcstart - v - halfThickness * w;              q = lcend + v - halfThickness * w;              Creator.CreateModelLine( doc' p' q );            }            else            {              layerOffset = halfThickness;              foreach( CompoundStructureLayer layer                in layers )              {                Debug.Print(                  "  Layer {0}: function {1}' "                  + "thickness {2}"'                  //++i' // 2011                  layers.IndexOf( layer )' // 2012                  layer.Function'                  Util.MmString( layer.Width ) );                  //layerOffset -= layer.Thickness; // 2011                layerOffset -= layer.Width; // 2012                  p = lcstart - v + layerOffset * w;                q = lcend + v + layerOffset * w;                Creator.CreateModelLine( doc' p' q );              }            }            tx.Commit();          }        }
Magic Number,BuildingCoder,CmdWallLayers,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallLayers.cs,Execute,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Draw wall layer sepearation lines" );            foreach( Wall wall in walls )          {            string desc = Util.ElementDescription( wall );              LocationCurve curve              = wall.Location as LocationCurve;              if( null == curve )            {              message = desc + ": No wall curve found.";              return Result.Failed;            }              // Wall centre line and thickness:              lcstart = curve.Curve.GetEndPoint( 0 );            lcend = curve.Curve.GetEndPoint( 1 );            halfThickness = 0.5 * wall.WallType.Width;            v = lcend - lcstart;            v = v.Normalize(); // one foot long            w = XYZ.BasisZ.CrossProduct( v ).Normalize();            if( wall.Flipped ) { w = -w; }              p = lcstart - 2 * v;            q = lcend + 2 * v;            Creator.CreateModelLine( doc' p' q );              q = p + halfThickness * w;            Creator.CreateModelLine( doc' p' q );              // Exterior edge              p = lcstart - v + halfThickness * w;            q = lcend + v + halfThickness * w;            Creator.CreateModelLine( doc' p' q );              //CompoundStructure structure = wall.WallType.CompoundStructure; // 2011            CompoundStructure structure = wall.WallType.GetCompoundStructure(); // 2012              if( null == structure )            {              message = desc + ": No compound structure "                + "found. Is this a stacked wall?";                return Result.Failed;            }              //CompoundStructureLayerArray layers = structure.Layers; // 2011            IList<CompoundStructureLayer> layers = structure.GetLayers(); // 2012              //i = 0; // 2011            //n = layers.Size; // 2011            n = layers.Count; // 2012              Debug.Print(              "{0} with thickness {1}"              + " has {2} layer{3}{4}"'              desc'              Util.MmString( 2 * halfThickness )'              n' Util.PluralSuffix( n )'              Util.DotOrColon( n ) );              if( 0 == n )            {              // Interior edge                p = lcstart - v - halfThickness * w;              q = lcend + v - halfThickness * w;              Creator.CreateModelLine( doc' p' q );            }            else            {              layerOffset = halfThickness;              foreach( CompoundStructureLayer layer                in layers )              {                Debug.Print(                  "  Layer {0}: function {1}' "                  + "thickness {2}"'                  //++i' // 2011                  layers.IndexOf( layer )' // 2012                  layer.Function'                  Util.MmString( layer.Width ) );                  //layerOffset -= layer.Thickness; // 2011                layerOffset -= layer.Width; // 2012                  p = lcstart - v + layerOffset * w;                q = lcend + v + layerOffset * w;                Creator.CreateModelLine( doc' p' q );              }            }            tx.Commit();          }        }
Magic Number,BuildingCoder,CmdWallProfile,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallProfile.cs,Execute2,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Wall Profile" );            // Get the external wall face for the profile            IList<Reference> sideFaces            = HostObjectUtils.GetSideFaces( wall'              ShellLayerType.Exterior );            Element e2 = doc.GetElement( sideFaces[0] );            Face face = e2.GetGeometryObjectFromReference(            sideFaces[0] ) as Face;            // The normal of the wall external face.            XYZ normal = face.ComputeNormal( new UV( 0' 0 ) );            // Offset curve copies for visibility.            Transform offset = Transform.CreateTranslation(            5 * normal );            // If the curve loop direction is counter-          // clockwise' change its color to RED.            Color colorRed = new Color( 255' 0' 0 );            // Get edge loops as curve loops.            IList<CurveLoop> curveLoops            = face.GetEdgesAsCurveLoops();            // ExporterIFCUtils class can also be used for           // non-IFC purposes. The SortCurveLoops method           // sorts curve loops (edge loops) so that the           // outer loops come first.            IList<IList<CurveLoop>> curveLoopLoop            = ExporterIFCUtils.SortCurveLoops(              curveLoops );            foreach( IList<CurveLoop> curveLoops2            in curveLoopLoop )          {            foreach( CurveLoop curveLoop2 in curveLoops2 )            {              // Check if curve loop is counter-clockwise.                bool isCCW = curveLoop2.IsCounterclockwise(                normal );                CurveArray curves = creapp.NewCurveArray();                foreach( Curve curve in curveLoop2 )              {                curves.Append( curve.CreateTransformed( offset ) );              }                // Create model lines for an curve loop.                //Plane plane = creapp.NewPlane( curves ); // 2016                Plane plane = curveLoop2.GetPlane(); // 2017                SketchPlane sketchPlane                = SketchPlane.Create( doc' plane );                ModelCurveArray curveElements                = credoc.NewModelCurveArray( curves'                  sketchPlane );                if( isCCW )              {                foreach( ModelCurve mcurve in curveElements )                {                  OverrideGraphicSettings overrides                    = view.GetElementOverrides(                      mcurve.Id );                    overrides.SetProjectionLineColor(                    colorRed );                    view.SetElementOverrides(                    mcurve.Id' overrides );                }              }            }          }          tx.Commit();        }
Magic Number,BuildingCoder,CmdWallProfile,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallProfile.cs,Execute2,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Wall Profile" );            // Get the external wall face for the profile            IList<Reference> sideFaces            = HostObjectUtils.GetSideFaces( wall'              ShellLayerType.Exterior );            Element e2 = doc.GetElement( sideFaces[0] );            Face face = e2.GetGeometryObjectFromReference(            sideFaces[0] ) as Face;            // The normal of the wall external face.            XYZ normal = face.ComputeNormal( new UV( 0' 0 ) );            // Offset curve copies for visibility.            Transform offset = Transform.CreateTranslation(            5 * normal );            // If the curve loop direction is counter-          // clockwise' change its color to RED.            Color colorRed = new Color( 255' 0' 0 );            // Get edge loops as curve loops.            IList<CurveLoop> curveLoops            = face.GetEdgesAsCurveLoops();            // ExporterIFCUtils class can also be used for           // non-IFC purposes. The SortCurveLoops method           // sorts curve loops (edge loops) so that the           // outer loops come first.            IList<IList<CurveLoop>> curveLoopLoop            = ExporterIFCUtils.SortCurveLoops(              curveLoops );            foreach( IList<CurveLoop> curveLoops2            in curveLoopLoop )          {            foreach( CurveLoop curveLoop2 in curveLoops2 )            {              // Check if curve loop is counter-clockwise.                bool isCCW = curveLoop2.IsCounterclockwise(                normal );                CurveArray curves = creapp.NewCurveArray();                foreach( Curve curve in curveLoop2 )              {                curves.Append( curve.CreateTransformed( offset ) );              }                // Create model lines for an curve loop.                //Plane plane = creapp.NewPlane( curves ); // 2016                Plane plane = curveLoop2.GetPlane(); // 2017                SketchPlane sketchPlane                = SketchPlane.Create( doc' plane );                ModelCurveArray curveElements                = credoc.NewModelCurveArray( curves'                  sketchPlane );                if( isCCW )              {                foreach( ModelCurve mcurve in curveElements )                {                  OverrideGraphicSettings overrides                    = view.GetElementOverrides(                      mcurve.Id );                    overrides.SetProjectionLineColor(                    colorRed );                    view.SetElementOverrides(                    mcurve.Id' overrides );                }              }            }          }          tx.Commit();        }
Magic Number,BuildingCoder,CmdWallProfile,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallProfile.cs,Execute3,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Wall Profile" );            // Get the external wall face for the profile          // a little bit simpler than in the last realization            Reference sideFaceReference            = HostObjectUtils.GetSideFaces(              wall' ShellLayerType.Exterior )                .First();            Face face = wall.GetGeometryObjectFromReference(            sideFaceReference ) as Face;            // The normal of the wall external face.            XYZ normal = wall.Orientation;            // Offset curve copies for visibility.            Transform offset = Transform.CreateTranslation(            5 * normal );            // If the curve loop direction is counter-          // clockwise' change its color to RED.            Color colorRed = new Color( 255' 0' 0 );            // Get edge loops as curve loops.            IList<CurveLoop> curveLoops            = face.GetEdgesAsCurveLoops();            foreach( var curveLoop in curveLoops )          {            CurveArray curves = creapp.NewCurveArray();              foreach( Curve curve in curveLoop )              curves.Append( curve.CreateTransformed(                offset ) );              var isCounterClockwize = curveLoop              .IsCounterclockwise( normal );              // Create model lines for an curve loop if it is made               if( ( (LocationCurve) wall.Location ).Curve              is Line )            {              //Plane plane = creapp.NewPlane( curves ); // 2016              Plane plane = CurveLoop.CreateViaOffset(                curveLoop' 5 * normal.GetLength()'                normal.Normalize() ).GetPlane(); // 2017                SketchPlane sketchPlane                = SketchPlane.Create( doc' plane );                ModelCurveArray curveElements = credoc                .NewModelCurveArray( curves' sketchPlane );                if( isCounterClockwize )              {                SetModelCurvesColor( curveElements'                  view' colorRed );              }            }            else            {              foreach( var curve in curves.Cast<Curve>() )              {                var curveElements = creator.CreateModelCurves( curve );                if( isCounterClockwize )                {                  SetModelCurvesColor( curveElements' view' colorRed );                }              }            }          }          tx.Commit();        }
Magic Number,BuildingCoder,CmdWallProfile,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallProfile.cs,Execute3,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Wall Profile" );            // Get the external wall face for the profile          // a little bit simpler than in the last realization            Reference sideFaceReference            = HostObjectUtils.GetSideFaces(              wall' ShellLayerType.Exterior )                .First();            Face face = wall.GetGeometryObjectFromReference(            sideFaceReference ) as Face;            // The normal of the wall external face.            XYZ normal = wall.Orientation;            // Offset curve copies for visibility.            Transform offset = Transform.CreateTranslation(            5 * normal );            // If the curve loop direction is counter-          // clockwise' change its color to RED.            Color colorRed = new Color( 255' 0' 0 );            // Get edge loops as curve loops.            IList<CurveLoop> curveLoops            = face.GetEdgesAsCurveLoops();            foreach( var curveLoop in curveLoops )          {            CurveArray curves = creapp.NewCurveArray();              foreach( Curve curve in curveLoop )              curves.Append( curve.CreateTransformed(                offset ) );              var isCounterClockwize = curveLoop              .IsCounterclockwise( normal );              // Create model lines for an curve loop if it is made               if( ( (LocationCurve) wall.Location ).Curve              is Line )            {              //Plane plane = creapp.NewPlane( curves ); // 2016              Plane plane = CurveLoop.CreateViaOffset(                curveLoop' 5 * normal.GetLength()'                normal.Normalize() ).GetPlane(); // 2017                SketchPlane sketchPlane                = SketchPlane.Create( doc' plane );                ModelCurveArray curveElements = credoc                .NewModelCurveArray( curves' sketchPlane );                if( isCounterClockwize )              {                SetModelCurvesColor( curveElements'                  view' colorRed );              }            }            else            {              foreach( var curve in curves.Cast<Curve>() )              {                var curveElements = creator.CreateModelCurves( curve );                if( isCounterClockwize )                {                  SetModelCurvesColor( curveElements' view' colorRed );                }              }            }          }          tx.Commit();        }
Magic Number,BuildingCoder,CmdWallProfile,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallProfile.cs,Execute3,The following statement contains a magic number: using( Transaction tx = new Transaction( doc ) )        {          tx.Start( "Wall Profile" );            // Get the external wall face for the profile          // a little bit simpler than in the last realization            Reference sideFaceReference            = HostObjectUtils.GetSideFaces(              wall' ShellLayerType.Exterior )                .First();            Face face = wall.GetGeometryObjectFromReference(            sideFaceReference ) as Face;            // The normal of the wall external face.            XYZ normal = wall.Orientation;            // Offset curve copies for visibility.            Transform offset = Transform.CreateTranslation(            5 * normal );            // If the curve loop direction is counter-          // clockwise' change its color to RED.            Color colorRed = new Color( 255' 0' 0 );            // Get edge loops as curve loops.            IList<CurveLoop> curveLoops            = face.GetEdgesAsCurveLoops();            foreach( var curveLoop in curveLoops )          {            CurveArray curves = creapp.NewCurveArray();              foreach( Curve curve in curveLoop )              curves.Append( curve.CreateTransformed(                offset ) );              var isCounterClockwize = curveLoop              .IsCounterclockwise( normal );              // Create model lines for an curve loop if it is made               if( ( (LocationCurve) wall.Location ).Curve              is Line )            {              //Plane plane = creapp.NewPlane( curves ); // 2016              Plane plane = CurveLoop.CreateViaOffset(                curveLoop' 5 * normal.GetLength()'                normal.Normalize() ).GetPlane(); // 2017                SketchPlane sketchPlane                = SketchPlane.Create( doc' plane );                ModelCurveArray curveElements = credoc                .NewModelCurveArray( curves' sketchPlane );                if( isCounterClockwize )              {                SetModelCurvesColor( curveElements'                  view' colorRed );              }            }            else            {              foreach( var curve in curves.Cast<Curve>() )              {                var curveElements = creator.CreateModelCurves( curve );                if( isCounterClockwize )                {                  SetModelCurvesColor( curveElements' view' colorRed );                }              }            }          }          tx.Commit();        }
Magic Number,BuildingCoder,CmdWallProfile,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallProfile.cs,Execute,The following statement contains a magic number: int use_execute_nr = 3;
Magic Number,BuildingCoder,CmdWallProfile,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallProfile.cs,Execute,The following statement contains a magic number: switch( use_execute_nr )        {          case 1: return Execute1( cd' ref msg' els );          case 2: return Execute2( cd' ref msg' els );          case 3: return Execute3( cd' ref msg' els );        }
Magic Number,BuildingCoder,CmdWallProfile,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallProfile.cs,Execute,The following statement contains a magic number: switch( use_execute_nr )        {          case 1: return Execute1( cd' ref msg' els );          case 2: return Execute2( cd' ref msg' els );          case 3: return Execute3( cd' ref msg' els );        }
Magic Number,BuildingCoder,CmdWallTopFaces,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallTopFaces.cs,IsTopFace,The following statement contains a magic number: UV midpoint = p + 0.5 * ( q - p );
Magic Number,BuildingCoder,CmdWallTopFaces,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallTopFaces.cs,Execute,The following statement contains a magic number: XyzEqualityComparer comparer          = new XyzEqualityComparer( 1e-6 );
Magic Number,BuildingCoder,CmdWindowHandleForm,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWindowHandleForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point( 13' 13 );
Magic Number,BuildingCoder,CmdWindowHandleForm,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWindowHandleForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point( 13' 13 );
Magic Number,BuildingCoder,CmdWindowHandleForm,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWindowHandleForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size( 35' 13 );
Magic Number,BuildingCoder,CmdWindowHandleForm,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWindowHandleForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size( 35' 13 );
Magic Number,BuildingCoder,CmdWindowHandleForm,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWindowHandleForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size( 221' 183 );
Magic Number,BuildingCoder,CmdWindowHandleForm,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWindowHandleForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size( 221' 183 );
Magic Number,BuildingCoder,CmdCropToRoom,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCropToRoom.cs,Execute,The following statement contains a magic number: using ( Transaction t = new Transaction( doc ) )        {          t.Start( "Crop to Room" );            // get the 3d view crop box:            BoundingBoxXYZ bb = view3d.CropBox;            // get the transform from the current view          // to the 3D model:            Transform transform = bb.Transform;            // get the transform from the 3D model          // to the current view:            Transform transformInverse = transform.Inverse;            // get all rooms in the model:            FilteredElementCollector collector            = new FilteredElementCollector( doc );            collector.OfClass( typeof( Room ) );          IList<Element> rooms = collector.ToElements();          int n = rooms.Count;            Room room = ( 0 < n )            ? rooms[BumpRoomIndex( n )] as Room            : null;            if ( null == room )          {            message = "No room element found in project.";            return Result.Failed;          }            // Collect all vertices of room closed shell          // to determine its extents:            GeometryElement e = room.ClosedShell;          List<XYZ> vertices = new List<XYZ>();            //foreach( GeometryObject o in e.Objects ) // 2012            foreach ( GeometryObject o in e ) // 2013          {            if ( o is Solid )            {              // Iterate over all the edges of all solids:                Solid solid = o as Solid;                foreach ( Edge edge in solid.Edges )              {                foreach ( XYZ p in edge.Tessellate() )                {                  // Collect all vertices'                  // including duplicates:                    vertices.Add( p );                }              }            }          }            List<XYZ> verticesIn3dView = new List<XYZ>();            foreach ( XYZ p in vertices )          {            verticesIn3dView.Add(              transformInverse.OfPoint( p ) );          }            // Ignore the Z coorindates and find the          // min and max X and Y in the 3d view:            double xMin = 0' yMin = 0' xMax = 0' yMax = 0;            bool first = true;          foreach ( XYZ p in verticesIn3dView )          {            if ( first )            {              xMin = p.X;              yMin = p.Y;              xMax = p.X;              yMax = p.Y;              first = false;            }            else            {              if ( xMin > p.X )                xMin = p.X;              if ( yMin > p.Y )                yMin = p.Y;              if ( xMax < p.X )                xMax = p.X;              if ( yMax < p.Y )                yMax = p.Y;            }          }            // Grow the crop box by one twentieth of its          // size to include the walls of the room:            double d = 0.05 * ( xMax - xMin );          xMin = xMin - d;          xMax = xMax + d;            d = 0.05 * ( yMax - yMin );          yMin = yMin - d;          yMax = yMax + d;            bb.Max = new XYZ( xMax' yMax' bb.Max.Z );          bb.Min = new XYZ( xMin' yMin' bb.Min.Z );            view3d.CropBox = bb;            // Change the crop view setting manually or          // programmatically to see the result:            view3d.CropBoxActive = true;          view3d.CropBoxVisible = true;          t.Commit();        }
Magic Number,BuildingCoder,CmdCropToRoom,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCropToRoom.cs,Execute,The following statement contains a magic number: using ( Transaction t = new Transaction( doc ) )        {          t.Start( "Crop to Room" );            // get the 3d view crop box:            BoundingBoxXYZ bb = view3d.CropBox;            // get the transform from the current view          // to the 3D model:            Transform transform = bb.Transform;            // get the transform from the 3D model          // to the current view:            Transform transformInverse = transform.Inverse;            // get all rooms in the model:            FilteredElementCollector collector            = new FilteredElementCollector( doc );            collector.OfClass( typeof( Room ) );          IList<Element> rooms = collector.ToElements();          int n = rooms.Count;            Room room = ( 0 < n )            ? rooms[BumpRoomIndex( n )] as Room            : null;            if ( null == room )          {            message = "No room element found in project.";            return Result.Failed;          }            // Collect all vertices of room closed shell          // to determine its extents:            GeometryElement e = room.ClosedShell;          List<XYZ> vertices = new List<XYZ>();            //foreach( GeometryObject o in e.Objects ) // 2012            foreach ( GeometryObject o in e ) // 2013          {            if ( o is Solid )            {              // Iterate over all the edges of all solids:                Solid solid = o as Solid;                foreach ( Edge edge in solid.Edges )              {                foreach ( XYZ p in edge.Tessellate() )                {                  // Collect all vertices'                  // including duplicates:                    vertices.Add( p );                }              }            }          }            List<XYZ> verticesIn3dView = new List<XYZ>();            foreach ( XYZ p in vertices )          {            verticesIn3dView.Add(              transformInverse.OfPoint( p ) );          }            // Ignore the Z coorindates and find the          // min and max X and Y in the 3d view:            double xMin = 0' yMin = 0' xMax = 0' yMax = 0;            bool first = true;          foreach ( XYZ p in verticesIn3dView )          {            if ( first )            {              xMin = p.X;              yMin = p.Y;              xMax = p.X;              yMax = p.Y;              first = false;            }            else            {              if ( xMin > p.X )                xMin = p.X;              if ( yMin > p.Y )                yMin = p.Y;              if ( xMax < p.X )                xMax = p.X;              if ( yMax < p.Y )                yMax = p.Y;            }          }            // Grow the crop box by one twentieth of its          // size to include the walls of the room:            double d = 0.05 * ( xMax - xMin );          xMin = xMin - d;          xMax = xMax + d;            d = 0.05 * ( yMax - yMin );          yMin = yMin - d;          yMax = yMax + d;            bb.Max = new XYZ( xMax' yMax' bb.Max.Z );          bb.Min = new XYZ( xMin' yMin' bb.Min.Z );            view3d.CropBox = bb;            // Change the crop view setting manually or          // programmatically to see the result:            view3d.CropBoxActive = true;          view3d.CropBoxVisible = true;          t.Commit();        }
Magic Number,BuildingCoder,Creator,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Creator.cs,GetCurveNormal,The following statement contains a magic number: if( 2 == n )        {          Debug.Assert( curve is Line'            "expected non-line element to have "            + "more than two tessellation points" );            // For non-vertical lines' use Z axis to          // span the plane' otherwise Y axis:            double dxy = Math.Abs( v.X ) + Math.Abs( v.Y );            w = ( dxy > Util.TolPointOnPlane )            ? XYZ.BasisZ            : XYZ.BasisY;            normal = v.CrossProduct( w ).Normalize();        }        else        {          int i = 0;          while( ++i < n - 1 )          {            w = pts[i] - p;            normal = v.CrossProduct( w );            if( !normal.IsZeroLength() )            {              normal = normal.Normalize();              break;            }          }    #if DEBUG          {            XYZ normal2;            while( ++i < n - 1 )            {              w = pts[i] - p;              normal2 = v.CrossProduct( w );              Debug.Assert( normal2.IsZeroLength()                || Util.IsZero( normal2.AngleTo( normal ) )'                "expected all points of curve to "                + "lie in same plane" );            }          }  #endif // DEBUG          }
Magic Number,BuildingCoder,Creator,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Creator.cs,DrawFaceTriangleNormals,The following statement contains a magic number: for( int i = 0; i < n; ++i )        {          MeshTriangle t = mesh.get_Triangle( i );            XYZ p = ( t.get_Vertex( 0 )            + t.get_Vertex( 1 )            + t.get_Vertex( 2 ) ) / 3;            XYZ v = t.get_Vertex( 1 )            - t.get_Vertex( 0 );            XYZ w = t.get_Vertex( 2 )            - t.get_Vertex( 0 );            XYZ normal = v.CrossProduct( w ).Normalize();            Debug.Print(            "{0} {1} --> {2}"' i'            Util.PointString( p )'            Util.PointString( normal ) );            CreateModelLine( _doc' p' p + normal );        }
Magic Number,BuildingCoder,Creator,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Creator.cs,DrawFaceTriangleNormals,The following statement contains a magic number: for( int i = 0; i < n; ++i )        {          MeshTriangle t = mesh.get_Triangle( i );            XYZ p = ( t.get_Vertex( 0 )            + t.get_Vertex( 1 )            + t.get_Vertex( 2 ) ) / 3;            XYZ v = t.get_Vertex( 1 )            - t.get_Vertex( 0 );            XYZ w = t.get_Vertex( 2 )            - t.get_Vertex( 0 );            XYZ normal = v.CrossProduct( w ).Normalize();            Debug.Print(            "{0} {1} --> {2}"' i'            Util.PointString( p )'            Util.PointString( normal ) );            CreateModelLine( _doc' p' p + normal );        }
Magic Number,BuildingCoder,Creator,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Creator.cs,DrawFaceTriangleNormals,The following statement contains a magic number: for( int i = 0; i < n; ++i )        {          MeshTriangle t = mesh.get_Triangle( i );            XYZ p = ( t.get_Vertex( 0 )            + t.get_Vertex( 1 )            + t.get_Vertex( 2 ) ) / 3;            XYZ v = t.get_Vertex( 1 )            - t.get_Vertex( 0 );            XYZ w = t.get_Vertex( 2 )            - t.get_Vertex( 0 );            XYZ normal = v.CrossProduct( w ).Normalize();            Debug.Print(            "{0} {1} --> {2}"' i'            Util.PointString( p )'            Util.PointString( normal ) );            CreateModelLine( _doc' p' p + normal );        }
Magic Number,BuildingCoder,JtPairPicker<T>,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\JtPairPicker.cs,Pick,The following statement contains a magic number: if( 2 > n )        {          return Result.Failed;        }
Magic Number,BuildingCoder,JtPairPicker<T>,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\JtPairPicker.cs,Pick,The following statement contains a magic number: if( 2 == n )        {          return Result.Succeeded;        }
Magic Number,BuildingCoder,JtPairPicker<T>,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\JtPairPicker.cs,Pick,The following statement contains a magic number: if( 1 < n )        {          foreach( ElementId id in ids )          {            T e = _doc.GetElement( id ) as T;              Debug.Assert( null != e'              "only elements of type T can be picked" );              _a.Add( e );              if( 2 == _a.Count )            {              Debug.Print( "Found two pre-selected "                + "elements of desired type and "                + "ignoring everything else." );                break;            }          }        }
Magic Number,BuildingCoder,JtPairPicker<T>,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\JtPairPicker.cs,Pick,The following statement contains a magic number: if( 2 != _a.Count )        {          _a.Clear();            // Select first element.            ISelectionFilter filter             = new JtElementsOfClassSelectionFilter<T>();            try          {            Reference r = sel.PickObject(              ObjectType.Element' filter'              "Please pick first element." );              _a.Add( _doc.GetElement( r.ElementId )              as T );          }          catch( Autodesk.Revit.Exceptions            .OperationCanceledException )          {            return Result.Cancelled;          }            // Select second element.            try          {            Reference r = sel.PickObject(              ObjectType.Element' filter'              "Please pick second element." );              _a.Add( _doc.GetElement( r.ElementId )              as T );          }          catch( Autodesk.Revit.Exceptions            .OperationCanceledException )          {            return Result.Cancelled;          }        }
Magic Number,BuildingCoder,TimeRegistry,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\JtTimer.cs,GetPercent,The following statement contains a magic number: return 0 == totalTime            ? 0            : Math.Round( value * 100 / totalTime' 2 );
Magic Number,BuildingCoder,TimeRegistry,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\JtTimer.cs,GetPercent,The following statement contains a magic number: return 0 == totalTime            ? 0            : Math.Round( value * 100 / totalTime' 2 );
Magic Number,BuildingCoder,TimeRegistry,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\JtTimer.cs,WriteResults,The following statement contains a magic number: foreach( KeyValuePair<string' Entry> pair in _collection )          {            Entry e = pair.Value;            lines.Add( string.Format( "{0'10:0.00}%{1'10:0.00}{2'8}   {3}"'              GetPercent( e.Time' totalTime )'              Math.Round( e.Time' 2 )'              e.Calls'              pair.Key ) );          }
Magic Number,BuildingCoder,ParameterUnitConverter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\ParameterUnitConverter.cs,AsProjectUnitTypeDouble,The following statement contains a magic number: switch (dut)        {          #region Length            case DisplayUnitType.DUT_METERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_CENTIMETERS:            return imperialValue * METERS_IN_FEET * 100;          case DisplayUnitType.DUT_DECIMAL_FEET:            return imperialValue;          case DisplayUnitType.DUT_DECIMAL_INCHES:            return imperialValue * 12;          case DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_METERS_CENTIMETERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_MILLIMETERS:            return imperialValue * METERS_IN_FEET * 1000;            #endregion // Length            #region Area            case DisplayUnitType.DUT_SQUARE_FEET:            return imperialValue;          case DisplayUnitType.DUT_ACRES:            return imperialValue * 1 / 43560.039;          case DisplayUnitType.DUT_HECTARES:            return imperialValue * 1 / 107639.104;          case DisplayUnitType.DUT_SQUARE_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 2);          case DisplayUnitType.DUT_SQUARE_INCHES:            return imperialValue * Math.Pow(12' 2);          case DisplayUnitType.DUT_SQUARE_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 2);          case DisplayUnitType.DUT_SQUARE_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 2);            #endregion // Area            #region Volume          case DisplayUnitType.DUT_CUBIC_FEET:            return imperialValue;          case DisplayUnitType.DUT_CUBIC_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 3);          case DisplayUnitType.DUT_CUBIC_INCHES:            return imperialValue * Math.Pow(12' 3);          case DisplayUnitType.DUT_CUBIC_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 3);          case DisplayUnitType.DUT_CUBIC_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 3);          case DisplayUnitType.DUT_CUBIC_YARDS:            return imperialValue * 1 / Math.Pow(3' 3);          case DisplayUnitType.DUT_GALLONS_US:            return imperialValue * 7.5;          case DisplayUnitType.DUT_LITERS:            return imperialValue * 28.31684;            #endregion // Volume            default:            NotSupported(dut);            break;        }
Magic Number,BuildingCoder,ParameterUnitConverter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\ParameterUnitConverter.cs,AsProjectUnitTypeDouble,The following statement contains a magic number: switch (dut)        {          #region Length            case DisplayUnitType.DUT_METERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_CENTIMETERS:            return imperialValue * METERS_IN_FEET * 100;          case DisplayUnitType.DUT_DECIMAL_FEET:            return imperialValue;          case DisplayUnitType.DUT_DECIMAL_INCHES:            return imperialValue * 12;          case DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_METERS_CENTIMETERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_MILLIMETERS:            return imperialValue * METERS_IN_FEET * 1000;            #endregion // Length            #region Area            case DisplayUnitType.DUT_SQUARE_FEET:            return imperialValue;          case DisplayUnitType.DUT_ACRES:            return imperialValue * 1 / 43560.039;          case DisplayUnitType.DUT_HECTARES:            return imperialValue * 1 / 107639.104;          case DisplayUnitType.DUT_SQUARE_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 2);          case DisplayUnitType.DUT_SQUARE_INCHES:            return imperialValue * Math.Pow(12' 2);          case DisplayUnitType.DUT_SQUARE_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 2);          case DisplayUnitType.DUT_SQUARE_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 2);            #endregion // Area            #region Volume          case DisplayUnitType.DUT_CUBIC_FEET:            return imperialValue;          case DisplayUnitType.DUT_CUBIC_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 3);          case DisplayUnitType.DUT_CUBIC_INCHES:            return imperialValue * Math.Pow(12' 3);          case DisplayUnitType.DUT_CUBIC_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 3);          case DisplayUnitType.DUT_CUBIC_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 3);          case DisplayUnitType.DUT_CUBIC_YARDS:            return imperialValue * 1 / Math.Pow(3' 3);          case DisplayUnitType.DUT_GALLONS_US:            return imperialValue * 7.5;          case DisplayUnitType.DUT_LITERS:            return imperialValue * 28.31684;            #endregion // Volume            default:            NotSupported(dut);            break;        }
Magic Number,BuildingCoder,ParameterUnitConverter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\ParameterUnitConverter.cs,AsProjectUnitTypeDouble,The following statement contains a magic number: switch (dut)        {          #region Length            case DisplayUnitType.DUT_METERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_CENTIMETERS:            return imperialValue * METERS_IN_FEET * 100;          case DisplayUnitType.DUT_DECIMAL_FEET:            return imperialValue;          case DisplayUnitType.DUT_DECIMAL_INCHES:            return imperialValue * 12;          case DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_METERS_CENTIMETERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_MILLIMETERS:            return imperialValue * METERS_IN_FEET * 1000;            #endregion // Length            #region Area            case DisplayUnitType.DUT_SQUARE_FEET:            return imperialValue;          case DisplayUnitType.DUT_ACRES:            return imperialValue * 1 / 43560.039;          case DisplayUnitType.DUT_HECTARES:            return imperialValue * 1 / 107639.104;          case DisplayUnitType.DUT_SQUARE_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 2);          case DisplayUnitType.DUT_SQUARE_INCHES:            return imperialValue * Math.Pow(12' 2);          case DisplayUnitType.DUT_SQUARE_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 2);          case DisplayUnitType.DUT_SQUARE_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 2);            #endregion // Area            #region Volume          case DisplayUnitType.DUT_CUBIC_FEET:            return imperialValue;          case DisplayUnitType.DUT_CUBIC_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 3);          case DisplayUnitType.DUT_CUBIC_INCHES:            return imperialValue * Math.Pow(12' 3);          case DisplayUnitType.DUT_CUBIC_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 3);          case DisplayUnitType.DUT_CUBIC_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 3);          case DisplayUnitType.DUT_CUBIC_YARDS:            return imperialValue * 1 / Math.Pow(3' 3);          case DisplayUnitType.DUT_GALLONS_US:            return imperialValue * 7.5;          case DisplayUnitType.DUT_LITERS:            return imperialValue * 28.31684;            #endregion // Volume            default:            NotSupported(dut);            break;        }
Magic Number,BuildingCoder,ParameterUnitConverter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\ParameterUnitConverter.cs,AsProjectUnitTypeDouble,The following statement contains a magic number: switch (dut)        {          #region Length            case DisplayUnitType.DUT_METERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_CENTIMETERS:            return imperialValue * METERS_IN_FEET * 100;          case DisplayUnitType.DUT_DECIMAL_FEET:            return imperialValue;          case DisplayUnitType.DUT_DECIMAL_INCHES:            return imperialValue * 12;          case DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_METERS_CENTIMETERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_MILLIMETERS:            return imperialValue * METERS_IN_FEET * 1000;            #endregion // Length            #region Area            case DisplayUnitType.DUT_SQUARE_FEET:            return imperialValue;          case DisplayUnitType.DUT_ACRES:            return imperialValue * 1 / 43560.039;          case DisplayUnitType.DUT_HECTARES:            return imperialValue * 1 / 107639.104;          case DisplayUnitType.DUT_SQUARE_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 2);          case DisplayUnitType.DUT_SQUARE_INCHES:            return imperialValue * Math.Pow(12' 2);          case DisplayUnitType.DUT_SQUARE_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 2);          case DisplayUnitType.DUT_SQUARE_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 2);            #endregion // Area            #region Volume          case DisplayUnitType.DUT_CUBIC_FEET:            return imperialValue;          case DisplayUnitType.DUT_CUBIC_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 3);          case DisplayUnitType.DUT_CUBIC_INCHES:            return imperialValue * Math.Pow(12' 3);          case DisplayUnitType.DUT_CUBIC_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 3);          case DisplayUnitType.DUT_CUBIC_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 3);          case DisplayUnitType.DUT_CUBIC_YARDS:            return imperialValue * 1 / Math.Pow(3' 3);          case DisplayUnitType.DUT_GALLONS_US:            return imperialValue * 7.5;          case DisplayUnitType.DUT_LITERS:            return imperialValue * 28.31684;            #endregion // Volume            default:            NotSupported(dut);            break;        }
Magic Number,BuildingCoder,ParameterUnitConverter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\ParameterUnitConverter.cs,AsProjectUnitTypeDouble,The following statement contains a magic number: switch (dut)        {          #region Length            case DisplayUnitType.DUT_METERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_CENTIMETERS:            return imperialValue * METERS_IN_FEET * 100;          case DisplayUnitType.DUT_DECIMAL_FEET:            return imperialValue;          case DisplayUnitType.DUT_DECIMAL_INCHES:            return imperialValue * 12;          case DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_METERS_CENTIMETERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_MILLIMETERS:            return imperialValue * METERS_IN_FEET * 1000;            #endregion // Length            #region Area            case DisplayUnitType.DUT_SQUARE_FEET:            return imperialValue;          case DisplayUnitType.DUT_ACRES:            return imperialValue * 1 / 43560.039;          case DisplayUnitType.DUT_HECTARES:            return imperialValue * 1 / 107639.104;          case DisplayUnitType.DUT_SQUARE_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 2);          case DisplayUnitType.DUT_SQUARE_INCHES:            return imperialValue * Math.Pow(12' 2);          case DisplayUnitType.DUT_SQUARE_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 2);          case DisplayUnitType.DUT_SQUARE_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 2);            #endregion // Area            #region Volume          case DisplayUnitType.DUT_CUBIC_FEET:            return imperialValue;          case DisplayUnitType.DUT_CUBIC_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 3);          case DisplayUnitType.DUT_CUBIC_INCHES:            return imperialValue * Math.Pow(12' 3);          case DisplayUnitType.DUT_CUBIC_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 3);          case DisplayUnitType.DUT_CUBIC_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 3);          case DisplayUnitType.DUT_CUBIC_YARDS:            return imperialValue * 1 / Math.Pow(3' 3);          case DisplayUnitType.DUT_GALLONS_US:            return imperialValue * 7.5;          case DisplayUnitType.DUT_LITERS:            return imperialValue * 28.31684;            #endregion // Volume            default:            NotSupported(dut);            break;        }
Magic Number,BuildingCoder,ParameterUnitConverter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\ParameterUnitConverter.cs,AsProjectUnitTypeDouble,The following statement contains a magic number: switch (dut)        {          #region Length            case DisplayUnitType.DUT_METERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_CENTIMETERS:            return imperialValue * METERS_IN_FEET * 100;          case DisplayUnitType.DUT_DECIMAL_FEET:            return imperialValue;          case DisplayUnitType.DUT_DECIMAL_INCHES:            return imperialValue * 12;          case DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_METERS_CENTIMETERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_MILLIMETERS:            return imperialValue * METERS_IN_FEET * 1000;            #endregion // Length            #region Area            case DisplayUnitType.DUT_SQUARE_FEET:            return imperialValue;          case DisplayUnitType.DUT_ACRES:            return imperialValue * 1 / 43560.039;          case DisplayUnitType.DUT_HECTARES:            return imperialValue * 1 / 107639.104;          case DisplayUnitType.DUT_SQUARE_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 2);          case DisplayUnitType.DUT_SQUARE_INCHES:            return imperialValue * Math.Pow(12' 2);          case DisplayUnitType.DUT_SQUARE_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 2);          case DisplayUnitType.DUT_SQUARE_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 2);            #endregion // Area            #region Volume          case DisplayUnitType.DUT_CUBIC_FEET:            return imperialValue;          case DisplayUnitType.DUT_CUBIC_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 3);          case DisplayUnitType.DUT_CUBIC_INCHES:            return imperialValue * Math.Pow(12' 3);          case DisplayUnitType.DUT_CUBIC_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 3);          case DisplayUnitType.DUT_CUBIC_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 3);          case DisplayUnitType.DUT_CUBIC_YARDS:            return imperialValue * 1 / Math.Pow(3' 3);          case DisplayUnitType.DUT_GALLONS_US:            return imperialValue * 7.5;          case DisplayUnitType.DUT_LITERS:            return imperialValue * 28.31684;            #endregion // Volume            default:            NotSupported(dut);            break;        }
Magic Number,BuildingCoder,ParameterUnitConverter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\ParameterUnitConverter.cs,AsProjectUnitTypeDouble,The following statement contains a magic number: switch (dut)        {          #region Length            case DisplayUnitType.DUT_METERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_CENTIMETERS:            return imperialValue * METERS_IN_FEET * 100;          case DisplayUnitType.DUT_DECIMAL_FEET:            return imperialValue;          case DisplayUnitType.DUT_DECIMAL_INCHES:            return imperialValue * 12;          case DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_METERS_CENTIMETERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_MILLIMETERS:            return imperialValue * METERS_IN_FEET * 1000;            #endregion // Length            #region Area            case DisplayUnitType.DUT_SQUARE_FEET:            return imperialValue;          case DisplayUnitType.DUT_ACRES:            return imperialValue * 1 / 43560.039;          case DisplayUnitType.DUT_HECTARES:            return imperialValue * 1 / 107639.104;          case DisplayUnitType.DUT_SQUARE_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 2);          case DisplayUnitType.DUT_SQUARE_INCHES:            return imperialValue * Math.Pow(12' 2);          case DisplayUnitType.DUT_SQUARE_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 2);          case DisplayUnitType.DUT_SQUARE_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 2);            #endregion // Area            #region Volume          case DisplayUnitType.DUT_CUBIC_FEET:            return imperialValue;          case DisplayUnitType.DUT_CUBIC_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 3);          case DisplayUnitType.DUT_CUBIC_INCHES:            return imperialValue * Math.Pow(12' 3);          case DisplayUnitType.DUT_CUBIC_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 3);          case DisplayUnitType.DUT_CUBIC_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 3);          case DisplayUnitType.DUT_CUBIC_YARDS:            return imperialValue * 1 / Math.Pow(3' 3);          case DisplayUnitType.DUT_GALLONS_US:            return imperialValue * 7.5;          case DisplayUnitType.DUT_LITERS:            return imperialValue * 28.31684;            #endregion // Volume            default:            NotSupported(dut);            break;        }
Magic Number,BuildingCoder,ParameterUnitConverter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\ParameterUnitConverter.cs,AsProjectUnitTypeDouble,The following statement contains a magic number: switch (dut)        {          #region Length            case DisplayUnitType.DUT_METERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_CENTIMETERS:            return imperialValue * METERS_IN_FEET * 100;          case DisplayUnitType.DUT_DECIMAL_FEET:            return imperialValue;          case DisplayUnitType.DUT_DECIMAL_INCHES:            return imperialValue * 12;          case DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_METERS_CENTIMETERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_MILLIMETERS:            return imperialValue * METERS_IN_FEET * 1000;            #endregion // Length            #region Area            case DisplayUnitType.DUT_SQUARE_FEET:            return imperialValue;          case DisplayUnitType.DUT_ACRES:            return imperialValue * 1 / 43560.039;          case DisplayUnitType.DUT_HECTARES:            return imperialValue * 1 / 107639.104;          case DisplayUnitType.DUT_SQUARE_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 2);          case DisplayUnitType.DUT_SQUARE_INCHES:            return imperialValue * Math.Pow(12' 2);          case DisplayUnitType.DUT_SQUARE_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 2);          case DisplayUnitType.DUT_SQUARE_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 2);            #endregion // Area            #region Volume          case DisplayUnitType.DUT_CUBIC_FEET:            return imperialValue;          case DisplayUnitType.DUT_CUBIC_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 3);          case DisplayUnitType.DUT_CUBIC_INCHES:            return imperialValue * Math.Pow(12' 3);          case DisplayUnitType.DUT_CUBIC_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 3);          case DisplayUnitType.DUT_CUBIC_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 3);          case DisplayUnitType.DUT_CUBIC_YARDS:            return imperialValue * 1 / Math.Pow(3' 3);          case DisplayUnitType.DUT_GALLONS_US:            return imperialValue * 7.5;          case DisplayUnitType.DUT_LITERS:            return imperialValue * 28.31684;            #endregion // Volume            default:            NotSupported(dut);            break;        }
Magic Number,BuildingCoder,ParameterUnitConverter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\ParameterUnitConverter.cs,AsProjectUnitTypeDouble,The following statement contains a magic number: switch (dut)        {          #region Length            case DisplayUnitType.DUT_METERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_CENTIMETERS:            return imperialValue * METERS_IN_FEET * 100;          case DisplayUnitType.DUT_DECIMAL_FEET:            return imperialValue;          case DisplayUnitType.DUT_DECIMAL_INCHES:            return imperialValue * 12;          case DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_METERS_CENTIMETERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_MILLIMETERS:            return imperialValue * METERS_IN_FEET * 1000;            #endregion // Length            #region Area            case DisplayUnitType.DUT_SQUARE_FEET:            return imperialValue;          case DisplayUnitType.DUT_ACRES:            return imperialValue * 1 / 43560.039;          case DisplayUnitType.DUT_HECTARES:            return imperialValue * 1 / 107639.104;          case DisplayUnitType.DUT_SQUARE_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 2);          case DisplayUnitType.DUT_SQUARE_INCHES:            return imperialValue * Math.Pow(12' 2);          case DisplayUnitType.DUT_SQUARE_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 2);          case DisplayUnitType.DUT_SQUARE_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 2);            #endregion // Area            #region Volume          case DisplayUnitType.DUT_CUBIC_FEET:            return imperialValue;          case DisplayUnitType.DUT_CUBIC_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 3);          case DisplayUnitType.DUT_CUBIC_INCHES:            return imperialValue * Math.Pow(12' 3);          case DisplayUnitType.DUT_CUBIC_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 3);          case DisplayUnitType.DUT_CUBIC_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 3);          case DisplayUnitType.DUT_CUBIC_YARDS:            return imperialValue * 1 / Math.Pow(3' 3);          case DisplayUnitType.DUT_GALLONS_US:            return imperialValue * 7.5;          case DisplayUnitType.DUT_LITERS:            return imperialValue * 28.31684;            #endregion // Volume            default:            NotSupported(dut);            break;        }
Magic Number,BuildingCoder,ParameterUnitConverter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\ParameterUnitConverter.cs,AsProjectUnitTypeDouble,The following statement contains a magic number: switch (dut)        {          #region Length            case DisplayUnitType.DUT_METERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_CENTIMETERS:            return imperialValue * METERS_IN_FEET * 100;          case DisplayUnitType.DUT_DECIMAL_FEET:            return imperialValue;          case DisplayUnitType.DUT_DECIMAL_INCHES:            return imperialValue * 12;          case DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_METERS_CENTIMETERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_MILLIMETERS:            return imperialValue * METERS_IN_FEET * 1000;            #endregion // Length            #region Area            case DisplayUnitType.DUT_SQUARE_FEET:            return imperialValue;          case DisplayUnitType.DUT_ACRES:            return imperialValue * 1 / 43560.039;          case DisplayUnitType.DUT_HECTARES:            return imperialValue * 1 / 107639.104;          case DisplayUnitType.DUT_SQUARE_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 2);          case DisplayUnitType.DUT_SQUARE_INCHES:            return imperialValue * Math.Pow(12' 2);          case DisplayUnitType.DUT_SQUARE_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 2);          case DisplayUnitType.DUT_SQUARE_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 2);            #endregion // Area            #region Volume          case DisplayUnitType.DUT_CUBIC_FEET:            return imperialValue;          case DisplayUnitType.DUT_CUBIC_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 3);          case DisplayUnitType.DUT_CUBIC_INCHES:            return imperialValue * Math.Pow(12' 3);          case DisplayUnitType.DUT_CUBIC_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 3);          case DisplayUnitType.DUT_CUBIC_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 3);          case DisplayUnitType.DUT_CUBIC_YARDS:            return imperialValue * 1 / Math.Pow(3' 3);          case DisplayUnitType.DUT_GALLONS_US:            return imperialValue * 7.5;          case DisplayUnitType.DUT_LITERS:            return imperialValue * 28.31684;            #endregion // Volume            default:            NotSupported(dut);            break;        }
Magic Number,BuildingCoder,ParameterUnitConverter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\ParameterUnitConverter.cs,AsProjectUnitTypeDouble,The following statement contains a magic number: switch (dut)        {          #region Length            case DisplayUnitType.DUT_METERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_CENTIMETERS:            return imperialValue * METERS_IN_FEET * 100;          case DisplayUnitType.DUT_DECIMAL_FEET:            return imperialValue;          case DisplayUnitType.DUT_DECIMAL_INCHES:            return imperialValue * 12;          case DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_METERS_CENTIMETERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_MILLIMETERS:            return imperialValue * METERS_IN_FEET * 1000;            #endregion // Length            #region Area            case DisplayUnitType.DUT_SQUARE_FEET:            return imperialValue;          case DisplayUnitType.DUT_ACRES:            return imperialValue * 1 / 43560.039;          case DisplayUnitType.DUT_HECTARES:            return imperialValue * 1 / 107639.104;          case DisplayUnitType.DUT_SQUARE_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 2);          case DisplayUnitType.DUT_SQUARE_INCHES:            return imperialValue * Math.Pow(12' 2);          case DisplayUnitType.DUT_SQUARE_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 2);          case DisplayUnitType.DUT_SQUARE_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 2);            #endregion // Area            #region Volume          case DisplayUnitType.DUT_CUBIC_FEET:            return imperialValue;          case DisplayUnitType.DUT_CUBIC_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 3);          case DisplayUnitType.DUT_CUBIC_INCHES:            return imperialValue * Math.Pow(12' 3);          case DisplayUnitType.DUT_CUBIC_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 3);          case DisplayUnitType.DUT_CUBIC_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 3);          case DisplayUnitType.DUT_CUBIC_YARDS:            return imperialValue * 1 / Math.Pow(3' 3);          case DisplayUnitType.DUT_GALLONS_US:            return imperialValue * 7.5;          case DisplayUnitType.DUT_LITERS:            return imperialValue * 28.31684;            #endregion // Volume            default:            NotSupported(dut);            break;        }
Magic Number,BuildingCoder,ParameterUnitConverter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\ParameterUnitConverter.cs,AsProjectUnitTypeDouble,The following statement contains a magic number: switch (dut)        {          #region Length            case DisplayUnitType.DUT_METERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_CENTIMETERS:            return imperialValue * METERS_IN_FEET * 100;          case DisplayUnitType.DUT_DECIMAL_FEET:            return imperialValue;          case DisplayUnitType.DUT_DECIMAL_INCHES:            return imperialValue * 12;          case DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_METERS_CENTIMETERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_MILLIMETERS:            return imperialValue * METERS_IN_FEET * 1000;            #endregion // Length            #region Area            case DisplayUnitType.DUT_SQUARE_FEET:            return imperialValue;          case DisplayUnitType.DUT_ACRES:            return imperialValue * 1 / 43560.039;          case DisplayUnitType.DUT_HECTARES:            return imperialValue * 1 / 107639.104;          case DisplayUnitType.DUT_SQUARE_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 2);          case DisplayUnitType.DUT_SQUARE_INCHES:            return imperialValue * Math.Pow(12' 2);          case DisplayUnitType.DUT_SQUARE_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 2);          case DisplayUnitType.DUT_SQUARE_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 2);            #endregion // Area            #region Volume          case DisplayUnitType.DUT_CUBIC_FEET:            return imperialValue;          case DisplayUnitType.DUT_CUBIC_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 3);          case DisplayUnitType.DUT_CUBIC_INCHES:            return imperialValue * Math.Pow(12' 3);          case DisplayUnitType.DUT_CUBIC_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 3);          case DisplayUnitType.DUT_CUBIC_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 3);          case DisplayUnitType.DUT_CUBIC_YARDS:            return imperialValue * 1 / Math.Pow(3' 3);          case DisplayUnitType.DUT_GALLONS_US:            return imperialValue * 7.5;          case DisplayUnitType.DUT_LITERS:            return imperialValue * 28.31684;            #endregion // Volume            default:            NotSupported(dut);            break;        }
Magic Number,BuildingCoder,ParameterUnitConverter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\ParameterUnitConverter.cs,AsProjectUnitTypeDouble,The following statement contains a magic number: switch (dut)        {          #region Length            case DisplayUnitType.DUT_METERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_CENTIMETERS:            return imperialValue * METERS_IN_FEET * 100;          case DisplayUnitType.DUT_DECIMAL_FEET:            return imperialValue;          case DisplayUnitType.DUT_DECIMAL_INCHES:            return imperialValue * 12;          case DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_METERS_CENTIMETERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_MILLIMETERS:            return imperialValue * METERS_IN_FEET * 1000;            #endregion // Length            #region Area            case DisplayUnitType.DUT_SQUARE_FEET:            return imperialValue;          case DisplayUnitType.DUT_ACRES:            return imperialValue * 1 / 43560.039;          case DisplayUnitType.DUT_HECTARES:            return imperialValue * 1 / 107639.104;          case DisplayUnitType.DUT_SQUARE_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 2);          case DisplayUnitType.DUT_SQUARE_INCHES:            return imperialValue * Math.Pow(12' 2);          case DisplayUnitType.DUT_SQUARE_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 2);          case DisplayUnitType.DUT_SQUARE_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 2);            #endregion // Area            #region Volume          case DisplayUnitType.DUT_CUBIC_FEET:            return imperialValue;          case DisplayUnitType.DUT_CUBIC_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 3);          case DisplayUnitType.DUT_CUBIC_INCHES:            return imperialValue * Math.Pow(12' 3);          case DisplayUnitType.DUT_CUBIC_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 3);          case DisplayUnitType.DUT_CUBIC_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 3);          case DisplayUnitType.DUT_CUBIC_YARDS:            return imperialValue * 1 / Math.Pow(3' 3);          case DisplayUnitType.DUT_GALLONS_US:            return imperialValue * 7.5;          case DisplayUnitType.DUT_LITERS:            return imperialValue * 28.31684;            #endregion // Volume            default:            NotSupported(dut);            break;        }
Magic Number,BuildingCoder,ParameterUnitConverter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\ParameterUnitConverter.cs,AsProjectUnitTypeDouble,The following statement contains a magic number: switch (dut)        {          #region Length            case DisplayUnitType.DUT_METERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_CENTIMETERS:            return imperialValue * METERS_IN_FEET * 100;          case DisplayUnitType.DUT_DECIMAL_FEET:            return imperialValue;          case DisplayUnitType.DUT_DECIMAL_INCHES:            return imperialValue * 12;          case DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_METERS_CENTIMETERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_MILLIMETERS:            return imperialValue * METERS_IN_FEET * 1000;            #endregion // Length            #region Area            case DisplayUnitType.DUT_SQUARE_FEET:            return imperialValue;          case DisplayUnitType.DUT_ACRES:            return imperialValue * 1 / 43560.039;          case DisplayUnitType.DUT_HECTARES:            return imperialValue * 1 / 107639.104;          case DisplayUnitType.DUT_SQUARE_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 2);          case DisplayUnitType.DUT_SQUARE_INCHES:            return imperialValue * Math.Pow(12' 2);          case DisplayUnitType.DUT_SQUARE_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 2);          case DisplayUnitType.DUT_SQUARE_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 2);            #endregion // Area            #region Volume          case DisplayUnitType.DUT_CUBIC_FEET:            return imperialValue;          case DisplayUnitType.DUT_CUBIC_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 3);          case DisplayUnitType.DUT_CUBIC_INCHES:            return imperialValue * Math.Pow(12' 3);          case DisplayUnitType.DUT_CUBIC_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 3);          case DisplayUnitType.DUT_CUBIC_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 3);          case DisplayUnitType.DUT_CUBIC_YARDS:            return imperialValue * 1 / Math.Pow(3' 3);          case DisplayUnitType.DUT_GALLONS_US:            return imperialValue * 7.5;          case DisplayUnitType.DUT_LITERS:            return imperialValue * 28.31684;            #endregion // Volume            default:            NotSupported(dut);            break;        }
Magic Number,BuildingCoder,ParameterUnitConverter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\ParameterUnitConverter.cs,AsProjectUnitTypeDouble,The following statement contains a magic number: switch (dut)        {          #region Length            case DisplayUnitType.DUT_METERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_CENTIMETERS:            return imperialValue * METERS_IN_FEET * 100;          case DisplayUnitType.DUT_DECIMAL_FEET:            return imperialValue;          case DisplayUnitType.DUT_DECIMAL_INCHES:            return imperialValue * 12;          case DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_METERS_CENTIMETERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_MILLIMETERS:            return imperialValue * METERS_IN_FEET * 1000;            #endregion // Length            #region Area            case DisplayUnitType.DUT_SQUARE_FEET:            return imperialValue;          case DisplayUnitType.DUT_ACRES:            return imperialValue * 1 / 43560.039;          case DisplayUnitType.DUT_HECTARES:            return imperialValue * 1 / 107639.104;          case DisplayUnitType.DUT_SQUARE_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 2);          case DisplayUnitType.DUT_SQUARE_INCHES:            return imperialValue * Math.Pow(12' 2);          case DisplayUnitType.DUT_SQUARE_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 2);          case DisplayUnitType.DUT_SQUARE_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 2);            #endregion // Area            #region Volume          case DisplayUnitType.DUT_CUBIC_FEET:            return imperialValue;          case DisplayUnitType.DUT_CUBIC_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 3);          case DisplayUnitType.DUT_CUBIC_INCHES:            return imperialValue * Math.Pow(12' 3);          case DisplayUnitType.DUT_CUBIC_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 3);          case DisplayUnitType.DUT_CUBIC_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 3);          case DisplayUnitType.DUT_CUBIC_YARDS:            return imperialValue * 1 / Math.Pow(3' 3);          case DisplayUnitType.DUT_GALLONS_US:            return imperialValue * 7.5;          case DisplayUnitType.DUT_LITERS:            return imperialValue * 28.31684;            #endregion // Volume            default:            NotSupported(dut);            break;        }
Magic Number,BuildingCoder,ParameterUnitConverter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\ParameterUnitConverter.cs,AsProjectUnitTypeDouble,The following statement contains a magic number: switch (dut)        {          #region Length            case DisplayUnitType.DUT_METERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_CENTIMETERS:            return imperialValue * METERS_IN_FEET * 100;          case DisplayUnitType.DUT_DECIMAL_FEET:            return imperialValue;          case DisplayUnitType.DUT_DECIMAL_INCHES:            return imperialValue * 12;          case DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_METERS_CENTIMETERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_MILLIMETERS:            return imperialValue * METERS_IN_FEET * 1000;            #endregion // Length            #region Area            case DisplayUnitType.DUT_SQUARE_FEET:            return imperialValue;          case DisplayUnitType.DUT_ACRES:            return imperialValue * 1 / 43560.039;          case DisplayUnitType.DUT_HECTARES:            return imperialValue * 1 / 107639.104;          case DisplayUnitType.DUT_SQUARE_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 2);          case DisplayUnitType.DUT_SQUARE_INCHES:            return imperialValue * Math.Pow(12' 2);          case DisplayUnitType.DUT_SQUARE_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 2);          case DisplayUnitType.DUT_SQUARE_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 2);            #endregion // Area            #region Volume          case DisplayUnitType.DUT_CUBIC_FEET:            return imperialValue;          case DisplayUnitType.DUT_CUBIC_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 3);          case DisplayUnitType.DUT_CUBIC_INCHES:            return imperialValue * Math.Pow(12' 3);          case DisplayUnitType.DUT_CUBIC_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 3);          case DisplayUnitType.DUT_CUBIC_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 3);          case DisplayUnitType.DUT_CUBIC_YARDS:            return imperialValue * 1 / Math.Pow(3' 3);          case DisplayUnitType.DUT_GALLONS_US:            return imperialValue * 7.5;          case DisplayUnitType.DUT_LITERS:            return imperialValue * 28.31684;            #endregion // Volume            default:            NotSupported(dut);            break;        }
Magic Number,BuildingCoder,ParameterUnitConverter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\ParameterUnitConverter.cs,AsProjectUnitTypeDouble,The following statement contains a magic number: switch (dut)        {          #region Length            case DisplayUnitType.DUT_METERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_CENTIMETERS:            return imperialValue * METERS_IN_FEET * 100;          case DisplayUnitType.DUT_DECIMAL_FEET:            return imperialValue;          case DisplayUnitType.DUT_DECIMAL_INCHES:            return imperialValue * 12;          case DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_METERS_CENTIMETERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_MILLIMETERS:            return imperialValue * METERS_IN_FEET * 1000;            #endregion // Length            #region Area            case DisplayUnitType.DUT_SQUARE_FEET:            return imperialValue;          case DisplayUnitType.DUT_ACRES:            return imperialValue * 1 / 43560.039;          case DisplayUnitType.DUT_HECTARES:            return imperialValue * 1 / 107639.104;          case DisplayUnitType.DUT_SQUARE_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 2);          case DisplayUnitType.DUT_SQUARE_INCHES:            return imperialValue * Math.Pow(12' 2);          case DisplayUnitType.DUT_SQUARE_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 2);          case DisplayUnitType.DUT_SQUARE_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 2);            #endregion // Area            #region Volume          case DisplayUnitType.DUT_CUBIC_FEET:            return imperialValue;          case DisplayUnitType.DUT_CUBIC_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 3);          case DisplayUnitType.DUT_CUBIC_INCHES:            return imperialValue * Math.Pow(12' 3);          case DisplayUnitType.DUT_CUBIC_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 3);          case DisplayUnitType.DUT_CUBIC_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 3);          case DisplayUnitType.DUT_CUBIC_YARDS:            return imperialValue * 1 / Math.Pow(3' 3);          case DisplayUnitType.DUT_GALLONS_US:            return imperialValue * 7.5;          case DisplayUnitType.DUT_LITERS:            return imperialValue * 28.31684;            #endregion // Volume            default:            NotSupported(dut);            break;        }
Magic Number,BuildingCoder,ParameterUnitConverter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\ParameterUnitConverter.cs,AsProjectUnitTypeDouble,The following statement contains a magic number: switch (dut)        {          #region Length            case DisplayUnitType.DUT_METERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_CENTIMETERS:            return imperialValue * METERS_IN_FEET * 100;          case DisplayUnitType.DUT_DECIMAL_FEET:            return imperialValue;          case DisplayUnitType.DUT_DECIMAL_INCHES:            return imperialValue * 12;          case DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_METERS_CENTIMETERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_MILLIMETERS:            return imperialValue * METERS_IN_FEET * 1000;            #endregion // Length            #region Area            case DisplayUnitType.DUT_SQUARE_FEET:            return imperialValue;          case DisplayUnitType.DUT_ACRES:            return imperialValue * 1 / 43560.039;          case DisplayUnitType.DUT_HECTARES:            return imperialValue * 1 / 107639.104;          case DisplayUnitType.DUT_SQUARE_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 2);          case DisplayUnitType.DUT_SQUARE_INCHES:            return imperialValue * Math.Pow(12' 2);          case DisplayUnitType.DUT_SQUARE_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 2);          case DisplayUnitType.DUT_SQUARE_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 2);            #endregion // Area            #region Volume          case DisplayUnitType.DUT_CUBIC_FEET:            return imperialValue;          case DisplayUnitType.DUT_CUBIC_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 3);          case DisplayUnitType.DUT_CUBIC_INCHES:            return imperialValue * Math.Pow(12' 3);          case DisplayUnitType.DUT_CUBIC_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 3);          case DisplayUnitType.DUT_CUBIC_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 3);          case DisplayUnitType.DUT_CUBIC_YARDS:            return imperialValue * 1 / Math.Pow(3' 3);          case DisplayUnitType.DUT_GALLONS_US:            return imperialValue * 7.5;          case DisplayUnitType.DUT_LITERS:            return imperialValue * 28.31684;            #endregion // Volume            default:            NotSupported(dut);            break;        }
Magic Number,BuildingCoder,ParameterUnitConverter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\ParameterUnitConverter.cs,AsProjectUnitTypeDouble,The following statement contains a magic number: switch (dut)        {          #region Length            case DisplayUnitType.DUT_METERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_CENTIMETERS:            return imperialValue * METERS_IN_FEET * 100;          case DisplayUnitType.DUT_DECIMAL_FEET:            return imperialValue;          case DisplayUnitType.DUT_DECIMAL_INCHES:            return imperialValue * 12;          case DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_METERS_CENTIMETERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_MILLIMETERS:            return imperialValue * METERS_IN_FEET * 1000;            #endregion // Length            #region Area            case DisplayUnitType.DUT_SQUARE_FEET:            return imperialValue;          case DisplayUnitType.DUT_ACRES:            return imperialValue * 1 / 43560.039;          case DisplayUnitType.DUT_HECTARES:            return imperialValue * 1 / 107639.104;          case DisplayUnitType.DUT_SQUARE_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 2);          case DisplayUnitType.DUT_SQUARE_INCHES:            return imperialValue * Math.Pow(12' 2);          case DisplayUnitType.DUT_SQUARE_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 2);          case DisplayUnitType.DUT_SQUARE_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 2);            #endregion // Area            #region Volume          case DisplayUnitType.DUT_CUBIC_FEET:            return imperialValue;          case DisplayUnitType.DUT_CUBIC_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 3);          case DisplayUnitType.DUT_CUBIC_INCHES:            return imperialValue * Math.Pow(12' 3);          case DisplayUnitType.DUT_CUBIC_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 3);          case DisplayUnitType.DUT_CUBIC_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 3);          case DisplayUnitType.DUT_CUBIC_YARDS:            return imperialValue * 1 / Math.Pow(3' 3);          case DisplayUnitType.DUT_GALLONS_US:            return imperialValue * 7.5;          case DisplayUnitType.DUT_LITERS:            return imperialValue * 28.31684;            #endregion // Volume            default:            NotSupported(dut);            break;        }
Magic Number,BuildingCoder,ParameterUnitConverter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\ParameterUnitConverter.cs,AsProjectUnitTypeDouble,The following statement contains a magic number: switch (dut)        {          #region Length            case DisplayUnitType.DUT_METERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_CENTIMETERS:            return imperialValue * METERS_IN_FEET * 100;          case DisplayUnitType.DUT_DECIMAL_FEET:            return imperialValue;          case DisplayUnitType.DUT_DECIMAL_INCHES:            return imperialValue * 12;          case DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_METERS_CENTIMETERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_MILLIMETERS:            return imperialValue * METERS_IN_FEET * 1000;            #endregion // Length            #region Area            case DisplayUnitType.DUT_SQUARE_FEET:            return imperialValue;          case DisplayUnitType.DUT_ACRES:            return imperialValue * 1 / 43560.039;          case DisplayUnitType.DUT_HECTARES:            return imperialValue * 1 / 107639.104;          case DisplayUnitType.DUT_SQUARE_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 2);          case DisplayUnitType.DUT_SQUARE_INCHES:            return imperialValue * Math.Pow(12' 2);          case DisplayUnitType.DUT_SQUARE_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 2);          case DisplayUnitType.DUT_SQUARE_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 2);            #endregion // Area            #region Volume          case DisplayUnitType.DUT_CUBIC_FEET:            return imperialValue;          case DisplayUnitType.DUT_CUBIC_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 3);          case DisplayUnitType.DUT_CUBIC_INCHES:            return imperialValue * Math.Pow(12' 3);          case DisplayUnitType.DUT_CUBIC_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 3);          case DisplayUnitType.DUT_CUBIC_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 3);          case DisplayUnitType.DUT_CUBIC_YARDS:            return imperialValue * 1 / Math.Pow(3' 3);          case DisplayUnitType.DUT_GALLONS_US:            return imperialValue * 7.5;          case DisplayUnitType.DUT_LITERS:            return imperialValue * 28.31684;            #endregion // Volume            default:            NotSupported(dut);            break;        }
Magic Number,BuildingCoder,ParameterUnitConverter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\ParameterUnitConverter.cs,AsProjectUnitTypeDouble,The following statement contains a magic number: switch (dut)        {          #region Length            case DisplayUnitType.DUT_METERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_CENTIMETERS:            return imperialValue * METERS_IN_FEET * 100;          case DisplayUnitType.DUT_DECIMAL_FEET:            return imperialValue;          case DisplayUnitType.DUT_DECIMAL_INCHES:            return imperialValue * 12;          case DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_METERS_CENTIMETERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_MILLIMETERS:            return imperialValue * METERS_IN_FEET * 1000;            #endregion // Length            #region Area            case DisplayUnitType.DUT_SQUARE_FEET:            return imperialValue;          case DisplayUnitType.DUT_ACRES:            return imperialValue * 1 / 43560.039;          case DisplayUnitType.DUT_HECTARES:            return imperialValue * 1 / 107639.104;          case DisplayUnitType.DUT_SQUARE_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 2);          case DisplayUnitType.DUT_SQUARE_INCHES:            return imperialValue * Math.Pow(12' 2);          case DisplayUnitType.DUT_SQUARE_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 2);          case DisplayUnitType.DUT_SQUARE_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 2);            #endregion // Area            #region Volume          case DisplayUnitType.DUT_CUBIC_FEET:            return imperialValue;          case DisplayUnitType.DUT_CUBIC_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 3);          case DisplayUnitType.DUT_CUBIC_INCHES:            return imperialValue * Math.Pow(12' 3);          case DisplayUnitType.DUT_CUBIC_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 3);          case DisplayUnitType.DUT_CUBIC_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 3);          case DisplayUnitType.DUT_CUBIC_YARDS:            return imperialValue * 1 / Math.Pow(3' 3);          case DisplayUnitType.DUT_GALLONS_US:            return imperialValue * 7.5;          case DisplayUnitType.DUT_LITERS:            return imperialValue * 28.31684;            #endregion // Volume            default:            NotSupported(dut);            break;        }
Magic Number,BuildingCoder,ParameterUnitConverter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\ParameterUnitConverter.cs,AsProjectUnitTypeDouble,The following statement contains a magic number: switch (dut)        {          #region Length            case DisplayUnitType.DUT_METERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_CENTIMETERS:            return imperialValue * METERS_IN_FEET * 100;          case DisplayUnitType.DUT_DECIMAL_FEET:            return imperialValue;          case DisplayUnitType.DUT_DECIMAL_INCHES:            return imperialValue * 12;          case DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_METERS_CENTIMETERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_MILLIMETERS:            return imperialValue * METERS_IN_FEET * 1000;            #endregion // Length            #region Area            case DisplayUnitType.DUT_SQUARE_FEET:            return imperialValue;          case DisplayUnitType.DUT_ACRES:            return imperialValue * 1 / 43560.039;          case DisplayUnitType.DUT_HECTARES:            return imperialValue * 1 / 107639.104;          case DisplayUnitType.DUT_SQUARE_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 2);          case DisplayUnitType.DUT_SQUARE_INCHES:            return imperialValue * Math.Pow(12' 2);          case DisplayUnitType.DUT_SQUARE_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 2);          case DisplayUnitType.DUT_SQUARE_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 2);            #endregion // Area            #region Volume          case DisplayUnitType.DUT_CUBIC_FEET:            return imperialValue;          case DisplayUnitType.DUT_CUBIC_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 3);          case DisplayUnitType.DUT_CUBIC_INCHES:            return imperialValue * Math.Pow(12' 3);          case DisplayUnitType.DUT_CUBIC_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 3);          case DisplayUnitType.DUT_CUBIC_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 3);          case DisplayUnitType.DUT_CUBIC_YARDS:            return imperialValue * 1 / Math.Pow(3' 3);          case DisplayUnitType.DUT_GALLONS_US:            return imperialValue * 7.5;          case DisplayUnitType.DUT_LITERS:            return imperialValue * 28.31684;            #endregion // Volume            default:            NotSupported(dut);            break;        }
Magic Number,BuildingCoder,ParameterUnitConverter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\ParameterUnitConverter.cs,AsProjectUnitTypeDouble,The following statement contains a magic number: switch (dut)        {          #region Length            case DisplayUnitType.DUT_METERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_CENTIMETERS:            return imperialValue * METERS_IN_FEET * 100;          case DisplayUnitType.DUT_DECIMAL_FEET:            return imperialValue;          case DisplayUnitType.DUT_DECIMAL_INCHES:            return imperialValue * 12;          case DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_FRACTIONAL_INCHES:            NotSupported(dut);            break;          case DisplayUnitType.DUT_METERS_CENTIMETERS:            return imperialValue * METERS_IN_FEET; //feet          case DisplayUnitType.DUT_MILLIMETERS:            return imperialValue * METERS_IN_FEET * 1000;            #endregion // Length            #region Area            case DisplayUnitType.DUT_SQUARE_FEET:            return imperialValue;          case DisplayUnitType.DUT_ACRES:            return imperialValue * 1 / 43560.039;          case DisplayUnitType.DUT_HECTARES:            return imperialValue * 1 / 107639.104;          case DisplayUnitType.DUT_SQUARE_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 2);          case DisplayUnitType.DUT_SQUARE_INCHES:            return imperialValue * Math.Pow(12' 2);          case DisplayUnitType.DUT_SQUARE_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 2);          case DisplayUnitType.DUT_SQUARE_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 2);            #endregion // Area            #region Volume          case DisplayUnitType.DUT_CUBIC_FEET:            return imperialValue;          case DisplayUnitType.DUT_CUBIC_CENTIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 100' 3);          case DisplayUnitType.DUT_CUBIC_INCHES:            return imperialValue * Math.Pow(12' 3);          case DisplayUnitType.DUT_CUBIC_METERS:            return imperialValue * Math.Pow(METERS_IN_FEET' 3);          case DisplayUnitType.DUT_CUBIC_MILLIMETERS:            return imperialValue * Math.Pow(METERS_IN_FEET * 1000' 3);          case DisplayUnitType.DUT_CUBIC_YARDS:            return imperialValue * 1 / Math.Pow(3' 3);          case DisplayUnitType.DUT_GALLONS_US:            return imperialValue * 7.5;          case DisplayUnitType.DUT_LITERS:            return imperialValue * 28.31684;            #endregion // Volume            default:            NotSupported(dut);            break;        }
Magic Number,BuildingCoder,ParameterUnitConverter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\ParameterUnitConverter.cs,AsMetersValue,The following statement contains a magic number: switch (ut)        {          case UnitType.UT_Length:            return imperialValue * METERS_IN_FEET;            case UnitType.UT_Area:            return imperialValue * Math.Pow(              METERS_IN_FEET' 2);            case UnitType.UT_Volume:            return imperialValue * Math.Pow(              METERS_IN_FEET' 3);        }
Magic Number,BuildingCoder,ParameterUnitConverter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\ParameterUnitConverter.cs,AsMetersValue,The following statement contains a magic number: switch (ut)        {          case UnitType.UT_Length:            return imperialValue * METERS_IN_FEET;            case UnitType.UT_Area:            return imperialValue * Math.Pow(              METERS_IN_FEET' 2);            case UnitType.UT_Volume:            return imperialValue * Math.Pow(              METERS_IN_FEET' 3);        }
Magic Number,BuildingCoder,Util,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Util.cs,GetArbitraryAxes,The following statement contains a magic number: double limit = 1.0 / 64;
Magic Number,BuildingCoder,Util,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Util.cs,Midpoint,The following statement contains a magic number: return 0.5 * ( p + q );
Magic Number,BuildingCoder,Util,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Util.cs,CreateSphereAt,The following statement contains a magic number: return GeometryCreationUtilities          .CreateRevolvedGeometry( frame' loops'            0' 2 * Math.PI );
Magic Number,BuildingCoder,Util,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Util.cs,CreateCone,The following statement contains a magic number: Solid cone = GeometryCreationUtilities          .CreateRevolvedGeometry( frame'            new CurveLoop[] { curveLoop }'            0' 2 * Math.PI );
Magic Number,BuildingCoder,Util,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Util.cs,CreateRectangularPrism,The following statement contains a magic number: XYZ profile00 = new XYZ( -d1 / 2' -d2 / 2' -d3 / 2 );
Magic Number,BuildingCoder,Util,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Util.cs,CreateRectangularPrism,The following statement contains a magic number: XYZ profile00 = new XYZ( -d1 / 2' -d2 / 2' -d3 / 2 );
Magic Number,BuildingCoder,Util,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Util.cs,CreateRectangularPrism,The following statement contains a magic number: XYZ profile00 = new XYZ( -d1 / 2' -d2 / 2' -d3 / 2 );
Magic Number,BuildingCoder,Util,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Util.cs,CreateRectangularPrism,The following statement contains a magic number: XYZ profile01 = new XYZ( -d1 / 2' d2 / 2' -d3 / 2 );
Magic Number,BuildingCoder,Util,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Util.cs,CreateRectangularPrism,The following statement contains a magic number: XYZ profile01 = new XYZ( -d1 / 2' d2 / 2' -d3 / 2 );
Magic Number,BuildingCoder,Util,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Util.cs,CreateRectangularPrism,The following statement contains a magic number: XYZ profile01 = new XYZ( -d1 / 2' d2 / 2' -d3 / 2 );
Magic Number,BuildingCoder,Util,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Util.cs,CreateRectangularPrism,The following statement contains a magic number: XYZ profile11 = new XYZ( d1 / 2' d2 / 2' -d3 / 2 );
Magic Number,BuildingCoder,Util,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Util.cs,CreateRectangularPrism,The following statement contains a magic number: XYZ profile11 = new XYZ( d1 / 2' d2 / 2' -d3 / 2 );
Magic Number,BuildingCoder,Util,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Util.cs,CreateRectangularPrism,The following statement contains a magic number: XYZ profile11 = new XYZ( d1 / 2' d2 / 2' -d3 / 2 );
Magic Number,BuildingCoder,Util,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Util.cs,CreateRectangularPrism,The following statement contains a magic number: XYZ profile10 = new XYZ( d1 / 2' -d2 / 2' -d3 / 2 );
Magic Number,BuildingCoder,Util,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Util.cs,CreateRectangularPrism,The following statement contains a magic number: XYZ profile10 = new XYZ( d1 / 2' -d2 / 2' -d3 / 2 );
Magic Number,BuildingCoder,Util,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Util.cs,CreateRectangularPrism,The following statement contains a magic number: XYZ profile10 = new XYZ( d1 / 2' -d2 / 2' -d3 / 2 );
Magic Number,BuildingCoder,Util,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Util.cs,ConvexHull,The following statement contains a magic number: do        {          convexHullPoints.Add( walkingPoint );          XYZ wp = walkingPoint;          XYZ rv = refVector;          walkingPoint = points.MinBy( p =>          {            double angle = ( p - wp ).AngleOnPlaneTo( rv' XYZ.BasisZ );            if( angle < 1e-10 ) angle = 2 * Math.PI;            return angle;          } );          refVector = wp - walkingPoint;        } while( walkingPoint != startPoint );
Magic Number,BuildingCoder,Util,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Util.cs,ConvexHull,The following statement contains a magic number: do        {          convexHullPoints.Add( walkingPoint );          XYZ wp = walkingPoint;          XYZ rv = refVector;          walkingPoint = points.MinBy( p =>          {            double angle = ( p - wp ).AngleOnPlaneTo( rv' XYZ.BasisZ );            if( angle < 1e-10 ) angle = 2 * Math.PI;            return angle;          } );          refVector = wp - walkingPoint;        } while( walkingPoint != startPoint );
Magic Number,BuildingCoder,Util,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Util.cs,AngleString,The following statement contains a magic number: return RealString( angle * 180 / Math.PI )          + " degrees";
Magic Number,BuildingCoder,Util,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Util.cs,UnitSymbolTypeString,The following statement contains a magic number: s = s.Substring( 4 )          .Replace( "_SUP_"' "^" )          .ToLower();
Magic Number,BuildingCoder,Util,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Util.cs,GetConnectorAt,The following statement contains a magic number: bool hasTwoConnectors = 2 == cm.Connectors.Size;
Magic Number,BuildingCoder,CompatibilityMethods,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\Util.cs,Duplicate2,The following statement contains a magic number: if( ls.Count > 0 )        {          Type t = ls[0];          object obj = view;          MethodInfo met = view.GetType().GetMethod(            "Duplicate"' new Type[] { t } );          if( met != null )          {            value = met.Invoke( obj'              new object[] { 2 } ) as ElementId;          }        }
Magic Number,BuildingCoder,CmdWallNeighbours,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallNeighbours.cs,Execute,The following statement contains a magic number: foreach( Wall wall in walls )        {          desc = Util.ElementDescription( wall );            LocationCurve c            = wall.Location as LocationCurve;            if( null == c )          {            s = desc + ": No wall curve found.";          }          else          {            s = string.Empty;              for( i = 0; i < 2; ++i )            {              neighbours = c.get_ElementsAtJoin( i );              n = neighbours.Size;                s += string.Format(                "\n\n{0} {1} point has {2} neighbour{3}{4}"'                desc'                (0 == i ? "start" : "end")'                n'                Util.PluralSuffix( n )'                Util.DotOrColon( n ) );                foreach( Wall nb in neighbours )              {                s += "\n  " +                  Util.ElementDescription( nb );              }            }          }          Util.InfoMsg( s );        }
Magic Number,FilterPerformance,ParamFilterTest,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,Execute,The following statement contains a magic number: FilterRule fRule          = new FilterDoubleRule( pvp' fnrv' 20' 1E-6 );
Magic Number,FilterPerformance,ParamFilterTest,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,Execute,The following statement contains a magic number: FilterRule fRule          = new FilterDoubleRule( pvp' fnrv' 20' 1E-6 );
Magic Number,FilterPerformance,CmdCollectorPerformance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,f3,The following statement contains a magic number: List<ElementFilter> a          = new List<ElementFilter>( 3 );
Magic Number,FilterPerformance,CmdCollectorPerformance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,f2,The following statement contains a magic number: Outline myOutLn = new Outline(          XYZ.Zero' new XYZ( 100' 100' 100 ) );
Magic Number,FilterPerformance,CmdCollectorPerformance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,f2,The following statement contains a magic number: Outline myOutLn = new Outline(          XYZ.Zero' new XYZ( 100' 100' 100 ) );
Magic Number,FilterPerformance,CmdCollectorPerformance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,f2,The following statement contains a magic number: Outline myOutLn = new Outline(          XYZ.Zero' new XYZ( 100' 100' 100 ) );
Magic Number,FilterPerformance,CmdCollectorPerformance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,f4,The following statement contains a magic number: ElementId ruleValId = new ElementId( 99 );
Magic Number,FilterPerformance,CmdCollectorPerformance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,f4,The following statement contains a magic number: double ruleValDb = 10;
Magic Number,FilterPerformance,CmdCollectorPerformance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,IsElementHiddenInView,The following statement contains a magic number: if( v.CropBoxActive )        {          BoundingBoxXYZ viewBox = v.CropBox;          BoundingBoxXYZ elBox = e.get_BoundingBox( v );            Transform transInv = v.CropBox.Transform.Inverse;            elBox.Max = transInv.OfPoint( elBox.Max );          elBox.Min = transInv.OfPoint( elBox.Min );            // The transform above might switch           // max and min values.            if( elBox.Min.X > elBox.Max.X )          {            XYZ tmpP = elBox.Min;            elBox.Min = new XYZ( elBox.Max.X' elBox.Min.Y' 0 );            elBox.Max = new XYZ( tmpP.X' elBox.Max.Y' 0 );          }            if( elBox.Min.Y > elBox.Max.Y )          {            XYZ tmpP = elBox.Min;            elBox.Min = new XYZ( elBox.Min.X' elBox.Max.Y' 0 );            elBox.Max = new XYZ( tmpP.X' elBox.Min.Y' 0 );          }            if( elBox.Min.X > viewBox.Max.X            || elBox.Max.X < viewBox.Min.X            || elBox.Min.Y > viewBox.Max.Y            || elBox.Max.Y < viewBox.Min.Y )          {            return true;          }          else          {            BoundingBoxXYZ inside = new BoundingBoxXYZ();              double x' y;              x = elBox.Max.X;              if( elBox.Max.X > viewBox.Max.X )              x = viewBox.Max.X;              y = elBox.Max.Y;              if( elBox.Max.Y > viewBox.Max.Y )              y = viewBox.Max.Y;              inside.Max = new XYZ( x' y' 0 );              x = elBox.Min.X;              if( elBox.Min.X < viewBox.Min.X )              x = viewBox.Min.X;              y = elBox.Min.Y;              if( elBox.Min.Y < viewBox.Min.Y )              y = viewBox.Min.Y;              inside.Min = new XYZ( x' y' 0 );              double eBBArea = ( elBox.Max.X - elBox.Min.X )              * ( elBox.Max.Y - elBox.Min.Y );              double einsideArea =              ( inside.Max.X - inside.Min.X )              * ( inside.Max.Y - inside.Min.Y );              double factor = einsideArea / eBBArea;              if( factor < 0.25 )              return true;          }        }
Magic Number,FilterPerformance,CmdCollectorPerformance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,RunBenchmark,The following statement contains a magic number: int maxLevel = 1000;
Magic Number,FilterPerformance,CmdCollectorPerformance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,RunBenchmark,The following statement contains a magic number: for( int i = 3; i < maxLevel; ++i )        {          CreateLevel( i );        }
Magic Number,FilterPerformance,CmdCollectorPerformance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,RunBenchmark,The following statement contains a magic number: int nRuns = 1000;
Magic Number,FilterPerformance,CmdCollectorPerformance,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdCollectorPerformance.cs,RunBenchmark,The following statement contains a magic number: nRuns = 1000;
Missing Default,BuildingCoder,CmdFamilyParamValue,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdFamilyParamValue.cs,FamilyParamValueString,The following switch statement is missing a default case: switch( fp.StorageType )        {          case StorageType.Double:            value = Util.RealString(              (double) t.AsDouble( fp ) )              + " (double)";            break;            case StorageType.ElementId:            ElementId id = t.AsElementId( fp );            Element e = doc.GetElement( id );            value = id.IntegerValue.ToString() + " ("              + Util.ElementDescription( e ) + ")";            break;            case StorageType.Integer:            value = t.AsInteger( fp ).ToString()              + " (int)";            break;            case StorageType.String:            value = "'" + t.AsString( fp )              + "' (string)";            break;        }
Missing Default,BuildingCoder,CmdWallProfile,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\CmdWallProfile.cs,Execute,The following switch statement is missing a default case: switch( use_execute_nr )        {          case 1: return Execute1( cd' ref msg' els );          case 2: return Execute2( cd' ref msg' els );          case 3: return Execute3( cd' ref msg' els );        }
Missing Default,BuildingCoder,ParameterUnitConverter,C:\repos\jeremytammik_the_building_coder_samples\BuildingCoder\BuildingCoder\ParameterUnitConverter.cs,AsMetersValue,The following switch statement is missing a default case: switch (ut)        {          case UnitType.UT_Length:            return imperialValue * METERS_IN_FEET;            case UnitType.UT_Area:            return imperialValue * Math.Pow(              METERS_IN_FEET' 2);            case UnitType.UT_Volume:            return imperialValue * Math.Pow(              METERS_IN_FEET' 3);        }
