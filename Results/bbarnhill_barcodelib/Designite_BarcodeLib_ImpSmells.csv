Implementation smell,Namespace,Class,File,Method,Description
Long Method,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Encode,The method has 127 lines of code.
Long Method,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The method has 151 lines of code.
Long Method,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The method has 760 lines of code.
Long Method,BarcodeLib.Symbologies,Code93,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code93.cs,init_Code93,The method has 251 lines of code.
Long Method,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The method has 136 lines of code.
Long Method,BarcodeLib.Symbologies,EAN13,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN13.cs,init_CountryCodes,The method has 564 lines of code.
Long Method,BarcodeLib.Symbologies,UPCA,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCA.cs,init_CountryCodes,The method has 133 lines of code.
Complex Method,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Encode,Cyclomatic complexity of the method is 92
Complex Method,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,Cyclomatic complexity of the method is 41
Complex Method,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,SaveImage,Cyclomatic complexity of the method is 20
Complex Method,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,SaveImage,Cyclomatic complexity of the method is 20
Complex Method,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_Generic,Cyclomatic complexity of the method is 33
Complex Method,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_UPCA,Cyclomatic complexity of the method is 15
Complex Method,BarcodeLib.Symbologies,Codabar,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Codabar.cs,Encode_Codabar,Cyclomatic complexity of the method is 26
Complex Method,BarcodeLib.Symbologies,Code11,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code11.cs,Encode_Code11,Cyclomatic complexity of the method is 10
Complex Method,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,FindStartorCodeCharacter,Cyclomatic complexity of the method is 11
Complex Method,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,BreakUpDataForEncoding,Cyclomatic complexity of the method is 12
Complex Method,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,InsertStartandCodeCharacters,Cyclomatic complexity of the method is 20
Complex Method,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,GetEncoding,Cyclomatic complexity of the method is 20
Complex Method,BarcodeLib.Symbologies,Pharmacode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Pharmacode.cs,Encode_Pharmacode,Cyclomatic complexity of the method is 9
Complex Method,BarcodeLib.Symbologies,FIM,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\FIM.cs,FIM,Cyclomatic complexity of the method is 19
Complex Method,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Encode_Telepen,Cyclomatic complexity of the method is 14
Complex Method,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,SetEncodingSequence,Cyclomatic complexity of the method is 9
Complex Method,BarcodeLib.Symbologies,ITF14,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ITF14.cs,Encode_ITF14,Cyclomatic complexity of the method is 9
Complex Method,BarcodeLib.Symbologies,EAN13,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN13.cs,Encode_EAN13,Cyclomatic complexity of the method is 8
Complex Method,BarcodeLib.Symbologies,Interleaved2of5,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Interleaved2of5.cs,Encode_Interleaved2of5,Cyclomatic complexity of the method is 9
Complex Method,BarcodeLib.Symbologies,MSI,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\MSI.cs,Encode_MSI,Cyclomatic complexity of the method is 20
Complex Method,BarcodeLib.Symbologies,Postnet,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Postnet.cs,Encode_Postnet,Cyclomatic complexity of the method is 10
Complex Method,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,Cyclomatic complexity of the method is 13
Complex Method,BarcodeLib.Symbologies,UPCSupplement2,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCSupplement2.cs,Encode_UPCSupplemental_2,Cyclomatic complexity of the method is 8
Complex Method,BarcodeLib.Symbologies,UPCSupplement5,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCSupplement5.cs,Encode_UPCSupplemental_5,Cyclomatic complexity of the method is 9
Long Parameter List,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Encode,The method has 6 parameters.
Long Parameter List,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,DoEncode,The method has 5 parameters.
Long Parameter List,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,DoEncode,The method has 5 parameters.
Long Parameter List,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,DoEncode,The method has 7 parameters.
Long Parameter List,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,DoEncode,The method has 8 parameters.
Long Statement,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The length of the statement  "			throw new Exception ("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)"); " is 191.
Long Statement,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The length of the statement  "						g.DrawLine (pen' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height)); " is 180.
Long Statement,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The length of the statement  "			throw new Exception ("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)"); " is 142.
Long Statement,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The length of the statement  "								g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLableAdjustment)); " is 209.
Long Statement,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The length of the statement  "								g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment)); " is 192.
Long Statement,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The length of the statement  "								g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)); " is 192.
Long Statement,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_ITF14,The length of the statement  "			g.FillRectangle (new SolidBrush (this.BackColor)' new Rectangle (0' img.Height - (font.Height - 2)' img.Width' font.Height)); " is 125.
Long Statement,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_ITF14,The length of the statement  "			g.DrawString (AlternateLabel == null ? RawData : AlternateLabel' font' new SolidBrush (ForeColor)' (float)(img.Width / 2)' img.Height - font.Height + 1' f); " is 156.
Long Statement,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_Generic,The length of the statement  "			g.FillRectangle (new SolidBrush (BackColor)' new RectangleF ((float)0' (float)LabelY' (float)img.Width' (float)font.Height)); " is 125.
Long Statement,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_Generic,The length of the statement  "			g.DrawString (AlternateLabel == null ? RawData : AlternateLabel' font' new SolidBrush (ForeColor)' new RectangleF ((float)0' (float)LabelY' (float)img.Width' (float)font.Height)' f); " is 182.
Long Statement,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_UPCA,The length of the statement  "		System.Drawing.Font font = new System.Drawing.Font ("OCR A Extended"' 12F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((System.Byte)(0))); " is 161.
Long Statement,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_UPCA,The length of the statement  "			RectangleF rect = new RectangleF ((iBarWidth * 3) + shiftAdjustment' this.Height - (int)(this.Height * 0.1)' (iBarWidth * 43)' (int)(this.Height * 0.1)); " is 153.
Long Statement,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,GetXML,The length of the statement  "		throw new Exception ("EGETXML-1: Could not retrieve XML due to the barcode not being encoded first.  Please call Encode first."); " is 129.
Long Statement,BarcodeLib,BarcodeCommon,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeCommon.cs,CheckNumericOnly,The length of the statement  "	//9223372036854775808 is the largest number a 64bit number(signed) can hold so ... make sure its less than that by one place " is 124.
Long Statement,BarcodeLib,BarcodeXML,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeXML.Designer.cs,GetTypedDataSetSchema,The length of the statement  "			for (global::System.Collections.IEnumerator schemas = xs.Schemas (dsSchema.TargetNamespace).GetEnumerator (); schemas.MoveNext ();) { " is 133.
Long Statement,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,FindStartorCodeCharacter,The length of the statement  "	if (s.Length > 1 && (Char.IsNumber (s [0]) || s [0] == Convert.ToChar (200)) && (Char.IsNumber (s [1]) || s [0] == Convert.ToChar (200))) { " is 139.
Long Statement,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,InsertStartandCodeCharacters,The length of the statement  "					if (row ["A"].ToString ().EndsWith (CurrentCodeString) || row ["B"].ToString ().EndsWith (CurrentCodeString) || row ["C"].ToString ().EndsWith (CurrentCodeString)) { " is 165.
Long Statement,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,InsertStartandCodeCharacters,The length of the statement  "				//if (CurrentCodeString == "" || !tempStartChars[0][col].ToString().EndsWith(CurrentCodeString)) /* Removed because of bug */ " is 125.
Long Statement,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,Encode_Code39,The length of the statement  "	string strFormattedData = "*" + strNoAstr + (_EnableChecksum ? getChecksumChar (strNoAstr).ToString () : String.Empty) + "*"; " is 125.
Long Statement,BarcodeLib.Symbologies,Code93,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code93.cs,Add_CheckDigits,The length of the statement  "		SUM += aryCWeights [i] * Int32.Parse (C93_Code.Select ("Character = '" + input [i].ToString () + "'") [0] ["Value"].ToString ()); " is 129.
Long Statement,BarcodeLib.Symbologies,Code93,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code93.cs,Add_CheckDigits,The length of the statement  "		SUM += aryKWeights [i] * Int32.Parse (C93_Code.Select ("Character = '" + input [i].ToString () + "'") [0] ["Value"].ToString ()); " is 129.
Long Statement,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The length of the statement  "		if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) { " is 138.
Complex Conditional,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,FindStartorCodeCharacter,The conditional expression  "s.Length > 1 && (Char.IsNumber (s [0]) || s [0] == Convert.ToChar (200)) && (Char.IsNumber (s [1]) || s [0] == Convert.ToChar (200))"  is complex.
Complex Conditional,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The conditional expression  "Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999"  is complex.
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type) {  case TYPE.ITF14: {  	// Automatically calculate the Width if applicable. Quite confusing with this  	// barcode type' and it seems this method overestimates the minimum width. But  	// at least it�s deterministic and doesn�t produce too small of a value.  	if (BarWidth.HasValue) {  		// Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone  		// Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20  		// Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length  		// Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)  		// Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)  		// Width = BarWidth * EncodedValue.Length / 176.9 * 241  		// Rounding error? + 1  		Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);  	}  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	if (IncludeLabel) {  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int bearerwidth = (int)((b.Width) / 12.05);  	int iquietzone = Convert.ToInt32 (b.Width * 0.05);  	int iBarWidth = (b.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;  	int shiftAdjustment = ((b.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;  	if (iBarWidth <= 0 || iquietzone <= 0)  		throw new Exception ("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	using (Graphics g = Graphics.FromImage (b)) {  		//fill background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen pen = new Pen (ForeColor' iBarWidth)) {  			pen.Alignment = PenAlignment.Right;  			while (pos < Encoded_Value.Length) {  				//draw the appropriate color line vertically  				if (Encoded_Value [pos] == '1')  					g.DrawLine (pen' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));  				pos++;  			}  			//while  			//bearer bars  			pen.Width = (float)ILHeight / 8;  			pen.Color = ForeColor;  			pen.Alignment = PenAlignment.Center;  			g.DrawLine (pen' new Point (0' 0)' new Point (b.Width' 0));  			//top  			g.DrawLine (pen' new Point (0' ILHeight)' new Point (b.Width' ILHeight));  			//bottom  			g.DrawLine (pen' new Point (0' 0)' new Point (0' ILHeight));  			//left  			g.DrawLine (pen' new Point (b.Width' 0)' new Point (b.Width' ILHeight));  			//right  		}  		//using  	}  	//using  	if (IncludeLabel)  		Label_ITF14 ((Image)b);  	break;  }  //case  default: {  	// Automatically calculate Width if applicable.  	Width = BarWidth * Encoded_Value.Length ?? Width;  	// Automatically calculate Height if applicable.  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	int topLableAdjustment = 0;  	if (IncludeLabel) {  		// Shift drawing down if top label.  		if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)  			topLableAdjustment = this.LabelFont.Height;  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int iBarWidth = Width / Encoded_Value.Length;  	int shiftAdjustment = 0;  	int iBarWidthModifier = 1;  	if (this.Encoded_Type == TYPE.PostNet)  		iBarWidthModifier = 2;  	//set alignment  	switch (Alignment) {  	case AlignmentPositions.CENTER:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	case AlignmentPositions.LEFT:  		shiftAdjustment = 0;  		break;  	case AlignmentPositions.RIGHT:  		shiftAdjustment = (Width % Encoded_Value.Length);  		break;  	default:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	}  	//switch  	if (iBarWidth <= 0)  		throw new Exception ("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	int halfBarWidth = (int)(iBarWidth * 0.5);  	using (Graphics g = Graphics.FromImage (b)) {  		//clears the image and colors the entire background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen backpen = new Pen (BackColor' iBarWidth / iBarWidthModifier)) {  			using (Pen pen = new Pen (ForeColor' iBarWidth / iBarWidthModifier)) {  				while (pos < Encoded_Value.Length) {  					if (this.Encoded_Type == TYPE.PostNet) {  						//draw half bars in postnet  						if (Encoded_Value [pos] == '0')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLableAdjustment));  						else  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment));  					} //if  					else {  						if (Encoded_Value [pos] == '1')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment));  					}  					pos++;  				}  				//while  			}  			//using  		}  		//using  	}  	//using  	if (IncludeLabel) {  		//if (this.EncodedType != TYPE.UPCA)  		Label_Generic ((Image)b);  		//else  		//    Label_UPCA((Image)b);  	}  	//if  	break;  }  //case  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type) {  case TYPE.ITF14: {  	// Automatically calculate the Width if applicable. Quite confusing with this  	// barcode type' and it seems this method overestimates the minimum width. But  	// at least it�s deterministic and doesn�t produce too small of a value.  	if (BarWidth.HasValue) {  		// Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone  		// Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20  		// Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length  		// Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)  		// Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)  		// Width = BarWidth * EncodedValue.Length / 176.9 * 241  		// Rounding error? + 1  		Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);  	}  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	if (IncludeLabel) {  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int bearerwidth = (int)((b.Width) / 12.05);  	int iquietzone = Convert.ToInt32 (b.Width * 0.05);  	int iBarWidth = (b.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;  	int shiftAdjustment = ((b.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;  	if (iBarWidth <= 0 || iquietzone <= 0)  		throw new Exception ("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	using (Graphics g = Graphics.FromImage (b)) {  		//fill background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen pen = new Pen (ForeColor' iBarWidth)) {  			pen.Alignment = PenAlignment.Right;  			while (pos < Encoded_Value.Length) {  				//draw the appropriate color line vertically  				if (Encoded_Value [pos] == '1')  					g.DrawLine (pen' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));  				pos++;  			}  			//while  			//bearer bars  			pen.Width = (float)ILHeight / 8;  			pen.Color = ForeColor;  			pen.Alignment = PenAlignment.Center;  			g.DrawLine (pen' new Point (0' 0)' new Point (b.Width' 0));  			//top  			g.DrawLine (pen' new Point (0' ILHeight)' new Point (b.Width' ILHeight));  			//bottom  			g.DrawLine (pen' new Point (0' 0)' new Point (0' ILHeight));  			//left  			g.DrawLine (pen' new Point (b.Width' 0)' new Point (b.Width' ILHeight));  			//right  		}  		//using  	}  	//using  	if (IncludeLabel)  		Label_ITF14 ((Image)b);  	break;  }  //case  default: {  	// Automatically calculate Width if applicable.  	Width = BarWidth * Encoded_Value.Length ?? Width;  	// Automatically calculate Height if applicable.  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	int topLableAdjustment = 0;  	if (IncludeLabel) {  		// Shift drawing down if top label.  		if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)  			topLableAdjustment = this.LabelFont.Height;  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int iBarWidth = Width / Encoded_Value.Length;  	int shiftAdjustment = 0;  	int iBarWidthModifier = 1;  	if (this.Encoded_Type == TYPE.PostNet)  		iBarWidthModifier = 2;  	//set alignment  	switch (Alignment) {  	case AlignmentPositions.CENTER:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	case AlignmentPositions.LEFT:  		shiftAdjustment = 0;  		break;  	case AlignmentPositions.RIGHT:  		shiftAdjustment = (Width % Encoded_Value.Length);  		break;  	default:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	}  	//switch  	if (iBarWidth <= 0)  		throw new Exception ("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	int halfBarWidth = (int)(iBarWidth * 0.5);  	using (Graphics g = Graphics.FromImage (b)) {  		//clears the image and colors the entire background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen backpen = new Pen (BackColor' iBarWidth / iBarWidthModifier)) {  			using (Pen pen = new Pen (ForeColor' iBarWidth / iBarWidthModifier)) {  				while (pos < Encoded_Value.Length) {  					if (this.Encoded_Type == TYPE.PostNet) {  						//draw half bars in postnet  						if (Encoded_Value [pos] == '0')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLableAdjustment));  						else  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment));  					} //if  					else {  						if (Encoded_Value [pos] == '1')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment));  					}  					pos++;  				}  				//while  			}  			//using  		}  		//using  	}  	//using  	if (IncludeLabel) {  		//if (this.EncodedType != TYPE.UPCA)  		Label_Generic ((Image)b);  		//else  		//    Label_UPCA((Image)b);  	}  	//if  	break;  }  //case  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type) {  case TYPE.ITF14: {  	// Automatically calculate the Width if applicable. Quite confusing with this  	// barcode type' and it seems this method overestimates the minimum width. But  	// at least it�s deterministic and doesn�t produce too small of a value.  	if (BarWidth.HasValue) {  		// Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone  		// Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20  		// Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length  		// Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)  		// Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)  		// Width = BarWidth * EncodedValue.Length / 176.9 * 241  		// Rounding error? + 1  		Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);  	}  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	if (IncludeLabel) {  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int bearerwidth = (int)((b.Width) / 12.05);  	int iquietzone = Convert.ToInt32 (b.Width * 0.05);  	int iBarWidth = (b.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;  	int shiftAdjustment = ((b.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;  	if (iBarWidth <= 0 || iquietzone <= 0)  		throw new Exception ("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	using (Graphics g = Graphics.FromImage (b)) {  		//fill background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen pen = new Pen (ForeColor' iBarWidth)) {  			pen.Alignment = PenAlignment.Right;  			while (pos < Encoded_Value.Length) {  				//draw the appropriate color line vertically  				if (Encoded_Value [pos] == '1')  					g.DrawLine (pen' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));  				pos++;  			}  			//while  			//bearer bars  			pen.Width = (float)ILHeight / 8;  			pen.Color = ForeColor;  			pen.Alignment = PenAlignment.Center;  			g.DrawLine (pen' new Point (0' 0)' new Point (b.Width' 0));  			//top  			g.DrawLine (pen' new Point (0' ILHeight)' new Point (b.Width' ILHeight));  			//bottom  			g.DrawLine (pen' new Point (0' 0)' new Point (0' ILHeight));  			//left  			g.DrawLine (pen' new Point (b.Width' 0)' new Point (b.Width' ILHeight));  			//right  		}  		//using  	}  	//using  	if (IncludeLabel)  		Label_ITF14 ((Image)b);  	break;  }  //case  default: {  	// Automatically calculate Width if applicable.  	Width = BarWidth * Encoded_Value.Length ?? Width;  	// Automatically calculate Height if applicable.  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	int topLableAdjustment = 0;  	if (IncludeLabel) {  		// Shift drawing down if top label.  		if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)  			topLableAdjustment = this.LabelFont.Height;  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int iBarWidth = Width / Encoded_Value.Length;  	int shiftAdjustment = 0;  	int iBarWidthModifier = 1;  	if (this.Encoded_Type == TYPE.PostNet)  		iBarWidthModifier = 2;  	//set alignment  	switch (Alignment) {  	case AlignmentPositions.CENTER:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	case AlignmentPositions.LEFT:  		shiftAdjustment = 0;  		break;  	case AlignmentPositions.RIGHT:  		shiftAdjustment = (Width % Encoded_Value.Length);  		break;  	default:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	}  	//switch  	if (iBarWidth <= 0)  		throw new Exception ("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	int halfBarWidth = (int)(iBarWidth * 0.5);  	using (Graphics g = Graphics.FromImage (b)) {  		//clears the image and colors the entire background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen backpen = new Pen (BackColor' iBarWidth / iBarWidthModifier)) {  			using (Pen pen = new Pen (ForeColor' iBarWidth / iBarWidthModifier)) {  				while (pos < Encoded_Value.Length) {  					if (this.Encoded_Type == TYPE.PostNet) {  						//draw half bars in postnet  						if (Encoded_Value [pos] == '0')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLableAdjustment));  						else  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment));  					} //if  					else {  						if (Encoded_Value [pos] == '1')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment));  					}  					pos++;  				}  				//while  			}  			//using  		}  		//using  	}  	//using  	if (IncludeLabel) {  		//if (this.EncodedType != TYPE.UPCA)  		Label_Generic ((Image)b);  		//else  		//    Label_UPCA((Image)b);  	}  	//if  	break;  }  //case  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type) {  case TYPE.ITF14: {  	// Automatically calculate the Width if applicable. Quite confusing with this  	// barcode type' and it seems this method overestimates the minimum width. But  	// at least it�s deterministic and doesn�t produce too small of a value.  	if (BarWidth.HasValue) {  		// Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone  		// Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20  		// Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length  		// Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)  		// Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)  		// Width = BarWidth * EncodedValue.Length / 176.9 * 241  		// Rounding error? + 1  		Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);  	}  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	if (IncludeLabel) {  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int bearerwidth = (int)((b.Width) / 12.05);  	int iquietzone = Convert.ToInt32 (b.Width * 0.05);  	int iBarWidth = (b.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;  	int shiftAdjustment = ((b.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;  	if (iBarWidth <= 0 || iquietzone <= 0)  		throw new Exception ("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	using (Graphics g = Graphics.FromImage (b)) {  		//fill background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen pen = new Pen (ForeColor' iBarWidth)) {  			pen.Alignment = PenAlignment.Right;  			while (pos < Encoded_Value.Length) {  				//draw the appropriate color line vertically  				if (Encoded_Value [pos] == '1')  					g.DrawLine (pen' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));  				pos++;  			}  			//while  			//bearer bars  			pen.Width = (float)ILHeight / 8;  			pen.Color = ForeColor;  			pen.Alignment = PenAlignment.Center;  			g.DrawLine (pen' new Point (0' 0)' new Point (b.Width' 0));  			//top  			g.DrawLine (pen' new Point (0' ILHeight)' new Point (b.Width' ILHeight));  			//bottom  			g.DrawLine (pen' new Point (0' 0)' new Point (0' ILHeight));  			//left  			g.DrawLine (pen' new Point (b.Width' 0)' new Point (b.Width' ILHeight));  			//right  		}  		//using  	}  	//using  	if (IncludeLabel)  		Label_ITF14 ((Image)b);  	break;  }  //case  default: {  	// Automatically calculate Width if applicable.  	Width = BarWidth * Encoded_Value.Length ?? Width;  	// Automatically calculate Height if applicable.  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	int topLableAdjustment = 0;  	if (IncludeLabel) {  		// Shift drawing down if top label.  		if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)  			topLableAdjustment = this.LabelFont.Height;  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int iBarWidth = Width / Encoded_Value.Length;  	int shiftAdjustment = 0;  	int iBarWidthModifier = 1;  	if (this.Encoded_Type == TYPE.PostNet)  		iBarWidthModifier = 2;  	//set alignment  	switch (Alignment) {  	case AlignmentPositions.CENTER:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	case AlignmentPositions.LEFT:  		shiftAdjustment = 0;  		break;  	case AlignmentPositions.RIGHT:  		shiftAdjustment = (Width % Encoded_Value.Length);  		break;  	default:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	}  	//switch  	if (iBarWidth <= 0)  		throw new Exception ("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	int halfBarWidth = (int)(iBarWidth * 0.5);  	using (Graphics g = Graphics.FromImage (b)) {  		//clears the image and colors the entire background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen backpen = new Pen (BackColor' iBarWidth / iBarWidthModifier)) {  			using (Pen pen = new Pen (ForeColor' iBarWidth / iBarWidthModifier)) {  				while (pos < Encoded_Value.Length) {  					if (this.Encoded_Type == TYPE.PostNet) {  						//draw half bars in postnet  						if (Encoded_Value [pos] == '0')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLableAdjustment));  						else  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment));  					} //if  					else {  						if (Encoded_Value [pos] == '1')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment));  					}  					pos++;  				}  				//while  			}  			//using  		}  		//using  	}  	//using  	if (IncludeLabel) {  		//if (this.EncodedType != TYPE.UPCA)  		Label_Generic ((Image)b);  		//else  		//    Label_UPCA((Image)b);  	}  	//if  	break;  }  //case  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type) {  case TYPE.ITF14: {  	// Automatically calculate the Width if applicable. Quite confusing with this  	// barcode type' and it seems this method overestimates the minimum width. But  	// at least it�s deterministic and doesn�t produce too small of a value.  	if (BarWidth.HasValue) {  		// Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone  		// Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20  		// Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length  		// Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)  		// Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)  		// Width = BarWidth * EncodedValue.Length / 176.9 * 241  		// Rounding error? + 1  		Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);  	}  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	if (IncludeLabel) {  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int bearerwidth = (int)((b.Width) / 12.05);  	int iquietzone = Convert.ToInt32 (b.Width * 0.05);  	int iBarWidth = (b.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;  	int shiftAdjustment = ((b.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;  	if (iBarWidth <= 0 || iquietzone <= 0)  		throw new Exception ("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	using (Graphics g = Graphics.FromImage (b)) {  		//fill background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen pen = new Pen (ForeColor' iBarWidth)) {  			pen.Alignment = PenAlignment.Right;  			while (pos < Encoded_Value.Length) {  				//draw the appropriate color line vertically  				if (Encoded_Value [pos] == '1')  					g.DrawLine (pen' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));  				pos++;  			}  			//while  			//bearer bars  			pen.Width = (float)ILHeight / 8;  			pen.Color = ForeColor;  			pen.Alignment = PenAlignment.Center;  			g.DrawLine (pen' new Point (0' 0)' new Point (b.Width' 0));  			//top  			g.DrawLine (pen' new Point (0' ILHeight)' new Point (b.Width' ILHeight));  			//bottom  			g.DrawLine (pen' new Point (0' 0)' new Point (0' ILHeight));  			//left  			g.DrawLine (pen' new Point (b.Width' 0)' new Point (b.Width' ILHeight));  			//right  		}  		//using  	}  	//using  	if (IncludeLabel)  		Label_ITF14 ((Image)b);  	break;  }  //case  default: {  	// Automatically calculate Width if applicable.  	Width = BarWidth * Encoded_Value.Length ?? Width;  	// Automatically calculate Height if applicable.  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	int topLableAdjustment = 0;  	if (IncludeLabel) {  		// Shift drawing down if top label.  		if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)  			topLableAdjustment = this.LabelFont.Height;  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int iBarWidth = Width / Encoded_Value.Length;  	int shiftAdjustment = 0;  	int iBarWidthModifier = 1;  	if (this.Encoded_Type == TYPE.PostNet)  		iBarWidthModifier = 2;  	//set alignment  	switch (Alignment) {  	case AlignmentPositions.CENTER:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	case AlignmentPositions.LEFT:  		shiftAdjustment = 0;  		break;  	case AlignmentPositions.RIGHT:  		shiftAdjustment = (Width % Encoded_Value.Length);  		break;  	default:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	}  	//switch  	if (iBarWidth <= 0)  		throw new Exception ("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	int halfBarWidth = (int)(iBarWidth * 0.5);  	using (Graphics g = Graphics.FromImage (b)) {  		//clears the image and colors the entire background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen backpen = new Pen (BackColor' iBarWidth / iBarWidthModifier)) {  			using (Pen pen = new Pen (ForeColor' iBarWidth / iBarWidthModifier)) {  				while (pos < Encoded_Value.Length) {  					if (this.Encoded_Type == TYPE.PostNet) {  						//draw half bars in postnet  						if (Encoded_Value [pos] == '0')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLableAdjustment));  						else  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment));  					} //if  					else {  						if (Encoded_Value [pos] == '1')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment));  					}  					pos++;  				}  				//while  			}  			//using  		}  		//using  	}  	//using  	if (IncludeLabel) {  		//if (this.EncodedType != TYPE.UPCA)  		Label_Generic ((Image)b);  		//else  		//    Label_UPCA((Image)b);  	}  	//if  	break;  }  //case  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type) {  case TYPE.ITF14: {  	// Automatically calculate the Width if applicable. Quite confusing with this  	// barcode type' and it seems this method overestimates the minimum width. But  	// at least it�s deterministic and doesn�t produce too small of a value.  	if (BarWidth.HasValue) {  		// Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone  		// Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20  		// Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length  		// Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)  		// Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)  		// Width = BarWidth * EncodedValue.Length / 176.9 * 241  		// Rounding error? + 1  		Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);  	}  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	if (IncludeLabel) {  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int bearerwidth = (int)((b.Width) / 12.05);  	int iquietzone = Convert.ToInt32 (b.Width * 0.05);  	int iBarWidth = (b.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;  	int shiftAdjustment = ((b.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;  	if (iBarWidth <= 0 || iquietzone <= 0)  		throw new Exception ("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	using (Graphics g = Graphics.FromImage (b)) {  		//fill background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen pen = new Pen (ForeColor' iBarWidth)) {  			pen.Alignment = PenAlignment.Right;  			while (pos < Encoded_Value.Length) {  				//draw the appropriate color line vertically  				if (Encoded_Value [pos] == '1')  					g.DrawLine (pen' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));  				pos++;  			}  			//while  			//bearer bars  			pen.Width = (float)ILHeight / 8;  			pen.Color = ForeColor;  			pen.Alignment = PenAlignment.Center;  			g.DrawLine (pen' new Point (0' 0)' new Point (b.Width' 0));  			//top  			g.DrawLine (pen' new Point (0' ILHeight)' new Point (b.Width' ILHeight));  			//bottom  			g.DrawLine (pen' new Point (0' 0)' new Point (0' ILHeight));  			//left  			g.DrawLine (pen' new Point (b.Width' 0)' new Point (b.Width' ILHeight));  			//right  		}  		//using  	}  	//using  	if (IncludeLabel)  		Label_ITF14 ((Image)b);  	break;  }  //case  default: {  	// Automatically calculate Width if applicable.  	Width = BarWidth * Encoded_Value.Length ?? Width;  	// Automatically calculate Height if applicable.  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	int topLableAdjustment = 0;  	if (IncludeLabel) {  		// Shift drawing down if top label.  		if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)  			topLableAdjustment = this.LabelFont.Height;  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int iBarWidth = Width / Encoded_Value.Length;  	int shiftAdjustment = 0;  	int iBarWidthModifier = 1;  	if (this.Encoded_Type == TYPE.PostNet)  		iBarWidthModifier = 2;  	//set alignment  	switch (Alignment) {  	case AlignmentPositions.CENTER:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	case AlignmentPositions.LEFT:  		shiftAdjustment = 0;  		break;  	case AlignmentPositions.RIGHT:  		shiftAdjustment = (Width % Encoded_Value.Length);  		break;  	default:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	}  	//switch  	if (iBarWidth <= 0)  		throw new Exception ("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	int halfBarWidth = (int)(iBarWidth * 0.5);  	using (Graphics g = Graphics.FromImage (b)) {  		//clears the image and colors the entire background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen backpen = new Pen (BackColor' iBarWidth / iBarWidthModifier)) {  			using (Pen pen = new Pen (ForeColor' iBarWidth / iBarWidthModifier)) {  				while (pos < Encoded_Value.Length) {  					if (this.Encoded_Type == TYPE.PostNet) {  						//draw half bars in postnet  						if (Encoded_Value [pos] == '0')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLableAdjustment));  						else  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment));  					} //if  					else {  						if (Encoded_Value [pos] == '1')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment));  					}  					pos++;  				}  				//while  			}  			//using  		}  		//using  	}  	//using  	if (IncludeLabel) {  		//if (this.EncodedType != TYPE.UPCA)  		Label_Generic ((Image)b);  		//else  		//    Label_UPCA((Image)b);  	}  	//if  	break;  }  //case  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type) {  case TYPE.ITF14: {  	// Automatically calculate the Width if applicable. Quite confusing with this  	// barcode type' and it seems this method overestimates the minimum width. But  	// at least it�s deterministic and doesn�t produce too small of a value.  	if (BarWidth.HasValue) {  		// Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone  		// Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20  		// Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length  		// Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)  		// Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)  		// Width = BarWidth * EncodedValue.Length / 176.9 * 241  		// Rounding error? + 1  		Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);  	}  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	if (IncludeLabel) {  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int bearerwidth = (int)((b.Width) / 12.05);  	int iquietzone = Convert.ToInt32 (b.Width * 0.05);  	int iBarWidth = (b.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;  	int shiftAdjustment = ((b.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;  	if (iBarWidth <= 0 || iquietzone <= 0)  		throw new Exception ("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	using (Graphics g = Graphics.FromImage (b)) {  		//fill background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen pen = new Pen (ForeColor' iBarWidth)) {  			pen.Alignment = PenAlignment.Right;  			while (pos < Encoded_Value.Length) {  				//draw the appropriate color line vertically  				if (Encoded_Value [pos] == '1')  					g.DrawLine (pen' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));  				pos++;  			}  			//while  			//bearer bars  			pen.Width = (float)ILHeight / 8;  			pen.Color = ForeColor;  			pen.Alignment = PenAlignment.Center;  			g.DrawLine (pen' new Point (0' 0)' new Point (b.Width' 0));  			//top  			g.DrawLine (pen' new Point (0' ILHeight)' new Point (b.Width' ILHeight));  			//bottom  			g.DrawLine (pen' new Point (0' 0)' new Point (0' ILHeight));  			//left  			g.DrawLine (pen' new Point (b.Width' 0)' new Point (b.Width' ILHeight));  			//right  		}  		//using  	}  	//using  	if (IncludeLabel)  		Label_ITF14 ((Image)b);  	break;  }  //case  default: {  	// Automatically calculate Width if applicable.  	Width = BarWidth * Encoded_Value.Length ?? Width;  	// Automatically calculate Height if applicable.  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	int topLableAdjustment = 0;  	if (IncludeLabel) {  		// Shift drawing down if top label.  		if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)  			topLableAdjustment = this.LabelFont.Height;  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int iBarWidth = Width / Encoded_Value.Length;  	int shiftAdjustment = 0;  	int iBarWidthModifier = 1;  	if (this.Encoded_Type == TYPE.PostNet)  		iBarWidthModifier = 2;  	//set alignment  	switch (Alignment) {  	case AlignmentPositions.CENTER:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	case AlignmentPositions.LEFT:  		shiftAdjustment = 0;  		break;  	case AlignmentPositions.RIGHT:  		shiftAdjustment = (Width % Encoded_Value.Length);  		break;  	default:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	}  	//switch  	if (iBarWidth <= 0)  		throw new Exception ("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	int halfBarWidth = (int)(iBarWidth * 0.5);  	using (Graphics g = Graphics.FromImage (b)) {  		//clears the image and colors the entire background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen backpen = new Pen (BackColor' iBarWidth / iBarWidthModifier)) {  			using (Pen pen = new Pen (ForeColor' iBarWidth / iBarWidthModifier)) {  				while (pos < Encoded_Value.Length) {  					if (this.Encoded_Type == TYPE.PostNet) {  						//draw half bars in postnet  						if (Encoded_Value [pos] == '0')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLableAdjustment));  						else  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment));  					} //if  					else {  						if (Encoded_Value [pos] == '1')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment));  					}  					pos++;  				}  				//while  			}  			//using  		}  		//using  	}  	//using  	if (IncludeLabel) {  		//if (this.EncodedType != TYPE.UPCA)  		Label_Generic ((Image)b);  		//else  		//    Label_UPCA((Image)b);  	}  	//if  	break;  }  //case  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type) {  case TYPE.ITF14: {  	// Automatically calculate the Width if applicable. Quite confusing with this  	// barcode type' and it seems this method overestimates the minimum width. But  	// at least it�s deterministic and doesn�t produce too small of a value.  	if (BarWidth.HasValue) {  		// Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone  		// Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20  		// Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length  		// Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)  		// Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)  		// Width = BarWidth * EncodedValue.Length / 176.9 * 241  		// Rounding error? + 1  		Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);  	}  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	if (IncludeLabel) {  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int bearerwidth = (int)((b.Width) / 12.05);  	int iquietzone = Convert.ToInt32 (b.Width * 0.05);  	int iBarWidth = (b.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;  	int shiftAdjustment = ((b.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;  	if (iBarWidth <= 0 || iquietzone <= 0)  		throw new Exception ("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	using (Graphics g = Graphics.FromImage (b)) {  		//fill background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen pen = new Pen (ForeColor' iBarWidth)) {  			pen.Alignment = PenAlignment.Right;  			while (pos < Encoded_Value.Length) {  				//draw the appropriate color line vertically  				if (Encoded_Value [pos] == '1')  					g.DrawLine (pen' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));  				pos++;  			}  			//while  			//bearer bars  			pen.Width = (float)ILHeight / 8;  			pen.Color = ForeColor;  			pen.Alignment = PenAlignment.Center;  			g.DrawLine (pen' new Point (0' 0)' new Point (b.Width' 0));  			//top  			g.DrawLine (pen' new Point (0' ILHeight)' new Point (b.Width' ILHeight));  			//bottom  			g.DrawLine (pen' new Point (0' 0)' new Point (0' ILHeight));  			//left  			g.DrawLine (pen' new Point (b.Width' 0)' new Point (b.Width' ILHeight));  			//right  		}  		//using  	}  	//using  	if (IncludeLabel)  		Label_ITF14 ((Image)b);  	break;  }  //case  default: {  	// Automatically calculate Width if applicable.  	Width = BarWidth * Encoded_Value.Length ?? Width;  	// Automatically calculate Height if applicable.  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	int topLableAdjustment = 0;  	if (IncludeLabel) {  		// Shift drawing down if top label.  		if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)  			topLableAdjustment = this.LabelFont.Height;  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int iBarWidth = Width / Encoded_Value.Length;  	int shiftAdjustment = 0;  	int iBarWidthModifier = 1;  	if (this.Encoded_Type == TYPE.PostNet)  		iBarWidthModifier = 2;  	//set alignment  	switch (Alignment) {  	case AlignmentPositions.CENTER:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	case AlignmentPositions.LEFT:  		shiftAdjustment = 0;  		break;  	case AlignmentPositions.RIGHT:  		shiftAdjustment = (Width % Encoded_Value.Length);  		break;  	default:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	}  	//switch  	if (iBarWidth <= 0)  		throw new Exception ("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	int halfBarWidth = (int)(iBarWidth * 0.5);  	using (Graphics g = Graphics.FromImage (b)) {  		//clears the image and colors the entire background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen backpen = new Pen (BackColor' iBarWidth / iBarWidthModifier)) {  			using (Pen pen = new Pen (ForeColor' iBarWidth / iBarWidthModifier)) {  				while (pos < Encoded_Value.Length) {  					if (this.Encoded_Type == TYPE.PostNet) {  						//draw half bars in postnet  						if (Encoded_Value [pos] == '0')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLableAdjustment));  						else  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment));  					} //if  					else {  						if (Encoded_Value [pos] == '1')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment));  					}  					pos++;  				}  				//while  			}  			//using  		}  		//using  	}  	//using  	if (IncludeLabel) {  		//if (this.EncodedType != TYPE.UPCA)  		Label_Generic ((Image)b);  		//else  		//    Label_UPCA((Image)b);  	}  	//if  	break;  }  //case  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type) {  case TYPE.ITF14: {  	// Automatically calculate the Width if applicable. Quite confusing with this  	// barcode type' and it seems this method overestimates the minimum width. But  	// at least it�s deterministic and doesn�t produce too small of a value.  	if (BarWidth.HasValue) {  		// Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone  		// Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20  		// Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length  		// Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)  		// Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)  		// Width = BarWidth * EncodedValue.Length / 176.9 * 241  		// Rounding error? + 1  		Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);  	}  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	if (IncludeLabel) {  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int bearerwidth = (int)((b.Width) / 12.05);  	int iquietzone = Convert.ToInt32 (b.Width * 0.05);  	int iBarWidth = (b.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;  	int shiftAdjustment = ((b.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;  	if (iBarWidth <= 0 || iquietzone <= 0)  		throw new Exception ("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	using (Graphics g = Graphics.FromImage (b)) {  		//fill background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen pen = new Pen (ForeColor' iBarWidth)) {  			pen.Alignment = PenAlignment.Right;  			while (pos < Encoded_Value.Length) {  				//draw the appropriate color line vertically  				if (Encoded_Value [pos] == '1')  					g.DrawLine (pen' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));  				pos++;  			}  			//while  			//bearer bars  			pen.Width = (float)ILHeight / 8;  			pen.Color = ForeColor;  			pen.Alignment = PenAlignment.Center;  			g.DrawLine (pen' new Point (0' 0)' new Point (b.Width' 0));  			//top  			g.DrawLine (pen' new Point (0' ILHeight)' new Point (b.Width' ILHeight));  			//bottom  			g.DrawLine (pen' new Point (0' 0)' new Point (0' ILHeight));  			//left  			g.DrawLine (pen' new Point (b.Width' 0)' new Point (b.Width' ILHeight));  			//right  		}  		//using  	}  	//using  	if (IncludeLabel)  		Label_ITF14 ((Image)b);  	break;  }  //case  default: {  	// Automatically calculate Width if applicable.  	Width = BarWidth * Encoded_Value.Length ?? Width;  	// Automatically calculate Height if applicable.  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	int topLableAdjustment = 0;  	if (IncludeLabel) {  		// Shift drawing down if top label.  		if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)  			topLableAdjustment = this.LabelFont.Height;  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int iBarWidth = Width / Encoded_Value.Length;  	int shiftAdjustment = 0;  	int iBarWidthModifier = 1;  	if (this.Encoded_Type == TYPE.PostNet)  		iBarWidthModifier = 2;  	//set alignment  	switch (Alignment) {  	case AlignmentPositions.CENTER:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	case AlignmentPositions.LEFT:  		shiftAdjustment = 0;  		break;  	case AlignmentPositions.RIGHT:  		shiftAdjustment = (Width % Encoded_Value.Length);  		break;  	default:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	}  	//switch  	if (iBarWidth <= 0)  		throw new Exception ("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	int halfBarWidth = (int)(iBarWidth * 0.5);  	using (Graphics g = Graphics.FromImage (b)) {  		//clears the image and colors the entire background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen backpen = new Pen (BackColor' iBarWidth / iBarWidthModifier)) {  			using (Pen pen = new Pen (ForeColor' iBarWidth / iBarWidthModifier)) {  				while (pos < Encoded_Value.Length) {  					if (this.Encoded_Type == TYPE.PostNet) {  						//draw half bars in postnet  						if (Encoded_Value [pos] == '0')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLableAdjustment));  						else  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment));  					} //if  					else {  						if (Encoded_Value [pos] == '1')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment));  					}  					pos++;  				}  				//while  			}  			//using  		}  		//using  	}  	//using  	if (IncludeLabel) {  		//if (this.EncodedType != TYPE.UPCA)  		Label_Generic ((Image)b);  		//else  		//    Label_UPCA((Image)b);  	}  	//if  	break;  }  //case  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type) {  case TYPE.ITF14: {  	// Automatically calculate the Width if applicable. Quite confusing with this  	// barcode type' and it seems this method overestimates the minimum width. But  	// at least it�s deterministic and doesn�t produce too small of a value.  	if (BarWidth.HasValue) {  		// Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone  		// Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20  		// Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length  		// Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)  		// Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)  		// Width = BarWidth * EncodedValue.Length / 176.9 * 241  		// Rounding error? + 1  		Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);  	}  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	if (IncludeLabel) {  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int bearerwidth = (int)((b.Width) / 12.05);  	int iquietzone = Convert.ToInt32 (b.Width * 0.05);  	int iBarWidth = (b.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;  	int shiftAdjustment = ((b.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;  	if (iBarWidth <= 0 || iquietzone <= 0)  		throw new Exception ("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	using (Graphics g = Graphics.FromImage (b)) {  		//fill background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen pen = new Pen (ForeColor' iBarWidth)) {  			pen.Alignment = PenAlignment.Right;  			while (pos < Encoded_Value.Length) {  				//draw the appropriate color line vertically  				if (Encoded_Value [pos] == '1')  					g.DrawLine (pen' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));  				pos++;  			}  			//while  			//bearer bars  			pen.Width = (float)ILHeight / 8;  			pen.Color = ForeColor;  			pen.Alignment = PenAlignment.Center;  			g.DrawLine (pen' new Point (0' 0)' new Point (b.Width' 0));  			//top  			g.DrawLine (pen' new Point (0' ILHeight)' new Point (b.Width' ILHeight));  			//bottom  			g.DrawLine (pen' new Point (0' 0)' new Point (0' ILHeight));  			//left  			g.DrawLine (pen' new Point (b.Width' 0)' new Point (b.Width' ILHeight));  			//right  		}  		//using  	}  	//using  	if (IncludeLabel)  		Label_ITF14 ((Image)b);  	break;  }  //case  default: {  	// Automatically calculate Width if applicable.  	Width = BarWidth * Encoded_Value.Length ?? Width;  	// Automatically calculate Height if applicable.  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	int topLableAdjustment = 0;  	if (IncludeLabel) {  		// Shift drawing down if top label.  		if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)  			topLableAdjustment = this.LabelFont.Height;  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int iBarWidth = Width / Encoded_Value.Length;  	int shiftAdjustment = 0;  	int iBarWidthModifier = 1;  	if (this.Encoded_Type == TYPE.PostNet)  		iBarWidthModifier = 2;  	//set alignment  	switch (Alignment) {  	case AlignmentPositions.CENTER:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	case AlignmentPositions.LEFT:  		shiftAdjustment = 0;  		break;  	case AlignmentPositions.RIGHT:  		shiftAdjustment = (Width % Encoded_Value.Length);  		break;  	default:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	}  	//switch  	if (iBarWidth <= 0)  		throw new Exception ("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	int halfBarWidth = (int)(iBarWidth * 0.5);  	using (Graphics g = Graphics.FromImage (b)) {  		//clears the image and colors the entire background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen backpen = new Pen (BackColor' iBarWidth / iBarWidthModifier)) {  			using (Pen pen = new Pen (ForeColor' iBarWidth / iBarWidthModifier)) {  				while (pos < Encoded_Value.Length) {  					if (this.Encoded_Type == TYPE.PostNet) {  						//draw half bars in postnet  						if (Encoded_Value [pos] == '0')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLableAdjustment));  						else  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment));  					} //if  					else {  						if (Encoded_Value [pos] == '1')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment));  					}  					pos++;  				}  				//while  			}  			//using  		}  		//using  	}  	//using  	if (IncludeLabel) {  		//if (this.EncodedType != TYPE.UPCA)  		Label_Generic ((Image)b);  		//else  		//    Label_UPCA((Image)b);  	}  	//if  	break;  }  //case  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type) {  case TYPE.ITF14: {  	// Automatically calculate the Width if applicable. Quite confusing with this  	// barcode type' and it seems this method overestimates the minimum width. But  	// at least it�s deterministic and doesn�t produce too small of a value.  	if (BarWidth.HasValue) {  		// Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone  		// Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20  		// Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length  		// Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)  		// Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)  		// Width = BarWidth * EncodedValue.Length / 176.9 * 241  		// Rounding error? + 1  		Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);  	}  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	if (IncludeLabel) {  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int bearerwidth = (int)((b.Width) / 12.05);  	int iquietzone = Convert.ToInt32 (b.Width * 0.05);  	int iBarWidth = (b.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;  	int shiftAdjustment = ((b.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;  	if (iBarWidth <= 0 || iquietzone <= 0)  		throw new Exception ("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	using (Graphics g = Graphics.FromImage (b)) {  		//fill background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen pen = new Pen (ForeColor' iBarWidth)) {  			pen.Alignment = PenAlignment.Right;  			while (pos < Encoded_Value.Length) {  				//draw the appropriate color line vertically  				if (Encoded_Value [pos] == '1')  					g.DrawLine (pen' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));  				pos++;  			}  			//while  			//bearer bars  			pen.Width = (float)ILHeight / 8;  			pen.Color = ForeColor;  			pen.Alignment = PenAlignment.Center;  			g.DrawLine (pen' new Point (0' 0)' new Point (b.Width' 0));  			//top  			g.DrawLine (pen' new Point (0' ILHeight)' new Point (b.Width' ILHeight));  			//bottom  			g.DrawLine (pen' new Point (0' 0)' new Point (0' ILHeight));  			//left  			g.DrawLine (pen' new Point (b.Width' 0)' new Point (b.Width' ILHeight));  			//right  		}  		//using  	}  	//using  	if (IncludeLabel)  		Label_ITF14 ((Image)b);  	break;  }  //case  default: {  	// Automatically calculate Width if applicable.  	Width = BarWidth * Encoded_Value.Length ?? Width;  	// Automatically calculate Height if applicable.  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	int topLableAdjustment = 0;  	if (IncludeLabel) {  		// Shift drawing down if top label.  		if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)  			topLableAdjustment = this.LabelFont.Height;  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int iBarWidth = Width / Encoded_Value.Length;  	int shiftAdjustment = 0;  	int iBarWidthModifier = 1;  	if (this.Encoded_Type == TYPE.PostNet)  		iBarWidthModifier = 2;  	//set alignment  	switch (Alignment) {  	case AlignmentPositions.CENTER:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	case AlignmentPositions.LEFT:  		shiftAdjustment = 0;  		break;  	case AlignmentPositions.RIGHT:  		shiftAdjustment = (Width % Encoded_Value.Length);  		break;  	default:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	}  	//switch  	if (iBarWidth <= 0)  		throw new Exception ("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	int halfBarWidth = (int)(iBarWidth * 0.5);  	using (Graphics g = Graphics.FromImage (b)) {  		//clears the image and colors the entire background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen backpen = new Pen (BackColor' iBarWidth / iBarWidthModifier)) {  			using (Pen pen = new Pen (ForeColor' iBarWidth / iBarWidthModifier)) {  				while (pos < Encoded_Value.Length) {  					if (this.Encoded_Type == TYPE.PostNet) {  						//draw half bars in postnet  						if (Encoded_Value [pos] == '0')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLableAdjustment));  						else  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment));  					} //if  					else {  						if (Encoded_Value [pos] == '1')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment));  					}  					pos++;  				}  				//while  			}  			//using  		}  		//using  	}  	//using  	if (IncludeLabel) {  		//if (this.EncodedType != TYPE.UPCA)  		Label_Generic ((Image)b);  		//else  		//    Label_UPCA((Image)b);  	}  	//if  	break;  }  //case  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type) {  case TYPE.ITF14: {  	// Automatically calculate the Width if applicable. Quite confusing with this  	// barcode type' and it seems this method overestimates the minimum width. But  	// at least it�s deterministic and doesn�t produce too small of a value.  	if (BarWidth.HasValue) {  		// Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone  		// Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20  		// Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length  		// Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)  		// Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)  		// Width = BarWidth * EncodedValue.Length / 176.9 * 241  		// Rounding error? + 1  		Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);  	}  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	if (IncludeLabel) {  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int bearerwidth = (int)((b.Width) / 12.05);  	int iquietzone = Convert.ToInt32 (b.Width * 0.05);  	int iBarWidth = (b.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;  	int shiftAdjustment = ((b.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;  	if (iBarWidth <= 0 || iquietzone <= 0)  		throw new Exception ("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	using (Graphics g = Graphics.FromImage (b)) {  		//fill background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen pen = new Pen (ForeColor' iBarWidth)) {  			pen.Alignment = PenAlignment.Right;  			while (pos < Encoded_Value.Length) {  				//draw the appropriate color line vertically  				if (Encoded_Value [pos] == '1')  					g.DrawLine (pen' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));  				pos++;  			}  			//while  			//bearer bars  			pen.Width = (float)ILHeight / 8;  			pen.Color = ForeColor;  			pen.Alignment = PenAlignment.Center;  			g.DrawLine (pen' new Point (0' 0)' new Point (b.Width' 0));  			//top  			g.DrawLine (pen' new Point (0' ILHeight)' new Point (b.Width' ILHeight));  			//bottom  			g.DrawLine (pen' new Point (0' 0)' new Point (0' ILHeight));  			//left  			g.DrawLine (pen' new Point (b.Width' 0)' new Point (b.Width' ILHeight));  			//right  		}  		//using  	}  	//using  	if (IncludeLabel)  		Label_ITF14 ((Image)b);  	break;  }  //case  default: {  	// Automatically calculate Width if applicable.  	Width = BarWidth * Encoded_Value.Length ?? Width;  	// Automatically calculate Height if applicable.  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	int topLableAdjustment = 0;  	if (IncludeLabel) {  		// Shift drawing down if top label.  		if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)  			topLableAdjustment = this.LabelFont.Height;  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int iBarWidth = Width / Encoded_Value.Length;  	int shiftAdjustment = 0;  	int iBarWidthModifier = 1;  	if (this.Encoded_Type == TYPE.PostNet)  		iBarWidthModifier = 2;  	//set alignment  	switch (Alignment) {  	case AlignmentPositions.CENTER:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	case AlignmentPositions.LEFT:  		shiftAdjustment = 0;  		break;  	case AlignmentPositions.RIGHT:  		shiftAdjustment = (Width % Encoded_Value.Length);  		break;  	default:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	}  	//switch  	if (iBarWidth <= 0)  		throw new Exception ("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	int halfBarWidth = (int)(iBarWidth * 0.5);  	using (Graphics g = Graphics.FromImage (b)) {  		//clears the image and colors the entire background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen backpen = new Pen (BackColor' iBarWidth / iBarWidthModifier)) {  			using (Pen pen = new Pen (ForeColor' iBarWidth / iBarWidthModifier)) {  				while (pos < Encoded_Value.Length) {  					if (this.Encoded_Type == TYPE.PostNet) {  						//draw half bars in postnet  						if (Encoded_Value [pos] == '0')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLableAdjustment));  						else  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment));  					} //if  					else {  						if (Encoded_Value [pos] == '1')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment));  					}  					pos++;  				}  				//while  			}  			//using  		}  		//using  	}  	//using  	if (IncludeLabel) {  		//if (this.EncodedType != TYPE.UPCA)  		Label_Generic ((Image)b);  		//else  		//    Label_UPCA((Image)b);  	}  	//if  	break;  }  //case  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type) {  case TYPE.ITF14: {  	// Automatically calculate the Width if applicable. Quite confusing with this  	// barcode type' and it seems this method overestimates the minimum width. But  	// at least it�s deterministic and doesn�t produce too small of a value.  	if (BarWidth.HasValue) {  		// Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone  		// Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20  		// Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length  		// Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)  		// Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)  		// Width = BarWidth * EncodedValue.Length / 176.9 * 241  		// Rounding error? + 1  		Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);  	}  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	if (IncludeLabel) {  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int bearerwidth = (int)((b.Width) / 12.05);  	int iquietzone = Convert.ToInt32 (b.Width * 0.05);  	int iBarWidth = (b.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;  	int shiftAdjustment = ((b.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;  	if (iBarWidth <= 0 || iquietzone <= 0)  		throw new Exception ("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	using (Graphics g = Graphics.FromImage (b)) {  		//fill background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen pen = new Pen (ForeColor' iBarWidth)) {  			pen.Alignment = PenAlignment.Right;  			while (pos < Encoded_Value.Length) {  				//draw the appropriate color line vertically  				if (Encoded_Value [pos] == '1')  					g.DrawLine (pen' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));  				pos++;  			}  			//while  			//bearer bars  			pen.Width = (float)ILHeight / 8;  			pen.Color = ForeColor;  			pen.Alignment = PenAlignment.Center;  			g.DrawLine (pen' new Point (0' 0)' new Point (b.Width' 0));  			//top  			g.DrawLine (pen' new Point (0' ILHeight)' new Point (b.Width' ILHeight));  			//bottom  			g.DrawLine (pen' new Point (0' 0)' new Point (0' ILHeight));  			//left  			g.DrawLine (pen' new Point (b.Width' 0)' new Point (b.Width' ILHeight));  			//right  		}  		//using  	}  	//using  	if (IncludeLabel)  		Label_ITF14 ((Image)b);  	break;  }  //case  default: {  	// Automatically calculate Width if applicable.  	Width = BarWidth * Encoded_Value.Length ?? Width;  	// Automatically calculate Height if applicable.  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	int topLableAdjustment = 0;  	if (IncludeLabel) {  		// Shift drawing down if top label.  		if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)  			topLableAdjustment = this.LabelFont.Height;  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int iBarWidth = Width / Encoded_Value.Length;  	int shiftAdjustment = 0;  	int iBarWidthModifier = 1;  	if (this.Encoded_Type == TYPE.PostNet)  		iBarWidthModifier = 2;  	//set alignment  	switch (Alignment) {  	case AlignmentPositions.CENTER:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	case AlignmentPositions.LEFT:  		shiftAdjustment = 0;  		break;  	case AlignmentPositions.RIGHT:  		shiftAdjustment = (Width % Encoded_Value.Length);  		break;  	default:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	}  	//switch  	if (iBarWidth <= 0)  		throw new Exception ("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	int halfBarWidth = (int)(iBarWidth * 0.5);  	using (Graphics g = Graphics.FromImage (b)) {  		//clears the image and colors the entire background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen backpen = new Pen (BackColor' iBarWidth / iBarWidthModifier)) {  			using (Pen pen = new Pen (ForeColor' iBarWidth / iBarWidthModifier)) {  				while (pos < Encoded_Value.Length) {  					if (this.Encoded_Type == TYPE.PostNet) {  						//draw half bars in postnet  						if (Encoded_Value [pos] == '0')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLableAdjustment));  						else  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment));  					} //if  					else {  						if (Encoded_Value [pos] == '1')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment));  					}  					pos++;  				}  				//while  			}  			//using  		}  		//using  	}  	//using  	if (IncludeLabel) {  		//if (this.EncodedType != TYPE.UPCA)  		Label_Generic ((Image)b);  		//else  		//    Label_UPCA((Image)b);  	}  	//if  	break;  }  //case  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type) {  case TYPE.ITF14: {  	// Automatically calculate the Width if applicable. Quite confusing with this  	// barcode type' and it seems this method overestimates the minimum width. But  	// at least it�s deterministic and doesn�t produce too small of a value.  	if (BarWidth.HasValue) {  		// Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone  		// Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20  		// Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length  		// Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)  		// Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)  		// Width = BarWidth * EncodedValue.Length / 176.9 * 241  		// Rounding error? + 1  		Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);  	}  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	if (IncludeLabel) {  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int bearerwidth = (int)((b.Width) / 12.05);  	int iquietzone = Convert.ToInt32 (b.Width * 0.05);  	int iBarWidth = (b.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;  	int shiftAdjustment = ((b.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;  	if (iBarWidth <= 0 || iquietzone <= 0)  		throw new Exception ("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	using (Graphics g = Graphics.FromImage (b)) {  		//fill background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen pen = new Pen (ForeColor' iBarWidth)) {  			pen.Alignment = PenAlignment.Right;  			while (pos < Encoded_Value.Length) {  				//draw the appropriate color line vertically  				if (Encoded_Value [pos] == '1')  					g.DrawLine (pen' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));  				pos++;  			}  			//while  			//bearer bars  			pen.Width = (float)ILHeight / 8;  			pen.Color = ForeColor;  			pen.Alignment = PenAlignment.Center;  			g.DrawLine (pen' new Point (0' 0)' new Point (b.Width' 0));  			//top  			g.DrawLine (pen' new Point (0' ILHeight)' new Point (b.Width' ILHeight));  			//bottom  			g.DrawLine (pen' new Point (0' 0)' new Point (0' ILHeight));  			//left  			g.DrawLine (pen' new Point (b.Width' 0)' new Point (b.Width' ILHeight));  			//right  		}  		//using  	}  	//using  	if (IncludeLabel)  		Label_ITF14 ((Image)b);  	break;  }  //case  default: {  	// Automatically calculate Width if applicable.  	Width = BarWidth * Encoded_Value.Length ?? Width;  	// Automatically calculate Height if applicable.  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	int topLableAdjustment = 0;  	if (IncludeLabel) {  		// Shift drawing down if top label.  		if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)  			topLableAdjustment = this.LabelFont.Height;  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int iBarWidth = Width / Encoded_Value.Length;  	int shiftAdjustment = 0;  	int iBarWidthModifier = 1;  	if (this.Encoded_Type == TYPE.PostNet)  		iBarWidthModifier = 2;  	//set alignment  	switch (Alignment) {  	case AlignmentPositions.CENTER:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	case AlignmentPositions.LEFT:  		shiftAdjustment = 0;  		break;  	case AlignmentPositions.RIGHT:  		shiftAdjustment = (Width % Encoded_Value.Length);  		break;  	default:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	}  	//switch  	if (iBarWidth <= 0)  		throw new Exception ("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	int halfBarWidth = (int)(iBarWidth * 0.5);  	using (Graphics g = Graphics.FromImage (b)) {  		//clears the image and colors the entire background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen backpen = new Pen (BackColor' iBarWidth / iBarWidthModifier)) {  			using (Pen pen = new Pen (ForeColor' iBarWidth / iBarWidthModifier)) {  				while (pos < Encoded_Value.Length) {  					if (this.Encoded_Type == TYPE.PostNet) {  						//draw half bars in postnet  						if (Encoded_Value [pos] == '0')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLableAdjustment));  						else  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment));  					} //if  					else {  						if (Encoded_Value [pos] == '1')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment));  					}  					pos++;  				}  				//while  			}  			//using  		}  		//using  	}  	//using  	if (IncludeLabel) {  		//if (this.EncodedType != TYPE.UPCA)  		Label_Generic ((Image)b);  		//else  		//    Label_UPCA((Image)b);  	}  	//if  	break;  }  //case  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type) {  case TYPE.ITF14: {  	// Automatically calculate the Width if applicable. Quite confusing with this  	// barcode type' and it seems this method overestimates the minimum width. But  	// at least it�s deterministic and doesn�t produce too small of a value.  	if (BarWidth.HasValue) {  		// Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone  		// Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20  		// Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length  		// Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)  		// Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)  		// Width = BarWidth * EncodedValue.Length / 176.9 * 241  		// Rounding error? + 1  		Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);  	}  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	if (IncludeLabel) {  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int bearerwidth = (int)((b.Width) / 12.05);  	int iquietzone = Convert.ToInt32 (b.Width * 0.05);  	int iBarWidth = (b.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;  	int shiftAdjustment = ((b.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;  	if (iBarWidth <= 0 || iquietzone <= 0)  		throw new Exception ("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	using (Graphics g = Graphics.FromImage (b)) {  		//fill background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen pen = new Pen (ForeColor' iBarWidth)) {  			pen.Alignment = PenAlignment.Right;  			while (pos < Encoded_Value.Length) {  				//draw the appropriate color line vertically  				if (Encoded_Value [pos] == '1')  					g.DrawLine (pen' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));  				pos++;  			}  			//while  			//bearer bars  			pen.Width = (float)ILHeight / 8;  			pen.Color = ForeColor;  			pen.Alignment = PenAlignment.Center;  			g.DrawLine (pen' new Point (0' 0)' new Point (b.Width' 0));  			//top  			g.DrawLine (pen' new Point (0' ILHeight)' new Point (b.Width' ILHeight));  			//bottom  			g.DrawLine (pen' new Point (0' 0)' new Point (0' ILHeight));  			//left  			g.DrawLine (pen' new Point (b.Width' 0)' new Point (b.Width' ILHeight));  			//right  		}  		//using  	}  	//using  	if (IncludeLabel)  		Label_ITF14 ((Image)b);  	break;  }  //case  default: {  	// Automatically calculate Width if applicable.  	Width = BarWidth * Encoded_Value.Length ?? Width;  	// Automatically calculate Height if applicable.  	Height = (int?)(Width / AspectRatio) ?? Height;  	int ILHeight = Height;  	int topLableAdjustment = 0;  	if (IncludeLabel) {  		// Shift drawing down if top label.  		if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)  			topLableAdjustment = this.LabelFont.Height;  		ILHeight -= this.LabelFont.Height;  	}  	b = new Bitmap (Width' Height);  	int iBarWidth = Width / Encoded_Value.Length;  	int shiftAdjustment = 0;  	int iBarWidthModifier = 1;  	if (this.Encoded_Type == TYPE.PostNet)  		iBarWidthModifier = 2;  	//set alignment  	switch (Alignment) {  	case AlignmentPositions.CENTER:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	case AlignmentPositions.LEFT:  		shiftAdjustment = 0;  		break;  	case AlignmentPositions.RIGHT:  		shiftAdjustment = (Width % Encoded_Value.Length);  		break;  	default:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	}  	//switch  	if (iBarWidth <= 0)  		throw new Exception ("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");  	//draw image  	int pos = 0;  	int halfBarWidth = (int)(iBarWidth * 0.5);  	using (Graphics g = Graphics.FromImage (b)) {  		//clears the image and colors the entire background  		g.Clear (BackColor);  		//lines are fBarWidth wide so draw the appropriate color line vertically  		using (Pen backpen = new Pen (BackColor' iBarWidth / iBarWidthModifier)) {  			using (Pen pen = new Pen (ForeColor' iBarWidth / iBarWidthModifier)) {  				while (pos < Encoded_Value.Length) {  					if (this.Encoded_Type == TYPE.PostNet) {  						//draw half bars in postnet  						if (Encoded_Value [pos] == '0')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLableAdjustment));  						else  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment));  					} //if  					else {  						if (Encoded_Value [pos] == '1')  							g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment));  					}  					pos++;  				}  				//while  			}  			//using  		}  		//using  	}  	//using  	if (IncludeLabel) {  		//if (this.EncodedType != TYPE.UPCA)  		Label_Generic ((Image)b);  		//else  		//    Label_UPCA((Image)b);  	}  	//if  	break;  }  //case  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: if (BarWidth.HasValue) {  	// Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone  	// Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20  	// Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length  	// Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)  	// Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)  	// Width = BarWidth * EncodedValue.Length / 176.9 * 241  	// Rounding error? + 1  	Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: if (BarWidth.HasValue) {  	// Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone  	// Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20  	// Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length  	// Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)  	// Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)  	// Width = BarWidth * EncodedValue.Length / 176.9 * 241  	// Rounding error? + 1  	Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (b)) {  	//fill background  	g.Clear (BackColor);  	//lines are fBarWidth wide so draw the appropriate color line vertically  	using (Pen pen = new Pen (ForeColor' iBarWidth)) {  		pen.Alignment = PenAlignment.Right;  		while (pos < Encoded_Value.Length) {  			//draw the appropriate color line vertically  			if (Encoded_Value [pos] == '1')  				g.DrawLine (pen' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));  			pos++;  		}  		//while  		//bearer bars  		pen.Width = (float)ILHeight / 8;  		pen.Color = ForeColor;  		pen.Alignment = PenAlignment.Center;  		g.DrawLine (pen' new Point (0' 0)' new Point (b.Width' 0));  		//top  		g.DrawLine (pen' new Point (0' ILHeight)' new Point (b.Width' ILHeight));  		//bottom  		g.DrawLine (pen' new Point (0' 0)' new Point (0' ILHeight));  		//left  		g.DrawLine (pen' new Point (b.Width' 0)' new Point (b.Width' ILHeight));  		//right  	}  	//using  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: using (Pen pen = new Pen (ForeColor' iBarWidth)) {  	pen.Alignment = PenAlignment.Right;  	while (pos < Encoded_Value.Length) {  		//draw the appropriate color line vertically  		if (Encoded_Value [pos] == '1')  			g.DrawLine (pen' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point ((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));  		pos++;  	}  	//while  	//bearer bars  	pen.Width = (float)ILHeight / 8;  	pen.Color = ForeColor;  	pen.Alignment = PenAlignment.Center;  	g.DrawLine (pen' new Point (0' 0)' new Point (b.Width' 0));  	//top  	g.DrawLine (pen' new Point (0' ILHeight)' new Point (b.Width' ILHeight));  	//bottom  	g.DrawLine (pen' new Point (0' 0)' new Point (0' ILHeight));  	//left  	g.DrawLine (pen' new Point (b.Width' 0)' new Point (b.Width' ILHeight));  	//right  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: pen.Width = (float)ILHeight / 8;  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: if (this.Encoded_Type == TYPE.PostNet)  	iBarWidthModifier = 2;  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: iBarWidthModifier = 2;  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (Alignment) {  case AlignmentPositions.CENTER:  	shiftAdjustment = (Width % Encoded_Value.Length) / 2;  	break;  case AlignmentPositions.LEFT:  	shiftAdjustment = 0;  	break;  case AlignmentPositions.RIGHT:  	shiftAdjustment = (Width % Encoded_Value.Length);  	break;  default:  	shiftAdjustment = (Width % Encoded_Value.Length) / 2;  	break;  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (Alignment) {  case AlignmentPositions.CENTER:  	shiftAdjustment = (Width % Encoded_Value.Length) / 2;  	break;  case AlignmentPositions.LEFT:  	shiftAdjustment = 0;  	break;  case AlignmentPositions.RIGHT:  	shiftAdjustment = (Width % Encoded_Value.Length);  	break;  default:  	shiftAdjustment = (Width % Encoded_Value.Length) / 2;  	break;  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: shiftAdjustment = (Width % Encoded_Value.Length) / 2;  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: shiftAdjustment = (Width % Encoded_Value.Length) / 2;  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (b)) {  	//clears the image and colors the entire background  	g.Clear (BackColor);  	//lines are fBarWidth wide so draw the appropriate color line vertically  	using (Pen backpen = new Pen (BackColor' iBarWidth / iBarWidthModifier)) {  		using (Pen pen = new Pen (ForeColor' iBarWidth / iBarWidthModifier)) {  			while (pos < Encoded_Value.Length) {  				if (this.Encoded_Type == TYPE.PostNet) {  					//draw half bars in postnet  					if (Encoded_Value [pos] == '0')  						g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLableAdjustment));  					else  						g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment));  				} //if  				else {  					if (Encoded_Value [pos] == '1')  						g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment));  				}  				pos++;  			}  			//while  		}  		//using  	}  	//using  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: using (Pen backpen = new Pen (BackColor' iBarWidth / iBarWidthModifier)) {  	using (Pen pen = new Pen (ForeColor' iBarWidth / iBarWidthModifier)) {  		while (pos < Encoded_Value.Length) {  			if (this.Encoded_Type == TYPE.PostNet) {  				//draw half bars in postnet  				if (Encoded_Value [pos] == '0')  					g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLableAdjustment));  				else  					g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment));  			} //if  			else {  				if (Encoded_Value [pos] == '1')  					g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment));  			}  			pos++;  		}  		//while  	}  	//using  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: using (Pen pen = new Pen (ForeColor' iBarWidth / iBarWidthModifier)) {  	while (pos < Encoded_Value.Length) {  		if (this.Encoded_Type == TYPE.PostNet) {  			//draw half bars in postnet  			if (Encoded_Value [pos] == '0')  				g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLableAdjustment));  			else  				g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment));  		} //if  		else {  			if (Encoded_Value [pos] == '1')  				g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment));  		}  		pos++;  	}  	//while  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: while (pos < Encoded_Value.Length) {  	if (this.Encoded_Type == TYPE.PostNet) {  		//draw half bars in postnet  		if (Encoded_Value [pos] == '0')  			g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLableAdjustment));  		else  			g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment));  	} //if  	else {  		if (Encoded_Value [pos] == '1')  			g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment));  	}  	pos++;  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: if (this.Encoded_Type == TYPE.PostNet) {  	//draw half bars in postnet  	if (Encoded_Value [pos] == '0')  		g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLableAdjustment));  	else  		g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment));  } //if  else {  	if (Encoded_Value [pos] == '1')  		g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment));  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: if (Encoded_Value [pos] == '0')  	g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLableAdjustment));  else  	g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' topLableAdjustment));  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: g.DrawLine (pen' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLableAdjustment)' new Point (pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLableAdjustment));  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,GetSizeOfImage,The following statement contains a magic number: if (this.EncodedImage != null && this.EncodedImage.Width > 0 && this.EncodedImage.Height > 0) {  	double MillimetersPerInch = 25.4;  	using (Graphics g = Graphics.FromImage (this.EncodedImage)) {  		Width = this.EncodedImage.Width / g.DpiX;  		Height = this.EncodedImage.Height / g.DpiY;  		if (Metric) {  			Width *= MillimetersPerInch;  			Height *= MillimetersPerInch;  		}  		//if  	}  	//using  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_ITF14,The following statement contains a magic number: try {  	System.Drawing.Font font = this.LabelFont;  	using (Graphics g = Graphics.FromImage (img)) {  		g.DrawImage (img' (float)0' (float)0);  		g.SmoothingMode = SmoothingMode.HighQuality;  		g.InterpolationMode = InterpolationMode.HighQualityBicubic;  		g.PixelOffsetMode = PixelOffsetMode.HighQuality;  		g.CompositingQuality = CompositingQuality.HighQuality;  		//color a white box at the bottom of the barcode to hold the string of data  		g.FillRectangle (new SolidBrush (this.BackColor)' new Rectangle (0' img.Height - (font.Height - 2)' img.Width' font.Height));  		//draw datastring under the barcode image  		StringFormat f = new StringFormat ();  		f.Alignment = StringAlignment.Center;  		g.DrawString (AlternateLabel == null ? RawData : AlternateLabel' font' new SolidBrush (ForeColor)' (float)(img.Width / 2)' img.Height - font.Height + 1' f);  		Pen pen = new Pen (ForeColor' (float)img.Height / 16);  		pen.Alignment = PenAlignment.Inset;  		g.DrawLine (pen' new Point (0' img.Height - font.Height - 2)' new Point (img.Width' img.Height - font.Height - 2));  		//bottom  		g.Save ();  	}  	//using  	return img;  } //try  catch (Exception ex) {  	throw new Exception ("ELABEL_ITF14-1: " + ex.Message);  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_ITF14,The following statement contains a magic number: try {  	System.Drawing.Font font = this.LabelFont;  	using (Graphics g = Graphics.FromImage (img)) {  		g.DrawImage (img' (float)0' (float)0);  		g.SmoothingMode = SmoothingMode.HighQuality;  		g.InterpolationMode = InterpolationMode.HighQualityBicubic;  		g.PixelOffsetMode = PixelOffsetMode.HighQuality;  		g.CompositingQuality = CompositingQuality.HighQuality;  		//color a white box at the bottom of the barcode to hold the string of data  		g.FillRectangle (new SolidBrush (this.BackColor)' new Rectangle (0' img.Height - (font.Height - 2)' img.Width' font.Height));  		//draw datastring under the barcode image  		StringFormat f = new StringFormat ();  		f.Alignment = StringAlignment.Center;  		g.DrawString (AlternateLabel == null ? RawData : AlternateLabel' font' new SolidBrush (ForeColor)' (float)(img.Width / 2)' img.Height - font.Height + 1' f);  		Pen pen = new Pen (ForeColor' (float)img.Height / 16);  		pen.Alignment = PenAlignment.Inset;  		g.DrawLine (pen' new Point (0' img.Height - font.Height - 2)' new Point (img.Width' img.Height - font.Height - 2));  		//bottom  		g.Save ();  	}  	//using  	return img;  } //try  catch (Exception ex) {  	throw new Exception ("ELABEL_ITF14-1: " + ex.Message);  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_ITF14,The following statement contains a magic number: try {  	System.Drawing.Font font = this.LabelFont;  	using (Graphics g = Graphics.FromImage (img)) {  		g.DrawImage (img' (float)0' (float)0);  		g.SmoothingMode = SmoothingMode.HighQuality;  		g.InterpolationMode = InterpolationMode.HighQualityBicubic;  		g.PixelOffsetMode = PixelOffsetMode.HighQuality;  		g.CompositingQuality = CompositingQuality.HighQuality;  		//color a white box at the bottom of the barcode to hold the string of data  		g.FillRectangle (new SolidBrush (this.BackColor)' new Rectangle (0' img.Height - (font.Height - 2)' img.Width' font.Height));  		//draw datastring under the barcode image  		StringFormat f = new StringFormat ();  		f.Alignment = StringAlignment.Center;  		g.DrawString (AlternateLabel == null ? RawData : AlternateLabel' font' new SolidBrush (ForeColor)' (float)(img.Width / 2)' img.Height - font.Height + 1' f);  		Pen pen = new Pen (ForeColor' (float)img.Height / 16);  		pen.Alignment = PenAlignment.Inset;  		g.DrawLine (pen' new Point (0' img.Height - font.Height - 2)' new Point (img.Width' img.Height - font.Height - 2));  		//bottom  		g.Save ();  	}  	//using  	return img;  } //try  catch (Exception ex) {  	throw new Exception ("ELABEL_ITF14-1: " + ex.Message);  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_ITF14,The following statement contains a magic number: try {  	System.Drawing.Font font = this.LabelFont;  	using (Graphics g = Graphics.FromImage (img)) {  		g.DrawImage (img' (float)0' (float)0);  		g.SmoothingMode = SmoothingMode.HighQuality;  		g.InterpolationMode = InterpolationMode.HighQualityBicubic;  		g.PixelOffsetMode = PixelOffsetMode.HighQuality;  		g.CompositingQuality = CompositingQuality.HighQuality;  		//color a white box at the bottom of the barcode to hold the string of data  		g.FillRectangle (new SolidBrush (this.BackColor)' new Rectangle (0' img.Height - (font.Height - 2)' img.Width' font.Height));  		//draw datastring under the barcode image  		StringFormat f = new StringFormat ();  		f.Alignment = StringAlignment.Center;  		g.DrawString (AlternateLabel == null ? RawData : AlternateLabel' font' new SolidBrush (ForeColor)' (float)(img.Width / 2)' img.Height - font.Height + 1' f);  		Pen pen = new Pen (ForeColor' (float)img.Height / 16);  		pen.Alignment = PenAlignment.Inset;  		g.DrawLine (pen' new Point (0' img.Height - font.Height - 2)' new Point (img.Width' img.Height - font.Height - 2));  		//bottom  		g.Save ();  	}  	//using  	return img;  } //try  catch (Exception ex) {  	throw new Exception ("ELABEL_ITF14-1: " + ex.Message);  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_ITF14,The following statement contains a magic number: try {  	System.Drawing.Font font = this.LabelFont;  	using (Graphics g = Graphics.FromImage (img)) {  		g.DrawImage (img' (float)0' (float)0);  		g.SmoothingMode = SmoothingMode.HighQuality;  		g.InterpolationMode = InterpolationMode.HighQualityBicubic;  		g.PixelOffsetMode = PixelOffsetMode.HighQuality;  		g.CompositingQuality = CompositingQuality.HighQuality;  		//color a white box at the bottom of the barcode to hold the string of data  		g.FillRectangle (new SolidBrush (this.BackColor)' new Rectangle (0' img.Height - (font.Height - 2)' img.Width' font.Height));  		//draw datastring under the barcode image  		StringFormat f = new StringFormat ();  		f.Alignment = StringAlignment.Center;  		g.DrawString (AlternateLabel == null ? RawData : AlternateLabel' font' new SolidBrush (ForeColor)' (float)(img.Width / 2)' img.Height - font.Height + 1' f);  		Pen pen = new Pen (ForeColor' (float)img.Height / 16);  		pen.Alignment = PenAlignment.Inset;  		g.DrawLine (pen' new Point (0' img.Height - font.Height - 2)' new Point (img.Width' img.Height - font.Height - 2));  		//bottom  		g.Save ();  	}  	//using  	return img;  } //try  catch (Exception ex) {  	throw new Exception ("ELABEL_ITF14-1: " + ex.Message);  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_ITF14,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (img)) {  	g.DrawImage (img' (float)0' (float)0);  	g.SmoothingMode = SmoothingMode.HighQuality;  	g.InterpolationMode = InterpolationMode.HighQualityBicubic;  	g.PixelOffsetMode = PixelOffsetMode.HighQuality;  	g.CompositingQuality = CompositingQuality.HighQuality;  	//color a white box at the bottom of the barcode to hold the string of data  	g.FillRectangle (new SolidBrush (this.BackColor)' new Rectangle (0' img.Height - (font.Height - 2)' img.Width' font.Height));  	//draw datastring under the barcode image  	StringFormat f = new StringFormat ();  	f.Alignment = StringAlignment.Center;  	g.DrawString (AlternateLabel == null ? RawData : AlternateLabel' font' new SolidBrush (ForeColor)' (float)(img.Width / 2)' img.Height - font.Height + 1' f);  	Pen pen = new Pen (ForeColor' (float)img.Height / 16);  	pen.Alignment = PenAlignment.Inset;  	g.DrawLine (pen' new Point (0' img.Height - font.Height - 2)' new Point (img.Width' img.Height - font.Height - 2));  	//bottom  	g.Save ();  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_ITF14,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (img)) {  	g.DrawImage (img' (float)0' (float)0);  	g.SmoothingMode = SmoothingMode.HighQuality;  	g.InterpolationMode = InterpolationMode.HighQualityBicubic;  	g.PixelOffsetMode = PixelOffsetMode.HighQuality;  	g.CompositingQuality = CompositingQuality.HighQuality;  	//color a white box at the bottom of the barcode to hold the string of data  	g.FillRectangle (new SolidBrush (this.BackColor)' new Rectangle (0' img.Height - (font.Height - 2)' img.Width' font.Height));  	//draw datastring under the barcode image  	StringFormat f = new StringFormat ();  	f.Alignment = StringAlignment.Center;  	g.DrawString (AlternateLabel == null ? RawData : AlternateLabel' font' new SolidBrush (ForeColor)' (float)(img.Width / 2)' img.Height - font.Height + 1' f);  	Pen pen = new Pen (ForeColor' (float)img.Height / 16);  	pen.Alignment = PenAlignment.Inset;  	g.DrawLine (pen' new Point (0' img.Height - font.Height - 2)' new Point (img.Width' img.Height - font.Height - 2));  	//bottom  	g.Save ();  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_ITF14,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (img)) {  	g.DrawImage (img' (float)0' (float)0);  	g.SmoothingMode = SmoothingMode.HighQuality;  	g.InterpolationMode = InterpolationMode.HighQualityBicubic;  	g.PixelOffsetMode = PixelOffsetMode.HighQuality;  	g.CompositingQuality = CompositingQuality.HighQuality;  	//color a white box at the bottom of the barcode to hold the string of data  	g.FillRectangle (new SolidBrush (this.BackColor)' new Rectangle (0' img.Height - (font.Height - 2)' img.Width' font.Height));  	//draw datastring under the barcode image  	StringFormat f = new StringFormat ();  	f.Alignment = StringAlignment.Center;  	g.DrawString (AlternateLabel == null ? RawData : AlternateLabel' font' new SolidBrush (ForeColor)' (float)(img.Width / 2)' img.Height - font.Height + 1' f);  	Pen pen = new Pen (ForeColor' (float)img.Height / 16);  	pen.Alignment = PenAlignment.Inset;  	g.DrawLine (pen' new Point (0' img.Height - font.Height - 2)' new Point (img.Width' img.Height - font.Height - 2));  	//bottom  	g.Save ();  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_ITF14,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (img)) {  	g.DrawImage (img' (float)0' (float)0);  	g.SmoothingMode = SmoothingMode.HighQuality;  	g.InterpolationMode = InterpolationMode.HighQualityBicubic;  	g.PixelOffsetMode = PixelOffsetMode.HighQuality;  	g.CompositingQuality = CompositingQuality.HighQuality;  	//color a white box at the bottom of the barcode to hold the string of data  	g.FillRectangle (new SolidBrush (this.BackColor)' new Rectangle (0' img.Height - (font.Height - 2)' img.Width' font.Height));  	//draw datastring under the barcode image  	StringFormat f = new StringFormat ();  	f.Alignment = StringAlignment.Center;  	g.DrawString (AlternateLabel == null ? RawData : AlternateLabel' font' new SolidBrush (ForeColor)' (float)(img.Width / 2)' img.Height - font.Height + 1' f);  	Pen pen = new Pen (ForeColor' (float)img.Height / 16);  	pen.Alignment = PenAlignment.Inset;  	g.DrawLine (pen' new Point (0' img.Height - font.Height - 2)' new Point (img.Width' img.Height - font.Height - 2));  	//bottom  	g.Save ();  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_ITF14,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (img)) {  	g.DrawImage (img' (float)0' (float)0);  	g.SmoothingMode = SmoothingMode.HighQuality;  	g.InterpolationMode = InterpolationMode.HighQualityBicubic;  	g.PixelOffsetMode = PixelOffsetMode.HighQuality;  	g.CompositingQuality = CompositingQuality.HighQuality;  	//color a white box at the bottom of the barcode to hold the string of data  	g.FillRectangle (new SolidBrush (this.BackColor)' new Rectangle (0' img.Height - (font.Height - 2)' img.Width' font.Height));  	//draw datastring under the barcode image  	StringFormat f = new StringFormat ();  	f.Alignment = StringAlignment.Center;  	g.DrawString (AlternateLabel == null ? RawData : AlternateLabel' font' new SolidBrush (ForeColor)' (float)(img.Width / 2)' img.Height - font.Height + 1' f);  	Pen pen = new Pen (ForeColor' (float)img.Height / 16);  	pen.Alignment = PenAlignment.Inset;  	g.DrawLine (pen' new Point (0' img.Height - font.Height - 2)' new Point (img.Width' img.Height - font.Height - 2));  	//bottom  	g.Save ();  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_ITF14,The following statement contains a magic number: g.FillRectangle (new SolidBrush (this.BackColor)' new Rectangle (0' img.Height - (font.Height - 2)' img.Width' font.Height));  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_ITF14,The following statement contains a magic number: g.DrawString (AlternateLabel == null ? RawData : AlternateLabel' font' new SolidBrush (ForeColor)' (float)(img.Width / 2)' img.Height - font.Height + 1' f);  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_ITF14,The following statement contains a magic number: g.DrawLine (pen' new Point (0' img.Height - font.Height - 2)' new Point (img.Width' img.Height - font.Height - 2));  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_ITF14,The following statement contains a magic number: g.DrawLine (pen' new Point (0' img.Height - font.Height - 2)' new Point (img.Width' img.Height - font.Height - 2));  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_Generic,The following statement contains a magic number: try {  	System.Drawing.Font font = this.LabelFont;  	using (Graphics g = Graphics.FromImage (img)) {  		g.DrawImage (img' (float)0' (float)0);  		g.SmoothingMode = SmoothingMode.HighQuality;  		g.InterpolationMode = InterpolationMode.HighQualityBicubic;  		g.PixelOffsetMode = PixelOffsetMode.HighQuality;  		g.CompositingQuality = CompositingQuality.HighQuality;  		g.TextRenderingHint = TextRenderingHint.AntiAliasGridFit;  		StringFormat f = new StringFormat ();  		f.Alignment = StringAlignment.Near;  		f.LineAlignment = StringAlignment.Near;  		int LabelX = 0;  		int LabelY = 0;  		switch (LabelPosition) {  		case LabelPositions.BOTTOMCENTER:  			LabelX = img.Width / 2;  			LabelY = img.Height - (font.Height);  			f.Alignment = StringAlignment.Center;  			break;  		case LabelPositions.BOTTOMLEFT:  			LabelX = 0;  			LabelY = img.Height - (font.Height);  			f.Alignment = StringAlignment.Near;  			break;  		case LabelPositions.BOTTOMRIGHT:  			LabelX = img.Width;  			LabelY = img.Height - (font.Height);  			f.Alignment = StringAlignment.Far;  			break;  		case LabelPositions.TOPCENTER:  			LabelX = img.Width / 2;  			LabelY = 0;  			f.Alignment = StringAlignment.Center;  			break;  		case LabelPositions.TOPLEFT:  			LabelX = img.Width;  			LabelY = 0;  			f.Alignment = StringAlignment.Near;  			break;  		case LabelPositions.TOPRIGHT:  			LabelX = img.Width;  			LabelY = 0;  			f.Alignment = StringAlignment.Far;  			break;  		}  		//switch  		//color a background color box at the bottom of the barcode to hold the string of data  		g.FillRectangle (new SolidBrush (BackColor)' new RectangleF ((float)0' (float)LabelY' (float)img.Width' (float)font.Height));  		//draw datastring under the barcode image  		g.DrawString (AlternateLabel == null ? RawData : AlternateLabel' font' new SolidBrush (ForeColor)' new RectangleF ((float)0' (float)LabelY' (float)img.Width' (float)font.Height)' f);  		g.Save ();  	}  	//using  	return img;  } //try  catch (Exception ex) {  	throw new Exception ("ELABEL_GENERIC-1: " + ex.Message);  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_Generic,The following statement contains a magic number: try {  	System.Drawing.Font font = this.LabelFont;  	using (Graphics g = Graphics.FromImage (img)) {  		g.DrawImage (img' (float)0' (float)0);  		g.SmoothingMode = SmoothingMode.HighQuality;  		g.InterpolationMode = InterpolationMode.HighQualityBicubic;  		g.PixelOffsetMode = PixelOffsetMode.HighQuality;  		g.CompositingQuality = CompositingQuality.HighQuality;  		g.TextRenderingHint = TextRenderingHint.AntiAliasGridFit;  		StringFormat f = new StringFormat ();  		f.Alignment = StringAlignment.Near;  		f.LineAlignment = StringAlignment.Near;  		int LabelX = 0;  		int LabelY = 0;  		switch (LabelPosition) {  		case LabelPositions.BOTTOMCENTER:  			LabelX = img.Width / 2;  			LabelY = img.Height - (font.Height);  			f.Alignment = StringAlignment.Center;  			break;  		case LabelPositions.BOTTOMLEFT:  			LabelX = 0;  			LabelY = img.Height - (font.Height);  			f.Alignment = StringAlignment.Near;  			break;  		case LabelPositions.BOTTOMRIGHT:  			LabelX = img.Width;  			LabelY = img.Height - (font.Height);  			f.Alignment = StringAlignment.Far;  			break;  		case LabelPositions.TOPCENTER:  			LabelX = img.Width / 2;  			LabelY = 0;  			f.Alignment = StringAlignment.Center;  			break;  		case LabelPositions.TOPLEFT:  			LabelX = img.Width;  			LabelY = 0;  			f.Alignment = StringAlignment.Near;  			break;  		case LabelPositions.TOPRIGHT:  			LabelX = img.Width;  			LabelY = 0;  			f.Alignment = StringAlignment.Far;  			break;  		}  		//switch  		//color a background color box at the bottom of the barcode to hold the string of data  		g.FillRectangle (new SolidBrush (BackColor)' new RectangleF ((float)0' (float)LabelY' (float)img.Width' (float)font.Height));  		//draw datastring under the barcode image  		g.DrawString (AlternateLabel == null ? RawData : AlternateLabel' font' new SolidBrush (ForeColor)' new RectangleF ((float)0' (float)LabelY' (float)img.Width' (float)font.Height)' f);  		g.Save ();  	}  	//using  	return img;  } //try  catch (Exception ex) {  	throw new Exception ("ELABEL_GENERIC-1: " + ex.Message);  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_Generic,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (img)) {  	g.DrawImage (img' (float)0' (float)0);  	g.SmoothingMode = SmoothingMode.HighQuality;  	g.InterpolationMode = InterpolationMode.HighQualityBicubic;  	g.PixelOffsetMode = PixelOffsetMode.HighQuality;  	g.CompositingQuality = CompositingQuality.HighQuality;  	g.TextRenderingHint = TextRenderingHint.AntiAliasGridFit;  	StringFormat f = new StringFormat ();  	f.Alignment = StringAlignment.Near;  	f.LineAlignment = StringAlignment.Near;  	int LabelX = 0;  	int LabelY = 0;  	switch (LabelPosition) {  	case LabelPositions.BOTTOMCENTER:  		LabelX = img.Width / 2;  		LabelY = img.Height - (font.Height);  		f.Alignment = StringAlignment.Center;  		break;  	case LabelPositions.BOTTOMLEFT:  		LabelX = 0;  		LabelY = img.Height - (font.Height);  		f.Alignment = StringAlignment.Near;  		break;  	case LabelPositions.BOTTOMRIGHT:  		LabelX = img.Width;  		LabelY = img.Height - (font.Height);  		f.Alignment = StringAlignment.Far;  		break;  	case LabelPositions.TOPCENTER:  		LabelX = img.Width / 2;  		LabelY = 0;  		f.Alignment = StringAlignment.Center;  		break;  	case LabelPositions.TOPLEFT:  		LabelX = img.Width;  		LabelY = 0;  		f.Alignment = StringAlignment.Near;  		break;  	case LabelPositions.TOPRIGHT:  		LabelX = img.Width;  		LabelY = 0;  		f.Alignment = StringAlignment.Far;  		break;  	}  	//switch  	//color a background color box at the bottom of the barcode to hold the string of data  	g.FillRectangle (new SolidBrush (BackColor)' new RectangleF ((float)0' (float)LabelY' (float)img.Width' (float)font.Height));  	//draw datastring under the barcode image  	g.DrawString (AlternateLabel == null ? RawData : AlternateLabel' font' new SolidBrush (ForeColor)' new RectangleF ((float)0' (float)LabelY' (float)img.Width' (float)font.Height)' f);  	g.Save ();  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_Generic,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (img)) {  	g.DrawImage (img' (float)0' (float)0);  	g.SmoothingMode = SmoothingMode.HighQuality;  	g.InterpolationMode = InterpolationMode.HighQualityBicubic;  	g.PixelOffsetMode = PixelOffsetMode.HighQuality;  	g.CompositingQuality = CompositingQuality.HighQuality;  	g.TextRenderingHint = TextRenderingHint.AntiAliasGridFit;  	StringFormat f = new StringFormat ();  	f.Alignment = StringAlignment.Near;  	f.LineAlignment = StringAlignment.Near;  	int LabelX = 0;  	int LabelY = 0;  	switch (LabelPosition) {  	case LabelPositions.BOTTOMCENTER:  		LabelX = img.Width / 2;  		LabelY = img.Height - (font.Height);  		f.Alignment = StringAlignment.Center;  		break;  	case LabelPositions.BOTTOMLEFT:  		LabelX = 0;  		LabelY = img.Height - (font.Height);  		f.Alignment = StringAlignment.Near;  		break;  	case LabelPositions.BOTTOMRIGHT:  		LabelX = img.Width;  		LabelY = img.Height - (font.Height);  		f.Alignment = StringAlignment.Far;  		break;  	case LabelPositions.TOPCENTER:  		LabelX = img.Width / 2;  		LabelY = 0;  		f.Alignment = StringAlignment.Center;  		break;  	case LabelPositions.TOPLEFT:  		LabelX = img.Width;  		LabelY = 0;  		f.Alignment = StringAlignment.Near;  		break;  	case LabelPositions.TOPRIGHT:  		LabelX = img.Width;  		LabelY = 0;  		f.Alignment = StringAlignment.Far;  		break;  	}  	//switch  	//color a background color box at the bottom of the barcode to hold the string of data  	g.FillRectangle (new SolidBrush (BackColor)' new RectangleF ((float)0' (float)LabelY' (float)img.Width' (float)font.Height));  	//draw datastring under the barcode image  	g.DrawString (AlternateLabel == null ? RawData : AlternateLabel' font' new SolidBrush (ForeColor)' new RectangleF ((float)0' (float)LabelY' (float)img.Width' (float)font.Height)' f);  	g.Save ();  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_Generic,The following statement contains a magic number: switch (LabelPosition) {  case LabelPositions.BOTTOMCENTER:  	LabelX = img.Width / 2;  	LabelY = img.Height - (font.Height);  	f.Alignment = StringAlignment.Center;  	break;  case LabelPositions.BOTTOMLEFT:  	LabelX = 0;  	LabelY = img.Height - (font.Height);  	f.Alignment = StringAlignment.Near;  	break;  case LabelPositions.BOTTOMRIGHT:  	LabelX = img.Width;  	LabelY = img.Height - (font.Height);  	f.Alignment = StringAlignment.Far;  	break;  case LabelPositions.TOPCENTER:  	LabelX = img.Width / 2;  	LabelY = 0;  	f.Alignment = StringAlignment.Center;  	break;  case LabelPositions.TOPLEFT:  	LabelX = img.Width;  	LabelY = 0;  	f.Alignment = StringAlignment.Near;  	break;  case LabelPositions.TOPRIGHT:  	LabelX = img.Width;  	LabelY = 0;  	f.Alignment = StringAlignment.Far;  	break;  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_Generic,The following statement contains a magic number: switch (LabelPosition) {  case LabelPositions.BOTTOMCENTER:  	LabelX = img.Width / 2;  	LabelY = img.Height - (font.Height);  	f.Alignment = StringAlignment.Center;  	break;  case LabelPositions.BOTTOMLEFT:  	LabelX = 0;  	LabelY = img.Height - (font.Height);  	f.Alignment = StringAlignment.Near;  	break;  case LabelPositions.BOTTOMRIGHT:  	LabelX = img.Width;  	LabelY = img.Height - (font.Height);  	f.Alignment = StringAlignment.Far;  	break;  case LabelPositions.TOPCENTER:  	LabelX = img.Width / 2;  	LabelY = 0;  	f.Alignment = StringAlignment.Center;  	break;  case LabelPositions.TOPLEFT:  	LabelX = img.Width;  	LabelY = 0;  	f.Alignment = StringAlignment.Near;  	break;  case LabelPositions.TOPRIGHT:  	LabelX = img.Width;  	LabelY = 0;  	f.Alignment = StringAlignment.Far;  	break;  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_Generic,The following statement contains a magic number: LabelX = img.Width / 2;  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_Generic,The following statement contains a magic number: LabelX = img.Width / 2;  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_UPCA,The following statement contains a magic number: try {  	int iBarWidth = Width / Encoded_Value.Length;  	int shiftAdjustment = 0;  	//set alignment  	switch (Alignment) {  	case AlignmentPositions.CENTER:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	case AlignmentPositions.LEFT:  		shiftAdjustment = 0;  		break;  	case AlignmentPositions.RIGHT:  		shiftAdjustment = (Width % Encoded_Value.Length);  		break;  	default:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	}  	//switch  	System.Drawing.Font font = new System.Drawing.Font ("OCR A Extended"' 12F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((System.Byte)(0)));  	;  	using (Graphics g = Graphics.FromImage (img)) {  		g.DrawImage (img' (float)0' (float)0);  		g.SmoothingMode = SmoothingMode.HighQuality;  		g.InterpolationMode = InterpolationMode.HighQualityBicubic;  		g.PixelOffsetMode = PixelOffsetMode.HighQuality;  		g.CompositingQuality = CompositingQuality.HighQuality;  		//draw datastring under the barcode image  		RectangleF rect = new RectangleF ((iBarWidth * 3) + shiftAdjustment' this.Height - (int)(this.Height * 0.1)' (iBarWidth * 43)' (int)(this.Height * 0.1));  		g.FillRectangle (new SolidBrush (Color.Yellow)' rect.X' rect.Y' rect.Width' rect.Height);  		g.DrawString (this.RawData.Substring (1' 5)' font' new SolidBrush (this.ForeColor)' rect.X' rect.Y);  		g.Save ();  	}  	//using  	return img;  } //try  catch (Exception ex) {  	throw new Exception ("ELABEL_UPCA-1: " + ex.Message);  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_UPCA,The following statement contains a magic number: try {  	int iBarWidth = Width / Encoded_Value.Length;  	int shiftAdjustment = 0;  	//set alignment  	switch (Alignment) {  	case AlignmentPositions.CENTER:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	case AlignmentPositions.LEFT:  		shiftAdjustment = 0;  		break;  	case AlignmentPositions.RIGHT:  		shiftAdjustment = (Width % Encoded_Value.Length);  		break;  	default:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	}  	//switch  	System.Drawing.Font font = new System.Drawing.Font ("OCR A Extended"' 12F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((System.Byte)(0)));  	;  	using (Graphics g = Graphics.FromImage (img)) {  		g.DrawImage (img' (float)0' (float)0);  		g.SmoothingMode = SmoothingMode.HighQuality;  		g.InterpolationMode = InterpolationMode.HighQualityBicubic;  		g.PixelOffsetMode = PixelOffsetMode.HighQuality;  		g.CompositingQuality = CompositingQuality.HighQuality;  		//draw datastring under the barcode image  		RectangleF rect = new RectangleF ((iBarWidth * 3) + shiftAdjustment' this.Height - (int)(this.Height * 0.1)' (iBarWidth * 43)' (int)(this.Height * 0.1));  		g.FillRectangle (new SolidBrush (Color.Yellow)' rect.X' rect.Y' rect.Width' rect.Height);  		g.DrawString (this.RawData.Substring (1' 5)' font' new SolidBrush (this.ForeColor)' rect.X' rect.Y);  		g.Save ();  	}  	//using  	return img;  } //try  catch (Exception ex) {  	throw new Exception ("ELABEL_UPCA-1: " + ex.Message);  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_UPCA,The following statement contains a magic number: try {  	int iBarWidth = Width / Encoded_Value.Length;  	int shiftAdjustment = 0;  	//set alignment  	switch (Alignment) {  	case AlignmentPositions.CENTER:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	case AlignmentPositions.LEFT:  		shiftAdjustment = 0;  		break;  	case AlignmentPositions.RIGHT:  		shiftAdjustment = (Width % Encoded_Value.Length);  		break;  	default:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	}  	//switch  	System.Drawing.Font font = new System.Drawing.Font ("OCR A Extended"' 12F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((System.Byte)(0)));  	;  	using (Graphics g = Graphics.FromImage (img)) {  		g.DrawImage (img' (float)0' (float)0);  		g.SmoothingMode = SmoothingMode.HighQuality;  		g.InterpolationMode = InterpolationMode.HighQualityBicubic;  		g.PixelOffsetMode = PixelOffsetMode.HighQuality;  		g.CompositingQuality = CompositingQuality.HighQuality;  		//draw datastring under the barcode image  		RectangleF rect = new RectangleF ((iBarWidth * 3) + shiftAdjustment' this.Height - (int)(this.Height * 0.1)' (iBarWidth * 43)' (int)(this.Height * 0.1));  		g.FillRectangle (new SolidBrush (Color.Yellow)' rect.X' rect.Y' rect.Width' rect.Height);  		g.DrawString (this.RawData.Substring (1' 5)' font' new SolidBrush (this.ForeColor)' rect.X' rect.Y);  		g.Save ();  	}  	//using  	return img;  } //try  catch (Exception ex) {  	throw new Exception ("ELABEL_UPCA-1: " + ex.Message);  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_UPCA,The following statement contains a magic number: try {  	int iBarWidth = Width / Encoded_Value.Length;  	int shiftAdjustment = 0;  	//set alignment  	switch (Alignment) {  	case AlignmentPositions.CENTER:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	case AlignmentPositions.LEFT:  		shiftAdjustment = 0;  		break;  	case AlignmentPositions.RIGHT:  		shiftAdjustment = (Width % Encoded_Value.Length);  		break;  	default:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	}  	//switch  	System.Drawing.Font font = new System.Drawing.Font ("OCR A Extended"' 12F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((System.Byte)(0)));  	;  	using (Graphics g = Graphics.FromImage (img)) {  		g.DrawImage (img' (float)0' (float)0);  		g.SmoothingMode = SmoothingMode.HighQuality;  		g.InterpolationMode = InterpolationMode.HighQualityBicubic;  		g.PixelOffsetMode = PixelOffsetMode.HighQuality;  		g.CompositingQuality = CompositingQuality.HighQuality;  		//draw datastring under the barcode image  		RectangleF rect = new RectangleF ((iBarWidth * 3) + shiftAdjustment' this.Height - (int)(this.Height * 0.1)' (iBarWidth * 43)' (int)(this.Height * 0.1));  		g.FillRectangle (new SolidBrush (Color.Yellow)' rect.X' rect.Y' rect.Width' rect.Height);  		g.DrawString (this.RawData.Substring (1' 5)' font' new SolidBrush (this.ForeColor)' rect.X' rect.Y);  		g.Save ();  	}  	//using  	return img;  } //try  catch (Exception ex) {  	throw new Exception ("ELABEL_UPCA-1: " + ex.Message);  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_UPCA,The following statement contains a magic number: try {  	int iBarWidth = Width / Encoded_Value.Length;  	int shiftAdjustment = 0;  	//set alignment  	switch (Alignment) {  	case AlignmentPositions.CENTER:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	case AlignmentPositions.LEFT:  		shiftAdjustment = 0;  		break;  	case AlignmentPositions.RIGHT:  		shiftAdjustment = (Width % Encoded_Value.Length);  		break;  	default:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	}  	//switch  	System.Drawing.Font font = new System.Drawing.Font ("OCR A Extended"' 12F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((System.Byte)(0)));  	;  	using (Graphics g = Graphics.FromImage (img)) {  		g.DrawImage (img' (float)0' (float)0);  		g.SmoothingMode = SmoothingMode.HighQuality;  		g.InterpolationMode = InterpolationMode.HighQualityBicubic;  		g.PixelOffsetMode = PixelOffsetMode.HighQuality;  		g.CompositingQuality = CompositingQuality.HighQuality;  		//draw datastring under the barcode image  		RectangleF rect = new RectangleF ((iBarWidth * 3) + shiftAdjustment' this.Height - (int)(this.Height * 0.1)' (iBarWidth * 43)' (int)(this.Height * 0.1));  		g.FillRectangle (new SolidBrush (Color.Yellow)' rect.X' rect.Y' rect.Width' rect.Height);  		g.DrawString (this.RawData.Substring (1' 5)' font' new SolidBrush (this.ForeColor)' rect.X' rect.Y);  		g.Save ();  	}  	//using  	return img;  } //try  catch (Exception ex) {  	throw new Exception ("ELABEL_UPCA-1: " + ex.Message);  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_UPCA,The following statement contains a magic number: try {  	int iBarWidth = Width / Encoded_Value.Length;  	int shiftAdjustment = 0;  	//set alignment  	switch (Alignment) {  	case AlignmentPositions.CENTER:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	case AlignmentPositions.LEFT:  		shiftAdjustment = 0;  		break;  	case AlignmentPositions.RIGHT:  		shiftAdjustment = (Width % Encoded_Value.Length);  		break;  	default:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	}  	//switch  	System.Drawing.Font font = new System.Drawing.Font ("OCR A Extended"' 12F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((System.Byte)(0)));  	;  	using (Graphics g = Graphics.FromImage (img)) {  		g.DrawImage (img' (float)0' (float)0);  		g.SmoothingMode = SmoothingMode.HighQuality;  		g.InterpolationMode = InterpolationMode.HighQualityBicubic;  		g.PixelOffsetMode = PixelOffsetMode.HighQuality;  		g.CompositingQuality = CompositingQuality.HighQuality;  		//draw datastring under the barcode image  		RectangleF rect = new RectangleF ((iBarWidth * 3) + shiftAdjustment' this.Height - (int)(this.Height * 0.1)' (iBarWidth * 43)' (int)(this.Height * 0.1));  		g.FillRectangle (new SolidBrush (Color.Yellow)' rect.X' rect.Y' rect.Width' rect.Height);  		g.DrawString (this.RawData.Substring (1' 5)' font' new SolidBrush (this.ForeColor)' rect.X' rect.Y);  		g.Save ();  	}  	//using  	return img;  } //try  catch (Exception ex) {  	throw new Exception ("ELABEL_UPCA-1: " + ex.Message);  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_UPCA,The following statement contains a magic number: try {  	int iBarWidth = Width / Encoded_Value.Length;  	int shiftAdjustment = 0;  	//set alignment  	switch (Alignment) {  	case AlignmentPositions.CENTER:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	case AlignmentPositions.LEFT:  		shiftAdjustment = 0;  		break;  	case AlignmentPositions.RIGHT:  		shiftAdjustment = (Width % Encoded_Value.Length);  		break;  	default:  		shiftAdjustment = (Width % Encoded_Value.Length) / 2;  		break;  	}  	//switch  	System.Drawing.Font font = new System.Drawing.Font ("OCR A Extended"' 12F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((System.Byte)(0)));  	;  	using (Graphics g = Graphics.FromImage (img)) {  		g.DrawImage (img' (float)0' (float)0);  		g.SmoothingMode = SmoothingMode.HighQuality;  		g.InterpolationMode = InterpolationMode.HighQualityBicubic;  		g.PixelOffsetMode = PixelOffsetMode.HighQuality;  		g.CompositingQuality = CompositingQuality.HighQuality;  		//draw datastring under the barcode image  		RectangleF rect = new RectangleF ((iBarWidth * 3) + shiftAdjustment' this.Height - (int)(this.Height * 0.1)' (iBarWidth * 43)' (int)(this.Height * 0.1));  		g.FillRectangle (new SolidBrush (Color.Yellow)' rect.X' rect.Y' rect.Width' rect.Height);  		g.DrawString (this.RawData.Substring (1' 5)' font' new SolidBrush (this.ForeColor)' rect.X' rect.Y);  		g.Save ();  	}  	//using  	return img;  } //try  catch (Exception ex) {  	throw new Exception ("ELABEL_UPCA-1: " + ex.Message);  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_UPCA,The following statement contains a magic number: switch (Alignment) {  case AlignmentPositions.CENTER:  	shiftAdjustment = (Width % Encoded_Value.Length) / 2;  	break;  case AlignmentPositions.LEFT:  	shiftAdjustment = 0;  	break;  case AlignmentPositions.RIGHT:  	shiftAdjustment = (Width % Encoded_Value.Length);  	break;  default:  	shiftAdjustment = (Width % Encoded_Value.Length) / 2;  	break;  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_UPCA,The following statement contains a magic number: switch (Alignment) {  case AlignmentPositions.CENTER:  	shiftAdjustment = (Width % Encoded_Value.Length) / 2;  	break;  case AlignmentPositions.LEFT:  	shiftAdjustment = 0;  	break;  case AlignmentPositions.RIGHT:  	shiftAdjustment = (Width % Encoded_Value.Length);  	break;  default:  	shiftAdjustment = (Width % Encoded_Value.Length) / 2;  	break;  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_UPCA,The following statement contains a magic number: shiftAdjustment = (Width % Encoded_Value.Length) / 2;  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_UPCA,The following statement contains a magic number: shiftAdjustment = (Width % Encoded_Value.Length) / 2;  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_UPCA,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (img)) {  	g.DrawImage (img' (float)0' (float)0);  	g.SmoothingMode = SmoothingMode.HighQuality;  	g.InterpolationMode = InterpolationMode.HighQualityBicubic;  	g.PixelOffsetMode = PixelOffsetMode.HighQuality;  	g.CompositingQuality = CompositingQuality.HighQuality;  	//draw datastring under the barcode image  	RectangleF rect = new RectangleF ((iBarWidth * 3) + shiftAdjustment' this.Height - (int)(this.Height * 0.1)' (iBarWidth * 43)' (int)(this.Height * 0.1));  	g.FillRectangle (new SolidBrush (Color.Yellow)' rect.X' rect.Y' rect.Width' rect.Height);  	g.DrawString (this.RawData.Substring (1' 5)' font' new SolidBrush (this.ForeColor)' rect.X' rect.Y);  	g.Save ();  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_UPCA,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (img)) {  	g.DrawImage (img' (float)0' (float)0);  	g.SmoothingMode = SmoothingMode.HighQuality;  	g.InterpolationMode = InterpolationMode.HighQualityBicubic;  	g.PixelOffsetMode = PixelOffsetMode.HighQuality;  	g.CompositingQuality = CompositingQuality.HighQuality;  	//draw datastring under the barcode image  	RectangleF rect = new RectangleF ((iBarWidth * 3) + shiftAdjustment' this.Height - (int)(this.Height * 0.1)' (iBarWidth * 43)' (int)(this.Height * 0.1));  	g.FillRectangle (new SolidBrush (Color.Yellow)' rect.X' rect.Y' rect.Width' rect.Height);  	g.DrawString (this.RawData.Substring (1' 5)' font' new SolidBrush (this.ForeColor)' rect.X' rect.Y);  	g.Save ();  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_UPCA,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (img)) {  	g.DrawImage (img' (float)0' (float)0);  	g.SmoothingMode = SmoothingMode.HighQuality;  	g.InterpolationMode = InterpolationMode.HighQualityBicubic;  	g.PixelOffsetMode = PixelOffsetMode.HighQuality;  	g.CompositingQuality = CompositingQuality.HighQuality;  	//draw datastring under the barcode image  	RectangleF rect = new RectangleF ((iBarWidth * 3) + shiftAdjustment' this.Height - (int)(this.Height * 0.1)' (iBarWidth * 43)' (int)(this.Height * 0.1));  	g.FillRectangle (new SolidBrush (Color.Yellow)' rect.X' rect.Y' rect.Width' rect.Height);  	g.DrawString (this.RawData.Substring (1' 5)' font' new SolidBrush (this.ForeColor)' rect.X' rect.Y);  	g.Save ();  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_UPCA,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (img)) {  	g.DrawImage (img' (float)0' (float)0);  	g.SmoothingMode = SmoothingMode.HighQuality;  	g.InterpolationMode = InterpolationMode.HighQualityBicubic;  	g.PixelOffsetMode = PixelOffsetMode.HighQuality;  	g.CompositingQuality = CompositingQuality.HighQuality;  	//draw datastring under the barcode image  	RectangleF rect = new RectangleF ((iBarWidth * 3) + shiftAdjustment' this.Height - (int)(this.Height * 0.1)' (iBarWidth * 43)' (int)(this.Height * 0.1));  	g.FillRectangle (new SolidBrush (Color.Yellow)' rect.X' rect.Y' rect.Width' rect.Height);  	g.DrawString (this.RawData.Substring (1' 5)' font' new SolidBrush (this.ForeColor)' rect.X' rect.Y);  	g.Save ();  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_UPCA,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (img)) {  	g.DrawImage (img' (float)0' (float)0);  	g.SmoothingMode = SmoothingMode.HighQuality;  	g.InterpolationMode = InterpolationMode.HighQualityBicubic;  	g.PixelOffsetMode = PixelOffsetMode.HighQuality;  	g.CompositingQuality = CompositingQuality.HighQuality;  	//draw datastring under the barcode image  	RectangleF rect = new RectangleF ((iBarWidth * 3) + shiftAdjustment' this.Height - (int)(this.Height * 0.1)' (iBarWidth * 43)' (int)(this.Height * 0.1));  	g.FillRectangle (new SolidBrush (Color.Yellow)' rect.X' rect.Y' rect.Width' rect.Height);  	g.DrawString (this.RawData.Substring (1' 5)' font' new SolidBrush (this.ForeColor)' rect.X' rect.Y);  	g.Save ();  }  
Magic Number,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_UPCA,The following statement contains a magic number: g.DrawString (this.RawData.Substring (1' 5)' font' new SolidBrush (this.ForeColor)' rect.X' rect.Y);  
Magic Number,BarcodeLib.Symbologies,Codabar,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Codabar.cs,Encode_Codabar,The following statement contains a magic number: if (Raw_Data.Length < 2)  	Error ("ECODABAR-1: Data format invalid. (Invalid length)");  
Magic Number,BarcodeLib.Symbologies,Codabar,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Codabar.cs,Encode_Codabar,The following statement contains a magic number: Raw_Data = Raw_Data.Trim ().Substring (1' RawData.Trim ().Length - 2);  
Magic Number,BarcodeLib.Symbologies,Code11,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code11.cs,Encode_Code11,The following statement contains a magic number: for (int i = Raw_Data.Length - 1; i >= 0; i--) {  	//C checksum weights go 1-10  	if (weight == 10)  		weight = 1;  	if (Raw_Data [i] != '-')  		CTotal += Int32.Parse (Raw_Data [i].ToString ()) * weight++;  	else  		CTotal += 10 * weight++;  }  
Magic Number,BarcodeLib.Symbologies,Code11,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code11.cs,Encode_Code11,The following statement contains a magic number: for (int i = Raw_Data.Length - 1; i >= 0; i--) {  	//C checksum weights go 1-10  	if (weight == 10)  		weight = 1;  	if (Raw_Data [i] != '-')  		CTotal += Int32.Parse (Raw_Data [i].ToString ()) * weight++;  	else  		CTotal += 10 * weight++;  }  
Magic Number,BarcodeLib.Symbologies,Code11,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code11.cs,Encode_Code11,The following statement contains a magic number: if (weight == 10)  	weight = 1;  
Magic Number,BarcodeLib.Symbologies,Code11,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code11.cs,Encode_Code11,The following statement contains a magic number: if (Raw_Data [i] != '-')  	CTotal += Int32.Parse (Raw_Data [i].ToString ()) * weight++;  else  	CTotal += 10 * weight++;  
Magic Number,BarcodeLib.Symbologies,Code11,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code11.cs,Encode_Code11,The following statement contains a magic number: CTotal += 10 * weight++;  
Magic Number,BarcodeLib.Symbologies,Code11,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code11.cs,Encode_Code11,The following statement contains a magic number: if (Raw_Data.Length >= 10) {  	weight = 1;  	int KTotal = 0;  	//calculate K checksum  	for (int i = Data_To_Encode_with_Checksums.Length - 1; i >= 0; i--) {  		//K checksum weights go 1-9  		if (weight == 9)  			weight = 1;  		if (Data_To_Encode_with_Checksums [i] != '-')  			KTotal += Int32.Parse (Data_To_Encode_with_Checksums [i].ToString ()) * weight++;  		else  			KTotal += 10 * weight++;  	}  	//for  	int checksumK = KTotal % 11;  	Data_To_Encode_with_Checksums += checksumK.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,Code11,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code11.cs,Encode_Code11,The following statement contains a magic number: if (Raw_Data.Length >= 10) {  	weight = 1;  	int KTotal = 0;  	//calculate K checksum  	for (int i = Data_To_Encode_with_Checksums.Length - 1; i >= 0; i--) {  		//K checksum weights go 1-9  		if (weight == 9)  			weight = 1;  		if (Data_To_Encode_with_Checksums [i] != '-')  			KTotal += Int32.Parse (Data_To_Encode_with_Checksums [i].ToString ()) * weight++;  		else  			KTotal += 10 * weight++;  	}  	//for  	int checksumK = KTotal % 11;  	Data_To_Encode_with_Checksums += checksumK.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,Code11,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code11.cs,Encode_Code11,The following statement contains a magic number: if (Raw_Data.Length >= 10) {  	weight = 1;  	int KTotal = 0;  	//calculate K checksum  	for (int i = Data_To_Encode_with_Checksums.Length - 1; i >= 0; i--) {  		//K checksum weights go 1-9  		if (weight == 9)  			weight = 1;  		if (Data_To_Encode_with_Checksums [i] != '-')  			KTotal += Int32.Parse (Data_To_Encode_with_Checksums [i].ToString ()) * weight++;  		else  			KTotal += 10 * weight++;  	}  	//for  	int checksumK = KTotal % 11;  	Data_To_Encode_with_Checksums += checksumK.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,Code11,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code11.cs,Encode_Code11,The following statement contains a magic number: if (Raw_Data.Length >= 10) {  	weight = 1;  	int KTotal = 0;  	//calculate K checksum  	for (int i = Data_To_Encode_with_Checksums.Length - 1; i >= 0; i--) {  		//K checksum weights go 1-9  		if (weight == 9)  			weight = 1;  		if (Data_To_Encode_with_Checksums [i] != '-')  			KTotal += Int32.Parse (Data_To_Encode_with_Checksums [i].ToString ()) * weight++;  		else  			KTotal += 10 * weight++;  	}  	//for  	int checksumK = KTotal % 11;  	Data_To_Encode_with_Checksums += checksumK.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,Code11,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code11.cs,Encode_Code11,The following statement contains a magic number: for (int i = Data_To_Encode_with_Checksums.Length - 1; i >= 0; i--) {  	//K checksum weights go 1-9  	if (weight == 9)  		weight = 1;  	if (Data_To_Encode_with_Checksums [i] != '-')  		KTotal += Int32.Parse (Data_To_Encode_with_Checksums [i].ToString ()) * weight++;  	else  		KTotal += 10 * weight++;  }  
Magic Number,BarcodeLib.Symbologies,Code11,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code11.cs,Encode_Code11,The following statement contains a magic number: for (int i = Data_To_Encode_with_Checksums.Length - 1; i >= 0; i--) {  	//K checksum weights go 1-9  	if (weight == 9)  		weight = 1;  	if (Data_To_Encode_with_Checksums [i] != '-')  		KTotal += Int32.Parse (Data_To_Encode_with_Checksums [i].ToString ()) * weight++;  	else  		KTotal += 10 * weight++;  }  
Magic Number,BarcodeLib.Symbologies,Code11,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code11.cs,Encode_Code11,The following statement contains a magic number: if (weight == 9)  	weight = 1;  
Magic Number,BarcodeLib.Symbologies,Code11,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code11.cs,Encode_Code11,The following statement contains a magic number: if (Data_To_Encode_with_Checksums [i] != '-')  	KTotal += Int32.Parse (Data_To_Encode_with_Checksums [i].ToString ()) * weight++;  else  	KTotal += 10 * weight++;  
Magic Number,BarcodeLib.Symbologies,Code11,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code11.cs,Encode_Code11,The following statement contains a magic number: KTotal += 10 * weight++;  
Magic Number,BarcodeLib.Symbologies,Code11,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code11.cs,Encode_Code11,The following statement contains a magic number: foreach (char c in Data_To_Encode_with_Checksums) {  	int index = (c == '-' ? 10 : Int32.Parse (c.ToString ()));  	result += C11_Code [index];  	//inter-character space  	result += space;  }  
Magic Number,BarcodeLib.Symbologies,Code11,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code11.cs,Encode_Code11,The following statement contains a magic number: result += C11_Code [11];  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"66"'  	Convert.ToChar (2).ToString ()'  	"b"'  	"66"'  	"10010000110"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"67"'  	Convert.ToChar (3).ToString ()'  	"c"'  	"67"'  	"10000101100"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"68"'  	Convert.ToChar (4).ToString ()'  	"d"'  	"68"'  	"10000100110"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"69"'  	Convert.ToChar (5).ToString ()'  	"e"'  	"69"'  	"10110010000"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"70"'  	Convert.ToChar (6).ToString ()'  	"f"'  	"70"'  	"10110000100"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"71"'  	Convert.ToChar (7).ToString ()'  	"g"'  	"71"'  	"10011010000"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"72"'  	Convert.ToChar (8).ToString ()'  	"h"'  	"72"'  	"10011000010"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"73"'  	Convert.ToChar (9).ToString ()'  	"i"'  	"73"'  	"10000110100"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"74"'  	Convert.ToChar (10).ToString ()'  	"j"'  	"74"'  	"10000110010"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"75"'  	Convert.ToChar (11).ToString ()'  	"k"'  	"75"'  	"11000010010"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"76"'  	Convert.ToChar (12).ToString ()'  	"l"'  	"76"'  	"11001010000"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"77"'  	Convert.ToChar (13).ToString ()'  	"m"'  	"77"'  	"11110111010"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"78"'  	Convert.ToChar (14).ToString ()'  	"n"'  	"78"'  	"11000010100"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"79"'  	Convert.ToChar (15).ToString ()'  	"o"'  	"79"'  	"10001111010"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"80"'  	Convert.ToChar (16).ToString ()'  	"p"'  	"80"'  	"10100111100"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"81"'  	Convert.ToChar (17).ToString ()'  	"q"'  	"81"'  	"10010111100"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"82"'  	Convert.ToChar (18).ToString ()'  	"r"'  	"82"'  	"10010011110"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"83"'  	Convert.ToChar (19).ToString ()'  	"s"'  	"83"'  	"10111100100"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"84"'  	Convert.ToChar (20).ToString ()'  	"t"'  	"84"'  	"10011110100"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"85"'  	Convert.ToChar (21).ToString ()'  	"u"'  	"85"'  	"10011110010"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"86"'  	Convert.ToChar (22).ToString ()'  	"v"'  	"86"'  	"11110100100"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"87"'  	Convert.ToChar (23).ToString ()'  	"w"'  	"87"'  	"11110010100"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"88"'  	Convert.ToChar (24).ToString ()'  	"x"'  	"88"'  	"11110010010"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"89"'  	Convert.ToChar (25).ToString ()'  	"y"'  	"89"'  	"11011011110"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"90"'  	Convert.ToChar (26).ToString ()'  	"z"'  	"90"'  	"11011110110"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"91"'  	Convert.ToChar (27).ToString ()'  	"{"'  	"91"'  	"11110110110"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"92"'  	Convert.ToChar (28).ToString ()'  	"|"'  	"92"'  	"10101111000"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"93"'  	Convert.ToChar (29).ToString ()'  	"}"'  	"93"'  	"10100011110"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"94"'  	Convert.ToChar (30).ToString ()'  	"~"'  	"94"'  	"10001011110"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"95"'  	Convert.ToChar (31).ToString ()'  	Convert.ToChar (127).ToString ()'  	"95"'  	"10111101000"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"95"'  	Convert.ToChar (31).ToString ()'  	Convert.ToChar (127).ToString ()'  	"95"'  	"10111101000"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"96"'  	Convert.ToChar (202).ToString ()/*FNC3*/'  	Convert.ToChar (202).ToString ()/*FNC3*/'  	"96"'  	"10111100010"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"96"'  	Convert.ToChar (202).ToString ()/*FNC3*/'  	Convert.ToChar (202).ToString ()/*FNC3*/'  	"96"'  	"10111100010"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"97"'  	Convert.ToChar (201).ToString ()/*FNC2*/'  	Convert.ToChar (201).ToString ()/*FNC2*/'  	"97"'  	"11110101000"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"97"'  	Convert.ToChar (201).ToString ()/*FNC2*/'  	Convert.ToChar (201).ToString ()/*FNC2*/'  	"97"'  	"11110101000"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"100"'  	"CODE_B"'  	Convert.ToChar (203).ToString ()/*FNC4*/'  	"CODE_B"'  	"10111101110"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"101"'  	Convert.ToChar (203).ToString ()/*FNC4*/'  	"CODE_A"'  	"CODE_A"'  	"11101011110"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"102"'  	Convert.ToChar (200).ToString ()/*FNC1*/'  	Convert.ToChar (200).ToString ()/*FNC1*/'  	Convert.ToChar (200).ToString ()/*FNC1*/'  	"11110101110"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"102"'  	Convert.ToChar (200).ToString ()/*FNC1*/'  	Convert.ToChar (200).ToString ()/*FNC1*/'  	Convert.ToChar (200).ToString ()/*FNC1*/'  	"11110101110"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add (new object[] {  	"102"'  	Convert.ToChar (200).ToString ()/*FNC1*/'  	Convert.ToChar (200).ToString ()/*FNC1*/'  	Convert.ToChar (200).ToString ()/*FNC1*/'  	"11110101110"  });  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,FindStartorCodeCharacter,The following statement contains a magic number: if (s.Length > 1 && (Char.IsNumber (s [0]) || s [0] == Convert.ToChar (200)) && (Char.IsNumber (s [1]) || s [0] == Convert.ToChar (200))) {  	if (StartCharacter == null) {  		StartCharacter = this.C128_Code.Select ("A = 'START_C'") [0];  		rows.Add (StartCharacter);  	} //if  	else  		rows.Add (this.C128_Code.Select ("A = 'CODE_C'") [0]);  	col = 1;  } //if  else {  	bool AFound = false;  	bool BFound = false;  	foreach (DataRow row in this.C128_Code.Rows) {  		try {  			if (!AFound && s == row ["A"].ToString ()) {  				AFound = true;  				col = 2;  				if (StartCharacter == null) {  					StartCharacter = this.C128_Code.Select ("A = 'START_A'") [0];  					rows.Add (StartCharacter);  				} //if  				else {  					rows.Add (this.C128_Code.Select ("B = 'CODE_A'") [0]);  					//first column is FNC4 so use B  				}  				//else  			} //if  			else if (!BFound && s == row ["B"].ToString ()) {  				BFound = true;  				col = 1;  				if (StartCharacter == null) {  					StartCharacter = this.C128_Code.Select ("A = 'START_B'") [0];  					rows.Add (StartCharacter);  				} //if  				else  					rows.Add (this.C128_Code.Select ("A = 'CODE_B'") [0]);  			} //else  			else if (AFound && BFound)  				break;  		} //try  		catch (Exception ex) {  			Error ("EC128-1: " + ex.Message);  		}  		//catch  	}  	//foreach                  	if (rows.Count <= 0)  		Error ("EC128-2: Could not determine start character.");  }  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,FindStartorCodeCharacter,The following statement contains a magic number: if (s.Length > 1 && (Char.IsNumber (s [0]) || s [0] == Convert.ToChar (200)) && (Char.IsNumber (s [1]) || s [0] == Convert.ToChar (200))) {  	if (StartCharacter == null) {  		StartCharacter = this.C128_Code.Select ("A = 'START_C'") [0];  		rows.Add (StartCharacter);  	} //if  	else  		rows.Add (this.C128_Code.Select ("A = 'CODE_C'") [0]);  	col = 1;  } //if  else {  	bool AFound = false;  	bool BFound = false;  	foreach (DataRow row in this.C128_Code.Rows) {  		try {  			if (!AFound && s == row ["A"].ToString ()) {  				AFound = true;  				col = 2;  				if (StartCharacter == null) {  					StartCharacter = this.C128_Code.Select ("A = 'START_A'") [0];  					rows.Add (StartCharacter);  				} //if  				else {  					rows.Add (this.C128_Code.Select ("B = 'CODE_A'") [0]);  					//first column is FNC4 so use B  				}  				//else  			} //if  			else if (!BFound && s == row ["B"].ToString ()) {  				BFound = true;  				col = 1;  				if (StartCharacter == null) {  					StartCharacter = this.C128_Code.Select ("A = 'START_B'") [0];  					rows.Add (StartCharacter);  				} //if  				else  					rows.Add (this.C128_Code.Select ("A = 'CODE_B'") [0]);  			} //else  			else if (AFound && BFound)  				break;  		} //try  		catch (Exception ex) {  			Error ("EC128-1: " + ex.Message);  		}  		//catch  	}  	//foreach                  	if (rows.Count <= 0)  		Error ("EC128-2: Could not determine start character.");  }  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,FindStartorCodeCharacter,The following statement contains a magic number: if (s.Length > 1 && (Char.IsNumber (s [0]) || s [0] == Convert.ToChar (200)) && (Char.IsNumber (s [1]) || s [0] == Convert.ToChar (200))) {  	if (StartCharacter == null) {  		StartCharacter = this.C128_Code.Select ("A = 'START_C'") [0];  		rows.Add (StartCharacter);  	} //if  	else  		rows.Add (this.C128_Code.Select ("A = 'CODE_C'") [0]);  	col = 1;  } //if  else {  	bool AFound = false;  	bool BFound = false;  	foreach (DataRow row in this.C128_Code.Rows) {  		try {  			if (!AFound && s == row ["A"].ToString ()) {  				AFound = true;  				col = 2;  				if (StartCharacter == null) {  					StartCharacter = this.C128_Code.Select ("A = 'START_A'") [0];  					rows.Add (StartCharacter);  				} //if  				else {  					rows.Add (this.C128_Code.Select ("B = 'CODE_A'") [0]);  					//first column is FNC4 so use B  				}  				//else  			} //if  			else if (!BFound && s == row ["B"].ToString ()) {  				BFound = true;  				col = 1;  				if (StartCharacter == null) {  					StartCharacter = this.C128_Code.Select ("A = 'START_B'") [0];  					rows.Add (StartCharacter);  				} //if  				else  					rows.Add (this.C128_Code.Select ("A = 'CODE_B'") [0]);  			} //else  			else if (AFound && BFound)  				break;  		} //try  		catch (Exception ex) {  			Error ("EC128-1: " + ex.Message);  		}  		//catch  	}  	//foreach                  	if (rows.Count <= 0)  		Error ("EC128-2: Could not determine start character.");  }  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,FindStartorCodeCharacter,The following statement contains a magic number: foreach (DataRow row in this.C128_Code.Rows) {  	try {  		if (!AFound && s == row ["A"].ToString ()) {  			AFound = true;  			col = 2;  			if (StartCharacter == null) {  				StartCharacter = this.C128_Code.Select ("A = 'START_A'") [0];  				rows.Add (StartCharacter);  			} //if  			else {  				rows.Add (this.C128_Code.Select ("B = 'CODE_A'") [0]);  				//first column is FNC4 so use B  			}  			//else  		} //if  		else if (!BFound && s == row ["B"].ToString ()) {  			BFound = true;  			col = 1;  			if (StartCharacter == null) {  				StartCharacter = this.C128_Code.Select ("A = 'START_B'") [0];  				rows.Add (StartCharacter);  			} //if  			else  				rows.Add (this.C128_Code.Select ("A = 'CODE_B'") [0]);  		} //else  		else if (AFound && BFound)  			break;  	} //try  	catch (Exception ex) {  		Error ("EC128-1: " + ex.Message);  	}  	//catch  }  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,FindStartorCodeCharacter,The following statement contains a magic number: try {  	if (!AFound && s == row ["A"].ToString ()) {  		AFound = true;  		col = 2;  		if (StartCharacter == null) {  			StartCharacter = this.C128_Code.Select ("A = 'START_A'") [0];  			rows.Add (StartCharacter);  		} //if  		else {  			rows.Add (this.C128_Code.Select ("B = 'CODE_A'") [0]);  			//first column is FNC4 so use B  		}  		//else  	} //if  	else if (!BFound && s == row ["B"].ToString ()) {  		BFound = true;  		col = 1;  		if (StartCharacter == null) {  			StartCharacter = this.C128_Code.Select ("A = 'START_B'") [0];  			rows.Add (StartCharacter);  		} //if  		else  			rows.Add (this.C128_Code.Select ("A = 'CODE_B'") [0]);  	} //else  	else if (AFound && BFound)  		break;  } //try  catch (Exception ex) {  	Error ("EC128-1: " + ex.Message);  }  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,FindStartorCodeCharacter,The following statement contains a magic number: if (!AFound && s == row ["A"].ToString ()) {  	AFound = true;  	col = 2;  	if (StartCharacter == null) {  		StartCharacter = this.C128_Code.Select ("A = 'START_A'") [0];  		rows.Add (StartCharacter);  	} //if  	else {  		rows.Add (this.C128_Code.Select ("B = 'CODE_A'") [0]);  		//first column is FNC4 so use B  	}  	//else  } //if  else if (!BFound && s == row ["B"].ToString ()) {  	BFound = true;  	col = 1;  	if (StartCharacter == null) {  		StartCharacter = this.C128_Code.Select ("A = 'START_B'") [0];  		rows.Add (StartCharacter);  	} //if  	else  		rows.Add (this.C128_Code.Select ("A = 'CODE_B'") [0]);  } //else  else if (AFound && BFound)  	break;  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,FindStartorCodeCharacter,The following statement contains a magic number: col = 2;  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,BreakUpDataForEncoding,The following statement contains a magic number: if (this.type == TYPES.C) {  	if (!CheckNumericOnly (Raw_Data))  		Error ("EC128-6: Only numeric values can be encoded with C128-C.");  	//CODE C: adds a 0 to the front of the Raw_Data if the length is not divisible by 2  	if (Raw_Data.Length % 2 > 0)  		tempRawData = "0" + Raw_Data;  }  
Magic Number,BarcodeLib.Symbologies,Code128,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code128.cs,BreakUpDataForEncoding,The following statement contains a magic number: if (Raw_Data.Length % 2 > 0)  	tempRawData = "0" + Raw_Data;  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (2).ToString ()' "$B");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (3).ToString ()' "$C");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (4).ToString ()' "$D");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (5).ToString ()' "$E");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (6).ToString ()' "$F");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (7).ToString ()' "$G");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (8).ToString ()' "$H");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (9).ToString ()' "$I");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (10).ToString ()' "$J");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (11).ToString ()' "$K");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (12).ToString ()' "$L");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (13).ToString ()' "$M");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (14).ToString ()' "$N");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (15).ToString ()' "$O");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (16).ToString ()' "$P");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (17).ToString ()' "$Q");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (18).ToString ()' "$R");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (19).ToString ()' "$S");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (20).ToString ()' "$T");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (21).ToString ()' "$U");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (22).ToString ()' "$V");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (23).ToString ()' "$W");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (24).ToString ()' "$X");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (25).ToString ()' "$Y");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (26).ToString ()' "$Z");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (27).ToString ()' "%A");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (28).ToString ()' "%B");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (29).ToString ()' "%C");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (30).ToString ()' "%D");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (31).ToString ()' "%E");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add (Convert.ToChar (127).ToString ()' "%T");  
Magic Number,BarcodeLib.Symbologies,Code39,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code39.cs,getChecksumChar,The following statement contains a magic number: return Code39_Charset [sum % 43];  
Magic Number,BarcodeLib.Symbologies,Code93,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code93.cs,Add_CheckDigits,The following statement contains a magic number: for (int i = input.Length - 1; i >= 0; i--) {  	if (curweight > 20)  		curweight = 1;  	aryCWeights [i] = curweight;  	curweight++;  }  
Magic Number,BarcodeLib.Symbologies,Code93,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code93.cs,Add_CheckDigits,The following statement contains a magic number: if (curweight > 20)  	curweight = 1;  
Magic Number,BarcodeLib.Symbologies,Code93,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code93.cs,Add_CheckDigits,The following statement contains a magic number: for (int i = input.Length; i >= 0; i--) {  	if (curweight > 15)  		curweight = 1;  	aryKWeights [i] = curweight;  	curweight++;  }  
Magic Number,BarcodeLib.Symbologies,Code93,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code93.cs,Add_CheckDigits,The following statement contains a magic number: if (curweight > 15)  	curweight = 1;  
Magic Number,BarcodeLib.Symbologies,Code93,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Code93.cs,Add_CheckDigits,The following statement contains a magic number: ChecksumValue = SUM % 47;  
Magic Number,BarcodeLib.Symbologies,Pharmacode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Pharmacode.cs,Pharmacode,The following statement contains a magic number: if (!CheckNumericOnly (Raw_Data)) {  	Error ("EPHARM-1: Data contains invalid  characters (non-numeric).");  } //if  else if (Raw_Data.Length > 6) {  	Error ("EPHARM-2: Data too long (invalid data input length).");  }  
Magic Number,BarcodeLib.Symbologies,Pharmacode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Pharmacode.cs,Pharmacode,The following statement contains a magic number: if (Raw_Data.Length > 6) {  	Error ("EPHARM-2: Data too long (invalid data input length).");  }  
Magic Number,BarcodeLib.Symbologies,Pharmacode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Pharmacode.cs,Encode_Pharmacode,The following statement contains a magic number: if (!Int32.TryParse (Raw_Data' out num)) {  	Error ("EPHARM-3: Input is unparseable.");  } else if (num < 3 || num > 131070) {  	Error ("EPHARM-4: Data contains invalid  characters (invalid numeric range).");  }  
Magic Number,BarcodeLib.Symbologies,Pharmacode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Pharmacode.cs,Encode_Pharmacode,The following statement contains a magic number: if (!Int32.TryParse (Raw_Data' out num)) {  	Error ("EPHARM-3: Input is unparseable.");  } else if (num < 3 || num > 131070) {  	Error ("EPHARM-4: Data contains invalid  characters (invalid numeric range).");  }  
Magic Number,BarcodeLib.Symbologies,Pharmacode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Pharmacode.cs,Encode_Pharmacode,The following statement contains a magic number: if (num < 3 || num > 131070) {  	Error ("EPHARM-4: Data contains invalid  characters (invalid numeric range).");  }  
Magic Number,BarcodeLib.Symbologies,Pharmacode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Pharmacode.cs,Encode_Pharmacode,The following statement contains a magic number: if (num < 3 || num > 131070) {  	Error ("EPHARM-4: Data contains invalid  characters (invalid numeric range).");  }  
Magic Number,BarcodeLib.Symbologies,Pharmacode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Pharmacode.cs,Encode_Pharmacode,The following statement contains a magic number: for (int index = 15; index >= 0; index--) {  	if (Math.Pow (2' index) < num / 2) {  		startIndex = index;  		break;  	}  }  
Magic Number,BarcodeLib.Symbologies,Pharmacode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Pharmacode.cs,Encode_Pharmacode,The following statement contains a magic number: for (int index = 15; index >= 0; index--) {  	if (Math.Pow (2' index) < num / 2) {  		startIndex = index;  		break;  	}  }  
Magic Number,BarcodeLib.Symbologies,Pharmacode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Pharmacode.cs,Encode_Pharmacode,The following statement contains a magic number: for (int index = 15; index >= 0; index--) {  	if (Math.Pow (2' index) < num / 2) {  		startIndex = index;  		break;  	}  }  
Magic Number,BarcodeLib.Symbologies,Pharmacode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Pharmacode.cs,Encode_Pharmacode,The following statement contains a magic number: if (Math.Pow (2' index) < num / 2) {  	startIndex = index;  	break;  }  
Magic Number,BarcodeLib.Symbologies,Pharmacode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Pharmacode.cs,Encode_Pharmacode,The following statement contains a magic number: if (Math.Pow (2' index) < num / 2) {  	startIndex = index;  	break;  }  
Magic Number,BarcodeLib.Symbologies,Pharmacode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Pharmacode.cs,Encode_Pharmacode,The following statement contains a magic number: for (int index = startIndex; index >= 0; index--) {  	double power = Math.Pow (2' index);  	double diff = num - sum;  	if (diff > power) {  		encoded [i++] = _thickBar;  		sum += power;  	} else {  		encoded [i++] = _thinBar;  	}  }  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,EncodeNumeric,The following statement contains a magic number: try {  	if ((input.Length % 2) > 0)  		Error ("ETELEPEN-3: Numeric encoding attempted on odd number of characters");  	for (int i = 0; i < input.Length; i += 2) {  		output += Telepen_Code [Convert.ToChar (Int32.Parse (input.Substring (i' 2)) + 27)];  		iCheckSum += Int32.Parse (input.Substring (i' 2)) + 27;  	}  	//for  } //try  catch {  	Error ("ETELEPEN-2: Numeric encoding failed");  }  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,EncodeNumeric,The following statement contains a magic number: try {  	if ((input.Length % 2) > 0)  		Error ("ETELEPEN-3: Numeric encoding attempted on odd number of characters");  	for (int i = 0; i < input.Length; i += 2) {  		output += Telepen_Code [Convert.ToChar (Int32.Parse (input.Substring (i' 2)) + 27)];  		iCheckSum += Int32.Parse (input.Substring (i' 2)) + 27;  	}  	//for  } //try  catch {  	Error ("ETELEPEN-2: Numeric encoding failed");  }  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,EncodeNumeric,The following statement contains a magic number: try {  	if ((input.Length % 2) > 0)  		Error ("ETELEPEN-3: Numeric encoding attempted on odd number of characters");  	for (int i = 0; i < input.Length; i += 2) {  		output += Telepen_Code [Convert.ToChar (Int32.Parse (input.Substring (i' 2)) + 27)];  		iCheckSum += Int32.Parse (input.Substring (i' 2)) + 27;  	}  	//for  } //try  catch {  	Error ("ETELEPEN-2: Numeric encoding failed");  }  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,EncodeNumeric,The following statement contains a magic number: try {  	if ((input.Length % 2) > 0)  		Error ("ETELEPEN-3: Numeric encoding attempted on odd number of characters");  	for (int i = 0; i < input.Length; i += 2) {  		output += Telepen_Code [Convert.ToChar (Int32.Parse (input.Substring (i' 2)) + 27)];  		iCheckSum += Int32.Parse (input.Substring (i' 2)) + 27;  	}  	//for  } //try  catch {  	Error ("ETELEPEN-2: Numeric encoding failed");  }  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,EncodeNumeric,The following statement contains a magic number: try {  	if ((input.Length % 2) > 0)  		Error ("ETELEPEN-3: Numeric encoding attempted on odd number of characters");  	for (int i = 0; i < input.Length; i += 2) {  		output += Telepen_Code [Convert.ToChar (Int32.Parse (input.Substring (i' 2)) + 27)];  		iCheckSum += Int32.Parse (input.Substring (i' 2)) + 27;  	}  	//for  } //try  catch {  	Error ("ETELEPEN-2: Numeric encoding failed");  }  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,EncodeNumeric,The following statement contains a magic number: try {  	if ((input.Length % 2) > 0)  		Error ("ETELEPEN-3: Numeric encoding attempted on odd number of characters");  	for (int i = 0; i < input.Length; i += 2) {  		output += Telepen_Code [Convert.ToChar (Int32.Parse (input.Substring (i' 2)) + 27)];  		iCheckSum += Int32.Parse (input.Substring (i' 2)) + 27;  	}  	//for  } //try  catch {  	Error ("ETELEPEN-2: Numeric encoding failed");  }  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,EncodeNumeric,The following statement contains a magic number: if ((input.Length % 2) > 0)  	Error ("ETELEPEN-3: Numeric encoding attempted on odd number of characters");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,EncodeNumeric,The following statement contains a magic number: for (int i = 0; i < input.Length; i += 2) {  	output += Telepen_Code [Convert.ToChar (Int32.Parse (input.Substring (i' 2)) + 27)];  	iCheckSum += Int32.Parse (input.Substring (i' 2)) + 27;  }  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,EncodeNumeric,The following statement contains a magic number: for (int i = 0; i < input.Length; i += 2) {  	output += Telepen_Code [Convert.ToChar (Int32.Parse (input.Substring (i' 2)) + 27)];  	iCheckSum += Int32.Parse (input.Substring (i' 2)) + 27;  }  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,EncodeNumeric,The following statement contains a magic number: for (int i = 0; i < input.Length; i += 2) {  	output += Telepen_Code [Convert.ToChar (Int32.Parse (input.Substring (i' 2)) + 27)];  	iCheckSum += Int32.Parse (input.Substring (i' 2)) + 27;  }  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,EncodeNumeric,The following statement contains a magic number: for (int i = 0; i < input.Length; i += 2) {  	output += Telepen_Code [Convert.ToChar (Int32.Parse (input.Substring (i' 2)) + 27)];  	iCheckSum += Int32.Parse (input.Substring (i' 2)) + 27;  }  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,EncodeNumeric,The following statement contains a magic number: for (int i = 0; i < input.Length; i += 2) {  	output += Telepen_Code [Convert.ToChar (Int32.Parse (input.Substring (i' 2)) + 27)];  	iCheckSum += Int32.Parse (input.Substring (i' 2)) + 27;  }  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,EncodeNumeric,The following statement contains a magic number: i += 2
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,EncodeNumeric,The following statement contains a magic number: output += Telepen_Code [Convert.ToChar (Int32.Parse (input.Substring (i' 2)) + 27)];  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,EncodeNumeric,The following statement contains a magic number: output += Telepen_Code [Convert.ToChar (Int32.Parse (input.Substring (i' 2)) + 27)];  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,EncodeNumeric,The following statement contains a magic number: iCheckSum += Int32.Parse (input.Substring (i' 2)) + 27;  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,EncodeNumeric,The following statement contains a magic number: iCheckSum += Int32.Parse (input.Substring (i' 2)) + 27;  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,EncodeSwitchMode,The following statement contains a magic number: iCheckSum += 16;  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,EncodeSwitchMode,The following statement contains a magic number: output += Telepen_Code [Convert.ToChar (16)];  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Calculate_Checksum,The following statement contains a magic number: return Convert.ToChar (127 - (iCheckSum % 127));  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Calculate_Checksum,The following statement contains a magic number: return Convert.ToChar (127 - (iCheckSum % 127));  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,SetEncodingSequence,The following statement contains a magic number: if (StartNumerics == Raw_Data.Length) {  	//Numeric only mode due to only numbers being present  	StartCode = StartStopCode.START2;  	StopCode = StartStopCode.STOP2;  	if ((Raw_Data.Length % 2) > 0)  		SwitchModeIndex = RawData.Length - 1;  } //if  else {  	//ending number of numbers  	int EndNumerics = 0;  	for (int i = Raw_Data.Length - 1; i >= 0; i--) {  		if (Char.IsNumber (Raw_Data [i]))  			EndNumerics++;  		else  			break;  	}  	//for  	if (StartNumerics >= 4 || EndNumerics >= 4) {  		//hybrid mode will be used  		if (StartNumerics > EndNumerics) {  			//start in numeric switching to ascii  			StartCode = StartStopCode.START2;  			StopCode = StartStopCode.STOP2;  			SwitchModeIndex = (StartNumerics % 2) == 1 ? StartNumerics - 1 : StartNumerics;  		} //if  		else {  			//start in ascii switching to numeric  			StartCode = StartStopCode.START3;  			StopCode = StartStopCode.STOP3;  			SwitchModeIndex = (EndNumerics % 2) == 1 ? Raw_Data.Length - EndNumerics + 1 : Raw_Data.Length - EndNumerics;  		}  		//else  	}  	//if  }  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,SetEncodingSequence,The following statement contains a magic number: if (StartNumerics == Raw_Data.Length) {  	//Numeric only mode due to only numbers being present  	StartCode = StartStopCode.START2;  	StopCode = StartStopCode.STOP2;  	if ((Raw_Data.Length % 2) > 0)  		SwitchModeIndex = RawData.Length - 1;  } //if  else {  	//ending number of numbers  	int EndNumerics = 0;  	for (int i = Raw_Data.Length - 1; i >= 0; i--) {  		if (Char.IsNumber (Raw_Data [i]))  			EndNumerics++;  		else  			break;  	}  	//for  	if (StartNumerics >= 4 || EndNumerics >= 4) {  		//hybrid mode will be used  		if (StartNumerics > EndNumerics) {  			//start in numeric switching to ascii  			StartCode = StartStopCode.START2;  			StopCode = StartStopCode.STOP2;  			SwitchModeIndex = (StartNumerics % 2) == 1 ? StartNumerics - 1 : StartNumerics;  		} //if  		else {  			//start in ascii switching to numeric  			StartCode = StartStopCode.START3;  			StopCode = StartStopCode.STOP3;  			SwitchModeIndex = (EndNumerics % 2) == 1 ? Raw_Data.Length - EndNumerics + 1 : Raw_Data.Length - EndNumerics;  		}  		//else  	}  	//if  }  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,SetEncodingSequence,The following statement contains a magic number: if (StartNumerics == Raw_Data.Length) {  	//Numeric only mode due to only numbers being present  	StartCode = StartStopCode.START2;  	StopCode = StartStopCode.STOP2;  	if ((Raw_Data.Length % 2) > 0)  		SwitchModeIndex = RawData.Length - 1;  } //if  else {  	//ending number of numbers  	int EndNumerics = 0;  	for (int i = Raw_Data.Length - 1; i >= 0; i--) {  		if (Char.IsNumber (Raw_Data [i]))  			EndNumerics++;  		else  			break;  	}  	//for  	if (StartNumerics >= 4 || EndNumerics >= 4) {  		//hybrid mode will be used  		if (StartNumerics > EndNumerics) {  			//start in numeric switching to ascii  			StartCode = StartStopCode.START2;  			StopCode = StartStopCode.STOP2;  			SwitchModeIndex = (StartNumerics % 2) == 1 ? StartNumerics - 1 : StartNumerics;  		} //if  		else {  			//start in ascii switching to numeric  			StartCode = StartStopCode.START3;  			StopCode = StartStopCode.STOP3;  			SwitchModeIndex = (EndNumerics % 2) == 1 ? Raw_Data.Length - EndNumerics + 1 : Raw_Data.Length - EndNumerics;  		}  		//else  	}  	//if  }  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,SetEncodingSequence,The following statement contains a magic number: if (StartNumerics == Raw_Data.Length) {  	//Numeric only mode due to only numbers being present  	StartCode = StartStopCode.START2;  	StopCode = StartStopCode.STOP2;  	if ((Raw_Data.Length % 2) > 0)  		SwitchModeIndex = RawData.Length - 1;  } //if  else {  	//ending number of numbers  	int EndNumerics = 0;  	for (int i = Raw_Data.Length - 1; i >= 0; i--) {  		if (Char.IsNumber (Raw_Data [i]))  			EndNumerics++;  		else  			break;  	}  	//for  	if (StartNumerics >= 4 || EndNumerics >= 4) {  		//hybrid mode will be used  		if (StartNumerics > EndNumerics) {  			//start in numeric switching to ascii  			StartCode = StartStopCode.START2;  			StopCode = StartStopCode.STOP2;  			SwitchModeIndex = (StartNumerics % 2) == 1 ? StartNumerics - 1 : StartNumerics;  		} //if  		else {  			//start in ascii switching to numeric  			StartCode = StartStopCode.START3;  			StopCode = StartStopCode.STOP3;  			SwitchModeIndex = (EndNumerics % 2) == 1 ? Raw_Data.Length - EndNumerics + 1 : Raw_Data.Length - EndNumerics;  		}  		//else  	}  	//if  }  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,SetEncodingSequence,The following statement contains a magic number: if (StartNumerics == Raw_Data.Length) {  	//Numeric only mode due to only numbers being present  	StartCode = StartStopCode.START2;  	StopCode = StartStopCode.STOP2;  	if ((Raw_Data.Length % 2) > 0)  		SwitchModeIndex = RawData.Length - 1;  } //if  else {  	//ending number of numbers  	int EndNumerics = 0;  	for (int i = Raw_Data.Length - 1; i >= 0; i--) {  		if (Char.IsNumber (Raw_Data [i]))  			EndNumerics++;  		else  			break;  	}  	//for  	if (StartNumerics >= 4 || EndNumerics >= 4) {  		//hybrid mode will be used  		if (StartNumerics > EndNumerics) {  			//start in numeric switching to ascii  			StartCode = StartStopCode.START2;  			StopCode = StartStopCode.STOP2;  			SwitchModeIndex = (StartNumerics % 2) == 1 ? StartNumerics - 1 : StartNumerics;  		} //if  		else {  			//start in ascii switching to numeric  			StartCode = StartStopCode.START3;  			StopCode = StartStopCode.STOP3;  			SwitchModeIndex = (EndNumerics % 2) == 1 ? Raw_Data.Length - EndNumerics + 1 : Raw_Data.Length - EndNumerics;  		}  		//else  	}  	//if  }  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,SetEncodingSequence,The following statement contains a magic number: if ((Raw_Data.Length % 2) > 0)  	SwitchModeIndex = RawData.Length - 1;  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,SetEncodingSequence,The following statement contains a magic number: if (StartNumerics >= 4 || EndNumerics >= 4) {  	//hybrid mode will be used  	if (StartNumerics > EndNumerics) {  		//start in numeric switching to ascii  		StartCode = StartStopCode.START2;  		StopCode = StartStopCode.STOP2;  		SwitchModeIndex = (StartNumerics % 2) == 1 ? StartNumerics - 1 : StartNumerics;  	} //if  	else {  		//start in ascii switching to numeric  		StartCode = StartStopCode.START3;  		StopCode = StartStopCode.STOP3;  		SwitchModeIndex = (EndNumerics % 2) == 1 ? Raw_Data.Length - EndNumerics + 1 : Raw_Data.Length - EndNumerics;  	}  	//else  }  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,SetEncodingSequence,The following statement contains a magic number: if (StartNumerics >= 4 || EndNumerics >= 4) {  	//hybrid mode will be used  	if (StartNumerics > EndNumerics) {  		//start in numeric switching to ascii  		StartCode = StartStopCode.START2;  		StopCode = StartStopCode.STOP2;  		SwitchModeIndex = (StartNumerics % 2) == 1 ? StartNumerics - 1 : StartNumerics;  	} //if  	else {  		//start in ascii switching to numeric  		StartCode = StartStopCode.START3;  		StopCode = StartStopCode.STOP3;  		SwitchModeIndex = (EndNumerics % 2) == 1 ? Raw_Data.Length - EndNumerics + 1 : Raw_Data.Length - EndNumerics;  	}  	//else  }  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,SetEncodingSequence,The following statement contains a magic number: if (StartNumerics >= 4 || EndNumerics >= 4) {  	//hybrid mode will be used  	if (StartNumerics > EndNumerics) {  		//start in numeric switching to ascii  		StartCode = StartStopCode.START2;  		StopCode = StartStopCode.STOP2;  		SwitchModeIndex = (StartNumerics % 2) == 1 ? StartNumerics - 1 : StartNumerics;  	} //if  	else {  		//start in ascii switching to numeric  		StartCode = StartStopCode.START3;  		StopCode = StartStopCode.STOP3;  		SwitchModeIndex = (EndNumerics % 2) == 1 ? Raw_Data.Length - EndNumerics + 1 : Raw_Data.Length - EndNumerics;  	}  	//else  }  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,SetEncodingSequence,The following statement contains a magic number: if (StartNumerics >= 4 || EndNumerics >= 4) {  	//hybrid mode will be used  	if (StartNumerics > EndNumerics) {  		//start in numeric switching to ascii  		StartCode = StartStopCode.START2;  		StopCode = StartStopCode.STOP2;  		SwitchModeIndex = (StartNumerics % 2) == 1 ? StartNumerics - 1 : StartNumerics;  	} //if  	else {  		//start in ascii switching to numeric  		StartCode = StartStopCode.START3;  		StopCode = StartStopCode.STOP3;  		SwitchModeIndex = (EndNumerics % 2) == 1 ? Raw_Data.Length - EndNumerics + 1 : Raw_Data.Length - EndNumerics;  	}  	//else  }  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,SetEncodingSequence,The following statement contains a magic number: if (StartNumerics > EndNumerics) {  	//start in numeric switching to ascii  	StartCode = StartStopCode.START2;  	StopCode = StartStopCode.STOP2;  	SwitchModeIndex = (StartNumerics % 2) == 1 ? StartNumerics - 1 : StartNumerics;  } //if  else {  	//start in ascii switching to numeric  	StartCode = StartStopCode.START3;  	StopCode = StartStopCode.STOP3;  	SwitchModeIndex = (EndNumerics % 2) == 1 ? Raw_Data.Length - EndNumerics + 1 : Raw_Data.Length - EndNumerics;  }  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,SetEncodingSequence,The following statement contains a magic number: if (StartNumerics > EndNumerics) {  	//start in numeric switching to ascii  	StartCode = StartStopCode.START2;  	StopCode = StartStopCode.STOP2;  	SwitchModeIndex = (StartNumerics % 2) == 1 ? StartNumerics - 1 : StartNumerics;  } //if  else {  	//start in ascii switching to numeric  	StartCode = StartStopCode.START3;  	StopCode = StartStopCode.STOP3;  	SwitchModeIndex = (EndNumerics % 2) == 1 ? Raw_Data.Length - EndNumerics + 1 : Raw_Data.Length - EndNumerics;  }  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,SetEncodingSequence,The following statement contains a magic number: SwitchModeIndex = (StartNumerics % 2) == 1 ? StartNumerics - 1 : StartNumerics;  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,SetEncodingSequence,The following statement contains a magic number: SwitchModeIndex = (EndNumerics % 2) == 1 ? Raw_Data.Length - EndNumerics + 1 : Raw_Data.Length - EndNumerics;  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (2)' "1110001110111010");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (3)' "1010111011101110");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (4)' "1110101110111010");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (5)' "1011100011101110");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (6)' "1000100011101110");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (7)' "1010101110111010");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (8)' "1110111000111010");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (9)' "1011101011101110");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (10)' "1110001011101110");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (11)' "1010111000111010");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (12)' "1110101011101110");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (13)' "1010001000111010");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (14)' "1000101000111010");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (15)' "1010101011101110");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (16)' "1110111010111010");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (17)' "1011101110001110");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (18)' "1110001110001110");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (19)' "1010111010111010");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (20)' "1110101110001110");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (21)' "1011100010111010");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (22)' "1000100010111010");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (23)' "1010101110001110");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (24)' "1110100010001110");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (25)' "1011101010111010");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (26)' "1110001010111010");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (27)' "1010100010001110");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (28)' "1110101010111010");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (29)' "1010001010001110");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (30)' "1000101010001110");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (31)' "1010101010111010");  
Magic Number,BarcodeLib.Symbologies,Telepen,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add (Convert.ToChar (127)' "1010101010101010");  
Magic Number,BarcodeLib.Symbologies,ITF14,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ITF14.cs,Encode_ITF14,The following statement contains a magic number: if (Raw_Data.Length > 14 || Raw_Data.Length < 13)  	Error ("EITF14-1: Data length invalid. (Length must be 13 or 14)");  
Magic Number,BarcodeLib.Symbologies,ITF14,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ITF14.cs,Encode_ITF14,The following statement contains a magic number: if (Raw_Data.Length > 14 || Raw_Data.Length < 13)  	Error ("EITF14-1: Data length invalid. (Length must be 13 or 14)");  
Magic Number,BarcodeLib.Symbologies,ITF14,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ITF14.cs,Encode_ITF14,The following statement contains a magic number: for (int i = 0; i < Raw_Data.Length; i += 2) {  	bool bars = true;  	string patternbars = ITF14_Code [Int32.Parse (Raw_Data [i].ToString ())];  	string patternspaces = ITF14_Code [Int32.Parse (Raw_Data [i + 1].ToString ())];  	string patternmixed = "";  	//interleave  	while (patternbars.Length > 0) {  		patternmixed += patternbars [0].ToString () + patternspaces [0].ToString ();  		patternbars = patternbars.Substring (1);  		patternspaces = patternspaces.Substring (1);  	}  	//while  	foreach (char c1 in patternmixed) {  		if (bars) {  			if (c1 == 'N')  				result += "1";  			else  				result += "11";  		} //if  		else {  			if (c1 == 'N')  				result += "0";  			else  				result += "00";  		}  		//else  		bars = !bars;  	}  	//foreach  }  
Magic Number,BarcodeLib.Symbologies,ITF14,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ITF14.cs,Encode_ITF14,The following statement contains a magic number: i += 2
Magic Number,BarcodeLib.Symbologies,ITF14,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ITF14.cs,CheckDigit,The following statement contains a magic number: if (Raw_Data.Length == 13) {  	int total = 0;  	for (int i = 0; i <= Raw_Data.Length - 1; i++) {  		int temp = Int32.Parse (Raw_Data.Substring (i' 1));  		total += temp * ((i == 0 || i % 2 == 0) ? 3 : 1);  	}  	//for  	int cs = total % 10;  	cs = 10 - cs;  	if (cs == 10)  		cs = 0;  	this.Raw_Data += cs.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,ITF14,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ITF14.cs,CheckDigit,The following statement contains a magic number: if (Raw_Data.Length == 13) {  	int total = 0;  	for (int i = 0; i <= Raw_Data.Length - 1; i++) {  		int temp = Int32.Parse (Raw_Data.Substring (i' 1));  		total += temp * ((i == 0 || i % 2 == 0) ? 3 : 1);  	}  	//for  	int cs = total % 10;  	cs = 10 - cs;  	if (cs == 10)  		cs = 0;  	this.Raw_Data += cs.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,ITF14,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ITF14.cs,CheckDigit,The following statement contains a magic number: if (Raw_Data.Length == 13) {  	int total = 0;  	for (int i = 0; i <= Raw_Data.Length - 1; i++) {  		int temp = Int32.Parse (Raw_Data.Substring (i' 1));  		total += temp * ((i == 0 || i % 2 == 0) ? 3 : 1);  	}  	//for  	int cs = total % 10;  	cs = 10 - cs;  	if (cs == 10)  		cs = 0;  	this.Raw_Data += cs.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,ITF14,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ITF14.cs,CheckDigit,The following statement contains a magic number: if (Raw_Data.Length == 13) {  	int total = 0;  	for (int i = 0; i <= Raw_Data.Length - 1; i++) {  		int temp = Int32.Parse (Raw_Data.Substring (i' 1));  		total += temp * ((i == 0 || i % 2 == 0) ? 3 : 1);  	}  	//for  	int cs = total % 10;  	cs = 10 - cs;  	if (cs == 10)  		cs = 0;  	this.Raw_Data += cs.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,ITF14,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ITF14.cs,CheckDigit,The following statement contains a magic number: if (Raw_Data.Length == 13) {  	int total = 0;  	for (int i = 0; i <= Raw_Data.Length - 1; i++) {  		int temp = Int32.Parse (Raw_Data.Substring (i' 1));  		total += temp * ((i == 0 || i % 2 == 0) ? 3 : 1);  	}  	//for  	int cs = total % 10;  	cs = 10 - cs;  	if (cs == 10)  		cs = 0;  	this.Raw_Data += cs.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,ITF14,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ITF14.cs,CheckDigit,The following statement contains a magic number: if (Raw_Data.Length == 13) {  	int total = 0;  	for (int i = 0; i <= Raw_Data.Length - 1; i++) {  		int temp = Int32.Parse (Raw_Data.Substring (i' 1));  		total += temp * ((i == 0 || i % 2 == 0) ? 3 : 1);  	}  	//for  	int cs = total % 10;  	cs = 10 - cs;  	if (cs == 10)  		cs = 0;  	this.Raw_Data += cs.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,ITF14,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ITF14.cs,CheckDigit,The following statement contains a magic number: for (int i = 0; i <= Raw_Data.Length - 1; i++) {  	int temp = Int32.Parse (Raw_Data.Substring (i' 1));  	total += temp * ((i == 0 || i % 2 == 0) ? 3 : 1);  }  
Magic Number,BarcodeLib.Symbologies,ITF14,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ITF14.cs,CheckDigit,The following statement contains a magic number: for (int i = 0; i <= Raw_Data.Length - 1; i++) {  	int temp = Int32.Parse (Raw_Data.Substring (i' 1));  	total += temp * ((i == 0 || i % 2 == 0) ? 3 : 1);  }  
Magic Number,BarcodeLib.Symbologies,ITF14,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ITF14.cs,CheckDigit,The following statement contains a magic number: total += temp * ((i == 0 || i % 2 == 0) ? 3 : 1);  
Magic Number,BarcodeLib.Symbologies,ITF14,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ITF14.cs,CheckDigit,The following statement contains a magic number: total += temp * ((i == 0 || i % 2 == 0) ? 3 : 1);  
Magic Number,BarcodeLib.Symbologies,ITF14,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ITF14.cs,CheckDigit,The following statement contains a magic number: cs = 10 - cs;  
Magic Number,BarcodeLib.Symbologies,ITF14,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ITF14.cs,CheckDigit,The following statement contains a magic number: if (cs == 10)  	cs = 0;  
Magic Number,BarcodeLib.Symbologies,EAN13,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN13.cs,Encode_EAN13,The following statement contains a magic number: if (Raw_Data.Length < 12 || Raw_Data.Length > 13)  	Error ("EEAN13-1: Data length invalid. (Length must be 12 or 13)");  
Magic Number,BarcodeLib.Symbologies,EAN13,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN13.cs,Encode_EAN13,The following statement contains a magic number: if (Raw_Data.Length < 12 || Raw_Data.Length > 13)  	Error ("EEAN13-1: Data length invalid. (Length must be 12 or 13)");  
Magic Number,BarcodeLib.Symbologies,EAN13,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN13.cs,Encode_EAN13,The following statement contains a magic number: while (pos < 6) {  	if (patterncode [pos] == 'a')  		result += EAN_CodeA [Int32.Parse (Raw_Data [pos + 1].ToString ())];  	if (patterncode [pos] == 'b')  		result += EAN_CodeB [Int32.Parse (Raw_Data [pos + 1].ToString ())];  	pos++;  }  
Magic Number,BarcodeLib.Symbologies,EAN13,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN13.cs,Encode_EAN13,The following statement contains a magic number: while (pos <= 5) {  	result += EAN_CodeC [Int32.Parse (Raw_Data [(pos++) + 6].ToString ())];  }  
Magic Number,BarcodeLib.Symbologies,EAN13,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN13.cs,Encode_EAN13,The following statement contains a magic number: while (pos <= 5) {  	result += EAN_CodeC [Int32.Parse (Raw_Data [(pos++) + 6].ToString ())];  }  
Magic Number,BarcodeLib.Symbologies,EAN13,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN13.cs,Encode_EAN13,The following statement contains a magic number: result += EAN_CodeC [Int32.Parse (Raw_Data [(pos++) + 6].ToString ())];  
Magic Number,BarcodeLib.Symbologies,EAN13,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN13.cs,CheckDigit,The following statement contains a magic number: try {  	string RawDataHolder = Raw_Data.Substring (0' 12);  	int even = 0;  	int odd = 0;  	for (int i = 0; i < RawDataHolder.Length; i++) {  		if (i % 2 == 0)  			odd += Int32.Parse (RawDataHolder.Substring (i' 1));  		else  			even += Int32.Parse (RawDataHolder.Substring (i' 1)) * 3;  	}  	//for  	int total = even + odd;  	int cs = total % 10;  	cs = 10 - cs;  	if (cs == 10)  		cs = 0;  	Raw_Data = RawDataHolder + cs.ToString () [0];  } //try  catch {  	Error ("EEAN13-4: Error calculating check digit.");  }  
Magic Number,BarcodeLib.Symbologies,EAN13,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN13.cs,CheckDigit,The following statement contains a magic number: try {  	string RawDataHolder = Raw_Data.Substring (0' 12);  	int even = 0;  	int odd = 0;  	for (int i = 0; i < RawDataHolder.Length; i++) {  		if (i % 2 == 0)  			odd += Int32.Parse (RawDataHolder.Substring (i' 1));  		else  			even += Int32.Parse (RawDataHolder.Substring (i' 1)) * 3;  	}  	//for  	int total = even + odd;  	int cs = total % 10;  	cs = 10 - cs;  	if (cs == 10)  		cs = 0;  	Raw_Data = RawDataHolder + cs.ToString () [0];  } //try  catch {  	Error ("EEAN13-4: Error calculating check digit.");  }  
Magic Number,BarcodeLib.Symbologies,EAN13,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN13.cs,CheckDigit,The following statement contains a magic number: try {  	string RawDataHolder = Raw_Data.Substring (0' 12);  	int even = 0;  	int odd = 0;  	for (int i = 0; i < RawDataHolder.Length; i++) {  		if (i % 2 == 0)  			odd += Int32.Parse (RawDataHolder.Substring (i' 1));  		else  			even += Int32.Parse (RawDataHolder.Substring (i' 1)) * 3;  	}  	//for  	int total = even + odd;  	int cs = total % 10;  	cs = 10 - cs;  	if (cs == 10)  		cs = 0;  	Raw_Data = RawDataHolder + cs.ToString () [0];  } //try  catch {  	Error ("EEAN13-4: Error calculating check digit.");  }  
Magic Number,BarcodeLib.Symbologies,EAN13,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN13.cs,CheckDigit,The following statement contains a magic number: try {  	string RawDataHolder = Raw_Data.Substring (0' 12);  	int even = 0;  	int odd = 0;  	for (int i = 0; i < RawDataHolder.Length; i++) {  		if (i % 2 == 0)  			odd += Int32.Parse (RawDataHolder.Substring (i' 1));  		else  			even += Int32.Parse (RawDataHolder.Substring (i' 1)) * 3;  	}  	//for  	int total = even + odd;  	int cs = total % 10;  	cs = 10 - cs;  	if (cs == 10)  		cs = 0;  	Raw_Data = RawDataHolder + cs.ToString () [0];  } //try  catch {  	Error ("EEAN13-4: Error calculating check digit.");  }  
Magic Number,BarcodeLib.Symbologies,EAN13,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN13.cs,CheckDigit,The following statement contains a magic number: try {  	string RawDataHolder = Raw_Data.Substring (0' 12);  	int even = 0;  	int odd = 0;  	for (int i = 0; i < RawDataHolder.Length; i++) {  		if (i % 2 == 0)  			odd += Int32.Parse (RawDataHolder.Substring (i' 1));  		else  			even += Int32.Parse (RawDataHolder.Substring (i' 1)) * 3;  	}  	//for  	int total = even + odd;  	int cs = total % 10;  	cs = 10 - cs;  	if (cs == 10)  		cs = 0;  	Raw_Data = RawDataHolder + cs.ToString () [0];  } //try  catch {  	Error ("EEAN13-4: Error calculating check digit.");  }  
Magic Number,BarcodeLib.Symbologies,EAN13,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN13.cs,CheckDigit,The following statement contains a magic number: try {  	string RawDataHolder = Raw_Data.Substring (0' 12);  	int even = 0;  	int odd = 0;  	for (int i = 0; i < RawDataHolder.Length; i++) {  		if (i % 2 == 0)  			odd += Int32.Parse (RawDataHolder.Substring (i' 1));  		else  			even += Int32.Parse (RawDataHolder.Substring (i' 1)) * 3;  	}  	//for  	int total = even + odd;  	int cs = total % 10;  	cs = 10 - cs;  	if (cs == 10)  		cs = 0;  	Raw_Data = RawDataHolder + cs.ToString () [0];  } //try  catch {  	Error ("EEAN13-4: Error calculating check digit.");  }  
Magic Number,BarcodeLib.Symbologies,EAN13,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN13.cs,CheckDigit,The following statement contains a magic number: for (int i = 0; i < RawDataHolder.Length; i++) {  	if (i % 2 == 0)  		odd += Int32.Parse (RawDataHolder.Substring (i' 1));  	else  		even += Int32.Parse (RawDataHolder.Substring (i' 1)) * 3;  }  
Magic Number,BarcodeLib.Symbologies,EAN13,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN13.cs,CheckDigit,The following statement contains a magic number: for (int i = 0; i < RawDataHolder.Length; i++) {  	if (i % 2 == 0)  		odd += Int32.Parse (RawDataHolder.Substring (i' 1));  	else  		even += Int32.Parse (RawDataHolder.Substring (i' 1)) * 3;  }  
Magic Number,BarcodeLib.Symbologies,EAN13,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN13.cs,CheckDigit,The following statement contains a magic number: if (i % 2 == 0)  	odd += Int32.Parse (RawDataHolder.Substring (i' 1));  else  	even += Int32.Parse (RawDataHolder.Substring (i' 1)) * 3;  
Magic Number,BarcodeLib.Symbologies,EAN13,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN13.cs,CheckDigit,The following statement contains a magic number: if (i % 2 == 0)  	odd += Int32.Parse (RawDataHolder.Substring (i' 1));  else  	even += Int32.Parse (RawDataHolder.Substring (i' 1)) * 3;  
Magic Number,BarcodeLib.Symbologies,EAN13,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN13.cs,CheckDigit,The following statement contains a magic number: even += Int32.Parse (RawDataHolder.Substring (i' 1)) * 3;  
Magic Number,BarcodeLib.Symbologies,EAN13,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN13.cs,CheckDigit,The following statement contains a magic number: cs = 10 - cs;  
Magic Number,BarcodeLib.Symbologies,EAN13,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN13.cs,CheckDigit,The following statement contains a magic number: if (cs == 10)  	cs = 0;  
Magic Number,BarcodeLib.Symbologies,EAN8,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN8.cs,Encode_EAN8,The following statement contains a magic number: if (Raw_Data.Length != 8 && Raw_Data.Length != 7)  	Error ("EEAN8-1: Invalid data length. (7 or 8 numbers only)");  
Magic Number,BarcodeLib.Symbologies,EAN8,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN8.cs,Encode_EAN8,The following statement contains a magic number: if (Raw_Data.Length != 8 && Raw_Data.Length != 7)  	Error ("EEAN8-1: Invalid data length. (7 or 8 numbers only)");  
Magic Number,BarcodeLib.Symbologies,EAN8,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN8.cs,Encode_EAN8,The following statement contains a magic number: for (int i = 0; i < Raw_Data.Length / 2; i++) {  	result += EAN_CodeA [Int32.Parse (Raw_Data [i].ToString ())];  }  
Magic Number,BarcodeLib.Symbologies,EAN8,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN8.cs,Encode_EAN8,The following statement contains a magic number: for (int i = Raw_Data.Length / 2; i < Raw_Data.Length; i++) {  	result += EAN_CodeC [Int32.Parse (Raw_Data [i].ToString ())];  }  
Magic Number,BarcodeLib.Symbologies,EAN8,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN8.cs,CheckDigit,The following statement contains a magic number: if (Raw_Data.Length == 7) {  	//calculate the checksum digit  	int even = 0;  	int odd = 0;  	//odd  	for (int i = 0; i <= 6; i += 2) {  		odd += Int32.Parse (Raw_Data.Substring (i' 1)) * 3;  	}  	//for  	//even  	for (int i = 1; i <= 5; i += 2) {  		even += Int32.Parse (Raw_Data.Substring (i' 1));  	}  	//for  	int total = even + odd;  	int checksum = total % 10;  	checksum = 10 - checksum;  	if (checksum == 10)  		checksum = 0;  	//add the checksum to the end of the   	Raw_Data += checksum.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,EAN8,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN8.cs,CheckDigit,The following statement contains a magic number: if (Raw_Data.Length == 7) {  	//calculate the checksum digit  	int even = 0;  	int odd = 0;  	//odd  	for (int i = 0; i <= 6; i += 2) {  		odd += Int32.Parse (Raw_Data.Substring (i' 1)) * 3;  	}  	//for  	//even  	for (int i = 1; i <= 5; i += 2) {  		even += Int32.Parse (Raw_Data.Substring (i' 1));  	}  	//for  	int total = even + odd;  	int checksum = total % 10;  	checksum = 10 - checksum;  	if (checksum == 10)  		checksum = 0;  	//add the checksum to the end of the   	Raw_Data += checksum.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,EAN8,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN8.cs,CheckDigit,The following statement contains a magic number: if (Raw_Data.Length == 7) {  	//calculate the checksum digit  	int even = 0;  	int odd = 0;  	//odd  	for (int i = 0; i <= 6; i += 2) {  		odd += Int32.Parse (Raw_Data.Substring (i' 1)) * 3;  	}  	//for  	//even  	for (int i = 1; i <= 5; i += 2) {  		even += Int32.Parse (Raw_Data.Substring (i' 1));  	}  	//for  	int total = even + odd;  	int checksum = total % 10;  	checksum = 10 - checksum;  	if (checksum == 10)  		checksum = 0;  	//add the checksum to the end of the   	Raw_Data += checksum.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,EAN8,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN8.cs,CheckDigit,The following statement contains a magic number: if (Raw_Data.Length == 7) {  	//calculate the checksum digit  	int even = 0;  	int odd = 0;  	//odd  	for (int i = 0; i <= 6; i += 2) {  		odd += Int32.Parse (Raw_Data.Substring (i' 1)) * 3;  	}  	//for  	//even  	for (int i = 1; i <= 5; i += 2) {  		even += Int32.Parse (Raw_Data.Substring (i' 1));  	}  	//for  	int total = even + odd;  	int checksum = total % 10;  	checksum = 10 - checksum;  	if (checksum == 10)  		checksum = 0;  	//add the checksum to the end of the   	Raw_Data += checksum.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,EAN8,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN8.cs,CheckDigit,The following statement contains a magic number: if (Raw_Data.Length == 7) {  	//calculate the checksum digit  	int even = 0;  	int odd = 0;  	//odd  	for (int i = 0; i <= 6; i += 2) {  		odd += Int32.Parse (Raw_Data.Substring (i' 1)) * 3;  	}  	//for  	//even  	for (int i = 1; i <= 5; i += 2) {  		even += Int32.Parse (Raw_Data.Substring (i' 1));  	}  	//for  	int total = even + odd;  	int checksum = total % 10;  	checksum = 10 - checksum;  	if (checksum == 10)  		checksum = 0;  	//add the checksum to the end of the   	Raw_Data += checksum.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,EAN8,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN8.cs,CheckDigit,The following statement contains a magic number: if (Raw_Data.Length == 7) {  	//calculate the checksum digit  	int even = 0;  	int odd = 0;  	//odd  	for (int i = 0; i <= 6; i += 2) {  		odd += Int32.Parse (Raw_Data.Substring (i' 1)) * 3;  	}  	//for  	//even  	for (int i = 1; i <= 5; i += 2) {  		even += Int32.Parse (Raw_Data.Substring (i' 1));  	}  	//for  	int total = even + odd;  	int checksum = total % 10;  	checksum = 10 - checksum;  	if (checksum == 10)  		checksum = 0;  	//add the checksum to the end of the   	Raw_Data += checksum.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,EAN8,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN8.cs,CheckDigit,The following statement contains a magic number: if (Raw_Data.Length == 7) {  	//calculate the checksum digit  	int even = 0;  	int odd = 0;  	//odd  	for (int i = 0; i <= 6; i += 2) {  		odd += Int32.Parse (Raw_Data.Substring (i' 1)) * 3;  	}  	//for  	//even  	for (int i = 1; i <= 5; i += 2) {  		even += Int32.Parse (Raw_Data.Substring (i' 1));  	}  	//for  	int total = even + odd;  	int checksum = total % 10;  	checksum = 10 - checksum;  	if (checksum == 10)  		checksum = 0;  	//add the checksum to the end of the   	Raw_Data += checksum.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,EAN8,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN8.cs,CheckDigit,The following statement contains a magic number: if (Raw_Data.Length == 7) {  	//calculate the checksum digit  	int even = 0;  	int odd = 0;  	//odd  	for (int i = 0; i <= 6; i += 2) {  		odd += Int32.Parse (Raw_Data.Substring (i' 1)) * 3;  	}  	//for  	//even  	for (int i = 1; i <= 5; i += 2) {  		even += Int32.Parse (Raw_Data.Substring (i' 1));  	}  	//for  	int total = even + odd;  	int checksum = total % 10;  	checksum = 10 - checksum;  	if (checksum == 10)  		checksum = 0;  	//add the checksum to the end of the   	Raw_Data += checksum.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,EAN8,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN8.cs,CheckDigit,The following statement contains a magic number: if (Raw_Data.Length == 7) {  	//calculate the checksum digit  	int even = 0;  	int odd = 0;  	//odd  	for (int i = 0; i <= 6; i += 2) {  		odd += Int32.Parse (Raw_Data.Substring (i' 1)) * 3;  	}  	//for  	//even  	for (int i = 1; i <= 5; i += 2) {  		even += Int32.Parse (Raw_Data.Substring (i' 1));  	}  	//for  	int total = even + odd;  	int checksum = total % 10;  	checksum = 10 - checksum;  	if (checksum == 10)  		checksum = 0;  	//add the checksum to the end of the   	Raw_Data += checksum.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,EAN8,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN8.cs,CheckDigit,The following statement contains a magic number: for (int i = 0; i <= 6; i += 2) {  	odd += Int32.Parse (Raw_Data.Substring (i' 1)) * 3;  }  
Magic Number,BarcodeLib.Symbologies,EAN8,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN8.cs,CheckDigit,The following statement contains a magic number: for (int i = 0; i <= 6; i += 2) {  	odd += Int32.Parse (Raw_Data.Substring (i' 1)) * 3;  }  
Magic Number,BarcodeLib.Symbologies,EAN8,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN8.cs,CheckDigit,The following statement contains a magic number: for (int i = 0; i <= 6; i += 2) {  	odd += Int32.Parse (Raw_Data.Substring (i' 1)) * 3;  }  
Magic Number,BarcodeLib.Symbologies,EAN8,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN8.cs,CheckDigit,The following statement contains a magic number: i += 2
Magic Number,BarcodeLib.Symbologies,EAN8,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN8.cs,CheckDigit,The following statement contains a magic number: odd += Int32.Parse (Raw_Data.Substring (i' 1)) * 3;  
Magic Number,BarcodeLib.Symbologies,EAN8,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN8.cs,CheckDigit,The following statement contains a magic number: for (int i = 1; i <= 5; i += 2) {  	even += Int32.Parse (Raw_Data.Substring (i' 1));  }  
Magic Number,BarcodeLib.Symbologies,EAN8,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN8.cs,CheckDigit,The following statement contains a magic number: for (int i = 1; i <= 5; i += 2) {  	even += Int32.Parse (Raw_Data.Substring (i' 1));  }  
Magic Number,BarcodeLib.Symbologies,EAN8,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN8.cs,CheckDigit,The following statement contains a magic number: i += 2
Magic Number,BarcodeLib.Symbologies,EAN8,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN8.cs,CheckDigit,The following statement contains a magic number: checksum = 10 - checksum;  
Magic Number,BarcodeLib.Symbologies,EAN8,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\EAN8.cs,CheckDigit,The following statement contains a magic number: if (checksum == 10)  	checksum = 0;  
Magic Number,BarcodeLib.Symbologies,Interleaved2of5,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Interleaved2of5.cs,Encode_Interleaved2of5,The following statement contains a magic number: if (Raw_Data.Length % 2 != 0)  	Error ("EI25-1: Data length invalid.");  
Magic Number,BarcodeLib.Symbologies,Interleaved2of5,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Interleaved2of5.cs,Encode_Interleaved2of5,The following statement contains a magic number: for (int i = 0; i < Raw_Data.Length; i += 2) {  	bool bars = true;  	string patternbars = I25_Code [Int32.Parse (Raw_Data [i].ToString ())];  	string patternspaces = I25_Code [Int32.Parse (Raw_Data [i + 1].ToString ())];  	string patternmixed = "";  	//interleave  	while (patternbars.Length > 0) {  		patternmixed += patternbars [0].ToString () + patternspaces [0].ToString ();  		patternbars = patternbars.Substring (1);  		patternspaces = patternspaces.Substring (1);  	}  	//while  	foreach (char c1 in patternmixed) {  		if (bars) {  			if (c1 == 'N')  				result += "1";  			else  				result += "11";  		} //if  		else {  			if (c1 == 'N')  				result += "0";  			else  				result += "00";  		}  		//else  		bars = !bars;  	}  	//foreach  }  
Magic Number,BarcodeLib.Symbologies,Interleaved2of5,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Interleaved2of5.cs,Encode_Interleaved2of5,The following statement contains a magic number: i += 2
Magic Number,BarcodeLib.Symbologies,ISBN,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ISBN.cs,Encode_ISBN_Bookland,The following statement contains a magic number: if (Raw_Data.Length == 10 || Raw_Data.Length == 9) {  	if (Raw_Data.Length == 10)  		Raw_Data = Raw_Data.Remove (9' 1);  	Raw_Data = "978" + Raw_Data;  	type = "ISBN";  } //if  else if (Raw_Data.Length == 12 && Raw_Data.StartsWith ("978")) {  	type = "BOOKLAND-NOCHECKDIGIT";  } //else if  else if (Raw_Data.Length == 13 && Raw_Data.StartsWith ("978")) {  	type = "BOOKLAND-CHECKDIGIT";  	Raw_Data = Raw_Data.Remove (12' 1);  }  
Magic Number,BarcodeLib.Symbologies,ISBN,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ISBN.cs,Encode_ISBN_Bookland,The following statement contains a magic number: if (Raw_Data.Length == 10 || Raw_Data.Length == 9) {  	if (Raw_Data.Length == 10)  		Raw_Data = Raw_Data.Remove (9' 1);  	Raw_Data = "978" + Raw_Data;  	type = "ISBN";  } //if  else if (Raw_Data.Length == 12 && Raw_Data.StartsWith ("978")) {  	type = "BOOKLAND-NOCHECKDIGIT";  } //else if  else if (Raw_Data.Length == 13 && Raw_Data.StartsWith ("978")) {  	type = "BOOKLAND-CHECKDIGIT";  	Raw_Data = Raw_Data.Remove (12' 1);  }  
Magic Number,BarcodeLib.Symbologies,ISBN,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ISBN.cs,Encode_ISBN_Bookland,The following statement contains a magic number: if (Raw_Data.Length == 10 || Raw_Data.Length == 9) {  	if (Raw_Data.Length == 10)  		Raw_Data = Raw_Data.Remove (9' 1);  	Raw_Data = "978" + Raw_Data;  	type = "ISBN";  } //if  else if (Raw_Data.Length == 12 && Raw_Data.StartsWith ("978")) {  	type = "BOOKLAND-NOCHECKDIGIT";  } //else if  else if (Raw_Data.Length == 13 && Raw_Data.StartsWith ("978")) {  	type = "BOOKLAND-CHECKDIGIT";  	Raw_Data = Raw_Data.Remove (12' 1);  }  
Magic Number,BarcodeLib.Symbologies,ISBN,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ISBN.cs,Encode_ISBN_Bookland,The following statement contains a magic number: if (Raw_Data.Length == 10 || Raw_Data.Length == 9) {  	if (Raw_Data.Length == 10)  		Raw_Data = Raw_Data.Remove (9' 1);  	Raw_Data = "978" + Raw_Data;  	type = "ISBN";  } //if  else if (Raw_Data.Length == 12 && Raw_Data.StartsWith ("978")) {  	type = "BOOKLAND-NOCHECKDIGIT";  } //else if  else if (Raw_Data.Length == 13 && Raw_Data.StartsWith ("978")) {  	type = "BOOKLAND-CHECKDIGIT";  	Raw_Data = Raw_Data.Remove (12' 1);  }  
Magic Number,BarcodeLib.Symbologies,ISBN,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ISBN.cs,Encode_ISBN_Bookland,The following statement contains a magic number: if (Raw_Data.Length == 10 || Raw_Data.Length == 9) {  	if (Raw_Data.Length == 10)  		Raw_Data = Raw_Data.Remove (9' 1);  	Raw_Data = "978" + Raw_Data;  	type = "ISBN";  } //if  else if (Raw_Data.Length == 12 && Raw_Data.StartsWith ("978")) {  	type = "BOOKLAND-NOCHECKDIGIT";  } //else if  else if (Raw_Data.Length == 13 && Raw_Data.StartsWith ("978")) {  	type = "BOOKLAND-CHECKDIGIT";  	Raw_Data = Raw_Data.Remove (12' 1);  }  
Magic Number,BarcodeLib.Symbologies,ISBN,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ISBN.cs,Encode_ISBN_Bookland,The following statement contains a magic number: if (Raw_Data.Length == 10 || Raw_Data.Length == 9) {  	if (Raw_Data.Length == 10)  		Raw_Data = Raw_Data.Remove (9' 1);  	Raw_Data = "978" + Raw_Data;  	type = "ISBN";  } //if  else if (Raw_Data.Length == 12 && Raw_Data.StartsWith ("978")) {  	type = "BOOKLAND-NOCHECKDIGIT";  } //else if  else if (Raw_Data.Length == 13 && Raw_Data.StartsWith ("978")) {  	type = "BOOKLAND-CHECKDIGIT";  	Raw_Data = Raw_Data.Remove (12' 1);  }  
Magic Number,BarcodeLib.Symbologies,ISBN,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ISBN.cs,Encode_ISBN_Bookland,The following statement contains a magic number: if (Raw_Data.Length == 10 || Raw_Data.Length == 9) {  	if (Raw_Data.Length == 10)  		Raw_Data = Raw_Data.Remove (9' 1);  	Raw_Data = "978" + Raw_Data;  	type = "ISBN";  } //if  else if (Raw_Data.Length == 12 && Raw_Data.StartsWith ("978")) {  	type = "BOOKLAND-NOCHECKDIGIT";  } //else if  else if (Raw_Data.Length == 13 && Raw_Data.StartsWith ("978")) {  	type = "BOOKLAND-CHECKDIGIT";  	Raw_Data = Raw_Data.Remove (12' 1);  }  
Magic Number,BarcodeLib.Symbologies,ISBN,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ISBN.cs,Encode_ISBN_Bookland,The following statement contains a magic number: if (Raw_Data.Length == 10)  	Raw_Data = Raw_Data.Remove (9' 1);  
Magic Number,BarcodeLib.Symbologies,ISBN,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ISBN.cs,Encode_ISBN_Bookland,The following statement contains a magic number: if (Raw_Data.Length == 10)  	Raw_Data = Raw_Data.Remove (9' 1);  
Magic Number,BarcodeLib.Symbologies,ISBN,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ISBN.cs,Encode_ISBN_Bookland,The following statement contains a magic number: Raw_Data = Raw_Data.Remove (9' 1);  
Magic Number,BarcodeLib.Symbologies,ISBN,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ISBN.cs,Encode_ISBN_Bookland,The following statement contains a magic number: if (Raw_Data.Length == 12 && Raw_Data.StartsWith ("978")) {  	type = "BOOKLAND-NOCHECKDIGIT";  } //else if  else if (Raw_Data.Length == 13 && Raw_Data.StartsWith ("978")) {  	type = "BOOKLAND-CHECKDIGIT";  	Raw_Data = Raw_Data.Remove (12' 1);  }  
Magic Number,BarcodeLib.Symbologies,ISBN,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ISBN.cs,Encode_ISBN_Bookland,The following statement contains a magic number: if (Raw_Data.Length == 12 && Raw_Data.StartsWith ("978")) {  	type = "BOOKLAND-NOCHECKDIGIT";  } //else if  else if (Raw_Data.Length == 13 && Raw_Data.StartsWith ("978")) {  	type = "BOOKLAND-CHECKDIGIT";  	Raw_Data = Raw_Data.Remove (12' 1);  }  
Magic Number,BarcodeLib.Symbologies,ISBN,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ISBN.cs,Encode_ISBN_Bookland,The following statement contains a magic number: if (Raw_Data.Length == 12 && Raw_Data.StartsWith ("978")) {  	type = "BOOKLAND-NOCHECKDIGIT";  } //else if  else if (Raw_Data.Length == 13 && Raw_Data.StartsWith ("978")) {  	type = "BOOKLAND-CHECKDIGIT";  	Raw_Data = Raw_Data.Remove (12' 1);  }  
Magic Number,BarcodeLib.Symbologies,ISBN,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ISBN.cs,Encode_ISBN_Bookland,The following statement contains a magic number: if (Raw_Data.Length == 13 && Raw_Data.StartsWith ("978")) {  	type = "BOOKLAND-CHECKDIGIT";  	Raw_Data = Raw_Data.Remove (12' 1);  }  
Magic Number,BarcodeLib.Symbologies,ISBN,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ISBN.cs,Encode_ISBN_Bookland,The following statement contains a magic number: if (Raw_Data.Length == 13 && Raw_Data.StartsWith ("978")) {  	type = "BOOKLAND-CHECKDIGIT";  	Raw_Data = Raw_Data.Remove (12' 1);  }  
Magic Number,BarcodeLib.Symbologies,ISBN,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\ISBN.cs,Encode_ISBN_Bookland,The following statement contains a magic number: Raw_Data = Raw_Data.Remove (12' 1);  
Magic Number,BarcodeLib.Symbologies,MSI,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: if (Encoded_Type == TYPE.MSI_Mod10 || Encoded_Type == TYPE.MSI_2Mod10) {  	string odds = "";  	string evens = "";  	for (int i = PreEncoded.Length - 1; i >= 0; i -= 2) {  		odds = PreEncoded [i].ToString () + odds;  		if (i - 1 >= 0)  			evens = PreEncoded [i - 1].ToString () + evens;  	}  	//for  	//multiply odds by 2  	odds = Convert.ToString ((Int32.Parse (odds) * 2));  	int evensum = 0;  	int oddsum = 0;  	foreach (char c in evens)  		evensum += Int32.Parse (c.ToString ());  	foreach (char c in odds)  		oddsum += Int32.Parse (c.ToString ());  	int checksum = 10 - ((oddsum + evensum) % 10);  	PreEncoded += checksum.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,MSI,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: if (Encoded_Type == TYPE.MSI_Mod10 || Encoded_Type == TYPE.MSI_2Mod10) {  	string odds = "";  	string evens = "";  	for (int i = PreEncoded.Length - 1; i >= 0; i -= 2) {  		odds = PreEncoded [i].ToString () + odds;  		if (i - 1 >= 0)  			evens = PreEncoded [i - 1].ToString () + evens;  	}  	//for  	//multiply odds by 2  	odds = Convert.ToString ((Int32.Parse (odds) * 2));  	int evensum = 0;  	int oddsum = 0;  	foreach (char c in evens)  		evensum += Int32.Parse (c.ToString ());  	foreach (char c in odds)  		oddsum += Int32.Parse (c.ToString ());  	int checksum = 10 - ((oddsum + evensum) % 10);  	PreEncoded += checksum.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,MSI,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: if (Encoded_Type == TYPE.MSI_Mod10 || Encoded_Type == TYPE.MSI_2Mod10) {  	string odds = "";  	string evens = "";  	for (int i = PreEncoded.Length - 1; i >= 0; i -= 2) {  		odds = PreEncoded [i].ToString () + odds;  		if (i - 1 >= 0)  			evens = PreEncoded [i - 1].ToString () + evens;  	}  	//for  	//multiply odds by 2  	odds = Convert.ToString ((Int32.Parse (odds) * 2));  	int evensum = 0;  	int oddsum = 0;  	foreach (char c in evens)  		evensum += Int32.Parse (c.ToString ());  	foreach (char c in odds)  		oddsum += Int32.Parse (c.ToString ());  	int checksum = 10 - ((oddsum + evensum) % 10);  	PreEncoded += checksum.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,MSI,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: if (Encoded_Type == TYPE.MSI_Mod10 || Encoded_Type == TYPE.MSI_2Mod10) {  	string odds = "";  	string evens = "";  	for (int i = PreEncoded.Length - 1; i >= 0; i -= 2) {  		odds = PreEncoded [i].ToString () + odds;  		if (i - 1 >= 0)  			evens = PreEncoded [i - 1].ToString () + evens;  	}  	//for  	//multiply odds by 2  	odds = Convert.ToString ((Int32.Parse (odds) * 2));  	int evensum = 0;  	int oddsum = 0;  	foreach (char c in evens)  		evensum += Int32.Parse (c.ToString ());  	foreach (char c in odds)  		oddsum += Int32.Parse (c.ToString ());  	int checksum = 10 - ((oddsum + evensum) % 10);  	PreEncoded += checksum.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,MSI,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: for (int i = PreEncoded.Length - 1; i >= 0; i -= 2) {  	odds = PreEncoded [i].ToString () + odds;  	if (i - 1 >= 0)  		evens = PreEncoded [i - 1].ToString () + evens;  }  
Magic Number,BarcodeLib.Symbologies,MSI,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: i -= 2
Magic Number,BarcodeLib.Symbologies,MSI,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: odds = Convert.ToString ((Int32.Parse (odds) * 2));  
Magic Number,BarcodeLib.Symbologies,MSI,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: if (Encoded_Type == TYPE.MSI_Mod11 || Encoded_Type == TYPE.MSI_Mod11_Mod10) {  	int sum = 0;  	int weight = 2;  	for (int i = PreEncoded.Length - 1; i >= 0; i--) {  		if (weight > 7)  			weight = 2;  		sum += Int32.Parse (PreEncoded [i].ToString ()) * weight++;  	}  	//foreach  	int checksum = 11 - (sum % 11);  	PreEncoded += checksum.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,MSI,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: if (Encoded_Type == TYPE.MSI_Mod11 || Encoded_Type == TYPE.MSI_Mod11_Mod10) {  	int sum = 0;  	int weight = 2;  	for (int i = PreEncoded.Length - 1; i >= 0; i--) {  		if (weight > 7)  			weight = 2;  		sum += Int32.Parse (PreEncoded [i].ToString ()) * weight++;  	}  	//foreach  	int checksum = 11 - (sum % 11);  	PreEncoded += checksum.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,MSI,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: if (Encoded_Type == TYPE.MSI_Mod11 || Encoded_Type == TYPE.MSI_Mod11_Mod10) {  	int sum = 0;  	int weight = 2;  	for (int i = PreEncoded.Length - 1; i >= 0; i--) {  		if (weight > 7)  			weight = 2;  		sum += Int32.Parse (PreEncoded [i].ToString ()) * weight++;  	}  	//foreach  	int checksum = 11 - (sum % 11);  	PreEncoded += checksum.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,MSI,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: if (Encoded_Type == TYPE.MSI_Mod11 || Encoded_Type == TYPE.MSI_Mod11_Mod10) {  	int sum = 0;  	int weight = 2;  	for (int i = PreEncoded.Length - 1; i >= 0; i--) {  		if (weight > 7)  			weight = 2;  		sum += Int32.Parse (PreEncoded [i].ToString ()) * weight++;  	}  	//foreach  	int checksum = 11 - (sum % 11);  	PreEncoded += checksum.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,MSI,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: if (Encoded_Type == TYPE.MSI_Mod11 || Encoded_Type == TYPE.MSI_Mod11_Mod10) {  	int sum = 0;  	int weight = 2;  	for (int i = PreEncoded.Length - 1; i >= 0; i--) {  		if (weight > 7)  			weight = 2;  		sum += Int32.Parse (PreEncoded [i].ToString ()) * weight++;  	}  	//foreach  	int checksum = 11 - (sum % 11);  	PreEncoded += checksum.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,MSI,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: for (int i = PreEncoded.Length - 1; i >= 0; i--) {  	if (weight > 7)  		weight = 2;  	sum += Int32.Parse (PreEncoded [i].ToString ()) * weight++;  }  
Magic Number,BarcodeLib.Symbologies,MSI,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: for (int i = PreEncoded.Length - 1; i >= 0; i--) {  	if (weight > 7)  		weight = 2;  	sum += Int32.Parse (PreEncoded [i].ToString ()) * weight++;  }  
Magic Number,BarcodeLib.Symbologies,MSI,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: if (weight > 7)  	weight = 2;  
Magic Number,BarcodeLib.Symbologies,MSI,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: if (weight > 7)  	weight = 2;  
Magic Number,BarcodeLib.Symbologies,MSI,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: weight = 2;  
Magic Number,BarcodeLib.Symbologies,MSI,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: if (Encoded_Type == TYPE.MSI_2Mod10 || Encoded_Type == TYPE.MSI_Mod11_Mod10) {  	//get second check digit if 2 mod 10 was selected or Mod11/Mod10  	string odds = "";  	string evens = "";  	for (int i = PreEncoded.Length - 1; i >= 0; i -= 2) {  		odds = PreEncoded [i].ToString () + odds;  		if (i - 1 >= 0)  			evens = PreEncoded [i - 1].ToString () + evens;  	}  	//for  	//multiply odds by 2  	odds = Convert.ToString ((Int32.Parse (odds) * 2));  	int evensum = 0;  	int oddsum = 0;  	foreach (char c in evens)  		evensum += Int32.Parse (c.ToString ());  	foreach (char c in odds)  		oddsum += Int32.Parse (c.ToString ());  	int checksum = 10 - ((oddsum + evensum) % 10);  	PreEncoded += checksum.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,MSI,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: if (Encoded_Type == TYPE.MSI_2Mod10 || Encoded_Type == TYPE.MSI_Mod11_Mod10) {  	//get second check digit if 2 mod 10 was selected or Mod11/Mod10  	string odds = "";  	string evens = "";  	for (int i = PreEncoded.Length - 1; i >= 0; i -= 2) {  		odds = PreEncoded [i].ToString () + odds;  		if (i - 1 >= 0)  			evens = PreEncoded [i - 1].ToString () + evens;  	}  	//for  	//multiply odds by 2  	odds = Convert.ToString ((Int32.Parse (odds) * 2));  	int evensum = 0;  	int oddsum = 0;  	foreach (char c in evens)  		evensum += Int32.Parse (c.ToString ());  	foreach (char c in odds)  		oddsum += Int32.Parse (c.ToString ());  	int checksum = 10 - ((oddsum + evensum) % 10);  	PreEncoded += checksum.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,MSI,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: if (Encoded_Type == TYPE.MSI_2Mod10 || Encoded_Type == TYPE.MSI_Mod11_Mod10) {  	//get second check digit if 2 mod 10 was selected or Mod11/Mod10  	string odds = "";  	string evens = "";  	for (int i = PreEncoded.Length - 1; i >= 0; i -= 2) {  		odds = PreEncoded [i].ToString () + odds;  		if (i - 1 >= 0)  			evens = PreEncoded [i - 1].ToString () + evens;  	}  	//for  	//multiply odds by 2  	odds = Convert.ToString ((Int32.Parse (odds) * 2));  	int evensum = 0;  	int oddsum = 0;  	foreach (char c in evens)  		evensum += Int32.Parse (c.ToString ());  	foreach (char c in odds)  		oddsum += Int32.Parse (c.ToString ());  	int checksum = 10 - ((oddsum + evensum) % 10);  	PreEncoded += checksum.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,MSI,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: if (Encoded_Type == TYPE.MSI_2Mod10 || Encoded_Type == TYPE.MSI_Mod11_Mod10) {  	//get second check digit if 2 mod 10 was selected or Mod11/Mod10  	string odds = "";  	string evens = "";  	for (int i = PreEncoded.Length - 1; i >= 0; i -= 2) {  		odds = PreEncoded [i].ToString () + odds;  		if (i - 1 >= 0)  			evens = PreEncoded [i - 1].ToString () + evens;  	}  	//for  	//multiply odds by 2  	odds = Convert.ToString ((Int32.Parse (odds) * 2));  	int evensum = 0;  	int oddsum = 0;  	foreach (char c in evens)  		evensum += Int32.Parse (c.ToString ());  	foreach (char c in odds)  		oddsum += Int32.Parse (c.ToString ());  	int checksum = 10 - ((oddsum + evensum) % 10);  	PreEncoded += checksum.ToString ();  }  
Magic Number,BarcodeLib.Symbologies,MSI,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: for (int i = PreEncoded.Length - 1; i >= 0; i -= 2) {  	odds = PreEncoded [i].ToString () + odds;  	if (i - 1 >= 0)  		evens = PreEncoded [i - 1].ToString () + evens;  }  
Magic Number,BarcodeLib.Symbologies,MSI,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: i -= 2
Magic Number,BarcodeLib.Symbologies,MSI,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: odds = Convert.ToString ((Int32.Parse (odds) * 2));  
Magic Number,BarcodeLib.Symbologies,Postnet,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Postnet.cs,Encode_Postnet,The following statement contains a magic number: switch (Raw_Data.Length) {  case 5:  case 6:  case 9:  case 11:  	break;  default:  	Error ("EPOSTNET-2: Invalid data length. (5' 6' 9' or 11 digits only)");  	break;  }  
Magic Number,BarcodeLib.Symbologies,Postnet,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Postnet.cs,Encode_Postnet,The following statement contains a magic number: switch (Raw_Data.Length) {  case 5:  case 6:  case 9:  case 11:  	break;  default:  	Error ("EPOSTNET-2: Invalid data length. (5' 6' 9' or 11 digits only)");  	break;  }  
Magic Number,BarcodeLib.Symbologies,Postnet,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Postnet.cs,Encode_Postnet,The following statement contains a magic number: switch (Raw_Data.Length) {  case 5:  case 6:  case 9:  case 11:  	break;  default:  	Error ("EPOSTNET-2: Invalid data length. (5' 6' 9' or 11 digits only)");  	break;  }  
Magic Number,BarcodeLib.Symbologies,Postnet,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\Postnet.cs,Encode_Postnet,The following statement contains a magic number: switch (Raw_Data.Length) {  case 5:  case 6:  case 9:  case 11:  	break;  default:  	Error ("EPOSTNET-2: Invalid data length. (5' 6' 9' or 11 digits only)");  	break;  }  
Magic Number,BarcodeLib.Symbologies,UPCA,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCA.cs,Encode_UPCA,The following statement contains a magic number: if (Raw_Data.Length != 11 && Raw_Data.Length != 12)  	Error ("EUPCA-1: Data length invalid. (Length must be 11 or 12)");  
Magic Number,BarcodeLib.Symbologies,UPCA,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCA.cs,Encode_UPCA,The following statement contains a magic number: if (Raw_Data.Length != 11 && Raw_Data.Length != 12)  	Error ("EUPCA-1: Data length invalid. (Length must be 11 or 12)");  
Magic Number,BarcodeLib.Symbologies,UPCA,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCA.cs,Encode_UPCA,The following statement contains a magic number: while (pos < 5) {  	result += UPC_CodeA [Int32.Parse (Raw_Data [pos + 1].ToString ())];  	pos++;  }  
Magic Number,BarcodeLib.Symbologies,UPCA,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCA.cs,Encode_UPCA,The following statement contains a magic number: while (pos < 5) {  	result += UPC_CodeB [Int32.Parse (Raw_Data [(pos++) + 6].ToString ())];  }  
Magic Number,BarcodeLib.Symbologies,UPCA,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCA.cs,Encode_UPCA,The following statement contains a magic number: while (pos < 5) {  	result += UPC_CodeB [Int32.Parse (Raw_Data [(pos++) + 6].ToString ())];  }  
Magic Number,BarcodeLib.Symbologies,UPCA,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCA.cs,Encode_UPCA,The following statement contains a magic number: result += UPC_CodeB [Int32.Parse (Raw_Data [(pos++) + 6].ToString ())];  
Magic Number,BarcodeLib.Symbologies,UPCA,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCA.cs,CheckDigit,The following statement contains a magic number: try {  	string RawDataHolder = Raw_Data.Substring (0' 11);  	//calculate check digit  	int even = 0;  	int odd = 0;  	for (int i = 0; i < RawDataHolder.Length; i++) {  		if (i % 2 == 0)  			odd += Int32.Parse (RawDataHolder.Substring (i' 1)) * 3;  		else  			even += Int32.Parse (RawDataHolder.Substring (i' 1));  	}  	//for  	int total = even + odd;  	int cs = total % 10;  	cs = 10 - cs;  	if (cs == 10)  		cs = 0;  	Raw_Data = RawDataHolder + cs.ToString () [0];  } //try  catch {  	Error ("EUPCA-4: Error calculating check digit.");  }  
Magic Number,BarcodeLib.Symbologies,UPCA,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCA.cs,CheckDigit,The following statement contains a magic number: try {  	string RawDataHolder = Raw_Data.Substring (0' 11);  	//calculate check digit  	int even = 0;  	int odd = 0;  	for (int i = 0; i < RawDataHolder.Length; i++) {  		if (i % 2 == 0)  			odd += Int32.Parse (RawDataHolder.Substring (i' 1)) * 3;  		else  			even += Int32.Parse (RawDataHolder.Substring (i' 1));  	}  	//for  	int total = even + odd;  	int cs = total % 10;  	cs = 10 - cs;  	if (cs == 10)  		cs = 0;  	Raw_Data = RawDataHolder + cs.ToString () [0];  } //try  catch {  	Error ("EUPCA-4: Error calculating check digit.");  }  
Magic Number,BarcodeLib.Symbologies,UPCA,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCA.cs,CheckDigit,The following statement contains a magic number: try {  	string RawDataHolder = Raw_Data.Substring (0' 11);  	//calculate check digit  	int even = 0;  	int odd = 0;  	for (int i = 0; i < RawDataHolder.Length; i++) {  		if (i % 2 == 0)  			odd += Int32.Parse (RawDataHolder.Substring (i' 1)) * 3;  		else  			even += Int32.Parse (RawDataHolder.Substring (i' 1));  	}  	//for  	int total = even + odd;  	int cs = total % 10;  	cs = 10 - cs;  	if (cs == 10)  		cs = 0;  	Raw_Data = RawDataHolder + cs.ToString () [0];  } //try  catch {  	Error ("EUPCA-4: Error calculating check digit.");  }  
Magic Number,BarcodeLib.Symbologies,UPCA,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCA.cs,CheckDigit,The following statement contains a magic number: try {  	string RawDataHolder = Raw_Data.Substring (0' 11);  	//calculate check digit  	int even = 0;  	int odd = 0;  	for (int i = 0; i < RawDataHolder.Length; i++) {  		if (i % 2 == 0)  			odd += Int32.Parse (RawDataHolder.Substring (i' 1)) * 3;  		else  			even += Int32.Parse (RawDataHolder.Substring (i' 1));  	}  	//for  	int total = even + odd;  	int cs = total % 10;  	cs = 10 - cs;  	if (cs == 10)  		cs = 0;  	Raw_Data = RawDataHolder + cs.ToString () [0];  } //try  catch {  	Error ("EUPCA-4: Error calculating check digit.");  }  
Magic Number,BarcodeLib.Symbologies,UPCA,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCA.cs,CheckDigit,The following statement contains a magic number: try {  	string RawDataHolder = Raw_Data.Substring (0' 11);  	//calculate check digit  	int even = 0;  	int odd = 0;  	for (int i = 0; i < RawDataHolder.Length; i++) {  		if (i % 2 == 0)  			odd += Int32.Parse (RawDataHolder.Substring (i' 1)) * 3;  		else  			even += Int32.Parse (RawDataHolder.Substring (i' 1));  	}  	//for  	int total = even + odd;  	int cs = total % 10;  	cs = 10 - cs;  	if (cs == 10)  		cs = 0;  	Raw_Data = RawDataHolder + cs.ToString () [0];  } //try  catch {  	Error ("EUPCA-4: Error calculating check digit.");  }  
Magic Number,BarcodeLib.Symbologies,UPCA,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCA.cs,CheckDigit,The following statement contains a magic number: try {  	string RawDataHolder = Raw_Data.Substring (0' 11);  	//calculate check digit  	int even = 0;  	int odd = 0;  	for (int i = 0; i < RawDataHolder.Length; i++) {  		if (i % 2 == 0)  			odd += Int32.Parse (RawDataHolder.Substring (i' 1)) * 3;  		else  			even += Int32.Parse (RawDataHolder.Substring (i' 1));  	}  	//for  	int total = even + odd;  	int cs = total % 10;  	cs = 10 - cs;  	if (cs == 10)  		cs = 0;  	Raw_Data = RawDataHolder + cs.ToString () [0];  } //try  catch {  	Error ("EUPCA-4: Error calculating check digit.");  }  
Magic Number,BarcodeLib.Symbologies,UPCA,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCA.cs,CheckDigit,The following statement contains a magic number: for (int i = 0; i < RawDataHolder.Length; i++) {  	if (i % 2 == 0)  		odd += Int32.Parse (RawDataHolder.Substring (i' 1)) * 3;  	else  		even += Int32.Parse (RawDataHolder.Substring (i' 1));  }  
Magic Number,BarcodeLib.Symbologies,UPCA,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCA.cs,CheckDigit,The following statement contains a magic number: for (int i = 0; i < RawDataHolder.Length; i++) {  	if (i % 2 == 0)  		odd += Int32.Parse (RawDataHolder.Substring (i' 1)) * 3;  	else  		even += Int32.Parse (RawDataHolder.Substring (i' 1));  }  
Magic Number,BarcodeLib.Symbologies,UPCA,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCA.cs,CheckDigit,The following statement contains a magic number: if (i % 2 == 0)  	odd += Int32.Parse (RawDataHolder.Substring (i' 1)) * 3;  else  	even += Int32.Parse (RawDataHolder.Substring (i' 1));  
Magic Number,BarcodeLib.Symbologies,UPCA,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCA.cs,CheckDigit,The following statement contains a magic number: if (i % 2 == 0)  	odd += Int32.Parse (RawDataHolder.Substring (i' 1)) * 3;  else  	even += Int32.Parse (RawDataHolder.Substring (i' 1));  
Magic Number,BarcodeLib.Symbologies,UPCA,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCA.cs,CheckDigit,The following statement contains a magic number: odd += Int32.Parse (RawDataHolder.Substring (i' 1)) * 3;  
Magic Number,BarcodeLib.Symbologies,UPCA,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCA.cs,CheckDigit,The following statement contains a magic number: cs = 10 - cs;  
Magic Number,BarcodeLib.Symbologies,UPCA,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCA.cs,CheckDigit,The following statement contains a magic number: if (cs == 10)  	cs = 0;  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Raw_Data.Length != 6 && Raw_Data.Length != 8 && Raw_Data.Length != 12)  	Error ("EUPCE-1: Invalid data length. (8 or 12 numbers only)");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Raw_Data.Length != 6 && Raw_Data.Length != 8 && Raw_Data.Length != 12)  	Error ("EUPCE-1: Invalid data length. (8 or 12 numbers only)");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Raw_Data.Length != 6 && Raw_Data.Length != 8 && Raw_Data.Length != 12)  	Error ("EUPCE-1: Invalid data length. (8 or 12 numbers only)");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Raw_Data.Length == 12) {  	string UPCECode = "";  	//break apart into components  	string Manufacturer = Raw_Data.Substring (1' 5);  	string ProductCode = Raw_Data.Substring (6' 5);  	if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  		//rule 1  		UPCECode += Manufacturer.Substring (0' 2);  		//first two of manufacturer  		UPCECode += ProductCode.Substring (2' 3);  		//last three of product  		UPCECode += Manufacturer [2].ToString ();  		//third of manufacturer  	} //if  	else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  		//rule 2  		UPCECode += Manufacturer.Substring (0' 3);  		//first three of manufacturer  		UPCECode += ProductCode.Substring (3' 2);  		//last two of product  		UPCECode += "3";  		//number 3  	} //else if  	else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  		//rule 3  		UPCECode += Manufacturer.Substring (0' 4);  		//first four of manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  		UPCECode += "4";  		//number 4  	} //else if  	else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  		//rule 4  		UPCECode += Manufacturer;  		//manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  	} //else if  	else  		Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  	Raw_Data = UPCECode;  }  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Raw_Data.Length == 12) {  	string UPCECode = "";  	//break apart into components  	string Manufacturer = Raw_Data.Substring (1' 5);  	string ProductCode = Raw_Data.Substring (6' 5);  	if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  		//rule 1  		UPCECode += Manufacturer.Substring (0' 2);  		//first two of manufacturer  		UPCECode += ProductCode.Substring (2' 3);  		//last three of product  		UPCECode += Manufacturer [2].ToString ();  		//third of manufacturer  	} //if  	else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  		//rule 2  		UPCECode += Manufacturer.Substring (0' 3);  		//first three of manufacturer  		UPCECode += ProductCode.Substring (3' 2);  		//last two of product  		UPCECode += "3";  		//number 3  	} //else if  	else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  		//rule 3  		UPCECode += Manufacturer.Substring (0' 4);  		//first four of manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  		UPCECode += "4";  		//number 4  	} //else if  	else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  		//rule 4  		UPCECode += Manufacturer;  		//manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  	} //else if  	else  		Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  	Raw_Data = UPCECode;  }  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Raw_Data.Length == 12) {  	string UPCECode = "";  	//break apart into components  	string Manufacturer = Raw_Data.Substring (1' 5);  	string ProductCode = Raw_Data.Substring (6' 5);  	if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  		//rule 1  		UPCECode += Manufacturer.Substring (0' 2);  		//first two of manufacturer  		UPCECode += ProductCode.Substring (2' 3);  		//last three of product  		UPCECode += Manufacturer [2].ToString ();  		//third of manufacturer  	} //if  	else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  		//rule 2  		UPCECode += Manufacturer.Substring (0' 3);  		//first three of manufacturer  		UPCECode += ProductCode.Substring (3' 2);  		//last two of product  		UPCECode += "3";  		//number 3  	} //else if  	else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  		//rule 3  		UPCECode += Manufacturer.Substring (0' 4);  		//first four of manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  		UPCECode += "4";  		//number 4  	} //else if  	else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  		//rule 4  		UPCECode += Manufacturer;  		//manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  	} //else if  	else  		Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  	Raw_Data = UPCECode;  }  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Raw_Data.Length == 12) {  	string UPCECode = "";  	//break apart into components  	string Manufacturer = Raw_Data.Substring (1' 5);  	string ProductCode = Raw_Data.Substring (6' 5);  	if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  		//rule 1  		UPCECode += Manufacturer.Substring (0' 2);  		//first two of manufacturer  		UPCECode += ProductCode.Substring (2' 3);  		//last three of product  		UPCECode += Manufacturer [2].ToString ();  		//third of manufacturer  	} //if  	else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  		//rule 2  		UPCECode += Manufacturer.Substring (0' 3);  		//first three of manufacturer  		UPCECode += ProductCode.Substring (3' 2);  		//last two of product  		UPCECode += "3";  		//number 3  	} //else if  	else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  		//rule 3  		UPCECode += Manufacturer.Substring (0' 4);  		//first four of manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  		UPCECode += "4";  		//number 4  	} //else if  	else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  		//rule 4  		UPCECode += Manufacturer;  		//manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  	} //else if  	else  		Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  	Raw_Data = UPCECode;  }  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Raw_Data.Length == 12) {  	string UPCECode = "";  	//break apart into components  	string Manufacturer = Raw_Data.Substring (1' 5);  	string ProductCode = Raw_Data.Substring (6' 5);  	if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  		//rule 1  		UPCECode += Manufacturer.Substring (0' 2);  		//first two of manufacturer  		UPCECode += ProductCode.Substring (2' 3);  		//last three of product  		UPCECode += Manufacturer [2].ToString ();  		//third of manufacturer  	} //if  	else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  		//rule 2  		UPCECode += Manufacturer.Substring (0' 3);  		//first three of manufacturer  		UPCECode += ProductCode.Substring (3' 2);  		//last two of product  		UPCECode += "3";  		//number 3  	} //else if  	else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  		//rule 3  		UPCECode += Manufacturer.Substring (0' 4);  		//first four of manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  		UPCECode += "4";  		//number 4  	} //else if  	else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  		//rule 4  		UPCECode += Manufacturer;  		//manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  	} //else if  	else  		Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  	Raw_Data = UPCECode;  }  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Raw_Data.Length == 12) {  	string UPCECode = "";  	//break apart into components  	string Manufacturer = Raw_Data.Substring (1' 5);  	string ProductCode = Raw_Data.Substring (6' 5);  	if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  		//rule 1  		UPCECode += Manufacturer.Substring (0' 2);  		//first two of manufacturer  		UPCECode += ProductCode.Substring (2' 3);  		//last three of product  		UPCECode += Manufacturer [2].ToString ();  		//third of manufacturer  	} //if  	else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  		//rule 2  		UPCECode += Manufacturer.Substring (0' 3);  		//first three of manufacturer  		UPCECode += ProductCode.Substring (3' 2);  		//last two of product  		UPCECode += "3";  		//number 3  	} //else if  	else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  		//rule 3  		UPCECode += Manufacturer.Substring (0' 4);  		//first four of manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  		UPCECode += "4";  		//number 4  	} //else if  	else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  		//rule 4  		UPCECode += Manufacturer;  		//manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  	} //else if  	else  		Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  	Raw_Data = UPCECode;  }  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Raw_Data.Length == 12) {  	string UPCECode = "";  	//break apart into components  	string Manufacturer = Raw_Data.Substring (1' 5);  	string ProductCode = Raw_Data.Substring (6' 5);  	if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  		//rule 1  		UPCECode += Manufacturer.Substring (0' 2);  		//first two of manufacturer  		UPCECode += ProductCode.Substring (2' 3);  		//last three of product  		UPCECode += Manufacturer [2].ToString ();  		//third of manufacturer  	} //if  	else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  		//rule 2  		UPCECode += Manufacturer.Substring (0' 3);  		//first three of manufacturer  		UPCECode += ProductCode.Substring (3' 2);  		//last two of product  		UPCECode += "3";  		//number 3  	} //else if  	else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  		//rule 3  		UPCECode += Manufacturer.Substring (0' 4);  		//first four of manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  		UPCECode += "4";  		//number 4  	} //else if  	else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  		//rule 4  		UPCECode += Manufacturer;  		//manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  	} //else if  	else  		Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  	Raw_Data = UPCECode;  }  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Raw_Data.Length == 12) {  	string UPCECode = "";  	//break apart into components  	string Manufacturer = Raw_Data.Substring (1' 5);  	string ProductCode = Raw_Data.Substring (6' 5);  	if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  		//rule 1  		UPCECode += Manufacturer.Substring (0' 2);  		//first two of manufacturer  		UPCECode += ProductCode.Substring (2' 3);  		//last three of product  		UPCECode += Manufacturer [2].ToString ();  		//third of manufacturer  	} //if  	else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  		//rule 2  		UPCECode += Manufacturer.Substring (0' 3);  		//first three of manufacturer  		UPCECode += ProductCode.Substring (3' 2);  		//last two of product  		UPCECode += "3";  		//number 3  	} //else if  	else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  		//rule 3  		UPCECode += Manufacturer.Substring (0' 4);  		//first four of manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  		UPCECode += "4";  		//number 4  	} //else if  	else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  		//rule 4  		UPCECode += Manufacturer;  		//manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  	} //else if  	else  		Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  	Raw_Data = UPCECode;  }  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Raw_Data.Length == 12) {  	string UPCECode = "";  	//break apart into components  	string Manufacturer = Raw_Data.Substring (1' 5);  	string ProductCode = Raw_Data.Substring (6' 5);  	if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  		//rule 1  		UPCECode += Manufacturer.Substring (0' 2);  		//first two of manufacturer  		UPCECode += ProductCode.Substring (2' 3);  		//last three of product  		UPCECode += Manufacturer [2].ToString ();  		//third of manufacturer  	} //if  	else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  		//rule 2  		UPCECode += Manufacturer.Substring (0' 3);  		//first three of manufacturer  		UPCECode += ProductCode.Substring (3' 2);  		//last two of product  		UPCECode += "3";  		//number 3  	} //else if  	else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  		//rule 3  		UPCECode += Manufacturer.Substring (0' 4);  		//first four of manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  		UPCECode += "4";  		//number 4  	} //else if  	else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  		//rule 4  		UPCECode += Manufacturer;  		//manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  	} //else if  	else  		Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  	Raw_Data = UPCECode;  }  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Raw_Data.Length == 12) {  	string UPCECode = "";  	//break apart into components  	string Manufacturer = Raw_Data.Substring (1' 5);  	string ProductCode = Raw_Data.Substring (6' 5);  	if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  		//rule 1  		UPCECode += Manufacturer.Substring (0' 2);  		//first two of manufacturer  		UPCECode += ProductCode.Substring (2' 3);  		//last three of product  		UPCECode += Manufacturer [2].ToString ();  		//third of manufacturer  	} //if  	else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  		//rule 2  		UPCECode += Manufacturer.Substring (0' 3);  		//first three of manufacturer  		UPCECode += ProductCode.Substring (3' 2);  		//last two of product  		UPCECode += "3";  		//number 3  	} //else if  	else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  		//rule 3  		UPCECode += Manufacturer.Substring (0' 4);  		//first four of manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  		UPCECode += "4";  		//number 4  	} //else if  	else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  		//rule 4  		UPCECode += Manufacturer;  		//manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  	} //else if  	else  		Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  	Raw_Data = UPCECode;  }  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Raw_Data.Length == 12) {  	string UPCECode = "";  	//break apart into components  	string Manufacturer = Raw_Data.Substring (1' 5);  	string ProductCode = Raw_Data.Substring (6' 5);  	if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  		//rule 1  		UPCECode += Manufacturer.Substring (0' 2);  		//first two of manufacturer  		UPCECode += ProductCode.Substring (2' 3);  		//last three of product  		UPCECode += Manufacturer [2].ToString ();  		//third of manufacturer  	} //if  	else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  		//rule 2  		UPCECode += Manufacturer.Substring (0' 3);  		//first three of manufacturer  		UPCECode += ProductCode.Substring (3' 2);  		//last two of product  		UPCECode += "3";  		//number 3  	} //else if  	else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  		//rule 3  		UPCECode += Manufacturer.Substring (0' 4);  		//first four of manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  		UPCECode += "4";  		//number 4  	} //else if  	else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  		//rule 4  		UPCECode += Manufacturer;  		//manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  	} //else if  	else  		Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  	Raw_Data = UPCECode;  }  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Raw_Data.Length == 12) {  	string UPCECode = "";  	//break apart into components  	string Manufacturer = Raw_Data.Substring (1' 5);  	string ProductCode = Raw_Data.Substring (6' 5);  	if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  		//rule 1  		UPCECode += Manufacturer.Substring (0' 2);  		//first two of manufacturer  		UPCECode += ProductCode.Substring (2' 3);  		//last three of product  		UPCECode += Manufacturer [2].ToString ();  		//third of manufacturer  	} //if  	else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  		//rule 2  		UPCECode += Manufacturer.Substring (0' 3);  		//first three of manufacturer  		UPCECode += ProductCode.Substring (3' 2);  		//last two of product  		UPCECode += "3";  		//number 3  	} //else if  	else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  		//rule 3  		UPCECode += Manufacturer.Substring (0' 4);  		//first four of manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  		UPCECode += "4";  		//number 4  	} //else if  	else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  		//rule 4  		UPCECode += Manufacturer;  		//manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  	} //else if  	else  		Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  	Raw_Data = UPCECode;  }  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Raw_Data.Length == 12) {  	string UPCECode = "";  	//break apart into components  	string Manufacturer = Raw_Data.Substring (1' 5);  	string ProductCode = Raw_Data.Substring (6' 5);  	if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  		//rule 1  		UPCECode += Manufacturer.Substring (0' 2);  		//first two of manufacturer  		UPCECode += ProductCode.Substring (2' 3);  		//last three of product  		UPCECode += Manufacturer [2].ToString ();  		//third of manufacturer  	} //if  	else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  		//rule 2  		UPCECode += Manufacturer.Substring (0' 3);  		//first three of manufacturer  		UPCECode += ProductCode.Substring (3' 2);  		//last two of product  		UPCECode += "3";  		//number 3  	} //else if  	else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  		//rule 3  		UPCECode += Manufacturer.Substring (0' 4);  		//first four of manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  		UPCECode += "4";  		//number 4  	} //else if  	else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  		//rule 4  		UPCECode += Manufacturer;  		//manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  	} //else if  	else  		Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  	Raw_Data = UPCECode;  }  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Raw_Data.Length == 12) {  	string UPCECode = "";  	//break apart into components  	string Manufacturer = Raw_Data.Substring (1' 5);  	string ProductCode = Raw_Data.Substring (6' 5);  	if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  		//rule 1  		UPCECode += Manufacturer.Substring (0' 2);  		//first two of manufacturer  		UPCECode += ProductCode.Substring (2' 3);  		//last three of product  		UPCECode += Manufacturer [2].ToString ();  		//third of manufacturer  	} //if  	else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  		//rule 2  		UPCECode += Manufacturer.Substring (0' 3);  		//first three of manufacturer  		UPCECode += ProductCode.Substring (3' 2);  		//last two of product  		UPCECode += "3";  		//number 3  	} //else if  	else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  		//rule 3  		UPCECode += Manufacturer.Substring (0' 4);  		//first four of manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  		UPCECode += "4";  		//number 4  	} //else if  	else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  		//rule 4  		UPCECode += Manufacturer;  		//manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  	} //else if  	else  		Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  	Raw_Data = UPCECode;  }  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Raw_Data.Length == 12) {  	string UPCECode = "";  	//break apart into components  	string Manufacturer = Raw_Data.Substring (1' 5);  	string ProductCode = Raw_Data.Substring (6' 5);  	if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  		//rule 1  		UPCECode += Manufacturer.Substring (0' 2);  		//first two of manufacturer  		UPCECode += ProductCode.Substring (2' 3);  		//last three of product  		UPCECode += Manufacturer [2].ToString ();  		//third of manufacturer  	} //if  	else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  		//rule 2  		UPCECode += Manufacturer.Substring (0' 3);  		//first three of manufacturer  		UPCECode += ProductCode.Substring (3' 2);  		//last two of product  		UPCECode += "3";  		//number 3  	} //else if  	else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  		//rule 3  		UPCECode += Manufacturer.Substring (0' 4);  		//first four of manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  		UPCECode += "4";  		//number 4  	} //else if  	else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  		//rule 4  		UPCECode += Manufacturer;  		//manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  	} //else if  	else  		Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  	Raw_Data = UPCECode;  }  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Raw_Data.Length == 12) {  	string UPCECode = "";  	//break apart into components  	string Manufacturer = Raw_Data.Substring (1' 5);  	string ProductCode = Raw_Data.Substring (6' 5);  	if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  		//rule 1  		UPCECode += Manufacturer.Substring (0' 2);  		//first two of manufacturer  		UPCECode += ProductCode.Substring (2' 3);  		//last three of product  		UPCECode += Manufacturer [2].ToString ();  		//third of manufacturer  	} //if  	else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  		//rule 2  		UPCECode += Manufacturer.Substring (0' 3);  		//first three of manufacturer  		UPCECode += ProductCode.Substring (3' 2);  		//last two of product  		UPCECode += "3";  		//number 3  	} //else if  	else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  		//rule 3  		UPCECode += Manufacturer.Substring (0' 4);  		//first four of manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  		UPCECode += "4";  		//number 4  	} //else if  	else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  		//rule 4  		UPCECode += Manufacturer;  		//manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  	} //else if  	else  		Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  	Raw_Data = UPCECode;  }  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Raw_Data.Length == 12) {  	string UPCECode = "";  	//break apart into components  	string Manufacturer = Raw_Data.Substring (1' 5);  	string ProductCode = Raw_Data.Substring (6' 5);  	if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  		//rule 1  		UPCECode += Manufacturer.Substring (0' 2);  		//first two of manufacturer  		UPCECode += ProductCode.Substring (2' 3);  		//last three of product  		UPCECode += Manufacturer [2].ToString ();  		//third of manufacturer  	} //if  	else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  		//rule 2  		UPCECode += Manufacturer.Substring (0' 3);  		//first three of manufacturer  		UPCECode += ProductCode.Substring (3' 2);  		//last two of product  		UPCECode += "3";  		//number 3  	} //else if  	else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  		//rule 3  		UPCECode += Manufacturer.Substring (0' 4);  		//first four of manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  		UPCECode += "4";  		//number 4  	} //else if  	else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  		//rule 4  		UPCECode += Manufacturer;  		//manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  	} //else if  	else  		Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  	Raw_Data = UPCECode;  }  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Raw_Data.Length == 12) {  	string UPCECode = "";  	//break apart into components  	string Manufacturer = Raw_Data.Substring (1' 5);  	string ProductCode = Raw_Data.Substring (6' 5);  	if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  		//rule 1  		UPCECode += Manufacturer.Substring (0' 2);  		//first two of manufacturer  		UPCECode += ProductCode.Substring (2' 3);  		//last three of product  		UPCECode += Manufacturer [2].ToString ();  		//third of manufacturer  	} //if  	else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  		//rule 2  		UPCECode += Manufacturer.Substring (0' 3);  		//first three of manufacturer  		UPCECode += ProductCode.Substring (3' 2);  		//last two of product  		UPCECode += "3";  		//number 3  	} //else if  	else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  		//rule 3  		UPCECode += Manufacturer.Substring (0' 4);  		//first four of manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  		UPCECode += "4";  		//number 4  	} //else if  	else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  		//rule 4  		UPCECode += Manufacturer;  		//manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  	} //else if  	else  		Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  	Raw_Data = UPCECode;  }  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Raw_Data.Length == 12) {  	string UPCECode = "";  	//break apart into components  	string Manufacturer = Raw_Data.Substring (1' 5);  	string ProductCode = Raw_Data.Substring (6' 5);  	if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  		//rule 1  		UPCECode += Manufacturer.Substring (0' 2);  		//first two of manufacturer  		UPCECode += ProductCode.Substring (2' 3);  		//last three of product  		UPCECode += Manufacturer [2].ToString ();  		//third of manufacturer  	} //if  	else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  		//rule 2  		UPCECode += Manufacturer.Substring (0' 3);  		//first three of manufacturer  		UPCECode += ProductCode.Substring (3' 2);  		//last two of product  		UPCECode += "3";  		//number 3  	} //else if  	else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  		//rule 3  		UPCECode += Manufacturer.Substring (0' 4);  		//first four of manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  		UPCECode += "4";  		//number 4  	} //else if  	else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  		//rule 4  		UPCECode += Manufacturer;  		//manufacturer  		UPCECode += ProductCode [4];  		//last digit of product  	} //else if  	else  		Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  	Raw_Data = UPCECode;  }  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  	//rule 1  	UPCECode += Manufacturer.Substring (0' 2);  	//first two of manufacturer  	UPCECode += ProductCode.Substring (2' 3);  	//last three of product  	UPCECode += Manufacturer [2].ToString ();  	//third of manufacturer  } //if  else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  	//rule 2  	UPCECode += Manufacturer.Substring (0' 3);  	//first three of manufacturer  	UPCECode += ProductCode.Substring (3' 2);  	//last two of product  	UPCECode += "3";  	//number 3  } //else if  else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  	//rule 1  	UPCECode += Manufacturer.Substring (0' 2);  	//first two of manufacturer  	UPCECode += ProductCode.Substring (2' 3);  	//last three of product  	UPCECode += Manufacturer [2].ToString ();  	//third of manufacturer  } //if  else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  	//rule 2  	UPCECode += Manufacturer.Substring (0' 3);  	//first three of manufacturer  	UPCECode += ProductCode.Substring (3' 2);  	//last two of product  	UPCECode += "3";  	//number 3  } //else if  else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  	//rule 1  	UPCECode += Manufacturer.Substring (0' 2);  	//first two of manufacturer  	UPCECode += ProductCode.Substring (2' 3);  	//last three of product  	UPCECode += Manufacturer [2].ToString ();  	//third of manufacturer  } //if  else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  	//rule 2  	UPCECode += Manufacturer.Substring (0' 3);  	//first three of manufacturer  	UPCECode += ProductCode.Substring (3' 2);  	//last two of product  	UPCECode += "3";  	//number 3  } //else if  else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  	//rule 1  	UPCECode += Manufacturer.Substring (0' 2);  	//first two of manufacturer  	UPCECode += ProductCode.Substring (2' 3);  	//last three of product  	UPCECode += Manufacturer [2].ToString ();  	//third of manufacturer  } //if  else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  	//rule 2  	UPCECode += Manufacturer.Substring (0' 3);  	//first three of manufacturer  	UPCECode += ProductCode.Substring (3' 2);  	//last two of product  	UPCECode += "3";  	//number 3  } //else if  else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  	//rule 1  	UPCECode += Manufacturer.Substring (0' 2);  	//first two of manufacturer  	UPCECode += ProductCode.Substring (2' 3);  	//last three of product  	UPCECode += Manufacturer [2].ToString ();  	//third of manufacturer  } //if  else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  	//rule 2  	UPCECode += Manufacturer.Substring (0' 3);  	//first three of manufacturer  	UPCECode += ProductCode.Substring (3' 2);  	//last two of product  	UPCECode += "3";  	//number 3  } //else if  else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  	//rule 1  	UPCECode += Manufacturer.Substring (0' 2);  	//first two of manufacturer  	UPCECode += ProductCode.Substring (2' 3);  	//last three of product  	UPCECode += Manufacturer [2].ToString ();  	//third of manufacturer  } //if  else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  	//rule 2  	UPCECode += Manufacturer.Substring (0' 3);  	//first three of manufacturer  	UPCECode += ProductCode.Substring (3' 2);  	//last two of product  	UPCECode += "3";  	//number 3  } //else if  else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  	//rule 1  	UPCECode += Manufacturer.Substring (0' 2);  	//first two of manufacturer  	UPCECode += ProductCode.Substring (2' 3);  	//last three of product  	UPCECode += Manufacturer [2].ToString ();  	//third of manufacturer  } //if  else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  	//rule 2  	UPCECode += Manufacturer.Substring (0' 3);  	//first three of manufacturer  	UPCECode += ProductCode.Substring (3' 2);  	//last two of product  	UPCECode += "3";  	//number 3  } //else if  else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  	//rule 1  	UPCECode += Manufacturer.Substring (0' 2);  	//first two of manufacturer  	UPCECode += ProductCode.Substring (2' 3);  	//last three of product  	UPCECode += Manufacturer [2].ToString ();  	//third of manufacturer  } //if  else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  	//rule 2  	UPCECode += Manufacturer.Substring (0' 3);  	//first three of manufacturer  	UPCECode += ProductCode.Substring (3' 2);  	//last two of product  	UPCECode += "3";  	//number 3  } //else if  else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  	//rule 1  	UPCECode += Manufacturer.Substring (0' 2);  	//first two of manufacturer  	UPCECode += ProductCode.Substring (2' 3);  	//last three of product  	UPCECode += Manufacturer [2].ToString ();  	//third of manufacturer  } //if  else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  	//rule 2  	UPCECode += Manufacturer.Substring (0' 3);  	//first three of manufacturer  	UPCECode += ProductCode.Substring (3' 2);  	//last two of product  	UPCECode += "3";  	//number 3  } //else if  else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  	//rule 1  	UPCECode += Manufacturer.Substring (0' 2);  	//first two of manufacturer  	UPCECode += ProductCode.Substring (2' 3);  	//last three of product  	UPCECode += Manufacturer [2].ToString ();  	//third of manufacturer  } //if  else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  	//rule 2  	UPCECode += Manufacturer.Substring (0' 3);  	//first three of manufacturer  	UPCECode += ProductCode.Substring (3' 2);  	//last two of product  	UPCECode += "3";  	//number 3  } //else if  else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  	//rule 1  	UPCECode += Manufacturer.Substring (0' 2);  	//first two of manufacturer  	UPCECode += ProductCode.Substring (2' 3);  	//last three of product  	UPCECode += Manufacturer [2].ToString ();  	//third of manufacturer  } //if  else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  	//rule 2  	UPCECode += Manufacturer.Substring (0' 3);  	//first three of manufacturer  	UPCECode += ProductCode.Substring (3' 2);  	//last two of product  	UPCECode += "3";  	//number 3  } //else if  else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  	//rule 1  	UPCECode += Manufacturer.Substring (0' 2);  	//first two of manufacturer  	UPCECode += ProductCode.Substring (2' 3);  	//last three of product  	UPCECode += Manufacturer [2].ToString ();  	//third of manufacturer  } //if  else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  	//rule 2  	UPCECode += Manufacturer.Substring (0' 3);  	//first three of manufacturer  	UPCECode += ProductCode.Substring (3' 2);  	//last two of product  	UPCECode += "3";  	//number 3  } //else if  else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  	//rule 1  	UPCECode += Manufacturer.Substring (0' 2);  	//first two of manufacturer  	UPCECode += ProductCode.Substring (2' 3);  	//last three of product  	UPCECode += Manufacturer [2].ToString ();  	//third of manufacturer  } //if  else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  	//rule 2  	UPCECode += Manufacturer.Substring (0' 3);  	//first three of manufacturer  	UPCECode += ProductCode.Substring (3' 2);  	//last two of product  	UPCECode += "3";  	//number 3  } //else if  else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  	//rule 1  	UPCECode += Manufacturer.Substring (0' 2);  	//first two of manufacturer  	UPCECode += ProductCode.Substring (2' 3);  	//last three of product  	UPCECode += Manufacturer [2].ToString ();  	//third of manufacturer  } //if  else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  	//rule 2  	UPCECode += Manufacturer.Substring (0' 3);  	//first three of manufacturer  	UPCECode += ProductCode.Substring (3' 2);  	//last two of product  	UPCECode += "3";  	//number 3  } //else if  else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("000") || Manufacturer.EndsWith ("100") || Manufacturer.EndsWith ("200") && Int32.Parse (ProductCode) <= 999) {  	//rule 1  	UPCECode += Manufacturer.Substring (0' 2);  	//first two of manufacturer  	UPCECode += ProductCode.Substring (2' 3);  	//last three of product  	UPCECode += Manufacturer [2].ToString ();  	//third of manufacturer  } //if  else if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  	//rule 2  	UPCECode += Manufacturer.Substring (0' 3);  	//first three of manufacturer  	UPCECode += ProductCode.Substring (3' 2);  	//last two of product  	UPCECode += "3";  	//number 3  } //else if  else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: UPCECode += Manufacturer.Substring (0' 2);  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: UPCECode += ProductCode.Substring (2' 3);  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: UPCECode += ProductCode.Substring (2' 3);  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: UPCECode += Manufacturer [2].ToString ();  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  	//rule 2  	UPCECode += Manufacturer.Substring (0' 3);  	//first three of manufacturer  	UPCECode += ProductCode.Substring (3' 2);  	//last two of product  	UPCECode += "3";  	//number 3  } //else if  else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  	//rule 2  	UPCECode += Manufacturer.Substring (0' 3);  	//first three of manufacturer  	UPCECode += ProductCode.Substring (3' 2);  	//last two of product  	UPCECode += "3";  	//number 3  } //else if  else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  	//rule 2  	UPCECode += Manufacturer.Substring (0' 3);  	//first three of manufacturer  	UPCECode += ProductCode.Substring (3' 2);  	//last two of product  	UPCECode += "3";  	//number 3  } //else if  else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  	//rule 2  	UPCECode += Manufacturer.Substring (0' 3);  	//first three of manufacturer  	UPCECode += ProductCode.Substring (3' 2);  	//last two of product  	UPCECode += "3";  	//number 3  } //else if  else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  	//rule 2  	UPCECode += Manufacturer.Substring (0' 3);  	//first three of manufacturer  	UPCECode += ProductCode.Substring (3' 2);  	//last two of product  	UPCECode += "3";  	//number 3  } //else if  else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  	//rule 2  	UPCECode += Manufacturer.Substring (0' 3);  	//first three of manufacturer  	UPCECode += ProductCode.Substring (3' 2);  	//last two of product  	UPCECode += "3";  	//number 3  } //else if  else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  	//rule 2  	UPCECode += Manufacturer.Substring (0' 3);  	//first three of manufacturer  	UPCECode += ProductCode.Substring (3' 2);  	//last two of product  	UPCECode += "3";  	//number 3  } //else if  else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  	//rule 2  	UPCECode += Manufacturer.Substring (0' 3);  	//first three of manufacturer  	UPCECode += ProductCode.Substring (3' 2);  	//last two of product  	UPCECode += "3";  	//number 3  } //else if  else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  	//rule 2  	UPCECode += Manufacturer.Substring (0' 3);  	//first three of manufacturer  	UPCECode += ProductCode.Substring (3' 2);  	//last two of product  	UPCECode += "3";  	//number 3  } //else if  else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("00") && Int32.Parse (ProductCode) <= 99) {  	//rule 2  	UPCECode += Manufacturer.Substring (0' 3);  	//first three of manufacturer  	UPCECode += ProductCode.Substring (3' 2);  	//last two of product  	UPCECode += "3";  	//number 3  } //else if  else if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: UPCECode += Manufacturer.Substring (0' 3);  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: UPCECode += ProductCode.Substring (3' 2);  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: UPCECode += ProductCode.Substring (3' 2);  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9) {  	//rule 3  	UPCECode += Manufacturer.Substring (0' 4);  	//first four of manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  	UPCECode += "4";  	//number 4  } //else if  else if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: UPCECode += Manufacturer.Substring (0' 4);  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: UPCECode += ProductCode [4];  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: if (!Manufacturer.EndsWith ("0") && Int32.Parse (ProductCode) <= 9 && Int32.Parse (ProductCode) >= 5) {  	//rule 4  	UPCECode += Manufacturer;  	//manufacturer  	UPCECode += ProductCode [4];  	//last digit of product  } //else if  else  	Error ("EUPCE-4: Illegal UPC-A entered for conversion.  Unable to convert.");  
Magic Number,BarcodeLib.Symbologies,UPCE,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: UPCECode += ProductCode [4];  
Magic Number,BarcodeLib.Symbologies,UPCSupplement2,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCSupplement2.cs,Encode_UPCSupplemental_2,The following statement contains a magic number: if (Raw_Data.Length != 2)  	Error ("EUPC-SUP2-1: Invalid data length. (Length = 2 required)");  
Magic Number,BarcodeLib.Symbologies,UPCSupplement2,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCSupplement2.cs,Encode_UPCSupplemental_2,The following statement contains a magic number: try {  	pattern = this.UPC_SUPP_2 [Int32.Parse (Raw_Data.Trim ()) % 4];  } //try  catch {  	Error ("EUPC-SUP2-3: Invalid Data. (Numeric only)");  }  
Magic Number,BarcodeLib.Symbologies,UPCSupplement2,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCSupplement2.cs,Encode_UPCSupplemental_2,The following statement contains a magic number: pattern = this.UPC_SUPP_2 [Int32.Parse (Raw_Data.Trim ()) % 4];  
Magic Number,BarcodeLib.Symbologies,UPCSupplement5,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCSupplement5.cs,Encode_UPCSupplemental_5,The following statement contains a magic number: if (Raw_Data.Length != 5)  	Error ("EUPC-SUP5-1: Invalid data length. (Length = 5 required)");  
Magic Number,BarcodeLib.Symbologies,UPCSupplement5,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCSupplement5.cs,Encode_UPCSupplemental_5,The following statement contains a magic number: for (int i = 0; i <= 4; i += 2) {  	odd += Int32.Parse (Raw_Data.Substring (i' 1)) * 3;  }  
Magic Number,BarcodeLib.Symbologies,UPCSupplement5,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCSupplement5.cs,Encode_UPCSupplemental_5,The following statement contains a magic number: for (int i = 0; i <= 4; i += 2) {  	odd += Int32.Parse (Raw_Data.Substring (i' 1)) * 3;  }  
Magic Number,BarcodeLib.Symbologies,UPCSupplement5,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCSupplement5.cs,Encode_UPCSupplemental_5,The following statement contains a magic number: for (int i = 0; i <= 4; i += 2) {  	odd += Int32.Parse (Raw_Data.Substring (i' 1)) * 3;  }  
Magic Number,BarcodeLib.Symbologies,UPCSupplement5,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCSupplement5.cs,Encode_UPCSupplemental_5,The following statement contains a magic number: i += 2
Magic Number,BarcodeLib.Symbologies,UPCSupplement5,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCSupplement5.cs,Encode_UPCSupplemental_5,The following statement contains a magic number: odd += Int32.Parse (Raw_Data.Substring (i' 1)) * 3;  
Magic Number,BarcodeLib.Symbologies,UPCSupplement5,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCSupplement5.cs,Encode_UPCSupplemental_5,The following statement contains a magic number: for (int i = 1; i < 4; i += 2) {  	even += Int32.Parse (Raw_Data.Substring (i' 1)) * 9;  }  
Magic Number,BarcodeLib.Symbologies,UPCSupplement5,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCSupplement5.cs,Encode_UPCSupplemental_5,The following statement contains a magic number: for (int i = 1; i < 4; i += 2) {  	even += Int32.Parse (Raw_Data.Substring (i' 1)) * 9;  }  
Magic Number,BarcodeLib.Symbologies,UPCSupplement5,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCSupplement5.cs,Encode_UPCSupplemental_5,The following statement contains a magic number: for (int i = 1; i < 4; i += 2) {  	even += Int32.Parse (Raw_Data.Substring (i' 1)) * 9;  }  
Magic Number,BarcodeLib.Symbologies,UPCSupplement5,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCSupplement5.cs,Encode_UPCSupplemental_5,The following statement contains a magic number: i += 2
Magic Number,BarcodeLib.Symbologies,UPCSupplement5,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\UPCSupplement5.cs,Encode_UPCSupplemental_5,The following statement contains a magic number: even += Int32.Parse (Raw_Data.Substring (i' 1)) * 9;  
Duplicate Code,BarcodeLib.Symbologies,MSI,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\Symbologies\MSI.cs,Encode_MSI,The method contains a code clone-set at the following line numbers (starting from the method definition): ((8' 27)' (43' 62))
Missing Default,BarcodeLib,Barcode,F:\newReposMay17\bbarnhill_barcodelib\BarcodeLib\BarcodeLib.cs,Label_Generic,The following switch statement is missing a default case: switch (LabelPosition) {  case LabelPositions.BOTTOMCENTER:  	LabelX = img.Width / 2;  	LabelY = img.Height - (font.Height);  	f.Alignment = StringAlignment.Center;  	break;  case LabelPositions.BOTTOMLEFT:  	LabelX = 0;  	LabelY = img.Height - (font.Height);  	f.Alignment = StringAlignment.Near;  	break;  case LabelPositions.BOTTOMRIGHT:  	LabelX = img.Width;  	LabelY = img.Height - (font.Height);  	f.Alignment = StringAlignment.Far;  	break;  case LabelPositions.TOPCENTER:  	LabelX = img.Width / 2;  	LabelY = 0;  	f.Alignment = StringAlignment.Center;  	break;  case LabelPositions.TOPLEFT:  	LabelX = img.Width;  	LabelY = 0;  	f.Alignment = StringAlignment.Near;  	break;  case LabelPositions.TOPRIGHT:  	LabelX = img.Width;  	LabelY = 0;  	f.Alignment = StringAlignment.Far;  	break;  }  
