Implementation smell,Namespace,Class,File,Method,Description
Long Method,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,GenerateBarcode,The method has 110 lines of code.
Long Method,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The method has 324 lines of code.
Long Method,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The method has 118 lines of code.
Long Method,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The method has 133 lines of code.
Long Method,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The method has 136 lines of code.
Long Method,BarcodeLib.Symbologies,UPCA,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCA.cs,init_CountryCodes,The method has 133 lines of code.
Complex Method,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,GenerateBarcode,Cyclomatic complexity of the method is 30
Complex Method,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,Cyclomatic complexity of the method is 44
Complex Method,BarcodeLib.Symbologies,Codabar,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Codabar.cs,Encode_Codabar,Cyclomatic complexity of the method is 14
Complex Method,BarcodeLib.Symbologies,Code11,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code11.cs,Encode_Code11,Cyclomatic complexity of the method is 10
Complex Method,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,FindStartorCodeCharacter,Cyclomatic complexity of the method is 10
Complex Method,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,BreakUpDataForEncoding,Cyclomatic complexity of the method is 13
Complex Method,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,InsertStartandCodeCharacters,Cyclomatic complexity of the method is 10
Complex Method,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,GetEncoding,Cyclomatic complexity of the method is 9
Complex Method,BarcodeLib.Symbologies,Interleaved2of5,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Interleaved2of5.cs,Encode_Interleaved2of5,Cyclomatic complexity of the method is 9
Complex Method,BarcodeLib.Symbologies,ITF14,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\ITF14.cs,Encode_ITF14,Cyclomatic complexity of the method is 9
Complex Method,BarcodeLib.Symbologies,MSI,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\MSI.cs,Encode_MSI,Cyclomatic complexity of the method is 16
Complex Method,BarcodeLib.Symbologies,Pharmacode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Pharmacode.cs,Encode_Pharmacode,Cyclomatic complexity of the method is 9
Complex Method,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,SetEncodingSequence,Cyclomatic complexity of the method is 9
Complex Method,BarcodeLib.Symbologies,UPCE,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCE.cs,Encode_UPCE,Cyclomatic complexity of the method is 13
Complex Method,BarcodeLib.Symbologies,UPCSupplement5,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCSupplement5.cs,Encode_UPCSupplemental_5,Cyclomatic complexity of the method is 9
Long Parameter List,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Encode,The method has 6 parameters. Parameters: iType' StringToEncode' ForeColor' BackColor' Width' Height
Long Parameter List,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,DoEncode,The method has 5 parameters. Parameters: iType' Data' IncludeLabel' Width' Height
Long Parameter List,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,DoEncode,The method has 5 parameters. Parameters: iType' Data' IncludeLabel' DrawColor' BackColor
Long Parameter List,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,DoEncode,The method has 7 parameters. Parameters: iType' Data' IncludeLabel' DrawColor' BackColor' Width' Height
Long Parameter List,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,DoEncode,The method has 8 parameters. Parameters: iType' Data' IncludeLabel' DrawColor' BackColor' Width' Height' XML
Long Identifier,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,,The length of the parameter _Country_Assigning_Manufacturer_Code is 36.
Long Identifier,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,,The length of the parameter _Country_Assigning_Manufacturer_Code is 36.
Long Identifier,BarcodeLib.Symbologies,UPCA,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCA.cs,,The length of the parameter _Country_Assigning_Manufacturer_Code is 36.
Long Statement,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The length of the statement  "                            throw new Exception("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)"); " is 190.
Long Statement,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The length of the statement  "                                        g.DrawLine(pen' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height)); " is 177.
Long Statement,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The length of the statement  "                                Font labFont = new Font(this.LabelFont != null ? this.LabelFont.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular); " is 153.
Long Statement,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The length of the statement  "                            throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)"); " is 141.
Long Statement,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The length of the statement  "                                            g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)); " is 189.
Long Statement,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The length of the statement  "                                Font labFont = new Font(font != null ? font.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular); " is 133.
Long Statement,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The length of the statement  "                            throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)"); " is 141.
Long Statement,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The length of the statement  "                                            g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)); " is 189.
Long Statement,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The length of the statement  "                            throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)"); " is 141.
Long Statement,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The length of the statement  "                                                g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLabelAdjustment)); " is 206.
Long Statement,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The length of the statement  "                                                g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)); " is 189.
Long Statement,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The length of the statement  "                                                g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)); " is 189.
Long Statement,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,GetXML,The length of the statement  "                throw new Exception("EGETXML-1: Could not retrieve XML due to the barcode not being encoded first.  Please call Encode first."); " is 128.
Long Statement,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_ITF14,The length of the statement  "                        g.DrawString(Barcode.AlternateLabel == null ? Barcode.RawData : Barcode.AlternateLabel' font' foreBrush' (float)(img.Width / 2)' img.Height - font.Height + 1' f); " is 162.
Long Statement,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_ITF14,The length of the statement  "                        g.DrawLine(pen' new Point(0' img.Height - font.Height - 2)' new Point(img.Width' img.Height - font.Height - 2));//bottom " is 120.
Long Statement,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_Generic,The length of the statement  "                        g.DrawString(Barcode.AlternateLabel == null ? Barcode.RawData : Barcode.AlternateLabel' font' foreBrush' new RectangleF((float)0' (float)LabelY' (float)img.Width' (float)font.Height)' f); " is 187.
Long Statement,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_EAN13,The length of the statement  "                using (Font labFont = new Font("Arial"' getFontsize(Barcode.Width - Barcode.Width % Barcode.EncodedValue.Length' img.Height' defTxt)' FontStyle.Regular)) " is 153.
Long Statement,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_EAN13,The length of the statement  "                                g.DrawString(defTxt.Substring(0' 1)' smallFont' foreBrush' new RectangleF(s1' (float)img.Height - (float)(smallFont.Height * 0.9)' (float)img.Width' (float)labFont.Height)' f); " is 176.
Long Statement,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_EAN13,The length of the statement  "                            g.DrawString(defTxt.Substring(1' 6)' labFont' foreBrush' new RectangleF(s2' (float)LabelY' (float)img.Width' (float)labFont.Height)' f); " is 136.
Long Statement,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_EAN13,The length of the statement  "                            g.DrawString(defTxt.Substring(7)' labFont' foreBrush' new RectangleF(s3 - iBarWidth' (float)LabelY' (float)img.Width' (float)labFont.Height)' f); " is 145.
Long Statement,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_UPCA,The length of the statement  "                using (Font labFont = new Font("Arial"' getFontsize((int)((Barcode.Width - Barcode.Width % Barcode.EncodedValue.Length) * 0.9f)' img.Height' defTxt)' FontStyle.Regular)) " is 169.
Long Statement,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_UPCA,The length of the statement  "                                g.DrawString(defTxt.Substring(0' 1)' smallFont' foreBrush' new RectangleF(s1' (float)img.Height - smallFont.Height' (float)img.Width' (float)labFont.Height)' f); " is 161.
Long Statement,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_UPCA,The length of the statement  "                                g.DrawString(defTxt.Substring(1' 5)' labFont' foreBrush' new RectangleF(s2 - iBarWidth' (float)LabelY' (float)img.Width' (float)labFont.Height)' f); " is 148.
Long Statement,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_UPCA,The length of the statement  "                                g.DrawString(defTxt.Substring(6' 5)' labFont' foreBrush' new RectangleF(s3 - iBarWidth' (float)LabelY' (float)img.Width' (float)labFont.Height)' f); " is 148.
Long Statement,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_UPCA,The length of the statement  "                                g.DrawString(defTxt.Substring(11)' smallFont' foreBrush' new RectangleF(s4' (float)img.Height - smallFont.Height' (float)img.Width' (float)labFont.Height)' f); " is 159.
Long Statement,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,getFontsize,The length of the statement  "                Image fakeImage = new Bitmap(1' 1); //As we cannot use CreateGraphics() in a class library' so the fake image is used to load the Graphics. " is 139.
Long Statement,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The length of the statement  "            this.C128_Code.Rows.Add(new object[] { "95"' Convert.ToChar(31).ToString()' Convert.ToChar(127).ToString()' "95"' "10111101000" }); " is 131.
Long Statement,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,InsertStartandCodeCharacters,The length of the statement  "                            if (row["A"].ToString().EndsWith(CurrentCodeString) || row["B"].ToString().EndsWith(CurrentCodeString) || row["C"].ToString().EndsWith(CurrentCodeString)) " is 154.
Long Statement,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,InsertStartandCodeCharacters,The length of the statement  "                        //if (CurrentCodeString == "" || !tempStartChars[0][col].ToString().EndsWith(CurrentCodeString)) /* Removed because of bug */ " is 125.
Long Statement,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,Encode_Code39,The length of the statement  "            string strFormattedData = "*" + strNoAstr + (_EnableChecksum ? getChecksumChar(strNoAstr).ToString() : String.Empty) + "*"; " is 123.
Long Statement,BarcodeLib.Symbologies,Code93,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code93.cs,Add_CheckDigits,The length of the statement  "                SUM += aryCWeights[i] * Int32.Parse(C93_Code.Select("Character = '" + input[i].ToString() + "'")[0]["Value"].ToString()); " is 121.
Long Statement,BarcodeLib.Symbologies,Code93,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code93.cs,Add_CheckDigits,The length of the statement  "                SUM += aryKWeights[i] * Int32.Parse(C93_Code.Select("Character = '" + input[i].ToString() + "'")[0]["Value"].ToString()); " is 121.
Long Statement,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The length of the statement  "			Create_CountryCodeRange(40' 49' "Used to issue restricted circulation numbers within a geographic region (MO defined)"); " is 120.
Long Statement,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The length of the statement  "			Create_CountryCodeRange(200' 299' "Used to issue GS1 restricted circulation number within a geographic region (MO defined)"); " is 125.
Long Statement,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The length of the statement  "			Create_CountryCodeRange(978' 979' "BOOKLAND (ISBN) – 979-0 USED FOR SHEET MUSIC (ISMN-13' REPLACES DEPRECATED ISMN M- NUMBERS)"); " is 129.
Long Statement,BarcodeLib.Symbologies,ISBN,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\ISBN.cs,Encode_ISBN_Bookland,The length of the statement  "            if (type == "UNKNOWN") Error("EBOOKLANDISBN-2: Invalid input.  Must start with 978 and be length must be 9' 10' 12' 13 characters."); " is 133.
Long Statement,BarcodeLib.Symbologies,UPCE,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCE.cs,Encode_UPCE,The length of the statement  "                if (Manufacturer.EndsWith("000") || Manufacturer.EndsWith("100") || Manufacturer.EndsWith("200") && Int32.Parse(ProductCode) <= 999) " is 132.
Complex Conditional,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,FindStartorCodeCharacter,The conditional expression  "s.Length > 1 && (Char.IsNumber(s[0]) || s[0] == FNC1) && (Char.IsNumber(s[1]) || s[1] == FNC1)"  is complex.
Complex Conditional,BarcodeLib.Symbologies,UPCE,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCE.cs,Encode_UPCE,The conditional expression  "Manufacturer.EndsWith("000") || Manufacturer.EndsWith("100") || Manufacturer.EndsWith("200") && Int32.Parse(ProductCode) <= 999"  is complex.
Magic Number,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type)              {                  case TYPE.ITF14:                      {                          // Automatically calculate the Width if applicable. Quite confusing with this                          // barcode type' and it seems this method overestimates the minimum width. But                          // at least it�s deterministic and doesn�t produce too small of a value.                          if (BarWidth.HasValue)                          {                              // Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone                              // Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20                              // Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length                              // Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)                              // Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)                              // Width = BarWidth * EncodedValue.Length / 176.9 * 241                              // Rounding error? + 1                              Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);                          }                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          if (IncludeLabel)                          {                              ILHeight -= this.LabelFont.Height;                          }                            bitmap = new Bitmap(Width' Height);                            int bearerwidth = (int)((bitmap.Width) / 12.05);                          int iquietzone = Convert.ToInt32(bitmap.Width * 0.05);                          int iBarWidth = (bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;                          int shiftAdjustment = ((bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;                            if (iBarWidth <= 0 || iquietzone <= 0)                              throw new Exception("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //fill background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen pen = new Pen(ForeColor' iBarWidth))                              {                                  pen.Alignment = PenAlignment.Right;                                    while (pos < Encoded_Value.Length)                                  {                                      //draw the appropriate color line vertically                                      if (Encoded_Value[pos] == '1')                                          g.DrawLine(pen' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));                                        pos++;                                  }//while                                    //bearer bars                                  pen.Width = (float)ILHeight / 8;                                  pen.Color = ForeColor;                                  pen.Alignment = PenAlignment.Center;                                  g.DrawLine(pen' new Point(0' 0)' new Point(bitmap.Width' 0));//top                                  g.DrawLine(pen' new Point(0' ILHeight)' new Point(bitmap.Width' ILHeight));//bottom                                  g.DrawLine(pen' new Point(0' 0)' new Point(0' ILHeight));//left                                  g.DrawLine(pen' new Point(bitmap.Width' 0)' new Point(bitmap.Width' ILHeight));//right                              }//using                          }//using                            if (IncludeLabel)                              Labels.Label_ITF14(this' bitmap);                            break;                      }//case                  case TYPE.UPCA:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                          int iBarWidth = Width / Encoded_Value.Length;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // UPCA standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                                                    Font labFont = new Font(this.LabelFont != null ? this.LabelFont.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                  if (this.LabelFont != null)                                  {                                      this.LabelFont.Dispose();                                  }                                  LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                                    iBarWidth = (int)Width / Encoded_Value.Length;                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_UPCA(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  case TYPE.EAN13:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // EAN13 standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                    Font font = this.LabelFont;                                  Font labFont = new Font(font != null ? font.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                    if (font != null)                                  {                                      this.LabelFont.Dispose();                                  }                                    LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_EAN13(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  default:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            if (IncludeLabel)                          {                              // Shift drawing down if top label.                              if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                  topLabelAdjustment = this.LabelFont.Height;                                ILHeight -= this.LabelFont.Height;                          }                              bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int shiftAdjustment = 0;                          int iBarWidthModifier = 1;                            if (this.Encoded_Type == TYPE.PostNet)                              iBarWidthModifier = 2;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)Math.Round(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (this.Encoded_Type == TYPE.PostNet)                                          {                                              //draw half bars in postnet                                              if (Encoded_Value[pos] == '0')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLabelAdjustment));                                              else                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment));                                          }//if                                          else                                          {                                              if (Encoded_Value[pos] == '1')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                          pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              Labels.Label_Generic(this' bitmap);                          }//if                            break;                      }//switch              }
Magic Number,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type)              {                  case TYPE.ITF14:                      {                          // Automatically calculate the Width if applicable. Quite confusing with this                          // barcode type' and it seems this method overestimates the minimum width. But                          // at least it�s deterministic and doesn�t produce too small of a value.                          if (BarWidth.HasValue)                          {                              // Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone                              // Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20                              // Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length                              // Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)                              // Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)                              // Width = BarWidth * EncodedValue.Length / 176.9 * 241                              // Rounding error? + 1                              Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);                          }                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          if (IncludeLabel)                          {                              ILHeight -= this.LabelFont.Height;                          }                            bitmap = new Bitmap(Width' Height);                            int bearerwidth = (int)((bitmap.Width) / 12.05);                          int iquietzone = Convert.ToInt32(bitmap.Width * 0.05);                          int iBarWidth = (bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;                          int shiftAdjustment = ((bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;                            if (iBarWidth <= 0 || iquietzone <= 0)                              throw new Exception("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //fill background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen pen = new Pen(ForeColor' iBarWidth))                              {                                  pen.Alignment = PenAlignment.Right;                                    while (pos < Encoded_Value.Length)                                  {                                      //draw the appropriate color line vertically                                      if (Encoded_Value[pos] == '1')                                          g.DrawLine(pen' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));                                        pos++;                                  }//while                                    //bearer bars                                  pen.Width = (float)ILHeight / 8;                                  pen.Color = ForeColor;                                  pen.Alignment = PenAlignment.Center;                                  g.DrawLine(pen' new Point(0' 0)' new Point(bitmap.Width' 0));//top                                  g.DrawLine(pen' new Point(0' ILHeight)' new Point(bitmap.Width' ILHeight));//bottom                                  g.DrawLine(pen' new Point(0' 0)' new Point(0' ILHeight));//left                                  g.DrawLine(pen' new Point(bitmap.Width' 0)' new Point(bitmap.Width' ILHeight));//right                              }//using                          }//using                            if (IncludeLabel)                              Labels.Label_ITF14(this' bitmap);                            break;                      }//case                  case TYPE.UPCA:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                          int iBarWidth = Width / Encoded_Value.Length;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // UPCA standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                                                    Font labFont = new Font(this.LabelFont != null ? this.LabelFont.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                  if (this.LabelFont != null)                                  {                                      this.LabelFont.Dispose();                                  }                                  LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                                    iBarWidth = (int)Width / Encoded_Value.Length;                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_UPCA(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  case TYPE.EAN13:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // EAN13 standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                    Font font = this.LabelFont;                                  Font labFont = new Font(font != null ? font.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                    if (font != null)                                  {                                      this.LabelFont.Dispose();                                  }                                    LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_EAN13(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  default:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            if (IncludeLabel)                          {                              // Shift drawing down if top label.                              if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                  topLabelAdjustment = this.LabelFont.Height;                                ILHeight -= this.LabelFont.Height;                          }                              bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int shiftAdjustment = 0;                          int iBarWidthModifier = 1;                            if (this.Encoded_Type == TYPE.PostNet)                              iBarWidthModifier = 2;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)Math.Round(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (this.Encoded_Type == TYPE.PostNet)                                          {                                              //draw half bars in postnet                                              if (Encoded_Value[pos] == '0')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLabelAdjustment));                                              else                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment));                                          }//if                                          else                                          {                                              if (Encoded_Value[pos] == '1')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                          pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              Labels.Label_Generic(this' bitmap);                          }//if                            break;                      }//switch              }
Magic Number,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type)              {                  case TYPE.ITF14:                      {                          // Automatically calculate the Width if applicable. Quite confusing with this                          // barcode type' and it seems this method overestimates the minimum width. But                          // at least it�s deterministic and doesn�t produce too small of a value.                          if (BarWidth.HasValue)                          {                              // Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone                              // Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20                              // Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length                              // Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)                              // Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)                              // Width = BarWidth * EncodedValue.Length / 176.9 * 241                              // Rounding error? + 1                              Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);                          }                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          if (IncludeLabel)                          {                              ILHeight -= this.LabelFont.Height;                          }                            bitmap = new Bitmap(Width' Height);                            int bearerwidth = (int)((bitmap.Width) / 12.05);                          int iquietzone = Convert.ToInt32(bitmap.Width * 0.05);                          int iBarWidth = (bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;                          int shiftAdjustment = ((bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;                            if (iBarWidth <= 0 || iquietzone <= 0)                              throw new Exception("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //fill background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen pen = new Pen(ForeColor' iBarWidth))                              {                                  pen.Alignment = PenAlignment.Right;                                    while (pos < Encoded_Value.Length)                                  {                                      //draw the appropriate color line vertically                                      if (Encoded_Value[pos] == '1')                                          g.DrawLine(pen' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));                                        pos++;                                  }//while                                    //bearer bars                                  pen.Width = (float)ILHeight / 8;                                  pen.Color = ForeColor;                                  pen.Alignment = PenAlignment.Center;                                  g.DrawLine(pen' new Point(0' 0)' new Point(bitmap.Width' 0));//top                                  g.DrawLine(pen' new Point(0' ILHeight)' new Point(bitmap.Width' ILHeight));//bottom                                  g.DrawLine(pen' new Point(0' 0)' new Point(0' ILHeight));//left                                  g.DrawLine(pen' new Point(bitmap.Width' 0)' new Point(bitmap.Width' ILHeight));//right                              }//using                          }//using                            if (IncludeLabel)                              Labels.Label_ITF14(this' bitmap);                            break;                      }//case                  case TYPE.UPCA:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                          int iBarWidth = Width / Encoded_Value.Length;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // UPCA standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                                                    Font labFont = new Font(this.LabelFont != null ? this.LabelFont.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                  if (this.LabelFont != null)                                  {                                      this.LabelFont.Dispose();                                  }                                  LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                                    iBarWidth = (int)Width / Encoded_Value.Length;                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_UPCA(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  case TYPE.EAN13:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // EAN13 standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                    Font font = this.LabelFont;                                  Font labFont = new Font(font != null ? font.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                    if (font != null)                                  {                                      this.LabelFont.Dispose();                                  }                                    LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_EAN13(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  default:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            if (IncludeLabel)                          {                              // Shift drawing down if top label.                              if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                  topLabelAdjustment = this.LabelFont.Height;                                ILHeight -= this.LabelFont.Height;                          }                              bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int shiftAdjustment = 0;                          int iBarWidthModifier = 1;                            if (this.Encoded_Type == TYPE.PostNet)                              iBarWidthModifier = 2;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)Math.Round(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (this.Encoded_Type == TYPE.PostNet)                                          {                                              //draw half bars in postnet                                              if (Encoded_Value[pos] == '0')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLabelAdjustment));                                              else                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment));                                          }//if                                          else                                          {                                              if (Encoded_Value[pos] == '1')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                          pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              Labels.Label_Generic(this' bitmap);                          }//if                            break;                      }//switch              }
Magic Number,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type)              {                  case TYPE.ITF14:                      {                          // Automatically calculate the Width if applicable. Quite confusing with this                          // barcode type' and it seems this method overestimates the minimum width. But                          // at least it�s deterministic and doesn�t produce too small of a value.                          if (BarWidth.HasValue)                          {                              // Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone                              // Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20                              // Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length                              // Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)                              // Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)                              // Width = BarWidth * EncodedValue.Length / 176.9 * 241                              // Rounding error? + 1                              Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);                          }                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          if (IncludeLabel)                          {                              ILHeight -= this.LabelFont.Height;                          }                            bitmap = new Bitmap(Width' Height);                            int bearerwidth = (int)((bitmap.Width) / 12.05);                          int iquietzone = Convert.ToInt32(bitmap.Width * 0.05);                          int iBarWidth = (bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;                          int shiftAdjustment = ((bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;                            if (iBarWidth <= 0 || iquietzone <= 0)                              throw new Exception("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //fill background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen pen = new Pen(ForeColor' iBarWidth))                              {                                  pen.Alignment = PenAlignment.Right;                                    while (pos < Encoded_Value.Length)                                  {                                      //draw the appropriate color line vertically                                      if (Encoded_Value[pos] == '1')                                          g.DrawLine(pen' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));                                        pos++;                                  }//while                                    //bearer bars                                  pen.Width = (float)ILHeight / 8;                                  pen.Color = ForeColor;                                  pen.Alignment = PenAlignment.Center;                                  g.DrawLine(pen' new Point(0' 0)' new Point(bitmap.Width' 0));//top                                  g.DrawLine(pen' new Point(0' ILHeight)' new Point(bitmap.Width' ILHeight));//bottom                                  g.DrawLine(pen' new Point(0' 0)' new Point(0' ILHeight));//left                                  g.DrawLine(pen' new Point(bitmap.Width' 0)' new Point(bitmap.Width' ILHeight));//right                              }//using                          }//using                            if (IncludeLabel)                              Labels.Label_ITF14(this' bitmap);                            break;                      }//case                  case TYPE.UPCA:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                          int iBarWidth = Width / Encoded_Value.Length;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // UPCA standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                                                    Font labFont = new Font(this.LabelFont != null ? this.LabelFont.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                  if (this.LabelFont != null)                                  {                                      this.LabelFont.Dispose();                                  }                                  LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                                    iBarWidth = (int)Width / Encoded_Value.Length;                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_UPCA(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  case TYPE.EAN13:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // EAN13 standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                    Font font = this.LabelFont;                                  Font labFont = new Font(font != null ? font.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                    if (font != null)                                  {                                      this.LabelFont.Dispose();                                  }                                    LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_EAN13(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  default:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            if (IncludeLabel)                          {                              // Shift drawing down if top label.                              if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                  topLabelAdjustment = this.LabelFont.Height;                                ILHeight -= this.LabelFont.Height;                          }                              bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int shiftAdjustment = 0;                          int iBarWidthModifier = 1;                            if (this.Encoded_Type == TYPE.PostNet)                              iBarWidthModifier = 2;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)Math.Round(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (this.Encoded_Type == TYPE.PostNet)                                          {                                              //draw half bars in postnet                                              if (Encoded_Value[pos] == '0')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLabelAdjustment));                                              else                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment));                                          }//if                                          else                                          {                                              if (Encoded_Value[pos] == '1')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                          pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              Labels.Label_Generic(this' bitmap);                          }//if                            break;                      }//switch              }
Magic Number,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type)              {                  case TYPE.ITF14:                      {                          // Automatically calculate the Width if applicable. Quite confusing with this                          // barcode type' and it seems this method overestimates the minimum width. But                          // at least it�s deterministic and doesn�t produce too small of a value.                          if (BarWidth.HasValue)                          {                              // Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone                              // Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20                              // Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length                              // Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)                              // Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)                              // Width = BarWidth * EncodedValue.Length / 176.9 * 241                              // Rounding error? + 1                              Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);                          }                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          if (IncludeLabel)                          {                              ILHeight -= this.LabelFont.Height;                          }                            bitmap = new Bitmap(Width' Height);                            int bearerwidth = (int)((bitmap.Width) / 12.05);                          int iquietzone = Convert.ToInt32(bitmap.Width * 0.05);                          int iBarWidth = (bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;                          int shiftAdjustment = ((bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;                            if (iBarWidth <= 0 || iquietzone <= 0)                              throw new Exception("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //fill background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen pen = new Pen(ForeColor' iBarWidth))                              {                                  pen.Alignment = PenAlignment.Right;                                    while (pos < Encoded_Value.Length)                                  {                                      //draw the appropriate color line vertically                                      if (Encoded_Value[pos] == '1')                                          g.DrawLine(pen' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));                                        pos++;                                  }//while                                    //bearer bars                                  pen.Width = (float)ILHeight / 8;                                  pen.Color = ForeColor;                                  pen.Alignment = PenAlignment.Center;                                  g.DrawLine(pen' new Point(0' 0)' new Point(bitmap.Width' 0));//top                                  g.DrawLine(pen' new Point(0' ILHeight)' new Point(bitmap.Width' ILHeight));//bottom                                  g.DrawLine(pen' new Point(0' 0)' new Point(0' ILHeight));//left                                  g.DrawLine(pen' new Point(bitmap.Width' 0)' new Point(bitmap.Width' ILHeight));//right                              }//using                          }//using                            if (IncludeLabel)                              Labels.Label_ITF14(this' bitmap);                            break;                      }//case                  case TYPE.UPCA:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                          int iBarWidth = Width / Encoded_Value.Length;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // UPCA standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                                                    Font labFont = new Font(this.LabelFont != null ? this.LabelFont.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                  if (this.LabelFont != null)                                  {                                      this.LabelFont.Dispose();                                  }                                  LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                                    iBarWidth = (int)Width / Encoded_Value.Length;                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_UPCA(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  case TYPE.EAN13:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // EAN13 standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                    Font font = this.LabelFont;                                  Font labFont = new Font(font != null ? font.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                    if (font != null)                                  {                                      this.LabelFont.Dispose();                                  }                                    LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_EAN13(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  default:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            if (IncludeLabel)                          {                              // Shift drawing down if top label.                              if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                  topLabelAdjustment = this.LabelFont.Height;                                ILHeight -= this.LabelFont.Height;                          }                              bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int shiftAdjustment = 0;                          int iBarWidthModifier = 1;                            if (this.Encoded_Type == TYPE.PostNet)                              iBarWidthModifier = 2;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)Math.Round(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (this.Encoded_Type == TYPE.PostNet)                                          {                                              //draw half bars in postnet                                              if (Encoded_Value[pos] == '0')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLabelAdjustment));                                              else                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment));                                          }//if                                          else                                          {                                              if (Encoded_Value[pos] == '1')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                          pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              Labels.Label_Generic(this' bitmap);                          }//if                            break;                      }//switch              }
Magic Number,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type)              {                  case TYPE.ITF14:                      {                          // Automatically calculate the Width if applicable. Quite confusing with this                          // barcode type' and it seems this method overestimates the minimum width. But                          // at least it�s deterministic and doesn�t produce too small of a value.                          if (BarWidth.HasValue)                          {                              // Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone                              // Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20                              // Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length                              // Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)                              // Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)                              // Width = BarWidth * EncodedValue.Length / 176.9 * 241                              // Rounding error? + 1                              Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);                          }                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          if (IncludeLabel)                          {                              ILHeight -= this.LabelFont.Height;                          }                            bitmap = new Bitmap(Width' Height);                            int bearerwidth = (int)((bitmap.Width) / 12.05);                          int iquietzone = Convert.ToInt32(bitmap.Width * 0.05);                          int iBarWidth = (bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;                          int shiftAdjustment = ((bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;                            if (iBarWidth <= 0 || iquietzone <= 0)                              throw new Exception("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //fill background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen pen = new Pen(ForeColor' iBarWidth))                              {                                  pen.Alignment = PenAlignment.Right;                                    while (pos < Encoded_Value.Length)                                  {                                      //draw the appropriate color line vertically                                      if (Encoded_Value[pos] == '1')                                          g.DrawLine(pen' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));                                        pos++;                                  }//while                                    //bearer bars                                  pen.Width = (float)ILHeight / 8;                                  pen.Color = ForeColor;                                  pen.Alignment = PenAlignment.Center;                                  g.DrawLine(pen' new Point(0' 0)' new Point(bitmap.Width' 0));//top                                  g.DrawLine(pen' new Point(0' ILHeight)' new Point(bitmap.Width' ILHeight));//bottom                                  g.DrawLine(pen' new Point(0' 0)' new Point(0' ILHeight));//left                                  g.DrawLine(pen' new Point(bitmap.Width' 0)' new Point(bitmap.Width' ILHeight));//right                              }//using                          }//using                            if (IncludeLabel)                              Labels.Label_ITF14(this' bitmap);                            break;                      }//case                  case TYPE.UPCA:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                          int iBarWidth = Width / Encoded_Value.Length;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // UPCA standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                                                    Font labFont = new Font(this.LabelFont != null ? this.LabelFont.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                  if (this.LabelFont != null)                                  {                                      this.LabelFont.Dispose();                                  }                                  LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                                    iBarWidth = (int)Width / Encoded_Value.Length;                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_UPCA(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  case TYPE.EAN13:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // EAN13 standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                    Font font = this.LabelFont;                                  Font labFont = new Font(font != null ? font.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                    if (font != null)                                  {                                      this.LabelFont.Dispose();                                  }                                    LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_EAN13(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  default:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            if (IncludeLabel)                          {                              // Shift drawing down if top label.                              if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                  topLabelAdjustment = this.LabelFont.Height;                                ILHeight -= this.LabelFont.Height;                          }                              bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int shiftAdjustment = 0;                          int iBarWidthModifier = 1;                            if (this.Encoded_Type == TYPE.PostNet)                              iBarWidthModifier = 2;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)Math.Round(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (this.Encoded_Type == TYPE.PostNet)                                          {                                              //draw half bars in postnet                                              if (Encoded_Value[pos] == '0')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLabelAdjustment));                                              else                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment));                                          }//if                                          else                                          {                                              if (Encoded_Value[pos] == '1')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                          pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              Labels.Label_Generic(this' bitmap);                          }//if                            break;                      }//switch              }
Magic Number,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type)              {                  case TYPE.ITF14:                      {                          // Automatically calculate the Width if applicable. Quite confusing with this                          // barcode type' and it seems this method overestimates the minimum width. But                          // at least it�s deterministic and doesn�t produce too small of a value.                          if (BarWidth.HasValue)                          {                              // Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone                              // Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20                              // Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length                              // Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)                              // Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)                              // Width = BarWidth * EncodedValue.Length / 176.9 * 241                              // Rounding error? + 1                              Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);                          }                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          if (IncludeLabel)                          {                              ILHeight -= this.LabelFont.Height;                          }                            bitmap = new Bitmap(Width' Height);                            int bearerwidth = (int)((bitmap.Width) / 12.05);                          int iquietzone = Convert.ToInt32(bitmap.Width * 0.05);                          int iBarWidth = (bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;                          int shiftAdjustment = ((bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;                            if (iBarWidth <= 0 || iquietzone <= 0)                              throw new Exception("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //fill background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen pen = new Pen(ForeColor' iBarWidth))                              {                                  pen.Alignment = PenAlignment.Right;                                    while (pos < Encoded_Value.Length)                                  {                                      //draw the appropriate color line vertically                                      if (Encoded_Value[pos] == '1')                                          g.DrawLine(pen' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));                                        pos++;                                  }//while                                    //bearer bars                                  pen.Width = (float)ILHeight / 8;                                  pen.Color = ForeColor;                                  pen.Alignment = PenAlignment.Center;                                  g.DrawLine(pen' new Point(0' 0)' new Point(bitmap.Width' 0));//top                                  g.DrawLine(pen' new Point(0' ILHeight)' new Point(bitmap.Width' ILHeight));//bottom                                  g.DrawLine(pen' new Point(0' 0)' new Point(0' ILHeight));//left                                  g.DrawLine(pen' new Point(bitmap.Width' 0)' new Point(bitmap.Width' ILHeight));//right                              }//using                          }//using                            if (IncludeLabel)                              Labels.Label_ITF14(this' bitmap);                            break;                      }//case                  case TYPE.UPCA:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                          int iBarWidth = Width / Encoded_Value.Length;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // UPCA standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                                                    Font labFont = new Font(this.LabelFont != null ? this.LabelFont.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                  if (this.LabelFont != null)                                  {                                      this.LabelFont.Dispose();                                  }                                  LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                                    iBarWidth = (int)Width / Encoded_Value.Length;                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_UPCA(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  case TYPE.EAN13:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // EAN13 standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                    Font font = this.LabelFont;                                  Font labFont = new Font(font != null ? font.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                    if (font != null)                                  {                                      this.LabelFont.Dispose();                                  }                                    LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_EAN13(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  default:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            if (IncludeLabel)                          {                              // Shift drawing down if top label.                              if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                  topLabelAdjustment = this.LabelFont.Height;                                ILHeight -= this.LabelFont.Height;                          }                              bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int shiftAdjustment = 0;                          int iBarWidthModifier = 1;                            if (this.Encoded_Type == TYPE.PostNet)                              iBarWidthModifier = 2;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)Math.Round(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (this.Encoded_Type == TYPE.PostNet)                                          {                                              //draw half bars in postnet                                              if (Encoded_Value[pos] == '0')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLabelAdjustment));                                              else                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment));                                          }//if                                          else                                          {                                              if (Encoded_Value[pos] == '1')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                          pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              Labels.Label_Generic(this' bitmap);                          }//if                            break;                      }//switch              }
Magic Number,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type)              {                  case TYPE.ITF14:                      {                          // Automatically calculate the Width if applicable. Quite confusing with this                          // barcode type' and it seems this method overestimates the minimum width. But                          // at least it�s deterministic and doesn�t produce too small of a value.                          if (BarWidth.HasValue)                          {                              // Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone                              // Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20                              // Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length                              // Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)                              // Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)                              // Width = BarWidth * EncodedValue.Length / 176.9 * 241                              // Rounding error? + 1                              Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);                          }                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          if (IncludeLabel)                          {                              ILHeight -= this.LabelFont.Height;                          }                            bitmap = new Bitmap(Width' Height);                            int bearerwidth = (int)((bitmap.Width) / 12.05);                          int iquietzone = Convert.ToInt32(bitmap.Width * 0.05);                          int iBarWidth = (bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;                          int shiftAdjustment = ((bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;                            if (iBarWidth <= 0 || iquietzone <= 0)                              throw new Exception("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //fill background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen pen = new Pen(ForeColor' iBarWidth))                              {                                  pen.Alignment = PenAlignment.Right;                                    while (pos < Encoded_Value.Length)                                  {                                      //draw the appropriate color line vertically                                      if (Encoded_Value[pos] == '1')                                          g.DrawLine(pen' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));                                        pos++;                                  }//while                                    //bearer bars                                  pen.Width = (float)ILHeight / 8;                                  pen.Color = ForeColor;                                  pen.Alignment = PenAlignment.Center;                                  g.DrawLine(pen' new Point(0' 0)' new Point(bitmap.Width' 0));//top                                  g.DrawLine(pen' new Point(0' ILHeight)' new Point(bitmap.Width' ILHeight));//bottom                                  g.DrawLine(pen' new Point(0' 0)' new Point(0' ILHeight));//left                                  g.DrawLine(pen' new Point(bitmap.Width' 0)' new Point(bitmap.Width' ILHeight));//right                              }//using                          }//using                            if (IncludeLabel)                              Labels.Label_ITF14(this' bitmap);                            break;                      }//case                  case TYPE.UPCA:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                          int iBarWidth = Width / Encoded_Value.Length;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // UPCA standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                                                    Font labFont = new Font(this.LabelFont != null ? this.LabelFont.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                  if (this.LabelFont != null)                                  {                                      this.LabelFont.Dispose();                                  }                                  LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                                    iBarWidth = (int)Width / Encoded_Value.Length;                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_UPCA(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  case TYPE.EAN13:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // EAN13 standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                    Font font = this.LabelFont;                                  Font labFont = new Font(font != null ? font.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                    if (font != null)                                  {                                      this.LabelFont.Dispose();                                  }                                    LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_EAN13(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  default:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            if (IncludeLabel)                          {                              // Shift drawing down if top label.                              if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                  topLabelAdjustment = this.LabelFont.Height;                                ILHeight -= this.LabelFont.Height;                          }                              bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int shiftAdjustment = 0;                          int iBarWidthModifier = 1;                            if (this.Encoded_Type == TYPE.PostNet)                              iBarWidthModifier = 2;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)Math.Round(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (this.Encoded_Type == TYPE.PostNet)                                          {                                              //draw half bars in postnet                                              if (Encoded_Value[pos] == '0')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLabelAdjustment));                                              else                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment));                                          }//if                                          else                                          {                                              if (Encoded_Value[pos] == '1')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                          pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              Labels.Label_Generic(this' bitmap);                          }//if                            break;                      }//switch              }
Magic Number,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type)              {                  case TYPE.ITF14:                      {                          // Automatically calculate the Width if applicable. Quite confusing with this                          // barcode type' and it seems this method overestimates the minimum width. But                          // at least it�s deterministic and doesn�t produce too small of a value.                          if (BarWidth.HasValue)                          {                              // Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone                              // Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20                              // Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length                              // Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)                              // Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)                              // Width = BarWidth * EncodedValue.Length / 176.9 * 241                              // Rounding error? + 1                              Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);                          }                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          if (IncludeLabel)                          {                              ILHeight -= this.LabelFont.Height;                          }                            bitmap = new Bitmap(Width' Height);                            int bearerwidth = (int)((bitmap.Width) / 12.05);                          int iquietzone = Convert.ToInt32(bitmap.Width * 0.05);                          int iBarWidth = (bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;                          int shiftAdjustment = ((bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;                            if (iBarWidth <= 0 || iquietzone <= 0)                              throw new Exception("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //fill background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen pen = new Pen(ForeColor' iBarWidth))                              {                                  pen.Alignment = PenAlignment.Right;                                    while (pos < Encoded_Value.Length)                                  {                                      //draw the appropriate color line vertically                                      if (Encoded_Value[pos] == '1')                                          g.DrawLine(pen' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));                                        pos++;                                  }//while                                    //bearer bars                                  pen.Width = (float)ILHeight / 8;                                  pen.Color = ForeColor;                                  pen.Alignment = PenAlignment.Center;                                  g.DrawLine(pen' new Point(0' 0)' new Point(bitmap.Width' 0));//top                                  g.DrawLine(pen' new Point(0' ILHeight)' new Point(bitmap.Width' ILHeight));//bottom                                  g.DrawLine(pen' new Point(0' 0)' new Point(0' ILHeight));//left                                  g.DrawLine(pen' new Point(bitmap.Width' 0)' new Point(bitmap.Width' ILHeight));//right                              }//using                          }//using                            if (IncludeLabel)                              Labels.Label_ITF14(this' bitmap);                            break;                      }//case                  case TYPE.UPCA:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                          int iBarWidth = Width / Encoded_Value.Length;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // UPCA standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                                                    Font labFont = new Font(this.LabelFont != null ? this.LabelFont.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                  if (this.LabelFont != null)                                  {                                      this.LabelFont.Dispose();                                  }                                  LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                                    iBarWidth = (int)Width / Encoded_Value.Length;                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_UPCA(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  case TYPE.EAN13:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // EAN13 standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                    Font font = this.LabelFont;                                  Font labFont = new Font(font != null ? font.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                    if (font != null)                                  {                                      this.LabelFont.Dispose();                                  }                                    LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_EAN13(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  default:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            if (IncludeLabel)                          {                              // Shift drawing down if top label.                              if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                  topLabelAdjustment = this.LabelFont.Height;                                ILHeight -= this.LabelFont.Height;                          }                              bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int shiftAdjustment = 0;                          int iBarWidthModifier = 1;                            if (this.Encoded_Type == TYPE.PostNet)                              iBarWidthModifier = 2;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)Math.Round(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (this.Encoded_Type == TYPE.PostNet)                                          {                                              //draw half bars in postnet                                              if (Encoded_Value[pos] == '0')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLabelAdjustment));                                              else                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment));                                          }//if                                          else                                          {                                              if (Encoded_Value[pos] == '1')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                          pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              Labels.Label_Generic(this' bitmap);                          }//if                            break;                      }//switch              }
Magic Number,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type)              {                  case TYPE.ITF14:                      {                          // Automatically calculate the Width if applicable. Quite confusing with this                          // barcode type' and it seems this method overestimates the minimum width. But                          // at least it�s deterministic and doesn�t produce too small of a value.                          if (BarWidth.HasValue)                          {                              // Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone                              // Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20                              // Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length                              // Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)                              // Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)                              // Width = BarWidth * EncodedValue.Length / 176.9 * 241                              // Rounding error? + 1                              Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);                          }                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          if (IncludeLabel)                          {                              ILHeight -= this.LabelFont.Height;                          }                            bitmap = new Bitmap(Width' Height);                            int bearerwidth = (int)((bitmap.Width) / 12.05);                          int iquietzone = Convert.ToInt32(bitmap.Width * 0.05);                          int iBarWidth = (bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;                          int shiftAdjustment = ((bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;                            if (iBarWidth <= 0 || iquietzone <= 0)                              throw new Exception("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //fill background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen pen = new Pen(ForeColor' iBarWidth))                              {                                  pen.Alignment = PenAlignment.Right;                                    while (pos < Encoded_Value.Length)                                  {                                      //draw the appropriate color line vertically                                      if (Encoded_Value[pos] == '1')                                          g.DrawLine(pen' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));                                        pos++;                                  }//while                                    //bearer bars                                  pen.Width = (float)ILHeight / 8;                                  pen.Color = ForeColor;                                  pen.Alignment = PenAlignment.Center;                                  g.DrawLine(pen' new Point(0' 0)' new Point(bitmap.Width' 0));//top                                  g.DrawLine(pen' new Point(0' ILHeight)' new Point(bitmap.Width' ILHeight));//bottom                                  g.DrawLine(pen' new Point(0' 0)' new Point(0' ILHeight));//left                                  g.DrawLine(pen' new Point(bitmap.Width' 0)' new Point(bitmap.Width' ILHeight));//right                              }//using                          }//using                            if (IncludeLabel)                              Labels.Label_ITF14(this' bitmap);                            break;                      }//case                  case TYPE.UPCA:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                          int iBarWidth = Width / Encoded_Value.Length;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // UPCA standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                                                    Font labFont = new Font(this.LabelFont != null ? this.LabelFont.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                  if (this.LabelFont != null)                                  {                                      this.LabelFont.Dispose();                                  }                                  LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                                    iBarWidth = (int)Width / Encoded_Value.Length;                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_UPCA(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  case TYPE.EAN13:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // EAN13 standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                    Font font = this.LabelFont;                                  Font labFont = new Font(font != null ? font.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                    if (font != null)                                  {                                      this.LabelFont.Dispose();                                  }                                    LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_EAN13(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  default:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            if (IncludeLabel)                          {                              // Shift drawing down if top label.                              if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                  topLabelAdjustment = this.LabelFont.Height;                                ILHeight -= this.LabelFont.Height;                          }                              bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int shiftAdjustment = 0;                          int iBarWidthModifier = 1;                            if (this.Encoded_Type == TYPE.PostNet)                              iBarWidthModifier = 2;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)Math.Round(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (this.Encoded_Type == TYPE.PostNet)                                          {                                              //draw half bars in postnet                                              if (Encoded_Value[pos] == '0')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLabelAdjustment));                                              else                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment));                                          }//if                                          else                                          {                                              if (Encoded_Value[pos] == '1')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                          pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              Labels.Label_Generic(this' bitmap);                          }//if                            break;                      }//switch              }
Magic Number,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type)              {                  case TYPE.ITF14:                      {                          // Automatically calculate the Width if applicable. Quite confusing with this                          // barcode type' and it seems this method overestimates the minimum width. But                          // at least it�s deterministic and doesn�t produce too small of a value.                          if (BarWidth.HasValue)                          {                              // Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone                              // Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20                              // Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length                              // Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)                              // Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)                              // Width = BarWidth * EncodedValue.Length / 176.9 * 241                              // Rounding error? + 1                              Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);                          }                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          if (IncludeLabel)                          {                              ILHeight -= this.LabelFont.Height;                          }                            bitmap = new Bitmap(Width' Height);                            int bearerwidth = (int)((bitmap.Width) / 12.05);                          int iquietzone = Convert.ToInt32(bitmap.Width * 0.05);                          int iBarWidth = (bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;                          int shiftAdjustment = ((bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;                            if (iBarWidth <= 0 || iquietzone <= 0)                              throw new Exception("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //fill background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen pen = new Pen(ForeColor' iBarWidth))                              {                                  pen.Alignment = PenAlignment.Right;                                    while (pos < Encoded_Value.Length)                                  {                                      //draw the appropriate color line vertically                                      if (Encoded_Value[pos] == '1')                                          g.DrawLine(pen' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));                                        pos++;                                  }//while                                    //bearer bars                                  pen.Width = (float)ILHeight / 8;                                  pen.Color = ForeColor;                                  pen.Alignment = PenAlignment.Center;                                  g.DrawLine(pen' new Point(0' 0)' new Point(bitmap.Width' 0));//top                                  g.DrawLine(pen' new Point(0' ILHeight)' new Point(bitmap.Width' ILHeight));//bottom                                  g.DrawLine(pen' new Point(0' 0)' new Point(0' ILHeight));//left                                  g.DrawLine(pen' new Point(bitmap.Width' 0)' new Point(bitmap.Width' ILHeight));//right                              }//using                          }//using                            if (IncludeLabel)                              Labels.Label_ITF14(this' bitmap);                            break;                      }//case                  case TYPE.UPCA:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                          int iBarWidth = Width / Encoded_Value.Length;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // UPCA standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                                                    Font labFont = new Font(this.LabelFont != null ? this.LabelFont.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                  if (this.LabelFont != null)                                  {                                      this.LabelFont.Dispose();                                  }                                  LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                                    iBarWidth = (int)Width / Encoded_Value.Length;                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_UPCA(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  case TYPE.EAN13:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // EAN13 standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                    Font font = this.LabelFont;                                  Font labFont = new Font(font != null ? font.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                    if (font != null)                                  {                                      this.LabelFont.Dispose();                                  }                                    LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_EAN13(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  default:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            if (IncludeLabel)                          {                              // Shift drawing down if top label.                              if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                  topLabelAdjustment = this.LabelFont.Height;                                ILHeight -= this.LabelFont.Height;                          }                              bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int shiftAdjustment = 0;                          int iBarWidthModifier = 1;                            if (this.Encoded_Type == TYPE.PostNet)                              iBarWidthModifier = 2;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)Math.Round(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (this.Encoded_Type == TYPE.PostNet)                                          {                                              //draw half bars in postnet                                              if (Encoded_Value[pos] == '0')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLabelAdjustment));                                              else                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment));                                          }//if                                          else                                          {                                              if (Encoded_Value[pos] == '1')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                          pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              Labels.Label_Generic(this' bitmap);                          }//if                            break;                      }//switch              }
Magic Number,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type)              {                  case TYPE.ITF14:                      {                          // Automatically calculate the Width if applicable. Quite confusing with this                          // barcode type' and it seems this method overestimates the minimum width. But                          // at least it�s deterministic and doesn�t produce too small of a value.                          if (BarWidth.HasValue)                          {                              // Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone                              // Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20                              // Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length                              // Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)                              // Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)                              // Width = BarWidth * EncodedValue.Length / 176.9 * 241                              // Rounding error? + 1                              Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);                          }                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          if (IncludeLabel)                          {                              ILHeight -= this.LabelFont.Height;                          }                            bitmap = new Bitmap(Width' Height);                            int bearerwidth = (int)((bitmap.Width) / 12.05);                          int iquietzone = Convert.ToInt32(bitmap.Width * 0.05);                          int iBarWidth = (bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;                          int shiftAdjustment = ((bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;                            if (iBarWidth <= 0 || iquietzone <= 0)                              throw new Exception("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //fill background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen pen = new Pen(ForeColor' iBarWidth))                              {                                  pen.Alignment = PenAlignment.Right;                                    while (pos < Encoded_Value.Length)                                  {                                      //draw the appropriate color line vertically                                      if (Encoded_Value[pos] == '1')                                          g.DrawLine(pen' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));                                        pos++;                                  }//while                                    //bearer bars                                  pen.Width = (float)ILHeight / 8;                                  pen.Color = ForeColor;                                  pen.Alignment = PenAlignment.Center;                                  g.DrawLine(pen' new Point(0' 0)' new Point(bitmap.Width' 0));//top                                  g.DrawLine(pen' new Point(0' ILHeight)' new Point(bitmap.Width' ILHeight));//bottom                                  g.DrawLine(pen' new Point(0' 0)' new Point(0' ILHeight));//left                                  g.DrawLine(pen' new Point(bitmap.Width' 0)' new Point(bitmap.Width' ILHeight));//right                              }//using                          }//using                            if (IncludeLabel)                              Labels.Label_ITF14(this' bitmap);                            break;                      }//case                  case TYPE.UPCA:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                          int iBarWidth = Width / Encoded_Value.Length;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // UPCA standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                                                    Font labFont = new Font(this.LabelFont != null ? this.LabelFont.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                  if (this.LabelFont != null)                                  {                                      this.LabelFont.Dispose();                                  }                                  LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                                    iBarWidth = (int)Width / Encoded_Value.Length;                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_UPCA(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  case TYPE.EAN13:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // EAN13 standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                    Font font = this.LabelFont;                                  Font labFont = new Font(font != null ? font.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                    if (font != null)                                  {                                      this.LabelFont.Dispose();                                  }                                    LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_EAN13(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  default:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            if (IncludeLabel)                          {                              // Shift drawing down if top label.                              if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                  topLabelAdjustment = this.LabelFont.Height;                                ILHeight -= this.LabelFont.Height;                          }                              bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int shiftAdjustment = 0;                          int iBarWidthModifier = 1;                            if (this.Encoded_Type == TYPE.PostNet)                              iBarWidthModifier = 2;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)Math.Round(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (this.Encoded_Type == TYPE.PostNet)                                          {                                              //draw half bars in postnet                                              if (Encoded_Value[pos] == '0')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLabelAdjustment));                                              else                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment));                                          }//if                                          else                                          {                                              if (Encoded_Value[pos] == '1')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                          pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              Labels.Label_Generic(this' bitmap);                          }//if                            break;                      }//switch              }
Magic Number,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type)              {                  case TYPE.ITF14:                      {                          // Automatically calculate the Width if applicable. Quite confusing with this                          // barcode type' and it seems this method overestimates the minimum width. But                          // at least it�s deterministic and doesn�t produce too small of a value.                          if (BarWidth.HasValue)                          {                              // Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone                              // Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20                              // Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length                              // Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)                              // Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)                              // Width = BarWidth * EncodedValue.Length / 176.9 * 241                              // Rounding error? + 1                              Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);                          }                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          if (IncludeLabel)                          {                              ILHeight -= this.LabelFont.Height;                          }                            bitmap = new Bitmap(Width' Height);                            int bearerwidth = (int)((bitmap.Width) / 12.05);                          int iquietzone = Convert.ToInt32(bitmap.Width * 0.05);                          int iBarWidth = (bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;                          int shiftAdjustment = ((bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;                            if (iBarWidth <= 0 || iquietzone <= 0)                              throw new Exception("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //fill background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen pen = new Pen(ForeColor' iBarWidth))                              {                                  pen.Alignment = PenAlignment.Right;                                    while (pos < Encoded_Value.Length)                                  {                                      //draw the appropriate color line vertically                                      if (Encoded_Value[pos] == '1')                                          g.DrawLine(pen' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));                                        pos++;                                  }//while                                    //bearer bars                                  pen.Width = (float)ILHeight / 8;                                  pen.Color = ForeColor;                                  pen.Alignment = PenAlignment.Center;                                  g.DrawLine(pen' new Point(0' 0)' new Point(bitmap.Width' 0));//top                                  g.DrawLine(pen' new Point(0' ILHeight)' new Point(bitmap.Width' ILHeight));//bottom                                  g.DrawLine(pen' new Point(0' 0)' new Point(0' ILHeight));//left                                  g.DrawLine(pen' new Point(bitmap.Width' 0)' new Point(bitmap.Width' ILHeight));//right                              }//using                          }//using                            if (IncludeLabel)                              Labels.Label_ITF14(this' bitmap);                            break;                      }//case                  case TYPE.UPCA:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                          int iBarWidth = Width / Encoded_Value.Length;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // UPCA standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                                                    Font labFont = new Font(this.LabelFont != null ? this.LabelFont.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                  if (this.LabelFont != null)                                  {                                      this.LabelFont.Dispose();                                  }                                  LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                                    iBarWidth = (int)Width / Encoded_Value.Length;                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_UPCA(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  case TYPE.EAN13:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // EAN13 standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                    Font font = this.LabelFont;                                  Font labFont = new Font(font != null ? font.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                    if (font != null)                                  {                                      this.LabelFont.Dispose();                                  }                                    LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_EAN13(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  default:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            if (IncludeLabel)                          {                              // Shift drawing down if top label.                              if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                  topLabelAdjustment = this.LabelFont.Height;                                ILHeight -= this.LabelFont.Height;                          }                              bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int shiftAdjustment = 0;                          int iBarWidthModifier = 1;                            if (this.Encoded_Type == TYPE.PostNet)                              iBarWidthModifier = 2;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)Math.Round(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (this.Encoded_Type == TYPE.PostNet)                                          {                                              //draw half bars in postnet                                              if (Encoded_Value[pos] == '0')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLabelAdjustment));                                              else                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment));                                          }//if                                          else                                          {                                              if (Encoded_Value[pos] == '1')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                          pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              Labels.Label_Generic(this' bitmap);                          }//if                            break;                      }//switch              }
Magic Number,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type)              {                  case TYPE.ITF14:                      {                          // Automatically calculate the Width if applicable. Quite confusing with this                          // barcode type' and it seems this method overestimates the minimum width. But                          // at least it�s deterministic and doesn�t produce too small of a value.                          if (BarWidth.HasValue)                          {                              // Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone                              // Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20                              // Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length                              // Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)                              // Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)                              // Width = BarWidth * EncodedValue.Length / 176.9 * 241                              // Rounding error? + 1                              Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);                          }                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          if (IncludeLabel)                          {                              ILHeight -= this.LabelFont.Height;                          }                            bitmap = new Bitmap(Width' Height);                            int bearerwidth = (int)((bitmap.Width) / 12.05);                          int iquietzone = Convert.ToInt32(bitmap.Width * 0.05);                          int iBarWidth = (bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;                          int shiftAdjustment = ((bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;                            if (iBarWidth <= 0 || iquietzone <= 0)                              throw new Exception("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //fill background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen pen = new Pen(ForeColor' iBarWidth))                              {                                  pen.Alignment = PenAlignment.Right;                                    while (pos < Encoded_Value.Length)                                  {                                      //draw the appropriate color line vertically                                      if (Encoded_Value[pos] == '1')                                          g.DrawLine(pen' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));                                        pos++;                                  }//while                                    //bearer bars                                  pen.Width = (float)ILHeight / 8;                                  pen.Color = ForeColor;                                  pen.Alignment = PenAlignment.Center;                                  g.DrawLine(pen' new Point(0' 0)' new Point(bitmap.Width' 0));//top                                  g.DrawLine(pen' new Point(0' ILHeight)' new Point(bitmap.Width' ILHeight));//bottom                                  g.DrawLine(pen' new Point(0' 0)' new Point(0' ILHeight));//left                                  g.DrawLine(pen' new Point(bitmap.Width' 0)' new Point(bitmap.Width' ILHeight));//right                              }//using                          }//using                            if (IncludeLabel)                              Labels.Label_ITF14(this' bitmap);                            break;                      }//case                  case TYPE.UPCA:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                          int iBarWidth = Width / Encoded_Value.Length;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // UPCA standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                                                    Font labFont = new Font(this.LabelFont != null ? this.LabelFont.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                  if (this.LabelFont != null)                                  {                                      this.LabelFont.Dispose();                                  }                                  LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                                    iBarWidth = (int)Width / Encoded_Value.Length;                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_UPCA(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  case TYPE.EAN13:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // EAN13 standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                    Font font = this.LabelFont;                                  Font labFont = new Font(font != null ? font.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                    if (font != null)                                  {                                      this.LabelFont.Dispose();                                  }                                    LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_EAN13(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  default:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            if (IncludeLabel)                          {                              // Shift drawing down if top label.                              if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                  topLabelAdjustment = this.LabelFont.Height;                                ILHeight -= this.LabelFont.Height;                          }                              bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int shiftAdjustment = 0;                          int iBarWidthModifier = 1;                            if (this.Encoded_Type == TYPE.PostNet)                              iBarWidthModifier = 2;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)Math.Round(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (this.Encoded_Type == TYPE.PostNet)                                          {                                              //draw half bars in postnet                                              if (Encoded_Value[pos] == '0')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLabelAdjustment));                                              else                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment));                                          }//if                                          else                                          {                                              if (Encoded_Value[pos] == '1')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                          pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              Labels.Label_Generic(this' bitmap);                          }//if                            break;                      }//switch              }
Magic Number,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type)              {                  case TYPE.ITF14:                      {                          // Automatically calculate the Width if applicable. Quite confusing with this                          // barcode type' and it seems this method overestimates the minimum width. But                          // at least it�s deterministic and doesn�t produce too small of a value.                          if (BarWidth.HasValue)                          {                              // Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone                              // Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20                              // Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length                              // Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)                              // Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)                              // Width = BarWidth * EncodedValue.Length / 176.9 * 241                              // Rounding error? + 1                              Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);                          }                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          if (IncludeLabel)                          {                              ILHeight -= this.LabelFont.Height;                          }                            bitmap = new Bitmap(Width' Height);                            int bearerwidth = (int)((bitmap.Width) / 12.05);                          int iquietzone = Convert.ToInt32(bitmap.Width * 0.05);                          int iBarWidth = (bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;                          int shiftAdjustment = ((bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;                            if (iBarWidth <= 0 || iquietzone <= 0)                              throw new Exception("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //fill background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen pen = new Pen(ForeColor' iBarWidth))                              {                                  pen.Alignment = PenAlignment.Right;                                    while (pos < Encoded_Value.Length)                                  {                                      //draw the appropriate color line vertically                                      if (Encoded_Value[pos] == '1')                                          g.DrawLine(pen' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));                                        pos++;                                  }//while                                    //bearer bars                                  pen.Width = (float)ILHeight / 8;                                  pen.Color = ForeColor;                                  pen.Alignment = PenAlignment.Center;                                  g.DrawLine(pen' new Point(0' 0)' new Point(bitmap.Width' 0));//top                                  g.DrawLine(pen' new Point(0' ILHeight)' new Point(bitmap.Width' ILHeight));//bottom                                  g.DrawLine(pen' new Point(0' 0)' new Point(0' ILHeight));//left                                  g.DrawLine(pen' new Point(bitmap.Width' 0)' new Point(bitmap.Width' ILHeight));//right                              }//using                          }//using                            if (IncludeLabel)                              Labels.Label_ITF14(this' bitmap);                            break;                      }//case                  case TYPE.UPCA:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                          int iBarWidth = Width / Encoded_Value.Length;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // UPCA standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                                                    Font labFont = new Font(this.LabelFont != null ? this.LabelFont.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                  if (this.LabelFont != null)                                  {                                      this.LabelFont.Dispose();                                  }                                  LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                                    iBarWidth = (int)Width / Encoded_Value.Length;                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_UPCA(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  case TYPE.EAN13:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // EAN13 standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                    Font font = this.LabelFont;                                  Font labFont = new Font(font != null ? font.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                    if (font != null)                                  {                                      this.LabelFont.Dispose();                                  }                                    LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_EAN13(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  default:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            if (IncludeLabel)                          {                              // Shift drawing down if top label.                              if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                  topLabelAdjustment = this.LabelFont.Height;                                ILHeight -= this.LabelFont.Height;                          }                              bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int shiftAdjustment = 0;                          int iBarWidthModifier = 1;                            if (this.Encoded_Type == TYPE.PostNet)                              iBarWidthModifier = 2;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)Math.Round(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (this.Encoded_Type == TYPE.PostNet)                                          {                                              //draw half bars in postnet                                              if (Encoded_Value[pos] == '0')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLabelAdjustment));                                              else                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment));                                          }//if                                          else                                          {                                              if (Encoded_Value[pos] == '1')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                          pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              Labels.Label_Generic(this' bitmap);                          }//if                            break;                      }//switch              }
Magic Number,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type)              {                  case TYPE.ITF14:                      {                          // Automatically calculate the Width if applicable. Quite confusing with this                          // barcode type' and it seems this method overestimates the minimum width. But                          // at least it�s deterministic and doesn�t produce too small of a value.                          if (BarWidth.HasValue)                          {                              // Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone                              // Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20                              // Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length                              // Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)                              // Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)                              // Width = BarWidth * EncodedValue.Length / 176.9 * 241                              // Rounding error? + 1                              Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);                          }                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          if (IncludeLabel)                          {                              ILHeight -= this.LabelFont.Height;                          }                            bitmap = new Bitmap(Width' Height);                            int bearerwidth = (int)((bitmap.Width) / 12.05);                          int iquietzone = Convert.ToInt32(bitmap.Width * 0.05);                          int iBarWidth = (bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;                          int shiftAdjustment = ((bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;                            if (iBarWidth <= 0 || iquietzone <= 0)                              throw new Exception("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //fill background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen pen = new Pen(ForeColor' iBarWidth))                              {                                  pen.Alignment = PenAlignment.Right;                                    while (pos < Encoded_Value.Length)                                  {                                      //draw the appropriate color line vertically                                      if (Encoded_Value[pos] == '1')                                          g.DrawLine(pen' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));                                        pos++;                                  }//while                                    //bearer bars                                  pen.Width = (float)ILHeight / 8;                                  pen.Color = ForeColor;                                  pen.Alignment = PenAlignment.Center;                                  g.DrawLine(pen' new Point(0' 0)' new Point(bitmap.Width' 0));//top                                  g.DrawLine(pen' new Point(0' ILHeight)' new Point(bitmap.Width' ILHeight));//bottom                                  g.DrawLine(pen' new Point(0' 0)' new Point(0' ILHeight));//left                                  g.DrawLine(pen' new Point(bitmap.Width' 0)' new Point(bitmap.Width' ILHeight));//right                              }//using                          }//using                            if (IncludeLabel)                              Labels.Label_ITF14(this' bitmap);                            break;                      }//case                  case TYPE.UPCA:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                          int iBarWidth = Width / Encoded_Value.Length;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // UPCA standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                                                    Font labFont = new Font(this.LabelFont != null ? this.LabelFont.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                  if (this.LabelFont != null)                                  {                                      this.LabelFont.Dispose();                                  }                                  LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                                    iBarWidth = (int)Width / Encoded_Value.Length;                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_UPCA(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  case TYPE.EAN13:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // EAN13 standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                    Font font = this.LabelFont;                                  Font labFont = new Font(font != null ? font.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                    if (font != null)                                  {                                      this.LabelFont.Dispose();                                  }                                    LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_EAN13(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  default:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            if (IncludeLabel)                          {                              // Shift drawing down if top label.                              if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                  topLabelAdjustment = this.LabelFont.Height;                                ILHeight -= this.LabelFont.Height;                          }                              bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int shiftAdjustment = 0;                          int iBarWidthModifier = 1;                            if (this.Encoded_Type == TYPE.PostNet)                              iBarWidthModifier = 2;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)Math.Round(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (this.Encoded_Type == TYPE.PostNet)                                          {                                              //draw half bars in postnet                                              if (Encoded_Value[pos] == '0')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLabelAdjustment));                                              else                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment));                                          }//if                                          else                                          {                                              if (Encoded_Value[pos] == '1')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                          pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              Labels.Label_Generic(this' bitmap);                          }//if                            break;                      }//switch              }
Magic Number,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type)              {                  case TYPE.ITF14:                      {                          // Automatically calculate the Width if applicable. Quite confusing with this                          // barcode type' and it seems this method overestimates the minimum width. But                          // at least it�s deterministic and doesn�t produce too small of a value.                          if (BarWidth.HasValue)                          {                              // Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone                              // Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20                              // Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length                              // Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)                              // Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)                              // Width = BarWidth * EncodedValue.Length / 176.9 * 241                              // Rounding error? + 1                              Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);                          }                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          if (IncludeLabel)                          {                              ILHeight -= this.LabelFont.Height;                          }                            bitmap = new Bitmap(Width' Height);                            int bearerwidth = (int)((bitmap.Width) / 12.05);                          int iquietzone = Convert.ToInt32(bitmap.Width * 0.05);                          int iBarWidth = (bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;                          int shiftAdjustment = ((bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;                            if (iBarWidth <= 0 || iquietzone <= 0)                              throw new Exception("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //fill background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen pen = new Pen(ForeColor' iBarWidth))                              {                                  pen.Alignment = PenAlignment.Right;                                    while (pos < Encoded_Value.Length)                                  {                                      //draw the appropriate color line vertically                                      if (Encoded_Value[pos] == '1')                                          g.DrawLine(pen' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));                                        pos++;                                  }//while                                    //bearer bars                                  pen.Width = (float)ILHeight / 8;                                  pen.Color = ForeColor;                                  pen.Alignment = PenAlignment.Center;                                  g.DrawLine(pen' new Point(0' 0)' new Point(bitmap.Width' 0));//top                                  g.DrawLine(pen' new Point(0' ILHeight)' new Point(bitmap.Width' ILHeight));//bottom                                  g.DrawLine(pen' new Point(0' 0)' new Point(0' ILHeight));//left                                  g.DrawLine(pen' new Point(bitmap.Width' 0)' new Point(bitmap.Width' ILHeight));//right                              }//using                          }//using                            if (IncludeLabel)                              Labels.Label_ITF14(this' bitmap);                            break;                      }//case                  case TYPE.UPCA:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                          int iBarWidth = Width / Encoded_Value.Length;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // UPCA standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                                                    Font labFont = new Font(this.LabelFont != null ? this.LabelFont.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                  if (this.LabelFont != null)                                  {                                      this.LabelFont.Dispose();                                  }                                  LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                                    iBarWidth = (int)Width / Encoded_Value.Length;                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_UPCA(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  case TYPE.EAN13:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // EAN13 standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                    Font font = this.LabelFont;                                  Font labFont = new Font(font != null ? font.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                    if (font != null)                                  {                                      this.LabelFont.Dispose();                                  }                                    LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_EAN13(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  default:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            if (IncludeLabel)                          {                              // Shift drawing down if top label.                              if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                  topLabelAdjustment = this.LabelFont.Height;                                ILHeight -= this.LabelFont.Height;                          }                              bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int shiftAdjustment = 0;                          int iBarWidthModifier = 1;                            if (this.Encoded_Type == TYPE.PostNet)                              iBarWidthModifier = 2;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)Math.Round(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (this.Encoded_Type == TYPE.PostNet)                                          {                                              //draw half bars in postnet                                              if (Encoded_Value[pos] == '0')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLabelAdjustment));                                              else                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment));                                          }//if                                          else                                          {                                              if (Encoded_Value[pos] == '1')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                          pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              Labels.Label_Generic(this' bitmap);                          }//if                            break;                      }//switch              }
Magic Number,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type)              {                  case TYPE.ITF14:                      {                          // Automatically calculate the Width if applicable. Quite confusing with this                          // barcode type' and it seems this method overestimates the minimum width. But                          // at least it�s deterministic and doesn�t produce too small of a value.                          if (BarWidth.HasValue)                          {                              // Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone                              // Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20                              // Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length                              // Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)                              // Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)                              // Width = BarWidth * EncodedValue.Length / 176.9 * 241                              // Rounding error? + 1                              Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);                          }                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          if (IncludeLabel)                          {                              ILHeight -= this.LabelFont.Height;                          }                            bitmap = new Bitmap(Width' Height);                            int bearerwidth = (int)((bitmap.Width) / 12.05);                          int iquietzone = Convert.ToInt32(bitmap.Width * 0.05);                          int iBarWidth = (bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;                          int shiftAdjustment = ((bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;                            if (iBarWidth <= 0 || iquietzone <= 0)                              throw new Exception("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //fill background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen pen = new Pen(ForeColor' iBarWidth))                              {                                  pen.Alignment = PenAlignment.Right;                                    while (pos < Encoded_Value.Length)                                  {                                      //draw the appropriate color line vertically                                      if (Encoded_Value[pos] == '1')                                          g.DrawLine(pen' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));                                        pos++;                                  }//while                                    //bearer bars                                  pen.Width = (float)ILHeight / 8;                                  pen.Color = ForeColor;                                  pen.Alignment = PenAlignment.Center;                                  g.DrawLine(pen' new Point(0' 0)' new Point(bitmap.Width' 0));//top                                  g.DrawLine(pen' new Point(0' ILHeight)' new Point(bitmap.Width' ILHeight));//bottom                                  g.DrawLine(pen' new Point(0' 0)' new Point(0' ILHeight));//left                                  g.DrawLine(pen' new Point(bitmap.Width' 0)' new Point(bitmap.Width' ILHeight));//right                              }//using                          }//using                            if (IncludeLabel)                              Labels.Label_ITF14(this' bitmap);                            break;                      }//case                  case TYPE.UPCA:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                          int iBarWidth = Width / Encoded_Value.Length;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // UPCA standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                                                    Font labFont = new Font(this.LabelFont != null ? this.LabelFont.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                  if (this.LabelFont != null)                                  {                                      this.LabelFont.Dispose();                                  }                                  LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                                    iBarWidth = (int)Width / Encoded_Value.Length;                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_UPCA(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  case TYPE.EAN13:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // EAN13 standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                    Font font = this.LabelFont;                                  Font labFont = new Font(font != null ? font.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                    if (font != null)                                  {                                      this.LabelFont.Dispose();                                  }                                    LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_EAN13(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  default:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            if (IncludeLabel)                          {                              // Shift drawing down if top label.                              if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                  topLabelAdjustment = this.LabelFont.Height;                                ILHeight -= this.LabelFont.Height;                          }                              bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int shiftAdjustment = 0;                          int iBarWidthModifier = 1;                            if (this.Encoded_Type == TYPE.PostNet)                              iBarWidthModifier = 2;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)Math.Round(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (this.Encoded_Type == TYPE.PostNet)                                          {                                              //draw half bars in postnet                                              if (Encoded_Value[pos] == '0')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLabelAdjustment));                                              else                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment));                                          }//if                                          else                                          {                                              if (Encoded_Value[pos] == '1')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                          pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              Labels.Label_Generic(this' bitmap);                          }//if                            break;                      }//switch              }
Magic Number,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type)              {                  case TYPE.ITF14:                      {                          // Automatically calculate the Width if applicable. Quite confusing with this                          // barcode type' and it seems this method overestimates the minimum width. But                          // at least it�s deterministic and doesn�t produce too small of a value.                          if (BarWidth.HasValue)                          {                              // Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone                              // Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20                              // Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length                              // Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)                              // Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)                              // Width = BarWidth * EncodedValue.Length / 176.9 * 241                              // Rounding error? + 1                              Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);                          }                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          if (IncludeLabel)                          {                              ILHeight -= this.LabelFont.Height;                          }                            bitmap = new Bitmap(Width' Height);                            int bearerwidth = (int)((bitmap.Width) / 12.05);                          int iquietzone = Convert.ToInt32(bitmap.Width * 0.05);                          int iBarWidth = (bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;                          int shiftAdjustment = ((bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;                            if (iBarWidth <= 0 || iquietzone <= 0)                              throw new Exception("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //fill background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen pen = new Pen(ForeColor' iBarWidth))                              {                                  pen.Alignment = PenAlignment.Right;                                    while (pos < Encoded_Value.Length)                                  {                                      //draw the appropriate color line vertically                                      if (Encoded_Value[pos] == '1')                                          g.DrawLine(pen' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));                                        pos++;                                  }//while                                    //bearer bars                                  pen.Width = (float)ILHeight / 8;                                  pen.Color = ForeColor;                                  pen.Alignment = PenAlignment.Center;                                  g.DrawLine(pen' new Point(0' 0)' new Point(bitmap.Width' 0));//top                                  g.DrawLine(pen' new Point(0' ILHeight)' new Point(bitmap.Width' ILHeight));//bottom                                  g.DrawLine(pen' new Point(0' 0)' new Point(0' ILHeight));//left                                  g.DrawLine(pen' new Point(bitmap.Width' 0)' new Point(bitmap.Width' ILHeight));//right                              }//using                          }//using                            if (IncludeLabel)                              Labels.Label_ITF14(this' bitmap);                            break;                      }//case                  case TYPE.UPCA:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                          int iBarWidth = Width / Encoded_Value.Length;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // UPCA standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                                                    Font labFont = new Font(this.LabelFont != null ? this.LabelFont.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                  if (this.LabelFont != null)                                  {                                      this.LabelFont.Dispose();                                  }                                  LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                                    iBarWidth = (int)Width / Encoded_Value.Length;                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_UPCA(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  case TYPE.EAN13:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // EAN13 standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                    Font font = this.LabelFont;                                  Font labFont = new Font(font != null ? font.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                    if (font != null)                                  {                                      this.LabelFont.Dispose();                                  }                                    LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_EAN13(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  default:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            if (IncludeLabel)                          {                              // Shift drawing down if top label.                              if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                  topLabelAdjustment = this.LabelFont.Height;                                ILHeight -= this.LabelFont.Height;                          }                              bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int shiftAdjustment = 0;                          int iBarWidthModifier = 1;                            if (this.Encoded_Type == TYPE.PostNet)                              iBarWidthModifier = 2;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)Math.Round(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (this.Encoded_Type == TYPE.PostNet)                                          {                                              //draw half bars in postnet                                              if (Encoded_Value[pos] == '0')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLabelAdjustment));                                              else                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment));                                          }//if                                          else                                          {                                              if (Encoded_Value[pos] == '1')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                          pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              Labels.Label_Generic(this' bitmap);                          }//if                            break;                      }//switch              }
Magic Number,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type)              {                  case TYPE.ITF14:                      {                          // Automatically calculate the Width if applicable. Quite confusing with this                          // barcode type' and it seems this method overestimates the minimum width. But                          // at least it�s deterministic and doesn�t produce too small of a value.                          if (BarWidth.HasValue)                          {                              // Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone                              // Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20                              // Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length                              // Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)                              // Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)                              // Width = BarWidth * EncodedValue.Length / 176.9 * 241                              // Rounding error? + 1                              Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);                          }                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          if (IncludeLabel)                          {                              ILHeight -= this.LabelFont.Height;                          }                            bitmap = new Bitmap(Width' Height);                            int bearerwidth = (int)((bitmap.Width) / 12.05);                          int iquietzone = Convert.ToInt32(bitmap.Width * 0.05);                          int iBarWidth = (bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;                          int shiftAdjustment = ((bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;                            if (iBarWidth <= 0 || iquietzone <= 0)                              throw new Exception("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //fill background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen pen = new Pen(ForeColor' iBarWidth))                              {                                  pen.Alignment = PenAlignment.Right;                                    while (pos < Encoded_Value.Length)                                  {                                      //draw the appropriate color line vertically                                      if (Encoded_Value[pos] == '1')                                          g.DrawLine(pen' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));                                        pos++;                                  }//while                                    //bearer bars                                  pen.Width = (float)ILHeight / 8;                                  pen.Color = ForeColor;                                  pen.Alignment = PenAlignment.Center;                                  g.DrawLine(pen' new Point(0' 0)' new Point(bitmap.Width' 0));//top                                  g.DrawLine(pen' new Point(0' ILHeight)' new Point(bitmap.Width' ILHeight));//bottom                                  g.DrawLine(pen' new Point(0' 0)' new Point(0' ILHeight));//left                                  g.DrawLine(pen' new Point(bitmap.Width' 0)' new Point(bitmap.Width' ILHeight));//right                              }//using                          }//using                            if (IncludeLabel)                              Labels.Label_ITF14(this' bitmap);                            break;                      }//case                  case TYPE.UPCA:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                          int iBarWidth = Width / Encoded_Value.Length;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // UPCA standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                                                    Font labFont = new Font(this.LabelFont != null ? this.LabelFont.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                  if (this.LabelFont != null)                                  {                                      this.LabelFont.Dispose();                                  }                                  LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                                    iBarWidth = (int)Width / Encoded_Value.Length;                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_UPCA(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  case TYPE.EAN13:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // EAN13 standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                    Font font = this.LabelFont;                                  Font labFont = new Font(font != null ? font.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                    if (font != null)                                  {                                      this.LabelFont.Dispose();                                  }                                    LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_EAN13(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  default:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            if (IncludeLabel)                          {                              // Shift drawing down if top label.                              if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                  topLabelAdjustment = this.LabelFont.Height;                                ILHeight -= this.LabelFont.Height;                          }                              bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int shiftAdjustment = 0;                          int iBarWidthModifier = 1;                            if (this.Encoded_Type == TYPE.PostNet)                              iBarWidthModifier = 2;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)Math.Round(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (this.Encoded_Type == TYPE.PostNet)                                          {                                              //draw half bars in postnet                                              if (Encoded_Value[pos] == '0')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLabelAdjustment));                                              else                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment));                                          }//if                                          else                                          {                                              if (Encoded_Value[pos] == '1')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                          pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              Labels.Label_Generic(this' bitmap);                          }//if                            break;                      }//switch              }
Magic Number,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type)              {                  case TYPE.ITF14:                      {                          // Automatically calculate the Width if applicable. Quite confusing with this                          // barcode type' and it seems this method overestimates the minimum width. But                          // at least it�s deterministic and doesn�t produce too small of a value.                          if (BarWidth.HasValue)                          {                              // Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone                              // Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20                              // Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length                              // Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)                              // Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)                              // Width = BarWidth * EncodedValue.Length / 176.9 * 241                              // Rounding error? + 1                              Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);                          }                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          if (IncludeLabel)                          {                              ILHeight -= this.LabelFont.Height;                          }                            bitmap = new Bitmap(Width' Height);                            int bearerwidth = (int)((bitmap.Width) / 12.05);                          int iquietzone = Convert.ToInt32(bitmap.Width * 0.05);                          int iBarWidth = (bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;                          int shiftAdjustment = ((bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;                            if (iBarWidth <= 0 || iquietzone <= 0)                              throw new Exception("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //fill background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen pen = new Pen(ForeColor' iBarWidth))                              {                                  pen.Alignment = PenAlignment.Right;                                    while (pos < Encoded_Value.Length)                                  {                                      //draw the appropriate color line vertically                                      if (Encoded_Value[pos] == '1')                                          g.DrawLine(pen' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));                                        pos++;                                  }//while                                    //bearer bars                                  pen.Width = (float)ILHeight / 8;                                  pen.Color = ForeColor;                                  pen.Alignment = PenAlignment.Center;                                  g.DrawLine(pen' new Point(0' 0)' new Point(bitmap.Width' 0));//top                                  g.DrawLine(pen' new Point(0' ILHeight)' new Point(bitmap.Width' ILHeight));//bottom                                  g.DrawLine(pen' new Point(0' 0)' new Point(0' ILHeight));//left                                  g.DrawLine(pen' new Point(bitmap.Width' 0)' new Point(bitmap.Width' ILHeight));//right                              }//using                          }//using                            if (IncludeLabel)                              Labels.Label_ITF14(this' bitmap);                            break;                      }//case                  case TYPE.UPCA:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                          int iBarWidth = Width / Encoded_Value.Length;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // UPCA standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                                                    Font labFont = new Font(this.LabelFont != null ? this.LabelFont.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                  if (this.LabelFont != null)                                  {                                      this.LabelFont.Dispose();                                  }                                  LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                                    iBarWidth = (int)Width / Encoded_Value.Length;                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_UPCA(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  case TYPE.EAN13:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // EAN13 standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                    Font font = this.LabelFont;                                  Font labFont = new Font(font != null ? font.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                    if (font != null)                                  {                                      this.LabelFont.Dispose();                                  }                                    LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_EAN13(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  default:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            if (IncludeLabel)                          {                              // Shift drawing down if top label.                              if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                  topLabelAdjustment = this.LabelFont.Height;                                ILHeight -= this.LabelFont.Height;                          }                              bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int shiftAdjustment = 0;                          int iBarWidthModifier = 1;                            if (this.Encoded_Type == TYPE.PostNet)                              iBarWidthModifier = 2;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)Math.Round(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (this.Encoded_Type == TYPE.PostNet)                                          {                                              //draw half bars in postnet                                              if (Encoded_Value[pos] == '0')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLabelAdjustment));                                              else                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment));                                          }//if                                          else                                          {                                              if (Encoded_Value[pos] == '1')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                          pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              Labels.Label_Generic(this' bitmap);                          }//if                            break;                      }//switch              }
Magic Number,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type)              {                  case TYPE.ITF14:                      {                          // Automatically calculate the Width if applicable. Quite confusing with this                          // barcode type' and it seems this method overestimates the minimum width. But                          // at least it�s deterministic and doesn�t produce too small of a value.                          if (BarWidth.HasValue)                          {                              // Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone                              // Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20                              // Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length                              // Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)                              // Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)                              // Width = BarWidth * EncodedValue.Length / 176.9 * 241                              // Rounding error? + 1                              Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);                          }                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          if (IncludeLabel)                          {                              ILHeight -= this.LabelFont.Height;                          }                            bitmap = new Bitmap(Width' Height);                            int bearerwidth = (int)((bitmap.Width) / 12.05);                          int iquietzone = Convert.ToInt32(bitmap.Width * 0.05);                          int iBarWidth = (bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;                          int shiftAdjustment = ((bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;                            if (iBarWidth <= 0 || iquietzone <= 0)                              throw new Exception("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //fill background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen pen = new Pen(ForeColor' iBarWidth))                              {                                  pen.Alignment = PenAlignment.Right;                                    while (pos < Encoded_Value.Length)                                  {                                      //draw the appropriate color line vertically                                      if (Encoded_Value[pos] == '1')                                          g.DrawLine(pen' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));                                        pos++;                                  }//while                                    //bearer bars                                  pen.Width = (float)ILHeight / 8;                                  pen.Color = ForeColor;                                  pen.Alignment = PenAlignment.Center;                                  g.DrawLine(pen' new Point(0' 0)' new Point(bitmap.Width' 0));//top                                  g.DrawLine(pen' new Point(0' ILHeight)' new Point(bitmap.Width' ILHeight));//bottom                                  g.DrawLine(pen' new Point(0' 0)' new Point(0' ILHeight));//left                                  g.DrawLine(pen' new Point(bitmap.Width' 0)' new Point(bitmap.Width' ILHeight));//right                              }//using                          }//using                            if (IncludeLabel)                              Labels.Label_ITF14(this' bitmap);                            break;                      }//case                  case TYPE.UPCA:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                          int iBarWidth = Width / Encoded_Value.Length;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // UPCA standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                                                    Font labFont = new Font(this.LabelFont != null ? this.LabelFont.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                  if (this.LabelFont != null)                                  {                                      this.LabelFont.Dispose();                                  }                                  LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                                    iBarWidth = (int)Width / Encoded_Value.Length;                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_UPCA(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  case TYPE.EAN13:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // EAN13 standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                    Font font = this.LabelFont;                                  Font labFont = new Font(font != null ? font.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                    if (font != null)                                  {                                      this.LabelFont.Dispose();                                  }                                    LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_EAN13(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  default:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            if (IncludeLabel)                          {                              // Shift drawing down if top label.                              if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                  topLabelAdjustment = this.LabelFont.Height;                                ILHeight -= this.LabelFont.Height;                          }                              bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int shiftAdjustment = 0;                          int iBarWidthModifier = 1;                            if (this.Encoded_Type == TYPE.PostNet)                              iBarWidthModifier = 2;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)Math.Round(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (this.Encoded_Type == TYPE.PostNet)                                          {                                              //draw half bars in postnet                                              if (Encoded_Value[pos] == '0')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLabelAdjustment));                                              else                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment));                                          }//if                                          else                                          {                                              if (Encoded_Value[pos] == '1')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                          pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              Labels.Label_Generic(this' bitmap);                          }//if                            break;                      }//switch              }
Magic Number,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type)              {                  case TYPE.ITF14:                      {                          // Automatically calculate the Width if applicable. Quite confusing with this                          // barcode type' and it seems this method overestimates the minimum width. But                          // at least it�s deterministic and doesn�t produce too small of a value.                          if (BarWidth.HasValue)                          {                              // Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone                              // Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20                              // Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length                              // Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)                              // Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)                              // Width = BarWidth * EncodedValue.Length / 176.9 * 241                              // Rounding error? + 1                              Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);                          }                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          if (IncludeLabel)                          {                              ILHeight -= this.LabelFont.Height;                          }                            bitmap = new Bitmap(Width' Height);                            int bearerwidth = (int)((bitmap.Width) / 12.05);                          int iquietzone = Convert.ToInt32(bitmap.Width * 0.05);                          int iBarWidth = (bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;                          int shiftAdjustment = ((bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;                            if (iBarWidth <= 0 || iquietzone <= 0)                              throw new Exception("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //fill background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen pen = new Pen(ForeColor' iBarWidth))                              {                                  pen.Alignment = PenAlignment.Right;                                    while (pos < Encoded_Value.Length)                                  {                                      //draw the appropriate color line vertically                                      if (Encoded_Value[pos] == '1')                                          g.DrawLine(pen' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));                                        pos++;                                  }//while                                    //bearer bars                                  pen.Width = (float)ILHeight / 8;                                  pen.Color = ForeColor;                                  pen.Alignment = PenAlignment.Center;                                  g.DrawLine(pen' new Point(0' 0)' new Point(bitmap.Width' 0));//top                                  g.DrawLine(pen' new Point(0' ILHeight)' new Point(bitmap.Width' ILHeight));//bottom                                  g.DrawLine(pen' new Point(0' 0)' new Point(0' ILHeight));//left                                  g.DrawLine(pen' new Point(bitmap.Width' 0)' new Point(bitmap.Width' ILHeight));//right                              }//using                          }//using                            if (IncludeLabel)                              Labels.Label_ITF14(this' bitmap);                            break;                      }//case                  case TYPE.UPCA:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                          int iBarWidth = Width / Encoded_Value.Length;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // UPCA standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                                                    Font labFont = new Font(this.LabelFont != null ? this.LabelFont.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                  if (this.LabelFont != null)                                  {                                      this.LabelFont.Dispose();                                  }                                  LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                                    iBarWidth = (int)Width / Encoded_Value.Length;                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_UPCA(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  case TYPE.EAN13:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // EAN13 standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                    Font font = this.LabelFont;                                  Font labFont = new Font(font != null ? font.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                    if (font != null)                                  {                                      this.LabelFont.Dispose();                                  }                                    LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_EAN13(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  default:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            if (IncludeLabel)                          {                              // Shift drawing down if top label.                              if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                  topLabelAdjustment = this.LabelFont.Height;                                ILHeight -= this.LabelFont.Height;                          }                              bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int shiftAdjustment = 0;                          int iBarWidthModifier = 1;                            if (this.Encoded_Type == TYPE.PostNet)                              iBarWidthModifier = 2;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)Math.Round(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (this.Encoded_Type == TYPE.PostNet)                                          {                                              //draw half bars in postnet                                              if (Encoded_Value[pos] == '0')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLabelAdjustment));                                              else                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment));                                          }//if                                          else                                          {                                              if (Encoded_Value[pos] == '1')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                          pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              Labels.Label_Generic(this' bitmap);                          }//if                            break;                      }//switch              }
Magic Number,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The following statement contains a magic number: switch (this.Encoded_Type)              {                  case TYPE.ITF14:                      {                          // Automatically calculate the Width if applicable. Quite confusing with this                          // barcode type' and it seems this method overestimates the minimum width. But                          // at least it�s deterministic and doesn�t produce too small of a value.                          if (BarWidth.HasValue)                          {                              // Width = (BarWidth * EncodedValue.Length) + bearerwidth + iquietzone                              // Width = (BarWidth * EncodedValue.Length) + 2*Width/12.05 + 2*Width/20                              // Width - 2*Width/12.05 - 2*Width/20 = BarWidth * EncodedValue.Length                              // Width = (BarWidth * EncodedValue.Length)/(1 - 2/12.05 - 2/20)                              // Width = (BarWidth * EncodedValue.Length)/((241 - 40 - 24.1)/241)                              // Width = BarWidth * EncodedValue.Length / 176.9 * 241                              // Rounding error? + 1                              Width = (int)(241 / 176.9 * Encoded_Value.Length * BarWidth.Value + 1);                          }                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          if (IncludeLabel)                          {                              ILHeight -= this.LabelFont.Height;                          }                            bitmap = new Bitmap(Width' Height);                            int bearerwidth = (int)((bitmap.Width) / 12.05);                          int iquietzone = Convert.ToInt32(bitmap.Width * 0.05);                          int iBarWidth = (bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) / Encoded_Value.Length;                          int shiftAdjustment = ((bitmap.Width - (bearerwidth * 2) - (iquietzone * 2)) % Encoded_Value.Length) / 2;                            if (iBarWidth <= 0 || iquietzone <= 0)                              throw new Exception("EGENERATE_IMAGE-3: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel or quiet zone determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //fill background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen pen = new Pen(ForeColor' iBarWidth))                              {                                  pen.Alignment = PenAlignment.Right;                                    while (pos < Encoded_Value.Length)                                  {                                      //draw the appropriate color line vertically                                      if (Encoded_Value[pos] == '1')                                          g.DrawLine(pen' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' 0)' new Point((pos * iBarWidth) + shiftAdjustment + bearerwidth + iquietzone' Height));                                        pos++;                                  }//while                                    //bearer bars                                  pen.Width = (float)ILHeight / 8;                                  pen.Color = ForeColor;                                  pen.Alignment = PenAlignment.Center;                                  g.DrawLine(pen' new Point(0' 0)' new Point(bitmap.Width' 0));//top                                  g.DrawLine(pen' new Point(0' ILHeight)' new Point(bitmap.Width' ILHeight));//bottom                                  g.DrawLine(pen' new Point(0' 0)' new Point(0' ILHeight));//left                                  g.DrawLine(pen' new Point(bitmap.Width' 0)' new Point(bitmap.Width' ILHeight));//right                              }//using                          }//using                            if (IncludeLabel)                              Labels.Label_ITF14(this' bitmap);                            break;                      }//case                  case TYPE.UPCA:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                          int iBarWidth = Width / Encoded_Value.Length;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // UPCA standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                                                    Font labFont = new Font(this.LabelFont != null ? this.LabelFont.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                  if (this.LabelFont != null)                                  {                                      this.LabelFont.Dispose();                                  }                                  LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                                    iBarWidth = (int)Width / Encoded_Value.Length;                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if ((AlternateLabel == null || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_UPCA(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  case TYPE.EAN13:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            int shiftAdjustment = 0;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  // EAN13 standardized label                                  string defTxt = RawData;                                  string labTxt = defTxt.Substring(0' 1) + "--" + defTxt.Substring(1' 6) + "--" + defTxt.Substring(7);                                    Font font = this.LabelFont;                                  Font labFont = new Font(font != null ? font.FontFamily.Name : "Arial"' Labels.getFontsize(Width' Height' labTxt)' FontStyle.Regular);                                    if (font != null)                                  {                                      this.LabelFont.Dispose();                                  }                                    LabelFont = labFont;                                    ILHeight -= (labFont.Height / 2);                              }                              else                              {                                  // Shift drawing down if top label.                                  if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                      topLabelAdjustment = this.LabelFont.Height;                                    ILHeight -= this.LabelFont.Height;                              }                          }                            bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int iBarWidthModifier = 1;                          if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (Encoded_Value[pos] == '1')                                          {                                              g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                            pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              if (((AlternateLabel == null) || RawData.StartsWith(AlternateLabel)) && _StandardizeLabel)                              {                                  Labels.Label_EAN13(this' bitmap);                              }                              else                              {                                  Labels.Label_Generic(this' bitmap);                              }                          }                            break;                      }//case                  default:                      {                          // Automatically calculate Width if applicable.                          Width = BarWidth * Encoded_Value.Length ?? Width;                            // Automatically calculate Height if applicable.                          Height = (int?)(Width / AspectRatio) ?? Height;                            int ILHeight = Height;                          int topLabelAdjustment = 0;                            if (IncludeLabel)                          {                              // Shift drawing down if top label.                              if ((LabelPosition & (LabelPositions.TOPCENTER | LabelPositions.TOPLEFT | LabelPositions.TOPRIGHT)) > 0)                                  topLabelAdjustment = this.LabelFont.Height;                                ILHeight -= this.LabelFont.Height;                          }                              bitmap = new Bitmap(Width' Height);                          int iBarWidth = Width / Encoded_Value.Length;                          int shiftAdjustment = 0;                          int iBarWidthModifier = 1;                            if (this.Encoded_Type == TYPE.PostNet)                              iBarWidthModifier = 2;                            //set alignment                          switch (Alignment)                          {                              case AlignmentPositions.LEFT:                                  shiftAdjustment = 0;                                  break;                              case AlignmentPositions.RIGHT:                                  shiftAdjustment = (Width % Encoded_Value.Length);                                  break;                              case AlignmentPositions.CENTER:                              default:                                  shiftAdjustment = (Width % Encoded_Value.Length) / 2;                                  break;                          }//switch                            if (iBarWidth <= 0)                              throw new Exception("EGENERATE_IMAGE-2: Image size specified not large enough to draw image. (Bar size determined to be less than 1 pixel)");                            //draw image                          int pos = 0;                          int halfBarWidth = (int)Math.Round(iBarWidth * 0.5);                            using (Graphics g = Graphics.FromImage(bitmap))                          {                              //clears the image and colors the entire background                              g.Clear(BackColor);                                //lines are fBarWidth wide so draw the appropriate color line vertically                              using (Pen backpen = new Pen(BackColor' iBarWidth / iBarWidthModifier))                              {                                  using (Pen pen = new Pen(ForeColor' iBarWidth / iBarWidthModifier))                                  {                                      while (pos < Encoded_Value.Length)                                      {                                          if (this.Encoded_Type == TYPE.PostNet)                                          {                                              //draw half bars in postnet                                              if (Encoded_Value[pos] == '0')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' (ILHeight / 2) + topLabelAdjustment));                                              else                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment));                                          }//if                                          else                                          {                                              if (Encoded_Value[pos] == '1')                                                  g.DrawLine(pen' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' topLabelAdjustment)' new Point(pos * iBarWidth + shiftAdjustment + halfBarWidth' ILHeight + topLabelAdjustment));                                          }                                          pos++;                                      }//while                                  }//using                              }//using                          }//using                          if (IncludeLabel)                          {                              Labels.Label_Generic(this' bitmap);                          }//if                            break;                      }//switch              }
Magic Number,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,GetSizeOfImage,The following statement contains a magic number: double MillimetersPerInch = 25.4;
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_ITF14,The following statement contains a magic number: g.FillRectangle(backBrush' new Rectangle(0' img.Height - (font.Height - 2)' img.Width' font.Height));
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_ITF14,The following statement contains a magic number: g.DrawString(Barcode.AlternateLabel == null ? Barcode.RawData : Barcode.AlternateLabel' font' foreBrush' (float)(img.Width / 2)' img.Height - font.Height + 1' f);
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_ITF14,The following statement contains a magic number: g.DrawLine(pen' new Point(0' img.Height - font.Height - 2)' new Point(img.Width' img.Height - font.Height - 2));
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_ITF14,The following statement contains a magic number: g.DrawLine(pen' new Point(0' img.Height - font.Height - 2)' new Point(img.Width' img.Height - font.Height - 2));
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_Generic,The following statement contains a magic number: switch (Barcode.LabelPosition)                      {                          case LabelPositions.BOTTOMCENTER:                              LabelX = img.Width / 2;                              LabelY = img.Height - (font.Height);                              f.Alignment = StringAlignment.Center;                              break;                          case LabelPositions.BOTTOMLEFT:                              LabelX = 0;                              LabelY = img.Height - (font.Height);                              f.Alignment = StringAlignment.Near;                              break;                          case LabelPositions.BOTTOMRIGHT:                              LabelX = img.Width;                              LabelY = img.Height - (font.Height);                              f.Alignment = StringAlignment.Far;                              break;                          case LabelPositions.TOPCENTER:                              LabelX = img.Width / 2;                              LabelY = 0;                              f.Alignment = StringAlignment.Center;                              break;                          case LabelPositions.TOPLEFT:                              LabelX = img.Width;                              LabelY = 0;                              f.Alignment = StringAlignment.Near;                              break;                          case LabelPositions.TOPRIGHT:                              LabelX = img.Width;                              LabelY = 0;                              f.Alignment = StringAlignment.Far;                              break;                      }
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_Generic,The following statement contains a magic number: switch (Barcode.LabelPosition)                      {                          case LabelPositions.BOTTOMCENTER:                              LabelX = img.Width / 2;                              LabelY = img.Height - (font.Height);                              f.Alignment = StringAlignment.Center;                              break;                          case LabelPositions.BOTTOMLEFT:                              LabelX = 0;                              LabelY = img.Height - (font.Height);                              f.Alignment = StringAlignment.Near;                              break;                          case LabelPositions.BOTTOMRIGHT:                              LabelX = img.Width;                              LabelY = img.Height - (font.Height);                              f.Alignment = StringAlignment.Far;                              break;                          case LabelPositions.TOPCENTER:                              LabelX = img.Width / 2;                              LabelY = 0;                              f.Alignment = StringAlignment.Center;                              break;                          case LabelPositions.TOPLEFT:                              LabelX = img.Width;                              LabelY = 0;                              f.Alignment = StringAlignment.Near;                              break;                          case LabelPositions.TOPRIGHT:                              LabelX = img.Width;                              LabelY = 0;                              f.Alignment = StringAlignment.Far;                              break;                      }
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_EAN13,The following statement contains a magic number: switch (Barcode.Alignment)                      {                          case AlignmentPositions.LEFT:                              shiftAdjustment = 0;                              break;                          case AlignmentPositions.RIGHT:                              shiftAdjustment = (Barcode.Width % Barcode.EncodedValue.Length);                              break;                          case AlignmentPositions.CENTER:                          default:                              shiftAdjustment = (Barcode.Width % Barcode.EncodedValue.Length) / 2;                              break;                      }
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_EAN13,The following statement contains a magic number: float w1 = iBarWidth * 4;
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_EAN13,The following statement contains a magic number: float w2 = iBarWidth * 42;
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_EAN13,The following statement contains a magic number: float w3 = iBarWidth * 42;
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_EAN13,The following statement contains a magic number: float s2 = s1 + (iBarWidth * 4);
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_EAN13,The following statement contains a magic number: float s3 = s2 + w2 + (iBarWidth * 5);
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_EAN13,The following statement contains a magic number: g.DrawString(defTxt.Substring(0' 1)' smallFont' foreBrush' new RectangleF(s1' (float)img.Height - (float)(smallFont.Height * 0.9)' (float)img.Width' (float)labFont.Height)' f);
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_EAN13,The following statement contains a magic number: g.DrawString(defTxt.Substring(1' 6)' labFont' foreBrush' new RectangleF(s2' (float)LabelY' (float)img.Width' (float)labFont.Height)' f);
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_EAN13,The following statement contains a magic number: g.DrawString(defTxt.Substring(7)' labFont' foreBrush' new RectangleF(s3 - iBarWidth' (float)LabelY' (float)img.Width' (float)labFont.Height)' f);
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_UPCA,The following statement contains a magic number: int halfBarWidth = (int)(iBarWidth * 0.5);
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_UPCA,The following statement contains a magic number: switch (Barcode.Alignment)                      {                          case AlignmentPositions.LEFT:                              shiftAdjustment = 0;                              break;                          case AlignmentPositions.RIGHT:                              shiftAdjustment = (Barcode.Width % Barcode.EncodedValue.Length);                              break;                          case AlignmentPositions.CENTER:                          default:                              shiftAdjustment = (Barcode.Width % Barcode.EncodedValue.Length) / 2;                              break;                      }
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_UPCA,The following statement contains a magic number: float w1 = iBarWidth * 4;
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_UPCA,The following statement contains a magic number: float w2 = iBarWidth * 34;
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_UPCA,The following statement contains a magic number: float w3 = iBarWidth * 34;
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_UPCA,The following statement contains a magic number: float s2 = s1 + (iBarWidth * 12);
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_UPCA,The following statement contains a magic number: float s3 = s2 + w2 + (iBarWidth * 5);
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_UPCA,The following statement contains a magic number: float s4 = s3 + w3 + (iBarWidth * 8) - halfBarWidth;
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_UPCA,The following statement contains a magic number: g.DrawString(defTxt.Substring(1' 5)' labFont' foreBrush' new RectangleF(s2 - iBarWidth' (float)LabelY' (float)img.Width' (float)labFont.Height)' f);
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_UPCA,The following statement contains a magic number: g.DrawString(defTxt.Substring(6' 5)' labFont' foreBrush' new RectangleF(s3 - iBarWidth' (float)LabelY' (float)img.Width' (float)labFont.Height)' f);
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_UPCA,The following statement contains a magic number: g.DrawString(defTxt.Substring(6' 5)' labFont' foreBrush' new RectangleF(s3 - iBarWidth' (float)LabelY' (float)img.Width' (float)labFont.Height)' f);
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_UPCA,The following statement contains a magic number: g.DrawString(defTxt.Substring(11)' smallFont' foreBrush' new RectangleF(s4' (float)img.Height - smallFont.Height' (float)img.Width' (float)labFont.Height)' f);
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,getFontsize,The following statement contains a magic number: int fontSize = 10;
Magic Number,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,getFontsize,The following statement contains a magic number: i <= 100
Magic Number,BarcodeLib.Symbologies,Codabar,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Codabar.cs,Encode_Codabar,The following statement contains a magic number: Raw_Data.Length < 2
Magic Number,BarcodeLib.Symbologies,Codabar,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Codabar.cs,Encode_Codabar,The following statement contains a magic number: Raw_Data = Raw_Data.Trim().Substring(1' RawData.Trim().Length - 2);
Magic Number,BarcodeLib.Symbologies,Code11,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code11.cs,Encode_Code11,The following statement contains a magic number: weight == 10
Magic Number,BarcodeLib.Symbologies,Code11,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code11.cs,Encode_Code11,The following statement contains a magic number: int checksumC = CTotal % 11;
Magic Number,BarcodeLib.Symbologies,Code11,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code11.cs,Encode_Code11,The following statement contains a magic number: weight == 9
Magic Number,BarcodeLib.Symbologies,Code11,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code11.cs,Encode_Code11,The following statement contains a magic number: int checksumK = KTotal % 11;
Magic Number,BarcodeLib.Symbologies,Code11,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code11.cs,Encode_Code11,The following statement contains a magic number: Raw_Data.Length >= 10
Magic Number,BarcodeLib.Symbologies,Code11,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code11.cs,Encode_Code11,The following statement contains a magic number: string result = C11_Code[11] + space;
Magic Number,BarcodeLib.Symbologies,Code11,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code11.cs,Encode_Code11,The following statement contains a magic number: int index = (c == '-' ? 10 : Int32.Parse(c.ToString()));
Magic Number,BarcodeLib.Symbologies,Code11,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code11.cs,Encode_Code11,The following statement contains a magic number: result += C11_Code[11];
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "66"' Convert.ToChar(2).ToString()' "b"' "66"' "10010000110" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "67"' Convert.ToChar(3).ToString()' "c"' "67"' "10000101100" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "68"' Convert.ToChar(4).ToString()' "d"' "68"' "10000100110" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "69"' Convert.ToChar(5).ToString()' "e"' "69"' "10110010000" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "70"' Convert.ToChar(6).ToString()' "f"' "70"' "10110000100" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "71"' Convert.ToChar(7).ToString()' "g"' "71"' "10011010000" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "72"' Convert.ToChar(8).ToString()' "h"' "72"' "10011000010" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "73"' Convert.ToChar(9).ToString()' "i"' "73"' "10000110100" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "74"' Convert.ToChar(10).ToString()' "j"' "74"' "10000110010" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "75"' Convert.ToChar(11).ToString()' "k"' "75"' "11000010010" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "76"' Convert.ToChar(12).ToString()' "l"' "76"' "11001010000" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "77"' Convert.ToChar(13).ToString()' "m"' "77"' "11110111010" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "78"' Convert.ToChar(14).ToString()' "n"' "78"' "11000010100" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "79"' Convert.ToChar(15).ToString()' "o"' "79"' "10001111010" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "80"' Convert.ToChar(16).ToString()' "p"' "80"' "10100111100" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "81"' Convert.ToChar(17).ToString()' "q"' "81"' "10010111100" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "82"' Convert.ToChar(18).ToString()' "r"' "82"' "10010011110" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "83"' Convert.ToChar(19).ToString()' "s"' "83"' "10111100100" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "84"' Convert.ToChar(20).ToString()' "t"' "84"' "10011110100" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "85"' Convert.ToChar(21).ToString()' "u"' "85"' "10011110010" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "86"' Convert.ToChar(22).ToString()' "v"' "86"' "11110100100" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "87"' Convert.ToChar(23).ToString()' "w"' "87"' "11110010100" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "88"' Convert.ToChar(24).ToString()' "x"' "88"' "11110010010" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "89"' Convert.ToChar(25).ToString()' "y"' "89"' "11011011110" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "90"' Convert.ToChar(26).ToString()' "z"' "90"' "11011110110" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "91"' Convert.ToChar(27).ToString()' "{"' "91"' "11110110110" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "92"' Convert.ToChar(28).ToString()' "|"' "92"' "10101111000" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "93"' Convert.ToChar(29).ToString()' "}"' "93"' "10100011110" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "94"' Convert.ToChar(30).ToString()' "~"' "94"' "10001011110" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "95"' Convert.ToChar(31).ToString()' Convert.ToChar(127).ToString()' "95"' "10111101000" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,init_Code128,The following statement contains a magic number: this.C128_Code.Rows.Add(new object[] { "95"' Convert.ToChar(31).ToString()' Convert.ToChar(127).ToString()' "95"' "10111101000" });
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,CalculateCheckDigit,The following statement contains a magic number: uint Remainder = (CheckSum % 103);
Magic Number,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,BreakUpDataForEncoding,The following statement contains a magic number: switch (this.type)              {                  case TYPES.A:                  case TYPES.B:                      {                          foreach (char c in Raw_Data)                              _FormattedData.Add(c.ToString());                          return;                      }                    case TYPES.C:                      {                          int indexOfFirstNumeric = -1;                          int numericCount = 0;                          for (int x = 0; x < RawData.Length; x++)                          {                              Char c = RawData[x];                              if (Char.IsNumber(c))                              {                                  numericCount++;                                  if (indexOfFirstNumeric == -1)                                  {                                      indexOfFirstNumeric = x;                                  }                              } else if (c != FNC1)                              {                                  Error("EC128-6: Only numeric values can be encoded with C128-C (Invalid char at position " + x + ").");                              }                          }                            //CODE C: adds a 0 to the front of the Raw_Data if the length is not divisible by 2                          if (numericCount % 2 == 1)                              tempRawData = tempRawData.Insert(indexOfFirstNumeric' "0");                          break;                      }              }
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(2).ToString()' "$B");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(3).ToString()' "$C");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(4).ToString()' "$D");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(5).ToString()' "$E");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(6).ToString()' "$F");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(7).ToString()' "$G");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(8).ToString()' "$H");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(9).ToString()' "$I");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(10).ToString()' "$J");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(11).ToString()' "$K");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(12).ToString()' "$L");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(13).ToString()' "$M");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(14).ToString()' "$N");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(15).ToString()' "$O");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(16).ToString()' "$P");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(17).ToString()' "$Q");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(18).ToString()' "$R");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(19).ToString()' "$S");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(20).ToString()' "$T");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(21).ToString()' "$U");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(22).ToString()' "$V");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(23).ToString()' "$W");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(24).ToString()' "$X");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(25).ToString()' "$Y");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(26).ToString()' "$Z");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(27).ToString()' "%A");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(28).ToString()' "%B");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(29).ToString()' "%C");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(30).ToString()' "%D");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(31).ToString()' "%E");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,init_ExtendedCode39,The following statement contains a magic number: ExtC39_Translation.Add(Convert.ToChar(127).ToString()' "%T");
Magic Number,BarcodeLib.Symbologies,Code39,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code39.cs,getChecksumChar,The following statement contains a magic number: return Code39_Charset[sum % 43];
Magic Number,BarcodeLib.Symbologies,Code93,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code93.cs,Add_CheckDigits,The following statement contains a magic number: curweight > 20
Magic Number,BarcodeLib.Symbologies,Code93,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code93.cs,Add_CheckDigits,The following statement contains a magic number: curweight > 15
Magic Number,BarcodeLib.Symbologies,Code93,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code93.cs,Add_CheckDigits,The following statement contains a magic number: int ChecksumValue = SUM % 47;
Magic Number,BarcodeLib.Symbologies,Code93,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code93.cs,Add_CheckDigits,The following statement contains a magic number: ChecksumValue = SUM % 47;
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Encode_EAN13,The following statement contains a magic number: Raw_Data.Length < 12 || Raw_Data.Length > 13
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Encode_EAN13,The following statement contains a magic number: Raw_Data.Length < 12 || Raw_Data.Length > 13
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Encode_EAN13,The following statement contains a magic number: pos < 6
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Encode_EAN13,The following statement contains a magic number: result += EAN_CodeC[Int32.Parse(Raw_Data[(pos++) + 6].ToString())];
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Encode_EAN13,The following statement contains a magic number: pos <= 5
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Encode_EAN13,The following statement contains a magic number: string twodigitCode = Raw_Data.Substring(0' 2);
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Encode_EAN13,The following statement contains a magic number: string threedigitCode = Raw_Data.Substring(0' 3);
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(0' 19' "US / CANADA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(20' 29' "IN STORE");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(20' 29' "IN STORE");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(30' 39' "US DRUGS");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(30' 39' "US DRUGS");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(40' 49' "Used to issue restricted circulation numbers within a geographic region (MO defined)");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(40' 49' "Used to issue restricted circulation numbers within a geographic region (MO defined)");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(50' 59' "GS1 US reserved for future use");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(50' 59' "GS1 US reserved for future use");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(60' 99' "US / CANADA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(60' 99' "US / CANADA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(100' 139' "UNITED STATES");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(100' 139' "UNITED STATES");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(200' 299' "Used to issue GS1 restricted circulation number within a geographic region (MO defined)");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(200' 299' "Used to issue GS1 restricted circulation number within a geographic region (MO defined)");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(300' 379' "FRANCE AND MONACO");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(300' 379' "FRANCE AND MONACO");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(380' 380' "BULGARIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(380' 380' "BULGARIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(383' 383' "SLOVENIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(383' 383' "SLOVENIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(385' 385' "CROATIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(385' 385' "CROATIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(387' 387' "BOSNIA AND HERZEGOVINA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(387' 387' "BOSNIA AND HERZEGOVINA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(389' 389' "MONTENEGRO");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(389' 389' "MONTENEGRO");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(400' 440' "GERMANY");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(400' 440' "GERMANY");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(450' 459' "JAPAN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(450' 459' "JAPAN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(460' 469' "RUSSIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(460' 469' "RUSSIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(470' 470' "KYRGYZSTAN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(470' 470' "KYRGYZSTAN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(471' 471' "TAIWAN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(471' 471' "TAIWAN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(474' 474' "ESTONIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(474' 474' "ESTONIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(475' 475' "LATVIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(475' 475' "LATVIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(476' 476' "AZERBAIJAN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(476' 476' "AZERBAIJAN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(477' 477' "LITHUANIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(477' 477' "LITHUANIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(478' 478' "UZBEKISTAN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(478' 478' "UZBEKISTAN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(479' 479' "SRI LANKA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(479' 479' "SRI LANKA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(480' 480' "PHILIPPINES");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(480' 480' "PHILIPPINES");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(481' 481' "BELARUS");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(481' 481' "BELARUS");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(482' 482' "UKRAINE");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(482' 482' "UKRAINE");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(483' 483' "TURKMENISTAN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(483' 483' "TURKMENISTAN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(484' 484' "MOLDOVA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(484' 484' "MOLDOVA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(485' 485' "ARMENIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(485' 485' "ARMENIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(486' 486' "GEORGIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(486' 486' "GEORGIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(487' 487' "KAZAKHSTAN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(487' 487' "KAZAKHSTAN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(488' 488' "TAJIKISTAN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(488' 488' "TAJIKISTAN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(489' 489' "HONG KONG");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(489' 489' "HONG KONG");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(490' 499' "JAPAN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(490' 499' "JAPAN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(500' 509' "UNITED KINGDOM");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(500' 509' "UNITED KINGDOM");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(520' 521' "GREECE");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(520' 521' "GREECE");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(528' 528' "LEBANON");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(528' 528' "LEBANON");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(529' 529' "CYPRUS");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(529' 529' "CYPRUS");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(530' 530' "ALBANIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(530' 530' "ALBANIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(531' 531' "MACEDONIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(531' 531' "MACEDONIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(535' 535' "MALTA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(535' 535' "MALTA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(539' 539' "REPUBLIC OF IRELAND");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(539' 539' "REPUBLIC OF IRELAND");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(540' 549' "BELGIUM AND LUXEMBOURG");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(540' 549' "BELGIUM AND LUXEMBOURG");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(560' 560' "PORTUGAL");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(560' 560' "PORTUGAL");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(569' 569' "ICELAND");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(569' 569' "ICELAND");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(570' 579' "DENMARK' FAROE ISLANDS AND GREENLAND");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(570' 579' "DENMARK' FAROE ISLANDS AND GREENLAND");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(590' 590' "POLAND");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(590' 590' "POLAND");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(594' 594' "ROMANIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(594' 594' "ROMANIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(599' 599' "HUNGARY");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(599' 599' "HUNGARY");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(600' 601' "SOUTH AFRICA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(600' 601' "SOUTH AFRICA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(603' 603' "GHANA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(603' 603' "GHANA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(604' 604' "SENEGAL");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(604' 604' "SENEGAL");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(608' 608' "BAHRAIN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(608' 608' "BAHRAIN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(609' 609' "MAURITIUS");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(609' 609' "MAURITIUS");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(611' 611' "MOROCCO");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(611' 611' "MOROCCO");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(613' 613' "ALGERIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(613' 613' "ALGERIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(615' 615' "NIGERIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(615' 615' "NIGERIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(616' 616' "KENYA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(616' 616' "KENYA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(618' 618' "IVORY COAST");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(618' 618' "IVORY COAST");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(619' 619' "TUNISIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(619' 619' "TUNISIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(620' 620' "TANZANIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(620' 620' "TANZANIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(621' 621' "SYRIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(621' 621' "SYRIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(622' 622' "EGYPT");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(622' 622' "EGYPT");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(623' 623' "BRUNEI");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(623' 623' "BRUNEI");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(624' 624' "LIBYA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(624' 624' "LIBYA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(625' 625' "JORDAN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(625' 625' "JORDAN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(626' 626' "IRAN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(626' 626' "IRAN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(627' 627' "KUWAIT");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(627' 627' "KUWAIT");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(628' 628' "SAUDI ARABIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(628' 628' "SAUDI ARABIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(629' 629' "UNITED ARAB EMIRATES");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(629' 629' "UNITED ARAB EMIRATES");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(640' 649' "FINLAND");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(640' 649' "FINLAND");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(690' 699' "CHINA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(690' 699' "CHINA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(700' 709' "NORWAY");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(700' 709' "NORWAY");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(729' 729' "ISRAEL");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(729' 729' "ISRAEL");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(730' 739' "SWEDEN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(730' 739' "SWEDEN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(740' 740' "GUATEMALA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(740' 740' "GUATEMALA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(741' 741' "EL SALVADOR");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(741' 741' "EL SALVADOR");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(742' 742' "HONDURAS");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(742' 742' "HONDURAS");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(743' 743' "NICARAGUA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(743' 743' "NICARAGUA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(744' 744' "COSTA RICA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(744' 744' "COSTA RICA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(745' 745' "PANAMA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(745' 745' "PANAMA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(746' 746' "DOMINICAN REPUBLIC");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(746' 746' "DOMINICAN REPUBLIC");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(750' 750' "MEXICO");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(750' 750' "MEXICO");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(754' 755' "CANADA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(754' 755' "CANADA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(759' 759' "VENEZUELA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(759' 759' "VENEZUELA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(760' 769' "SWITZERLAND AND LIECHTENSTEIN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(760' 769' "SWITZERLAND AND LIECHTENSTEIN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(770' 771' "COLOMBIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(770' 771' "COLOMBIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(773' 773' "URUGUAY");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(773' 773' "URUGUAY");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(775' 775' "PERU");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(775' 775' "PERU");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(777' 777' "BOLIVIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(777' 777' "BOLIVIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(778' 779' "ARGENTINA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(778' 779' "ARGENTINA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(780' 780' "CHILE");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(780' 780' "CHILE");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(784' 784' "PARAGUAY");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(784' 784' "PARAGUAY");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(786' 786' "ECUADOR");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(786' 786' "ECUADOR");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(789' 790' "BRAZIL");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(789' 790' "BRAZIL");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(800' 839' "ITALY' SAN MARINO AND VATICAN CITY");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(800' 839' "ITALY' SAN MARINO AND VATICAN CITY");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(840' 849' "SPAIN AND ANDORRA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(840' 849' "SPAIN AND ANDORRA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(850' 850' "CUBA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(850' 850' "CUBA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(858' 858' "SLOVAKIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(858' 858' "SLOVAKIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(859' 859' "CZECH REPUBLIC");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(859' 859' "CZECH REPUBLIC");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(860' 860' "SERBIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(860' 860' "SERBIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(865' 865' "MONGOLIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(865' 865' "MONGOLIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(867' 867' "NORTH KOREA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(867' 867' "NORTH KOREA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(868' 869' "TURKEY");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(868' 869' "TURKEY");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(870' 879' "NETHERLANDS");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(870' 879' "NETHERLANDS");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(880' 880' "SOUTH KOREA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(880' 880' "SOUTH KOREA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(884' 884' "CAMBODIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(884' 884' "CAMBODIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(885' 885' "THAILAND");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(885' 885' "THAILAND");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(888' 888' "SINGAPORE");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(888' 888' "SINGAPORE");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(890' 890' "INDIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(890' 890' "INDIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(893' 893' "VIETNAM");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(893' 893' "VIETNAM");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(896' 896' "PAKISTAN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(896' 896' "PAKISTAN");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(899' 899' "INDONESIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(899' 899' "INDONESIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(900' 919' "AUSTRIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(900' 919' "AUSTRIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(930' 939' "AUSTRALIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(930' 939' "AUSTRALIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(940' 949' "NEW ZEALAND");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(940' 949' "NEW ZEALAND");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(950' 950' "GS1 GLOBAL OFFICE SPECIAL APPLICATIONS");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(950' 950' "GS1 GLOBAL OFFICE SPECIAL APPLICATIONS");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(951' 951' "EPC GLOBAL SPECIAL APPLICATIONS");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(951' 951' "EPC GLOBAL SPECIAL APPLICATIONS");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(955' 955' "MALAYSIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(955' 955' "MALAYSIA");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(958' 958' "MACAU");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(958' 958' "MACAU");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(960' 961' "GS1 UK OFFICE: GTIN-8 ALLOCATIONS");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(960' 961' "GS1 UK OFFICE: GTIN-8 ALLOCATIONS");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(962' 969' "GS1 GLOBAL OFFICE: GTIN-8 ALLOCATIONS");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(962' 969' "GS1 GLOBAL OFFICE: GTIN-8 ALLOCATIONS");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(977' 977' "SERIAL PUBLICATIONS (ISSN)");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(977' 977' "SERIAL PUBLICATIONS (ISSN)");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(978' 979' "BOOKLAND (ISBN) – 979-0 USED FOR SHEET MUSIC (ISMN-13' REPLACES DEPRECATED ISMN M- NUMBERS)");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(978' 979' "BOOKLAND (ISBN) – 979-0 USED FOR SHEET MUSIC (ISMN-13' REPLACES DEPRECATED ISMN M- NUMBERS)");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(980' 980' "REFUND RECEIPTS");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(980' 980' "REFUND RECEIPTS");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(981' 984' "GS1 COUPON IDENTIFICATION FOR COMMON CURRENCY AREAS");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(981' 984' "GS1 COUPON IDENTIFICATION FOR COMMON CURRENCY AREAS");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(990' 999' "GS1 COUPON IDENTIFICATION");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,Init_CountryCodes,The following statement contains a magic number: Create_CountryCodeRange(990' 999' "GS1 COUPON IDENTIFICATION");
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,CheckDigit,The following statement contains a magic number: string RawDataHolder = Raw_Data.Substring(0' 12);
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,CheckDigit,The following statement contains a magic number: i % 2 == 0
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,CheckDigit,The following statement contains a magic number: int cs = total % 10;
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,CheckDigit,The following statement contains a magic number: cs = 10 - cs;
Magic Number,BarcodeLib.Symbologies,EAN13,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN13.cs,CheckDigit,The following statement contains a magic number: cs == 10
Magic Number,BarcodeLib.Symbologies,EAN8,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN8.cs,Encode_EAN8,The following statement contains a magic number: Raw_Data.Length != 8 && Raw_Data.Length != 7
Magic Number,BarcodeLib.Symbologies,EAN8,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN8.cs,Encode_EAN8,The following statement contains a magic number: Raw_Data.Length != 8 && Raw_Data.Length != 7
Magic Number,BarcodeLib.Symbologies,EAN8,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN8.cs,Encode_EAN8,The following statement contains a magic number: i < Raw_Data.Length / 2
Magic Number,BarcodeLib.Symbologies,EAN8,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN8.cs,CheckDigit,The following statement contains a magic number: odd += Int32.Parse(Raw_Data.Substring(i' 1)) * 3;
Magic Number,BarcodeLib.Symbologies,EAN8,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN8.cs,CheckDigit,The following statement contains a magic number: i <= 6
Magic Number,BarcodeLib.Symbologies,EAN8,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN8.cs,CheckDigit,The following statement contains a magic number: i <= 5
Magic Number,BarcodeLib.Symbologies,EAN8,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN8.cs,CheckDigit,The following statement contains a magic number: int checksum = total % 10;
Magic Number,BarcodeLib.Symbologies,EAN8,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN8.cs,CheckDigit,The following statement contains a magic number: checksum = 10 - checksum;
Magic Number,BarcodeLib.Symbologies,EAN8,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN8.cs,CheckDigit,The following statement contains a magic number: checksum == 10
Magic Number,BarcodeLib.Symbologies,EAN8,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\EAN8.cs,CheckDigit,The following statement contains a magic number: Raw_Data.Length == 7
Magic Number,BarcodeLib.Symbologies,Interleaved2of5,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Interleaved2of5.cs,Encode_Interleaved2of5,The following statement contains a magic number: Raw_Data.Length % 2 != (Encoded_Type == TYPE.Interleaved2of5_Mod10 ? 1 : 0)
Magic Number,BarcodeLib.Symbologies,Interleaved2of5,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Interleaved2of5.cs,CalculateMod10CheckDigit,The following statement contains a magic number: sum += Raw_Data[i] * (even ? 3 : 1);
Magic Number,BarcodeLib.Symbologies,Interleaved2of5,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Interleaved2of5.cs,CalculateMod10CheckDigit,The following statement contains a magic number: return sum % 10;
Magic Number,BarcodeLib.Symbologies,ISBN,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\ISBN.cs,Encode_ISBN_Bookland,The following statement contains a magic number: Raw_Data = Raw_Data.Remove(9' 1);
Magic Number,BarcodeLib.Symbologies,ISBN,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\ISBN.cs,Encode_ISBN_Bookland,The following statement contains a magic number: Raw_Data.Length == 10
Magic Number,BarcodeLib.Symbologies,ISBN,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\ISBN.cs,Encode_ISBN_Bookland,The following statement contains a magic number: Raw_Data.Length == 10 || Raw_Data.Length == 9
Magic Number,BarcodeLib.Symbologies,ISBN,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\ISBN.cs,Encode_ISBN_Bookland,The following statement contains a magic number: Raw_Data.Length == 10 || Raw_Data.Length == 9
Magic Number,BarcodeLib.Symbologies,ITF14,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\ITF14.cs,Encode_ITF14,The following statement contains a magic number: Raw_Data.Length > 14 || Raw_Data.Length < 13
Magic Number,BarcodeLib.Symbologies,ITF14,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\ITF14.cs,Encode_ITF14,The following statement contains a magic number: Raw_Data.Length > 14 || Raw_Data.Length < 13
Magic Number,BarcodeLib.Symbologies,ITF14,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\ITF14.cs,CheckDigit,The following statement contains a magic number: total += temp * ((i == 0 || i % 2 == 0) ? 3 : 1);
Magic Number,BarcodeLib.Symbologies,ITF14,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\ITF14.cs,CheckDigit,The following statement contains a magic number: total += temp * ((i == 0 || i % 2 == 0) ? 3 : 1);
Magic Number,BarcodeLib.Symbologies,ITF14,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\ITF14.cs,CheckDigit,The following statement contains a magic number: int cs = total % 10;
Magic Number,BarcodeLib.Symbologies,ITF14,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\ITF14.cs,CheckDigit,The following statement contains a magic number: cs = 10 - cs;
Magic Number,BarcodeLib.Symbologies,ITF14,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\ITF14.cs,CheckDigit,The following statement contains a magic number: cs == 10
Magic Number,BarcodeLib.Symbologies,ITF14,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\ITF14.cs,CheckDigit,The following statement contains a magic number: Raw_Data.Length == 13
Magic Number,BarcodeLib.Symbologies,MSI,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: odds = Convert.ToString((Int32.Parse(odds) * 2));
Magic Number,BarcodeLib.Symbologies,MSI,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: int mod = (oddsum + evensum) % 10;
Magic Number,BarcodeLib.Symbologies,MSI,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: int checksum = mod == 0 ? 0 : 10 - mod;
Magic Number,BarcodeLib.Symbologies,MSI,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: int weight = 2;
Magic Number,BarcodeLib.Symbologies,MSI,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: weight = 2;
Magic Number,BarcodeLib.Symbologies,MSI,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: weight > 7
Magic Number,BarcodeLib.Symbologies,MSI,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: int mod = sum % 11;
Magic Number,BarcodeLib.Symbologies,MSI,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: int checksum = mod == 0 ? 0 : 11 - mod;
Magic Number,BarcodeLib.Symbologies,MSI,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: odds = Convert.ToString((Int32.Parse(odds) * 2));
Magic Number,BarcodeLib.Symbologies,MSI,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: int checksum = 10 - ((oddsum + evensum) % 10);
Magic Number,BarcodeLib.Symbologies,MSI,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\MSI.cs,Encode_MSI,The following statement contains a magic number: int checksum = 10 - ((oddsum + evensum) % 10);
Magic Number,BarcodeLib.Symbologies,Pharmacode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Pharmacode.cs,Encode_Pharmacode,The following statement contains a magic number: Math.Pow(2' index) < num/2
Magic Number,BarcodeLib.Symbologies,Pharmacode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Pharmacode.cs,Encode_Pharmacode,The following statement contains a magic number: Math.Pow(2' index) < num/2
Magic Number,BarcodeLib.Symbologies,Pharmacode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Pharmacode.cs,Encode_Pharmacode,The following statement contains a magic number: double sum = Math.Pow(2' startIndex + 1) - 2;
Magic Number,BarcodeLib.Symbologies,Pharmacode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Pharmacode.cs,Encode_Pharmacode,The following statement contains a magic number: double sum = Math.Pow(2' startIndex + 1) - 2;
Magic Number,BarcodeLib.Symbologies,Pharmacode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Pharmacode.cs,Encode_Pharmacode,The following statement contains a magic number: double power = Math.Pow(2' index);
Magic Number,BarcodeLib.Symbologies,Postnet,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Postnet.cs,Encode_Postnet,The following statement contains a magic number: switch (Raw_Data.Length)              {                  case 5:                  case 6:                  case 9:                  case 11: break;                  default: Error("EPOSTNET-2: Invalid data length. (5' 6' 9' or 11 digits only)");                       break;              }
Magic Number,BarcodeLib.Symbologies,Postnet,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Postnet.cs,Encode_Postnet,The following statement contains a magic number: switch (Raw_Data.Length)              {                  case 5:                  case 6:                  case 9:                  case 11: break;                  default: Error("EPOSTNET-2: Invalid data length. (5' 6' 9' or 11 digits only)");                       break;              }
Magic Number,BarcodeLib.Symbologies,Postnet,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Postnet.cs,Encode_Postnet,The following statement contains a magic number: switch (Raw_Data.Length)              {                  case 5:                  case 6:                  case 9:                  case 11: break;                  default: Error("EPOSTNET-2: Invalid data length. (5' 6' 9' or 11 digits only)");                       break;              }
Magic Number,BarcodeLib.Symbologies,Postnet,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Postnet.cs,Encode_Postnet,The following statement contains a magic number: switch (Raw_Data.Length)              {                  case 5:                  case 6:                  case 9:                  case 11: break;                  default: Error("EPOSTNET-2: Invalid data length. (5' 6' 9' or 11 digits only)");                       break;              }
Magic Number,BarcodeLib.Symbologies,Postnet,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Postnet.cs,Encode_Postnet,The following statement contains a magic number: int temp = checkdigitsum % 10;
Magic Number,BarcodeLib.Symbologies,Postnet,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Postnet.cs,Encode_Postnet,The following statement contains a magic number: int checkdigit = 10 - (temp == 0 ? 10 : temp);
Magic Number,BarcodeLib.Symbologies,Postnet,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Postnet.cs,Encode_Postnet,The following statement contains a magic number: int checkdigit = 10 - (temp == 0 ? 10 : temp);
Magic Number,BarcodeLib.Symbologies,Standard2of5,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Standard2of5.cs,CalculateMod10CheckDigit,The following statement contains a magic number: sum += Raw_Data[i] * (even ? 3 : 1);
Magic Number,BarcodeLib.Symbologies,Standard2of5,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Standard2of5.cs,CalculateMod10CheckDigit,The following statement contains a magic number: return sum % 10;
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,EncodeNumeric,The following statement contains a magic number: (input.Length % 2) > 0
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,EncodeNumeric,The following statement contains a magic number: output += Telepen_Code[Convert.ToChar(Int32.Parse(input.Substring(i' 2)) + 27)];
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,EncodeNumeric,The following statement contains a magic number: output += Telepen_Code[Convert.ToChar(Int32.Parse(input.Substring(i' 2)) + 27)];
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,EncodeNumeric,The following statement contains a magic number: iCheckSum += Int32.Parse(input.Substring(i' 2)) + 27;
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,EncodeNumeric,The following statement contains a magic number: iCheckSum += Int32.Parse(input.Substring(i' 2)) + 27;
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,EncodeSwitchMode,The following statement contains a magic number: iCheckSum += 16;
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,EncodeSwitchMode,The following statement contains a magic number: output += Telepen_Code[Convert.ToChar(16)];
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Calculate_Checksum,The following statement contains a magic number: return Convert.ToChar(127 - (iCheckSum % 127));
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Calculate_Checksum,The following statement contains a magic number: return Convert.ToChar(127 - (iCheckSum % 127));
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,SetEncodingSequence,The following statement contains a magic number: (Raw_Data.Length % 2) > 0
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(2)' "1110001110111010");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(3)' "1010111011101110");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(4)' "1110101110111010");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(5)' "1011100011101110");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(6)' "1000100011101110");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(7)' "1010101110111010");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(8)' "1110111000111010");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(9)' "1011101011101110");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(10)' "1110001011101110");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(11)' "1010111000111010");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(12)' "1110101011101110");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(13)' "1010001000111010");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(14)' "1000101000111010");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(15)' "1010101011101110");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(16)' "1110111010111010");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(17)' "1011101110001110");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(18)' "1110001110001110");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(19)' "1010111010111010");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(20)' "1110101110001110");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(21)' "1011100010111010");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(22)' "1000100010111010");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(23)' "1010101110001110");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(24)' "1110100010001110");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(25)' "1011101010111010");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(26)' "1110001010111010");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(27)' "1010100010001110");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(28)' "1110101010111010");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(29)' "1010001010001110");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(30)' "1000101010001110");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(31)' "1010101010111010");
Magic Number,BarcodeLib.Symbologies,Telepen,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Telepen.cs,Init_Telepen,The following statement contains a magic number: Telepen_Code.Add(Convert.ToChar(127)' "1010101010101010");
Magic Number,BarcodeLib.Symbologies,UPCA,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCA.cs,Encode_UPCA,The following statement contains a magic number: Raw_Data.Length != 11 && Raw_Data.Length != 12
Magic Number,BarcodeLib.Symbologies,UPCA,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCA.cs,Encode_UPCA,The following statement contains a magic number: Raw_Data.Length != 11 && Raw_Data.Length != 12
Magic Number,BarcodeLib.Symbologies,UPCA,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCA.cs,Encode_UPCA,The following statement contains a magic number: pos < 5
Magic Number,BarcodeLib.Symbologies,UPCA,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCA.cs,Encode_UPCA,The following statement contains a magic number: result += UPC_CodeB[Int32.Parse(Raw_Data[(pos++) + 6].ToString())];
Magic Number,BarcodeLib.Symbologies,UPCA,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCA.cs,Encode_UPCA,The following statement contains a magic number: pos < 5
Magic Number,BarcodeLib.Symbologies,UPCA,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCA.cs,CheckDigit,The following statement contains a magic number: string RawDataHolder = Raw_Data.Substring(0' 11);
Magic Number,BarcodeLib.Symbologies,UPCA,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCA.cs,CheckDigit,The following statement contains a magic number: odd += Int32.Parse(RawDataHolder.Substring(i' 1)) * 3;
Magic Number,BarcodeLib.Symbologies,UPCA,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCA.cs,CheckDigit,The following statement contains a magic number: i % 2 == 0
Magic Number,BarcodeLib.Symbologies,UPCA,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCA.cs,CheckDigit,The following statement contains a magic number: int cs = total % 10;
Magic Number,BarcodeLib.Symbologies,UPCA,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCA.cs,CheckDigit,The following statement contains a magic number: cs = 10 - cs;
Magic Number,BarcodeLib.Symbologies,UPCA,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCA.cs,CheckDigit,The following statement contains a magic number: cs == 10
Magic Number,BarcodeLib.Symbologies,UPCE,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: Raw_Data.Length != 6 && Raw_Data.Length != 8 && Raw_Data.Length != 12
Magic Number,BarcodeLib.Symbologies,UPCE,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: Raw_Data.Length != 6 && Raw_Data.Length != 8 && Raw_Data.Length != 12
Magic Number,BarcodeLib.Symbologies,UPCE,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: Raw_Data.Length != 6 && Raw_Data.Length != 8 && Raw_Data.Length != 12
Magic Number,BarcodeLib.Symbologies,UPCE,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: string Manufacturer = Raw_Data.Substring(1' 5);
Magic Number,BarcodeLib.Symbologies,UPCE,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: string ProductCode = Raw_Data.Substring(6' 5);
Magic Number,BarcodeLib.Symbologies,UPCE,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: string ProductCode = Raw_Data.Substring(6' 5);
Magic Number,BarcodeLib.Symbologies,UPCE,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: UPCECode += Manufacturer.Substring(0' 2);
Magic Number,BarcodeLib.Symbologies,UPCE,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: UPCECode += ProductCode.Substring(2' 3);
Magic Number,BarcodeLib.Symbologies,UPCE,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: UPCECode += ProductCode.Substring(2' 3);
Magic Number,BarcodeLib.Symbologies,UPCE,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: UPCECode += Manufacturer[2].ToString();
Magic Number,BarcodeLib.Symbologies,UPCE,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: Manufacturer.EndsWith("000") || Manufacturer.EndsWith("100") || Manufacturer.EndsWith("200") && Int32.Parse(ProductCode) <= 999
Magic Number,BarcodeLib.Symbologies,UPCE,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCE.cs,Encode_UPCE,The following statement contains a magic number: Raw_Data.Length == 12
Magic Number,BarcodeLib.Symbologies,UPCSupplement2,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCSupplement2.cs,Encode_UPCSupplemental_2,The following statement contains a magic number: Raw_Data.Length != 2
Magic Number,BarcodeLib.Symbologies,UPCSupplement2,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCSupplement2.cs,Encode_UPCSupplemental_2,The following statement contains a magic number: pattern = this.UPC_SUPP_2[Int32.Parse(Raw_Data.Trim()) % 4];
Magic Number,BarcodeLib.Symbologies,UPCSupplement5,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCSupplement5.cs,Encode_UPCSupplemental_5,The following statement contains a magic number: Raw_Data.Length != 5
Magic Number,BarcodeLib.Symbologies,UPCSupplement5,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCSupplement5.cs,Encode_UPCSupplemental_5,The following statement contains a magic number: odd += Int32.Parse(Raw_Data.Substring(i' 1)) * 3;
Magic Number,BarcodeLib.Symbologies,UPCSupplement5,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCSupplement5.cs,Encode_UPCSupplemental_5,The following statement contains a magic number: i <= 4
Magic Number,BarcodeLib.Symbologies,UPCSupplement5,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCSupplement5.cs,Encode_UPCSupplemental_5,The following statement contains a magic number: even += Int32.Parse(Raw_Data.Substring(i' 1)) * 9;
Magic Number,BarcodeLib.Symbologies,UPCSupplement5,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCSupplement5.cs,Encode_UPCSupplemental_5,The following statement contains a magic number: i < 4
Magic Number,BarcodeLib.Symbologies,UPCSupplement5,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\UPCSupplement5.cs,Encode_UPCSupplemental_5,The following statement contains a magic number: int cs = total % 10;
Duplicate Code,BarcodeLib,Barcode,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\BarcodeLib.cs,Generate_Image,The method contains a code clone-set at the following line numbers (starting from the method definition): ((140' 171)' (244' 275))
Missing Default,BarcodeLib,Labels,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Labels.cs,Label_Generic,The following switch statement is missing a default case: switch (Barcode.LabelPosition)                      {                          case LabelPositions.BOTTOMCENTER:                              LabelX = img.Width / 2;                              LabelY = img.Height - (font.Height);                              f.Alignment = StringAlignment.Center;                              break;                          case LabelPositions.BOTTOMLEFT:                              LabelX = 0;                              LabelY = img.Height - (font.Height);                              f.Alignment = StringAlignment.Near;                              break;                          case LabelPositions.BOTTOMRIGHT:                              LabelX = img.Width;                              LabelY = img.Height - (font.Height);                              f.Alignment = StringAlignment.Far;                              break;                          case LabelPositions.TOPCENTER:                              LabelX = img.Width / 2;                              LabelY = 0;                              f.Alignment = StringAlignment.Center;                              break;                          case LabelPositions.TOPLEFT:                              LabelX = img.Width;                              LabelY = 0;                              f.Alignment = StringAlignment.Near;                              break;                          case LabelPositions.TOPRIGHT:                              LabelX = img.Width;                              LabelY = 0;                              f.Alignment = StringAlignment.Far;                              break;                      }
Missing Default,BarcodeLib.Symbologies,Code128,D:\research\architectureSmells\repos\bbarnhill_barcodelib\BarcodeStandard\Symbologies\Code128.cs,BreakUpDataForEncoding,The following switch statement is missing a default case: switch (this.type)              {                  case TYPES.A:                  case TYPES.B:                      {                          foreach (char c in Raw_Data)                              _FormattedData.Add(c.ToString());                          return;                      }                    case TYPES.C:                      {                          int indexOfFirstNumeric = -1;                          int numericCount = 0;                          for (int x = 0; x < RawData.Length; x++)                          {                              Char c = RawData[x];                              if (Char.IsNumber(c))                              {                                  numericCount++;                                  if (indexOfFirstNumeric == -1)                                  {                                      indexOfFirstNumeric = x;                                  }                              } else if (c != FNC1)                              {                                  Error("EC128-6: Only numeric values can be encoded with C128-C (Invalid char at position " + x + ").");                              }                          }                            //CODE C: adds a 0 to the front of the Raw_Data if the length is not divisible by 2                          if (numericCount % 2 == 1)                              tempRawData = tempRawData.Insert(indexOfFirstNumeric' "0");                          break;                      }              }
