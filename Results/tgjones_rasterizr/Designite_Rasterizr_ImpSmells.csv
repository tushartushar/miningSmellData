Implementation smell,Namespace,Class,File,Method,Description
Long Method,Rasterizr.Pipeline.InputAssembler,PrimitiveAssembler,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\InputAssembler\PrimitiveAssembler.cs,GetPrimitiveStream,The method has 112 lines of code.
Complex Method,Rasterizr.Pipeline.OutputMerger,OutputMergerStage,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\OutputMerger\OutputMergerStage.cs,Execute,Cyclomatic complexity of the method is 9
Complex Method,Rasterizr.Pipeline.PixelShader,PixelShaderStage,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\PixelShader\PixelShaderStage.cs,Execute,Cyclomatic complexity of the method is 8
Long Parameter List,Rasterizr.Math,Box2D,C:\repos\tgjones_rasterizr\src\Rasterizr\Math\Box2D.cs,CheckMinMax,The method has 5 parameters. Parameters: v' minX' maxX' minY' maxY
Long Parameter List,Rasterizr.Pipeline.InputAssembler,InputAssemblerStage,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\InputAssembler\InputAssemblerStage.cs,GetVertexStreamInstanced,The method has 5 parameters. Parameters: vertexShaderInputSignature' vertexCountPerInstance' instanceCount' startVertexLocation' startInstanceLocation
Long Parameter List,Rasterizr.Pipeline.InputAssembler,InputAssemblerStage,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\InputAssembler\InputAssemblerStage.cs,GetVertexStreamIndexedInstanced,The method has 6 parameters. Parameters: vertexShaderInputSignature' indexCountPerInstance' instanceCount' startIndexLocation' baseVertexLocation' startInstanceLocation
Long Parameter List,Rasterizr.Pipeline.InputAssembler,InputAssemblerStage,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\InputAssembler\InputAssemblerStage.cs,GetVertexStreamInternal,The method has 5 parameters. Parameters: vertexShaderInputSignature' vertexCount' instanceID' vertexID' vertexBufferIndices
Long Parameter List,Rasterizr.Pipeline.InputAssembler,InputElement,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\InputAssembler\InputElement.cs,InputElement,The method has 7 parameters. Parameters: semanticName' semanticIndex' format' inputSlot' alignedByteOffset' inputSlotClass' instanceDataStepRate
Long Parameter List,Rasterizr.Pipeline.InputAssembler,InputElement,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\InputAssembler\InputElement.cs,InputElement,The method has 5 parameters. Parameters: semanticName' semanticIndex' format' inputSlot' alignedByteOffset
Long Parameter List,Rasterizr.Pipeline.OutputMerger,PixelEventArgs,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\OutputMerger\PixelEventArgs.cs,PixelEventArgs,The method has 9 parameters. Parameters: vertices' primitiveID' renderTargetArrayIndex' x' y' pixelShader' previous' result' exclusionReason
Long Parameter List,Rasterizr.Pipeline.OutputMerger,RenderTargetView,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\OutputMerger\RenderTargetView.Texture1DArrayView.cs,SetColor,The method has 5 parameters. Parameters: arrayIndex' x' y' sampleIndex' color
Long Parameter List,Rasterizr.Pipeline.OutputMerger,Texture1DArrayView,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\OutputMerger\RenderTargetView.Texture1DArrayView.cs,SetData,The method has 5 parameters. Parameters: arrayIndex' x' y' sampleIndex' value
Long Parameter List,Rasterizr.Pipeline.OutputMerger,Texture1DArrayView,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\OutputMerger\RenderTargetView.Texture1DArrayView.cs,SetData,The method has 5 parameters. Parameters: arrayIndex' x' y' sampleIndex' value
Long Parameter List,Rasterizr.Pipeline.OutputMerger,Texture1DView,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\OutputMerger\RenderTargetView.Texture1DView.cs,SetData,The method has 5 parameters. Parameters: arrayIndex' x' y' sampleIndex' value
Long Parameter List,Rasterizr.Pipeline.OutputMerger,Texture1DView,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\OutputMerger\RenderTargetView.Texture1DView.cs,SetData,The method has 5 parameters. Parameters: arrayIndex' x' y' sampleIndex' value
Long Parameter List,Rasterizr.Pipeline.OutputMerger,DepthStencilView,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\OutputMerger\DepthStencilView.Texture1DArrayView.cs,SetDepth,The method has 5 parameters. Parameters: arrayIndex' x' y' sampleIndex' depth
Long Parameter List,Rasterizr.Pipeline.OutputMerger,Texture2DArrayView,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\OutputMerger\DepthStencilView.Texture2DArrayView.cs,SetData,The method has 5 parameters. Parameters: arrayIndex' x' y' sampleIndex' value
Long Parameter List,Rasterizr.Pipeline.OutputMerger,Texture2DArrayView,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\OutputMerger\DepthStencilView.Texture2DArrayView.cs,SetData,The method has 5 parameters. Parameters: arrayIndex' x' y' sampleIndex' value
Long Parameter List,Rasterizr.Pipeline.OutputMerger,InnerResourceView,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\OutputMerger\DepthStencilView.InnerResourceView.cs,SetData,The method has 5 parameters. Parameters: arrayIndex' x' y' sampleIndex' value
Long Parameter List,Rasterizr.Pipeline.OutputMerger,InnerResourceView,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\OutputMerger\DepthStencilView.InnerResourceView.cs,SetData,The method has 5 parameters. Parameters: arrayIndex' x' y' sampleIndex' value
Long Parameter List,Rasterizr.Pipeline.OutputMerger,Texture2DView,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\OutputMerger\DepthStencilView.Texture2DView.cs,SetData,The method has 5 parameters. Parameters: arrayIndex' x' y' sampleIndex' value
Long Parameter List,Rasterizr.Pipeline.OutputMerger,Texture2DView,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\OutputMerger\DepthStencilView.Texture2DView.cs,SetData,The method has 5 parameters. Parameters: arrayIndex' x' y' sampleIndex' value
Long Parameter List,Rasterizr.Pipeline.OutputMerger,Texture3DView,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\OutputMerger\RenderTargetView.Texture3DView.cs,SetData,The method has 5 parameters. Parameters: arrayIndex' x' y' sampleIndex' value
Long Parameter List,Rasterizr.Pipeline.Rasterizer.Primitives,PrimitiveRasterizerFactory,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Primitives\PrimitiveRasterizerFactory.cs,CreateRasterizer,The method has 6 parameters. Parameters: primitiveTopology' rasterizerState' multiSampleCount' outputInputBindings' viewport' fragmentQuadFilter
Long Parameter List,Rasterizr.Pipeline.Rasterizer.Primitives,InterpolationUtility,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Primitives\InterpolationUtility.cs,Linear,The method has 6 parameters. Parameters: alpha' beta' gamma' p1' p2' p3
Long Parameter List,Rasterizr.Pipeline.Rasterizer.Primitives,InterpolationUtility,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Primitives\InterpolationUtility.cs,Linear,The method has 6 parameters. Parameters: alpha' beta' gamma' p1' p2' p3
Long Parameter List,Rasterizr.Pipeline.Rasterizer.Primitives,InterpolationUtility,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Primitives\InterpolationUtility.cs,PrecalculateW,The method has 6 parameters. Parameters: alpha' beta' gamma' p1W' p2W' p3W
Long Parameter List,Rasterizr.Pipeline.Rasterizer.Primitives,InterpolationUtility,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Primitives\InterpolationUtility.cs,Perspective,The method has 10 parameters. Parameters: alpha' beta' gamma' p1' p2' p3' p1W' p2W' p3W' w
Long Parameter List,Rasterizr.Pipeline.Rasterizer.Primitives,InterpolationUtility,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Primitives\InterpolationUtility.cs,Perspective,The method has 10 parameters. Parameters: alpha' beta' gamma' p1' p2' p3' p1W' p2W' p3W' w
Long Parameter List,Rasterizr.Pipeline.Rasterizer.Primitives,PrimitiveRasterizer,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Primitives\PrimitiveRasterizer.cs,PrimitiveRasterizer,The method has 5 parameters. Parameters: rasterizerState' multiSampleCount' outputInputBindings' viewport' fragmentFilter
Long Parameter List,Rasterizr.Pipeline.Rasterizer.Primitives,TriangleRasterizer,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Primitives\TriangleRasterizer.cs,TriangleRasterizer,The method has 5 parameters. Parameters: rasterizerState' multiSampleCount' outputInputBindings' viewport' fragmentFilter
Long Parameter List,Rasterizr.Pipeline.Rasterizer,Fragment,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Fragment.cs,Fragment,The method has 7 parameters. Parameters: vertices' primitiveID' renderTargetArrayIndex' x' y' quadLocation' isInsideViewport
Long Parameter List,Rasterizr.Pipeline.Rasterizer,RasterizerStage,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\RasterizerStage.cs,Execute,The method has 5 parameters. Parameters: inputs' primitiveTopology' previousStageOutputSignature' pixelShader' multiSampleCount
Long Parameter List,Rasterizr.Pipeline.Rasterizer,Viewport,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Viewport.cs,Viewport,The method has 6 parameters. Parameters: x' y' width' height' minZ' maxZ
Long Parameter List,Rasterizr.Resources,Texture3D,C:\repos\tgjones_rasterizr\src\Rasterizr\Resources\Texture3D.cs,GetDimensions,The method has 5 parameters. Parameters: mipLevel' width' height' depth' numberOfLevels
Long Parameter List,Rasterizr.Util,Utilities,C:\repos\tgjones_rasterizr\src\Rasterizr\Util\Utilities.cs,FromByteArray,The method has 5 parameters. Parameters: destination' destinationOffset' source' sourceOffset' countInBytes
Long Identifier,Rasterizr,Device,C:\repos\tgjones_rasterizr\src\Rasterizr\Device.cs,CreateInputLayout,The length of the parameter shaderBytecodeWithInputSignature is 32.
Long Identifier,Rasterizr.Pipeline.InputAssembler,InputLayout,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\InputAssembler\InputLayout.cs,InputLayout,The length of the parameter shaderBytecodeWithInputSignature is 32.
Long Identifier,Rasterizr.Pipeline.OutputMerger,BlendState,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\OutputMerger\BlendState.cs,,The length of the parameter _renderTargetBlendDescriptions is 30.
Long Identifier,Rasterizr.Pipeline.GeometryShader,GeometryShaderStage,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\GeometryShader\GeometryShaderStage.cs,,The length of the parameter _renderTargetArrayIndexRegister is 31.
Long Statement,Rasterizr,DeviceContext,C:\repos\tgjones_rasterizr\src\Rasterizr\DeviceContext.cs,ClearDepthStencilView,The length of the statement  "            DiagnosticUtilities.RaiseEvent(this' ClearingDepthStencilView' DiagnosticUtilities.GetID(depthStencilView)' clearFlags' depth' stencil); " is 136.
Long Statement,Rasterizr,DeviceContext,C:\repos\tgjones_rasterizr\src\Rasterizr\DeviceContext.cs,Draw,The length of the statement  "			DrawInternal(_inputAssembler.GetVertexStream(_vertexShader.Shader.Bytecode.InputSignature' vertexCount' startVertexLocation)); " is 126.
Long Statement,Rasterizr,DeviceContext,C:\repos\tgjones_rasterizr\src\Rasterizr\DeviceContext.cs,DrawIndexed,The length of the statement  "			DrawInternal(_inputAssembler.GetVertexStreamIndexed(_vertexShader.Shader.Bytecode.InputSignature' indexCount' startIndexLocation' baseVertexLocation)); " is 151.
Long Statement,Rasterizr,DeviceContext,C:\repos\tgjones_rasterizr\src\Rasterizr\DeviceContext.cs,DrawInstanced,The length of the statement  "            DiagnosticUtilities.RaiseEvent(this' DrawingInstanced' vertexCountPerInstance' instanceCount' startVertexLocation' startInstanceLocation); " is 138.
Long Statement,Rasterizr,DeviceContext,C:\repos\tgjones_rasterizr\src\Rasterizr\DeviceContext.cs,DrawInstanced,The length of the statement  "			DrawInternal(_inputAssembler.GetVertexStreamInstanced(_vertexShader.Shader.Bytecode.InputSignature' vertexCountPerInstance' " is 123.
Long Statement,Rasterizr.Pipeline.InputAssembler,InputAssemblerStage,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\InputAssembler\InputAssemblerStage.cs,GetVertexStreamInstanced,The length of the statement  "				foreach (var result in GetVertexStreamInternal(vertexShaderInputSignature' vertexCountPerInstance' i' startVertexLocation' vertexBufferIndices)) " is 144.
Long Statement,Rasterizr.Pipeline.InputAssembler,InputLayout,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\InputAssembler\InputLayout.cs,ProcessSlots,The length of the statement  "						throw new Exception(string.Format("Element[{0}]'s InputSlotClass is different from the InputSlotClass of a previously defined element at the same input slot.  All elements from a given input slot must have the same InputSlotClass and InstanceDataStepRate."' i)); " is 262.
Long Statement,Rasterizr.Pipeline.InputAssembler,InputLayout,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\InputAssembler\InputLayout.cs,ProcessSlots,The length of the statement  "						throw new Exception(string.Format("Element[{0}]'s InstanceDataStepRate is different from the InstanceDataStepRate of a previously defined element at the same input slot.  All elements from a given input slot must have the same InputSlotClass and InstanceDataStepRate."' i)); " is 274.
Long Statement,Rasterizr.Pipeline.OutputMerger,BlendState,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\OutputMerger\BlendState.cs,DoBlend,The length of the statement  "			var colorDestinationBlendFactor = GetBlendFactor(blendDescription.DestinationBlend' ref source' ref destination' ref blendFactor); " is 130.
Long Statement,Rasterizr.Pipeline.OutputMerger,BlendState,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\OutputMerger\BlendState.cs,DoBlend,The length of the statement  "			var colorSourceBlendFactor = GetBlendFactor(blendDescription.SourceBlend' ref source' ref destination' ref blendFactor); " is 120.
Long Statement,Rasterizr.Pipeline.OutputMerger,BlendState,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\OutputMerger\BlendState.cs,DoBlend,The length of the statement  "			var alphaDestinationBlendFactor = GetBlendFactor(blendDescription.DestinationAlphaBlend' ref source' ref destination' ref blendFactor); " is 135.
Long Statement,Rasterizr.Pipeline.OutputMerger,BlendState,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\OutputMerger\BlendState.cs,DoBlend,The length of the statement  "			var alphaSourceBlendFactor = GetBlendFactor(blendDescription.SourceAlphaBlend' ref source' ref destination' ref blendFactor); " is 125.
Long Statement,Rasterizr.Pipeline.Rasterizer.Primitives,TriangleRasterizer,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Primitives\TriangleRasterizer.cs,Rasterize,The length of the statement  "            //if (_alphaDenominator < degenerateThreshold || _betaDenominator < degenerateThreshold || _gammaDenominator < degenerateThreshold) " is 131.
Long Statement,Rasterizr.Pipeline.Rasterizer.Primitives,TriangleRasterizer,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Primitives\TriangleRasterizer.cs,IsSampleInsideTriangle,The length of the statement  "					return coordinates.Alpha < wireframeThreshold || coordinates.Beta < wireframeThreshold || coordinates.Gamma < wireframeThreshold; " is 129.
Long Statement,Rasterizr.Pipeline,CommonShaderStage<T>,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\CommonShaderStage.cs,SetShaderConstants,The length of the statement  "                    for (ushort j = 0; j < System.Math.Max((int) variableDefinition.ShaderType.ElementCount' 1); j++) // Element count is 0 if not an array. " is 136.
Long Statement,Rasterizr.Pipeline,CommonShaderStage<T>,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\CommonShaderStage.cs,SetShaderConstants,The length of the statement  "							    (int) variableDefinition.StartOffset + (j * variableDefinition.ShaderType.Rows * variableDefinition.ShaderType.Columns * 4) + (k * variableDefinition.ShaderType.Columns * 4)' " is 174.
Long Statement,Rasterizr.Pipeline,CommonShaderStage<T>,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\CommonShaderStage.cs,SetShaderConstants,The length of the statement  "            for (ushort i = 0; i < _shader.Bytecode.ResourceDefinition.ResourceBindings.Count(x => x.Type == ShaderInputType.Sampler); i++) " is 127.
Long Statement,Rasterizr.Pipeline,CommonShaderStage<T>,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\CommonShaderStage.cs,SetShaderConstants,The length of the statement  "			for (ushort i = 0; i < _shader.Bytecode.ResourceDefinition.ResourceBindings.Count(x => x.Type == ShaderInputType.Texture); i++) " is 127.
Long Statement,Rasterizr.Resources,Texture2D,C:\repos\tgjones_rasterizr\src\Rasterizr\Resources\Texture2D.cs,GenerateMips,The length of the statement  "							var c10 = moreDetailedMipLevel.GetData(ClampToDimension(previousLevelX + 1' moreDetailedMipLevel.Width)' previousLevelY); " is 121.
Long Statement,Rasterizr.Resources,Texture2D,C:\repos\tgjones_rasterizr\src\Rasterizr\Resources\Texture2D.cs,GenerateMips,The length of the statement  "                            var c01 = moreDetailedMipLevel.GetData(previousLevelX' ClampToDimension(previousLevelY + 1' moreDetailedMipLevel.Height)); " is 122.
Long Statement,Rasterizr.Resources,Texture2D,C:\repos\tgjones_rasterizr\src\Rasterizr\Resources\Texture2D.cs,GenerateMips,The length of the statement  "                            var c11 = moreDetailedMipLevel.GetData(ClampToDimension(previousLevelX + 1' moreDetailedMipLevel.Width)' ClampToDimension(previousLevelY + 1' moreDetailedMipLevel.Height)); " is 172.
Complex Conditional,Rasterizr.Pipeline.Rasterizer.Primitives,TriangleRasterizer,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Primitives\TriangleRasterizer.cs,Rasterize,The conditional expression  "!FragmentFilter(x' y)                              && !FragmentFilter(x + 1' y)                              && !FragmentFilter(x' y + 1)                              && !FragmentFilter(x + 1' y + 1)"  is complex.
Complex Conditional,Rasterizr.Pipeline.Rasterizer.Primitives,TriangleRasterizer,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Primitives\TriangleRasterizer.cs,Rasterize,The conditional expression  "!covered0 && !covered1 && !covered2 && !covered3"  is complex.
Complex Conditional,Rasterizr.Pipeline.Rasterizer.Primitives,TriangleRasterizer,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Primitives\TriangleRasterizer.cs,Rasterize,The conditional expression  "!covered0 && !covered1 && !covered2 && !covered3"  is complex.
Magic Number,Rasterizr,FormatHelper,C:\repos\tgjones_rasterizr\src\Rasterizr\FormatHelper.cs,SizeOfInBytes,The following statement contains a magic number: return SizeOfInBits(format) / 8;
Magic Number,Rasterizr,FormatHelper,C:\repos\tgjones_rasterizr\src\Rasterizr\FormatHelper.cs,FormatHelper,The following statement contains a magic number: InitFormat(new[] { Format.A8_UNorm' Format.R8_SInt' Format.R8_SNorm' Format.R8_Typeless' Format.R8_UInt' Format.R8_UNorm }' 8);
Magic Number,Rasterizr,FormatHelper,C:\repos\tgjones_rasterizr\src\Rasterizr\FormatHelper.cs,FormatHelper,The following statement contains a magic number: InitFormat(new[] {                   Format.B5G5R5A1_UNorm'                  Format.B5G6R5_UNorm'                  Format.D16_UNorm'                  Format.R16_Float'                  Format.R16_SInt'                  Format.R16_SNorm'                  Format.R16_Typeless'                  Format.R16_UInt'                  Format.R16_UNorm'                  Format.R8G8_SInt'                  Format.R8G8_SNorm'                  Format.R8G8_Typeless'                  Format.R8G8_UInt'                  Format.R8G8_UNorm'                  Format.B4G4R4A4_UNorm              }' 16);
Magic Number,Rasterizr,FormatHelper,C:\repos\tgjones_rasterizr\src\Rasterizr\FormatHelper.cs,FormatHelper,The following statement contains a magic number: InitFormat(new[] {                   Format.B8G8R8X8_Typeless'                  Format.B8G8R8X8_UNorm'                  Format.B8G8R8X8_UNorm_SRgb'                  Format.D24_UNorm_S8_UInt'                  Format.D32_Float'                  Format.D32_Float_S8X24_UInt'                  Format.G8R8_G8B8_UNorm'                  Format.R10G10B10_Xr_Bias_A2_UNorm'                  Format.R10G10B10A2_Typeless'                  Format.R10G10B10A2_UInt'                  Format.R10G10B10A2_UNorm'                  Format.R11G11B10_Float'                  Format.R16G16_Float'                  Format.R16G16_SInt'                  Format.R16G16_SNorm'                  Format.R16G16_Typeless'                  Format.R16G16_UInt'                  Format.R16G16_UNorm'                  Format.R24_UNorm_X8_Typeless'                  Format.R24G8_Typeless'                  Format.R32_Float'                  Format.R32_Float_X8X24_Typeless'                  Format.R32_SInt'                  Format.R32_Typeless'                  Format.R32_UInt'                  Format.R8G8_B8G8_UNorm'                  Format.R8G8B8A8_SInt'                  Format.R8G8B8A8_SNorm'                  Format.R8G8B8A8_Typeless'                  Format.R8G8B8A8_UInt'                  Format.R8G8B8A8_UNorm'                  Format.R8G8B8A8_UNorm_SRgb'                  Format.B8G8R8A8_Typeless'  				Format.B8G8R8A8_UInt'                  Format.B8G8R8A8_UNorm'                  Format.B8G8R8A8_UNorm_SRgb'                  Format.R9G9B9E5_Sharedexp'                  Format.X24_Typeless_G8_UInt'                  Format.X32_Typeless_G8X24_UInt'              }' 32);
Magic Number,Rasterizr,FormatHelper,C:\repos\tgjones_rasterizr\src\Rasterizr\FormatHelper.cs,FormatHelper,The following statement contains a magic number: InitFormat(new[] {                   Format.R16G16B16A16_Float'                  Format.R16G16B16A16_SInt'                  Format.R16G16B16A16_SNorm'                  Format.R16G16B16A16_Typeless'                  Format.R16G16B16A16_UInt'                  Format.R16G16B16A16_UNorm'                  Format.R32G32_Float'                  Format.R32G32_SInt'                  Format.R32G32_Typeless'                  Format.R32G32_UInt'                  Format.R32G8X24_Typeless'              }' 64);
Magic Number,Rasterizr,FormatHelper,C:\repos\tgjones_rasterizr\src\Rasterizr\FormatHelper.cs,FormatHelper,The following statement contains a magic number: InitFormat(new[] {                   Format.R32G32B32_Float'                  Format.R32G32B32_SInt'                  Format.R32G32B32_Typeless'                  Format.R32G32B32_UInt'              }' 96);
Magic Number,Rasterizr,FormatHelper,C:\repos\tgjones_rasterizr\src\Rasterizr\FormatHelper.cs,FormatHelper,The following statement contains a magic number: InitFormat(new[] {                   Format.R32G32B32A32_Float'                  Format.R32G32B32A32_SInt'                  Format.R32G32B32A32_Typeless'                  Format.R32G32B32A32_UInt'              }' 128);
Magic Number,Rasterizr.Pipeline.InputAssembler,IndexedVertexBufferIndex,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\InputAssembler\IndexedVertexBufferIndex.cs,GetIndex,The following statement contains a magic number: if (_indexBufferBinding.Format == Format.R32_UInt)  			{  				var data = new uint[1];  				_indexBufferBinding.Buffer.GetData(data' _offset + (index * 4)' 4);  				return (int)data[0];  			}  			else  			{  				var data = new ushort[1];  				_indexBufferBinding.Buffer.GetData(data' _offset + (index * 2)' 2);  				return data[0];  			}
Magic Number,Rasterizr.Pipeline.InputAssembler,IndexedVertexBufferIndex,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\InputAssembler\IndexedVertexBufferIndex.cs,GetIndex,The following statement contains a magic number: if (_indexBufferBinding.Format == Format.R32_UInt)  			{  				var data = new uint[1];  				_indexBufferBinding.Buffer.GetData(data' _offset + (index * 4)' 4);  				return (int)data[0];  			}  			else  			{  				var data = new ushort[1];  				_indexBufferBinding.Buffer.GetData(data' _offset + (index * 2)' 2);  				return data[0];  			}
Magic Number,Rasterizr.Pipeline.InputAssembler,IndexedVertexBufferIndex,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\InputAssembler\IndexedVertexBufferIndex.cs,GetIndex,The following statement contains a magic number: if (_indexBufferBinding.Format == Format.R32_UInt)  			{  				var data = new uint[1];  				_indexBufferBinding.Buffer.GetData(data' _offset + (index * 4)' 4);  				return (int)data[0];  			}  			else  			{  				var data = new ushort[1];  				_indexBufferBinding.Buffer.GetData(data' _offset + (index * 2)' 2);  				return data[0];  			}
Magic Number,Rasterizr.Pipeline.InputAssembler,IndexedVertexBufferIndex,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\InputAssembler\IndexedVertexBufferIndex.cs,GetIndex,The following statement contains a magic number: if (_indexBufferBinding.Format == Format.R32_UInt)  			{  				var data = new uint[1];  				_indexBufferBinding.Buffer.GetData(data' _offset + (index * 4)' 4);  				return (int)data[0];  			}  			else  			{  				var data = new ushort[1];  				_indexBufferBinding.Buffer.GetData(data' _offset + (index * 2)' 2);  				return data[0];  			}
Magic Number,Rasterizr.Pipeline.Rasterizer.Culling,ViewportCuller,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Culling\ViewportCuller.cs,ShouldCullTriangle,The following statement contains a magic number: var v2ClipCode = CalculateClipCode(ref vertices[2].Position);
Magic Number,Rasterizr.Pipeline.Rasterizer.Culling,ViewportCuller,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Culling\ViewportCuller.cs,CalculateClipCode,The following statement contains a magic number: if (position.X > w)                  result |= 2;
Magic Number,Rasterizr.Pipeline.Rasterizer.Culling,ViewportCuller,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Culling\ViewportCuller.cs,CalculateClipCode,The following statement contains a magic number: if (position.Y < -w)                  result |= 4;
Magic Number,Rasterizr.Pipeline.Rasterizer.Culling,ViewportCuller,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Culling\ViewportCuller.cs,CalculateClipCode,The following statement contains a magic number: if (position.Y > w)                  result |= 8;
Magic Number,Rasterizr.Pipeline.Rasterizer.Culling,ViewportCuller,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Culling\ViewportCuller.cs,CalculateClipCode,The following statement contains a magic number: if (position.Z < 0)                  result |= 16;
Magic Number,Rasterizr.Pipeline.Rasterizer.Culling,ViewportCuller,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Culling\ViewportCuller.cs,CalculateClipCode,The following statement contains a magic number: if (position.Z > w)                  result |= 32;
Magic Number,Rasterizr.Pipeline.Rasterizer.Primitives,TriangleRasterizer,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Primitives\TriangleRasterizer.cs,ShouldCull,The following statement contains a magic number: var c = vertices[2].Position;
Magic Number,Rasterizr.Pipeline.Rasterizer.Primitives,TriangleRasterizer,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Primitives\TriangleRasterizer.cs,Rasterize,The following statement contains a magic number: _p2 = _primitive.Vertices[2].Position;
Magic Number,Rasterizr.Pipeline.Rasterizer.Primitives,TriangleRasterizer,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Primitives\TriangleRasterizer.cs,Rasterize,The following statement contains a magic number: for (int y = startY; y < maxY; y += 2)  				for (int x = startX; x < maxX; x += 2)  				{  				    if (FragmentFilter != null)  				    {                          if (!FragmentFilter(x' y)                              && !FragmentFilter(x + 1' y)                              && !FragmentFilter(x' y + 1)                              && !FragmentFilter(x + 1' y + 1))                              continue;  				    }    				    // First check whether any fragments in this quad are covered. If not' we don't  					// need to do any (expensive) interpolation of attributes.  					var fragmentQuad = new FragmentQuad  					{  						Fragment0 = CreateFragment(x' y' FragmentQuadLocation.TopLeft' ref screenBounds)'                          Fragment1 = CreateFragment(x + 1' y' FragmentQuadLocation.TopRight' ref screenBounds)'                          Fragment2 = CreateFragment(x' y + 1' FragmentQuadLocation.BottomLeft' ref screenBounds)'                          Fragment3 = CreateFragment(x + 1' y + 1' FragmentQuadLocation.BottomRight' ref screenBounds)'  					};    					if (RasterizerState.IsMultisampleEnabled)  					{  						// For multisampling' we test coverage and interpolate attributes in two separate steps.  						// Check all samples to determine whether they are inside the triangle.  						bool covered0 = CalculateSampleCoverage(ref fragmentQuad.Fragment0);  						bool covered1 = CalculateSampleCoverage(ref fragmentQuad.Fragment1);  						bool covered2 = CalculateSampleCoverage(ref fragmentQuad.Fragment2);  						bool covered3 = CalculateSampleCoverage(ref fragmentQuad.Fragment3);    						if (!covered0 && !covered1 && !covered2 && !covered3)  							continue;    						// Otherwise' we do have at least one fragment with covered samples' so continue  						// with interpolation. We need to interpolate values for all fragments in this quad'  						// even though they may not all be covered' because we need all four fragments in order  						// to calculate derivatives correctly.  						InterpolateFragmentData(ref fragmentQuad.Fragment0);  						InterpolateFragmentData(ref fragmentQuad.Fragment1);  						InterpolateFragmentData(ref fragmentQuad.Fragment2);  						InterpolateFragmentData(ref fragmentQuad.Fragment3);  					}  					else  					{  						BarycentricCoordinates fragment0Coordinates' fragment1Coordinates' fragment2Coordinates' fragment3Coordinates;    						// For non-multisampling' we can re-use the same calculations for coverage and interpolation.  						bool covered0 = CalculateCoverageAndInterpolateFragmentData(ref fragmentQuad.Fragment0' out fragment0Coordinates);  						bool covered1 = CalculateCoverageAndInterpolateFragmentData(ref fragmentQuad.Fragment1' out fragment1Coordinates);  						bool covered2 = CalculateCoverageAndInterpolateFragmentData(ref fragmentQuad.Fragment2' out fragment2Coordinates);  						bool covered3 = CalculateCoverageAndInterpolateFragmentData(ref fragmentQuad.Fragment3' out fragment3Coordinates);    						if (!covered0 && !covered1 && !covered2 && !covered3)  							continue;    						// Create pixel shader input.  						fragmentQuad.Fragment0.Data = CreatePixelShaderInput(ref fragment0Coordinates);  						fragmentQuad.Fragment1.Data = CreatePixelShaderInput(ref fragment1Coordinates);  						fragmentQuad.Fragment2.Data = CreatePixelShaderInput(ref fragment2Coordinates);  						fragmentQuad.Fragment3.Data = CreatePixelShaderInput(ref fragment3Coordinates);  					}    					yield return fragmentQuad;  				}
Magic Number,Rasterizr.Pipeline.Rasterizer.Primitives,TriangleRasterizer,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Primitives\TriangleRasterizer.cs,Rasterize,The following statement contains a magic number: for (int y = startY; y < maxY; y += 2)  				for (int x = startX; x < maxX; x += 2)  				{  				    if (FragmentFilter != null)  				    {                          if (!FragmentFilter(x' y)                              && !FragmentFilter(x + 1' y)                              && !FragmentFilter(x' y + 1)                              && !FragmentFilter(x + 1' y + 1))                              continue;  				    }    				    // First check whether any fragments in this quad are covered. If not' we don't  					// need to do any (expensive) interpolation of attributes.  					var fragmentQuad = new FragmentQuad  					{  						Fragment0 = CreateFragment(x' y' FragmentQuadLocation.TopLeft' ref screenBounds)'                          Fragment1 = CreateFragment(x + 1' y' FragmentQuadLocation.TopRight' ref screenBounds)'                          Fragment2 = CreateFragment(x' y + 1' FragmentQuadLocation.BottomLeft' ref screenBounds)'                          Fragment3 = CreateFragment(x + 1' y + 1' FragmentQuadLocation.BottomRight' ref screenBounds)'  					};    					if (RasterizerState.IsMultisampleEnabled)  					{  						// For multisampling' we test coverage and interpolate attributes in two separate steps.  						// Check all samples to determine whether they are inside the triangle.  						bool covered0 = CalculateSampleCoverage(ref fragmentQuad.Fragment0);  						bool covered1 = CalculateSampleCoverage(ref fragmentQuad.Fragment1);  						bool covered2 = CalculateSampleCoverage(ref fragmentQuad.Fragment2);  						bool covered3 = CalculateSampleCoverage(ref fragmentQuad.Fragment3);    						if (!covered0 && !covered1 && !covered2 && !covered3)  							continue;    						// Otherwise' we do have at least one fragment with covered samples' so continue  						// with interpolation. We need to interpolate values for all fragments in this quad'  						// even though they may not all be covered' because we need all four fragments in order  						// to calculate derivatives correctly.  						InterpolateFragmentData(ref fragmentQuad.Fragment0);  						InterpolateFragmentData(ref fragmentQuad.Fragment1);  						InterpolateFragmentData(ref fragmentQuad.Fragment2);  						InterpolateFragmentData(ref fragmentQuad.Fragment3);  					}  					else  					{  						BarycentricCoordinates fragment0Coordinates' fragment1Coordinates' fragment2Coordinates' fragment3Coordinates;    						// For non-multisampling' we can re-use the same calculations for coverage and interpolation.  						bool covered0 = CalculateCoverageAndInterpolateFragmentData(ref fragmentQuad.Fragment0' out fragment0Coordinates);  						bool covered1 = CalculateCoverageAndInterpolateFragmentData(ref fragmentQuad.Fragment1' out fragment1Coordinates);  						bool covered2 = CalculateCoverageAndInterpolateFragmentData(ref fragmentQuad.Fragment2' out fragment2Coordinates);  						bool covered3 = CalculateCoverageAndInterpolateFragmentData(ref fragmentQuad.Fragment3' out fragment3Coordinates);    						if (!covered0 && !covered1 && !covered2 && !covered3)  							continue;    						// Create pixel shader input.  						fragmentQuad.Fragment0.Data = CreatePixelShaderInput(ref fragment0Coordinates);  						fragmentQuad.Fragment1.Data = CreatePixelShaderInput(ref fragment1Coordinates);  						fragmentQuad.Fragment2.Data = CreatePixelShaderInput(ref fragment2Coordinates);  						fragmentQuad.Fragment3.Data = CreatePixelShaderInput(ref fragment3Coordinates);  					}    					yield return fragmentQuad;  				}
Magic Number,Rasterizr.Pipeline.Rasterizer.Primitives,TriangleRasterizer,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Primitives\TriangleRasterizer.cs,RoundDownToEven,The following statement contains a magic number: return (value % 2 == 0) ? value : value - 1;
Magic Number,Rasterizr.Pipeline.Rasterizer.Primitives,TriangleRasterizer,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Primitives\TriangleRasterizer.cs,CalculateSampleCoverage,The following statement contains a magic number: if (multiSampleCount > 2)  				anyCoveredSamples = anyCoveredSamples || CalculateSampleCoverage(ref fragment' 2' out fragment.Samples.Sample2);
Magic Number,Rasterizr.Pipeline.Rasterizer.Primitives,TriangleRasterizer,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Primitives\TriangleRasterizer.cs,CalculateSampleCoverage,The following statement contains a magic number: if (multiSampleCount > 2)  				anyCoveredSamples = anyCoveredSamples || CalculateSampleCoverage(ref fragment' 2' out fragment.Samples.Sample2);
Magic Number,Rasterizr.Pipeline.Rasterizer.Primitives,TriangleRasterizer,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Primitives\TriangleRasterizer.cs,CalculateSampleCoverage,The following statement contains a magic number: if (multiSampleCount > 3)  				anyCoveredSamples = anyCoveredSamples || CalculateSampleCoverage(ref fragment' 3' out fragment.Samples.Sample3);
Magic Number,Rasterizr.Pipeline.Rasterizer.Primitives,TriangleRasterizer,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Primitives\TriangleRasterizer.cs,CalculateSampleCoverage,The following statement contains a magic number: if (multiSampleCount > 3)  				anyCoveredSamples = anyCoveredSamples || CalculateSampleCoverage(ref fragment' 3' out fragment.Samples.Sample3);
Magic Number,Rasterizr.Pipeline.Rasterizer.Primitives,TriangleRasterizer,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\Primitives\TriangleRasterizer.cs,CreatePixelShaderInput,The following statement contains a magic number: var v2Data = _primitive.Vertices[2].OutputData;
Magic Number,Rasterizr.Pipeline.Rasterizer,MultiSamplingUtility,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\MultiSamplingUtility.cs,GetSamplePosition,The following statement contains a magic number: switch (multiSampleCount)  			{  				case 1:                      return new Point(x + 0.5f' y + 0.5f);  				case 2:  					switch (sampleIndex)  					{  						case 0:                              return new Point(x + 0.25f' y + 0.25f);  						case 1:                              return new Point(x + 0.75f' y + 0.75f);  						default:  							throw new InvalidOperationException();  					}  				case 4:  					switch (sampleIndex)  					{  						case 0:                              return new Point(x + 0.31f' y + 0.11f);  						case 1:                              return new Point(x + 0.88f' y + 0.31f);  						case 2:                              return new Point(x + 0.68f' y + 0.88f);  						case 3:                              return new Point(x + 0.11f' y + 0.68f);  						default:  							throw new InvalidOperationException();  					}  				default:  					throw new ArgumentOutOfRangeException("multiSampleCount");  			}
Magic Number,Rasterizr.Pipeline.Rasterizer,MultiSamplingUtility,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\MultiSamplingUtility.cs,GetSamplePosition,The following statement contains a magic number: switch (multiSampleCount)  			{  				case 1:                      return new Point(x + 0.5f' y + 0.5f);  				case 2:  					switch (sampleIndex)  					{  						case 0:                              return new Point(x + 0.25f' y + 0.25f);  						case 1:                              return new Point(x + 0.75f' y + 0.75f);  						default:  							throw new InvalidOperationException();  					}  				case 4:  					switch (sampleIndex)  					{  						case 0:                              return new Point(x + 0.31f' y + 0.11f);  						case 1:                              return new Point(x + 0.88f' y + 0.31f);  						case 2:                              return new Point(x + 0.68f' y + 0.88f);  						case 3:                              return new Point(x + 0.11f' y + 0.68f);  						default:  							throw new InvalidOperationException();  					}  				default:  					throw new ArgumentOutOfRangeException("multiSampleCount");  			}
Magic Number,Rasterizr.Pipeline.Rasterizer,MultiSamplingUtility,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\MultiSamplingUtility.cs,GetSamplePosition,The following statement contains a magic number: switch (multiSampleCount)  			{  				case 1:                      return new Point(x + 0.5f' y + 0.5f);  				case 2:  					switch (sampleIndex)  					{  						case 0:                              return new Point(x + 0.25f' y + 0.25f);  						case 1:                              return new Point(x + 0.75f' y + 0.75f);  						default:  							throw new InvalidOperationException();  					}  				case 4:  					switch (sampleIndex)  					{  						case 0:                              return new Point(x + 0.31f' y + 0.11f);  						case 1:                              return new Point(x + 0.88f' y + 0.31f);  						case 2:                              return new Point(x + 0.68f' y + 0.88f);  						case 3:                              return new Point(x + 0.11f' y + 0.68f);  						default:  							throw new InvalidOperationException();  					}  				default:  					throw new ArgumentOutOfRangeException("multiSampleCount");  			}
Magic Number,Rasterizr.Pipeline.Rasterizer,MultiSamplingUtility,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\Rasterizer\MultiSamplingUtility.cs,GetSamplePosition,The following statement contains a magic number: switch (multiSampleCount)  			{  				case 1:                      return new Point(x + 0.5f' y + 0.5f);  				case 2:  					switch (sampleIndex)  					{  						case 0:                              return new Point(x + 0.25f' y + 0.25f);  						case 1:                              return new Point(x + 0.75f' y + 0.75f);  						default:  							throw new InvalidOperationException();  					}  				case 4:  					switch (sampleIndex)  					{  						case 0:                              return new Point(x + 0.31f' y + 0.11f);  						case 1:                              return new Point(x + 0.88f' y + 0.31f);  						case 2:                              return new Point(x + 0.68f' y + 0.88f);  						case 3:                              return new Point(x + 0.11f' y + 0.68f);  						default:  							throw new InvalidOperationException();  					}  				default:  					throw new ArgumentOutOfRangeException("multiSampleCount");  			}
Magic Number,Rasterizr.Pipeline,CommonShaderStage<T>,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\CommonShaderStage.cs,SetShaderConstants,The following statement contains a magic number: for (ushort i = 0; i < _shader.Bytecode.ResourceDefinition.ConstantBuffers.Count; i++)  			{  				ushort registerIndex = 0;  				var constantBufferDefinition = _shader.Bytecode.ResourceDefinition.ConstantBuffers[i];  				foreach (var variableDefinition in constantBufferDefinition.Variables)                      for (ushort j = 0; j < System.Math.Max((int) variableDefinition.ShaderType.ElementCount' 1); j++) // Element count is 0 if not an array.  					    for (ushort k = 0; k < variableDefinition.ShaderType.Rows; k++)  					    {  						    Number4 value;  						    _constantBuffers[i].GetData(out value'   							    (int) variableDefinition.StartOffset + (j * variableDefinition.ShaderType.Rows * variableDefinition.ShaderType.Columns * 4) + (k * variableDefinition.ShaderType.Columns * 4)'  							    variableDefinition.ShaderType.Columns * 4);  						    _virtualMachine.SetConstantBufferRegisterValue(  							    i' registerIndex++' ref value);  					    }  			}
Magic Number,Rasterizr.Pipeline,CommonShaderStage<T>,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\CommonShaderStage.cs,SetShaderConstants,The following statement contains a magic number: for (ushort i = 0; i < _shader.Bytecode.ResourceDefinition.ConstantBuffers.Count; i++)  			{  				ushort registerIndex = 0;  				var constantBufferDefinition = _shader.Bytecode.ResourceDefinition.ConstantBuffers[i];  				foreach (var variableDefinition in constantBufferDefinition.Variables)                      for (ushort j = 0; j < System.Math.Max((int) variableDefinition.ShaderType.ElementCount' 1); j++) // Element count is 0 if not an array.  					    for (ushort k = 0; k < variableDefinition.ShaderType.Rows; k++)  					    {  						    Number4 value;  						    _constantBuffers[i].GetData(out value'   							    (int) variableDefinition.StartOffset + (j * variableDefinition.ShaderType.Rows * variableDefinition.ShaderType.Columns * 4) + (k * variableDefinition.ShaderType.Columns * 4)'  							    variableDefinition.ShaderType.Columns * 4);  						    _virtualMachine.SetConstantBufferRegisterValue(  							    i' registerIndex++' ref value);  					    }  			}
Magic Number,Rasterizr.Pipeline,CommonShaderStage<T>,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\CommonShaderStage.cs,SetShaderConstants,The following statement contains a magic number: for (ushort i = 0; i < _shader.Bytecode.ResourceDefinition.ConstantBuffers.Count; i++)  			{  				ushort registerIndex = 0;  				var constantBufferDefinition = _shader.Bytecode.ResourceDefinition.ConstantBuffers[i];  				foreach (var variableDefinition in constantBufferDefinition.Variables)                      for (ushort j = 0; j < System.Math.Max((int) variableDefinition.ShaderType.ElementCount' 1); j++) // Element count is 0 if not an array.  					    for (ushort k = 0; k < variableDefinition.ShaderType.Rows; k++)  					    {  						    Number4 value;  						    _constantBuffers[i].GetData(out value'   							    (int) variableDefinition.StartOffset + (j * variableDefinition.ShaderType.Rows * variableDefinition.ShaderType.Columns * 4) + (k * variableDefinition.ShaderType.Columns * 4)'  							    variableDefinition.ShaderType.Columns * 4);  						    _virtualMachine.SetConstantBufferRegisterValue(  							    i' registerIndex++' ref value);  					    }  			}
Magic Number,Rasterizr.Pipeline.PixelShader,PixelShaderStage,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\PixelShader\PixelShaderStage.cs,Execute,The following statement contains a magic number: foreach (var fragmentQuadBatch in inputs.Batch(BatchSize / 4))              {                  var fragmentQuads = fragmentQuadBatch.ToList();                    var contextIndex = 0;                  foreach (var fragmentQuad in fragmentQuads)                  {                      SetShaderInputs(contextIndex + 0' 0' fragmentQuad.Fragment0.Data);                      SetShaderInputs(contextIndex + 1' 0' fragmentQuad.Fragment1.Data);                      SetShaderInputs(contextIndex + 2' 0' fragmentQuad.Fragment2.Data);                      SetShaderInputs(contextIndex + 3' 0' fragmentQuad.Fragment3.Data);                      contextIndex += 4;                  }                    VirtualMachine.Execute();                    contextIndex = 0;                  for (int i = 0; i < fragmentQuads.Count; i++)                  {                      var fragmentQuad = fragmentQuads[i];                        if (fragmentQuad.Fragment0.IsInsideViewport && fragmentQuad.Fragment0.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment0' contextIndex + 0);                      if (fragmentQuad.Fragment1.IsInsideViewport && fragmentQuad.Fragment1.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment1' contextIndex + 1);                      if (fragmentQuad.Fragment2.IsInsideViewport && fragmentQuad.Fragment2.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment2' contextIndex + 2);                      if (fragmentQuad.Fragment3.IsInsideViewport && fragmentQuad.Fragment3.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment3' contextIndex + 3);                      contextIndex += 4;                  }              }
Magic Number,Rasterizr.Pipeline.PixelShader,PixelShaderStage,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\PixelShader\PixelShaderStage.cs,Execute,The following statement contains a magic number: foreach (var fragmentQuadBatch in inputs.Batch(BatchSize / 4))              {                  var fragmentQuads = fragmentQuadBatch.ToList();                    var contextIndex = 0;                  foreach (var fragmentQuad in fragmentQuads)                  {                      SetShaderInputs(contextIndex + 0' 0' fragmentQuad.Fragment0.Data);                      SetShaderInputs(contextIndex + 1' 0' fragmentQuad.Fragment1.Data);                      SetShaderInputs(contextIndex + 2' 0' fragmentQuad.Fragment2.Data);                      SetShaderInputs(contextIndex + 3' 0' fragmentQuad.Fragment3.Data);                      contextIndex += 4;                  }                    VirtualMachine.Execute();                    contextIndex = 0;                  for (int i = 0; i < fragmentQuads.Count; i++)                  {                      var fragmentQuad = fragmentQuads[i];                        if (fragmentQuad.Fragment0.IsInsideViewport && fragmentQuad.Fragment0.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment0' contextIndex + 0);                      if (fragmentQuad.Fragment1.IsInsideViewport && fragmentQuad.Fragment1.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment1' contextIndex + 1);                      if (fragmentQuad.Fragment2.IsInsideViewport && fragmentQuad.Fragment2.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment2' contextIndex + 2);                      if (fragmentQuad.Fragment3.IsInsideViewport && fragmentQuad.Fragment3.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment3' contextIndex + 3);                      contextIndex += 4;                  }              }
Magic Number,Rasterizr.Pipeline.PixelShader,PixelShaderStage,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\PixelShader\PixelShaderStage.cs,Execute,The following statement contains a magic number: foreach (var fragmentQuadBatch in inputs.Batch(BatchSize / 4))              {                  var fragmentQuads = fragmentQuadBatch.ToList();                    var contextIndex = 0;                  foreach (var fragmentQuad in fragmentQuads)                  {                      SetShaderInputs(contextIndex + 0' 0' fragmentQuad.Fragment0.Data);                      SetShaderInputs(contextIndex + 1' 0' fragmentQuad.Fragment1.Data);                      SetShaderInputs(contextIndex + 2' 0' fragmentQuad.Fragment2.Data);                      SetShaderInputs(contextIndex + 3' 0' fragmentQuad.Fragment3.Data);                      contextIndex += 4;                  }                    VirtualMachine.Execute();                    contextIndex = 0;                  for (int i = 0; i < fragmentQuads.Count; i++)                  {                      var fragmentQuad = fragmentQuads[i];                        if (fragmentQuad.Fragment0.IsInsideViewport && fragmentQuad.Fragment0.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment0' contextIndex + 0);                      if (fragmentQuad.Fragment1.IsInsideViewport && fragmentQuad.Fragment1.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment1' contextIndex + 1);                      if (fragmentQuad.Fragment2.IsInsideViewport && fragmentQuad.Fragment2.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment2' contextIndex + 2);                      if (fragmentQuad.Fragment3.IsInsideViewport && fragmentQuad.Fragment3.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment3' contextIndex + 3);                      contextIndex += 4;                  }              }
Magic Number,Rasterizr.Pipeline.PixelShader,PixelShaderStage,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\PixelShader\PixelShaderStage.cs,Execute,The following statement contains a magic number: foreach (var fragmentQuadBatch in inputs.Batch(BatchSize / 4))              {                  var fragmentQuads = fragmentQuadBatch.ToList();                    var contextIndex = 0;                  foreach (var fragmentQuad in fragmentQuads)                  {                      SetShaderInputs(contextIndex + 0' 0' fragmentQuad.Fragment0.Data);                      SetShaderInputs(contextIndex + 1' 0' fragmentQuad.Fragment1.Data);                      SetShaderInputs(contextIndex + 2' 0' fragmentQuad.Fragment2.Data);                      SetShaderInputs(contextIndex + 3' 0' fragmentQuad.Fragment3.Data);                      contextIndex += 4;                  }                    VirtualMachine.Execute();                    contextIndex = 0;                  for (int i = 0; i < fragmentQuads.Count; i++)                  {                      var fragmentQuad = fragmentQuads[i];                        if (fragmentQuad.Fragment0.IsInsideViewport && fragmentQuad.Fragment0.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment0' contextIndex + 0);                      if (fragmentQuad.Fragment1.IsInsideViewport && fragmentQuad.Fragment1.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment1' contextIndex + 1);                      if (fragmentQuad.Fragment2.IsInsideViewport && fragmentQuad.Fragment2.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment2' contextIndex + 2);                      if (fragmentQuad.Fragment3.IsInsideViewport && fragmentQuad.Fragment3.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment3' contextIndex + 3);                      contextIndex += 4;                  }              }
Magic Number,Rasterizr.Pipeline.PixelShader,PixelShaderStage,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\PixelShader\PixelShaderStage.cs,Execute,The following statement contains a magic number: foreach (var fragmentQuadBatch in inputs.Batch(BatchSize / 4))              {                  var fragmentQuads = fragmentQuadBatch.ToList();                    var contextIndex = 0;                  foreach (var fragmentQuad in fragmentQuads)                  {                      SetShaderInputs(contextIndex + 0' 0' fragmentQuad.Fragment0.Data);                      SetShaderInputs(contextIndex + 1' 0' fragmentQuad.Fragment1.Data);                      SetShaderInputs(contextIndex + 2' 0' fragmentQuad.Fragment2.Data);                      SetShaderInputs(contextIndex + 3' 0' fragmentQuad.Fragment3.Data);                      contextIndex += 4;                  }                    VirtualMachine.Execute();                    contextIndex = 0;                  for (int i = 0; i < fragmentQuads.Count; i++)                  {                      var fragmentQuad = fragmentQuads[i];                        if (fragmentQuad.Fragment0.IsInsideViewport && fragmentQuad.Fragment0.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment0' contextIndex + 0);                      if (fragmentQuad.Fragment1.IsInsideViewport && fragmentQuad.Fragment1.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment1' contextIndex + 1);                      if (fragmentQuad.Fragment2.IsInsideViewport && fragmentQuad.Fragment2.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment2' contextIndex + 2);                      if (fragmentQuad.Fragment3.IsInsideViewport && fragmentQuad.Fragment3.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment3' contextIndex + 3);                      contextIndex += 4;                  }              }
Magic Number,Rasterizr.Pipeline.PixelShader,PixelShaderStage,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\PixelShader\PixelShaderStage.cs,Execute,The following statement contains a magic number: foreach (var fragmentQuadBatch in inputs.Batch(BatchSize / 4))              {                  var fragmentQuads = fragmentQuadBatch.ToList();                    var contextIndex = 0;                  foreach (var fragmentQuad in fragmentQuads)                  {                      SetShaderInputs(contextIndex + 0' 0' fragmentQuad.Fragment0.Data);                      SetShaderInputs(contextIndex + 1' 0' fragmentQuad.Fragment1.Data);                      SetShaderInputs(contextIndex + 2' 0' fragmentQuad.Fragment2.Data);                      SetShaderInputs(contextIndex + 3' 0' fragmentQuad.Fragment3.Data);                      contextIndex += 4;                  }                    VirtualMachine.Execute();                    contextIndex = 0;                  for (int i = 0; i < fragmentQuads.Count; i++)                  {                      var fragmentQuad = fragmentQuads[i];                        if (fragmentQuad.Fragment0.IsInsideViewport && fragmentQuad.Fragment0.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment0' contextIndex + 0);                      if (fragmentQuad.Fragment1.IsInsideViewport && fragmentQuad.Fragment1.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment1' contextIndex + 1);                      if (fragmentQuad.Fragment2.IsInsideViewport && fragmentQuad.Fragment2.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment2' contextIndex + 2);                      if (fragmentQuad.Fragment3.IsInsideViewport && fragmentQuad.Fragment3.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment3' contextIndex + 3);                      contextIndex += 4;                  }              }
Magic Number,Rasterizr.Pipeline.PixelShader,PixelShaderStage,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\PixelShader\PixelShaderStage.cs,Execute,The following statement contains a magic number: foreach (var fragmentQuadBatch in inputs.Batch(BatchSize / 4))              {                  var fragmentQuads = fragmentQuadBatch.ToList();                    var contextIndex = 0;                  foreach (var fragmentQuad in fragmentQuads)                  {                      SetShaderInputs(contextIndex + 0' 0' fragmentQuad.Fragment0.Data);                      SetShaderInputs(contextIndex + 1' 0' fragmentQuad.Fragment1.Data);                      SetShaderInputs(contextIndex + 2' 0' fragmentQuad.Fragment2.Data);                      SetShaderInputs(contextIndex + 3' 0' fragmentQuad.Fragment3.Data);                      contextIndex += 4;                  }                    VirtualMachine.Execute();                    contextIndex = 0;                  for (int i = 0; i < fragmentQuads.Count; i++)                  {                      var fragmentQuad = fragmentQuads[i];                        if (fragmentQuad.Fragment0.IsInsideViewport && fragmentQuad.Fragment0.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment0' contextIndex + 0);                      if (fragmentQuad.Fragment1.IsInsideViewport && fragmentQuad.Fragment1.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment1' contextIndex + 1);                      if (fragmentQuad.Fragment2.IsInsideViewport && fragmentQuad.Fragment2.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment2' contextIndex + 2);                      if (fragmentQuad.Fragment3.IsInsideViewport && fragmentQuad.Fragment3.Samples.AnyCovered)                          yield return GetPixel(ref fragmentQuad.Fragment3' contextIndex + 3);                      contextIndex += 4;                  }              }
Magic Number,Rasterizr.Resources,MipMapUtility,C:\repos\tgjones_rasterizr\src\Rasterizr\Resources\MipMapUtility.cs,CreateMipMaps,The following statement contains a magic number: for (int level = 0; level < mipLevels; level++)  			{  				result[level] = new Texture1D.Texture1DSubresource(width);                    width = System.Math.Max((int) System.Math.Floor(width / 2.0)' 1);  			}
Magic Number,Rasterizr.Resources,MipMapUtility,C:\repos\tgjones_rasterizr\src\Rasterizr\Resources\MipMapUtility.cs,CreateMipMaps,The following statement contains a magic number: for (int level = 0; level < mipLevels; level++)  			{  				result[level] = new Texture2D.Texture2DSubresource(width' height);    				width = System.Math.Max((int) System.Math.Floor(width / 2.0)' 1);                  height = System.Math.Max((int) System.Math.Floor(height / 2.0)' 1);  			}
Magic Number,Rasterizr.Resources,MipMapUtility,C:\repos\tgjones_rasterizr\src\Rasterizr\Resources\MipMapUtility.cs,CreateMipMaps,The following statement contains a magic number: for (int level = 0; level < mipLevels; level++)  			{  				result[level] = new Texture2D.Texture2DSubresource(width' height);    				width = System.Math.Max((int) System.Math.Floor(width / 2.0)' 1);                  height = System.Math.Max((int) System.Math.Floor(height / 2.0)' 1);  			}
Magic Number,Rasterizr.Resources,MipMapUtility,C:\repos\tgjones_rasterizr\src\Rasterizr\Resources\MipMapUtility.cs,CreateMipMaps,The following statement contains a magic number: for (int level = 0; level < mipLevels; level++)  			{  				result[level] = new Texture3D.Texture3DSubresource(width' height' depth);                    width = System.Math.Max((int) System.Math.Floor(width / 2.0)' 1);                  height = System.Math.Max((int) System.Math.Floor(height / 2.0)' 1);                  depth = System.Math.Max((int) System.Math.Floor(depth / 2.0)' 1);  			}
Magic Number,Rasterizr.Resources,MipMapUtility,C:\repos\tgjones_rasterizr\src\Rasterizr\Resources\MipMapUtility.cs,CreateMipMaps,The following statement contains a magic number: for (int level = 0; level < mipLevels; level++)  			{  				result[level] = new Texture3D.Texture3DSubresource(width' height' depth);                    width = System.Math.Max((int) System.Math.Floor(width / 2.0)' 1);                  height = System.Math.Max((int) System.Math.Floor(height / 2.0)' 1);                  depth = System.Math.Max((int) System.Math.Floor(depth / 2.0)' 1);  			}
Magic Number,Rasterizr.Resources,MipMapUtility,C:\repos\tgjones_rasterizr\src\Rasterizr\Resources\MipMapUtility.cs,CreateMipMaps,The following statement contains a magic number: for (int level = 0; level < mipLevels; level++)  			{  				result[level] = new Texture3D.Texture3DSubresource(width' height' depth);                    width = System.Math.Max((int) System.Math.Floor(width / 2.0)' 1);                  height = System.Math.Max((int) System.Math.Floor(height / 2.0)' 1);                  depth = System.Math.Max((int) System.Math.Floor(depth / 2.0)' 1);  			}
Magic Number,Rasterizr.Resources,Texture2D,C:\repos\tgjones_rasterizr\src\Rasterizr\Resources\Texture2D.cs,GenerateMips,The following statement contains a magic number: for (int i = 0; i < _description.ArraySize; i++)  				for (int mipSlice = 1; mipSlice < _subresources[0].Length; ++mipSlice)  				{  					var subresource = GetSubresource(i' mipSlice);  					int width = subresource.Width;  					int height = subresource.Height;  					for (int y = 0; y < height; ++y)  					{  						for (int x = 0; x < width; ++x)  						{  							int previousLevelX = x * 2;  							int previousLevelY = y * 2;    							var moreDetailedMipLevel = GetSubresource(i' mipSlice - 1);  							var c00 = moreDetailedMipLevel.GetData(previousLevelX' previousLevelY);  							var c10 = moreDetailedMipLevel.GetData(ClampToDimension(previousLevelX + 1' moreDetailedMipLevel.Width)' previousLevelY);                              var c01 = moreDetailedMipLevel.GetData(previousLevelX' ClampToDimension(previousLevelY + 1' moreDetailedMipLevel.Height));                              var c11 = moreDetailedMipLevel.GetData(ClampToDimension(previousLevelX + 1' moreDetailedMipLevel.Width)' ClampToDimension(previousLevelY + 1' moreDetailedMipLevel.Height));  							var interpolatedColor = Number4.Average(ref c00' ref c10' ref c01' ref c11);    						    subresource.SetData(x' y' ref interpolatedColor);  						}  					}  				}
Magic Number,Rasterizr.Resources,Texture2D,C:\repos\tgjones_rasterizr\src\Rasterizr\Resources\Texture2D.cs,GenerateMips,The following statement contains a magic number: for (int i = 0; i < _description.ArraySize; i++)  				for (int mipSlice = 1; mipSlice < _subresources[0].Length; ++mipSlice)  				{  					var subresource = GetSubresource(i' mipSlice);  					int width = subresource.Width;  					int height = subresource.Height;  					for (int y = 0; y < height; ++y)  					{  						for (int x = 0; x < width; ++x)  						{  							int previousLevelX = x * 2;  							int previousLevelY = y * 2;    							var moreDetailedMipLevel = GetSubresource(i' mipSlice - 1);  							var c00 = moreDetailedMipLevel.GetData(previousLevelX' previousLevelY);  							var c10 = moreDetailedMipLevel.GetData(ClampToDimension(previousLevelX + 1' moreDetailedMipLevel.Width)' previousLevelY);                              var c01 = moreDetailedMipLevel.GetData(previousLevelX' ClampToDimension(previousLevelY + 1' moreDetailedMipLevel.Height));                              var c11 = moreDetailedMipLevel.GetData(ClampToDimension(previousLevelX + 1' moreDetailedMipLevel.Width)' ClampToDimension(previousLevelY + 1' moreDetailedMipLevel.Height));  							var interpolatedColor = Number4.Average(ref c00' ref c10' ref c01' ref c11);    						    subresource.SetData(x' y' ref interpolatedColor);  						}  					}  				}
Missing Default,Rasterizr.Pipeline.InputAssembler,InputAssemblerStage,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\InputAssembler\InputAssemblerStage.cs,GetVertexStreamInternal,The following switch statement is missing a default case: switch (parameter.SystemValueType)  					{  						case Name.Undefined:  						case Name.Position:  							if (inputElementsKeyedByRegister == null)  								throw new Exception("InputLayout must be set in order to use these system value types.");  							var inputElement = inputElementsKeyedByRegister[(int) parameter.Register];  							vertexBufferIndices[inputElement.InputSlot].GetData(  								output.Data' inputElement.RegisterIndex'  								inputElement.AlignedByteOffset'  								FormatHelper.SizeOfInBytes(inputElement.Format));  							break;  						case Name.VertexID:  							output.Data[parameter.Register] = new Number4(output.VertexID' 0' 0' 0);  							break;  						case Name.InstanceID:  							output.Data[parameter.Register] = new Number4(output.InstanceID' 0' 0' 0);  							break;  					}
Missing Default,Rasterizr.Pipeline.OutputMerger,DepthStencilView,C:\repos\tgjones_rasterizr\src\Rasterizr\Pipeline\OutputMerger\DepthStencilView.Texture1DArrayView.cs,DepthStencilView,The following switch statement is missing a default case: switch (resource.ResourceType)  			{  				case ResourceType.Buffer:  					throw new ArgumentException("Invalid resource type for depth stencil view: " + resource.ResourceType);  			}
