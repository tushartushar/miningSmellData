Implementation smell,Namespace,Class,File,Method,Description
Long Method,Rasterizr.Toolkit.Models,ModelLoader,C:\repos\tgjones_rasterizr\src\Rasterizr.Toolkit\Models\ModelLoader.cs,AddVertexData,The method has 170 lines of code.
Complex Method,Rasterizr.Toolkit.Models,ModelLoader,C:\repos\tgjones_rasterizr\src\Rasterizr.Toolkit\Models\ModelLoader.cs,AddVertexData,Cyclomatic complexity of the method is 17
Long Parameter List,Rasterizr.Toolkit.Models,ModelLoader,C:\repos\tgjones_rasterizr\src\Rasterizr.Toolkit\Models\ModelLoader.cs,ComputeBoundingBox,The method has 5 parameters. Parameters: scene' node' min' max' transform
Long Parameter List,Rasterizr.Toolkit.Models,ModelLoader,C:\repos\tgjones_rasterizr\src\Rasterizr.Toolkit\Models\ModelLoader.cs,AddVertexData,The method has 5 parameters. Parameters: model' scene' node' device' transform
Magic Number,Rasterizr.Toolkit,ProceduralTextures,C:\repos\tgjones_rasterizr\src\Rasterizr.Toolkit\ProceduralTextures.cs,CreateCheckerboard,The following statement contains a magic number: for (int y = 0; y < height; y++)  			{  				for (int x = 0; x < width; x++)  				{                      data[(y * width) + x] = (black) ? new Color4(0' 0' 0' 1) : new Color4(1' 1' 1' 1);  					if (x % 8 == 0)  						black = !black;  				}  				if (y % 8 == 0)  					black = !black;  			}
Magic Number,Rasterizr.Toolkit,ProceduralTextures,C:\repos\tgjones_rasterizr\src\Rasterizr.Toolkit\ProceduralTextures.cs,CreateCheckerboard,The following statement contains a magic number: for (int y = 0; y < height; y++)  			{  				for (int x = 0; x < width; x++)  				{                      data[(y * width) + x] = (black) ? new Color4(0' 0' 0' 1) : new Color4(1' 1' 1' 1);  					if (x % 8 == 0)  						black = !black;  				}  				if (y % 8 == 0)  					black = !black;  			}
Magic Number,Rasterizr.Toolkit.Models,ConversionExtensions,C:\repos\tgjones_rasterizr\src\Rasterizr.Toolkit\Models\ConversionExtensions.cs,ToColor,The following statement contains a magic number: c.R = (byte) (color.R * 255);
Magic Number,Rasterizr.Toolkit.Models,ConversionExtensions,C:\repos\tgjones_rasterizr\src\Rasterizr.Toolkit\Models\ConversionExtensions.cs,ToColor,The following statement contains a magic number: c.G = (byte) (color.G * 255);
Magic Number,Rasterizr.Toolkit.Models,ConversionExtensions,C:\repos\tgjones_rasterizr\src\Rasterizr.Toolkit\Models\ConversionExtensions.cs,ToColor,The following statement contains a magic number: c.B = (byte) (color.B * 255);
Magic Number,Rasterizr.Toolkit.Models,ConversionExtensions,C:\repos\tgjones_rasterizr\src\Rasterizr.Toolkit\Models\ConversionExtensions.cs,ToColor,The following statement contains a magic number: c.A = (byte) (color.A * 255);
Magic Number,Rasterizr.Toolkit.Models,ModelLoader,C:\repos\tgjones_rasterizr\src\Rasterizr.Toolkit\Models\ModelLoader.cs,AddVertexData,The following statement contains a magic number: if (node.HasMeshes)              {                  foreach (int index in node.MeshIndices)                  {                      // Get a mesh from the scene.                      Mesh mesh = scene.Meshes[index];                        // Create new mesh to add to model.                      var modelMesh = new ModelMesh();                      model.AddMesh(modelMesh);                        // If mesh has a material extract the diffuse texture' if present.                      Material material = scene.Materials[mesh.MaterialIndex];                      if (material != null && material.GetTextureCount(TextureType.Diffuse) > 0)                      {                          TextureSlot aiTexture = material.GetTexture(TextureType.Diffuse' 0);                          using (var fileStream = File.OpenRead(_modelPath + "\\" + Path.GetFileName(aiTexture.FilePath)))                          {                              var texture = _textureLoadHandler(_device' fileStream);                              modelMesh.AddTextureDiffuse(device' texture);                          }                      }                        // Determine the elements in the vertex.                      bool hasTexCoords = mesh.HasTextureCoords(0);                      bool hasColors = mesh.HasVertexColors(0);                      bool hasNormals = mesh.HasNormals;                      bool hasTangents = mesh.Tangents != null;                      bool hasBitangents = mesh.BiTangents != null;                        // Create vertex element list.                      var vertexElements = new InputElement[GetNumberOfInputElements(mesh)];                      uint elementIndex = 0;                      vertexElements[elementIndex++] = new InputElement("POSITION"' 0' Format.R32G32B32_Float' 0' 0);                      var vertexSize = (short) Utilities.SizeOf<Vector3>();                        if (hasColors)                      {                          vertexElements[elementIndex++] = new InputElement("COLOR"' 0' Format.R8G8B8A8_UInt' 0' vertexSize);                          vertexSize += (short) Utilities.SizeOf<Color>();                      }                      if (hasNormals)                      {                          vertexElements[elementIndex++] = new InputElement("NORMAL"' 0' Format.R32G32B32_Float' 0' vertexSize);                          vertexSize += (short) Utilities.SizeOf<Vector3>();                      }                      if (hasTangents)                      {                          vertexElements[elementIndex++] = new InputElement("TANGENT"' 0' Format.R32G32B32_Float' 0' vertexSize);                          vertexSize += (short) Utilities.SizeOf<Vector3>();                      }                      if (hasBitangents)                      {                          vertexElements[elementIndex++] = new InputElement("BITANGENT"' 0' Format.R32G32B32_Float' 0' vertexSize);                          vertexSize += (short) Utilities.SizeOf<Vector3>();                      }                      if (hasTexCoords)                      {                          vertexElements[elementIndex++] = new InputElement("TEXCOORD"' 0' Format.R32G32_Float' 0' vertexSize);                          vertexSize += (short) Utilities.SizeOf<Vector2>();                      }                        //set the vertex elements and size                      modelMesh.InputElements = vertexElements;                      modelMesh.VertexSize = vertexSize;                        //get pointers to vertex data                      Vector3D[] positions = mesh.Vertices;                      Vector3D[] texCoords = mesh.GetTextureCoords(0);                      Vector3D[] normals = mesh.Normals;                      Vector3D[] tangents = mesh.Tangents;                      Vector3D[] biTangents = mesh.BiTangents;                      Color4D[] colours = mesh.GetVertexColors(0);                        //also determine primitive type                      switch (mesh.PrimitiveType)                      {                          case PrimitiveType.Point:                              modelMesh.PrimitiveTopology = PrimitiveTopology.PointList;                              break;                          case PrimitiveType.Line:                              modelMesh.PrimitiveTopology = PrimitiveTopology.LineList;                              break;                          case PrimitiveType.Triangle:                              modelMesh.PrimitiveTopology = PrimitiveTopology.TriangleList;                              break;                          default:                              throw new Exception("ModelLoader::AddVertexData(): Unknown primitive type");                      }                        // Create new vertex buffer.                      var vertexBuffer = device.CreateBuffer(                          new BufferDescription                          {                              BindFlags = BindFlags.VertexBuffer'                              SizeInBytes = mesh.VertexCount * vertexSize                          });                        int byteOffset = 0;                      for (int i = 0; i < mesh.VertexCount; i++)                      {                          {                              // Add position' after transforming it with accumulated node transform.                              Vector4 tempResult;                              Vector3 pos = positions[i].ToVector3();                              Vector3.Transform(ref pos' ref transform' out tempResult);                              var result = new Vector3(tempResult.X' tempResult.Y' tempResult.Z);                              device.ImmediateContext.SetBufferData(vertexBuffer' ref result' byteOffset);                              byteOffset += Vector3.SizeInBytes;                          }                            if (hasColors)                          {                              var vertColor = colours[i].ToColor();                              device.ImmediateContext.SetBufferData(vertexBuffer' ref vertColor' byteOffset);                              byteOffset += 4;                          }                          if (hasNormals)                          {                              var normal = normals[i].ToVector3();                              Vector4 tempResult;                              Vector3.Transform(ref normal' ref invTranspose' out tempResult);                              var result = new Vector3(tempResult.X' tempResult.Y' tempResult.Z);                              device.ImmediateContext.SetBufferData(vertexBuffer' ref result' byteOffset);                              byteOffset += Vector3.SizeInBytes;                          }                          if (hasTangents)                          {                              var tangent = tangents[i].ToVector3();                              Vector4 tempResult;                              Vector3.Transform(ref tangent' ref invTranspose' out tempResult);                              var result = new Vector3(tempResult.X' tempResult.Y' tempResult.Z);                              device.ImmediateContext.SetBufferData(vertexBuffer' ref result' byteOffset);                              byteOffset += Vector3.SizeInBytes;                          }                          if (hasBitangents)                          {                              var biTangent = biTangents[i].ToVector3();                              Vector4 tempResult;                              Vector3.Transform(ref biTangent' ref invTranspose' out tempResult);                              var result = new Vector3(tempResult.X' tempResult.Y' tempResult.Z);                              device.ImmediateContext.SetBufferData(vertexBuffer' ref result' byteOffset);                              byteOffset += Vector3.SizeInBytes;                          }                          if (hasTexCoords)                          {                              var result = new Vector2(texCoords[i].X' 1 - texCoords[i].Y);                              device.ImmediateContext.SetBufferData(vertexBuffer' ref result' byteOffset);                              byteOffset += Vector2.SizeInBytes;                          }                      }                        // Add it to the mesh.                      modelMesh.VertexBuffer = vertexBuffer;                      modelMesh.VertexCount = mesh.VertexCount;                      modelMesh.PrimitiveCount = mesh.FaceCount;                        // Get pointer to indices data.                      var indices = mesh.GetIndices();                        // Create new index buffer.                      var indexBuffer = device.CreateBuffer(                          new BufferDescription                          {                              BindFlags = BindFlags.IndexBuffer'                              SizeInBytes = indices.Length * sizeof(uint)                          }' indices);                        // Add it to the mesh.                      modelMesh.IndexBuffer = indexBuffer;                      modelMesh.IndexCount = indices.Length;                  }              }
