Implementation smell,Namespace,Class,File,Method,Description
Long Method,Cassette,PocoJsonSerializerStrategy,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,DeserializeObject,The method has 134 lines of code.
Long Method,Cassette,PocoJsonSerializerStrategy,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,DeserializeObject,The method has 134 lines of code.
Long Method,Cassette.Scripts,JavaScriptCommentParser,C:\repos\andrewdavey_cassette\src\Cassette\Scripts\JavaScriptCommentParser.cs,Parse,The method has 101 lines of code.
Long Method,Reflection,PocoJsonSerializerStrategy,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,DeserializeObject,The method has 134 lines of code.
Long Method,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,ResolveInternal,The method has 100 lines of code.
Complex Method,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,Cyclomatic complexity of the method is 9
Complex Method,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,IsNumeric,Cyclomatic complexity of the method is 12
Complex Method,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,Cyclomatic complexity of the method is 9
Complex Method,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,IsNumeric,Cyclomatic complexity of the method is 12
Complex Method,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,Cyclomatic complexity of the method is 9
Complex Method,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,IsNumeric,Cyclomatic complexity of the method is 12
Complex Method,Cassette.TinyIoC,GenericMethodCacheKey,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,Equals,Cyclomatic complexity of the method is 10
Complex Method,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,CanResolveInternal,Cyclomatic complexity of the method is 13
Complex Method,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,ResolveInternal,Cyclomatic complexity of the method is 13
Long Parameter List,Cassette,BundleCollection,C:\repos\andrewdavey_cassette\src\Cassette\BundleCollection.cs,CreateDirectoryBundle,The method has 5 parameters. Parameters: applicationRelativePath' bundleFactory' allFiles' directory' descriptor
Long Parameter List,Cassette,BundleCollection,C:\repos\andrewdavey_cassette\src\Cassette\BundleCollection.cs,AddEmbeddedResources,The method has 5 parameters. Parameters: applicationRelativePath' assembly' resourceNamespace' resourceFilenames' customizeBundle
Long Parameter List,Cassette,CacheAwareBundleCollectionInitializer,C:\repos\andrewdavey_cassette\src\Cassette\CacheAwareBundleCollectionInitializer.cs,CacheAwareBundleCollectionInitializer,The method has 5 parameters. Parameters: bundleConfigurations' cache' externalBundleGenerator' manifestValidator' settings
Long Parameter List,Cassette.Interop,ActiveScriptParseWrapper,C:\repos\andrewdavey_cassette\src\Cassette\Interop\ActiveScriptParseWrapper.cs,AddScriptlet,The method has 9 parameters. Parameters: defaultName' code' itemName' subItemName' eventName' delimiter' sourceContextCookie' startingLineNumber' flags
Long Parameter List,Cassette.Interop,ActiveScriptParseWrapper,C:\repos\andrewdavey_cassette\src\Cassette\Interop\ActiveScriptParseWrapper.cs,ParseScriptText,The method has 7 parameters. Parameters: code' itemName' context' delimiter' sourceContextCookie' startingLineNumber' flags
Long Parameter List,Cassette.Interop,IActiveScriptParse32,C:\repos\andrewdavey_cassette\src\Cassette\Interop\IActiveScriptParse32.cs,AddScriptlet,The method has 11 parameters. Parameters: defaultName' code' itemName' subItemName' eventName' delimiter' sourceContextCookie' startingLineNumber' flags' name' exceptionInfo
Long Parameter List,Cassette.Interop,IActiveScriptParse32,C:\repos\andrewdavey_cassette\src\Cassette\Interop\IActiveScriptParse32.cs,ParseScriptText,The method has 9 parameters. Parameters: code' itemName' context' delimiter' sourceContextCookie' startingLineNumber' flags' result' exceptionInfo
Long Parameter List,Cassette.Interop,IActiveScriptParse64,C:\repos\andrewdavey_cassette\src\Cassette\Interop\IActiveScriptParse64.cs,AddScriptlet,The method has 11 parameters. Parameters: defaultName' code' itemName' subItemName' eventName' delimiter' sourceContextCookie' startingLineNumber' flags' name' exceptionInfo
Long Parameter List,Cassette.Interop,IActiveScriptParse64,C:\repos\andrewdavey_cassette\src\Cassette\Interop\IActiveScriptParse64.cs,ParseScriptText,The method has 9 parameters. Parameters: code' itemName' context' delimiter' sourceContextCookie' startingLineNumber' flags' result' exceptionInfo
Long Parameter List,Cassette.Interop,IActiveScriptParseWrapper,C:\repos\andrewdavey_cassette\src\Cassette\Interop\IActiveScriptParseWrapper.cs,AddScriptlet,The method has 9 parameters. Parameters: defaultName' code' itemName' subItemName' eventName' delimiter' sourceContextCookie' startingLineNumber' flags
Long Parameter List,Cassette.Interop,IActiveScriptParseWrapper,C:\repos\andrewdavey_cassette\src\Cassette\Interop\IActiveScriptParseWrapper.cs,ParseScriptText,The method has 7 parameters. Parameters: code' itemName' context' delimiter' sourceContextCookie' startingLineNumber' flags
Long Parameter List,Cassette.Stylesheets,ExpandCssUrlsAssetTransformer,C:\repos\andrewdavey_cassette\src\Cassette\Stylesheets\ExpandCssUrlsAssetTransformer.cs,ReplaceUrlWithCassetteRawFileUrl,The method has 5 parameters. Parameters: builder' matchedUrlGroup' filename' queryString' fragment
Long Parameter List,Cassette.TinyIoC,TypeExtensions,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,GetGenericMethod,The method has 5 parameters. Parameters: sourceType' bindingFlags' methodName' genericTypes' parameterTypes
Long Parameter List,Cassette.TinyIoC,TypeExtensions,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,GetMethod,The method has 5 parameters. Parameters: sourceType' bindingFlags' methodName' genericTypes' parameterTypes
Long Parameter List,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,TryResolve,The method has 5 parameters. Parameters: resolveType' name' parameters' options' resolvedType
Long Parameter List,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,ConstructType,The method has 5 parameters. Parameters: requestedType' implementationType' constructor' parameters' options
Long Identifier,Cassette,BundleCollection,C:\repos\andrewdavey_cassette\src\Cassette\BundleCollection.cs,TryGetDescriptorFile,The length of the parameter typeSpecificDescriptorFilename is 30.
Long Identifier,Cassette,RuntimeBundleCollectionInitializer,C:\repos\andrewdavey_cassette\src\Cassette\RuntimeBundleCollectionInitializer.cs,RuntimeBundleCollectionInitializer,The length of the parameter cacheAwareBundleCollectionInitializer is 37.
Long Identifier,Cassette,RuntimeBundleCollectionInitializer,C:\repos\andrewdavey_cassette\src\Cassette\RuntimeBundleCollectionInitializer.cs,,The length of the parameter cacheAwareBundleCollectionInitializer is 37.
Long Identifier,Cassette.Caching,BundleCollectionCache,C:\repos\andrewdavey_cassette\src\Cassette\Caching\BundleCollectionCache.cs,BundleCollectionCache,The length of the parameter getDeserializerForBundleTypeName is 32.
Long Identifier,Cassette.Caching,BundleCollectionCache,C:\repos\andrewdavey_cassette\src\Cassette\Caching\BundleCollectionCache.cs,,The length of the parameter getDeserializerForBundleTypeName is 32.
Long Identifier,Cassette.Caching,BundleCollectionCacheReader,C:\repos\andrewdavey_cassette\src\Cassette\Caching\BundleCollectionCacheReader.cs,BundleCollectionCacheReader,The length of the parameter getDeserializerForBundleTypeName is 32.
Long Identifier,Cassette.Caching,BundleCollectionCacheReader,C:\repos\andrewdavey_cassette\src\Cassette\Caching\BundleCollectionCacheReader.cs,,The length of the parameter getDeserializerForBundleTypeName is 32.
Long Identifier,Cassette.Stylesheets,CssBackgroundImageUrlMatchTransformer,C:\repos\andrewdavey_cassette\src\Cassette\Stylesheets\CssImageToDataUriTransformer.cs,FileIsTooLargeForInternetExplorer8,The length of the parameter internetExplorer8DataUriSizeLimitInBytes is 40.
Long Identifier,Cassette.TinyIoC,ResolveOptions,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,,The length of the parameter _FailUnregisteredAndNameNotFound is 32.
Long Identifier,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,AutoRegister,The length of the parameter ignoreDuplicateImplementations is 30.
Long Identifier,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,AutoRegister,The length of the parameter ignoreDuplicateImplementations is 30.
Long Identifier,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,AutoRegister,The length of the parameter ignoreDuplicateImplementations is 30.
Long Identifier,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,AutoRegister,The length of the parameter ignoreDuplicateImplementations is 30.
Long Identifier,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,AutoRegisterInternal,The length of the parameter ignoreDuplicateImplementations is 30.
Long Identifier,Cassette.TinyIoC,DelegateFactoryBuilder,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,,The length of the parameter namedParameterOverloadsConstructor is 34.
Long Statement,Cassette,FileAccessAuthorization,C:\repos\andrewdavey_cassette\src\Cassette\FileAccessAuthorization.cs,AllowAccess,The length of the statement  "            if (!path.StartsWith("~/")) throw new ArgumentException(string.Format("The path \"{0}\" is not application relative. It must start with \"~/\"."' path)' "path"); " is 161.
Long Statement,Cassette,HostBase,C:\repos\andrewdavey_cassette\src\Cassette\HostBase.cs,RegisterUrlGenerator,The length of the statement  "            container.Register<IUrlGenerator>((c' n) => new UrlGenerator(c.Resolve<IUrlModifier>()' c.Resolve<CassetteSettings>().SourceDirectory' "cassette.axd/")); " is 153.
Long Statement,Cassette,HostBase,C:\repos\andrewdavey_cassette\src\Cassette\HostBase.cs,RegisterSettings,The length of the statement  "            // Host specific settings configuration is named so that it's included when CassetteSettings asks for IEnumerable<IConfiguration<CassetteSettings>>. " is 148.
Long Statement,Cassette,BundleCollection,C:\repos\andrewdavey_cassette\src\Cassette\BundleCollection.cs,GetReadLock,The length of the statement  "                // this prevents unintentional "caching" of compiler errors for things like Less or Compass until the AppDomain recycles " is 120.
Long Statement,Cassette,BundleCollection,C:\repos\andrewdavey_cassette\src\Cassette\BundleCollection.cs,Add,The length of the statement  "                    string.Format("A {0} with the path \"{1}\" has already been added to the collection."' bundle.GetType().Name' bundle.Path) " is 122.
Long Statement,Cassette,BundleCollection,C:\repos\andrewdavey_cassette\src\Cassette\BundleCollection.cs,AddPerSubDirectory,The length of the statement  "            Trace.Source.TraceInformation(string.Format("Creating {0} for each subdirectory of {1}"' typeof(T).Name' applicationRelativePath)); " is 131.
Long Statement,Cassette,BundleCollection,C:\repos\andrewdavey_cassette\src\Cassette\BundleCollection.cs,AddUrlWithLocalAssets,The length of the statement  "                throw new ArgumentException("Cannot determine the type of bundle to add. Specify the type using the generic overload of this method."); " is 135.
Long Statement,Cassette,BundleCollection,C:\repos\andrewdavey_cassette\src\Cassette\BundleCollection.cs,AddUrlWithAlias,The length of the statement  "                throw new ArgumentException("Cannot determine the type of bundle to add. Specify the type using the generic overload of this method."); " is 135.
Long Statement,Cassette,BundleCollection,C:\repos\andrewdavey_cassette\src\Cassette\BundleCollection.cs,AddUrl,The length of the statement  "                throw new ArgumentException("Cannot determine the type of bundle to add. Specify the type using the generic overload of this method."); " is 135.
Long Statement,Cassette,FileSystemWatchingBundleRebuilder,C:\repos\andrewdavey_cassette\src\Cassette\FileSystemWatchingBundleRebuilder.cs,GetBundleDescriptorFilenames,The length of the statement  "            return new HashedCompareSet<string>(bundleTypes.Select(type => type.Name + ".txt").ToArray()' StringComparer.OrdinalIgnoreCase); " is 128.
Long Statement,Cassette,AssetDeserializer,C:\repos\andrewdavey_cassette\src\Cassette\AssetDeserializer.cs,ParseSourceLineNumber,The length of the statement  "            throw new CassetteDeserializationException(string.Format("Invalid asset reference source line number \"{0}\"."' sourceLineNumberString)); " is 137.
Long Statement,Cassette,BundleDeserializer<T>,C:\repos\andrewdavey_cassette\src\Cassette\BundleDeserializer.cs,GetRequiredAttribute,The length of the statement  "                () => new CassetteDeserializationException(string.Format("Bundle manifest element missing \"{0}\" attribute."' attributeName)) " is 126.
Long Statement,Cassette,BundleDeserializer<T>,C:\repos\andrewdavey_cassette\src\Cassette\BundleDeserializer.cs,CreateHtmlRenderer,The length of the statement  "                () => new CassetteDeserializationException(string.Format("Bundle manifest element missing \"{0}\" attribute."' attributeName)) " is 126.
Long Statement,Cassette,ReferenceBuilder,C:\repos\andrewdavey_cassette\src\Cassette\ReferenceBuilder.cs,ThrowRewritingRequiredException,The length of the statement  "                    "Cannot add a bundle reference. The bundles have already been rendered. Either move the reference before the render call' or set ICassetteApplication.IsHtmlRewritingEnabled to true in your Cassette configuration." " is 213.
Long Statement,Cassette,ReferenceBuilder,C:\repos\andrewdavey_cassette\src\Cassette\ReferenceBuilder.cs,ThrowRewritingRequiredException,The length of the statement  "                        "Cannot add a bundle reference' for location \"{0}\". This location has already been rendered. Either move the reference before the render call' or set ICassetteApplication.IsHtmlRewritingEnabled to true in your Cassette configuration."' " is 237.
Long Statement,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseNumber,The length of the statement  "            if (str.IndexOf("."' StringComparison.OrdinalIgnoreCase) != -1 || str.IndexOf("e"' StringComparison.OrdinalIgnoreCase) != -1) " is 125.
Long Statement,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseNumber,The length of the statement  "                success = double.TryParse(new string(json' index' charLength)' NumberStyles.Any' CultureInfo.InvariantCulture' out number); " is 123.
Long Statement,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseNumber,The length of the statement  "                success = long.TryParse(new string(json' index' charLength)' NumberStyles.Any' CultureInfo.InvariantCulture' out number); " is 121.
Long Statement,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseNumber,The length of the statement  "            if (str.IndexOf("."' StringComparison.OrdinalIgnoreCase) != -1 || str.IndexOf("e"' StringComparison.OrdinalIgnoreCase) != -1) " is 125.
Long Statement,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseNumber,The length of the statement  "                success = double.TryParse(new string(json' index' charLength)' NumberStyles.Any' CultureInfo.InvariantCulture' out number); " is 123.
Long Statement,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseNumber,The length of the statement  "                success = long.TryParse(new string(json' index' charLength)' NumberStyles.Any' CultureInfo.InvariantCulture' out number); " is 121.
Long Statement,Cassette,PocoJsonSerializerStrategy,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                    if (type == typeof(DateTime) || (ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type) == typeof(DateTime))) " is 127.
Long Statement,Cassette,PocoJsonSerializerStrategy,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                        obj = DateTime.ParseExact(str' Iso8601Format' CultureInfo.InvariantCulture' DateTimeStyles.AssumeUniversal | DateTimeStyles.AdjustToUniversal); " is 143.
Long Statement,Cassette,PocoJsonSerializerStrategy,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                    else if (type == typeof(Guid) || (ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type) == typeof(Guid))) " is 124.
Long Statement,Cassette,PocoJsonSerializerStrategy,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                    type == typeof(int) || type == typeof(long) || type == typeof(double) ||type == typeof(float) || type == typeof(bool) || type == typeof(decimal) ||type == typeof(byte) || type == typeof(short) " is 192.
Long Statement,Cassette,PocoJsonSerializerStrategy,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                    if (type == typeof(DateTime) || (ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type) == typeof(DateTime))) " is 127.
Long Statement,Cassette,PocoJsonSerializerStrategy,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                        obj = DateTime.ParseExact(str' Iso8601Format' CultureInfo.InvariantCulture' DateTimeStyles.AssumeUniversal | DateTimeStyles.AdjustToUniversal); " is 143.
Long Statement,Cassette,PocoJsonSerializerStrategy,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                    else if (type == typeof(Guid) || (ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type) == typeof(Guid))) " is 124.
Long Statement,Cassette,PocoJsonSerializerStrategy,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                    type == typeof(int) || type == typeof(long) || type == typeof(double) ||type == typeof(float) || type == typeof(bool) || type == typeof(decimal) ||type == typeof(byte) || type == typeof(short) " is 192.
Long Statement,Cassette,ReflectionUtils,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,IsTypeGenericeCollectionInterface,The length of the statement  "                return (genericDefinition == typeof(IList<>) || genericDefinition == typeof(ICollection<>) || genericDefinition == typeof(IEnumerable<>)); " is 138.
Long Statement,Cassette,ReflectionUtils,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ToNullableType,The length of the statement  "                return obj == null ? null : Convert.ChangeType(obj' Nullable.GetUnderlyingType(nullableType)' CultureInfo.InvariantCulture); " is 124.
Long Statement,Cassette,ReflectionUtils,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,IsTypeGenericeCollectionInterface,The length of the statement  "                return (genericDefinition == typeof(IList<>) || genericDefinition == typeof(ICollection<>) || genericDefinition == typeof(IEnumerable<>)); " is 138.
Long Statement,Cassette,ReflectionUtils,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ToNullableType,The length of the statement  "                return obj == null ? null : Convert.ChangeType(obj' Nullable.GetUnderlyingType(nullableType)' CultureInfo.InvariantCulture); " is 124.
Long Statement,Cassette,CacheResolver,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,GetNewInstance,The length of the statement  "                    ConstructorInfo constructorInfo = type.GetConstructor(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance' null' Type.EmptyTypes' null); " is 153.
Long Statement,Cassette,CacheResolver,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,GetNewInstance,The length of the statement  "                ConstructorInfo constructorInfo = type.GetConstructor(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance' null' Type.EmptyTypes' null); " is 153.
Long Statement,Cassette,CacheResolver,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,CreateGetHandler,The length of the statement  "                DynamicMethod dynamicGet = CreateDynamicMethod("Get" + fieldInfo.Name' fieldInfo.DeclaringType' new Type[] { typeof(object) }' fieldInfo.DeclaringType); " is 152.
Long Statement,Cassette,CacheResolver,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,CreateSetHandler,The length of the statement  "                DynamicMethod dynamicSet = CreateDynamicMethod("Set" + fieldInfo.Name' null' new Type[] { typeof(object)' typeof(object) }' fieldInfo.DeclaringType); " is 149.
Long Statement,Cassette,CacheResolver,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,CreateGetHandler,The length of the statement  "                DynamicMethod dynamicGet = CreateDynamicMethod("Get" + propertyInfo.Name' propertyInfo.DeclaringType' new Type[] { typeof(object) }' propertyInfo.DeclaringType); " is 161.
Long Statement,Cassette,CacheResolver,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,CreateSetHandler,The length of the statement  "                DynamicMethod dynamicSet = CreateDynamicMethod("Set" + propertyInfo.Name' null' new Type[] { typeof(object)' typeof(object) }' propertyInfo.DeclaringType); " is 155.
Long Statement,Cassette,CacheResolver,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,GetNewInstance,The length of the statement  "                    ConstructorInfo constructorInfo = type.GetConstructor(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance' null' Type.EmptyTypes' null); " is 153.
Long Statement,Cassette,CacheResolver,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,GetNewInstance,The length of the statement  "                ConstructorInfo constructorInfo = type.GetConstructor(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance' null' Type.EmptyTypes' null); " is 153.
Long Statement,Cassette,CacheResolver,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,CreateGetHandler,The length of the statement  "                DynamicMethod dynamicGet = CreateDynamicMethod("Get" + fieldInfo.Name' fieldInfo.DeclaringType' new Type[] { typeof(object) }' fieldInfo.DeclaringType); " is 152.
Long Statement,Cassette,CacheResolver,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,CreateSetHandler,The length of the statement  "                DynamicMethod dynamicSet = CreateDynamicMethod("Set" + fieldInfo.Name' null' new Type[] { typeof(object)' typeof(object) }' fieldInfo.DeclaringType); " is 149.
Long Statement,Cassette,CacheResolver,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,CreateGetHandler,The length of the statement  "                DynamicMethod dynamicGet = CreateDynamicMethod("Get" + propertyInfo.Name' propertyInfo.DeclaringType' new Type[] { typeof(object) }' propertyInfo.DeclaringType); " is 161.
Long Statement,Cassette,CacheResolver,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,CreateSetHandler,The length of the statement  "                DynamicMethod dynamicSet = CreateDynamicMethod("Set" + propertyInfo.Name' null' new Type[] { typeof(object)' typeof(object) }' propertyInfo.DeclaringType); " is 155.
Long Statement,Cassette,BundleDescriptorReader,C:\repos\andrewdavey_cassette\src\Cassette\BundleDescriptorReader.cs,ParseExternal,The length of the statement  "                            "The [external] section of bundle descriptor must contain a \"url\" property before the \"fallbackCondition\" property."); " is 122.
Long Statement,Cassette,AssetReference,C:\repos\andrewdavey_cassette\src\Cassette\AssetReference.cs,ValidatePath,The length of the statement  "                    throw new ArgumentException(string.Format("Referenced path must be application relative and start with a \"~\". Path: {0}"' path)' "path"); " is 139.
Long Statement,Cassette,UrlGenerator,C:\repos\andrewdavey_cassette\src\Cassette\UrlGenerator.cs,CreateAssetUrl,The length of the statement  "            // This maintains the asset directory structure i.e. two assets in the same directory appear together in web browser JavaScript development tooling. " is 148.
Long Statement,Cassette,UrlGenerator,C:\repos\andrewdavey_cassette\src\Cassette\UrlGenerator.cs,CreateCachedFileUrl,The length of the statement  "                throw new ArgumentException("Filename must be application relative (starting with '~'). Filename: "+filename' "filename"); " is 122.
Long Statement,Cassette.BundleProcessing,ReferenceParser,C:\repos\andrewdavey_cassette\src\Cassette\BundleProcessing\ReferenceParser.cs,ParsePaths,The length of the statement  "                throw new Exception(string.Format("Asset reference error in {0} line {1}. Missing closing double quote (\")."' sourceAsset.Path' lineNumber)); " is 142.
Long Statement,Cassette.BundleProcessing,ReferenceParser,C:\repos\andrewdavey_cassette\src\Cassette\BundleProcessing\ReferenceParser.cs,ParsePaths,The length of the statement  "                throw new Exception(string.Format("Asset reference error in {0} line {1}. Missing closing single quote (')."' sourceAsset.Path' lineNumber)); " is 141.
Long Statement,Cassette.HtmlTemplates,WrapJavaScriptHtmlTemplates,C:\repos\andrewdavey_cassette\src\Cassette\HtmlTemplates\WrapJavaScriptHtmlTemplates.cs,Process,The length of the statement  "            if (bundle.Assets.Count > 1) throw new ArgumentException("WrapJavaScriptHtmlTemplates should only process a bundle where the assets have been concatenated."' "bundle"); " is 168.
Long Statement,Cassette.IO,FileSystemDirectory,C:\repos\andrewdavey_cassette\src\Cassette\IO\FileSystemDirectory.cs,WatchForChanges,The length of the statement  "            watcher.Renamed += (s' e) => pathRenamed(ConvertSystemPathToAppPath(e.OldFullPath)' ConvertSystemPathToAppPath(e.FullPath)); " is 124.
Long Statement,Cassette.IO,FileSystemDirectory,C:\repos\andrewdavey_cassette\src\Cassette\IO\FileSystemDirectory.cs,TryGetAsSubDirectory,The length of the statement  "                directory.fullSystemPath.Substring(0' fullSystemPath.Length).Equals(fullSystemPath' StringComparison.OrdinalIgnoreCase); " is 120.
Long Statement,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseNumber,The length of the statement  "            if (str.IndexOf("."' StringComparison.OrdinalIgnoreCase) != -1 || str.IndexOf("e"' StringComparison.OrdinalIgnoreCase) != -1) " is 125.
Long Statement,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseNumber,The length of the statement  "                success = double.TryParse(new string(json' index' charLength)' NumberStyles.Any' CultureInfo.InvariantCulture' out number); " is 123.
Long Statement,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseNumber,The length of the statement  "                success = long.TryParse(new string(json' index' charLength)' NumberStyles.Any' CultureInfo.InvariantCulture' out number); " is 121.
Long Statement,Reflection,PocoJsonSerializerStrategy,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                    if (type == typeof(DateTime) || (ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type) == typeof(DateTime))) " is 127.
Long Statement,Reflection,PocoJsonSerializerStrategy,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                        obj = DateTime.ParseExact(str' Iso8601Format' CultureInfo.InvariantCulture' DateTimeStyles.AssumeUniversal | DateTimeStyles.AdjustToUniversal); " is 143.
Long Statement,Reflection,PocoJsonSerializerStrategy,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                    else if (type == typeof(Guid) || (ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type) == typeof(Guid))) " is 124.
Long Statement,Reflection,PocoJsonSerializerStrategy,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,DeserializeObject,The length of the statement  "                    type == typeof(int) || type == typeof(long) || type == typeof(double) ||type == typeof(float) || type == typeof(bool) || type == typeof(decimal) ||type == typeof(byte) || type == typeof(short) " is 192.
Long Statement,Reflection,ReflectionUtils,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,IsTypeGenericeCollectionInterface,The length of the statement  "                return (genericDefinition == typeof(IList<>) || genericDefinition == typeof(ICollection<>) || genericDefinition == typeof(IEnumerable<>)); " is 138.
Long Statement,Reflection,ReflectionUtils,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ToNullableType,The length of the statement  "                return obj == null ? null : Convert.ChangeType(obj' Nullable.GetUnderlyingType(nullableType)' CultureInfo.InvariantCulture); " is 124.
Long Statement,Reflection,CacheResolver,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,GetNewInstance,The length of the statement  "                    ConstructorInfo constructorInfo = type.GetConstructor(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance' null' Type.EmptyTypes' null); " is 153.
Long Statement,Reflection,CacheResolver,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,GetNewInstance,The length of the statement  "                ConstructorInfo constructorInfo = type.GetConstructor(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance' null' Type.EmptyTypes' null); " is 153.
Long Statement,Reflection,CacheResolver,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,CreateGetHandler,The length of the statement  "                DynamicMethod dynamicGet = CreateDynamicMethod("Get" + fieldInfo.Name' fieldInfo.DeclaringType' new Type[] { typeof(object) }' fieldInfo.DeclaringType); " is 152.
Long Statement,Reflection,CacheResolver,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,CreateSetHandler,The length of the statement  "                DynamicMethod dynamicSet = CreateDynamicMethod("Set" + fieldInfo.Name' null' new Type[] { typeof(object)' typeof(object) }' fieldInfo.DeclaringType); " is 149.
Long Statement,Reflection,CacheResolver,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,CreateGetHandler,The length of the statement  "                DynamicMethod dynamicGet = CreateDynamicMethod("Get" + propertyInfo.Name' propertyInfo.DeclaringType' new Type[] { typeof(object) }' propertyInfo.DeclaringType); " is 161.
Long Statement,Reflection,CacheResolver,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,CreateSetHandler,The length of the statement  "                DynamicMethod dynamicSet = CreateDynamicMethod("Set" + propertyInfo.Name' null' new Type[] { typeof(object)' typeof(object) }' propertyInfo.DeclaringType); " is 155.
Long Statement,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,AutoRegister,The length of the statement  "            AutoRegisterInternal(AppDomain.CurrentDomain.GetAssemblies().Where(a => !IsIgnoredAssembly(a))' true' registrationPredicate); " is 125.
Long Statement,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,AutoRegister,The length of the statement  "            AutoRegisterInternal(AppDomain.CurrentDomain.GetAssemblies().Where(a => !IsIgnoredAssembly(a))' ignoreDuplicateImplementations' null); " is 134.
Long Statement,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,AutoRegister,The length of the statement  "            AutoRegisterInternal(AppDomain.CurrentDomain.GetAssemblies().Where(a => !IsIgnoredAssembly(a))' ignoreDuplicateImplementations' registrationPredicate); " is 151.
Long Statement,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,AutoRegister,The length of the statement  "            AutoRegisterInternal(new Assembly[] { this.GetType().Assembly }' ignoreDuplicateImplementations' registrationPredicate); " is 120.
Long Statement,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,Register,The length of the statement  "            return this.RegisterInternal(registerType' string.Empty' GetDefaultObjectFactory(registerType' registerImplementation)); " is 120.
Long Statement,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,Register,The length of the statement  "            return RegisterInternal(registerType' string.Empty' new InstanceFactory(registerType' registerImplementation' instance)); " is 121.
Long Statement,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,RegisterMultiple,The length of the statement  "                    throw new ArgumentException(String.Format("types: The type {0} is not assignable from {1}"' registrationType.FullName' type.FullName)); " is 135.
Long Statement,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,Resolve,The length of the statement  "            return ResolveInternal(new TypeRegistration(resolveType' name)' NamedParameterOverloads.Default' ResolveOptions.Default); " is 121.
Long Statement,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,CanResolve,The length of the statement  "            return CanResolveInternal(new TypeRegistration(resolveType' name)' NamedParameterOverloads.Default' ResolveOptions.Default); " is 124.
Long Statement,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,AutoRegisterInternal,The length of the statement  "                                    where (type.IsClass == true) && (type.IsAbstract == false) && (type != this.GetType() && (type.DeclaringType != this.GetType()) && (!type.IsGenericTypeDefinition)) " is 163.
Long Statement,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,AutoRegisterInternal,The length of the statement  "                                             where ((type.IsInterface == true || type.IsAbstract == true) && (type.DeclaringType != this.GetType()) && (!type.IsGenericTypeDefinition)) " is 138.
Long Statement,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,CanResolveInternal,The length of the statement  "            if (!String.IsNullOrEmpty(name) && options.NamedResolutionFailureAction == NamedResolutionFailureActions.AttemptUnnamedResolution) " is 130.
Long Statement,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,CanResolveInternal,The length of the statement  "            if ((options.UnregisteredResolutionAction == UnregisteredResolutionActions.AttemptResolve) || (checkType.IsGenericType && options.UnregisteredResolutionAction == UnregisteredResolutionActions.GenericsOnly)) " is 206.
Long Statement,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,CanResolveInternal,The length of the statement  "                return (GetBestConstructor(checkType' parameters' options) != null) ? true : (_Parent != null) ? _Parent.CanResolveInternal(registration' parameters' options) : false; " is 167.
Long Statement,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,IsAutomaticLazyFactoryRequest,The length of the statement  "            if ((genericType == typeof(Func<''>) && type.GetGenericArguments()[0] == typeof(string) && type.GetGenericArguments()[1] == typeof(IDictionary<String' object>))) " is 161.
Long Statement,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,ResolveInternal,The length of the statement  "            if (!String.IsNullOrEmpty(registration.Name) && options.NamedResolutionFailureAction == NamedResolutionFailureActions.Fail) " is 123.
Long Statement,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,ResolveInternal,The length of the statement  "            if (!String.IsNullOrEmpty(registration.Name) && options.NamedResolutionFailureAction == NamedResolutionFailureActions.AttemptUnnamedResolution) " is 143.
Long Statement,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,ResolveInternal,The length of the statement  "            if ((options.UnregisteredResolutionAction == UnregisteredResolutionActions.AttemptResolve) || (registration.Type.IsGenericType && options.UnregisteredResolutionAction == UnregisteredResolutionActions.GenericsOnly)) " is 214.
Long Statement,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,GetLazyAutomaticFactoryRequest,The length of the statement  "            if ((genericType == typeof(Func<''>) && type.GetGenericArguments()[0] == typeof(string) && type.GetGenericArguments()[1] == typeof(IDictionary<string' object>))) " is 161.
Long Statement,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,GetLazyAutomaticFactoryRequest,The length of the statement  "                MethodInfo resolveMethod = typeof(TinyIoCContainer).GetMethod("Resolve"' new Type[] { typeof(String)' typeof(NamedParameterOverloads) }); " is 137.
Long Statement,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,GetLazyAutomaticFactoryRequest,The length of the statement  "                var resolveCall = Expression.Call(Expression.Constant(this)' resolveMethod' name' Expression.Call(typeof(NamedParameterOverloads)' "FromIDictionary"' null' parameters)); " is 169.
Long Statement,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,GetIEnumerableRequest,The length of the statement  "            var genericResolveAllMethod = this.GetType().GetGenericMethod(BindingFlags.Public | BindingFlags.Instance' "ResolveAll"' type.GetGenericArguments()' new[] { typeof(bool) }); " is 173.
Long Statement,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,CanConstruct,The length of the statement  "                if (!isParameterOverload && !CanResolveInternal(new TypeRegistration(parameter.ParameterType)' NamedParameterOverloads.Default' options)) " is 137.
Long Statement,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,ConstructType,The length of the statement  "                constructor = GetBestConstructor(typeToConstruct' parameters' options) ?? GetTypeConstructors(typeToConstruct).LastOrDefault(); " is 127.
Long Statement,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,BuildUpInternal,The length of the statement  "                        property.SetValue(input' ResolveInternal(new TypeRegistration(property.PropertyType)' NamedParameterOverloads.Default' resolveOptions)' null); " is 142.
Long Statement,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,ResolveAllInternal,The length of the statement  "            var registrations = _RegisteredTypes.Keys.Where(tr => tr.Type == resolveType).Concat(GetParentRegistrationsForType(resolveType)); " is 129.
Long Statement,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,ResolveAllInternal,The length of the statement  "            return registrations.Select(registration => this.ResolveInternal(registration' NamedParameterOverloads.Default' ResolveOptions.Default)); " is 137.
Long Statement,Cassette.TinyIoC,RegisterOptions,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,ToCustomLifetimeManager,The length of the statement  "                return instance._Container.AddUpdateRegistration(instance._Registration' currentFactory.GetCustomObjectLifetimeVariant(lifetimeProvider' errorString)); " is 151.
Long Statement,Cassette.TinyIoC,DelegateFactory,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,SetConstructor,The length of the statement  "                throw new TinyIoCConstructorResolutionException("Constructor selection is not possible for delegate factory registrations"); " is 124.
Long Statement,Cassette.TinyIoC,WeakDelegateFactory,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,SetConstructor,The length of the statement  "                throw new TinyIoCConstructorResolutionException("Constructor selection is not possible for delegate factory registrations"); " is 124.
Long Statement,Cassette.TinyIoC,InstanceFactory,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,SetConstructor,The length of the statement  "                throw new TinyIoCConstructorResolutionException("Constructor selection is not possible for instance factory registrations"); " is 124.
Long Statement,Cassette.TinyIoC,WeakInstanceFactory,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,SetConstructor,The length of the statement  "                throw new TinyIoCConstructorResolutionException("Constructor selection is not possible for instance factory registrations"); " is 124.
Complex Conditional,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The conditional expression  "json[index] == 'f' &&                      json[index + 1] == 'a' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 's' &&                      json[index + 4] == 'e'"  is complex.
Complex Conditional,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The conditional expression  "json[index] == 't' &&                      json[index + 1] == 'r' &&                      json[index + 2] == 'u' &&                      json[index + 3] == 'e'"  is complex.
Complex Conditional,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The conditional expression  "json[index] == 'n' &&                      json[index + 1] == 'u' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 'l'"  is complex.
Complex Conditional,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The conditional expression  "json[index] == 'f' &&                      json[index + 1] == 'a' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 's' &&                      json[index + 4] == 'e'"  is complex.
Complex Conditional,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The conditional expression  "json[index] == 't' &&                      json[index + 1] == 'r' &&                      json[index + 2] == 'u' &&                      json[index + 3] == 'e'"  is complex.
Complex Conditional,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The conditional expression  "json[index] == 'n' &&                      json[index + 1] == 'u' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 'l'"  is complex.
Complex Conditional,Cassette,PocoJsonSerializerStrategy,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,DeserializeObject,The conditional expression  "(value is long && type == typeof(long)) || (value is double && type == typeof(double))"  is complex.
Complex Conditional,Cassette,PocoJsonSerializerStrategy,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,DeserializeObject,The conditional expression  "(value is double && type != typeof(double)) || (value is long && type != typeof(long))"  is complex.
Complex Conditional,Cassette,PocoJsonSerializerStrategy,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,DeserializeObject,The conditional expression  "(value is long && type == typeof(long)) || (value is double && type == typeof(double))"  is complex.
Complex Conditional,Cassette,PocoJsonSerializerStrategy,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,DeserializeObject,The conditional expression  "(value is double && type != typeof(double)) || (value is long && type != typeof(long))"  is complex.
Complex Conditional,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The conditional expression  "json[index] == 'f' &&                      json[index + 1] == 'a' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 's' &&                      json[index + 4] == 'e'"  is complex.
Complex Conditional,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The conditional expression  "json[index] == 't' &&                      json[index + 1] == 'r' &&                      json[index + 2] == 'u' &&                      json[index + 3] == 'e'"  is complex.
Complex Conditional,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The conditional expression  "json[index] == 'n' &&                      json[index + 1] == 'u' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 'l'"  is complex.
Complex Conditional,Reflection,PocoJsonSerializerStrategy,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,DeserializeObject,The conditional expression  "(value is long && type == typeof(long)) || (value is double && type == typeof(double))"  is complex.
Complex Conditional,Reflection,PocoJsonSerializerStrategy,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,DeserializeObject,The conditional expression  "(value is double && type != typeof(double)) || (value is long && type != typeof(long))"  is complex.
Empty Catch Block,Cassette.Interop,ActiveScriptException,C:\repos\andrewdavey_cassette\src\Cassette\Interop\ActiveScriptException.cs,Create,The method has an empty catch block.
Empty Catch Block,Cassette.Interop,ActiveScriptException,C:\repos\andrewdavey_cassette\src\Cassette\Interop\ActiveScriptException.cs,Create,The method has an empty catch block.
Empty Catch Block,Cassette.Interop,ActiveScriptException,C:\repos\andrewdavey_cassette\src\Cassette\Interop\ActiveScriptException.cs,Create,The method has an empty catch block.
Empty Catch Block,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,AutoRegisterInternal,The method has an empty catch block.
Empty Catch Block,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,AutoRegisterInternal,The method has an empty catch block.
Empty Catch Block,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,BuildUpInternal,The method has an empty catch block.
Magic Number,Cassette,FileSystemWatchingBundleRebuilder,C:\repos\andrewdavey_cassette\src\Cassette\FileSystemWatchingBundleRebuilder.cs,QueueRebuild,The following statement contains a magic number: rebuildDelayTimer.Change(100' Timeout.Infinite);
Magic Number,Cassette,BundleFactoryBase<T>,C:\repos\andrewdavey_cassette\src\Cassette\BundleFactoryBase.cs,ThrowIfShouldReferenceNonMinFile,The following statement contains a magic number: if (minMatch.Success)              {                  var nonMinFilename = minMatch.Groups[1].Value + minMatch.Groups[2].Value;                  if (filesByPath.ContainsKey(nonMinFilename))                  {                      throw new ArgumentException(                          string.Format(                              "Bundle \"{0}\" references \"{1}\" when it should reference \"{2}\"."'                              bundle.Path'                              filename'                              nonMinFilename                              )                          );                  }              }
Magic Number,Cassette,HtmlAttributeDictionary,C:\repos\andrewdavey_cassette\src\Cassette\HtmlAttributeDictionary.cs,BuildAttributesString,The following statement contains a magic number: var builder = new StringBuilder(256);
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,EscapeToJavascriptString,The following statement contains a magic number: for (int i = 0; i < jsonString.Length; )              {                  c = jsonString[i++];                    if (c == '\\')                  {                      int remainingLength = jsonString.Length - i;                      if (remainingLength >= 2)                      {                          char lookahead = jsonString[i];                          if (lookahead == '\\')                          {                              sb.Append('\\');                              ++i;                          }                          else if (lookahead == '"')                          {                              sb.Append("\"");                              ++i;                          }                          else if (lookahead == 't')                          {                              sb.Append('\t');                              ++i;                          }                          else if (lookahead == 'b')                          {                              sb.Append('\b');                              ++i;                          }                          else if (lookahead == 'n')                          {                              sb.Append('\n');                              ++i;                          }                          else if (lookahead == 'r')                          {                              sb.Append('\r');                              ++i;                          }                      }                  }                  else                  {                      sb.Append(c);                  }              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                  {                      break;                  }                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (                                  !(success =                                    UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber'                                                    CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                                if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" &&                                          UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber'                                                          CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }  #if SILVERLIGHT                              s.Append(ConvertFromUtf32((int)codePoint));  #else                              s.Append(Char.ConvertFromUtf32((int)codePoint));  #endif                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                  {                      break;                  }                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (                                  !(success =                                    UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber'                                                    CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                                if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" &&                                          UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber'                                                          CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }  #if SILVERLIGHT                              s.Append(ConvertFromUtf32((int)codePoint));  #else                              s.Append(Char.ConvertFromUtf32((int)codePoint));  #endif                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                  {                      break;                  }                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (                                  !(success =                                    UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber'                                                    CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                                if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" &&                                          UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber'                                                          CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }  #if SILVERLIGHT                              s.Append(ConvertFromUtf32((int)codePoint));  #else                              s.Append(Char.ConvertFromUtf32((int)codePoint));  #endif                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                  {                      break;                  }                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (                                  !(success =                                    UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber'                                                    CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                                if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" &&                                          UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber'                                                          CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }  #if SILVERLIGHT                              s.Append(ConvertFromUtf32((int)codePoint));  #else                              s.Append(Char.ConvertFromUtf32((int)codePoint));  #endif                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                  {                      break;                  }                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (                                  !(success =                                    UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber'                                                    CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                                if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" &&                                          UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber'                                                          CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }  #if SILVERLIGHT                              s.Append(ConvertFromUtf32((int)codePoint));  #else                              s.Append(Char.ConvertFromUtf32((int)codePoint));  #endif                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                  {                      break;                  }                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (                                  !(success =                                    UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber'                                                    CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                                if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" &&                                          UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber'                                                          CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }  #if SILVERLIGHT                              s.Append(ConvertFromUtf32((int)codePoint));  #else                              s.Append(Char.ConvertFromUtf32((int)codePoint));  #endif                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                  {                      break;                  }                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (                                  !(success =                                    UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber'                                                    CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                                if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" &&                                          UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber'                                                          CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }  #if SILVERLIGHT                              s.Append(ConvertFromUtf32((int)codePoint));  #else                              s.Append(Char.ConvertFromUtf32((int)codePoint));  #endif                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                  {                      break;                  }                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (                                  !(success =                                    UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber'                                                    CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                                if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" &&                                          UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber'                                                          CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }  #if SILVERLIGHT                              s.Append(ConvertFromUtf32((int)codePoint));  #else                              s.Append(Char.ConvertFromUtf32((int)codePoint));  #endif                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                  {                      break;                  }                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (                                  !(success =                                    UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber'                                                    CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                                if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" &&                                          UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber'                                                          CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }  #if SILVERLIGHT                              s.Append(ConvertFromUtf32((int)codePoint));  #else                              s.Append(Char.ConvertFromUtf32((int)codePoint));  #endif                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' &&                      json[index + 1] == 'a' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 's' &&                      json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' &&                      json[index + 1] == 'a' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 's' &&                      json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' &&                      json[index + 1] == 'a' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 's' &&                      json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' &&                      json[index + 1] == 'a' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 's' &&                      json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' &&                      json[index + 1] == 'a' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 's' &&                      json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' &&                      json[index + 1] == 'r' &&                      json[index + 2] == 'u' &&                      json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' &&                      json[index + 1] == 'r' &&                      json[index + 2] == 'u' &&                      json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' &&                      json[index + 1] == 'r' &&                      json[index + 2] == 'u' &&                      json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' &&                      json[index + 1] == 'r' &&                      json[index + 2] == 'u' &&                      json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' &&                      json[index + 1] == 'u' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' &&                      json[index + 1] == 'u' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' &&                      json[index + 1] == 'u' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' &&                      json[index + 1] == 'u' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,EscapeToJavascriptString,The following statement contains a magic number: for (int i = 0; i < jsonString.Length; )              {                  c = jsonString[i++];                    if (c == '\\')                  {                      int remainingLength = jsonString.Length - i;                      if (remainingLength >= 2)                      {                          char lookahead = jsonString[i];                          if (lookahead == '\\')                          {                              sb.Append('\\');                              ++i;                          }                          else if (lookahead == '"')                          {                              sb.Append("\"");                              ++i;                          }                          else if (lookahead == 't')                          {                              sb.Append('\t');                              ++i;                          }                          else if (lookahead == 'b')                          {                              sb.Append('\b');                              ++i;                          }                          else if (lookahead == 'n')                          {                              sb.Append('\n');                              ++i;                          }                          else if (lookahead == 'r')                          {                              sb.Append('\r');                              ++i;                          }                      }                  }                  else                  {                      sb.Append(c);                  }              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                  {                      break;                  }                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (                                  !(success =                                    UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber'                                                    CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                                if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" &&                                          UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber'                                                          CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }  #if SILVERLIGHT                              s.Append(ConvertFromUtf32((int)codePoint));  #else                              s.Append(Char.ConvertFromUtf32((int)codePoint));  #endif                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                  {                      break;                  }                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (                                  !(success =                                    UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber'                                                    CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                                if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" &&                                          UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber'                                                          CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }  #if SILVERLIGHT                              s.Append(ConvertFromUtf32((int)codePoint));  #else                              s.Append(Char.ConvertFromUtf32((int)codePoint));  #endif                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                  {                      break;                  }                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (                                  !(success =                                    UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber'                                                    CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                                if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" &&                                          UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber'                                                          CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }  #if SILVERLIGHT                              s.Append(ConvertFromUtf32((int)codePoint));  #else                              s.Append(Char.ConvertFromUtf32((int)codePoint));  #endif                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                  {                      break;                  }                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (                                  !(success =                                    UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber'                                                    CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                                if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" &&                                          UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber'                                                          CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }  #if SILVERLIGHT                              s.Append(ConvertFromUtf32((int)codePoint));  #else                              s.Append(Char.ConvertFromUtf32((int)codePoint));  #endif                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                  {                      break;                  }                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (                                  !(success =                                    UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber'                                                    CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                                if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" &&                                          UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber'                                                          CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }  #if SILVERLIGHT                              s.Append(ConvertFromUtf32((int)codePoint));  #else                              s.Append(Char.ConvertFromUtf32((int)codePoint));  #endif                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                  {                      break;                  }                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (                                  !(success =                                    UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber'                                                    CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                                if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" &&                                          UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber'                                                          CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }  #if SILVERLIGHT                              s.Append(ConvertFromUtf32((int)codePoint));  #else                              s.Append(Char.ConvertFromUtf32((int)codePoint));  #endif                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                  {                      break;                  }                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (                                  !(success =                                    UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber'                                                    CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                                if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" &&                                          UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber'                                                          CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }  #if SILVERLIGHT                              s.Append(ConvertFromUtf32((int)codePoint));  #else                              s.Append(Char.ConvertFromUtf32((int)codePoint));  #endif                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                  {                      break;                  }                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (                                  !(success =                                    UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber'                                                    CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                                if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" &&                                          UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber'                                                          CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }  #if SILVERLIGHT                              s.Append(ConvertFromUtf32((int)codePoint));  #else                              s.Append(Char.ConvertFromUtf32((int)codePoint));  #endif                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                  {                      break;                  }                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (                                  !(success =                                    UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber'                                                    CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                                if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" &&                                          UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber'                                                          CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }  #if SILVERLIGHT                              s.Append(ConvertFromUtf32((int)codePoint));  #else                              s.Append(Char.ConvertFromUtf32((int)codePoint));  #endif                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' &&                      json[index + 1] == 'a' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 's' &&                      json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' &&                      json[index + 1] == 'a' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 's' &&                      json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' &&                      json[index + 1] == 'a' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 's' &&                      json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' &&                      json[index + 1] == 'a' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 's' &&                      json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' &&                      json[index + 1] == 'a' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 's' &&                      json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' &&                      json[index + 1] == 'r' &&                      json[index + 2] == 'u' &&                      json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' &&                      json[index + 1] == 'r' &&                      json[index + 2] == 'u' &&                      json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' &&                      json[index + 1] == 'r' &&                      json[index + 2] == 'u' &&                      json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' &&                      json[index + 1] == 'r' &&                      json[index + 2] == 'u' &&                      json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' &&                      json[index + 1] == 'u' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' &&                      json[index + 1] == 'u' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' &&                      json[index + 1] == 'u' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' &&                      json[index + 1] == 'u' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,Cassette.BundleProcessing,ReferenceParser,C:\repos\andrewdavey_cassette\src\Cassette\BundleProcessing\ReferenceParser.cs,ParsePaths,The following statement contains a magic number: for (var i = 10; i < comment.Length; i++)              {                  var c = comment[i];                  switch (state)                  {                      case State.None:                          if (char.IsWhiteSpace(c)) continue;                          else if (c == '"')                          {                              state = State.InDoubleQuote;                              pathStart = i + 1;                          }                          else if (c == '\'')                          {                              state = State.InSingleQuote;                              pathStart = i + 1;                          }                          else                          {                              state = State.InRawPath;                              pathStart = i;                          }                          break;                        case State.InSingleQuote:                          if (c == '\'')                          {                              yield return comment.Substring(pathStart' i - pathStart);                              state = State.None;                          }                          break;                        case State.InDoubleQuote:                          if (c == '"')                          {                              yield return comment.Substring(pathStart' i - pathStart);                              state = State.None;                          }                          break;                        case State.InRawPath:                          if (char.IsWhiteSpace(c))                          {                              yield return comment.Substring(pathStart' i - pathStart);                              state = State.None;                          }                          break;                  }              }
Magic Number,Cassette.HtmlTemplates,HtmlTemplateCommentParser,C:\repos\andrewdavey_cassette\src\Cassette\HtmlTemplates\HtmlTemplateCommentParser.cs,Parse,The following statement contains a magic number: for (var i = 0; i <= code.Length - 3; i++)              {                  switch (state)                  {                      case State.Code:                          if (code[i] == '\r')                          {                              if (i < code.Length - 1 && code[i + 1] == '\n')                              {                                  i++;                              }                              line++;                              continue;                          }                          else if (code[i] == '\n')                          {                              line++;                              continue;                          }                          else if (i < code.Length - 4 && code.Substring(i' 4) == "<!--")                          {                              state = State.Comment;                              i += 3;                              commentStart = i + 1;                          }                          break;                        case State.Comment:                          if (code.Substring(i' 3) == "-->")                          {                              yield return new Comment                              {                                  LineNumber = line'                                  Value = code.Substring(commentStart' i - commentStart)                              };                              i += 2;                              state = State.Code;                          }                          else if (code[i] == '\r')                          {                              if (i < code.Length - 1 && code[i + 1] == '\n')                              {                                  yield return new Comment                                  {                                      LineNumber = line'                                      Value = code.Substring(commentStart' i - commentStart)                                  };                                  i++;                                  commentStart = i + 1;                              }                              line++;                          }                          else if (code[i] == '\n')                          {                              yield return new Comment                              {                                  LineNumber = line'                                  Value = code.Substring(commentStart' i - commentStart)                              };                              i++;                              line++;                              commentStart = i;                          }                          break;                  }              }
Magic Number,Cassette.HtmlTemplates,HtmlTemplateCommentParser,C:\repos\andrewdavey_cassette\src\Cassette\HtmlTemplates\HtmlTemplateCommentParser.cs,Parse,The following statement contains a magic number: for (var i = 0; i <= code.Length - 3; i++)              {                  switch (state)                  {                      case State.Code:                          if (code[i] == '\r')                          {                              if (i < code.Length - 1 && code[i + 1] == '\n')                              {                                  i++;                              }                              line++;                              continue;                          }                          else if (code[i] == '\n')                          {                              line++;                              continue;                          }                          else if (i < code.Length - 4 && code.Substring(i' 4) == "<!--")                          {                              state = State.Comment;                              i += 3;                              commentStart = i + 1;                          }                          break;                        case State.Comment:                          if (code.Substring(i' 3) == "-->")                          {                              yield return new Comment                              {                                  LineNumber = line'                                  Value = code.Substring(commentStart' i - commentStart)                              };                              i += 2;                              state = State.Code;                          }                          else if (code[i] == '\r')                          {                              if (i < code.Length - 1 && code[i + 1] == '\n')                              {                                  yield return new Comment                                  {                                      LineNumber = line'                                      Value = code.Substring(commentStart' i - commentStart)                                  };                                  i++;                                  commentStart = i + 1;                              }                              line++;                          }                          else if (code[i] == '\n')                          {                              yield return new Comment                              {                                  LineNumber = line'                                  Value = code.Substring(commentStart' i - commentStart)                              };                              i++;                              line++;                              commentStart = i;                          }                          break;                  }              }
Magic Number,Cassette.HtmlTemplates,HtmlTemplateCommentParser,C:\repos\andrewdavey_cassette\src\Cassette\HtmlTemplates\HtmlTemplateCommentParser.cs,Parse,The following statement contains a magic number: for (var i = 0; i <= code.Length - 3; i++)              {                  switch (state)                  {                      case State.Code:                          if (code[i] == '\r')                          {                              if (i < code.Length - 1 && code[i + 1] == '\n')                              {                                  i++;                              }                              line++;                              continue;                          }                          else if (code[i] == '\n')                          {                              line++;                              continue;                          }                          else if (i < code.Length - 4 && code.Substring(i' 4) == "<!--")                          {                              state = State.Comment;                              i += 3;                              commentStart = i + 1;                          }                          break;                        case State.Comment:                          if (code.Substring(i' 3) == "-->")                          {                              yield return new Comment                              {                                  LineNumber = line'                                  Value = code.Substring(commentStart' i - commentStart)                              };                              i += 2;                              state = State.Code;                          }                          else if (code[i] == '\r')                          {                              if (i < code.Length - 1 && code[i + 1] == '\n')                              {                                  yield return new Comment                                  {                                      LineNumber = line'                                      Value = code.Substring(commentStart' i - commentStart)                                  };                                  i++;                                  commentStart = i + 1;                              }                              line++;                          }                          else if (code[i] == '\n')                          {                              yield return new Comment                              {                                  LineNumber = line'                                  Value = code.Substring(commentStart' i - commentStart)                              };                              i++;                              line++;                              commentStart = i;                          }                          break;                  }              }
Magic Number,Cassette.HtmlTemplates,HtmlTemplateCommentParser,C:\repos\andrewdavey_cassette\src\Cassette\HtmlTemplates\HtmlTemplateCommentParser.cs,Parse,The following statement contains a magic number: for (var i = 0; i <= code.Length - 3; i++)              {                  switch (state)                  {                      case State.Code:                          if (code[i] == '\r')                          {                              if (i < code.Length - 1 && code[i + 1] == '\n')                              {                                  i++;                              }                              line++;                              continue;                          }                          else if (code[i] == '\n')                          {                              line++;                              continue;                          }                          else if (i < code.Length - 4 && code.Substring(i' 4) == "<!--")                          {                              state = State.Comment;                              i += 3;                              commentStart = i + 1;                          }                          break;                        case State.Comment:                          if (code.Substring(i' 3) == "-->")                          {                              yield return new Comment                              {                                  LineNumber = line'                                  Value = code.Substring(commentStart' i - commentStart)                              };                              i += 2;                              state = State.Code;                          }                          else if (code[i] == '\r')                          {                              if (i < code.Length - 1 && code[i + 1] == '\n')                              {                                  yield return new Comment                                  {                                      LineNumber = line'                                      Value = code.Substring(commentStart' i - commentStart)                                  };                                  i++;                                  commentStart = i + 1;                              }                              line++;                          }                          else if (code[i] == '\n')                          {                              yield return new Comment                              {                                  LineNumber = line'                                  Value = code.Substring(commentStart' i - commentStart)                              };                              i++;                              line++;                              commentStart = i;                          }                          break;                  }              }
Magic Number,Cassette.HtmlTemplates,HtmlTemplateCommentParser,C:\repos\andrewdavey_cassette\src\Cassette\HtmlTemplates\HtmlTemplateCommentParser.cs,Parse,The following statement contains a magic number: for (var i = 0; i <= code.Length - 3; i++)              {                  switch (state)                  {                      case State.Code:                          if (code[i] == '\r')                          {                              if (i < code.Length - 1 && code[i + 1] == '\n')                              {                                  i++;                              }                              line++;                              continue;                          }                          else if (code[i] == '\n')                          {                              line++;                              continue;                          }                          else if (i < code.Length - 4 && code.Substring(i' 4) == "<!--")                          {                              state = State.Comment;                              i += 3;                              commentStart = i + 1;                          }                          break;                        case State.Comment:                          if (code.Substring(i' 3) == "-->")                          {                              yield return new Comment                              {                                  LineNumber = line'                                  Value = code.Substring(commentStart' i - commentStart)                              };                              i += 2;                              state = State.Code;                          }                          else if (code[i] == '\r')                          {                              if (i < code.Length - 1 && code[i + 1] == '\n')                              {                                  yield return new Comment                                  {                                      LineNumber = line'                                      Value = code.Substring(commentStart' i - commentStart)                                  };                                  i++;                                  commentStart = i + 1;                              }                              line++;                          }                          else if (code[i] == '\n')                          {                              yield return new Comment                              {                                  LineNumber = line'                                  Value = code.Substring(commentStart' i - commentStart)                              };                              i++;                              line++;                              commentStart = i;                          }                          break;                  }              }
Magic Number,Cassette.HtmlTemplates,HtmlTemplateCommentParser,C:\repos\andrewdavey_cassette\src\Cassette\HtmlTemplates\HtmlTemplateCommentParser.cs,Parse,The following statement contains a magic number: for (var i = 0; i <= code.Length - 3; i++)              {                  switch (state)                  {                      case State.Code:                          if (code[i] == '\r')                          {                              if (i < code.Length - 1 && code[i + 1] == '\n')                              {                                  i++;                              }                              line++;                              continue;                          }                          else if (code[i] == '\n')                          {                              line++;                              continue;                          }                          else if (i < code.Length - 4 && code.Substring(i' 4) == "<!--")                          {                              state = State.Comment;                              i += 3;                              commentStart = i + 1;                          }                          break;                        case State.Comment:                          if (code.Substring(i' 3) == "-->")                          {                              yield return new Comment                              {                                  LineNumber = line'                                  Value = code.Substring(commentStart' i - commentStart)                              };                              i += 2;                              state = State.Code;                          }                          else if (code[i] == '\r')                          {                              if (i < code.Length - 1 && code[i + 1] == '\n')                              {                                  yield return new Comment                                  {                                      LineNumber = line'                                      Value = code.Substring(commentStart' i - commentStart)                                  };                                  i++;                                  commentStart = i + 1;                              }                              line++;                          }                          else if (code[i] == '\n')                          {                              yield return new Comment                              {                                  LineNumber = line'                                  Value = code.Substring(commentStart' i - commentStart)                              };                              i++;                              line++;                              commentStart = i;                          }                          break;                  }              }
Magic Number,Cassette.IO,FileSystemDirectory,C:\repos\andrewdavey_cassette\src\Cassette\IO\FileSystemDirectory.cs,GetAbsolutePath,The following statement contains a magic number: if (filename.StartsWith("~/"))              {                  return GetRootDirectory().GetAbsolutePath(filename.Substring(2));              }
Magic Number,Cassette.IO,FileSystemDirectory,C:\repos\andrewdavey_cassette\src\Cassette\IO\FileSystemDirectory.cs,GetDirectory,The following statement contains a magic number: if (path[0] == '~')              {                  path = path.Length == 1 ? "" : path.Substring(2);                  return GetRootDirectory().GetDirectory(path);              }
Magic Number,Cassette.IO,IsolatedStorageDirectory,C:\repos\andrewdavey_cassette\src\Cassette\IO\IsolatedStorageDirectory.cs,GetFile,The following statement contains a magic number: if (parts.Length > 2)              {                  var subDirectory = string.Join("/"' parts.Reverse().Skip(1).Reverse().ToArray());                  directory = new IsolatedStorageDirectory(getStorage' subDirectory);              }              else              {                  directory = this;              }
Magic Number,Cassette.IO,IsolatedStorageFile,C:\repos\andrewdavey_cassette\src\Cassette\IO\IsolatedStorageFile.cs,IsolatedStorageFile,The following statement contains a magic number: systemFilename = filename.Substring(2);
Magic Number,Cassette.Scripts,JavaScriptCommentParser,C:\repos\andrewdavey_cassette\src\Cassette\Scripts\JavaScriptCommentParser.cs,Parse,The following statement contains a magic number: for (var i = 0; i < code.Length; i++)              {                  var c = code[i];                    if (c == '\r')                  {                      if (i < code.Length - 1 && code[i + 1] == '\n')                      {                          i++;                      }                      line++;                      continue;                  }                  else if (c == '\n')                  {                      line++;                      continue;                  }                    switch (state)                  {                      case State.Code:                          if (c != '/') continue;                          if (i >= code.Length - 2) yield break;                          if (code[i + 1] == '/')                          {                              state = State.SingleLineComment;                              commentStart = i + 2;                              i++; // Skip the '/'                          }                          else if (code[i + 1] == '*')                          {                              state = State.MultiLineComment;                              commentStart = i + 2;                              i++; // Skip the '*'                          }                          break;                        case State.SingleLineComment:                          // Scan forward until newline or end of code.                          while (i < code.Length && code[i] != '\r' && code[i] != '\n')                          {                              i++;                          }                          yield return new Comment                          {                              LineNumber = line'                              Value = code.Substring(commentStart' i - commentStart)                          };                          if (i < code.Length - 1 && code[i] == '\r' && code[i + 1] == '\n') i++;                          line++;                          state = State.Code;                          break;                        case State.MultiLineComment:                          // Scan forwards until "*/" or end of code.                          while (i < code.Length - 1 && (code[i] != '*' || code[i + 1] != '/'))                          {                              // Track new lines within the comment.                              switch (code[i])                              {                                  case '\r':                                      yield return new Comment                                      {                                          LineNumber = line'                                          Value = code.Substring(commentStart' i - commentStart)                                      };                                      i++;                                      if (i < code.Length && code[i] == '\n')                                      {                                          i++;                                      }                                      commentStart = i;                                      line++;                                      break;                                    case '\n':                                      yield return new Comment                                      {                                          LineNumber = line'                                          Value = code.Substring(commentStart' i - commentStart)                                      };                                      i++;                                      commentStart = i;                                      line++;                                      break;                                    default:                                      i++;                                      break;                              }                          }                          yield return new Comment                          {                              LineNumber = line'                              Value = code.Substring(commentStart' i - commentStart)                          };                          i++; // Skip the '/'                          state = State.Code;                          break;                  }              }
Magic Number,Cassette.Scripts,JavaScriptCommentParser,C:\repos\andrewdavey_cassette\src\Cassette\Scripts\JavaScriptCommentParser.cs,Parse,The following statement contains a magic number: for (var i = 0; i < code.Length; i++)              {                  var c = code[i];                    if (c == '\r')                  {                      if (i < code.Length - 1 && code[i + 1] == '\n')                      {                          i++;                      }                      line++;                      continue;                  }                  else if (c == '\n')                  {                      line++;                      continue;                  }                    switch (state)                  {                      case State.Code:                          if (c != '/') continue;                          if (i >= code.Length - 2) yield break;                          if (code[i + 1] == '/')                          {                              state = State.SingleLineComment;                              commentStart = i + 2;                              i++; // Skip the '/'                          }                          else if (code[i + 1] == '*')                          {                              state = State.MultiLineComment;                              commentStart = i + 2;                              i++; // Skip the '*'                          }                          break;                        case State.SingleLineComment:                          // Scan forward until newline or end of code.                          while (i < code.Length && code[i] != '\r' && code[i] != '\n')                          {                              i++;                          }                          yield return new Comment                          {                              LineNumber = line'                              Value = code.Substring(commentStart' i - commentStart)                          };                          if (i < code.Length - 1 && code[i] == '\r' && code[i + 1] == '\n') i++;                          line++;                          state = State.Code;                          break;                        case State.MultiLineComment:                          // Scan forwards until "*/" or end of code.                          while (i < code.Length - 1 && (code[i] != '*' || code[i + 1] != '/'))                          {                              // Track new lines within the comment.                              switch (code[i])                              {                                  case '\r':                                      yield return new Comment                                      {                                          LineNumber = line'                                          Value = code.Substring(commentStart' i - commentStart)                                      };                                      i++;                                      if (i < code.Length && code[i] == '\n')                                      {                                          i++;                                      }                                      commentStart = i;                                      line++;                                      break;                                    case '\n':                                      yield return new Comment                                      {                                          LineNumber = line'                                          Value = code.Substring(commentStart' i - commentStart)                                      };                                      i++;                                      commentStart = i;                                      line++;                                      break;                                    default:                                      i++;                                      break;                              }                          }                          yield return new Comment                          {                              LineNumber = line'                              Value = code.Substring(commentStart' i - commentStart)                          };                          i++; // Skip the '/'                          state = State.Code;                          break;                  }              }
Magic Number,Cassette.Scripts,JavaScriptCommentParser,C:\repos\andrewdavey_cassette\src\Cassette\Scripts\JavaScriptCommentParser.cs,Parse,The following statement contains a magic number: for (var i = 0; i < code.Length; i++)              {                  var c = code[i];                    if (c == '\r')                  {                      if (i < code.Length - 1 && code[i + 1] == '\n')                      {                          i++;                      }                      line++;                      continue;                  }                  else if (c == '\n')                  {                      line++;                      continue;                  }                    switch (state)                  {                      case State.Code:                          if (c != '/') continue;                          if (i >= code.Length - 2) yield break;                          if (code[i + 1] == '/')                          {                              state = State.SingleLineComment;                              commentStart = i + 2;                              i++; // Skip the '/'                          }                          else if (code[i + 1] == '*')                          {                              state = State.MultiLineComment;                              commentStart = i + 2;                              i++; // Skip the '*'                          }                          break;                        case State.SingleLineComment:                          // Scan forward until newline or end of code.                          while (i < code.Length && code[i] != '\r' && code[i] != '\n')                          {                              i++;                          }                          yield return new Comment                          {                              LineNumber = line'                              Value = code.Substring(commentStart' i - commentStart)                          };                          if (i < code.Length - 1 && code[i] == '\r' && code[i + 1] == '\n') i++;                          line++;                          state = State.Code;                          break;                        case State.MultiLineComment:                          // Scan forwards until "*/" or end of code.                          while (i < code.Length - 1 && (code[i] != '*' || code[i + 1] != '/'))                          {                              // Track new lines within the comment.                              switch (code[i])                              {                                  case '\r':                                      yield return new Comment                                      {                                          LineNumber = line'                                          Value = code.Substring(commentStart' i - commentStart)                                      };                                      i++;                                      if (i < code.Length && code[i] == '\n')                                      {                                          i++;                                      }                                      commentStart = i;                                      line++;                                      break;                                    case '\n':                                      yield return new Comment                                      {                                          LineNumber = line'                                          Value = code.Substring(commentStart' i - commentStart)                                      };                                      i++;                                      commentStart = i;                                      line++;                                      break;                                    default:                                      i++;                                      break;                              }                          }                          yield return new Comment                          {                              LineNumber = line'                              Value = code.Substring(commentStart' i - commentStart)                          };                          i++; // Skip the '/'                          state = State.Code;                          break;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,EscapeToJavascriptString,The following statement contains a magic number: for (int i = 0; i < jsonString.Length; )              {                  c = jsonString[i++];                    if (c == '\\')                  {                      int remainingLength = jsonString.Length - i;                      if (remainingLength >= 2)                      {                          char lookahead = jsonString[i];                          if (lookahead == '\\')                          {                              sb.Append('\\');                              ++i;                          }                          else if (lookahead == '"')                          {                              sb.Append("\"");                              ++i;                          }                          else if (lookahead == 't')                          {                              sb.Append('\t');                              ++i;                          }                          else if (lookahead == 'b')                          {                              sb.Append('\b');                              ++i;                          }                          else if (lookahead == 'n')                          {                              sb.Append('\n');                              ++i;                          }                          else if (lookahead == 'r')                          {                              sb.Append('\r');                              ++i;                          }                      }                  }                  else                  {                      sb.Append(c);                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                  {                      break;                  }                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (                                  !(success =                                    UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber'                                                    CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                                if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" &&                                          UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber'                                                          CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }  #if SILVERLIGHT                              s.Append(ConvertFromUtf32((int)codePoint));  #else                              s.Append(Char.ConvertFromUtf32((int)codePoint));  #endif                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                  {                      break;                  }                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (                                  !(success =                                    UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber'                                                    CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                                if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" &&                                          UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber'                                                          CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }  #if SILVERLIGHT                              s.Append(ConvertFromUtf32((int)codePoint));  #else                              s.Append(Char.ConvertFromUtf32((int)codePoint));  #endif                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                  {                      break;                  }                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (                                  !(success =                                    UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber'                                                    CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                                if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" &&                                          UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber'                                                          CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }  #if SILVERLIGHT                              s.Append(ConvertFromUtf32((int)codePoint));  #else                              s.Append(Char.ConvertFromUtf32((int)codePoint));  #endif                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                  {                      break;                  }                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (                                  !(success =                                    UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber'                                                    CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                                if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" &&                                          UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber'                                                          CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }  #if SILVERLIGHT                              s.Append(ConvertFromUtf32((int)codePoint));  #else                              s.Append(Char.ConvertFromUtf32((int)codePoint));  #endif                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                  {                      break;                  }                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (                                  !(success =                                    UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber'                                                    CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                                if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" &&                                          UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber'                                                          CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }  #if SILVERLIGHT                              s.Append(ConvertFromUtf32((int)codePoint));  #else                              s.Append(Char.ConvertFromUtf32((int)codePoint));  #endif                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                  {                      break;                  }                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (                                  !(success =                                    UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber'                                                    CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                                if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" &&                                          UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber'                                                          CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }  #if SILVERLIGHT                              s.Append(ConvertFromUtf32((int)codePoint));  #else                              s.Append(Char.ConvertFromUtf32((int)codePoint));  #endif                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                  {                      break;                  }                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (                                  !(success =                                    UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber'                                                    CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                                if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" &&                                          UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber'                                                          CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }  #if SILVERLIGHT                              s.Append(ConvertFromUtf32((int)codePoint));  #else                              s.Append(Char.ConvertFromUtf32((int)codePoint));  #endif                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                  {                      break;                  }                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (                                  !(success =                                    UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber'                                                    CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                                if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" &&                                          UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber'                                                          CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }  #if SILVERLIGHT                              s.Append(ConvertFromUtf32((int)codePoint));  #else                              s.Append(Char.ConvertFromUtf32((int)codePoint));  #endif                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                  {                      break;                  }                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (                                  !(success =                                    UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber'                                                    CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                                if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" &&                                          UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber'                                                          CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }  #if SILVERLIGHT                              s.Append(ConvertFromUtf32((int)codePoint));  #else                              s.Append(Char.ConvertFromUtf32((int)codePoint));  #endif                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' &&                      json[index + 1] == 'a' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 's' &&                      json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' &&                      json[index + 1] == 'a' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 's' &&                      json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' &&                      json[index + 1] == 'a' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 's' &&                      json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' &&                      json[index + 1] == 'a' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 's' &&                      json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' &&                      json[index + 1] == 'a' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 's' &&                      json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' &&                      json[index + 1] == 'r' &&                      json[index + 2] == 'u' &&                      json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' &&                      json[index + 1] == 'r' &&                      json[index + 2] == 'u' &&                      json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' &&                      json[index + 1] == 'r' &&                      json[index + 2] == 'u' &&                      json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' &&                      json[index + 1] == 'r' &&                      json[index + 2] == 'u' &&                      json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' &&                      json[index + 1] == 'u' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' &&                      json[index + 1] == 'u' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' &&                      json[index + 1] == 'u' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' &&                      json[index + 1] == 'u' &&                      json[index + 2] == 'l' &&                      json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,Cassette.Stylesheets,CssCommentParser,C:\repos\andrewdavey_cassette\src\Cassette\Stylesheets\CssCommentParser.cs,Parse,The following statement contains a magic number: for (var i = 0; i < code.Length; i++)              {                  var c = code[i];                    if (c == '\r')                  {                      if (i < code.Length - 1 && code[i + 1] == '\n')                      {                          i++;                      }                      line++;                      continue;                  }                  else if (c == '\n')                  {                      line++;                      continue;                  }                    switch (state)                  {                      case State.Code:                          if (c != '/') continue;                          if (i >= code.Length - 2) yield break;                          if (code[i + 1] == '*')                          {                              state = State.Comment;                              commentStart = i + 2;                              i++; // Skip the '*'                          }                          break;                        case State.Comment:                          // Scan forwards until "*/" or end of code.                          while (i < code.Length - 1 && (code[i] != '*' || code[i + 1] != '/'))                          {                              // Track new lines within the comment.                              switch (code[i])                              {                                  case '\r':                                      yield return new Comment                                      {                                          LineNumber = line'                                          Value = code.Substring(commentStart' i - commentStart)                                      };                                      i++;                                      if (i < code.Length && code[i] == '\n')                                      {                                          i++;                                      }                                      commentStart = i;                                      line++;                                      break;                                    case '\n':                                      yield return new Comment                                      {                                          LineNumber = line'                                          Value = code.Substring(commentStart' i - commentStart)                                      };                                      i++;                                      commentStart = i;                                      line++;                                      break;                                    default:                                      i++;                                      break;                              }                          }                          yield return new Comment                          {                              LineNumber = line'                              Value = code.Substring(commentStart' i - commentStart)                          };                          i++; // Skip the '/'                          state = State.Code;                          break;                  }              }
Magic Number,Cassette.Stylesheets,CssCommentParser,C:\repos\andrewdavey_cassette\src\Cassette\Stylesheets\CssCommentParser.cs,Parse,The following statement contains a magic number: for (var i = 0; i < code.Length; i++)              {                  var c = code[i];                    if (c == '\r')                  {                      if (i < code.Length - 1 && code[i + 1] == '\n')                      {                          i++;                      }                      line++;                      continue;                  }                  else if (c == '\n')                  {                      line++;                      continue;                  }                    switch (state)                  {                      case State.Code:                          if (c != '/') continue;                          if (i >= code.Length - 2) yield break;                          if (code[i + 1] == '*')                          {                              state = State.Comment;                              commentStart = i + 2;                              i++; // Skip the '*'                          }                          break;                        case State.Comment:                          // Scan forwards until "*/" or end of code.                          while (i < code.Length - 1 && (code[i] != '*' || code[i + 1] != '/'))                          {                              // Track new lines within the comment.                              switch (code[i])                              {                                  case '\r':                                      yield return new Comment                                      {                                          LineNumber = line'                                          Value = code.Substring(commentStart' i - commentStart)                                      };                                      i++;                                      if (i < code.Length && code[i] == '\n')                                      {                                          i++;                                      }                                      commentStart = i;                                      line++;                                      break;                                    case '\n':                                      yield return new Comment                                      {                                          LineNumber = line'                                          Value = code.Substring(commentStart' i - commentStart)                                      };                                      i++;                                      commentStart = i;                                      line++;                                      break;                                    default:                                      i++;                                      break;                              }                          }                          yield return new Comment                          {                              LineNumber = line'                              Value = code.Substring(commentStart' i - commentStart)                          };                          i++; // Skip the '/'                          state = State.Code;                          break;                  }              }
Magic Number,Cassette.Stylesheets,CssBackgroundImageUrlMatchTransformer,C:\repos\andrewdavey_cassette\src\Cassette\Stylesheets\CssImageToDataUriTransformer.cs,FileIsTooLargeForInternetExplorer8,The following statement contains a magic number: const int internetExplorer8DataUriSizeLimitInBytes = 32768;
Magic Number,Cassette.TinyIoC,GenericMethodCacheKey,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,GenerateHashCode,The following statement contains a magic number: unchecked                  {                      var result = _sourceType.GetHashCode();                        result = (result * 397) ^ _methodName.GetHashCode();                        for (int i = 0; i < _genericTypes.Length; ++i)                      {                          result = (result * 397) ^ _genericTypes[i].GetHashCode();                      }                        for (int i = 0; i < _parameterTypes.Length; ++i)                      {                          result = (result * 397) ^ _parameterTypes[i].GetHashCode();                      }                        return result;                  }
Magic Number,Cassette.TinyIoC,GenericMethodCacheKey,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,GenerateHashCode,The following statement contains a magic number: unchecked                  {                      var result = _sourceType.GetHashCode();                        result = (result * 397) ^ _methodName.GetHashCode();                        for (int i = 0; i < _genericTypes.Length; ++i)                      {                          result = (result * 397) ^ _genericTypes[i].GetHashCode();                      }                        for (int i = 0; i < _parameterTypes.Length; ++i)                      {                          result = (result * 397) ^ _parameterTypes[i].GetHashCode();                      }                        return result;                  }
Magic Number,Cassette.TinyIoC,GenericMethodCacheKey,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,GenerateHashCode,The following statement contains a magic number: unchecked                  {                      var result = _sourceType.GetHashCode();                        result = (result * 397) ^ _methodName.GetHashCode();                        for (int i = 0; i < _genericTypes.Length; ++i)                      {                          result = (result * 397) ^ _genericTypes[i].GetHashCode();                      }                        for (int i = 0; i < _parameterTypes.Length; ++i)                      {                          result = (result * 397) ^ _parameterTypes[i].GetHashCode();                      }                        return result;                  }
Magic Number,Cassette.TinyIoC,TinyIoCContainer,C:\repos\andrewdavey_cassette\src\Cassette\TinyIoC\TinyIoC.cs,GetLazyAutomaticFactoryRequest,The following statement contains a magic number: if ((genericType == typeof(Func<''>) && type.GetGenericArguments()[0] == typeof(string) && type.GetGenericArguments()[1] == typeof(IDictionary<string' object>)))              {                  Type returnType = genericArguments[2];                    var name = Expression.Parameter(typeof(string)' "name");                  var parameters = Expression.Parameter(typeof(IDictionary<string' object>)' "parameters");                    MethodInfo resolveMethod = typeof(TinyIoCContainer).GetMethod("Resolve"' new Type[] { typeof(String)' typeof(NamedParameterOverloads) });                  resolveMethod = resolveMethod.MakeGenericMethod(returnType);                    var resolveCall = Expression.Call(Expression.Constant(this)' resolveMethod' name' Expression.Call(typeof(NamedParameterOverloads)' "FromIDictionary"' null' parameters));                    var resolveLambda = Expression.Lambda(resolveCall' name' parameters).Compile();                    return resolveLambda;              }
Magic Number,Cassette.Utilities,ByteArrayExtensions,C:\repos\andrewdavey_cassette\src\Cassette\Utilities\ByteArrayExtensions.cs,FromHexString,The following statement contains a magic number: var bytes = new byte[hex.Length / 2];
Magic Number,Cassette.Utilities,ByteArrayExtensions,C:\repos\andrewdavey_cassette\src\Cassette\Utilities\ByteArrayExtensions.cs,FromHexString,The following statement contains a magic number: for (var i = 0; i < hex.Length; i += 2)              {                  bytes[i / 2] = Convert.ToByte(hex.Substring(i' 2)' 16);              }
Magic Number,Cassette.Utilities,ByteArrayExtensions,C:\repos\andrewdavey_cassette\src\Cassette\Utilities\ByteArrayExtensions.cs,FromHexString,The following statement contains a magic number: for (var i = 0; i < hex.Length; i += 2)              {                  bytes[i / 2] = Convert.ToByte(hex.Substring(i' 2)' 16);              }
Magic Number,Cassette.Utilities,ByteArrayExtensions,C:\repos\andrewdavey_cassette\src\Cassette\Utilities\ByteArrayExtensions.cs,FromHexString,The following statement contains a magic number: for (var i = 0; i < hex.Length; i += 2)              {                  bytes[i / 2] = Convert.ToByte(hex.Substring(i' 2)' 16);              }
Magic Number,Cassette.Utilities,ByteArrayExtensions,C:\repos\andrewdavey_cassette\src\Cassette\Utilities\ByteArrayExtensions.cs,FromHexString,The following statement contains a magic number: for (var i = 0; i < hex.Length; i += 2)              {                  bytes[i / 2] = Convert.ToByte(hex.Substring(i' 2)' 16);              }
Missing Default,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseValue,The following switch statement is missing a default case: switch (LookAhead(json' index))              {                  case TOKEN_STRING:                      return ParseString(json' ref index' ref success);                  case TOKEN_NUMBER:                      return ParseNumber(json' ref index' ref success);                  case TOKEN_CURLY_OPEN:                      return ParseObject(json' ref index' ref success);                  case TOKEN_SQUARED_OPEN:                      return ParseArray(json' ref index' ref success);                  case TOKEN_TRUE:                      NextToken(json' ref index);                      return true;                  case TOKEN_FALSE:                      NextToken(json' ref index);                      return false;                  case TOKEN_NULL:                      NextToken(json' ref index);                      return null;                  case TOKEN_NONE:                      break;              }
Missing Default,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following switch statement is missing a default case: switch (c)              {                  case '{':                      return TOKEN_CURLY_OPEN;                  case '}':                      return TOKEN_CURLY_CLOSE;                  case '[':                      return TOKEN_SQUARED_OPEN;                  case ']':                      return TOKEN_SQUARED_CLOSE;                  case ''':                      return TOKEN_COMMA;                  case '"':                      return TOKEN_STRING;                  case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                      return TOKEN_NUMBER;                  case ':':                      return TOKEN_COLON;              }
Missing Default,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseValue,The following switch statement is missing a default case: switch (LookAhead(json' index))              {                  case TOKEN_STRING:                      return ParseString(json' ref index' ref success);                  case TOKEN_NUMBER:                      return ParseNumber(json' ref index' ref success);                  case TOKEN_CURLY_OPEN:                      return ParseObject(json' ref index' ref success);                  case TOKEN_SQUARED_OPEN:                      return ParseArray(json' ref index' ref success);                  case TOKEN_TRUE:                      NextToken(json' ref index);                      return true;                  case TOKEN_FALSE:                      NextToken(json' ref index);                      return false;                  case TOKEN_NULL:                      NextToken(json' ref index);                      return null;                  case TOKEN_NONE:                      break;              }
Missing Default,Cassette,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following switch statement is missing a default case: switch (c)              {                  case '{':                      return TOKEN_CURLY_OPEN;                  case '}':                      return TOKEN_CURLY_CLOSE;                  case '[':                      return TOKEN_SQUARED_OPEN;                  case ']':                      return TOKEN_SQUARED_CLOSE;                  case ''':                      return TOKEN_COMMA;                  case '"':                      return TOKEN_STRING;                  case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                      return TOKEN_NUMBER;                  case ':':                      return TOKEN_COLON;              }
Missing Default,Cassette.BundleProcessing,ReferenceParser,C:\repos\andrewdavey_cassette\src\Cassette\BundleProcessing\ReferenceParser.cs,ParsePaths,The following switch statement is missing a default case: switch (state)                  {                      case State.None:                          if (char.IsWhiteSpace(c)) continue;                          else if (c == '"')                          {                              state = State.InDoubleQuote;                              pathStart = i + 1;                          }                          else if (c == '\'')                          {                              state = State.InSingleQuote;                              pathStart = i + 1;                          }                          else                          {                              state = State.InRawPath;                              pathStart = i;                          }                          break;                        case State.InSingleQuote:                          if (c == '\'')                          {                              yield return comment.Substring(pathStart' i - pathStart);                              state = State.None;                          }                          break;                        case State.InDoubleQuote:                          if (c == '"')                          {                              yield return comment.Substring(pathStart' i - pathStart);                              state = State.None;                          }                          break;                        case State.InRawPath:                          if (char.IsWhiteSpace(c))                          {                              yield return comment.Substring(pathStart' i - pathStart);                              state = State.None;                          }                          break;                  }
Missing Default,Cassette.HtmlTemplates,HtmlTemplateCommentParser,C:\repos\andrewdavey_cassette\src\Cassette\HtmlTemplates\HtmlTemplateCommentParser.cs,Parse,The following switch statement is missing a default case: switch (state)                  {                      case State.Code:                          if (code[i] == '\r')                          {                              if (i < code.Length - 1 && code[i + 1] == '\n')                              {                                  i++;                              }                              line++;                              continue;                          }                          else if (code[i] == '\n')                          {                              line++;                              continue;                          }                          else if (i < code.Length - 4 && code.Substring(i' 4) == "<!--")                          {                              state = State.Comment;                              i += 3;                              commentStart = i + 1;                          }                          break;                        case State.Comment:                          if (code.Substring(i' 3) == "-->")                          {                              yield return new Comment                              {                                  LineNumber = line'                                  Value = code.Substring(commentStart' i - commentStart)                              };                              i += 2;                              state = State.Code;                          }                          else if (code[i] == '\r')                          {                              if (i < code.Length - 1 && code[i + 1] == '\n')                              {                                  yield return new Comment                                  {                                      LineNumber = line'                                      Value = code.Substring(commentStart' i - commentStart)                                  };                                  i++;                                  commentStart = i + 1;                              }                              line++;                          }                          else if (code[i] == '\n')                          {                              yield return new Comment                              {                                  LineNumber = line'                                  Value = code.Substring(commentStart' i - commentStart)                              };                              i++;                              line++;                              commentStart = i;                          }                          break;                  }
Missing Default,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,ParseValue,The following switch statement is missing a default case: switch (LookAhead(json' index))              {                  case TOKEN_STRING:                      return ParseString(json' ref index' ref success);                  case TOKEN_NUMBER:                      return ParseNumber(json' ref index' ref success);                  case TOKEN_CURLY_OPEN:                      return ParseObject(json' ref index' ref success);                  case TOKEN_SQUARED_OPEN:                      return ParseArray(json' ref index' ref success);                  case TOKEN_TRUE:                      NextToken(json' ref index);                      return true;                  case TOKEN_FALSE:                      NextToken(json' ref index);                      return false;                  case TOKEN_NULL:                      NextToken(json' ref index);                      return null;                  case TOKEN_NONE:                      break;              }
Missing Default,Reflection,SimpleJson,C:\repos\andrewdavey_cassette\src\Cassette\SimpleJson\SimpleJson.cs,NextToken,The following switch statement is missing a default case: switch (c)              {                  case '{':                      return TOKEN_CURLY_OPEN;                  case '}':                      return TOKEN_CURLY_CLOSE;                  case '[':                      return TOKEN_SQUARED_OPEN;                  case ']':                      return TOKEN_SQUARED_CLOSE;                  case ''':                      return TOKEN_COMMA;                  case '"':                      return TOKEN_STRING;                  case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                      return TOKEN_NUMBER;                  case ':':                      return TOKEN_COLON;              }
