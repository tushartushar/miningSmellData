Implementation smell,Namespace,Class,File,Method,Description
Long Statement,Akka.Cluster.Tests.MultiNode,ClusterAccrualFailureDetectorSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ClusterAccrualFailureDetectorSpec.cs,ClusterAccrualFailureDetectorSpecs,The length of the statement  "            A_heartbeat_driven_Failure_Detector_mark_node_as_unavailable_when_network_partition_and_then_back_to_available_when_partition_is_healed " is 135.
Long Statement,Akka.Cluster.Tests.MultiNode,ClusterAccrualFailureDetectorSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ClusterAccrualFailureDetectorSpec.cs,ClusterAccrualFailureDetectorSpecs,The length of the statement  "            A_heartbeat_driven_Failure_Detector_mark_node_as_unavailable_if_a_node_in_the_cluster_is_shut_down_and_its_heartbeats_stops " is 123.
Long Statement,Akka.Cluster.Tests.MultiNode,ClusterDeathWatchSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ClusterDeathWatchSpec.cs,ClusterDeathWatchSpecTests,The length of the statement  "            An_actor_watching_a_remote_actor_in_the_cluster_must_be_able_to_watch_actor_before_node_joins_cluster_and_cluster_remote_watcher_takes_over_from_remote_watcher(); " is 162.
Long Statement,Akka.Cluster.Tests.MultiNode,ClusterDeathWatchSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ClusterDeathWatchSpec.cs,ClusterDeathWatchSpecTests,The length of the statement  "            An_actor_watching_a_remote_actor_in_the_cluster_must_be_able_to_shutdown_system_when_using_remote_deployed_actor_on_node_that_crashed(); " is 136.
Long Statement,Akka.Cluster.Tests.MultiNode,ClusterDeathWatchSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ClusterDeathWatchSpec.cs,An_actor_watching_a_remote_actor_in_the_cluster_must_receive_terminated_when_watched_node_becomes_down_removed,The length of the statement  "                    AwaitAssert(() => Assert.DoesNotContain(GetAddress(_config.Third)' ClusterView.UnreachableMembers.Select(x => x.Address))); " is 123.
Long Statement,Akka.Cluster.Tests.MultiNode,ClusterDeathWatchSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ClusterDeathWatchSpec.cs,An_actor_watching_a_remote_actor_in_the_cluster_must_receive_terminated_when_watched_node_becomes_down_removed,The length of the statement  "                        AwaitAssert(() => Assert.DoesNotContain(GetAddress(_config.Second)' ClusterView.UnreachableMembers.Select(x => x.Address))); " is 124.
Long Statement,Akka.Cluster.Tests.MultiNode,ClusterDeathWatchSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ClusterDeathWatchSpec.cs,An_actor_watching_a_remote_actor_in_the_cluster_must_be_able_to_watch_actor_before_node_joins_cluster_and_cluster_remote_watcher_takes_over_from_remote_watcher,The length of the statement  "                    Sys.ActorSelection(new RootActorPath(GetAddress(_config.Fifth)) / "user" / "subject5").Tell(new Identify("subject5")' TestActor); " is 129.
Long Statement,Akka.Cluster.Tests.MultiNode,ClusterDeathWatchSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ClusterDeathWatchSpec.cs,An_actor_watching_a_remote_actor_in_the_cluster_must_be_able_to_watch_actor_before_node_joins_cluster_and_cluster_remote_watcher_takes_over_from_remote_watcher,The length of the statement  "                    AwaitAssert(() => ClusterView.UnreachableMembers.Select(x => x.Address).Contains(GetAddress(_config.Fifth)).ShouldBeTrue()); " is 124.
Long Statement,Akka.Cluster.Tests.MultiNode,ClusterDeathWatchSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ClusterDeathWatchSpec.cs,An_actor_watching_a_remote_actor_in_the_cluster_must_be_able_to_watch_actor_before_node_joins_cluster_and_cluster_remote_watcher_takes_over_from_remote_watcher,The length of the statement  "                    AwaitAssert(() => Assert.DoesNotContain(GetAddress(_config.Fifth)' ClusterView.UnreachableMembers.Select(x => x.Address))); " is 123.
Long Statement,Akka.Cluster.Tests.MultiNode,ClusterDeathWatchSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ClusterDeathWatchSpec.cs,An_actor_watching_a_remote_actor_in_the_cluster_must_be_able_to_shutdown_system_when_using_remote_deployed_actor_on_node_that_crashed,The length of the statement  "                    AwaitAssert(() => ClusterView.UnreachableMembers.Select(x => x.Address).Contains(GetAddress(_config.First)).ShouldBeTrue()); " is 124.
Long Statement,Akka.Cluster.Tests.MultiNode,ClusterDeathWatchSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ClusterDeathWatchSpec.cs,An_actor_watching_a_remote_actor_in_the_cluster_must_be_able_to_shutdown_system_when_using_remote_deployed_actor_on_node_that_crashed,The length of the statement  "                    AwaitAssert(() => Assert.DoesNotContain(GetAddress(_config.First)' ClusterView.UnreachableMembers.Select(x => x.Address))); " is 123.
Long Statement,Akka.Cluster.Tests.MultiNode,JoinWithOfflineSeedNodeSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\JoinWithOfflineSeedNodeSpec.cs,JoinClusterWithOneOfflineSeedNode,The length of the statement  "                    _seedSystem.Value.ActorSelection(new RootActorPath(GetAddress(_config.NonSeed)) / "user" / "address-receiver").Tell(_seedUniqueAddress' probe.Ref); " is 147.
Long Statement,Akka.Cluster.Tests.MultiNode,DomainEventLogger,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\JoinWithOfflineSeedNodeSpec.cs,PreStart,The length of the statement  "                Akka.Cluster.Cluster.Get(Context.System).Subscribe(Self' ClusterEvent.SubscriptionInitialStateMode.InitialStateAsEvents' typeof(ClusterEvent.IClusterDomainEvent)); " is 163.
Long Statement,Akka.Cluster.Tests.MultiNode,MembershipChangeListenerUpSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\MembershipChangeListenerUpSpec.cs,MembershipChangeListenerUpSpecs,The length of the statement  "            Set_of_connected_cluster_systems_must_when_two_nodes_after_cluster_convergence_updates_membership_table_then_all_MembershipChangeListeners_should_be_triggered(); " is 161.
Long Statement,Akka.Cluster.Tests.MultiNode,MembershipChangeListenerUpSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\MembershipChangeListenerUpSpec.cs,MembershipChangeListenerUpSpecs,The length of the statement  "            Set_of_connected_cluster_systems_must_when_three_nodes_after_cluster_convergence_updates_membership_table_then_all_MembershipChangeListeners_should_be_triggered(); " is 163.
Long Statement,Akka.Cluster.Tests.MultiNode,MembershipChangeListenerUpSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\MembershipChangeListenerUpSpec.cs,Set_of_connected_cluster_systems_must_when_three_nodes_after_cluster_convergence_updates_membership_table_then_all_MembershipChangeListeners_should_be_triggered,The length of the statement  "            var expectedAddresses = ImmutableList.Create(GetAddress(_config.First)' GetAddress(_config.Second)' GetAddress(_config.Third)); " is 127.
Long Statement,Akka.Cluster.Tests.MultiNode,MemberWeaklyUpSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\MemberWeaklyUpSpec.cs,A_cluster_of_3_members_should_accept_joining_on_each_side_and_set_status_to_WeaklyUp,The length of the statement  "                    ClusterView.Members.Any(m => m.Address == GetAddress(_config.Second) && m.Status == MemberStatus.WeaklyUp).ShouldBe(true); " is 122.
Long Statement,Akka.Cluster.Tests.MultiNode,MemberWeaklyUpSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\MemberWeaklyUpSpec.cs,A_cluster_of_3_members_should_accept_joining_on_each_side_and_set_status_to_WeaklyUp,The length of the statement  "                    ClusterView.Members.Any(m => m.Address == GetAddress(_config.Fifth) && m.Status == MemberStatus.WeaklyUp).ShouldBe(true); " is 121.
Long Statement,Akka.Cluster.Tests.MultiNode,NodeMembershipSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\NodeMembershipSpec.cs,NodeMembershipSpecs,The length of the statement  "            Set_of_connected_cluster_systems_must_with_two_nodes_start_gossiping_to_each_other_so_that_both_nodes_gets_same_gossip_info(); " is 126.
Long Statement,Akka.Cluster.Tests.MultiNode,NodeMembershipSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\NodeMembershipSpec.cs,NodeMembershipSpecs,The length of the statement  "            Set_of_connected_cluster_systems_must_with_three_nodes_start_gossiping_to_each_other_so_that_all_nodes_gets_same_gossip_info(); " is 127.
Long Statement,Akka.Cluster.Tests.MultiNode,RestartNode2Spec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartNode2Spec.cs,Cluster_seed_nodes_must_be_able_to_restart_first_seed_node_and_join_other_seed_nodes,The length of the statement  "                    AwaitAssert(() => Cluster.Get(seed1System.Value).ReadView.Members.All(x => x.Status == MemberStatus.Up).Should().BeTrue()); " is 123.
Long Statement,Akka.Cluster.Tests.MultiNode,RestartNode2Spec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartNode2Spec.cs,Cluster_seed_nodes_must_be_able_to_restart_first_seed_node_and_join_other_seed_nodes,The length of the statement  "                        AwaitAssert(() => Cluster.Get(restartedSeed1System.Value).ReadView.Members.All(x => x.Status == MemberStatus.Up).Should().BeTrue()); " is 132.
Long Statement,Akka.Cluster.Tests.MultiNode,RestartNodeSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartNodeSpec.cs,ClusterNodesMustBeAbleToRestartAndJoinAgain,The length of the statement  "                    AwaitAssert(() => Assert.True(Cluster.Get(_secondSystem.Value).ReadView.Members.Select(x => x.Status).All(s => s == MemberStatus.Up))); " is 135.
Long Statement,Akka.Cluster.Tests.MultiNode,RestartNodeSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartNodeSpec.cs,ClusterNodesMustBeAbleToRestartAndJoinAgain,The length of the statement  "                    AwaitAssert(() => Assert.True(Cluster.Get(_secondRestartedSystem.Value).ReadView.Members.Select(x => x.Status).All(s => s == MemberStatus.Up))); " is 144.
Long Statement,Akka.Cluster.Tests.MultiNode,SurviveNetworkInstabilitySpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\SurviveNetworkInstabilitySpec.cs,A_Network_partition_tolerant_cluster_must_mark_quarantined_node_with_reachability_status_Terminated,The length of the statement  "                var others = ImmutableArray.Create(_config.First' _config.Third' _config.Fourth' _config.Fifth' _config.Sixth' _config.Seventh); " is 128.
Long Statement,Akka.Cluster.Tests.MultiNode,SurviveNetworkInstabilitySpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\SurviveNetworkInstabilitySpec.cs,A_Network_partition_tolerant_cluster_must_mark_quarantined_node_with_reachability_status_Terminated,The length of the statement  "                    Sys.ActorSelection(Node(_config.Third) / "user" / "watcher").Tell(new SurviveNetworkInstabilitySpecConfig.Targets(refs)); " is 121.
Long Statement,Akka.Cluster.Tests.MultiNode,SurviveNetworkInstabilitySpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\SurviveNetworkInstabilitySpec.cs,A_Network_partition_tolerant_cluster_must_mark_quarantined_node_with_reachability_status_Terminated,The length of the statement  "                    AwaitAssert(() => ClusterView.Reachability.Status(secondUniqueAddress?.UniqueAddress).Should().Be(Reachability.ReachabilityStatus.Terminated)); " is 143.
Long Statement,Akka.Cluster.Tests.MultiNode,SurviveNetworkInstabilitySpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\SurviveNetworkInstabilitySpec.cs,A_Network_partition_tolerant_cluster_must_continue_and_move_Joining_to_Up_after_downing_of_one_half,The length of the statement  "                        ClusterView.Members.Where(m => m.Address.Equals(GetAddress(_config.Eighth))).Select(m => m.Status).FirstOrDefault().Should().Be(MemberStatus.Up); " is 145.
Long Statement,Akka.Cluster.Tests.MultiNode,TransitionSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\TransitionSpec.cs,A_Cluster_must_perform_correct_transitions_when_third_joins_second,The length of the statement  "                AwaitAssert(() => SeenLatestGossip().Should().BeEquivalentTo(ImmutableHashSet.Create(_config.First' _config.Second' _config.Third))); " is 133.
Long Statement,Akka.Cluster.Tests.MultiNode,TransitionSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\TransitionSpec.cs,A_Cluster_must_perform_correct_transitions_when_third_joins_second,The length of the statement  "                AwaitAssert(() => SeenLatestGossip().Should().BeEquivalentTo(ImmutableHashSet.Create(_config.First' _config.Second' _config.Third))); " is 133.
Long Statement,Akka.Cluster.Tests.MultiNode,TransitionSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\TransitionSpec.cs,A_Cluster_must_perform_correct_transitions_when_third_joins_second,The length of the statement  "                AwaitAssert(() => SeenLatestGossip().Should().BeEquivalentTo(ImmutableHashSet.Create(_config.First' _config.Second' _config.Third))); " is 133.
Long Statement,Akka.Cluster.Tests.MultiNode,TransitionSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\TransitionSpec.cs,A_Cluster_must_perform_correct_transitions_when_third_joins_second,The length of the statement  "                AwaitAssert(() => SeenLatestGossip().Should().BeEquivalentTo(ImmutableHashSet.Create(_config.First' _config.Second' _config.Third))); " is 133.
Long Statement,Akka.Cluster.Tests.MultiNode.Routing,ClusterBroadcastGroupSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterBroadcastRouter2266BugfixSpec.cs,A_cluster_router_with_a_BroadcastGroup_router_must_lookup_routees_on_the_member_nodes_in_the_cluster,The length of the statement  "            Sys.ActorOf(Props.Create(() => new ClusterBroadcastGroupSpecConfig.SomeActor(new ClusterBroadcastGroupSpecConfig.GroupRoutee()))' "myserviceA"); " is 144.
Long Statement,Akka.Cluster.Tests.MultiNode.Routing,ClusterBroadcastGroupSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterBroadcastRouter2266BugfixSpec.cs,A_cluster_router_with_a_BroadcastGroup_router_must_lookup_routees_on_the_member_nodes_in_the_cluster,The length of the statement  "                    AwaitAssert(() => CurrentRoutees(_router.Value).Count().Should().Be(2)); //only seems to pass with a single routee should be 2 " is 126.
Long Statement,Akka.Cluster.Tests.MultiNode.Routing,ClusterConsistentHashingRouterSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterConsistentHashingRouterSpec.cs,AssertHashMapping,The length of the statement  "            routerMembers.SetEquals(expected).Should().BeTrue($"Expected [{string.Join("'"' expected)}] but was [{string.Join("'"' routerMembers)}]"); " is 138.
Long Statement,Akka.Cluster.Tests.MultiNode.Routing,ClusterConsistentHashingRouterSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterConsistentHashingRouterSpec.cs,ClusterConsistentHashingRouterSpecs,The length of the statement  "            A_cluster_router_with_consistent_hashing_pool_must_deploy_programatically_defined_routees_to_the_member_nodes_in_the_cluster(); " is 127.
Long Statement,Akka.Cluster.Tests.MultiNode.Routing,ClusterConsistentHashingRouterSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterConsistentHashingRouterSpec.cs,ClusterConsistentHashingRouterSpecs,The length of the statement  "            A_cluster_router_with_consistent_hashing_pool_must_handle_combination_of_configured_router_and_programatically_defined_hash_mapping(); " is 134.
Long Statement,Akka.Cluster.Tests.MultiNode.Routing,ClusterConsistentHashingRouterSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterConsistentHashingRouterSpec.cs,ClusterConsistentHashingRouterSpecs,The length of the statement  "            A_cluster_router_with_consistent_hashing_pool_must_handle_combination_of_configured_router_and_programatically_defined_hash_mapping_and_cluster_config(); " is 153.
Long Statement,Akka.Cluster.Tests.MultiNode.Routing,ClusterConsistentHashingRouterSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterConsistentHashingRouterSpec.cs,A_cluster_router_with_consistent_hashing_pool_must_remove_routees_from_downed_node,The length of the statement  "                AwaitAssert(() => Assert.DoesNotContain(GetAddress(_config.Third)' ClusterView.UnreachableMembers.Select(x => x.Address))); " is 123.
Long Statement,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,ClusterRoundRobinSpecs,The length of the statement  "            A_cluster_router_with_a_RoundRobin_router_must_deploy_programatically_defined_routees_to_the_member_nodes_in_the_cluster(); " is 123.
Long Statement,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,ClusterRoundRobinSpecs,The length of the statement  "            A_cluster_router_with_a_RoundRobin_router_must_deploy_programatically_defined_routees_to_other_node_when_a_node_becomes_down(); " is 127.
Long Statement,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,A_cluster_router_with_a_RoundRobin_router_must_lookup_routees_on_the_member_nodes_in_the_cluster,The length of the statement  "            Sys.ActorOf(Props.Create(() => new ClusterRoundRobinSpecConfig.SomeActor(new ClusterRoundRobinSpecConfig.GroupRoutee()))' " is 121.
Long Statement,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,A_cluster_router_with_a_RoundRobin_router_must_lookup_routees_on_the_member_nodes_in_the_cluster,The length of the statement  "            Sys.ActorOf(Props.Create(() => new ClusterRoundRobinSpecConfig.SomeActor(new ClusterRoundRobinSpecConfig.GroupRoutee()))' " is 121.
Long Statement,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_start_cluster,The length of the statement  "            Sys.ActorOf(Props.Create(() => new UseRoleIgnoredSpecConfig.SomeActor(new UseRoleIgnoredSpecConfig.GroupRoutee()))' "foo"); " is 123.
Long Statement,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_start_cluster,The length of the statement  "            Sys.ActorOf(Props.Create(() => new UseRoleIgnoredSpecConfig.SomeActor(new UseRoleIgnoredSpecConfig.GroupRoutee()))' "bar"); " is 123.
Long Statement,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_group_local_off_roles_off,The length of the statement  "                        new ClusterRouterGroupSettings(6' ImmutableHashSet.Create("/user/foo"' "/user/bar")' allowLocalRoutees: false' useRole: role)).Props()' " is 135.
Long Statement,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_group_local_on_role_b,The length of the statement  "                        new ClusterRouterGroupSettings(6' ImmutableHashSet.Create("/user/foo"' "/user/bar")' allowLocalRoutees: true' useRole: role)).Props()' " is 134.
Long Statement,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_group_local_on_role_a,The length of the statement  "                        new ClusterRouterGroupSettings(6' ImmutableHashSet.Create("/user/foo"' "/user/bar")' allowLocalRoutees: true' useRole: role)).Props()' " is 134.
Long Statement,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_group_local_on_role_c,The length of the statement  "                        new ClusterRouterGroupSettings(6' ImmutableHashSet.Create("/user/foo"' "/user/bar")' allowLocalRoutees: true' useRole: role)).Props()' " is 134.
Magic Number,Akka.Cluster.Tests.MultiNode,AttemptSysMsgRedeliverySpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\AttemptSysMsgRedeliverySpec.cs,AttemptSysMsgRedelivery_must_redeliver_system_message_after_inactivity,The following statement contains a magic number: RunOn(() =>              {                  ExpectTerminated(secondRef' 10.Seconds());              }' _config.First' _config.Third);
Magic Number,Akka.Cluster.Tests.MultiNode,AttemptSysMsgRedeliverySpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\AttemptSysMsgRedeliverySpec.cs,AttemptSysMsgRedelivery_must_redeliver_system_message_after_inactivity,The following statement contains a magic number: RunOn(() =>              {                  ExpectTerminated(firstRef' 10.Seconds());              }' _config.Second);
Magic Number,Akka.Cluster.Tests.MultiNode,ClientDowningNodeThatIsUnreachableSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ClientDowningNodeThatIsUnreachableSpec.cs,Client_of_a_4_node_cluster_must_be_able_to_DOWN_a_node_that_is_UNREACHABLE,The following statement contains a magic number: RunOn(() =>              {                  // kill 'third' node                  TestConductor.Exit(_config.Third' 0).Wait();                  MarkNodeAsUnavailable(thirdAddress);                    // mark 'third' node as DOWN                  Cluster.Down(thirdAddress);                  EnterBarrier("down-third-node");                    AwaitMembersUp(3' ImmutableHashSet.Create(thirdAddress));                  ClusterView.Members.Any(x => x.Address == thirdAddress).ShouldBeFalse();              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode,ClientDowningNodeThatIsUnreachableSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ClientDowningNodeThatIsUnreachableSpec.cs,Client_of_a_4_node_cluster_must_be_able_to_DOWN_a_node_that_is_UNREACHABLE,The following statement contains a magic number: RunOn(() =>              {                  EnterBarrier("down-third-node");                    AwaitMembersUp(3' ImmutableHashSet.Create(thirdAddress));              }' _config.Second' _config.Fourth);
Magic Number,Akka.Cluster.Tests.MultiNode,ClusterAccrualFailureDetectorSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ClusterAccrualFailureDetectorSpec.cs,A_heartbeat_driven_Failure_Detector_receive_heartbeats_so_that_all_member_nodes_in_the_cluster_are_marked_available,The following statement contains a magic number: Thread.Sleep(5);
Magic Number,Akka.Cluster.Tests.MultiNode,ClusterAccrualFailureDetectorSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ClusterAccrualFailureDetectorSpec.cs,A_heartbeat_driven_Failure_Detector_mark_node_as_unavailable_when_network_partition_and_then_back_to_available_when_partition_is_healed,The following statement contains a magic number: RunOn(() =>              {                  // detect failure...                  AwaitCondition(() => !Cluster.FailureDetector.IsAvailable(GetAddress(_config.Second))'                      TimeSpan.FromSeconds(15));                  // other connections still ok                  Cluster.FailureDetector.IsAvailable(GetAddress(_config.Third)).ShouldBeTrue();              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode,ClusterAccrualFailureDetectorSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ClusterAccrualFailureDetectorSpec.cs,A_heartbeat_driven_Failure_Detector_mark_node_as_unavailable_when_network_partition_and_then_back_to_available_when_partition_is_healed,The following statement contains a magic number: RunOn(() =>              {                  // detect failure...                  AwaitCondition(() => !Cluster.FailureDetector.IsAvailable(GetAddress(_config.First))'                      TimeSpan.FromSeconds(15));                  // other connections still ok                  Cluster.FailureDetector.IsAvailable(GetAddress(_config.Third)).ShouldBeTrue();              }' _config.Second);
Magic Number,Akka.Cluster.Tests.MultiNode,ClusterAccrualFailureDetectorSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ClusterAccrualFailureDetectorSpec.cs,A_heartbeat_driven_Failure_Detector_mark_node_as_unavailable_when_network_partition_and_then_back_to_available_when_partition_is_healed,The following statement contains a magic number: RunOn(() =>              {                  AwaitCondition(() => Cluster.FailureDetector.IsAvailable(GetAddress(_config.Second))'                      TimeSpan.FromSeconds(15));              }' _config.First' _config.Third);
Magic Number,Akka.Cluster.Tests.MultiNode,ClusterAccrualFailureDetectorSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ClusterAccrualFailureDetectorSpec.cs,A_heartbeat_driven_Failure_Detector_mark_node_as_unavailable_when_network_partition_and_then_back_to_available_when_partition_is_healed,The following statement contains a magic number: RunOn(() =>              {                  AwaitCondition(() => Cluster.FailureDetector.IsAvailable(GetAddress(_config.First))'                      TimeSpan.FromSeconds(15));              }' _config.Second);
Magic Number,Akka.Cluster.Tests.MultiNode,ClusterAccrualFailureDetectorSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ClusterAccrualFailureDetectorSpec.cs,A_heartbeat_driven_Failure_Detector_mark_node_as_unavailable_if_a_node_in_the_cluster_is_shut_down_and_its_heartbeats_stops,The following statement contains a magic number: RunOn(() =>              {                  // remaining nodes should detect failure...                  AwaitCondition(() => !Cluster.FailureDetector.IsAvailable(GetAddress(_config.Third))' TimeSpan.FromSeconds(15));                  // other connections still ok                  Cluster.FailureDetector.IsAvailable(GetAddress(_config.First)).ShouldBeTrue();                  Cluster.FailureDetector.IsAvailable(GetAddress(_config.Second)).ShouldBeTrue();              }' _config.First' _config.Second);
Magic Number,Akka.Cluster.Tests.MultiNode,ClusterDeathWatchSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ClusterDeathWatchSpec.cs,An_actor_watching_a_remote_actor_in_the_cluster_must_receive_terminated_when_watched_node_becomes_down_removed,The following statement contains a magic number: Within(TimeSpan.FromSeconds(30)' () =>              {                  AwaitClusterUp(_config.First' _config.Second' _config.Third' _config.Fourth);                  EnterBarrier("cluster-up");                    RunOn(() =>                  {                      EnterBarrier("subjected-started");                        var path2 = new RootActorPath(GetAddress(_config.Second)) / "user" / "subject";                      var path3 = new RootActorPath(GetAddress(_config.Third)) / "user" / "subject";                      var watchEstablished = new TestLatch(2);                      Sys.ActorOf(Props.Create(() => new Observer(path2' path3' watchEstablished' TestActor))                          .WithDeploy(Deploy.Local)' "observer1");                        watchEstablished.Ready();                      EnterBarrier("watch-established");                      ExpectMsg(path2);                      ExpectNoMsg(TimeSpan.FromSeconds(2));                      EnterBarrier("second-terminated");                      MarkNodeAsUnavailable(GetAddress(_config.Third));                      AwaitAssert(() => Assert.Contains(GetAddress(_config.Third)' ClusterView.UnreachableMembers.Select(x => x.Address)));                      Cluster.Down(GetAddress(_config.Third));                      //removed                      AwaitAssert(() => Assert.DoesNotContain(GetAddress(_config.Third)' ClusterView.Members.Select(x => x.Address)));                      AwaitAssert(() => Assert.DoesNotContain(GetAddress(_config.Third)' ClusterView.UnreachableMembers.Select(x => x.Address)));                      ExpectMsg(path3);                      EnterBarrier("third-terminated");                  }' _config.First);                    RunOn(() =>                  {                      Sys.ActorOf(BlackHoleActor.Props' "subject");                      EnterBarrier("subjected-started");                      EnterBarrier("watch-established");                      RunOn(() =>                      {                          MarkNodeAsUnavailable(GetAddress(_config.Second));                          AwaitAssert(() => Assert.Contains(GetAddress(_config.Second)' ClusterView.UnreachableMembers.Select(x => x.Address)));                          Cluster.Down(GetAddress(_config.Second));                          //removed                          AwaitAssert(() => Assert.DoesNotContain(GetAddress(_config.Second)' ClusterView.Members.Select(x => x.Address)));                          AwaitAssert(() => Assert.DoesNotContain(GetAddress(_config.Second)' ClusterView.UnreachableMembers.Select(x => x.Address)));                      }' _config.Third);                      EnterBarrier("second-terminated");                      EnterBarrier("third-terminated");                  }' _config.Second' _config.Third' _config.Fourth);                    RunOn(() =>                  {                      EnterBarrier("subjected-started");                      EnterBarrier("watch-established");                      EnterBarrier("second-terminated");                      EnterBarrier("third-terminated");                  }' _config.Fifth);                    EnterBarrier("after-1");              });
Magic Number,Akka.Cluster.Tests.MultiNode,ClusterDeathWatchSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ClusterDeathWatchSpec.cs,An_actor_watching_a_remote_actor_in_the_cluster_must_receive_terminated_when_watched_node_becomes_down_removed,The following statement contains a magic number: Within(TimeSpan.FromSeconds(30)' () =>              {                  AwaitClusterUp(_config.First' _config.Second' _config.Third' _config.Fourth);                  EnterBarrier("cluster-up");                    RunOn(() =>                  {                      EnterBarrier("subjected-started");                        var path2 = new RootActorPath(GetAddress(_config.Second)) / "user" / "subject";                      var path3 = new RootActorPath(GetAddress(_config.Third)) / "user" / "subject";                      var watchEstablished = new TestLatch(2);                      Sys.ActorOf(Props.Create(() => new Observer(path2' path3' watchEstablished' TestActor))                          .WithDeploy(Deploy.Local)' "observer1");                        watchEstablished.Ready();                      EnterBarrier("watch-established");                      ExpectMsg(path2);                      ExpectNoMsg(TimeSpan.FromSeconds(2));                      EnterBarrier("second-terminated");                      MarkNodeAsUnavailable(GetAddress(_config.Third));                      AwaitAssert(() => Assert.Contains(GetAddress(_config.Third)' ClusterView.UnreachableMembers.Select(x => x.Address)));                      Cluster.Down(GetAddress(_config.Third));                      //removed                      AwaitAssert(() => Assert.DoesNotContain(GetAddress(_config.Third)' ClusterView.Members.Select(x => x.Address)));                      AwaitAssert(() => Assert.DoesNotContain(GetAddress(_config.Third)' ClusterView.UnreachableMembers.Select(x => x.Address)));                      ExpectMsg(path3);                      EnterBarrier("third-terminated");                  }' _config.First);                    RunOn(() =>                  {                      Sys.ActorOf(BlackHoleActor.Props' "subject");                      EnterBarrier("subjected-started");                      EnterBarrier("watch-established");                      RunOn(() =>                      {                          MarkNodeAsUnavailable(GetAddress(_config.Second));                          AwaitAssert(() => Assert.Contains(GetAddress(_config.Second)' ClusterView.UnreachableMembers.Select(x => x.Address)));                          Cluster.Down(GetAddress(_config.Second));                          //removed                          AwaitAssert(() => Assert.DoesNotContain(GetAddress(_config.Second)' ClusterView.Members.Select(x => x.Address)));                          AwaitAssert(() => Assert.DoesNotContain(GetAddress(_config.Second)' ClusterView.UnreachableMembers.Select(x => x.Address)));                      }' _config.Third);                      EnterBarrier("second-terminated");                      EnterBarrier("third-terminated");                  }' _config.Second' _config.Third' _config.Fourth);                    RunOn(() =>                  {                      EnterBarrier("subjected-started");                      EnterBarrier("watch-established");                      EnterBarrier("second-terminated");                      EnterBarrier("third-terminated");                  }' _config.Fifth);                    EnterBarrier("after-1");              });
Magic Number,Akka.Cluster.Tests.MultiNode,ClusterDeathWatchSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ClusterDeathWatchSpec.cs,An_actor_watching_a_remote_actor_in_the_cluster_must_receive_terminated_when_watched_node_becomes_down_removed,The following statement contains a magic number: Within(TimeSpan.FromSeconds(30)' () =>              {                  AwaitClusterUp(_config.First' _config.Second' _config.Third' _config.Fourth);                  EnterBarrier("cluster-up");                    RunOn(() =>                  {                      EnterBarrier("subjected-started");                        var path2 = new RootActorPath(GetAddress(_config.Second)) / "user" / "subject";                      var path3 = new RootActorPath(GetAddress(_config.Third)) / "user" / "subject";                      var watchEstablished = new TestLatch(2);                      Sys.ActorOf(Props.Create(() => new Observer(path2' path3' watchEstablished' TestActor))                          .WithDeploy(Deploy.Local)' "observer1");                        watchEstablished.Ready();                      EnterBarrier("watch-established");                      ExpectMsg(path2);                      ExpectNoMsg(TimeSpan.FromSeconds(2));                      EnterBarrier("second-terminated");                      MarkNodeAsUnavailable(GetAddress(_config.Third));                      AwaitAssert(() => Assert.Contains(GetAddress(_config.Third)' ClusterView.UnreachableMembers.Select(x => x.Address)));                      Cluster.Down(GetAddress(_config.Third));                      //removed                      AwaitAssert(() => Assert.DoesNotContain(GetAddress(_config.Third)' ClusterView.Members.Select(x => x.Address)));                      AwaitAssert(() => Assert.DoesNotContain(GetAddress(_config.Third)' ClusterView.UnreachableMembers.Select(x => x.Address)));                      ExpectMsg(path3);                      EnterBarrier("third-terminated");                  }' _config.First);                    RunOn(() =>                  {                      Sys.ActorOf(BlackHoleActor.Props' "subject");                      EnterBarrier("subjected-started");                      EnterBarrier("watch-established");                      RunOn(() =>                      {                          MarkNodeAsUnavailable(GetAddress(_config.Second));                          AwaitAssert(() => Assert.Contains(GetAddress(_config.Second)' ClusterView.UnreachableMembers.Select(x => x.Address)));                          Cluster.Down(GetAddress(_config.Second));                          //removed                          AwaitAssert(() => Assert.DoesNotContain(GetAddress(_config.Second)' ClusterView.Members.Select(x => x.Address)));                          AwaitAssert(() => Assert.DoesNotContain(GetAddress(_config.Second)' ClusterView.UnreachableMembers.Select(x => x.Address)));                      }' _config.Third);                      EnterBarrier("second-terminated");                      EnterBarrier("third-terminated");                  }' _config.Second' _config.Third' _config.Fourth);                    RunOn(() =>                  {                      EnterBarrier("subjected-started");                      EnterBarrier("watch-established");                      EnterBarrier("second-terminated");                      EnterBarrier("third-terminated");                  }' _config.Fifth);                    EnterBarrier("after-1");              });
Magic Number,Akka.Cluster.Tests.MultiNode,ClusterDeathWatchSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ClusterDeathWatchSpec.cs,An_actor_watching_a_remote_actor_in_the_cluster_must_be_able_to_watch_actor_before_node_joins_cluster_and_cluster_remote_watcher_takes_over_from_remote_watcher,The following statement contains a magic number: Within(TimeSpan.FromSeconds(20)' () =>              {                  RunOn(() => Sys.ActorOf(BlackHoleActor.Props.WithDeploy(Deploy.Local)' "subject5")' _config.Fifth);                  EnterBarrier("subjected-started");                    RunOn(() =>                  {                      Sys.ActorSelection(new RootActorPath(GetAddress(_config.Fifth)) / "user" / "subject5").Tell(new Identify("subject5")' TestActor);                      var subject5 = ExpectMsg<ActorIdentity>().Subject;                      Watch(subject5);                        //fifth is not a cluster member' so the watch is handled by the RemoteWatcher                      AwaitAssert(() =>                      {                          RemoteWatcher.Tell(Remote.RemoteWatcher.Stats.Empty);                          var stats = ExpectMsg<Remote.RemoteWatcher.Stats>();                          stats.WatchingRefs.Contains((subject5' TestActor)).ShouldBeTrue();                          stats.WatchingAddresses.Contains(GetAddress(_config.Fifth)).ShouldBeTrue();                      });                  }' _config.First);                  EnterBarrier("remote-watch");                    // second and third are already removed                  AwaitClusterUp(_config.First' _config.Fourth' _config.Fifth);                    RunOn(() =>                  {                      // fifth is member' so the watch is handled by the ClusterRemoteWatcher'                      // and cleaned up from RemoteWatcher                      AwaitAssert(() =>                      {                          RemoteWatcher.Tell(Remote.RemoteWatcher.Stats.Empty);                          var stats = ExpectMsg<Remote.RemoteWatcher.Stats>();                          stats.WatchingRefs.Select(x => x.Item1.Path.Name).Contains("subject5").ShouldBeTrue();                          stats.WatchingAddresses.Contains(GetAddress(_config.Fifth)).ShouldBeFalse();                      });                  }' _config.First);                    EnterBarrier("cluster-watch");                    RunOn(() =>                  {                      MarkNodeAsUnavailable(GetAddress(_config.Fifth));                      AwaitAssert(() => ClusterView.UnreachableMembers.Select(x => x.Address).Contains(GetAddress(_config.Fifth)).ShouldBeTrue());                      Cluster.Down(GetAddress(_config.Fifth));                      // removed                      AwaitAssert(() => Assert.DoesNotContain(GetAddress(_config.Fifth)' ClusterView.UnreachableMembers.Select(x => x.Address)));                      AwaitAssert(() => Assert.DoesNotContain(GetAddress(_config.Fifth)' ClusterView.Members.Select(x => x.Address)));                  }' _config.Fourth);                    EnterBarrier("fifth-terminated");                  RunOn(() =>                  {                      ExpectMsg<Terminated>().ActorRef.Path.Name.ShouldBe("subject5");                  }' _config.First);                    EnterBarrier("after-3");              });
Magic Number,Akka.Cluster.Tests.MultiNode,ClusterDeathWatchSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ClusterDeathWatchSpec.cs,An_actor_watching_a_remote_actor_in_the_cluster_must_be_able_to_shutdown_system_when_using_remote_deployed_actor_on_node_that_crashed,The following statement contains a magic number: Within(TimeSpan.FromSeconds(20)' () =>              {                  // fourth actor system will be shutdown' not part of testConductor any more                  // so we can't use barriers to synchronize with it                  var firstAddress = GetAddress(_config.First);                  RunOn(() =>                  {                      Sys.ActorOf(Props.Create(() => new EndActor(TestActor' null))' "end");                  }' _config.First);                  EnterBarrier("end-actor-created");                    RunOn(() =>                  {                      var hello = Sys.ActorOf(BlackHoleActor.Props' "hello");                      Assert.IsType<RemoteActorRef>(hello);                      hello.Path.Address.ShouldBe(GetAddress(_config.First));                      Watch(hello);                      EnterBarrier("hello-deployed");                      MarkNodeAsUnavailable(GetAddress(_config.First));                      AwaitAssert(() => ClusterView.UnreachableMembers.Select(x => x.Address).Contains(GetAddress(_config.First)).ShouldBeTrue());                      Cluster.Down(GetAddress(_config.First));                      // removed                      AwaitAssert(() => Assert.DoesNotContain(GetAddress(_config.First)' ClusterView.UnreachableMembers.Select(x => x.Address)));                      AwaitAssert(() => Assert.DoesNotContain(GetAddress(_config.First)' ClusterView.Members.Select(x => x.Address)));                        ExpectTerminated(hello);                      EnterBarrier("first-unavailable");                        var timeout = RemainingOrDefault;                      try                      {                          if (!Sys.WhenTerminated.Wait(timeout)) // TestConductor.Shutdown called by First MUST terminate this actor system                          {                              Assert.True(false' String.Format("Failed to stop [{0}] within [{1}]"' Sys.Name' timeout));                          }                      }                      catch (TimeoutException)                      {                          Assert.True(false' String.Format("Failed to stop [{0}] within [{1}]"' Sys.Name' timeout));                      }                                              // signal to the first node that the fourth node is done                      var endSystem = ActorSystem.Create("EndSystem"' Sys.Settings.Config);                      try                      {                          var endProbe = CreateTestProbe(endSystem);                          var endActor = endSystem.ActorOf(Props.Create(() => new EndActor(endProbe.Ref' firstAddress))'                              "end");                          endActor.Tell(EndActor.SendEnd.Instance);                          endProbe.ExpectMsg<EndActor.EndAck>();                      }                      finally                      {                          Shutdown(endSystem' TimeSpan.FromSeconds(10));                      }                        // no barrier here' because it is not part of TestConductor roles any more                    }' _config.Fourth);                    RunOn(() =>                  {                      EnterBarrier("hello-deployed");                      EnterBarrier("first-unavailable");                        // don't end the test until fourth is done                      RunOn(() =>                      {                          // fourth system will be shutdown' remove to not participate in barriers any more                          TestConductor.Shutdown(_config.Fourth).Wait();                          ExpectMsg<EndActor.End>();                      }' _config.First);                        EnterBarrier("after-4");                  }' _config.First' _config.Second' _config.Third' _config.Fifth);                });
Magic Number,Akka.Cluster.Tests.MultiNode,ClusterDeathWatchSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ClusterDeathWatchSpec.cs,An_actor_watching_a_remote_actor_in_the_cluster_must_be_able_to_shutdown_system_when_using_remote_deployed_actor_on_node_that_crashed,The following statement contains a magic number: Within(TimeSpan.FromSeconds(20)' () =>              {                  // fourth actor system will be shutdown' not part of testConductor any more                  // so we can't use barriers to synchronize with it                  var firstAddress = GetAddress(_config.First);                  RunOn(() =>                  {                      Sys.ActorOf(Props.Create(() => new EndActor(TestActor' null))' "end");                  }' _config.First);                  EnterBarrier("end-actor-created");                    RunOn(() =>                  {                      var hello = Sys.ActorOf(BlackHoleActor.Props' "hello");                      Assert.IsType<RemoteActorRef>(hello);                      hello.Path.Address.ShouldBe(GetAddress(_config.First));                      Watch(hello);                      EnterBarrier("hello-deployed");                      MarkNodeAsUnavailable(GetAddress(_config.First));                      AwaitAssert(() => ClusterView.UnreachableMembers.Select(x => x.Address).Contains(GetAddress(_config.First)).ShouldBeTrue());                      Cluster.Down(GetAddress(_config.First));                      // removed                      AwaitAssert(() => Assert.DoesNotContain(GetAddress(_config.First)' ClusterView.UnreachableMembers.Select(x => x.Address)));                      AwaitAssert(() => Assert.DoesNotContain(GetAddress(_config.First)' ClusterView.Members.Select(x => x.Address)));                        ExpectTerminated(hello);                      EnterBarrier("first-unavailable");                        var timeout = RemainingOrDefault;                      try                      {                          if (!Sys.WhenTerminated.Wait(timeout)) // TestConductor.Shutdown called by First MUST terminate this actor system                          {                              Assert.True(false' String.Format("Failed to stop [{0}] within [{1}]"' Sys.Name' timeout));                          }                      }                      catch (TimeoutException)                      {                          Assert.True(false' String.Format("Failed to stop [{0}] within [{1}]"' Sys.Name' timeout));                      }                                              // signal to the first node that the fourth node is done                      var endSystem = ActorSystem.Create("EndSystem"' Sys.Settings.Config);                      try                      {                          var endProbe = CreateTestProbe(endSystem);                          var endActor = endSystem.ActorOf(Props.Create(() => new EndActor(endProbe.Ref' firstAddress))'                              "end");                          endActor.Tell(EndActor.SendEnd.Instance);                          endProbe.ExpectMsg<EndActor.EndAck>();                      }                      finally                      {                          Shutdown(endSystem' TimeSpan.FromSeconds(10));                      }                        // no barrier here' because it is not part of TestConductor roles any more                    }' _config.Fourth);                    RunOn(() =>                  {                      EnterBarrier("hello-deployed");                      EnterBarrier("first-unavailable");                        // don't end the test until fourth is done                      RunOn(() =>                      {                          // fourth system will be shutdown' remove to not participate in barriers any more                          TestConductor.Shutdown(_config.Fourth).Wait();                          ExpectMsg<EndActor.End>();                      }' _config.First);                        EnterBarrier("after-4");                  }' _config.First' _config.Second' _config.Third' _config.Fifth);                });
Magic Number,Akka.Cluster.Tests.MultiNode,ConvergenceSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ConvergenceSpec.cs,A_cluster_of_3_members_must_not_reach_convergence_while_any_nodes_are_unreachable,The following statement contains a magic number: RunOn(() => Within(TimeSpan.FromSeconds(28)' () =>              {                  //third becomes unreachable                  AwaitAssert(() => ClusterView.UnreachableMembers.Count.ShouldBe(1));                  AwaitSeenSameState(GetAddress(_config.First)' GetAddress(_config.Second));                  // still one unreachable                  ClusterView.UnreachableMembers.Count.ShouldBe(1);                  ClusterView.UnreachableMembers.First().Address.ShouldBe(thirdAddress);                  ClusterView.Members.Count.ShouldBe(3);              })' _config.First' _config.Second);
Magic Number,Akka.Cluster.Tests.MultiNode,ConvergenceSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ConvergenceSpec.cs,A_cluster_of_3_members_must_not_reach_convergence_while_any_nodes_are_unreachable,The following statement contains a magic number: RunOn(() => Within(TimeSpan.FromSeconds(28)' () =>              {                  //third becomes unreachable                  AwaitAssert(() => ClusterView.UnreachableMembers.Count.ShouldBe(1));                  AwaitSeenSameState(GetAddress(_config.First)' GetAddress(_config.Second));                  // still one unreachable                  ClusterView.UnreachableMembers.Count.ShouldBe(1);                  ClusterView.UnreachableMembers.First().Address.ShouldBe(thirdAddress);                  ClusterView.Members.Count.ShouldBe(3);              })' _config.First' _config.Second);
Magic Number,Akka.Cluster.Tests.MultiNode,ConvergenceSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ConvergenceSpec.cs,A_cluster_of_3_members_must_not_move_a_new_joining_node_to_up_while_there_is_no_convergence,The following statement contains a magic number: RunOn(() =>              {                  for (var i = 0; i < 5; i++)                  {                      AwaitAssert(() => ClusterView.Members.Count.ShouldBe(4));                      AwaitSeenSameState(GetAddress(_config.First)' GetAddress(_config.Second)' GetAddress(_config.Fourth));                      MemberStatus(GetAddress(_config.First)).ShouldBe(Akka.Cluster.MemberStatus.Up);                      MemberStatus(GetAddress(_config.Second)).ShouldBe(Akka.Cluster.MemberStatus.Up);                      MemberStatus(GetAddress(_config.Fourth)).ShouldBe(Akka.Cluster.MemberStatus.Joining);                      // wait and then check again                      Thread.Sleep(Dilated(TimeSpan.FromSeconds(1)));                  }              }' _config.First' _config.Second' _config.Fourth);
Magic Number,Akka.Cluster.Tests.MultiNode,ConvergenceSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ConvergenceSpec.cs,A_cluster_of_3_members_must_not_move_a_new_joining_node_to_up_while_there_is_no_convergence,The following statement contains a magic number: RunOn(() =>              {                  for (var i = 0; i < 5; i++)                  {                      AwaitAssert(() => ClusterView.Members.Count.ShouldBe(4));                      AwaitSeenSameState(GetAddress(_config.First)' GetAddress(_config.Second)' GetAddress(_config.Fourth));                      MemberStatus(GetAddress(_config.First)).ShouldBe(Akka.Cluster.MemberStatus.Up);                      MemberStatus(GetAddress(_config.Second)).ShouldBe(Akka.Cluster.MemberStatus.Up);                      MemberStatus(GetAddress(_config.Fourth)).ShouldBe(Akka.Cluster.MemberStatus.Joining);                      // wait and then check again                      Thread.Sleep(Dilated(TimeSpan.FromSeconds(1)));                  }              }' _config.First' _config.Second' _config.Fourth);
Magic Number,Akka.Cluster.Tests.MultiNode,DeterministicOldestWhenJoiningSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\DeterministicOldestWhenJoiningSpec.cs,Joining_cluster_must_result_in_deterministic_oldest_node,The following statement contains a magic number: RunOn(() =>              {                  Cluster.JoinSeedNodes(SeedNodes);              }' RoleByAddress[SeedNodes[1]]' RoleByAddress[SeedNodes[2]]);
Magic Number,Akka.Cluster.Tests.MultiNode,DeterministicOldestWhenJoiningSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\DeterministicOldestWhenJoiningSpec.cs,Joining_cluster_must_result_in_deterministic_oldest_node,The following statement contains a magic number: Within(10.Seconds()' () =>              {                  var ups = ImmutableList.Create(                      ExpectMsg<ClusterEvent.MemberUp>()'                      ExpectMsg<ClusterEvent.MemberUp>()'                      ExpectMsg<ClusterEvent.MemberUp>());                    ups.Select(c => c.Member)                      .ToImmutableList()                      .Sort(Member.AgeOrdering)                      .First()                      .Address.Should()                      .Be(SeedNodes.First());              });
Magic Number,Akka.Cluster.Tests.MultiNode,DisallowJoinOfTwoClusterSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\DisallowJoinOfTwoClustersSpec.cs,Three_different_clusters_must_not_be_able_to_join,The following statement contains a magic number: int expectedSize = Myself == _config.c1 ? 1 : 2;
Magic Number,Akka.Cluster.Tests.MultiNode,DisallowJoinOfTwoClusterSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\DisallowJoinOfTwoClustersSpec.cs,Three_different_clusters_must_not_be_able_to_join,The following statement contains a magic number: Thread.Sleep(1000);
Magic Number,Akka.Cluster.Tests.MultiNode,DisallowJoinOfTwoClusterSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\DisallowJoinOfTwoClustersSpec.cs,Three_different_clusters_must_not_be_able_to_join,The following statement contains a magic number: Enumerable.Range(1' 5)
Magic Number,Akka.Cluster.Tests.MultiNode,InitialHeartbeatSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\InitialHeartbeatSpec.cs,A_member_must_detect_failure_even_though_no_heartbeats_have_been_received,The following statement contains a magic number: RunOn(() =>                      AwaitAssert(() =>                      {                          Cluster.SendCurrentClusterState(TestActor);                          Assert.Contains(secondAddress' ExpectMsg<ClusterEvent.CurrentClusterState>().Members.Select(m => m.Address));                      }' TimeSpan.FromSeconds(20)' TimeSpan.FromMilliseconds(50))                      ' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode,InitialHeartbeatSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\InitialHeartbeatSpec.cs,A_member_must_detect_failure_even_though_no_heartbeats_have_been_received,The following statement contains a magic number: RunOn(() =>                      AwaitAssert(() =>                      {                          Cluster.SendCurrentClusterState(TestActor);                          Assert.Contains(secondAddress' ExpectMsg<ClusterEvent.CurrentClusterState>().Members.Select(m => m.Address));                      }' TimeSpan.FromSeconds(20)' TimeSpan.FromMilliseconds(50))                      ' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode,InitialHeartbeatSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\InitialHeartbeatSpec.cs,A_member_must_detect_failure_even_though_no_heartbeats_have_been_received,The following statement contains a magic number: RunOn(() =>                  {                      Cluster.Join(GetAddress(_config.First));                      AwaitAssert(() =>                      {                          Cluster.SendCurrentClusterState(TestActor);                          Assert.Contains(firstAddress' ExpectMsg<ClusterEvent.CurrentClusterState>().Members.Select(m => m.Address));                      }' TimeSpan.FromSeconds(20)' TimeSpan.FromMilliseconds(50));                  }' _config.Second);
Magic Number,Akka.Cluster.Tests.MultiNode,InitialHeartbeatSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\InitialHeartbeatSpec.cs,A_member_must_detect_failure_even_though_no_heartbeats_have_been_received,The following statement contains a magic number: RunOn(() =>                  {                      Cluster.Join(GetAddress(_config.First));                      AwaitAssert(() =>                      {                          Cluster.SendCurrentClusterState(TestActor);                          Assert.Contains(firstAddress' ExpectMsg<ClusterEvent.CurrentClusterState>().Members.Select(m => m.Address));                      }' TimeSpan.FromSeconds(20)' TimeSpan.FromMilliseconds(50));                  }' _config.Second);
Magic Number,Akka.Cluster.Tests.MultiNode,InitialHeartbeatSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\InitialHeartbeatSpec.cs,A_member_must_detect_failure_even_though_no_heartbeats_have_been_received,The following statement contains a magic number: RunOn(                      () => AwaitCondition(                          () => !Cluster.FailureDetector.IsAvailable(GetAddress(_config.First))                          ' TimeSpan.FromSeconds(15))                      ' _config.Second);
Magic Number,Akka.Cluster.Tests.MultiNode,JoinInProgressSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\JoinInProgressSpec.cs,A_cluster_node_must_send_heartbeats_immediately_when_joining_to_avoid_false_failure_detection_due_to_delayed_gossip,The following statement contains a magic number: RunOn(() =>              {                  var until = Deadline.Now + TimeSpan.FromSeconds(5);                  while (!until.IsOverdue)                  {                      Thread.Sleep(200);                      Assert.True(Cluster.FailureDetector.IsAvailable(GetAddress(_config.Second)));                  }              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode,JoinInProgressSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\JoinInProgressSpec.cs,A_cluster_node_must_send_heartbeats_immediately_when_joining_to_avoid_false_failure_detection_due_to_delayed_gossip,The following statement contains a magic number: RunOn(() =>              {                  var until = Deadline.Now + TimeSpan.FromSeconds(5);                  while (!until.IsOverdue)                  {                      Thread.Sleep(200);                      Assert.True(Cluster.FailureDetector.IsAvailable(GetAddress(_config.Second)));                  }              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode,JoinSeedNodeSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\JoinSeedNodeSpec.cs,A_cluster_with_seed_nodes_must_be_able_to_start_the_seed_nodes_concurrently,The following statement contains a magic number: RunOn(() =>              {                  // test that first seed doesn't have to be started first                  Thread.Sleep(3000);              }' _config.Seed1);
Magic Number,Akka.Cluster.Tests.MultiNode,JoinSeedNodeSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\JoinSeedNodeSpec.cs,A_cluster_with_seed_nodes_must_be_able_to_start_the_seed_nodes_concurrently,The following statement contains a magic number: RunOn(() =>              {                  Cluster.JoinSeedNodes(_seedNodes);                  RunOn(() =>                  {                      //verify that we can call this multiple times with no issue                                          Cluster.JoinSeedNodes(_seedNodes);                  }' _config.Seed3);                  AwaitMembersUp(3);              }' _config.Seed1' _config.Seed2' _config.Seed3);
Magic Number,Akka.Cluster.Tests.MultiNode,JoinWithOfflineSeedNodeSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\JoinWithOfflineSeedNodeSpec.cs,JoinClusterWithOneOfflineSeedNode,The following statement contains a magic number: Within(TimeSpan.FromSeconds(30)' () =>              {                  RunOn(() =>                  {                      Sys.ActorOf(c => c.Receive<UniqueAddress>((address' ctx) =>                      {                          _seedUniqueAddress = address;                          ctx.Sender.Tell("ok");                      })' "address-receiver");                      Sys.ActorOf(Props.Create(() => new DomainEventLogger())' "cluster-logger");                      }' _config.NonSeed);                  EnterBarrier("addr-receiver-ready");                    RunOn(() =>                  {                      _seedUniqueAddress = Cluster.Get(_seedSystem.Value).SelfUniqueAddress;                      _seedSystem.Value.ActorOf(Props.Create(() => new DomainEventLogger())' "clusterLogger");                      var probe = CreateTestProbe(_seedSystem.Value);                      _seedSystem.Value.ActorSelection(new RootActorPath(GetAddress(_config.NonSeed)) / "user" / "address-receiver").Tell(_seedUniqueAddress' probe.Ref);                      probe.ExpectMsg("ok"' TimeSpan.FromSeconds(5));                  }' _config.Seed);                  EnterBarrier("addr-transferred");                    RunOn(() =>                  {                      Cluster.Get(_seedSystem.Value).JoinSeedNodes(SeedNodes);                      AwaitCondition(() => Cluster.Get(_seedSystem.Value).ReadView.IsSingletonCluster);                      _seedSystem.Value.ActorOf(Props.Create(() => new LeaderSynchronizer())' "leader-sync");                  }' _config.Seed);                  EnterBarrier("seed-self-joined");                    RunOn(() =>                  {                      var unreachableNodeAddress = Cluster.Get(_unavailableSeedSystem.Value).SelfAddress;                      // terminate the unreachableSeedNode                      Shutdown(_unavailableSeedSystem.Value' RemainingOrDefault);                        Cluster.JoinSeedNodes(SeedNodes.Add(unreachableNodeAddress)); // append the unreachable node address                      AwaitMembersUp(2);                      Sys.ActorOf(Props.Create(() => new LeaderSynchronizer())' "leader-sync");                  }' _config.NonSeed);                  EnterBarrier("formed-cluster");                                     /*                   * Verify that both nodes agree on who the leader is                   */                    RunOn(() =>                  {                      var addr2 = GetAddress(_config.NonSeed);                      var probe2 = CreateTestProbe(_seedSystem.Value);                      AwaitAssert(() =>                      {                          _seedSystem.Value.ActorSelection(new RootActorPath(addr2) / "user" / "leader-sync")                              .Tell("leader"' probe2.Ref);                          _verifiedLeader = probe2.ExpectMsg<Address>();                          _verifiedLeader.Should().Be(Cluster.Get(_seedSystem.Value).State.Leader);                      });                      }' _config.Seed);                    RunOn(() =>                  {                      AwaitAssert(() =>                      {                          _verifiedLeader =                              Sys.ActorSelection(new RootActorPath(SeedUniqueAddress.Address) / "user" / "leader-sync")                                  .Ask<Address>("leader")                                  .Result;                          _verifiedLeader.Should().Be(Cluster.State.Leader);                      });                  }' _config.NonSeed);                  EnterBarrier("verified-leader");              });
Magic Number,Akka.Cluster.Tests.MultiNode,JoinWithOfflineSeedNodeSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\JoinWithOfflineSeedNodeSpec.cs,JoinClusterWithOneOfflineSeedNode,The following statement contains a magic number: Within(TimeSpan.FromSeconds(30)' () =>              {                  RunOn(() =>                  {                      Sys.ActorOf(c => c.Receive<UniqueAddress>((address' ctx) =>                      {                          _seedUniqueAddress = address;                          ctx.Sender.Tell("ok");                      })' "address-receiver");                      Sys.ActorOf(Props.Create(() => new DomainEventLogger())' "cluster-logger");                      }' _config.NonSeed);                  EnterBarrier("addr-receiver-ready");                    RunOn(() =>                  {                      _seedUniqueAddress = Cluster.Get(_seedSystem.Value).SelfUniqueAddress;                      _seedSystem.Value.ActorOf(Props.Create(() => new DomainEventLogger())' "clusterLogger");                      var probe = CreateTestProbe(_seedSystem.Value);                      _seedSystem.Value.ActorSelection(new RootActorPath(GetAddress(_config.NonSeed)) / "user" / "address-receiver").Tell(_seedUniqueAddress' probe.Ref);                      probe.ExpectMsg("ok"' TimeSpan.FromSeconds(5));                  }' _config.Seed);                  EnterBarrier("addr-transferred");                    RunOn(() =>                  {                      Cluster.Get(_seedSystem.Value).JoinSeedNodes(SeedNodes);                      AwaitCondition(() => Cluster.Get(_seedSystem.Value).ReadView.IsSingletonCluster);                      _seedSystem.Value.ActorOf(Props.Create(() => new LeaderSynchronizer())' "leader-sync");                  }' _config.Seed);                  EnterBarrier("seed-self-joined");                    RunOn(() =>                  {                      var unreachableNodeAddress = Cluster.Get(_unavailableSeedSystem.Value).SelfAddress;                      // terminate the unreachableSeedNode                      Shutdown(_unavailableSeedSystem.Value' RemainingOrDefault);                        Cluster.JoinSeedNodes(SeedNodes.Add(unreachableNodeAddress)); // append the unreachable node address                      AwaitMembersUp(2);                      Sys.ActorOf(Props.Create(() => new LeaderSynchronizer())' "leader-sync");                  }' _config.NonSeed);                  EnterBarrier("formed-cluster");                                     /*                   * Verify that both nodes agree on who the leader is                   */                    RunOn(() =>                  {                      var addr2 = GetAddress(_config.NonSeed);                      var probe2 = CreateTestProbe(_seedSystem.Value);                      AwaitAssert(() =>                      {                          _seedSystem.Value.ActorSelection(new RootActorPath(addr2) / "user" / "leader-sync")                              .Tell("leader"' probe2.Ref);                          _verifiedLeader = probe2.ExpectMsg<Address>();                          _verifiedLeader.Should().Be(Cluster.Get(_seedSystem.Value).State.Leader);                      });                      }' _config.Seed);                    RunOn(() =>                  {                      AwaitAssert(() =>                      {                          _verifiedLeader =                              Sys.ActorSelection(new RootActorPath(SeedUniqueAddress.Address) / "user" / "leader-sync")                                  .Ask<Address>("leader")                                  .Result;                          _verifiedLeader.Should().Be(Cluster.State.Leader);                      });                  }' _config.NonSeed);                  EnterBarrier("verified-leader");              });
Magic Number,Akka.Cluster.Tests.MultiNode,JoinWithOfflineSeedNodeSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\JoinWithOfflineSeedNodeSpec.cs,JoinClusterWithOneOfflineSeedNode,The following statement contains a magic number: Within(TimeSpan.FromSeconds(30)' () =>              {                  RunOn(() =>                  {                      Sys.ActorOf(c => c.Receive<UniqueAddress>((address' ctx) =>                      {                          _seedUniqueAddress = address;                          ctx.Sender.Tell("ok");                      })' "address-receiver");                      Sys.ActorOf(Props.Create(() => new DomainEventLogger())' "cluster-logger");                      }' _config.NonSeed);                  EnterBarrier("addr-receiver-ready");                    RunOn(() =>                  {                      _seedUniqueAddress = Cluster.Get(_seedSystem.Value).SelfUniqueAddress;                      _seedSystem.Value.ActorOf(Props.Create(() => new DomainEventLogger())' "clusterLogger");                      var probe = CreateTestProbe(_seedSystem.Value);                      _seedSystem.Value.ActorSelection(new RootActorPath(GetAddress(_config.NonSeed)) / "user" / "address-receiver").Tell(_seedUniqueAddress' probe.Ref);                      probe.ExpectMsg("ok"' TimeSpan.FromSeconds(5));                  }' _config.Seed);                  EnterBarrier("addr-transferred");                    RunOn(() =>                  {                      Cluster.Get(_seedSystem.Value).JoinSeedNodes(SeedNodes);                      AwaitCondition(() => Cluster.Get(_seedSystem.Value).ReadView.IsSingletonCluster);                      _seedSystem.Value.ActorOf(Props.Create(() => new LeaderSynchronizer())' "leader-sync");                  }' _config.Seed);                  EnterBarrier("seed-self-joined");                    RunOn(() =>                  {                      var unreachableNodeAddress = Cluster.Get(_unavailableSeedSystem.Value).SelfAddress;                      // terminate the unreachableSeedNode                      Shutdown(_unavailableSeedSystem.Value' RemainingOrDefault);                        Cluster.JoinSeedNodes(SeedNodes.Add(unreachableNodeAddress)); // append the unreachable node address                      AwaitMembersUp(2);                      Sys.ActorOf(Props.Create(() => new LeaderSynchronizer())' "leader-sync");                  }' _config.NonSeed);                  EnterBarrier("formed-cluster");                                     /*                   * Verify that both nodes agree on who the leader is                   */                    RunOn(() =>                  {                      var addr2 = GetAddress(_config.NonSeed);                      var probe2 = CreateTestProbe(_seedSystem.Value);                      AwaitAssert(() =>                      {                          _seedSystem.Value.ActorSelection(new RootActorPath(addr2) / "user" / "leader-sync")                              .Tell("leader"' probe2.Ref);                          _verifiedLeader = probe2.ExpectMsg<Address>();                          _verifiedLeader.Should().Be(Cluster.Get(_seedSystem.Value).State.Leader);                      });                      }' _config.Seed);                    RunOn(() =>                  {                      AwaitAssert(() =>                      {                          _verifiedLeader =                              Sys.ActorSelection(new RootActorPath(SeedUniqueAddress.Address) / "user" / "leader-sync")                                  .Ask<Address>("leader")                                  .Result;                          _verifiedLeader.Should().Be(Cluster.State.Leader);                      });                  }' _config.NonSeed);                  EnterBarrier("verified-leader");              });
Magic Number,Akka.Cluster.Tests.MultiNode,LeaderDowningAllOtherNodesSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\LeaderDowningAllOtherNodesSpec.cs,A_Cluster_of_6_nodes_with_monitored_by_nr_of_members_2_must_remove_all_shutdown_nodes,The following statement contains a magic number: AwaitMembersUp(numbersOfMembers: 1' canNotBePartOfMemberRing: shutdownAddresses' timeout: 30.Seconds());
Magic Number,Akka.Cluster.Tests.MultiNode,LeaderDowningNodeThatIsUnreachableSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\LeaderDowningNodeThatIsUnreachableSpec.cs,Leader_in_4_node_cluster_must_be_able_to_down_last_node_that_is_unreachable,The following statement contains a magic number: RunOn(() =>              {                  // kill 'fourth' node                  TestConductor.Exit(_config.Fourth' 0).Wait();                  EnterBarrier("down-fourth-node");                    // mark the node as unreachable in the failure detector                  MarkNodeAsUnavailable(fourthAddress);                    // --- HERE THE LEADER SHOULD DETECT FAILURE AND AUTO-DOWN THE UNREACHABLE NODE ---                  AwaitMembersUp(3' ImmutableHashSet.Create(fourthAddress)' 30.Seconds());              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode,LeaderDowningNodeThatIsUnreachableSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\LeaderDowningNodeThatIsUnreachableSpec.cs,Leader_in_4_node_cluster_must_be_able_to_down_last_node_that_is_unreachable,The following statement contains a magic number: RunOn(() =>              {                  // kill 'fourth' node                  TestConductor.Exit(_config.Fourth' 0).Wait();                  EnterBarrier("down-fourth-node");                    // mark the node as unreachable in the failure detector                  MarkNodeAsUnavailable(fourthAddress);                    // --- HERE THE LEADER SHOULD DETECT FAILURE AND AUTO-DOWN THE UNREACHABLE NODE ---                  AwaitMembersUp(3' ImmutableHashSet.Create(fourthAddress)' 30.Seconds());              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode,LeaderDowningNodeThatIsUnreachableSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\LeaderDowningNodeThatIsUnreachableSpec.cs,Leader_in_4_node_cluster_must_be_able_to_down_last_node_that_is_unreachable,The following statement contains a magic number: RunOn(() =>              {                  EnterBarrier("down-fourth-node");                  AwaitMembersUp(3' ImmutableHashSet.Create(fourthAddress)' 30.Seconds());              }' _config.Second' _config.Third);
Magic Number,Akka.Cluster.Tests.MultiNode,LeaderDowningNodeThatIsUnreachableSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\LeaderDowningNodeThatIsUnreachableSpec.cs,Leader_in_4_node_cluster_must_be_able_to_down_last_node_that_is_unreachable,The following statement contains a magic number: RunOn(() =>              {                  EnterBarrier("down-fourth-node");                  AwaitMembersUp(3' ImmutableHashSet.Create(fourthAddress)' 30.Seconds());              }' _config.Second' _config.Third);
Magic Number,Akka.Cluster.Tests.MultiNode,LeaderDowningNodeThatIsUnreachableSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\LeaderDowningNodeThatIsUnreachableSpec.cs,Leader_in_4_node_cluster_must_be_able_to_down_middle_node_that_is_unreachable,The following statement contains a magic number: RunOn(() =>              {                  // kill 'fourth' node                  TestConductor.Exit(_config.Second' 0).Wait();                  EnterBarrier("down-second-node");                    // mark the node as unreachable in the failure detector                  MarkNodeAsUnavailable(secondAddress);                    // --- HERE THE LEADER SHOULD DETECT FAILURE AND AUTO-DOWN THE UNREACHABLE NODE ---                  AwaitMembersUp(2' ImmutableHashSet.Create(secondAddress)' 30.Seconds());              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode,LeaderDowningNodeThatIsUnreachableSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\LeaderDowningNodeThatIsUnreachableSpec.cs,Leader_in_4_node_cluster_must_be_able_to_down_middle_node_that_is_unreachable,The following statement contains a magic number: RunOn(() =>              {                  // kill 'fourth' node                  TestConductor.Exit(_config.Second' 0).Wait();                  EnterBarrier("down-second-node");                    // mark the node as unreachable in the failure detector                  MarkNodeAsUnavailable(secondAddress);                    // --- HERE THE LEADER SHOULD DETECT FAILURE AND AUTO-DOWN THE UNREACHABLE NODE ---                  AwaitMembersUp(2' ImmutableHashSet.Create(secondAddress)' 30.Seconds());              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode,LeaderDowningNodeThatIsUnreachableSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\LeaderDowningNodeThatIsUnreachableSpec.cs,Leader_in_4_node_cluster_must_be_able_to_down_middle_node_that_is_unreachable,The following statement contains a magic number: RunOn(() =>              {                  EnterBarrier("down-second-node");                  AwaitMembersUp(2' ImmutableHashSet.Create(secondAddress)' 30.Seconds());              }' _config.Second' _config.Third);
Magic Number,Akka.Cluster.Tests.MultiNode,LeaderDowningNodeThatIsUnreachableSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\LeaderDowningNodeThatIsUnreachableSpec.cs,Leader_in_4_node_cluster_must_be_able_to_down_middle_node_that_is_unreachable,The following statement contains a magic number: RunOn(() =>              {                  EnterBarrier("down-second-node");                  AwaitMembersUp(2' ImmutableHashSet.Create(secondAddress)' 30.Seconds());              }' _config.Second' _config.Third);
Magic Number,Akka.Cluster.Tests.MultiNode,LeaderElectionSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\LeaderElectionSpec.cs,ShutdownLeaderAndVerifyNewLeader,The following statement contains a magic number: currentRoles.Count.ShouldBeGreaterOrEqual(2);
Magic Number,Akka.Cluster.Tests.MultiNode,LeaderElectionSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\LeaderElectionSpec.cs,Cluster_of_four_nodes_must_be_able_to_reelect_single_leader_after_leader_has_left,The following statement contains a magic number: Within(TimeSpan.FromSeconds(30)' () =>              {                  ShutdownLeaderAndVerifyNewLeader(0);                  EnterBarrier("after-2");              });
Magic Number,Akka.Cluster.Tests.MultiNode,LeaderElectionSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\LeaderElectionSpec.cs,Cluster_of_four_nodes_must_be_able_to_reelect_single_leader_after_leader_has_left_again,The following statement contains a magic number: Within(TimeSpan.FromSeconds(30)' () =>              {                  ShutdownLeaderAndVerifyNewLeader(1);                  EnterBarrier("after-3");              });
Magic Number,Akka.Cluster.Tests.MultiNode,LeaderLeavingSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\LeaderLeavingSpec.cs,A_leader_that_is_leaving_must_be_moved_to_leaving_then_exiting_then_removed_then_be_shut_down_and_then_a_new_leader_should_be_elected,The following statement contains a magic number: Within(TimeSpan.FromSeconds(30)' () =>                  {                      if (ClusterView.IsLeader)                      {                          EnterBarrier("registered-listener");                            Cluster.Leave(oldLeaderAddress);                          EnterBarrier("leader-left");                            // verify that the LEADER is shut down                          AwaitCondition(() => Cluster.IsTerminated);                          EnterBarrier("leader-shutdown");                      }                      else                      {                          var exitingLatch = new TestLatch();                            var listener = Sys.ActorOf(Props.Create(() => new Listener(oldLeaderAddress' exitingLatch)).WithDeploy(Deploy.Local));                            Cluster.Subscribe(listener' new []{typeof(ClusterEvent.IMemberEvent)});                            EnterBarrier("registered-listener");                            EnterBarrier("leader-left");                            // verify that the LEADER is EXITING                          exitingLatch.Ready(TestKitSettings.DefaultTimeout);                            EnterBarrier("leader-shutdown");                          MarkNodeAsUnavailable(oldLeaderAddress);                            // verify that the LEADER is no longer part of the 'members' set                          AwaitAssert(() => ClusterView.Members.Select(m => m.Address).Contains(oldLeaderAddress).ShouldBeFalse());                            // verify that the LEADER is not part of the 'unreachable' set                          AwaitAssert(() => ClusterView.UnreachableMembers.Select(m => m.Address).Contains(oldLeaderAddress).ShouldBeFalse());                            // verify that we have a new LEADER                          AwaitAssert(() => ClusterView.Leader.ShouldNotBe(oldLeaderAddress));                      }                        EnterBarrier("finished");                  });
Magic Number,Akka.Cluster.Tests.MultiNode,MemberWeaklyUpSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\MemberWeaklyUpSpec.cs,A_cluster_of_3_members_should_detect_network_partition_and_mark_nodes_on_the_other_side_as_unreachable,The following statement contains a magic number: Within(TimeSpan.FromSeconds(20)' () =>              {                  RunOn(() =>                  {                      // split the cluster in two parts (first' second) / (third' fourth' fifth)                      foreach (var role1 in _side1)                          foreach (var role2 in _side2)                              TestConductor.Blackhole(role1' role2' ThrottleTransportAdapter.Direction.Both).Wait(TimeSpan.FromSeconds(3));                  }' _config.First);                    EnterBarrier("after-split");                    RunOn(() =>                  {                      AwaitAssert(() =>                          ClusterView.UnreachableMembers                              .Select(m => m.Address).ToImmutableHashSet()                              .ShouldBe(ImmutableHashSet.CreateRange(new[] { GetAddress(_config.Third)' GetAddress(_config.Fourth) })));                  }' _config.First);                    RunOn(() =>                  {                      AwaitAssert(() =>                          ClusterView.UnreachableMembers                              .Select(m => m.Address).ToImmutableHashSet()                              .ShouldBe(ImmutableHashSet.CreateRange(new[] { GetAddress(_config.First) })));                  }' _config.Third' _config.Fourth);                    EnterBarrier("after-2");              });
Magic Number,Akka.Cluster.Tests.MultiNode,MemberWeaklyUpSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\MemberWeaklyUpSpec.cs,A_cluster_of_3_members_should_detect_network_partition_and_mark_nodes_on_the_other_side_as_unreachable,The following statement contains a magic number: Within(TimeSpan.FromSeconds(20)' () =>              {                  RunOn(() =>                  {                      // split the cluster in two parts (first' second) / (third' fourth' fifth)                      foreach (var role1 in _side1)                          foreach (var role2 in _side2)                              TestConductor.Blackhole(role1' role2' ThrottleTransportAdapter.Direction.Both).Wait(TimeSpan.FromSeconds(3));                  }' _config.First);                    EnterBarrier("after-split");                    RunOn(() =>                  {                      AwaitAssert(() =>                          ClusterView.UnreachableMembers                              .Select(m => m.Address).ToImmutableHashSet()                              .ShouldBe(ImmutableHashSet.CreateRange(new[] { GetAddress(_config.Third)' GetAddress(_config.Fourth) })));                  }' _config.First);                    RunOn(() =>                  {                      AwaitAssert(() =>                          ClusterView.UnreachableMembers                              .Select(m => m.Address).ToImmutableHashSet()                              .ShouldBe(ImmutableHashSet.CreateRange(new[] { GetAddress(_config.First) })));                  }' _config.Third' _config.Fourth);                    EnterBarrier("after-2");              });
Magic Number,Akka.Cluster.Tests.MultiNode,MemberWeaklyUpSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\MemberWeaklyUpSpec.cs,A_cluster_of_3_members_should_accept_joining_on_each_side_and_set_status_to_WeaklyUp,The following statement contains a magic number: Within(TimeSpan.FromSeconds(20)' () =>              {                  RunOn(() => Cluster.Get(Sys).Join(GetAddress(_config.First))' _config.Second);                  RunOn(() => Cluster.Get(Sys).Join(GetAddress(_config.Fourth))' _config.Fifth);                    EnterBarrier("joined");                    RunOn(() => AwaitAssert(() =>                  {                      ClusterView.Members.Count.ShouldBe(4);                      ClusterView.Members.Any(m => m.Address == GetAddress(_config.Second) && m.Status == MemberStatus.WeaklyUp).ShouldBe(true);                    })' _side1.ToArray());                    RunOn(() => AwaitAssert(() =>                  {                      ClusterView.Members.Count.ShouldBe(4);                      ClusterView.Members.Any(m => m.Address == GetAddress(_config.Fifth) && m.Status == MemberStatus.WeaklyUp).ShouldBe(true);                    })' _side2.ToArray());                    EnterBarrier("after-3");              });
Magic Number,Akka.Cluster.Tests.MultiNode,MemberWeaklyUpSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\MemberWeaklyUpSpec.cs,A_cluster_of_3_members_should_accept_joining_on_each_side_and_set_status_to_WeaklyUp,The following statement contains a magic number: Within(TimeSpan.FromSeconds(20)' () =>              {                  RunOn(() => Cluster.Get(Sys).Join(GetAddress(_config.First))' _config.Second);                  RunOn(() => Cluster.Get(Sys).Join(GetAddress(_config.Fourth))' _config.Fifth);                    EnterBarrier("joined");                    RunOn(() => AwaitAssert(() =>                  {                      ClusterView.Members.Count.ShouldBe(4);                      ClusterView.Members.Any(m => m.Address == GetAddress(_config.Second) && m.Status == MemberStatus.WeaklyUp).ShouldBe(true);                    })' _side1.ToArray());                    RunOn(() => AwaitAssert(() =>                  {                      ClusterView.Members.Count.ShouldBe(4);                      ClusterView.Members.Any(m => m.Address == GetAddress(_config.Fifth) && m.Status == MemberStatus.WeaklyUp).ShouldBe(true);                    })' _side2.ToArray());                    EnterBarrier("after-3");              });
Magic Number,Akka.Cluster.Tests.MultiNode,MemberWeaklyUpSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\MemberWeaklyUpSpec.cs,A_cluster_of_3_members_should_accept_joining_on_each_side_and_set_status_to_WeaklyUp,The following statement contains a magic number: Within(TimeSpan.FromSeconds(20)' () =>              {                  RunOn(() => Cluster.Get(Sys).Join(GetAddress(_config.First))' _config.Second);                  RunOn(() => Cluster.Get(Sys).Join(GetAddress(_config.Fourth))' _config.Fifth);                    EnterBarrier("joined");                    RunOn(() => AwaitAssert(() =>                  {                      ClusterView.Members.Count.ShouldBe(4);                      ClusterView.Members.Any(m => m.Address == GetAddress(_config.Second) && m.Status == MemberStatus.WeaklyUp).ShouldBe(true);                    })' _side1.ToArray());                    RunOn(() => AwaitAssert(() =>                  {                      ClusterView.Members.Count.ShouldBe(4);                      ClusterView.Members.Any(m => m.Address == GetAddress(_config.Fifth) && m.Status == MemberStatus.WeaklyUp).ShouldBe(true);                    })' _side2.ToArray());                    EnterBarrier("after-3");              });
Magic Number,Akka.Cluster.Tests.MultiNode,MemberWeaklyUpSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\MemberWeaklyUpSpec.cs,A_cluster_of_3_members_should_change_status_to_Up_after_healed_network_partition,The following statement contains a magic number: Within(TimeSpan.FromSeconds(20)' () =>              {                  RunOn(() =>                  {                      foreach (var role1 in _side1)                          foreach (var role2 in _side2)                          {                              TestConductor.PassThrough(role1' role2' ThrottleTransportAdapter.Direction.Both).Wait(TimeSpan.FromSeconds(3));                          }                  }' _config.First);                    EnterBarrier("after-passThrough");                    AwaitAllReachable();                  AwaitMembersUp(5);                    EnterBarrier("after-4");              });
Magic Number,Akka.Cluster.Tests.MultiNode,MemberWeaklyUpSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\MemberWeaklyUpSpec.cs,A_cluster_of_3_members_should_change_status_to_Up_after_healed_network_partition,The following statement contains a magic number: Within(TimeSpan.FromSeconds(20)' () =>              {                  RunOn(() =>                  {                      foreach (var role1 in _side1)                          foreach (var role2 in _side2)                          {                              TestConductor.PassThrough(role1' role2' ThrottleTransportAdapter.Direction.Both).Wait(TimeSpan.FromSeconds(3));                          }                  }' _config.First);                    EnterBarrier("after-passThrough");                    AwaitAllReachable();                  AwaitMembersUp(5);                    EnterBarrier("after-4");              });
Magic Number,Akka.Cluster.Tests.MultiNode,MemberWeaklyUpSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\MemberWeaklyUpSpec.cs,A_cluster_of_3_members_should_change_status_to_Up_after_healed_network_partition,The following statement contains a magic number: Within(TimeSpan.FromSeconds(20)' () =>              {                  RunOn(() =>                  {                      foreach (var role1 in _side1)                          foreach (var role2 in _side2)                          {                              TestConductor.PassThrough(role1' role2' ThrottleTransportAdapter.Direction.Both).Wait(TimeSpan.FromSeconds(3));                          }                  }' _config.First);                    EnterBarrier("after-passThrough");                    AwaitAllReachable();                  AwaitMembersUp(5);                    EnterBarrier("after-4");              });
Magic Number,Akka.Cluster.Tests.MultiNode,MinMembersBeforeUpBase,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\MinMembersBeforeUpSpec.cs,TestWaitMovingMembersToUp,The following statement contains a magic number: RunOn(() =>              {                  var expectedAddresses = new List<Address> { GetAddress(First)' GetAddress(Second) };                  AwaitAssert(() =>                  {                      ClusterView.RefreshCurrentState();                      ClusterView.Members.Select(c => c.Address).Except(expectedAddresses).Count().ShouldBe(0);                  });                  ClusterView.Members.All(c => c.Status == MemberStatus.Joining).ShouldBeTrue();                  // and it should not change                  foreach (var _ in Enumerable.Range(1' 5))                  {                      Thread.Sleep(1000);                      ClusterView.Members.Select(c => c.Address).Except(expectedAddresses).Count().ShouldBe(0);                      ClusterView.Members.All(c => c.Status == MemberStatus.Joining).ShouldBeTrue();                  }              }' First' Second);
Magic Number,Akka.Cluster.Tests.MultiNode,MinMembersBeforeUpBase,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\MinMembersBeforeUpSpec.cs,TestWaitMovingMembersToUp,The following statement contains a magic number: RunOn(() =>              {                  var expectedAddresses = new List<Address> { GetAddress(First)' GetAddress(Second) };                  AwaitAssert(() =>                  {                      ClusterView.RefreshCurrentState();                      ClusterView.Members.Select(c => c.Address).Except(expectedAddresses).Count().ShouldBe(0);                  });                  ClusterView.Members.All(c => c.Status == MemberStatus.Joining).ShouldBeTrue();                  // and it should not change                  foreach (var _ in Enumerable.Range(1' 5))                  {                      Thread.Sleep(1000);                      ClusterView.Members.Select(c => c.Address).Except(expectedAddresses).Count().ShouldBe(0);                      ClusterView.Members.All(c => c.Status == MemberStatus.Joining).ShouldBeTrue();                  }              }' First' Second);
Magic Number,Akka.Cluster.Tests.MultiNode,NodeChurnSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\NodeChurnSpec.cs,Cluster_with_short_lived_members_must_setup_stable_nodes,The following statement contains a magic number: Within(15.Seconds()' () =>              {                  var logListener = Sys.ActorOf(Props.Create(() => new LogListener(TestActor))' "logListener");                  Sys.EventStream.Subscribe(logListener' typeof(Info));                  Cluster.JoinSeedNodes(SeedNodes);                  AwaitMembersUp(Roles.Count);                  EnterBarrier("stable");              });
Magic Number,Akka.Cluster.Tests.MultiNode,NodeChurnSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\NodeChurnSpec.cs,Cluster_with_short_lived_members_must_join_and_remove_transient_nodes_without_growing_gossip_payload,The following statement contains a magic number: n % 2 == 0
Magic Number,Akka.Cluster.Tests.MultiNode,NodeChurnSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\NodeChurnSpec.cs,Cluster_with_short_lived_members_must_join_and_remove_transient_nodes_without_growing_gossip_payload,The following statement contains a magic number: ExpectNoMsg(2.Seconds());
Magic Number,Akka.Cluster.Tests.MultiNode,NodeChurnSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\NodeChurnSpec.cs,Cluster_with_short_lived_members_must_join_and_remove_transient_nodes_without_growing_gossip_payload,The following statement contains a magic number: ExpectNoMsg(5.Seconds());
Magic Number,Akka.Cluster.Tests.MultiNode,NodeChurnSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\NodeChurnSpec.cs,AwaitAllMembersUp,The following statement contains a magic number: Within(20.Seconds()' () =>              {                  AwaitAssert(() =>                  {                      additionalSystems.ForEach(s =>                      {                          var cluster = Cluster.Get(s);                          cluster.State.Members.Count.Should().Be(numberOfMembers);                          cluster.State.Members.All(c => c.Status == MemberStatus.Up).Should().BeTrue();                      });                  });              });
Magic Number,Akka.Cluster.Tests.MultiNode,NodeChurnSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\NodeChurnSpec.cs,AwaitRemoved,The following statement contains a magic number: AwaitMembersUp(Roles.Count' timeout: 40.Seconds());
Magic Number,Akka.Cluster.Tests.MultiNode,NodeChurnSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\NodeChurnSpec.cs,AwaitRemoved,The following statement contains a magic number: Within(3.Seconds()' () =>              {                  AwaitAssert(() =>                  {                      additionalSystems.ForEach(s =>                      {                          Cluster.Get(s).IsTerminated.Should().BeTrue($"{Cluster.Get(s).SelfAddress}");                      });                  });              });
Magic Number,Akka.Cluster.Tests.MultiNode,NodeDowningAndBeingRemovedSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\NodeDowningAndBeingRemovedSpec.cs,Node_that_is_downed_must_eventually_be_removed_from_membership,The following statement contains a magic number: Within(TimeSpan.FromSeconds(30)' () =>              {                  RunOn(() =>                  {                      Cluster.Down(GetAddress(_config.Second));                      Cluster.Down(GetAddress(_config.Third));                  }' _config.First);                  EnterBarrier("second-and-third-down");                    RunOn(() =>                  {                      // verify that the node is shut down                      AwaitCondition(() => Cluster.IsTerminated);                  }' _config.Second' _config.Third);                  EnterBarrier("second-and-third-shutdown");                    RunOn(() =>                  {                      AwaitAssert(() =>                      {                          ClusterView.Members.Select(c => c.Address).Should().NotContain(GetAddress(_config.Second));                          ClusterView.Members.Select(c => c.Address).Should().NotContain(GetAddress(_config.Third));                      });                  }' _config.First);                    EnterBarrier("finished");              });
Magic Number,Akka.Cluster.Tests.MultiNode,NodeLeavingAndExitingAndBeingRemovedSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\NodeLeavingAndExitingAndBeingRemovedSpec.cs,Node_that_is_leaving_non_singleton_cluster_eventually_set_to_removed_and_removed_from_membership_ring_and_seen_table,The following statement contains a magic number: Within(TimeSpan.FromSeconds(15)' () =>              {                  RunOn(() =>                  {                      Cluster.Leave(GetAddress(_config.Second));                  }' _config.First);                  EnterBarrier("second-left");                    RunOn(() =>                  {                      EnterBarrier("second-shutdown");                      // this test verifies that the removal is performed via the ExitingCompleted message'                      // otherwise we would have `MarkNodeAsUnavailable(second)` to trigger the FailureDetectorPuppet                        // verify that the 'second' node is no longer part of the 'members'/'unreachable' set                      AwaitAssert(() =>                      {                          ClusterView.Members.Select(c => c.Address).Should().NotContain(GetAddress(_config.Second));                      });                      AwaitAssert(() =>                      {                          ClusterView.UnreachableMembers.Select(c => c.Address).Should().NotContain(GetAddress(_config.Second));                      });                  }' _config.First' _config.Third);                    RunOn(() =>                  {                      // verify that the second node is shut down                      AwaitCondition(() => Cluster.IsTerminated);                      EnterBarrier("second-shutdown");                  }' _config.Second);                    EnterBarrier("finished");              });
Magic Number,Akka.Cluster.Tests.MultiNode,NodeMembershipSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\NodeMembershipSpec.cs,Set_of_connected_cluster_systems_must_with_two_nodes_start_gossiping_to_each_other_so_that_both_nodes_gets_same_gossip_info,The following statement contains a magic number: RunOn(() =>              {                  Cluster.Join(GetAddress(_config.First));                  AwaitAssert(() => ClusterView.Members.Count.ShouldBe(2));                  AssertMembers(ClusterView.Members' GetAddress(_config.First)' GetAddress(_config.Second));                  AwaitAssert(() => ClusterView.Members.All(c => c.Status == MemberStatus.Up).ShouldBeTrue());              }' _config.First' _config.Second);
Magic Number,Akka.Cluster.Tests.MultiNode,NodeMembershipSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\NodeMembershipSpec.cs,Set_of_connected_cluster_systems_must_with_three_nodes_start_gossiping_to_each_other_so_that_all_nodes_gets_same_gossip_info,The following statement contains a magic number: AwaitAssert(() => ClusterView.Members.Count.ShouldBe(3));
Magic Number,Akka.Cluster.Tests.MultiNode,NodeUpSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\NodeUpSpec.cs,Cluster_node_that_is_joining_another_cluster_must_not_be_able_to_join_node_that_is_not_cluster_member,The following statement contains a magic number: Thread.Sleep(2000);
Magic Number,Akka.Cluster.Tests.MultiNode,NodeUpSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\NodeUpSpec.cs,Cluster_node_that_is_joining_another_cluster_must_be_unaffected_when_joining_again,The following statement contains a magic number: Thread.Sleep(Dilated(TimeSpan.FromMilliseconds(100)));
Magic Number,Akka.Cluster.Tests.MultiNode,NodeUpSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\NodeUpSpec.cs,Cluster_node_that_is_joining_another_cluster_must_be_unaffected_when_joining_again,The following statement contains a magic number: Enumerable.Range(1' 20)
Magic Number,Akka.Cluster.Tests.MultiNode,QuickRestartSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\QuickRestartSpec.cs,SetupStableSeedNodes,The following statement contains a magic number: Within(TimeSpan.FromSeconds(15)' () =>              {                  Cluster.JoinSeedNodes(_seedNodes.Value);                  AwaitMembersUp(Roles.Count);                  EnterBarrier("stable");              });
Magic Number,Akka.Cluster.Tests.MultiNode,QuickRestartSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\QuickRestartSpec.cs,JoinAndRestart,The following statement contains a magic number: RunOn(() =>                  {                      restartingSystem = restartingSystem == null                          ? ActorSystem.Create(Sys.Name' ConfigurationFactory.ParseString($"akka.cluster.roles=[round-{round}]")                              .WithFallback(Sys.Settings.Config))                          : ActorSystem.Create(Sys.Name' ConfigurationFactory.ParseString($"akka.cluster.roles=[round-{round}]")                              .WithFallback(                                  $"akka.remote.dot-netty.tcp.port={Cluster.Get(restartingSystem).SelfAddress.Port}")                              .WithFallback(Sys.Settings.Config));                      Log.Info("Restarting node has address {0}"' Cluster.Get(restartingSystem).SelfUniqueAddress);                      Cluster.Get(restartingSystem).JoinSeedNodes(_seedNodes.Value);                      Within(TimeSpan.FromSeconds(20)' () =>                      {                          AwaitAssert(() =>                          {                              Cluster.Get(restartingSystem).State.Members.Count.ShouldBe(totalNumberOfNodes);                              Cluster.Get(restartingSystem).State.Members.All(x => x.Status == MemberStatus.Up).ShouldBeTrue();                          });                      });                  }' _config.Second);
Magic Number,Akka.Cluster.Tests.MultiNode,QuickRestartSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\QuickRestartSpec.cs,JoinAndRestart,The following statement contains a magic number: Within(TimeSpan.FromSeconds(20)' () =>                  {                      AwaitAssert(() =>                      {                          Cluster.Get(Sys).State.Members.Count.ShouldBe(totalNumberOfNodes);                          Cluster.Get(Sys).State.Members.All(x => x.Status == MemberStatus.Up).ShouldBeTrue();                          // use the role to test that it is the new incarnation that joined' sneaky                          Cluster.Get(Sys).State.Members.SelectMany(x => x.Roles).ShouldBe(new [] { $"round-{round}" });                      });                  });
Magic Number,Akka.Cluster.Tests.MultiNode,QuickRestartSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\QuickRestartSpec.cs,JoinAndRestart,The following statement contains a magic number: Thread.Sleep(ThreadLocalRandom.Current.Next(15) * 1000);
Magic Number,Akka.Cluster.Tests.MultiNode,QuickRestartSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\QuickRestartSpec.cs,JoinAndRestart,The following statement contains a magic number: Thread.Sleep(ThreadLocalRandom.Current.Next(15) * 1000);
Magic Number,Akka.Cluster.Tests.MultiNode,RestartFirstSeedNodeSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartFirstSeedNodeSpec.cs,RestartFirstSeedNodeSpec,The following statement contains a magic number: _missedSeed = GetAddress(config.Seed3).WithPort(61313);
Magic Number,Akka.Cluster.Tests.MultiNode,RestartFirstSeedNodeSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartFirstSeedNodeSpec.cs,Cluster_seed_nodes__must_be_able_to_restart_first_seed_node_and_join_other_seed_nodes,The following statement contains a magic number: Within(TimeSpan.FromSeconds(40)' () =>              {                  RunOn(() =>                  {                      Sys.ActorOf(Props.Create(() => new Listener())                          .WithDeploy(Deploy.Local)' "address-receiver");                        EnterBarrier("seed1-address-receiver-ready");                  }' _config.Seed2' _config.Seed3);                    RunOn(() =>                  {                      EnterBarrier("seed1-address-receiver-ready");                      _seedNode1Address = Cluster.Get(seed1System.Value).SelfAddress;                      foreach (var r in new List<RoleName> { _config.Seed2' _config.Seed3 })                      {                          Sys.ActorSelection(new RootActorPath(GetAddress(r)) / "user" / "address-receiver").Tell(_seedNode1Address);                          ExpectMsg("ok"' TimeSpan.FromSeconds(5));                      }                  }' _config.Seed1);                  EnterBarrier("seed1-address-transfered");                    // now we can join seed1System' seed2' seed3 together                  RunOn(() =>                  {                      Cluster.Get(seed1System.Value).JoinSeedNodes(GetSeedNodes());                      AwaitAssert(() =>                      {                          Cluster.Get(seed1System.Value)                              .ReadView.Members.Count                              .Should()                              .Be(3);                      }' TimeSpan.FromSeconds(10));                      AwaitAssert(() =>                      {                          Cluster.Get(seed1System.Value)                              .ReadView.Members.All(c => c.Status == MemberStatus.Up)                              .Should()                              .BeTrue();                      });                  }' _config.Seed1);                  RunOn(() =>                  {                      Cluster.JoinSeedNodes(GetSeedNodes());                      AwaitMembersUp(3);                  }' _config.Seed2' _config.Seed3);                  EnterBarrier("started");                    // shutdown seed1System                  RunOn(() =>                  {                      Shutdown(seed1System.Value' RemainingOrDefault);                  }' _config.Seed1);                  EnterBarrier("seed1-shutdown");                    RunOn(() =>                  {                      Cluster.Get(restartedSeed1System.Value).JoinSeedNodes(GetSeedNodes());                      Within(TimeSpan.FromSeconds(20)' () =>                      {                          AwaitAssert(() =>                          {                              Cluster.Get(restartedSeed1System.Value)                                  .ReadView.Members.Count                                  .Should()                                  .Be(3);                          });                          AwaitAssert(() =>                          {                              Cluster.Get(restartedSeed1System.Value)                                  .ReadView.Members.All(c => c.Status == MemberStatus.Up)                                  .Should()                                  .BeTrue();                          });                      });                  }' _config.Seed1);                    RunOn(() =>                  {                      AwaitMembersUp(3);                  }' _config.Seed2' _config.Seed3);                  EnterBarrier("seed1-restarted");              });
Magic Number,Akka.Cluster.Tests.MultiNode,RestartFirstSeedNodeSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartFirstSeedNodeSpec.cs,Cluster_seed_nodes__must_be_able_to_restart_first_seed_node_and_join_other_seed_nodes,The following statement contains a magic number: Within(TimeSpan.FromSeconds(40)' () =>              {                  RunOn(() =>                  {                      Sys.ActorOf(Props.Create(() => new Listener())                          .WithDeploy(Deploy.Local)' "address-receiver");                        EnterBarrier("seed1-address-receiver-ready");                  }' _config.Seed2' _config.Seed3);                    RunOn(() =>                  {                      EnterBarrier("seed1-address-receiver-ready");                      _seedNode1Address = Cluster.Get(seed1System.Value).SelfAddress;                      foreach (var r in new List<RoleName> { _config.Seed2' _config.Seed3 })                      {                          Sys.ActorSelection(new RootActorPath(GetAddress(r)) / "user" / "address-receiver").Tell(_seedNode1Address);                          ExpectMsg("ok"' TimeSpan.FromSeconds(5));                      }                  }' _config.Seed1);                  EnterBarrier("seed1-address-transfered");                    // now we can join seed1System' seed2' seed3 together                  RunOn(() =>                  {                      Cluster.Get(seed1System.Value).JoinSeedNodes(GetSeedNodes());                      AwaitAssert(() =>                      {                          Cluster.Get(seed1System.Value)                              .ReadView.Members.Count                              .Should()                              .Be(3);                      }' TimeSpan.FromSeconds(10));                      AwaitAssert(() =>                      {                          Cluster.Get(seed1System.Value)                              .ReadView.Members.All(c => c.Status == MemberStatus.Up)                              .Should()                              .BeTrue();                      });                  }' _config.Seed1);                  RunOn(() =>                  {                      Cluster.JoinSeedNodes(GetSeedNodes());                      AwaitMembersUp(3);                  }' _config.Seed2' _config.Seed3);                  EnterBarrier("started");                    // shutdown seed1System                  RunOn(() =>                  {                      Shutdown(seed1System.Value' RemainingOrDefault);                  }' _config.Seed1);                  EnterBarrier("seed1-shutdown");                    RunOn(() =>                  {                      Cluster.Get(restartedSeed1System.Value).JoinSeedNodes(GetSeedNodes());                      Within(TimeSpan.FromSeconds(20)' () =>                      {                          AwaitAssert(() =>                          {                              Cluster.Get(restartedSeed1System.Value)                                  .ReadView.Members.Count                                  .Should()                                  .Be(3);                          });                          AwaitAssert(() =>                          {                              Cluster.Get(restartedSeed1System.Value)                                  .ReadView.Members.All(c => c.Status == MemberStatus.Up)                                  .Should()                                  .BeTrue();                          });                      });                  }' _config.Seed1);                    RunOn(() =>                  {                      AwaitMembersUp(3);                  }' _config.Seed2' _config.Seed3);                  EnterBarrier("seed1-restarted");              });
Magic Number,Akka.Cluster.Tests.MultiNode,RestartFirstSeedNodeSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartFirstSeedNodeSpec.cs,Cluster_seed_nodes__must_be_able_to_restart_first_seed_node_and_join_other_seed_nodes,The following statement contains a magic number: Within(TimeSpan.FromSeconds(40)' () =>              {                  RunOn(() =>                  {                      Sys.ActorOf(Props.Create(() => new Listener())                          .WithDeploy(Deploy.Local)' "address-receiver");                        EnterBarrier("seed1-address-receiver-ready");                  }' _config.Seed2' _config.Seed3);                    RunOn(() =>                  {                      EnterBarrier("seed1-address-receiver-ready");                      _seedNode1Address = Cluster.Get(seed1System.Value).SelfAddress;                      foreach (var r in new List<RoleName> { _config.Seed2' _config.Seed3 })                      {                          Sys.ActorSelection(new RootActorPath(GetAddress(r)) / "user" / "address-receiver").Tell(_seedNode1Address);                          ExpectMsg("ok"' TimeSpan.FromSeconds(5));                      }                  }' _config.Seed1);                  EnterBarrier("seed1-address-transfered");                    // now we can join seed1System' seed2' seed3 together                  RunOn(() =>                  {                      Cluster.Get(seed1System.Value).JoinSeedNodes(GetSeedNodes());                      AwaitAssert(() =>                      {                          Cluster.Get(seed1System.Value)                              .ReadView.Members.Count                              .Should()                              .Be(3);                      }' TimeSpan.FromSeconds(10));                      AwaitAssert(() =>                      {                          Cluster.Get(seed1System.Value)                              .ReadView.Members.All(c => c.Status == MemberStatus.Up)                              .Should()                              .BeTrue();                      });                  }' _config.Seed1);                  RunOn(() =>                  {                      Cluster.JoinSeedNodes(GetSeedNodes());                      AwaitMembersUp(3);                  }' _config.Seed2' _config.Seed3);                  EnterBarrier("started");                    // shutdown seed1System                  RunOn(() =>                  {                      Shutdown(seed1System.Value' RemainingOrDefault);                  }' _config.Seed1);                  EnterBarrier("seed1-shutdown");                    RunOn(() =>                  {                      Cluster.Get(restartedSeed1System.Value).JoinSeedNodes(GetSeedNodes());                      Within(TimeSpan.FromSeconds(20)' () =>                      {                          AwaitAssert(() =>                          {                              Cluster.Get(restartedSeed1System.Value)                                  .ReadView.Members.Count                                  .Should()                                  .Be(3);                          });                          AwaitAssert(() =>                          {                              Cluster.Get(restartedSeed1System.Value)                                  .ReadView.Members.All(c => c.Status == MemberStatus.Up)                                  .Should()                                  .BeTrue();                          });                      });                  }' _config.Seed1);                    RunOn(() =>                  {                      AwaitMembersUp(3);                  }' _config.Seed2' _config.Seed3);                  EnterBarrier("seed1-restarted");              });
Magic Number,Akka.Cluster.Tests.MultiNode,RestartFirstSeedNodeSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartFirstSeedNodeSpec.cs,Cluster_seed_nodes__must_be_able_to_restart_first_seed_node_and_join_other_seed_nodes,The following statement contains a magic number: Within(TimeSpan.FromSeconds(40)' () =>              {                  RunOn(() =>                  {                      Sys.ActorOf(Props.Create(() => new Listener())                          .WithDeploy(Deploy.Local)' "address-receiver");                        EnterBarrier("seed1-address-receiver-ready");                  }' _config.Seed2' _config.Seed3);                    RunOn(() =>                  {                      EnterBarrier("seed1-address-receiver-ready");                      _seedNode1Address = Cluster.Get(seed1System.Value).SelfAddress;                      foreach (var r in new List<RoleName> { _config.Seed2' _config.Seed3 })                      {                          Sys.ActorSelection(new RootActorPath(GetAddress(r)) / "user" / "address-receiver").Tell(_seedNode1Address);                          ExpectMsg("ok"' TimeSpan.FromSeconds(5));                      }                  }' _config.Seed1);                  EnterBarrier("seed1-address-transfered");                    // now we can join seed1System' seed2' seed3 together                  RunOn(() =>                  {                      Cluster.Get(seed1System.Value).JoinSeedNodes(GetSeedNodes());                      AwaitAssert(() =>                      {                          Cluster.Get(seed1System.Value)                              .ReadView.Members.Count                              .Should()                              .Be(3);                      }' TimeSpan.FromSeconds(10));                      AwaitAssert(() =>                      {                          Cluster.Get(seed1System.Value)                              .ReadView.Members.All(c => c.Status == MemberStatus.Up)                              .Should()                              .BeTrue();                      });                  }' _config.Seed1);                  RunOn(() =>                  {                      Cluster.JoinSeedNodes(GetSeedNodes());                      AwaitMembersUp(3);                  }' _config.Seed2' _config.Seed3);                  EnterBarrier("started");                    // shutdown seed1System                  RunOn(() =>                  {                      Shutdown(seed1System.Value' RemainingOrDefault);                  }' _config.Seed1);                  EnterBarrier("seed1-shutdown");                    RunOn(() =>                  {                      Cluster.Get(restartedSeed1System.Value).JoinSeedNodes(GetSeedNodes());                      Within(TimeSpan.FromSeconds(20)' () =>                      {                          AwaitAssert(() =>                          {                              Cluster.Get(restartedSeed1System.Value)                                  .ReadView.Members.Count                                  .Should()                                  .Be(3);                          });                          AwaitAssert(() =>                          {                              Cluster.Get(restartedSeed1System.Value)                                  .ReadView.Members.All(c => c.Status == MemberStatus.Up)                                  .Should()                                  .BeTrue();                          });                      });                  }' _config.Seed1);                    RunOn(() =>                  {                      AwaitMembersUp(3);                  }' _config.Seed2' _config.Seed3);                  EnterBarrier("seed1-restarted");              });
Magic Number,Akka.Cluster.Tests.MultiNode,RestartFirstSeedNodeSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartFirstSeedNodeSpec.cs,Cluster_seed_nodes__must_be_able_to_restart_first_seed_node_and_join_other_seed_nodes,The following statement contains a magic number: Within(TimeSpan.FromSeconds(40)' () =>              {                  RunOn(() =>                  {                      Sys.ActorOf(Props.Create(() => new Listener())                          .WithDeploy(Deploy.Local)' "address-receiver");                        EnterBarrier("seed1-address-receiver-ready");                  }' _config.Seed2' _config.Seed3);                    RunOn(() =>                  {                      EnterBarrier("seed1-address-receiver-ready");                      _seedNode1Address = Cluster.Get(seed1System.Value).SelfAddress;                      foreach (var r in new List<RoleName> { _config.Seed2' _config.Seed3 })                      {                          Sys.ActorSelection(new RootActorPath(GetAddress(r)) / "user" / "address-receiver").Tell(_seedNode1Address);                          ExpectMsg("ok"' TimeSpan.FromSeconds(5));                      }                  }' _config.Seed1);                  EnterBarrier("seed1-address-transfered");                    // now we can join seed1System' seed2' seed3 together                  RunOn(() =>                  {                      Cluster.Get(seed1System.Value).JoinSeedNodes(GetSeedNodes());                      AwaitAssert(() =>                      {                          Cluster.Get(seed1System.Value)                              .ReadView.Members.Count                              .Should()                              .Be(3);                      }' TimeSpan.FromSeconds(10));                      AwaitAssert(() =>                      {                          Cluster.Get(seed1System.Value)                              .ReadView.Members.All(c => c.Status == MemberStatus.Up)                              .Should()                              .BeTrue();                      });                  }' _config.Seed1);                  RunOn(() =>                  {                      Cluster.JoinSeedNodes(GetSeedNodes());                      AwaitMembersUp(3);                  }' _config.Seed2' _config.Seed3);                  EnterBarrier("started");                    // shutdown seed1System                  RunOn(() =>                  {                      Shutdown(seed1System.Value' RemainingOrDefault);                  }' _config.Seed1);                  EnterBarrier("seed1-shutdown");                    RunOn(() =>                  {                      Cluster.Get(restartedSeed1System.Value).JoinSeedNodes(GetSeedNodes());                      Within(TimeSpan.FromSeconds(20)' () =>                      {                          AwaitAssert(() =>                          {                              Cluster.Get(restartedSeed1System.Value)                                  .ReadView.Members.Count                                  .Should()                                  .Be(3);                          });                          AwaitAssert(() =>                          {                              Cluster.Get(restartedSeed1System.Value)                                  .ReadView.Members.All(c => c.Status == MemberStatus.Up)                                  .Should()                                  .BeTrue();                          });                      });                  }' _config.Seed1);                    RunOn(() =>                  {                      AwaitMembersUp(3);                  }' _config.Seed2' _config.Seed3);                  EnterBarrier("seed1-restarted");              });
Magic Number,Akka.Cluster.Tests.MultiNode,RestartFirstSeedNodeSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartFirstSeedNodeSpec.cs,Cluster_seed_nodes__must_be_able_to_restart_first_seed_node_and_join_other_seed_nodes,The following statement contains a magic number: Within(TimeSpan.FromSeconds(40)' () =>              {                  RunOn(() =>                  {                      Sys.ActorOf(Props.Create(() => new Listener())                          .WithDeploy(Deploy.Local)' "address-receiver");                        EnterBarrier("seed1-address-receiver-ready");                  }' _config.Seed2' _config.Seed3);                    RunOn(() =>                  {                      EnterBarrier("seed1-address-receiver-ready");                      _seedNode1Address = Cluster.Get(seed1System.Value).SelfAddress;                      foreach (var r in new List<RoleName> { _config.Seed2' _config.Seed3 })                      {                          Sys.ActorSelection(new RootActorPath(GetAddress(r)) / "user" / "address-receiver").Tell(_seedNode1Address);                          ExpectMsg("ok"' TimeSpan.FromSeconds(5));                      }                  }' _config.Seed1);                  EnterBarrier("seed1-address-transfered");                    // now we can join seed1System' seed2' seed3 together                  RunOn(() =>                  {                      Cluster.Get(seed1System.Value).JoinSeedNodes(GetSeedNodes());                      AwaitAssert(() =>                      {                          Cluster.Get(seed1System.Value)                              .ReadView.Members.Count                              .Should()                              .Be(3);                      }' TimeSpan.FromSeconds(10));                      AwaitAssert(() =>                      {                          Cluster.Get(seed1System.Value)                              .ReadView.Members.All(c => c.Status == MemberStatus.Up)                              .Should()                              .BeTrue();                      });                  }' _config.Seed1);                  RunOn(() =>                  {                      Cluster.JoinSeedNodes(GetSeedNodes());                      AwaitMembersUp(3);                  }' _config.Seed2' _config.Seed3);                  EnterBarrier("started");                    // shutdown seed1System                  RunOn(() =>                  {                      Shutdown(seed1System.Value' RemainingOrDefault);                  }' _config.Seed1);                  EnterBarrier("seed1-shutdown");                    RunOn(() =>                  {                      Cluster.Get(restartedSeed1System.Value).JoinSeedNodes(GetSeedNodes());                      Within(TimeSpan.FromSeconds(20)' () =>                      {                          AwaitAssert(() =>                          {                              Cluster.Get(restartedSeed1System.Value)                                  .ReadView.Members.Count                                  .Should()                                  .Be(3);                          });                          AwaitAssert(() =>                          {                              Cluster.Get(restartedSeed1System.Value)                                  .ReadView.Members.All(c => c.Status == MemberStatus.Up)                                  .Should()                                  .BeTrue();                          });                      });                  }' _config.Seed1);                    RunOn(() =>                  {                      AwaitMembersUp(3);                  }' _config.Seed2' _config.Seed3);                  EnterBarrier("seed1-restarted");              });
Magic Number,Akka.Cluster.Tests.MultiNode,RestartFirstSeedNodeSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartFirstSeedNodeSpec.cs,Cluster_seed_nodes__must_be_able_to_restart_first_seed_node_and_join_other_seed_nodes,The following statement contains a magic number: Within(TimeSpan.FromSeconds(40)' () =>              {                  RunOn(() =>                  {                      Sys.ActorOf(Props.Create(() => new Listener())                          .WithDeploy(Deploy.Local)' "address-receiver");                        EnterBarrier("seed1-address-receiver-ready");                  }' _config.Seed2' _config.Seed3);                    RunOn(() =>                  {                      EnterBarrier("seed1-address-receiver-ready");                      _seedNode1Address = Cluster.Get(seed1System.Value).SelfAddress;                      foreach (var r in new List<RoleName> { _config.Seed2' _config.Seed3 })                      {                          Sys.ActorSelection(new RootActorPath(GetAddress(r)) / "user" / "address-receiver").Tell(_seedNode1Address);                          ExpectMsg("ok"' TimeSpan.FromSeconds(5));                      }                  }' _config.Seed1);                  EnterBarrier("seed1-address-transfered");                    // now we can join seed1System' seed2' seed3 together                  RunOn(() =>                  {                      Cluster.Get(seed1System.Value).JoinSeedNodes(GetSeedNodes());                      AwaitAssert(() =>                      {                          Cluster.Get(seed1System.Value)                              .ReadView.Members.Count                              .Should()                              .Be(3);                      }' TimeSpan.FromSeconds(10));                      AwaitAssert(() =>                      {                          Cluster.Get(seed1System.Value)                              .ReadView.Members.All(c => c.Status == MemberStatus.Up)                              .Should()                              .BeTrue();                      });                  }' _config.Seed1);                  RunOn(() =>                  {                      Cluster.JoinSeedNodes(GetSeedNodes());                      AwaitMembersUp(3);                  }' _config.Seed2' _config.Seed3);                  EnterBarrier("started");                    // shutdown seed1System                  RunOn(() =>                  {                      Shutdown(seed1System.Value' RemainingOrDefault);                  }' _config.Seed1);                  EnterBarrier("seed1-shutdown");                    RunOn(() =>                  {                      Cluster.Get(restartedSeed1System.Value).JoinSeedNodes(GetSeedNodes());                      Within(TimeSpan.FromSeconds(20)' () =>                      {                          AwaitAssert(() =>                          {                              Cluster.Get(restartedSeed1System.Value)                                  .ReadView.Members.Count                                  .Should()                                  .Be(3);                          });                          AwaitAssert(() =>                          {                              Cluster.Get(restartedSeed1System.Value)                                  .ReadView.Members.All(c => c.Status == MemberStatus.Up)                                  .Should()                                  .BeTrue();                          });                      });                  }' _config.Seed1);                    RunOn(() =>                  {                      AwaitMembersUp(3);                  }' _config.Seed2' _config.Seed3);                  EnterBarrier("seed1-restarted");              });
Magic Number,Akka.Cluster.Tests.MultiNode,RestartFirstSeedNodeSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartFirstSeedNodeSpec.cs,Cluster_seed_nodes__must_be_able_to_restart_first_seed_node_and_join_other_seed_nodes,The following statement contains a magic number: Within(TimeSpan.FromSeconds(40)' () =>              {                  RunOn(() =>                  {                      Sys.ActorOf(Props.Create(() => new Listener())                          .WithDeploy(Deploy.Local)' "address-receiver");                        EnterBarrier("seed1-address-receiver-ready");                  }' _config.Seed2' _config.Seed3);                    RunOn(() =>                  {                      EnterBarrier("seed1-address-receiver-ready");                      _seedNode1Address = Cluster.Get(seed1System.Value).SelfAddress;                      foreach (var r in new List<RoleName> { _config.Seed2' _config.Seed3 })                      {                          Sys.ActorSelection(new RootActorPath(GetAddress(r)) / "user" / "address-receiver").Tell(_seedNode1Address);                          ExpectMsg("ok"' TimeSpan.FromSeconds(5));                      }                  }' _config.Seed1);                  EnterBarrier("seed1-address-transfered");                    // now we can join seed1System' seed2' seed3 together                  RunOn(() =>                  {                      Cluster.Get(seed1System.Value).JoinSeedNodes(GetSeedNodes());                      AwaitAssert(() =>                      {                          Cluster.Get(seed1System.Value)                              .ReadView.Members.Count                              .Should()                              .Be(3);                      }' TimeSpan.FromSeconds(10));                      AwaitAssert(() =>                      {                          Cluster.Get(seed1System.Value)                              .ReadView.Members.All(c => c.Status == MemberStatus.Up)                              .Should()                              .BeTrue();                      });                  }' _config.Seed1);                  RunOn(() =>                  {                      Cluster.JoinSeedNodes(GetSeedNodes());                      AwaitMembersUp(3);                  }' _config.Seed2' _config.Seed3);                  EnterBarrier("started");                    // shutdown seed1System                  RunOn(() =>                  {                      Shutdown(seed1System.Value' RemainingOrDefault);                  }' _config.Seed1);                  EnterBarrier("seed1-shutdown");                    RunOn(() =>                  {                      Cluster.Get(restartedSeed1System.Value).JoinSeedNodes(GetSeedNodes());                      Within(TimeSpan.FromSeconds(20)' () =>                      {                          AwaitAssert(() =>                          {                              Cluster.Get(restartedSeed1System.Value)                                  .ReadView.Members.Count                                  .Should()                                  .Be(3);                          });                          AwaitAssert(() =>                          {                              Cluster.Get(restartedSeed1System.Value)                                  .ReadView.Members.All(c => c.Status == MemberStatus.Up)                                  .Should()                                  .BeTrue();                          });                      });                  }' _config.Seed1);                    RunOn(() =>                  {                      AwaitMembersUp(3);                  }' _config.Seed2' _config.Seed3);                  EnterBarrier("seed1-restarted");              });
Magic Number,Akka.Cluster.Tests.MultiNode,RestartNode2Spec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartNode2Spec.cs,Cluster_seed_nodes_must_be_able_to_restart_first_seed_node_and_join_other_seed_nodes,The following statement contains a magic number: Within(TimeSpan.FromSeconds(60)' () =>              {                  RunOn(() =>                  {                      // seed1System is a separate ActorSystem' to be able to simulate restart                      // we must transfer its address to seed2                      Sys.ActorOf(Props.Create<Watcher>().WithDeploy(Deploy.Local)' "address-receiver");                      EnterBarrier("seed1-address-receiver-ready");                  }' _config.Seed2);                      RunOn(() =>                  {                      EnterBarrier("seed1-address-receiver-ready");                      seedNode1Address = Cluster.Get(seed1System.Value).SelfAddress;                      foreach (var r in ImmutableList.Create(_config.Seed2))                      {                          Sys.ActorSelection(new RootActorPath(GetAddress(r)) / "user" / "address-receiver").Tell(seedNode1Address);                          ExpectMsg("ok"' TimeSpan.FromSeconds(5));                      }                  }' _config.Seed1);                  EnterBarrier("seed1-address-transfered");                    // now we can join seed1System' seed2 together                  RunOn(() =>                  {                      Cluster.Get(seed1System.Value).JoinSeedNodes(SeedNodes);                      AwaitAssert(() => Cluster.Get(seed1System.Value).ReadView.Members.Count.Should().Be(2));                      AwaitAssert(() => Cluster.Get(seed1System.Value).ReadView.Members.All(x => x.Status == MemberStatus.Up).Should().BeTrue());                  }' _config.Seed1);                    RunOn(() =>                  {                      Cluster.JoinSeedNodes(SeedNodes);                      AwaitMembersUp(2);                  }' _config.Seed2);                  EnterBarrier("started");                    // shutdown seed1System                  RunOn(() =>                  {                      Shutdown(seed1System.Value' RemainingOrDefault);                  }' _config.Seed1);                  EnterBarrier("seed1-shutdown");                    RunOn(() =>                  {                      Cluster.Get(restartedSeed1System.Value).JoinSeedNodes(SeedNodes);                      Within(TimeSpan.FromSeconds(30)' () =>                      {                          AwaitAssert(() => Cluster.Get(restartedSeed1System.Value).ReadView.Members.Count.Should().Be(2));                          AwaitAssert(() => Cluster.Get(restartedSeed1System.Value).ReadView.Members.All(x => x.Status == MemberStatus.Up).Should().BeTrue());                      });                  }' _config.Seed1);                    RunOn(() =>                  {                      AwaitMembersUp(2);                  }' _config.Seed2);                  EnterBarrier("seed1-restarted");              });
Magic Number,Akka.Cluster.Tests.MultiNode,RestartNode2Spec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartNode2Spec.cs,Cluster_seed_nodes_must_be_able_to_restart_first_seed_node_and_join_other_seed_nodes,The following statement contains a magic number: Within(TimeSpan.FromSeconds(60)' () =>              {                  RunOn(() =>                  {                      // seed1System is a separate ActorSystem' to be able to simulate restart                      // we must transfer its address to seed2                      Sys.ActorOf(Props.Create<Watcher>().WithDeploy(Deploy.Local)' "address-receiver");                      EnterBarrier("seed1-address-receiver-ready");                  }' _config.Seed2);                      RunOn(() =>                  {                      EnterBarrier("seed1-address-receiver-ready");                      seedNode1Address = Cluster.Get(seed1System.Value).SelfAddress;                      foreach (var r in ImmutableList.Create(_config.Seed2))                      {                          Sys.ActorSelection(new RootActorPath(GetAddress(r)) / "user" / "address-receiver").Tell(seedNode1Address);                          ExpectMsg("ok"' TimeSpan.FromSeconds(5));                      }                  }' _config.Seed1);                  EnterBarrier("seed1-address-transfered");                    // now we can join seed1System' seed2 together                  RunOn(() =>                  {                      Cluster.Get(seed1System.Value).JoinSeedNodes(SeedNodes);                      AwaitAssert(() => Cluster.Get(seed1System.Value).ReadView.Members.Count.Should().Be(2));                      AwaitAssert(() => Cluster.Get(seed1System.Value).ReadView.Members.All(x => x.Status == MemberStatus.Up).Should().BeTrue());                  }' _config.Seed1);                    RunOn(() =>                  {                      Cluster.JoinSeedNodes(SeedNodes);                      AwaitMembersUp(2);                  }' _config.Seed2);                  EnterBarrier("started");                    // shutdown seed1System                  RunOn(() =>                  {                      Shutdown(seed1System.Value' RemainingOrDefault);                  }' _config.Seed1);                  EnterBarrier("seed1-shutdown");                    RunOn(() =>                  {                      Cluster.Get(restartedSeed1System.Value).JoinSeedNodes(SeedNodes);                      Within(TimeSpan.FromSeconds(30)' () =>                      {                          AwaitAssert(() => Cluster.Get(restartedSeed1System.Value).ReadView.Members.Count.Should().Be(2));                          AwaitAssert(() => Cluster.Get(restartedSeed1System.Value).ReadView.Members.All(x => x.Status == MemberStatus.Up).Should().BeTrue());                      });                  }' _config.Seed1);                    RunOn(() =>                  {                      AwaitMembersUp(2);                  }' _config.Seed2);                  EnterBarrier("seed1-restarted");              });
Magic Number,Akka.Cluster.Tests.MultiNode,RestartNode2Spec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartNode2Spec.cs,Cluster_seed_nodes_must_be_able_to_restart_first_seed_node_and_join_other_seed_nodes,The following statement contains a magic number: Within(TimeSpan.FromSeconds(60)' () =>              {                  RunOn(() =>                  {                      // seed1System is a separate ActorSystem' to be able to simulate restart                      // we must transfer its address to seed2                      Sys.ActorOf(Props.Create<Watcher>().WithDeploy(Deploy.Local)' "address-receiver");                      EnterBarrier("seed1-address-receiver-ready");                  }' _config.Seed2);                      RunOn(() =>                  {                      EnterBarrier("seed1-address-receiver-ready");                      seedNode1Address = Cluster.Get(seed1System.Value).SelfAddress;                      foreach (var r in ImmutableList.Create(_config.Seed2))                      {                          Sys.ActorSelection(new RootActorPath(GetAddress(r)) / "user" / "address-receiver").Tell(seedNode1Address);                          ExpectMsg("ok"' TimeSpan.FromSeconds(5));                      }                  }' _config.Seed1);                  EnterBarrier("seed1-address-transfered");                    // now we can join seed1System' seed2 together                  RunOn(() =>                  {                      Cluster.Get(seed1System.Value).JoinSeedNodes(SeedNodes);                      AwaitAssert(() => Cluster.Get(seed1System.Value).ReadView.Members.Count.Should().Be(2));                      AwaitAssert(() => Cluster.Get(seed1System.Value).ReadView.Members.All(x => x.Status == MemberStatus.Up).Should().BeTrue());                  }' _config.Seed1);                    RunOn(() =>                  {                      Cluster.JoinSeedNodes(SeedNodes);                      AwaitMembersUp(2);                  }' _config.Seed2);                  EnterBarrier("started");                    // shutdown seed1System                  RunOn(() =>                  {                      Shutdown(seed1System.Value' RemainingOrDefault);                  }' _config.Seed1);                  EnterBarrier("seed1-shutdown");                    RunOn(() =>                  {                      Cluster.Get(restartedSeed1System.Value).JoinSeedNodes(SeedNodes);                      Within(TimeSpan.FromSeconds(30)' () =>                      {                          AwaitAssert(() => Cluster.Get(restartedSeed1System.Value).ReadView.Members.Count.Should().Be(2));                          AwaitAssert(() => Cluster.Get(restartedSeed1System.Value).ReadView.Members.All(x => x.Status == MemberStatus.Up).Should().BeTrue());                      });                  }' _config.Seed1);                    RunOn(() =>                  {                      AwaitMembersUp(2);                  }' _config.Seed2);                  EnterBarrier("seed1-restarted");              });
Magic Number,Akka.Cluster.Tests.MultiNode,RestartNode2Spec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartNode2Spec.cs,Cluster_seed_nodes_must_be_able_to_restart_first_seed_node_and_join_other_seed_nodes,The following statement contains a magic number: Within(TimeSpan.FromSeconds(60)' () =>              {                  RunOn(() =>                  {                      // seed1System is a separate ActorSystem' to be able to simulate restart                      // we must transfer its address to seed2                      Sys.ActorOf(Props.Create<Watcher>().WithDeploy(Deploy.Local)' "address-receiver");                      EnterBarrier("seed1-address-receiver-ready");                  }' _config.Seed2);                      RunOn(() =>                  {                      EnterBarrier("seed1-address-receiver-ready");                      seedNode1Address = Cluster.Get(seed1System.Value).SelfAddress;                      foreach (var r in ImmutableList.Create(_config.Seed2))                      {                          Sys.ActorSelection(new RootActorPath(GetAddress(r)) / "user" / "address-receiver").Tell(seedNode1Address);                          ExpectMsg("ok"' TimeSpan.FromSeconds(5));                      }                  }' _config.Seed1);                  EnterBarrier("seed1-address-transfered");                    // now we can join seed1System' seed2 together                  RunOn(() =>                  {                      Cluster.Get(seed1System.Value).JoinSeedNodes(SeedNodes);                      AwaitAssert(() => Cluster.Get(seed1System.Value).ReadView.Members.Count.Should().Be(2));                      AwaitAssert(() => Cluster.Get(seed1System.Value).ReadView.Members.All(x => x.Status == MemberStatus.Up).Should().BeTrue());                  }' _config.Seed1);                    RunOn(() =>                  {                      Cluster.JoinSeedNodes(SeedNodes);                      AwaitMembersUp(2);                  }' _config.Seed2);                  EnterBarrier("started");                    // shutdown seed1System                  RunOn(() =>                  {                      Shutdown(seed1System.Value' RemainingOrDefault);                  }' _config.Seed1);                  EnterBarrier("seed1-shutdown");                    RunOn(() =>                  {                      Cluster.Get(restartedSeed1System.Value).JoinSeedNodes(SeedNodes);                      Within(TimeSpan.FromSeconds(30)' () =>                      {                          AwaitAssert(() => Cluster.Get(restartedSeed1System.Value).ReadView.Members.Count.Should().Be(2));                          AwaitAssert(() => Cluster.Get(restartedSeed1System.Value).ReadView.Members.All(x => x.Status == MemberStatus.Up).Should().BeTrue());                      });                  }' _config.Seed1);                    RunOn(() =>                  {                      AwaitMembersUp(2);                  }' _config.Seed2);                  EnterBarrier("seed1-restarted");              });
Magic Number,Akka.Cluster.Tests.MultiNode,RestartNode2Spec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartNode2Spec.cs,Cluster_seed_nodes_must_be_able_to_restart_first_seed_node_and_join_other_seed_nodes,The following statement contains a magic number: Within(TimeSpan.FromSeconds(60)' () =>              {                  RunOn(() =>                  {                      // seed1System is a separate ActorSystem' to be able to simulate restart                      // we must transfer its address to seed2                      Sys.ActorOf(Props.Create<Watcher>().WithDeploy(Deploy.Local)' "address-receiver");                      EnterBarrier("seed1-address-receiver-ready");                  }' _config.Seed2);                      RunOn(() =>                  {                      EnterBarrier("seed1-address-receiver-ready");                      seedNode1Address = Cluster.Get(seed1System.Value).SelfAddress;                      foreach (var r in ImmutableList.Create(_config.Seed2))                      {                          Sys.ActorSelection(new RootActorPath(GetAddress(r)) / "user" / "address-receiver").Tell(seedNode1Address);                          ExpectMsg("ok"' TimeSpan.FromSeconds(5));                      }                  }' _config.Seed1);                  EnterBarrier("seed1-address-transfered");                    // now we can join seed1System' seed2 together                  RunOn(() =>                  {                      Cluster.Get(seed1System.Value).JoinSeedNodes(SeedNodes);                      AwaitAssert(() => Cluster.Get(seed1System.Value).ReadView.Members.Count.Should().Be(2));                      AwaitAssert(() => Cluster.Get(seed1System.Value).ReadView.Members.All(x => x.Status == MemberStatus.Up).Should().BeTrue());                  }' _config.Seed1);                    RunOn(() =>                  {                      Cluster.JoinSeedNodes(SeedNodes);                      AwaitMembersUp(2);                  }' _config.Seed2);                  EnterBarrier("started");                    // shutdown seed1System                  RunOn(() =>                  {                      Shutdown(seed1System.Value' RemainingOrDefault);                  }' _config.Seed1);                  EnterBarrier("seed1-shutdown");                    RunOn(() =>                  {                      Cluster.Get(restartedSeed1System.Value).JoinSeedNodes(SeedNodes);                      Within(TimeSpan.FromSeconds(30)' () =>                      {                          AwaitAssert(() => Cluster.Get(restartedSeed1System.Value).ReadView.Members.Count.Should().Be(2));                          AwaitAssert(() => Cluster.Get(restartedSeed1System.Value).ReadView.Members.All(x => x.Status == MemberStatus.Up).Should().BeTrue());                      });                  }' _config.Seed1);                    RunOn(() =>                  {                      AwaitMembersUp(2);                  }' _config.Seed2);                  EnterBarrier("seed1-restarted");              });
Magic Number,Akka.Cluster.Tests.MultiNode,RestartNode2Spec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartNode2Spec.cs,Cluster_seed_nodes_must_be_able_to_restart_first_seed_node_and_join_other_seed_nodes,The following statement contains a magic number: Within(TimeSpan.FromSeconds(60)' () =>              {                  RunOn(() =>                  {                      // seed1System is a separate ActorSystem' to be able to simulate restart                      // we must transfer its address to seed2                      Sys.ActorOf(Props.Create<Watcher>().WithDeploy(Deploy.Local)' "address-receiver");                      EnterBarrier("seed1-address-receiver-ready");                  }' _config.Seed2);                      RunOn(() =>                  {                      EnterBarrier("seed1-address-receiver-ready");                      seedNode1Address = Cluster.Get(seed1System.Value).SelfAddress;                      foreach (var r in ImmutableList.Create(_config.Seed2))                      {                          Sys.ActorSelection(new RootActorPath(GetAddress(r)) / "user" / "address-receiver").Tell(seedNode1Address);                          ExpectMsg("ok"' TimeSpan.FromSeconds(5));                      }                  }' _config.Seed1);                  EnterBarrier("seed1-address-transfered");                    // now we can join seed1System' seed2 together                  RunOn(() =>                  {                      Cluster.Get(seed1System.Value).JoinSeedNodes(SeedNodes);                      AwaitAssert(() => Cluster.Get(seed1System.Value).ReadView.Members.Count.Should().Be(2));                      AwaitAssert(() => Cluster.Get(seed1System.Value).ReadView.Members.All(x => x.Status == MemberStatus.Up).Should().BeTrue());                  }' _config.Seed1);                    RunOn(() =>                  {                      Cluster.JoinSeedNodes(SeedNodes);                      AwaitMembersUp(2);                  }' _config.Seed2);                  EnterBarrier("started");                    // shutdown seed1System                  RunOn(() =>                  {                      Shutdown(seed1System.Value' RemainingOrDefault);                  }' _config.Seed1);                  EnterBarrier("seed1-shutdown");                    RunOn(() =>                  {                      Cluster.Get(restartedSeed1System.Value).JoinSeedNodes(SeedNodes);                      Within(TimeSpan.FromSeconds(30)' () =>                      {                          AwaitAssert(() => Cluster.Get(restartedSeed1System.Value).ReadView.Members.Count.Should().Be(2));                          AwaitAssert(() => Cluster.Get(restartedSeed1System.Value).ReadView.Members.All(x => x.Status == MemberStatus.Up).Should().BeTrue());                      });                  }' _config.Seed1);                    RunOn(() =>                  {                      AwaitMembersUp(2);                  }' _config.Seed2);                  EnterBarrier("seed1-restarted");              });
Magic Number,Akka.Cluster.Tests.MultiNode,RestartNode2Spec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartNode2Spec.cs,Cluster_seed_nodes_must_be_able_to_restart_first_seed_node_and_join_other_seed_nodes,The following statement contains a magic number: Within(TimeSpan.FromSeconds(60)' () =>              {                  RunOn(() =>                  {                      // seed1System is a separate ActorSystem' to be able to simulate restart                      // we must transfer its address to seed2                      Sys.ActorOf(Props.Create<Watcher>().WithDeploy(Deploy.Local)' "address-receiver");                      EnterBarrier("seed1-address-receiver-ready");                  }' _config.Seed2);                      RunOn(() =>                  {                      EnterBarrier("seed1-address-receiver-ready");                      seedNode1Address = Cluster.Get(seed1System.Value).SelfAddress;                      foreach (var r in ImmutableList.Create(_config.Seed2))                      {                          Sys.ActorSelection(new RootActorPath(GetAddress(r)) / "user" / "address-receiver").Tell(seedNode1Address);                          ExpectMsg("ok"' TimeSpan.FromSeconds(5));                      }                  }' _config.Seed1);                  EnterBarrier("seed1-address-transfered");                    // now we can join seed1System' seed2 together                  RunOn(() =>                  {                      Cluster.Get(seed1System.Value).JoinSeedNodes(SeedNodes);                      AwaitAssert(() => Cluster.Get(seed1System.Value).ReadView.Members.Count.Should().Be(2));                      AwaitAssert(() => Cluster.Get(seed1System.Value).ReadView.Members.All(x => x.Status == MemberStatus.Up).Should().BeTrue());                  }' _config.Seed1);                    RunOn(() =>                  {                      Cluster.JoinSeedNodes(SeedNodes);                      AwaitMembersUp(2);                  }' _config.Seed2);                  EnterBarrier("started");                    // shutdown seed1System                  RunOn(() =>                  {                      Shutdown(seed1System.Value' RemainingOrDefault);                  }' _config.Seed1);                  EnterBarrier("seed1-shutdown");                    RunOn(() =>                  {                      Cluster.Get(restartedSeed1System.Value).JoinSeedNodes(SeedNodes);                      Within(TimeSpan.FromSeconds(30)' () =>                      {                          AwaitAssert(() => Cluster.Get(restartedSeed1System.Value).ReadView.Members.Count.Should().Be(2));                          AwaitAssert(() => Cluster.Get(restartedSeed1System.Value).ReadView.Members.All(x => x.Status == MemberStatus.Up).Should().BeTrue());                      });                  }' _config.Seed1);                    RunOn(() =>                  {                      AwaitMembersUp(2);                  }' _config.Seed2);                  EnterBarrier("seed1-restarted");              });
Magic Number,Akka.Cluster.Tests.MultiNode,RestartNode3Spec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartNode3Spec.cs,Cluster_nodes_must_be_able_to_restart_and_join_again_when_down_before_up,The following statement contains a magic number: Within(TimeSpan.FromSeconds(60)' () =>              {                  // secondSystem is a separate ActorSystem' to be able to simulate restart                  // we must transfer its address to first                  RunOn(() =>                  {                      Sys.ActorOf(Props.Create<Watcher>().WithDeploy(Deploy.Local)' "address-receiver");                      EnterBarrier("second-address-receiver-ready");                  }' _config.First' _config.Third);                    RunOn(() =>                  {                      EnterBarrier("second-address-receiver-ready");                      secondUniqueAddress = Cluster.Get(secondSystem.Value).SelfUniqueAddress;                      foreach (var r in ImmutableList.Create(_config.First' _config.Third))                      {                          Sys.ActorSelection(new RootActorPath(GetAddress(r)) / "user" / "address-receiver")                              .Tell(secondUniqueAddress);                          ExpectMsg("ok"' TimeSpan.FromSeconds(5));                      }                  }' _config.Second);                  EnterBarrier("second-address-transfered");                    // now we can join first' third together                  RunOn(() =>                  {                      Cluster.JoinSeedNodes(seedNodes);                      AwaitMembersUp(2);                  }' _config.First' _config.Third);                  EnterBarrier("first-third-up");                    // make third unreachable' so that leader can't perform its duties                  RunOn(() =>                  {                      TestConductor.Blackhole(_config.First' _config.Third' ThrottleTransportAdapter.Direction.Both)                          .Wait();                      var thirdAddress = GetAddress(_config.Third);                      AwaitAssert(() => ClusterView.UnreachableMembers.Select(c => c.Address)                          .Should().BeEquivalentTo(thirdAddress));                  }' _config.First);                  EnterBarrier("third-unreachable");                    RunOn(() =>                  {                      Cluster.Get(secondSystem.Value).JoinSeedNodes(seedNodes);                      AwaitAssert(() => Cluster.Get(secondSystem.Value).ReadView.Members.Should().HaveCount(3));                      AwaitAssert(() => Cluster.Get(secondSystem.Value).ReadView                          .Members                          .Where(m => m.Address == Cluster.Get(secondSystem.Value).SelfAddress)                          .Select(c => c.Status)                          .First()                          .Should().Be(MemberStatus.Joining));                  }' _config.Second);                  EnterBarrier("second-joined");                    // shutdown secondSystem                  RunOn(() =>                  {                      Shutdown(secondSystem.Value' Remaining);                  }' _config.Second);                  EnterBarrier("second-shutdown");                    // then immediately start restartedSecondSystem' which has the same address as secondSystem                  RunOn(() =>                  {                      TestConductor.PassThrough(_config.First' _config.Third' ThrottleTransportAdapter.Direction.Both)                          .Wait();                  }' _config.First);                    RunOn(() =>                  {                      Cluster.Get(restartedSecondSystem.Value).JoinSeedNodes(seedNodes);                      AwaitAssert(() => Cluster.Get(restartedSecondSystem.Value).ReadView.Members.Should().HaveCount(3));                      AwaitAssert(() => Cluster.Get(restartedSecondSystem.Value).ReadView                          .Members                          .All(c => c.Status == MemberStatus.Up)                          .Should().BeTrue());                  }' _config.Second);                    RunOn(() =>                  {                      AwaitAssert(() => Cluster.Get(Sys).ReadView.Members.Should().HaveCount(3));                      AwaitAssert(() => Cluster.Get(Sys).ReadView                          .Members                          .Count(                              m =>                                  m.Address == secondUniqueAddress.Address &&                                  m.UniqueAddress.Uid != secondUniqueAddress.Uid).Should().BeGreaterThan(0)                          );                  }' _config.First' _config.Third);                  EnterBarrier("second-restarted");              });
Magic Number,Akka.Cluster.Tests.MultiNode,RestartNode3Spec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartNode3Spec.cs,Cluster_nodes_must_be_able_to_restart_and_join_again_when_down_before_up,The following statement contains a magic number: Within(TimeSpan.FromSeconds(60)' () =>              {                  // secondSystem is a separate ActorSystem' to be able to simulate restart                  // we must transfer its address to first                  RunOn(() =>                  {                      Sys.ActorOf(Props.Create<Watcher>().WithDeploy(Deploy.Local)' "address-receiver");                      EnterBarrier("second-address-receiver-ready");                  }' _config.First' _config.Third);                    RunOn(() =>                  {                      EnterBarrier("second-address-receiver-ready");                      secondUniqueAddress = Cluster.Get(secondSystem.Value).SelfUniqueAddress;                      foreach (var r in ImmutableList.Create(_config.First' _config.Third))                      {                          Sys.ActorSelection(new RootActorPath(GetAddress(r)) / "user" / "address-receiver")                              .Tell(secondUniqueAddress);                          ExpectMsg("ok"' TimeSpan.FromSeconds(5));                      }                  }' _config.Second);                  EnterBarrier("second-address-transfered");                    // now we can join first' third together                  RunOn(() =>                  {                      Cluster.JoinSeedNodes(seedNodes);                      AwaitMembersUp(2);                  }' _config.First' _config.Third);                  EnterBarrier("first-third-up");                    // make third unreachable' so that leader can't perform its duties                  RunOn(() =>                  {                      TestConductor.Blackhole(_config.First' _config.Third' ThrottleTransportAdapter.Direction.Both)                          .Wait();                      var thirdAddress = GetAddress(_config.Third);                      AwaitAssert(() => ClusterView.UnreachableMembers.Select(c => c.Address)                          .Should().BeEquivalentTo(thirdAddress));                  }' _config.First);                  EnterBarrier("third-unreachable");                    RunOn(() =>                  {                      Cluster.Get(secondSystem.Value).JoinSeedNodes(seedNodes);                      AwaitAssert(() => Cluster.Get(secondSystem.Value).ReadView.Members.Should().HaveCount(3));                      AwaitAssert(() => Cluster.Get(secondSystem.Value).ReadView                          .Members                          .Where(m => m.Address == Cluster.Get(secondSystem.Value).SelfAddress)                          .Select(c => c.Status)                          .First()                          .Should().Be(MemberStatus.Joining));                  }' _config.Second);                  EnterBarrier("second-joined");                    // shutdown secondSystem                  RunOn(() =>                  {                      Shutdown(secondSystem.Value' Remaining);                  }' _config.Second);                  EnterBarrier("second-shutdown");                    // then immediately start restartedSecondSystem' which has the same address as secondSystem                  RunOn(() =>                  {                      TestConductor.PassThrough(_config.First' _config.Third' ThrottleTransportAdapter.Direction.Both)                          .Wait();                  }' _config.First);                    RunOn(() =>                  {                      Cluster.Get(restartedSecondSystem.Value).JoinSeedNodes(seedNodes);                      AwaitAssert(() => Cluster.Get(restartedSecondSystem.Value).ReadView.Members.Should().HaveCount(3));                      AwaitAssert(() => Cluster.Get(restartedSecondSystem.Value).ReadView                          .Members                          .All(c => c.Status == MemberStatus.Up)                          .Should().BeTrue());                  }' _config.Second);                    RunOn(() =>                  {                      AwaitAssert(() => Cluster.Get(Sys).ReadView.Members.Should().HaveCount(3));                      AwaitAssert(() => Cluster.Get(Sys).ReadView                          .Members                          .Count(                              m =>                                  m.Address == secondUniqueAddress.Address &&                                  m.UniqueAddress.Uid != secondUniqueAddress.Uid).Should().BeGreaterThan(0)                          );                  }' _config.First' _config.Third);                  EnterBarrier("second-restarted");              });
Magic Number,Akka.Cluster.Tests.MultiNode,RestartNode3Spec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartNode3Spec.cs,Cluster_nodes_must_be_able_to_restart_and_join_again_when_down_before_up,The following statement contains a magic number: Within(TimeSpan.FromSeconds(60)' () =>              {                  // secondSystem is a separate ActorSystem' to be able to simulate restart                  // we must transfer its address to first                  RunOn(() =>                  {                      Sys.ActorOf(Props.Create<Watcher>().WithDeploy(Deploy.Local)' "address-receiver");                      EnterBarrier("second-address-receiver-ready");                  }' _config.First' _config.Third);                    RunOn(() =>                  {                      EnterBarrier("second-address-receiver-ready");                      secondUniqueAddress = Cluster.Get(secondSystem.Value).SelfUniqueAddress;                      foreach (var r in ImmutableList.Create(_config.First' _config.Third))                      {                          Sys.ActorSelection(new RootActorPath(GetAddress(r)) / "user" / "address-receiver")                              .Tell(secondUniqueAddress);                          ExpectMsg("ok"' TimeSpan.FromSeconds(5));                      }                  }' _config.Second);                  EnterBarrier("second-address-transfered");                    // now we can join first' third together                  RunOn(() =>                  {                      Cluster.JoinSeedNodes(seedNodes);                      AwaitMembersUp(2);                  }' _config.First' _config.Third);                  EnterBarrier("first-third-up");                    // make third unreachable' so that leader can't perform its duties                  RunOn(() =>                  {                      TestConductor.Blackhole(_config.First' _config.Third' ThrottleTransportAdapter.Direction.Both)                          .Wait();                      var thirdAddress = GetAddress(_config.Third);                      AwaitAssert(() => ClusterView.UnreachableMembers.Select(c => c.Address)                          .Should().BeEquivalentTo(thirdAddress));                  }' _config.First);                  EnterBarrier("third-unreachable");                    RunOn(() =>                  {                      Cluster.Get(secondSystem.Value).JoinSeedNodes(seedNodes);                      AwaitAssert(() => Cluster.Get(secondSystem.Value).ReadView.Members.Should().HaveCount(3));                      AwaitAssert(() => Cluster.Get(secondSystem.Value).ReadView                          .Members                          .Where(m => m.Address == Cluster.Get(secondSystem.Value).SelfAddress)                          .Select(c => c.Status)                          .First()                          .Should().Be(MemberStatus.Joining));                  }' _config.Second);                  EnterBarrier("second-joined");                    // shutdown secondSystem                  RunOn(() =>                  {                      Shutdown(secondSystem.Value' Remaining);                  }' _config.Second);                  EnterBarrier("second-shutdown");                    // then immediately start restartedSecondSystem' which has the same address as secondSystem                  RunOn(() =>                  {                      TestConductor.PassThrough(_config.First' _config.Third' ThrottleTransportAdapter.Direction.Both)                          .Wait();                  }' _config.First);                    RunOn(() =>                  {                      Cluster.Get(restartedSecondSystem.Value).JoinSeedNodes(seedNodes);                      AwaitAssert(() => Cluster.Get(restartedSecondSystem.Value).ReadView.Members.Should().HaveCount(3));                      AwaitAssert(() => Cluster.Get(restartedSecondSystem.Value).ReadView                          .Members                          .All(c => c.Status == MemberStatus.Up)                          .Should().BeTrue());                  }' _config.Second);                    RunOn(() =>                  {                      AwaitAssert(() => Cluster.Get(Sys).ReadView.Members.Should().HaveCount(3));                      AwaitAssert(() => Cluster.Get(Sys).ReadView                          .Members                          .Count(                              m =>                                  m.Address == secondUniqueAddress.Address &&                                  m.UniqueAddress.Uid != secondUniqueAddress.Uid).Should().BeGreaterThan(0)                          );                  }' _config.First' _config.Third);                  EnterBarrier("second-restarted");              });
Magic Number,Akka.Cluster.Tests.MultiNode,RestartNode3Spec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartNode3Spec.cs,Cluster_nodes_must_be_able_to_restart_and_join_again_when_down_before_up,The following statement contains a magic number: Within(TimeSpan.FromSeconds(60)' () =>              {                  // secondSystem is a separate ActorSystem' to be able to simulate restart                  // we must transfer its address to first                  RunOn(() =>                  {                      Sys.ActorOf(Props.Create<Watcher>().WithDeploy(Deploy.Local)' "address-receiver");                      EnterBarrier("second-address-receiver-ready");                  }' _config.First' _config.Third);                    RunOn(() =>                  {                      EnterBarrier("second-address-receiver-ready");                      secondUniqueAddress = Cluster.Get(secondSystem.Value).SelfUniqueAddress;                      foreach (var r in ImmutableList.Create(_config.First' _config.Third))                      {                          Sys.ActorSelection(new RootActorPath(GetAddress(r)) / "user" / "address-receiver")                              .Tell(secondUniqueAddress);                          ExpectMsg("ok"' TimeSpan.FromSeconds(5));                      }                  }' _config.Second);                  EnterBarrier("second-address-transfered");                    // now we can join first' third together                  RunOn(() =>                  {                      Cluster.JoinSeedNodes(seedNodes);                      AwaitMembersUp(2);                  }' _config.First' _config.Third);                  EnterBarrier("first-third-up");                    // make third unreachable' so that leader can't perform its duties                  RunOn(() =>                  {                      TestConductor.Blackhole(_config.First' _config.Third' ThrottleTransportAdapter.Direction.Both)                          .Wait();                      var thirdAddress = GetAddress(_config.Third);                      AwaitAssert(() => ClusterView.UnreachableMembers.Select(c => c.Address)                          .Should().BeEquivalentTo(thirdAddress));                  }' _config.First);                  EnterBarrier("third-unreachable");                    RunOn(() =>                  {                      Cluster.Get(secondSystem.Value).JoinSeedNodes(seedNodes);                      AwaitAssert(() => Cluster.Get(secondSystem.Value).ReadView.Members.Should().HaveCount(3));                      AwaitAssert(() => Cluster.Get(secondSystem.Value).ReadView                          .Members                          .Where(m => m.Address == Cluster.Get(secondSystem.Value).SelfAddress)                          .Select(c => c.Status)                          .First()                          .Should().Be(MemberStatus.Joining));                  }' _config.Second);                  EnterBarrier("second-joined");                    // shutdown secondSystem                  RunOn(() =>                  {                      Shutdown(secondSystem.Value' Remaining);                  }' _config.Second);                  EnterBarrier("second-shutdown");                    // then immediately start restartedSecondSystem' which has the same address as secondSystem                  RunOn(() =>                  {                      TestConductor.PassThrough(_config.First' _config.Third' ThrottleTransportAdapter.Direction.Both)                          .Wait();                  }' _config.First);                    RunOn(() =>                  {                      Cluster.Get(restartedSecondSystem.Value).JoinSeedNodes(seedNodes);                      AwaitAssert(() => Cluster.Get(restartedSecondSystem.Value).ReadView.Members.Should().HaveCount(3));                      AwaitAssert(() => Cluster.Get(restartedSecondSystem.Value).ReadView                          .Members                          .All(c => c.Status == MemberStatus.Up)                          .Should().BeTrue());                  }' _config.Second);                    RunOn(() =>                  {                      AwaitAssert(() => Cluster.Get(Sys).ReadView.Members.Should().HaveCount(3));                      AwaitAssert(() => Cluster.Get(Sys).ReadView                          .Members                          .Count(                              m =>                                  m.Address == secondUniqueAddress.Address &&                                  m.UniqueAddress.Uid != secondUniqueAddress.Uid).Should().BeGreaterThan(0)                          );                  }' _config.First' _config.Third);                  EnterBarrier("second-restarted");              });
Magic Number,Akka.Cluster.Tests.MultiNode,RestartNode3Spec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartNode3Spec.cs,Cluster_nodes_must_be_able_to_restart_and_join_again_when_down_before_up,The following statement contains a magic number: Within(TimeSpan.FromSeconds(60)' () =>              {                  // secondSystem is a separate ActorSystem' to be able to simulate restart                  // we must transfer its address to first                  RunOn(() =>                  {                      Sys.ActorOf(Props.Create<Watcher>().WithDeploy(Deploy.Local)' "address-receiver");                      EnterBarrier("second-address-receiver-ready");                  }' _config.First' _config.Third);                    RunOn(() =>                  {                      EnterBarrier("second-address-receiver-ready");                      secondUniqueAddress = Cluster.Get(secondSystem.Value).SelfUniqueAddress;                      foreach (var r in ImmutableList.Create(_config.First' _config.Third))                      {                          Sys.ActorSelection(new RootActorPath(GetAddress(r)) / "user" / "address-receiver")                              .Tell(secondUniqueAddress);                          ExpectMsg("ok"' TimeSpan.FromSeconds(5));                      }                  }' _config.Second);                  EnterBarrier("second-address-transfered");                    // now we can join first' third together                  RunOn(() =>                  {                      Cluster.JoinSeedNodes(seedNodes);                      AwaitMembersUp(2);                  }' _config.First' _config.Third);                  EnterBarrier("first-third-up");                    // make third unreachable' so that leader can't perform its duties                  RunOn(() =>                  {                      TestConductor.Blackhole(_config.First' _config.Third' ThrottleTransportAdapter.Direction.Both)                          .Wait();                      var thirdAddress = GetAddress(_config.Third);                      AwaitAssert(() => ClusterView.UnreachableMembers.Select(c => c.Address)                          .Should().BeEquivalentTo(thirdAddress));                  }' _config.First);                  EnterBarrier("third-unreachable");                    RunOn(() =>                  {                      Cluster.Get(secondSystem.Value).JoinSeedNodes(seedNodes);                      AwaitAssert(() => Cluster.Get(secondSystem.Value).ReadView.Members.Should().HaveCount(3));                      AwaitAssert(() => Cluster.Get(secondSystem.Value).ReadView                          .Members                          .Where(m => m.Address == Cluster.Get(secondSystem.Value).SelfAddress)                          .Select(c => c.Status)                          .First()                          .Should().Be(MemberStatus.Joining));                  }' _config.Second);                  EnterBarrier("second-joined");                    // shutdown secondSystem                  RunOn(() =>                  {                      Shutdown(secondSystem.Value' Remaining);                  }' _config.Second);                  EnterBarrier("second-shutdown");                    // then immediately start restartedSecondSystem' which has the same address as secondSystem                  RunOn(() =>                  {                      TestConductor.PassThrough(_config.First' _config.Third' ThrottleTransportAdapter.Direction.Both)                          .Wait();                  }' _config.First);                    RunOn(() =>                  {                      Cluster.Get(restartedSecondSystem.Value).JoinSeedNodes(seedNodes);                      AwaitAssert(() => Cluster.Get(restartedSecondSystem.Value).ReadView.Members.Should().HaveCount(3));                      AwaitAssert(() => Cluster.Get(restartedSecondSystem.Value).ReadView                          .Members                          .All(c => c.Status == MemberStatus.Up)                          .Should().BeTrue());                  }' _config.Second);                    RunOn(() =>                  {                      AwaitAssert(() => Cluster.Get(Sys).ReadView.Members.Should().HaveCount(3));                      AwaitAssert(() => Cluster.Get(Sys).ReadView                          .Members                          .Count(                              m =>                                  m.Address == secondUniqueAddress.Address &&                                  m.UniqueAddress.Uid != secondUniqueAddress.Uid).Should().BeGreaterThan(0)                          );                  }' _config.First' _config.Third);                  EnterBarrier("second-restarted");              });
Magic Number,Akka.Cluster.Tests.MultiNode,RestartNode3Spec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartNode3Spec.cs,Cluster_nodes_must_be_able_to_restart_and_join_again_when_down_before_up,The following statement contains a magic number: Within(TimeSpan.FromSeconds(60)' () =>              {                  // secondSystem is a separate ActorSystem' to be able to simulate restart                  // we must transfer its address to first                  RunOn(() =>                  {                      Sys.ActorOf(Props.Create<Watcher>().WithDeploy(Deploy.Local)' "address-receiver");                      EnterBarrier("second-address-receiver-ready");                  }' _config.First' _config.Third);                    RunOn(() =>                  {                      EnterBarrier("second-address-receiver-ready");                      secondUniqueAddress = Cluster.Get(secondSystem.Value).SelfUniqueAddress;                      foreach (var r in ImmutableList.Create(_config.First' _config.Third))                      {                          Sys.ActorSelection(new RootActorPath(GetAddress(r)) / "user" / "address-receiver")                              .Tell(secondUniqueAddress);                          ExpectMsg("ok"' TimeSpan.FromSeconds(5));                      }                  }' _config.Second);                  EnterBarrier("second-address-transfered");                    // now we can join first' third together                  RunOn(() =>                  {                      Cluster.JoinSeedNodes(seedNodes);                      AwaitMembersUp(2);                  }' _config.First' _config.Third);                  EnterBarrier("first-third-up");                    // make third unreachable' so that leader can't perform its duties                  RunOn(() =>                  {                      TestConductor.Blackhole(_config.First' _config.Third' ThrottleTransportAdapter.Direction.Both)                          .Wait();                      var thirdAddress = GetAddress(_config.Third);                      AwaitAssert(() => ClusterView.UnreachableMembers.Select(c => c.Address)                          .Should().BeEquivalentTo(thirdAddress));                  }' _config.First);                  EnterBarrier("third-unreachable");                    RunOn(() =>                  {                      Cluster.Get(secondSystem.Value).JoinSeedNodes(seedNodes);                      AwaitAssert(() => Cluster.Get(secondSystem.Value).ReadView.Members.Should().HaveCount(3));                      AwaitAssert(() => Cluster.Get(secondSystem.Value).ReadView                          .Members                          .Where(m => m.Address == Cluster.Get(secondSystem.Value).SelfAddress)                          .Select(c => c.Status)                          .First()                          .Should().Be(MemberStatus.Joining));                  }' _config.Second);                  EnterBarrier("second-joined");                    // shutdown secondSystem                  RunOn(() =>                  {                      Shutdown(secondSystem.Value' Remaining);                  }' _config.Second);                  EnterBarrier("second-shutdown");                    // then immediately start restartedSecondSystem' which has the same address as secondSystem                  RunOn(() =>                  {                      TestConductor.PassThrough(_config.First' _config.Third' ThrottleTransportAdapter.Direction.Both)                          .Wait();                  }' _config.First);                    RunOn(() =>                  {                      Cluster.Get(restartedSecondSystem.Value).JoinSeedNodes(seedNodes);                      AwaitAssert(() => Cluster.Get(restartedSecondSystem.Value).ReadView.Members.Should().HaveCount(3));                      AwaitAssert(() => Cluster.Get(restartedSecondSystem.Value).ReadView                          .Members                          .All(c => c.Status == MemberStatus.Up)                          .Should().BeTrue());                  }' _config.Second);                    RunOn(() =>                  {                      AwaitAssert(() => Cluster.Get(Sys).ReadView.Members.Should().HaveCount(3));                      AwaitAssert(() => Cluster.Get(Sys).ReadView                          .Members                          .Count(                              m =>                                  m.Address == secondUniqueAddress.Address &&                                  m.UniqueAddress.Uid != secondUniqueAddress.Uid).Should().BeGreaterThan(0)                          );                  }' _config.First' _config.Third);                  EnterBarrier("second-restarted");              });
Magic Number,Akka.Cluster.Tests.MultiNode,RestartNodeSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartNodeSpec.cs,ClusterNodesMustBeAbleToRestartAndJoinAgain,The following statement contains a magic number: Within(TimeSpan.FromSeconds(60)' () =>              {                  // secondSystem is a separate ActorSystem' to be able to simulate restart                  // we must transfer its address to first                  RunOn(() =>                  {                      Sys.ActorOf(c => c.Receive<UniqueAddress>((address' ctx) =>                      {                          _secondUniqueAddress = address;                          ctx.Sender.Tell("ok");                      })' "address-receiver");                        EnterBarrier("second-address-receiver-ready");                    }' _config.First' _config.Third);                    RunOn(() =>                  {                      EnterBarrier("second-address-receiver-ready");                      _secondUniqueAddress = Cluster.Get(_secondSystem.Value).SelfUniqueAddress;                      foreach (var r in new[] {GetAddress(_config.First)' GetAddress(_config.Third)})                      {                          Sys.ActorSelection(new RootActorPath(r) / "user" / "address-receiver").Tell(_secondUniqueAddress);                          ExpectMsg("ok"' TimeSpan.FromSeconds(5));                      }                  }' _config.Second);                  EnterBarrier("second-address-transfered");                    // now we can join first' secondSystem' third together                  RunOn(() =>                  {                      Cluster.JoinSeedNodes(SeedNodes);                      AwaitMembersUp(3);                  }' _config.First' _config.Third);                    RunOn(() =>                  {                      Cluster.Get(_secondSystem.Value).JoinSeedNodes(SeedNodes);                      AwaitAssert(() => Assert.Equal(3' Cluster.Get(_secondSystem.Value).ReadView.Members.Count));                      AwaitAssert(() => Assert.True(Cluster.Get(_secondSystem.Value).ReadView.Members.Select(x => x.Status).All(s => s == MemberStatus.Up)));                  }' _config.Second);                  EnterBarrier("started");                    // shutdown _secondSystem                  RunOn(() =>                  {                      // send system message just before shutdown                      _secondSystem.Value.ActorOf(Props.Create(() => new Watcher(GetAddress(_config.First)' TestActor))'                          "testWatcher");                      ExpectMsg<Done>();                        Shutdown(_secondSystem.Value' Remaining);                  }' _config.Second);                    EnterBarrier("second-shutdown");                    // then immediately start restartedSecondSystem' which has the same address as secondSystem                  RunOn(() =>                  {                      Cluster.Get(_secondRestartedSystem.Value).JoinSeedNodes(SeedNodes);                      AwaitAssert(() => Assert.Equal(3' Cluster.Get(_secondRestartedSystem.Value).ReadView.Members.Count));                      AwaitAssert(() => Assert.True(Cluster.Get(_secondRestartedSystem.Value).ReadView.Members.Select(x => x.Status).All(s => s == MemberStatus.Up)));                  }' _config.Second);                    RunOn(() =>                  {                      AwaitAssert(() =>                      {                          Assert.Equal(3' Cluster.Get(Sys).ReadView.Members.Count);                          Assert.Contains(                              Cluster.Get(Sys).ReadView.Members'                              m => m.Address.Equals(SecondUniqueAddress.Address) && m.UniqueAddress.Uid != SecondUniqueAddress.Uid);                      });                  }' _config.First' _config.Third);                    EnterBarrier("second-restarted");              });
Magic Number,Akka.Cluster.Tests.MultiNode,RestartNodeSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartNodeSpec.cs,ClusterNodesMustBeAbleToRestartAndJoinAgain,The following statement contains a magic number: Within(TimeSpan.FromSeconds(60)' () =>              {                  // secondSystem is a separate ActorSystem' to be able to simulate restart                  // we must transfer its address to first                  RunOn(() =>                  {                      Sys.ActorOf(c => c.Receive<UniqueAddress>((address' ctx) =>                      {                          _secondUniqueAddress = address;                          ctx.Sender.Tell("ok");                      })' "address-receiver");                        EnterBarrier("second-address-receiver-ready");                    }' _config.First' _config.Third);                    RunOn(() =>                  {                      EnterBarrier("second-address-receiver-ready");                      _secondUniqueAddress = Cluster.Get(_secondSystem.Value).SelfUniqueAddress;                      foreach (var r in new[] {GetAddress(_config.First)' GetAddress(_config.Third)})                      {                          Sys.ActorSelection(new RootActorPath(r) / "user" / "address-receiver").Tell(_secondUniqueAddress);                          ExpectMsg("ok"' TimeSpan.FromSeconds(5));                      }                  }' _config.Second);                  EnterBarrier("second-address-transfered");                    // now we can join first' secondSystem' third together                  RunOn(() =>                  {                      Cluster.JoinSeedNodes(SeedNodes);                      AwaitMembersUp(3);                  }' _config.First' _config.Third);                    RunOn(() =>                  {                      Cluster.Get(_secondSystem.Value).JoinSeedNodes(SeedNodes);                      AwaitAssert(() => Assert.Equal(3' Cluster.Get(_secondSystem.Value).ReadView.Members.Count));                      AwaitAssert(() => Assert.True(Cluster.Get(_secondSystem.Value).ReadView.Members.Select(x => x.Status).All(s => s == MemberStatus.Up)));                  }' _config.Second);                  EnterBarrier("started");                    // shutdown _secondSystem                  RunOn(() =>                  {                      // send system message just before shutdown                      _secondSystem.Value.ActorOf(Props.Create(() => new Watcher(GetAddress(_config.First)' TestActor))'                          "testWatcher");                      ExpectMsg<Done>();                        Shutdown(_secondSystem.Value' Remaining);                  }' _config.Second);                    EnterBarrier("second-shutdown");                    // then immediately start restartedSecondSystem' which has the same address as secondSystem                  RunOn(() =>                  {                      Cluster.Get(_secondRestartedSystem.Value).JoinSeedNodes(SeedNodes);                      AwaitAssert(() => Assert.Equal(3' Cluster.Get(_secondRestartedSystem.Value).ReadView.Members.Count));                      AwaitAssert(() => Assert.True(Cluster.Get(_secondRestartedSystem.Value).ReadView.Members.Select(x => x.Status).All(s => s == MemberStatus.Up)));                  }' _config.Second);                    RunOn(() =>                  {                      AwaitAssert(() =>                      {                          Assert.Equal(3' Cluster.Get(Sys).ReadView.Members.Count);                          Assert.Contains(                              Cluster.Get(Sys).ReadView.Members'                              m => m.Address.Equals(SecondUniqueAddress.Address) && m.UniqueAddress.Uid != SecondUniqueAddress.Uid);                      });                  }' _config.First' _config.Third);                    EnterBarrier("second-restarted");              });
Magic Number,Akka.Cluster.Tests.MultiNode,RestartNodeSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartNodeSpec.cs,ClusterNodesMustBeAbleToRestartAndJoinAgain,The following statement contains a magic number: Within(TimeSpan.FromSeconds(60)' () =>              {                  // secondSystem is a separate ActorSystem' to be able to simulate restart                  // we must transfer its address to first                  RunOn(() =>                  {                      Sys.ActorOf(c => c.Receive<UniqueAddress>((address' ctx) =>                      {                          _secondUniqueAddress = address;                          ctx.Sender.Tell("ok");                      })' "address-receiver");                        EnterBarrier("second-address-receiver-ready");                    }' _config.First' _config.Third);                    RunOn(() =>                  {                      EnterBarrier("second-address-receiver-ready");                      _secondUniqueAddress = Cluster.Get(_secondSystem.Value).SelfUniqueAddress;                      foreach (var r in new[] {GetAddress(_config.First)' GetAddress(_config.Third)})                      {                          Sys.ActorSelection(new RootActorPath(r) / "user" / "address-receiver").Tell(_secondUniqueAddress);                          ExpectMsg("ok"' TimeSpan.FromSeconds(5));                      }                  }' _config.Second);                  EnterBarrier("second-address-transfered");                    // now we can join first' secondSystem' third together                  RunOn(() =>                  {                      Cluster.JoinSeedNodes(SeedNodes);                      AwaitMembersUp(3);                  }' _config.First' _config.Third);                    RunOn(() =>                  {                      Cluster.Get(_secondSystem.Value).JoinSeedNodes(SeedNodes);                      AwaitAssert(() => Assert.Equal(3' Cluster.Get(_secondSystem.Value).ReadView.Members.Count));                      AwaitAssert(() => Assert.True(Cluster.Get(_secondSystem.Value).ReadView.Members.Select(x => x.Status).All(s => s == MemberStatus.Up)));                  }' _config.Second);                  EnterBarrier("started");                    // shutdown _secondSystem                  RunOn(() =>                  {                      // send system message just before shutdown                      _secondSystem.Value.ActorOf(Props.Create(() => new Watcher(GetAddress(_config.First)' TestActor))'                          "testWatcher");                      ExpectMsg<Done>();                        Shutdown(_secondSystem.Value' Remaining);                  }' _config.Second);                    EnterBarrier("second-shutdown");                    // then immediately start restartedSecondSystem' which has the same address as secondSystem                  RunOn(() =>                  {                      Cluster.Get(_secondRestartedSystem.Value).JoinSeedNodes(SeedNodes);                      AwaitAssert(() => Assert.Equal(3' Cluster.Get(_secondRestartedSystem.Value).ReadView.Members.Count));                      AwaitAssert(() => Assert.True(Cluster.Get(_secondRestartedSystem.Value).ReadView.Members.Select(x => x.Status).All(s => s == MemberStatus.Up)));                  }' _config.Second);                    RunOn(() =>                  {                      AwaitAssert(() =>                      {                          Assert.Equal(3' Cluster.Get(Sys).ReadView.Members.Count);                          Assert.Contains(                              Cluster.Get(Sys).ReadView.Members'                              m => m.Address.Equals(SecondUniqueAddress.Address) && m.UniqueAddress.Uid != SecondUniqueAddress.Uid);                      });                  }' _config.First' _config.Third);                    EnterBarrier("second-restarted");              });
Magic Number,Akka.Cluster.Tests.MultiNode,RestartNodeSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartNodeSpec.cs,ClusterNodesMustBeAbleToRestartAndJoinAgain,The following statement contains a magic number: Within(TimeSpan.FromSeconds(60)' () =>              {                  // secondSystem is a separate ActorSystem' to be able to simulate restart                  // we must transfer its address to first                  RunOn(() =>                  {                      Sys.ActorOf(c => c.Receive<UniqueAddress>((address' ctx) =>                      {                          _secondUniqueAddress = address;                          ctx.Sender.Tell("ok");                      })' "address-receiver");                        EnterBarrier("second-address-receiver-ready");                    }' _config.First' _config.Third);                    RunOn(() =>                  {                      EnterBarrier("second-address-receiver-ready");                      _secondUniqueAddress = Cluster.Get(_secondSystem.Value).SelfUniqueAddress;                      foreach (var r in new[] {GetAddress(_config.First)' GetAddress(_config.Third)})                      {                          Sys.ActorSelection(new RootActorPath(r) / "user" / "address-receiver").Tell(_secondUniqueAddress);                          ExpectMsg("ok"' TimeSpan.FromSeconds(5));                      }                  }' _config.Second);                  EnterBarrier("second-address-transfered");                    // now we can join first' secondSystem' third together                  RunOn(() =>                  {                      Cluster.JoinSeedNodes(SeedNodes);                      AwaitMembersUp(3);                  }' _config.First' _config.Third);                    RunOn(() =>                  {                      Cluster.Get(_secondSystem.Value).JoinSeedNodes(SeedNodes);                      AwaitAssert(() => Assert.Equal(3' Cluster.Get(_secondSystem.Value).ReadView.Members.Count));                      AwaitAssert(() => Assert.True(Cluster.Get(_secondSystem.Value).ReadView.Members.Select(x => x.Status).All(s => s == MemberStatus.Up)));                  }' _config.Second);                  EnterBarrier("started");                    // shutdown _secondSystem                  RunOn(() =>                  {                      // send system message just before shutdown                      _secondSystem.Value.ActorOf(Props.Create(() => new Watcher(GetAddress(_config.First)' TestActor))'                          "testWatcher");                      ExpectMsg<Done>();                        Shutdown(_secondSystem.Value' Remaining);                  }' _config.Second);                    EnterBarrier("second-shutdown");                    // then immediately start restartedSecondSystem' which has the same address as secondSystem                  RunOn(() =>                  {                      Cluster.Get(_secondRestartedSystem.Value).JoinSeedNodes(SeedNodes);                      AwaitAssert(() => Assert.Equal(3' Cluster.Get(_secondRestartedSystem.Value).ReadView.Members.Count));                      AwaitAssert(() => Assert.True(Cluster.Get(_secondRestartedSystem.Value).ReadView.Members.Select(x => x.Status).All(s => s == MemberStatus.Up)));                  }' _config.Second);                    RunOn(() =>                  {                      AwaitAssert(() =>                      {                          Assert.Equal(3' Cluster.Get(Sys).ReadView.Members.Count);                          Assert.Contains(                              Cluster.Get(Sys).ReadView.Members'                              m => m.Address.Equals(SecondUniqueAddress.Address) && m.UniqueAddress.Uid != SecondUniqueAddress.Uid);                      });                  }' _config.First' _config.Third);                    EnterBarrier("second-restarted");              });
Magic Number,Akka.Cluster.Tests.MultiNode,RestartNodeSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartNodeSpec.cs,ClusterNodesMustBeAbleToRestartAndJoinAgain,The following statement contains a magic number: Within(TimeSpan.FromSeconds(60)' () =>              {                  // secondSystem is a separate ActorSystem' to be able to simulate restart                  // we must transfer its address to first                  RunOn(() =>                  {                      Sys.ActorOf(c => c.Receive<UniqueAddress>((address' ctx) =>                      {                          _secondUniqueAddress = address;                          ctx.Sender.Tell("ok");                      })' "address-receiver");                        EnterBarrier("second-address-receiver-ready");                    }' _config.First' _config.Third);                    RunOn(() =>                  {                      EnterBarrier("second-address-receiver-ready");                      _secondUniqueAddress = Cluster.Get(_secondSystem.Value).SelfUniqueAddress;                      foreach (var r in new[] {GetAddress(_config.First)' GetAddress(_config.Third)})                      {                          Sys.ActorSelection(new RootActorPath(r) / "user" / "address-receiver").Tell(_secondUniqueAddress);                          ExpectMsg("ok"' TimeSpan.FromSeconds(5));                      }                  }' _config.Second);                  EnterBarrier("second-address-transfered");                    // now we can join first' secondSystem' third together                  RunOn(() =>                  {                      Cluster.JoinSeedNodes(SeedNodes);                      AwaitMembersUp(3);                  }' _config.First' _config.Third);                    RunOn(() =>                  {                      Cluster.Get(_secondSystem.Value).JoinSeedNodes(SeedNodes);                      AwaitAssert(() => Assert.Equal(3' Cluster.Get(_secondSystem.Value).ReadView.Members.Count));                      AwaitAssert(() => Assert.True(Cluster.Get(_secondSystem.Value).ReadView.Members.Select(x => x.Status).All(s => s == MemberStatus.Up)));                  }' _config.Second);                  EnterBarrier("started");                    // shutdown _secondSystem                  RunOn(() =>                  {                      // send system message just before shutdown                      _secondSystem.Value.ActorOf(Props.Create(() => new Watcher(GetAddress(_config.First)' TestActor))'                          "testWatcher");                      ExpectMsg<Done>();                        Shutdown(_secondSystem.Value' Remaining);                  }' _config.Second);                    EnterBarrier("second-shutdown");                    // then immediately start restartedSecondSystem' which has the same address as secondSystem                  RunOn(() =>                  {                      Cluster.Get(_secondRestartedSystem.Value).JoinSeedNodes(SeedNodes);                      AwaitAssert(() => Assert.Equal(3' Cluster.Get(_secondRestartedSystem.Value).ReadView.Members.Count));                      AwaitAssert(() => Assert.True(Cluster.Get(_secondRestartedSystem.Value).ReadView.Members.Select(x => x.Status).All(s => s == MemberStatus.Up)));                  }' _config.Second);                    RunOn(() =>                  {                      AwaitAssert(() =>                      {                          Assert.Equal(3' Cluster.Get(Sys).ReadView.Members.Count);                          Assert.Contains(                              Cluster.Get(Sys).ReadView.Members'                              m => m.Address.Equals(SecondUniqueAddress.Address) && m.UniqueAddress.Uid != SecondUniqueAddress.Uid);                      });                  }' _config.First' _config.Third);                    EnterBarrier("second-restarted");              });
Magic Number,Akka.Cluster.Tests.MultiNode,RestartNodeSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\RestartNodeSpec.cs,ClusterNodesMustBeAbleToRestartAndJoinAgain,The following statement contains a magic number: Within(TimeSpan.FromSeconds(60)' () =>              {                  // secondSystem is a separate ActorSystem' to be able to simulate restart                  // we must transfer its address to first                  RunOn(() =>                  {                      Sys.ActorOf(c => c.Receive<UniqueAddress>((address' ctx) =>                      {                          _secondUniqueAddress = address;                          ctx.Sender.Tell("ok");                      })' "address-receiver");                        EnterBarrier("second-address-receiver-ready");                    }' _config.First' _config.Third);                    RunOn(() =>                  {                      EnterBarrier("second-address-receiver-ready");                      _secondUniqueAddress = Cluster.Get(_secondSystem.Value).SelfUniqueAddress;                      foreach (var r in new[] {GetAddress(_config.First)' GetAddress(_config.Third)})                      {                          Sys.ActorSelection(new RootActorPath(r) / "user" / "address-receiver").Tell(_secondUniqueAddress);                          ExpectMsg("ok"' TimeSpan.FromSeconds(5));                      }                  }' _config.Second);                  EnterBarrier("second-address-transfered");                    // now we can join first' secondSystem' third together                  RunOn(() =>                  {                      Cluster.JoinSeedNodes(SeedNodes);                      AwaitMembersUp(3);                  }' _config.First' _config.Third);                    RunOn(() =>                  {                      Cluster.Get(_secondSystem.Value).JoinSeedNodes(SeedNodes);                      AwaitAssert(() => Assert.Equal(3' Cluster.Get(_secondSystem.Value).ReadView.Members.Count));                      AwaitAssert(() => Assert.True(Cluster.Get(_secondSystem.Value).ReadView.Members.Select(x => x.Status).All(s => s == MemberStatus.Up)));                  }' _config.Second);                  EnterBarrier("started");                    // shutdown _secondSystem                  RunOn(() =>                  {                      // send system message just before shutdown                      _secondSystem.Value.ActorOf(Props.Create(() => new Watcher(GetAddress(_config.First)' TestActor))'                          "testWatcher");                      ExpectMsg<Done>();                        Shutdown(_secondSystem.Value' Remaining);                  }' _config.Second);                    EnterBarrier("second-shutdown");                    // then immediately start restartedSecondSystem' which has the same address as secondSystem                  RunOn(() =>                  {                      Cluster.Get(_secondRestartedSystem.Value).JoinSeedNodes(SeedNodes);                      AwaitAssert(() => Assert.Equal(3' Cluster.Get(_secondRestartedSystem.Value).ReadView.Members.Count));                      AwaitAssert(() => Assert.True(Cluster.Get(_secondRestartedSystem.Value).ReadView.Members.Select(x => x.Status).All(s => s == MemberStatus.Up)));                  }' _config.Second);                    RunOn(() =>                  {                      AwaitAssert(() =>                      {                          Assert.Equal(3' Cluster.Get(Sys).ReadView.Members.Count);                          Assert.Contains(                              Cluster.Get(Sys).ReadView.Members'                              m => m.Address.Equals(SecondUniqueAddress.Address) && m.UniqueAddress.Uid != SecondUniqueAddress.Uid);                      });                  }' _config.First' _config.Third);                    EnterBarrier("second-restarted");              });
Magic Number,Akka.Cluster.Tests.MultiNode,SingletonClusterSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\SingletonClusterSpec.cs,Cluster_of_2_nodes_must_become_singleton_cluster_when_one_node_is_shutdown,The following statement contains a magic number: RunOn(() =>              {                  var secondAddress = GetAddress(_config.Second);                  TestConductor.Exit(_config.Second' 0).Wait();                    MarkNodeAsUnavailable(secondAddress);                    AwaitMembersUp(1' ImmutableHashSet.Create<Address>(secondAddress)' TimeSpan.FromSeconds(30));                  ClusterView.IsSingletonCluster.ShouldBeTrue();                  AwaitCondition(() => ClusterView.IsLeader);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode,SingletonClusterSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\SingletonClusterSpec.cs,Cluster_of_2_nodes_must_leave_and_shutdown_itself_when_singleton_cluster,The following statement contains a magic number: RunOn(() =>              {                  Cluster.Leave(GetAddress(_config.First));                  AwaitCondition(() => Cluster.IsTerminated' TimeSpan.FromSeconds(5));              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode,SunnyWeatherSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\SunnyWeatherSpec.cs,Normal_cluster_must_be_healthy,The following statement contains a magic number: n % 5 == 0
Magic Number,Akka.Cluster.Tests.MultiNode,SunnyWeatherSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\SunnyWeatherSpec.cs,Normal_cluster_must_be_healthy,The following statement contains a magic number: Thread.Sleep(1000);
Magic Number,Akka.Cluster.Tests.MultiNode,SunnyWeatherSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\SunnyWeatherSpec.cs,Normal_cluster_must_be_healthy,The following statement contains a magic number: Enumerable.Range(1' 30)
Magic Number,Akka.Cluster.Tests.MultiNode,SurviveNetworkInstabilitySpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\SurviveNetworkInstabilitySpec.cs,A_Network_partition_tolerant_cluster_must_heal_after_a_broken_pair,The following statement contains a magic number: Within(45.Seconds()' () =>              {                  RunOn(() =>                  {                      TestConductor.Blackhole(_config.First' _config.Second' ThrottleTransportAdapter.Direction.Both).Wait();                  }' _config.First);                  EnterBarrier("blackhole-2");                    RunOn(() =>                  {                      AssertUnreachable(_config.Second);                  }' _config.First);                    RunOn(() =>                  {                      AssertUnreachable(_config.First);                  }' _config.Second);                    RunOn(() =>                  {                      AssertUnreachable(_config.First' _config.Second);                  }' _config.Third' _config.Fourth' _config.Fifth);                    EnterBarrier("unreachable-2");                    RunOn(() =>                  {                      TestConductor.PassThrough(_config.First' _config.Second' ThrottleTransportAdapter.Direction.Both).Wait();                  }' _config.First);                  EnterBarrier("repair-2");                    // This test illustrates why we can't ignore gossip from unreachable aggregated                  // status. If all third' fourth' and fifth has been infected by first and second                  // unreachable they must accept gossip from first and second when their                  // broken connection has healed' otherwise they will be isolated forever.                  EnterBarrier("after-2");                  AssertCanTalk(_config.First' _config.Second' _config.Third' _config.Fourth' _config.Fifth);              });
Magic Number,Akka.Cluster.Tests.MultiNode,SurviveNetworkInstabilitySpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\SurviveNetworkInstabilitySpec.cs,A_Network_partition_tolerant_cluster_must_heal_after_one_isolated_node,The following statement contains a magic number: Within(45.Seconds()' () =>              {                  var others = ImmutableArray.Create(_config.Second' _config.Third' _config.Fourth' _config.Fifth);                  RunOn(() =>                  {                      foreach (var other in others)                      {                          TestConductor.Blackhole(_config.First' other' ThrottleTransportAdapter.Direction.Both).Wait();                      }                  }' _config.First);                  EnterBarrier("blackhole-3");                    RunOn(() =>                  {                      AssertUnreachable(others.ToArray());                  }' _config.First);                    RunOn(() =>                  {                      AssertUnreachable(_config.First);                  }' others.ToArray());                    EnterBarrier("unreachable-3");                    RunOn(() =>                  {                      foreach (var other in others)                      {                          TestConductor.PassThrough(_config.First' other' ThrottleTransportAdapter.Direction.Both).Wait();                      }                  }' _config.First);                  EnterBarrier("repair-3");                  AssertCanTalk(others.Add(_config.First).ToArray());              });
Magic Number,Akka.Cluster.Tests.MultiNode,SurviveNetworkInstabilitySpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\SurviveNetworkInstabilitySpec.cs,A_Network_partition_tolerant_cluster_must_heal_two_isolated_islands,The following statement contains a magic number: Within(45.Seconds()' () =>              {                  var island1 = ImmutableArray.Create(_config.First' _config.Second);                  var island2 = ImmutableArray.Create(_config.Third' _config.Fourth' _config.Fifth);                    RunOn(() =>                  {                      // split the cluster in two parts (first' second) / (third' fourth' fifth)                      foreach (var role1 in island1)                      {                          foreach (var role2 in island2)                          {                              TestConductor.Blackhole(role1' role2' ThrottleTransportAdapter.Direction.Both).Wait();                          }                      }                  }' _config.First);                  EnterBarrier("blackhole-4");                    RunOn(() =>                  {                      AssertUnreachable(island2.ToArray());                  }' island1.ToArray());                    RunOn(() =>                  {                      AssertUnreachable(island1.ToArray());                  }' island2.ToArray());                    EnterBarrier("unreachable-4");                    RunOn(() =>                  {                      foreach (var role1 in island1)                      {                          foreach (var role2 in island2)                          {                              TestConductor.PassThrough(role1' role2' ThrottleTransportAdapter.Direction.Both).Wait();                          }                      }                  }' _config.First);                  EnterBarrier("repair-4");                    AssertCanTalk(island1.AddRange(island2).ToArray());              });
Magic Number,Akka.Cluster.Tests.MultiNode,SurviveNetworkInstabilitySpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\SurviveNetworkInstabilitySpec.cs,A_Network_partition_tolerant_cluster_must_heal_after_unreachable_when_ring_is_changed,The following statement contains a magic number: Within(60.Seconds()' () =>              {                  var joining = ImmutableArray.Create(_config.Sixth' _config.Seventh);                  var others = ImmutableArray.Create(_config.Second' _config.Third' _config.Fourth' _config.Fifth);                    RunOn(() =>                  {                      foreach (var role1 in joining.Add(_config.First))                      {                          foreach (var role2 in others)                          {                              TestConductor.Blackhole(role1' role2' ThrottleTransportAdapter.Direction.Both).Wait();                          }                      }                  }' _config.First);                  EnterBarrier("blackhole-5");                    RunOn(() =>                  {                      AssertUnreachable(others.ToArray());                  }' _config.First);                    RunOn(() =>                  {                      AssertUnreachable(_config.First);                  }' others.ToArray());                    EnterBarrier("unreachable-5");                    RunOn(() =>                  {                      Cluster.Join(GetAddress(_config.First));                        // let them join and stabilize heartbeating                      Thread.Sleep(Dilated(5000.Milliseconds()));                  }' joining.ToArray());                    EnterBarrier("joined-5");                    RunOn(() =>                  {                      AssertUnreachable(others.ToArray());                  }' joining.Add(_config.First).ToArray());                    // others doesn't know about the joining nodes yet' no gossip passed through                  RunOn(() =>                  {                      AssertUnreachable(_config.First);                  }' others.ToArray());                    EnterBarrier("more-unreachable-5");                    RunOn(() =>                  {                      foreach (var role1 in joining.Add(_config.First))                      {                          foreach (var role2 in others)                          {                              TestConductor.PassThrough(role1' role2' ThrottleTransportAdapter.Direction.Both).Wait();                          }                      }                  }' _config.First);                  EnterBarrier("repair-5");                    RunOn(() =>                  {                      // eighth not joined yet                      AwaitMembersUp(Roles.Count - 1' timeout: Remaining);                  }' joining.AddRange(others).Add(_config.First).ToArray());                  EnterBarrier("after-5");                    AssertCanTalk(joining.AddRange(others).Add(_config.First).ToArray());              });
Magic Number,Akka.Cluster.Tests.MultiNode,SurviveNetworkInstabilitySpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\SurviveNetworkInstabilitySpec.cs,A_Network_partition_tolerant_cluster_must_heal_after_unreachable_when_ring_is_changed,The following statement contains a magic number: Within(60.Seconds()' () =>              {                  var joining = ImmutableArray.Create(_config.Sixth' _config.Seventh);                  var others = ImmutableArray.Create(_config.Second' _config.Third' _config.Fourth' _config.Fifth);                    RunOn(() =>                  {                      foreach (var role1 in joining.Add(_config.First))                      {                          foreach (var role2 in others)                          {                              TestConductor.Blackhole(role1' role2' ThrottleTransportAdapter.Direction.Both).Wait();                          }                      }                  }' _config.First);                  EnterBarrier("blackhole-5");                    RunOn(() =>                  {                      AssertUnreachable(others.ToArray());                  }' _config.First);                    RunOn(() =>                  {                      AssertUnreachable(_config.First);                  }' others.ToArray());                    EnterBarrier("unreachable-5");                    RunOn(() =>                  {                      Cluster.Join(GetAddress(_config.First));                        // let them join and stabilize heartbeating                      Thread.Sleep(Dilated(5000.Milliseconds()));                  }' joining.ToArray());                    EnterBarrier("joined-5");                    RunOn(() =>                  {                      AssertUnreachable(others.ToArray());                  }' joining.Add(_config.First).ToArray());                    // others doesn't know about the joining nodes yet' no gossip passed through                  RunOn(() =>                  {                      AssertUnreachable(_config.First);                  }' others.ToArray());                    EnterBarrier("more-unreachable-5");                    RunOn(() =>                  {                      foreach (var role1 in joining.Add(_config.First))                      {                          foreach (var role2 in others)                          {                              TestConductor.PassThrough(role1' role2' ThrottleTransportAdapter.Direction.Both).Wait();                          }                      }                  }' _config.First);                  EnterBarrier("repair-5");                    RunOn(() =>                  {                      // eighth not joined yet                      AwaitMembersUp(Roles.Count - 1' timeout: Remaining);                  }' joining.AddRange(others).Add(_config.First).ToArray());                  EnterBarrier("after-5");                    AssertCanTalk(joining.AddRange(others).Add(_config.First).ToArray());              });
Magic Number,Akka.Cluster.Tests.MultiNode,SurviveNetworkInstabilitySpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\SurviveNetworkInstabilitySpec.cs,A_Network_partition_tolerant_cluster_must_mark_quarantined_node_with_reachability_status_Terminated,The following statement contains a magic number: Within(60.Seconds()' () =>              {                  var others = ImmutableArray.Create(_config.First' _config.Third' _config.Fourth' _config.Fifth' _config.Sixth' _config.Seventh);                    RunOn(() =>                  {                      Sys.ActorOf<SurviveNetworkInstabilitySpecConfig.Watcher>("watcher");                        // undelivered system messages in RemoteChild on third should trigger QuarantinedEvent                      Sys.EventStream.Subscribe(TestActor' typeof(QuarantinedEvent));                  }' _config.Third);                  EnterBarrier("watcher-created");                    RunOn(() =>                  {                      var sysMsgBufferSize = Sys                          .AsInstanceOf<ExtendedActorSystem>().Provider                          .AsInstanceOf<RemoteActorRefProvider>().RemoteSettings.SysMsgBufferSize;                        var refs = Vector.Fill<IActorRef>(sysMsgBufferSize + 1)(                          () => Sys.ActorOf<SurviveNetworkInstabilitySpecConfig.Echo>()).ToImmutableHashSet();                        Sys.ActorSelection(Node(_config.Third) / "user" / "watcher").Tell(new SurviveNetworkInstabilitySpecConfig.Targets(refs));                      ExpectMsg<SurviveNetworkInstabilitySpecConfig.TargetsRegistered>();                  }' _config.Second);                  EnterBarrier("targets-registered");                    RunOn(() =>                  {                      foreach (var role in others)                      {                          TestConductor.Blackhole(role' _config.Second' ThrottleTransportAdapter.Direction.Both).Wait();                      }                  }' _config.First);                  EnterBarrier("blackhole-6");                    RunOn(() =>                  {                      // this will trigger watch of targets on second' resulting in too many outstanding                      // system messages and quarantine                      Sys.ActorSelection("/user/watcher").Tell("boom");                      Within(10.Seconds()' () =>                      {                          ExpectMsg<QuarantinedEvent>().Address.Should().Be(GetAddress(_config.Second));                      });                      Sys.EventStream.Unsubscribe(TestActor' typeof(QuarantinedEvent));                  }' _config.Third);                  EnterBarrier("quarantined");                    RunOn(() =>                  {                      Thread.Sleep(2000.Milliseconds());                        var secondUniqueAddress = Cluster.State.Members.SingleOrDefault(m => m.Address == GetAddress(_config.Second));                      secondUniqueAddress.Should().NotBeNull(because: "2nd node should stay visible");                      secondUniqueAddress?.Status.Should().Be(MemberStatus.Up' because: "2nd node should be Up");                                            // second should be marked with reachability status Terminated                      AwaitAssert(() => ClusterView.Reachability.Status(secondUniqueAddress?.UniqueAddress).Should().Be(Reachability.ReachabilityStatus.Terminated));                  }' others.ToArray());                  EnterBarrier("reachability-terminated");                    RunOn(() =>                  {                      Cluster.Down(GetAddress(_config.Second));                  }' _config.Fourth);                    RunOn(() =>                  {                      // second should be removed because of quarantine                      AwaitAssert(() => ClusterView.Members.Select(c => c.Address).Should().NotContain(GetAddress(_config.Second)));                      // and also removed from reachability table                      AwaitAssert(() => ClusterView.Reachability.AllUnreachableOrTerminated.Should().BeEmpty());                  }' others.ToArray());                  EnterBarrier("removed-after-down");                    EnterBarrier("after-6");                  AssertCanTalk(others.ToArray());              });
Magic Number,Akka.Cluster.Tests.MultiNode,SurviveNetworkInstabilitySpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\SurviveNetworkInstabilitySpec.cs,A_Network_partition_tolerant_cluster_must_mark_quarantined_node_with_reachability_status_Terminated,The following statement contains a magic number: Within(60.Seconds()' () =>              {                  var others = ImmutableArray.Create(_config.First' _config.Third' _config.Fourth' _config.Fifth' _config.Sixth' _config.Seventh);                    RunOn(() =>                  {                      Sys.ActorOf<SurviveNetworkInstabilitySpecConfig.Watcher>("watcher");                        // undelivered system messages in RemoteChild on third should trigger QuarantinedEvent                      Sys.EventStream.Subscribe(TestActor' typeof(QuarantinedEvent));                  }' _config.Third);                  EnterBarrier("watcher-created");                    RunOn(() =>                  {                      var sysMsgBufferSize = Sys                          .AsInstanceOf<ExtendedActorSystem>().Provider                          .AsInstanceOf<RemoteActorRefProvider>().RemoteSettings.SysMsgBufferSize;                        var refs = Vector.Fill<IActorRef>(sysMsgBufferSize + 1)(                          () => Sys.ActorOf<SurviveNetworkInstabilitySpecConfig.Echo>()).ToImmutableHashSet();                        Sys.ActorSelection(Node(_config.Third) / "user" / "watcher").Tell(new SurviveNetworkInstabilitySpecConfig.Targets(refs));                      ExpectMsg<SurviveNetworkInstabilitySpecConfig.TargetsRegistered>();                  }' _config.Second);                  EnterBarrier("targets-registered");                    RunOn(() =>                  {                      foreach (var role in others)                      {                          TestConductor.Blackhole(role' _config.Second' ThrottleTransportAdapter.Direction.Both).Wait();                      }                  }' _config.First);                  EnterBarrier("blackhole-6");                    RunOn(() =>                  {                      // this will trigger watch of targets on second' resulting in too many outstanding                      // system messages and quarantine                      Sys.ActorSelection("/user/watcher").Tell("boom");                      Within(10.Seconds()' () =>                      {                          ExpectMsg<QuarantinedEvent>().Address.Should().Be(GetAddress(_config.Second));                      });                      Sys.EventStream.Unsubscribe(TestActor' typeof(QuarantinedEvent));                  }' _config.Third);                  EnterBarrier("quarantined");                    RunOn(() =>                  {                      Thread.Sleep(2000.Milliseconds());                        var secondUniqueAddress = Cluster.State.Members.SingleOrDefault(m => m.Address == GetAddress(_config.Second));                      secondUniqueAddress.Should().NotBeNull(because: "2nd node should stay visible");                      secondUniqueAddress?.Status.Should().Be(MemberStatus.Up' because: "2nd node should be Up");                                            // second should be marked with reachability status Terminated                      AwaitAssert(() => ClusterView.Reachability.Status(secondUniqueAddress?.UniqueAddress).Should().Be(Reachability.ReachabilityStatus.Terminated));                  }' others.ToArray());                  EnterBarrier("reachability-terminated");                    RunOn(() =>                  {                      Cluster.Down(GetAddress(_config.Second));                  }' _config.Fourth);                    RunOn(() =>                  {                      // second should be removed because of quarantine                      AwaitAssert(() => ClusterView.Members.Select(c => c.Address).Should().NotContain(GetAddress(_config.Second)));                      // and also removed from reachability table                      AwaitAssert(() => ClusterView.Reachability.AllUnreachableOrTerminated.Should().BeEmpty());                  }' others.ToArray());                  EnterBarrier("removed-after-down");                    EnterBarrier("after-6");                  AssertCanTalk(others.ToArray());              });
Magic Number,Akka.Cluster.Tests.MultiNode,SurviveNetworkInstabilitySpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\SurviveNetworkInstabilitySpec.cs,A_Network_partition_tolerant_cluster_must_mark_quarantined_node_with_reachability_status_Terminated,The following statement contains a magic number: Within(60.Seconds()' () =>              {                  var others = ImmutableArray.Create(_config.First' _config.Third' _config.Fourth' _config.Fifth' _config.Sixth' _config.Seventh);                    RunOn(() =>                  {                      Sys.ActorOf<SurviveNetworkInstabilitySpecConfig.Watcher>("watcher");                        // undelivered system messages in RemoteChild on third should trigger QuarantinedEvent                      Sys.EventStream.Subscribe(TestActor' typeof(QuarantinedEvent));                  }' _config.Third);                  EnterBarrier("watcher-created");                    RunOn(() =>                  {                      var sysMsgBufferSize = Sys                          .AsInstanceOf<ExtendedActorSystem>().Provider                          .AsInstanceOf<RemoteActorRefProvider>().RemoteSettings.SysMsgBufferSize;                        var refs = Vector.Fill<IActorRef>(sysMsgBufferSize + 1)(                          () => Sys.ActorOf<SurviveNetworkInstabilitySpecConfig.Echo>()).ToImmutableHashSet();                        Sys.ActorSelection(Node(_config.Third) / "user" / "watcher").Tell(new SurviveNetworkInstabilitySpecConfig.Targets(refs));                      ExpectMsg<SurviveNetworkInstabilitySpecConfig.TargetsRegistered>();                  }' _config.Second);                  EnterBarrier("targets-registered");                    RunOn(() =>                  {                      foreach (var role in others)                      {                          TestConductor.Blackhole(role' _config.Second' ThrottleTransportAdapter.Direction.Both).Wait();                      }                  }' _config.First);                  EnterBarrier("blackhole-6");                    RunOn(() =>                  {                      // this will trigger watch of targets on second' resulting in too many outstanding                      // system messages and quarantine                      Sys.ActorSelection("/user/watcher").Tell("boom");                      Within(10.Seconds()' () =>                      {                          ExpectMsg<QuarantinedEvent>().Address.Should().Be(GetAddress(_config.Second));                      });                      Sys.EventStream.Unsubscribe(TestActor' typeof(QuarantinedEvent));                  }' _config.Third);                  EnterBarrier("quarantined");                    RunOn(() =>                  {                      Thread.Sleep(2000.Milliseconds());                        var secondUniqueAddress = Cluster.State.Members.SingleOrDefault(m => m.Address == GetAddress(_config.Second));                      secondUniqueAddress.Should().NotBeNull(because: "2nd node should stay visible");                      secondUniqueAddress?.Status.Should().Be(MemberStatus.Up' because: "2nd node should be Up");                                            // second should be marked with reachability status Terminated                      AwaitAssert(() => ClusterView.Reachability.Status(secondUniqueAddress?.UniqueAddress).Should().Be(Reachability.ReachabilityStatus.Terminated));                  }' others.ToArray());                  EnterBarrier("reachability-terminated");                    RunOn(() =>                  {                      Cluster.Down(GetAddress(_config.Second));                  }' _config.Fourth);                    RunOn(() =>                  {                      // second should be removed because of quarantine                      AwaitAssert(() => ClusterView.Members.Select(c => c.Address).Should().NotContain(GetAddress(_config.Second)));                      // and also removed from reachability table                      AwaitAssert(() => ClusterView.Reachability.AllUnreachableOrTerminated.Should().BeEmpty());                  }' others.ToArray());                  EnterBarrier("removed-after-down");                    EnterBarrier("after-6");                  AssertCanTalk(others.ToArray());              });
Magic Number,Akka.Cluster.Tests.MultiNode,SurviveNetworkInstabilitySpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\SurviveNetworkInstabilitySpec.cs,A_Network_partition_tolerant_cluster_must_continue_and_move_Joining_to_Up_after_downing_of_one_half,The following statement contains a magic number: Within(60.Seconds()' () =>              {                  // note that second is already removed in previous step                  var side1 = ImmutableArray.Create(_config.First' _config.Third' _config.Fourth);                  var side1AfterJoin = side1.Add(_config.Eighth);                  var side2 = ImmutableArray.Create(_config.Fifth' _config.Sixth' _config.Seventh);                    RunOn(() =>                  {                      foreach (var role1 in side1AfterJoin)                      {                          foreach (var role2 in side2)                          {                              TestConductor.Blackhole(role1' role2' ThrottleTransportAdapter.Direction.Both).Wait();                          }                      }                  }' _config.First);                  EnterBarrier("blackhole-7");                    RunOn(() =>                  {                      AssertUnreachable(side2.ToArray());                  }' side1.ToArray());                    RunOn(() =>                  {                      AssertUnreachable(side1.ToArray());                  }' side2.ToArray());                    EnterBarrier("unreachable-7");                    RunOn(() =>                  {                      Cluster.Join(GetAddress(_config.Third));                  }' _config.Eighth);                    RunOn(() =>                  {                      foreach (var role2 in side2)                      {                          Cluster.Down(GetAddress(role2));                      }                  }' _config.Fourth);                    EnterBarrier("downed-7");                    RunOn(() =>                  {                      // side2 removed                      var expected = side1AfterJoin.Select(c => GetAddress(c)).ToImmutableHashSet();                      AwaitAssert(() =>                      {                          RunOn(() =>                          {                              // repeat the downing in case it was not successful' which may                              // happen if the removal was reverted due to gossip merge                              foreach (var role2 in side2)                              {                                  Cluster.Down(GetAddress(role2));                              }                          }' _config.Fourth);                            ClusterView.Members.Select(c => c.Address).Should().BeEquivalentTo(expected);                          ClusterView.Members.Where(m => m.Address.Equals(GetAddress(_config.Eighth))).Select(m => m.Status).FirstOrDefault().Should().Be(MemberStatus.Up);                      });                  }' side1AfterJoin.ToArray());                  EnterBarrier("side2-removed");                    RunOn(() =>                  {                      foreach (var role1 in side1AfterJoin)                      {                          foreach (var role2 in side2)                          {                              TestConductor.PassThrough(role1' role2' ThrottleTransportAdapter.Direction.Both).Wait();                          }                      }                  }' _config.First);                  EnterBarrier("repair-7");                    // side2 should not detect side1 as reachable again                  Thread.Sleep(10000);                    RunOn(() =>                  {                      var expected = side1AfterJoin.Select(c => GetAddress(c)).ToImmutableHashSet();                      ClusterView.Members.Select(c => c.Address).Should().BeEquivalentTo(expected);                  }' side1AfterJoin.ToArray());                    RunOn(() =>                  {                      // side2 comes back but stays unreachable                      var expected = side2.AddRange(side1).Select(c => GetAddress(c)).ToImmutableHashSet();                      ClusterView.Members.Select(c => c.Address).Should().BeEquivalentTo(expected);                      AssertUnreachable(side1.ToArray());                  }' side2.ToArray());                    EnterBarrier("after-7");                  AssertCanTalk(side1AfterJoin.ToArray());              });
Magic Number,Akka.Cluster.Tests.MultiNode,SurviveNetworkInstabilitySpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\SurviveNetworkInstabilitySpec.cs,A_Network_partition_tolerant_cluster_must_continue_and_move_Joining_to_Up_after_downing_of_one_half,The following statement contains a magic number: Within(60.Seconds()' () =>              {                  // note that second is already removed in previous step                  var side1 = ImmutableArray.Create(_config.First' _config.Third' _config.Fourth);                  var side1AfterJoin = side1.Add(_config.Eighth);                  var side2 = ImmutableArray.Create(_config.Fifth' _config.Sixth' _config.Seventh);                    RunOn(() =>                  {                      foreach (var role1 in side1AfterJoin)                      {                          foreach (var role2 in side2)                          {                              TestConductor.Blackhole(role1' role2' ThrottleTransportAdapter.Direction.Both).Wait();                          }                      }                  }' _config.First);                  EnterBarrier("blackhole-7");                    RunOn(() =>                  {                      AssertUnreachable(side2.ToArray());                  }' side1.ToArray());                    RunOn(() =>                  {                      AssertUnreachable(side1.ToArray());                  }' side2.ToArray());                    EnterBarrier("unreachable-7");                    RunOn(() =>                  {                      Cluster.Join(GetAddress(_config.Third));                  }' _config.Eighth);                    RunOn(() =>                  {                      foreach (var role2 in side2)                      {                          Cluster.Down(GetAddress(role2));                      }                  }' _config.Fourth);                    EnterBarrier("downed-7");                    RunOn(() =>                  {                      // side2 removed                      var expected = side1AfterJoin.Select(c => GetAddress(c)).ToImmutableHashSet();                      AwaitAssert(() =>                      {                          RunOn(() =>                          {                              // repeat the downing in case it was not successful' which may                              // happen if the removal was reverted due to gossip merge                              foreach (var role2 in side2)                              {                                  Cluster.Down(GetAddress(role2));                              }                          }' _config.Fourth);                            ClusterView.Members.Select(c => c.Address).Should().BeEquivalentTo(expected);                          ClusterView.Members.Where(m => m.Address.Equals(GetAddress(_config.Eighth))).Select(m => m.Status).FirstOrDefault().Should().Be(MemberStatus.Up);                      });                  }' side1AfterJoin.ToArray());                  EnterBarrier("side2-removed");                    RunOn(() =>                  {                      foreach (var role1 in side1AfterJoin)                      {                          foreach (var role2 in side2)                          {                              TestConductor.PassThrough(role1' role2' ThrottleTransportAdapter.Direction.Both).Wait();                          }                      }                  }' _config.First);                  EnterBarrier("repair-7");                    // side2 should not detect side1 as reachable again                  Thread.Sleep(10000);                    RunOn(() =>                  {                      var expected = side1AfterJoin.Select(c => GetAddress(c)).ToImmutableHashSet();                      ClusterView.Members.Select(c => c.Address).Should().BeEquivalentTo(expected);                  }' side1AfterJoin.ToArray());                    RunOn(() =>                  {                      // side2 comes back but stays unreachable                      var expected = side2.AddRange(side1).Select(c => GetAddress(c)).ToImmutableHashSet();                      ClusterView.Members.Select(c => c.Address).Should().BeEquivalentTo(expected);                      AssertUnreachable(side1.ToArray());                  }' side2.ToArray());                    EnterBarrier("after-7");                  AssertCanTalk(side1AfterJoin.ToArray());              });
Magic Number,Akka.Cluster.Tests.MultiNode,UnreachableNodeJoinsAgainSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\UnreachableNodeJoinsAgainSpec.cs,MarkNodeAsUNREACHABLEWhenWePullTheNetwork,The following statement contains a magic number: Thread.Sleep(Dilated(TimeSpan.FromSeconds(2)));
Magic Number,Akka.Cluster.Tests.MultiNode,UnreachableNodeJoinsAgainSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\UnreachableNodeJoinsAgainSpec.cs,MarkNodeAsUNREACHABLEWhenWePullTheNetwork,The following statement contains a magic number: RunOn(() =>              {                  var victimAddress = GetAddress(_victim.Value);                  allButVictim.ForEach(name => MarkNodeAsUnavailable(GetAddress(name)));                  Within(TimeSpan.FromSeconds(30)' () =>                  {                      // victim becomes all alone                      AwaitAssert(() =>                      {                          var members = ClusterView.Members; // to snapshot the object                          Assert.Equal(Roles.Count - 1' ClusterView.UnreachableMembers.Count);                      });                      var addresses = allButVictim.Select(GetAddress).ToList();                      Assert.True(ClusterView.UnreachableMembers.Select(x => x.Address).All(y => addresses.Contains(y)));                  });              }' _victim.Value);
Magic Number,Akka.Cluster.Tests.MultiNode,UnreachableNodeJoinsAgainSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\UnreachableNodeJoinsAgainSpec.cs,MarkNodeAsUNREACHABLEWhenWePullTheNetwork,The following statement contains a magic number: RunOn(() =>              {                  MarkNodeAsUnavailable(GetAddress(_victim.Value));                  Within(TimeSpan.FromSeconds(30)' () =>                  {                      // victim becomes unreachable                      AwaitAssert(() =>                      {                          var members = ClusterView.Members; // to snapshot the object                          Assert.Single(ClusterView.UnreachableMembers);                      });                      AwaitSeenSameState(allButVictim.Select(GetAddress).ToArray());                        // still once unreachable                      Assert.Single(ClusterView.UnreachableMembers);                      Assert.Equal(Node(_victim.Value).Address' ClusterView.UnreachableMembers.First().Address);                      Assert.Equal(MemberStatus.Up' ClusterView.UnreachableMembers.First().Status);                  });              }' allButVictim);
Magic Number,Akka.Cluster.Tests.MultiNode,UnreachableNodeJoinsAgainSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\UnreachableNodeJoinsAgainSpec.cs,MarkTheNodeAsDOWN,The following statement contains a magic number: RunOn(() =>              {                  // eventually removed                  AwaitMembersUp(Roles.Count - 1' ImmutableHashSet.Create(GetAddress(_victim.Value)));                  AwaitAssert(() => Assert.True(ClusterView.UnreachableMembers.IsEmpty)' TimeSpan.FromSeconds(15));                  var addresses = allButVictim.Select(GetAddress).ToList();                  AwaitAssert(() => Assert.True(ClusterView.Members.Select(x => x.Address).All(y => addresses.Contains(y))));              }' allButVictim);
Magic Number,Akka.Cluster.Tests.MultiNode,UnreachableNodeJoinsAgainSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\UnreachableNodeJoinsAgainSpec.cs,AllowFreshNodeWithSameHostAndPortToJoinAgainWhenTheNetworkIsPluggedBackIn,The following statement contains a magic number: RunOn(() =>              {                  var victimAddress = Sys.AsInstanceOf<ExtendedActorSystem>().Provider.DefaultAddress;                  Sys.WhenTerminated.Wait(TimeSpan.FromSeconds(10));                    // create new ActorSystem with same host:port                  var freshSystem = ActorSystem.Create(Sys.Name' ConfigurationFactory.ParseString(@"akka.remote.dot-netty.tcp{                      hostname = "+ victimAddress.Host + @"                      port = "+ victimAddress.Port + @"                  }").WithFallback(Sys.Settings.Config));                    try                  {                      Cluster.Get(freshSystem).Join(masterAddress);                      Within(TimeSpan.FromSeconds(15)' () =>                      {                          AwaitAssert(() => Assert.Contains(victimAddress' Cluster.Get(freshSystem).ReadView.Members.Select(x => x.Address)));                          AwaitAssert(() => Assert.Equal(expectedNumberOfMembers'Cluster.Get(freshSystem).ReadView.Members.Count));                          AwaitAssert(() => Assert.True(Cluster.Get(freshSystem).ReadView.Members.All(y => y.Status == MemberStatus.Up)));                      });                        // signal to master node that victim is done                      var endProbe = CreateTestProbe(freshSystem);                      var endActor = freshSystem.ActorOf(Props.Create(() => new EndActor(endProbe.Ref' masterAddress))'                          "end");                      endActor.Tell(EndActor.SendEnd.Instance);                      endProbe.ExpectMsg<EndActor.EndAck>();                  }                  finally                  {                      Shutdown(freshSystem);                  }                  // no barrier here' because it is not part of testConductor roles any more              }' _victim.Value);
Magic Number,Akka.Cluster.Tests.MultiNode,UnreachableNodeJoinsAgainSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\UnreachableNodeJoinsAgainSpec.cs,AllowFreshNodeWithSameHostAndPortToJoinAgainWhenTheNetworkIsPluggedBackIn,The following statement contains a magic number: RunOn(() =>              {                  var victimAddress = Sys.AsInstanceOf<ExtendedActorSystem>().Provider.DefaultAddress;                  Sys.WhenTerminated.Wait(TimeSpan.FromSeconds(10));                    // create new ActorSystem with same host:port                  var freshSystem = ActorSystem.Create(Sys.Name' ConfigurationFactory.ParseString(@"akka.remote.dot-netty.tcp{                      hostname = "+ victimAddress.Host + @"                      port = "+ victimAddress.Port + @"                  }").WithFallback(Sys.Settings.Config));                    try                  {                      Cluster.Get(freshSystem).Join(masterAddress);                      Within(TimeSpan.FromSeconds(15)' () =>                      {                          AwaitAssert(() => Assert.Contains(victimAddress' Cluster.Get(freshSystem).ReadView.Members.Select(x => x.Address)));                          AwaitAssert(() => Assert.Equal(expectedNumberOfMembers'Cluster.Get(freshSystem).ReadView.Members.Count));                          AwaitAssert(() => Assert.True(Cluster.Get(freshSystem).ReadView.Members.All(y => y.Status == MemberStatus.Up)));                      });                        // signal to master node that victim is done                      var endProbe = CreateTestProbe(freshSystem);                      var endActor = freshSystem.ActorOf(Props.Create(() => new EndActor(endProbe.Ref' masterAddress))'                          "end");                      endActor.Tell(EndActor.SendEnd.Instance);                      endProbe.ExpectMsg<EndActor.EndAck>();                  }                  finally                  {                      Shutdown(freshSystem);                  }                  // no barrier here' because it is not part of testConductor roles any more              }' _victim.Value);
Magic Number,Akka.Cluster.Tests.MultiNode,UnreachableNodeJoinsAgainSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\UnreachableNodeJoinsAgainSpec.cs,AllowFreshNodeWithSameHostAndPortToJoinAgainWhenTheNetworkIsPluggedBackIn,The following statement contains a magic number: RunOn(() =>              {                  AwaitMembersUp(expectedNumberOfMembers);                  // don't end the test until the freshSystem is done                  RunOn(() =>                  {                      ExpectMsg<EndActor.End>(TimeSpan.FromSeconds(20));                  }' _master.Value);                  EndBarrier();              }' AllBut(_victim.Value).ToArray());
Magic Number,Akka.Cluster.TestKit,ClientDowningNodeThatIsUpSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ClientDowningNodeThatIsUpSpec.cs,Client_of_4_node_cluster_must_be_able_to_DOWN_a_node_that_is_UP,The following statement contains a magic number: RunOn(() =>              {                  Cluster.Down(thirdAddress);                  EnterBarrier("down-third-node");                    MarkNodeAsUnavailable(thirdAddress);                    AwaitMembersUp(3' ImmutableHashSet.Create(thirdAddress));                    ClusterView.Members.Any(x => x.Address == thirdAddress).ShouldBeFalse();              }' _config.First);
Magic Number,Akka.Cluster.TestKit,ClientDowningNodeThatIsUpSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\ClientDowningNodeThatIsUpSpec.cs,Client_of_4_node_cluster_must_be_able_to_DOWN_a_node_that_is_UP,The following statement contains a magic number: RunOn(() =>              {                  EnterBarrier("down-third-node");                    AwaitMembersUp(3' ImmutableHashSet.Create(thirdAddress));              }' _config.Second' _config.Fourth);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterBroadcastGroupSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterBroadcastRouter2266BugfixSpec.cs,ReceiveReplays,The following statement contains a magic number: var replays = ReceiveWhile(5.Seconds()' msg =>              {                  var routee = msg as ClusterBroadcastGroupSpecConfig.Reply;                  if (routee != null && routee.RouteeType.GetType() == routeeType.GetType())                      return FullAddress(routee.ActorRef);                  return null;              }' expectedReplies).Aggregate(zero' (replyMap' address) =>              {                  replyMap[address]++;                  return replyMap;              });
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterBroadcastGroupSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterBroadcastRouter2266BugfixSpec.cs,A_cluster_router_with_a_BroadcastGroup_router_must_lookup_routees_on_the_member_nodes_in_the_cluster,The following statement contains a magic number: RunOn(() =>              {                  // 2 nodes' 1 routees on each node                  Within(10.Seconds()' () =>                  {                      AwaitAssert(() => CurrentRoutees(_router.Value).Count().Should().Be(2)); //only seems to pass with a single routee should be 2                  });                    var routeeCount = CurrentRoutees(_router.Value).Count();                  var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      _router.Value.Tell("hit");                  }                    var replays = ReceiveReplays(new ClusterBroadcastGroupSpecConfig.GroupRoutee()' iterationCount*routeeCount);                    replays[GetAddress(_config.First)].Should().Be(10);                  replays[GetAddress(_config.Second)].Should().Be(10);                  replays.Values.Sum().Should().Be(iterationCount*routeeCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterBroadcastGroupSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterBroadcastRouter2266BugfixSpec.cs,A_cluster_router_with_a_BroadcastGroup_router_must_lookup_routees_on_the_member_nodes_in_the_cluster,The following statement contains a magic number: RunOn(() =>              {                  // 2 nodes' 1 routees on each node                  Within(10.Seconds()' () =>                  {                      AwaitAssert(() => CurrentRoutees(_router.Value).Count().Should().Be(2)); //only seems to pass with a single routee should be 2                  });                    var routeeCount = CurrentRoutees(_router.Value).Count();                  var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      _router.Value.Tell("hit");                  }                    var replays = ReceiveReplays(new ClusterBroadcastGroupSpecConfig.GroupRoutee()' iterationCount*routeeCount);                    replays[GetAddress(_config.First)].Should().Be(10);                  replays[GetAddress(_config.Second)].Should().Be(10);                  replays.Values.Sum().Should().Be(iterationCount*routeeCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterBroadcastGroupSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterBroadcastRouter2266BugfixSpec.cs,A_cluster_router_with_a_BroadcastGroup_router_must_lookup_routees_on_the_member_nodes_in_the_cluster,The following statement contains a magic number: RunOn(() =>              {                  // 2 nodes' 1 routees on each node                  Within(10.Seconds()' () =>                  {                      AwaitAssert(() => CurrentRoutees(_router.Value).Count().Should().Be(2)); //only seems to pass with a single routee should be 2                  });                    var routeeCount = CurrentRoutees(_router.Value).Count();                  var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      _router.Value.Tell("hit");                  }                    var replays = ReceiveReplays(new ClusterBroadcastGroupSpecConfig.GroupRoutee()' iterationCount*routeeCount);                    replays[GetAddress(_config.First)].Should().Be(10);                  replays[GetAddress(_config.Second)].Should().Be(10);                  replays.Values.Sum().Should().Be(iterationCount*routeeCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterBroadcastGroupSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterBroadcastRouter2266BugfixSpec.cs,A_cluster_router_with_a_BroadcastGroup_router_must_lookup_routees_on_the_member_nodes_in_the_cluster,The following statement contains a magic number: RunOn(() =>              {                  // 2 nodes' 1 routees on each node                  Within(10.Seconds()' () =>                  {                      AwaitAssert(() => CurrentRoutees(_router.Value).Count().Should().Be(2)); //only seems to pass with a single routee should be 2                  });                    var routeeCount = CurrentRoutees(_router.Value).Count();                  var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      _router.Value.Tell("hit");                  }                    var replays = ReceiveReplays(new ClusterBroadcastGroupSpecConfig.GroupRoutee()' iterationCount*routeeCount);                    replays[GetAddress(_config.First)].Should().Be(10);                  replays[GetAddress(_config.Second)].Should().Be(10);                  replays.Values.Sum().Should().Be(iterationCount*routeeCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterBroadcastGroupSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterBroadcastRouter2266BugfixSpec.cs,A_cluster_router_with_a_BroadcastGroup_router_must_lookup_routees_on_the_member_nodes_in_the_cluster,The following statement contains a magic number: RunOn(() =>              {                  // 2 nodes' 1 routees on each node                  Within(10.Seconds()' () =>                  {                      AwaitAssert(() => CurrentRoutees(_router.Value).Count().Should().Be(2)); //only seems to pass with a single routee should be 2                  });                    var routeeCount = CurrentRoutees(_router.Value).Count();                  var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      _router.Value.Tell("hit");                  }                    var replays = ReceiveReplays(new ClusterBroadcastGroupSpecConfig.GroupRoutee()' iterationCount*routeeCount);                    replays[GetAddress(_config.First)].Should().Be(10);                  replays[GetAddress(_config.Second)].Should().Be(10);                  replays.Values.Sum().Should().Be(iterationCount*routeeCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterConsistentHashingGroupSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterConsistentHashingGroupSpec.cs,A_cluster_router_with_consistent_hashing_group_must_send_to_same_destinations_from_different_nodes,The following statement contains a magic number: var router =                  Sys.ActorOf(                      new ClusterRouterGroup(                          local: new ConsistentHashingGroup(paths).WithHashMapping(hashMapping)'                          settings: new ClusterRouterGroupSettings(                              10'                              ImmutableHashSet.Create(paths.ToArray())'                              allowLocalRoutees: true'                              useRole: null))                          .Props()' "router");
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterConsistentHashingGroupSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterConsistentHashingGroupSpec.cs,A_cluster_router_with_consistent_hashing_group_must_send_to_same_destinations_from_different_nodes,The following statement contains a magic number: AwaitAssert(() =>              {                  CurrentRoutees(router).Members.Should().HaveCount(3);              });
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterConsistentHashingGroupSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterConsistentHashingGroupSpec.cs,A_cluster_router_with_consistent_hashing_group_must_send_to_same_destinations_from_different_nodes,The following statement contains a magic number: Enumerable.Range(1' 10).SelectMany(i => keys)
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterConsistentHashingRouterSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterConsistentHashingRouterSpec.cs,AssertHashMapping,The following statement contains a magic number: AwaitAssert(() =>              {                  CurrentRoutees(router).Count().ShouldBe(6);              });
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterConsistentHashingRouterSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterConsistentHashingRouterSpec.cs,A_cluster_router_with_consistent_hashing_pool_must_create_routees_from_configuration,The following statement contains a magic number: RunOn(() =>              {                  // it may take some time until router receives cluster member events                  AwaitAssert(() =>                  {                      CurrentRoutees(router1.Value).Should().HaveCount(4);                  });                  var routees = CurrentRoutees(router1.Value);                  routees                      .Select(x => FullAddress(((ActorRefRoutee)x).Actor))                      .ToImmutableHashSet()                      .Should()                      .BeEquivalentTo(new List<Address> { GetAddress(_config.First)' GetAddress(_config.Second) });              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterConsistentHashingRouterSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterConsistentHashingRouterSpec.cs,A_cluster_router_with_consistent_hashing_pool_must_deploy_routees_to_new_member_nodes_in_the_cluster,The following statement contains a magic number: RunOn(() =>              {                  //it may take some time until router receives cluster member events                  AwaitAssert(() =>                  {                      CurrentRoutees(router1.Value).Should().HaveCount(6);                  });                  var routees = CurrentRoutees(router1.Value);                  var routerMembers = routees.Select(x => FullAddress(((ActorRefRoutee)x).Actor)).Distinct().ToList();                  routerMembers.Should().BeEquivalentTo(Roles.Select(GetAddress).ToList());              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterConsistentHashingRouterSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterConsistentHashingRouterSpec.cs,A_cluster_router_with_consistent_hashing_pool_must_deploy_programatically_defined_routees_to_the_member_nodes_in_the_cluster,The following statement contains a magic number: RunOn(() =>              {                  var router2 =                      Sys.ActorOf(                          new ClusterRouterPool(                              local: new ConsistentHashingPool(nrOfInstances: 0)'                              settings: new ClusterRouterPoolSettings(                                  10'                                  2'                                  allowLocalRoutees: true'                                  useRole: null)).Props(Props.Create<ConsistentHashingRouterMultiNodeConfig.Echo>())' "router2");                    //it may take some time until router receives cluster member events                  AwaitAssert(() =>                  {                      CurrentRoutees(router2).Should().HaveCount(6);                  });                  var routees = CurrentRoutees(router2);                  var routerMembers = routees.Select(x => FullAddress(((ActorRefRoutee)x).Actor)).Distinct().ToList();                  routerMembers.Should().BeEquivalentTo(Roles.Select(GetAddress).ToList());              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterConsistentHashingRouterSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterConsistentHashingRouterSpec.cs,A_cluster_router_with_consistent_hashing_pool_must_deploy_programatically_defined_routees_to_the_member_nodes_in_the_cluster,The following statement contains a magic number: RunOn(() =>              {                  var router2 =                      Sys.ActorOf(                          new ClusterRouterPool(                              local: new ConsistentHashingPool(nrOfInstances: 0)'                              settings: new ClusterRouterPoolSettings(                                  10'                                  2'                                  allowLocalRoutees: true'                                  useRole: null)).Props(Props.Create<ConsistentHashingRouterMultiNodeConfig.Echo>())' "router2");                    //it may take some time until router receives cluster member events                  AwaitAssert(() =>                  {                      CurrentRoutees(router2).Should().HaveCount(6);                  });                  var routees = CurrentRoutees(router2);                  var routerMembers = routees.Select(x => FullAddress(((ActorRefRoutee)x).Actor)).Distinct().ToList();                  routerMembers.Should().BeEquivalentTo(Roles.Select(GetAddress).ToList());              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterConsistentHashingRouterSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterConsistentHashingRouterSpec.cs,A_cluster_router_with_consistent_hashing_pool_must_deploy_programatically_defined_routees_to_the_member_nodes_in_the_cluster,The following statement contains a magic number: RunOn(() =>              {                  var router2 =                      Sys.ActorOf(                          new ClusterRouterPool(                              local: new ConsistentHashingPool(nrOfInstances: 0)'                              settings: new ClusterRouterPoolSettings(                                  10'                                  2'                                  allowLocalRoutees: true'                                  useRole: null)).Props(Props.Create<ConsistentHashingRouterMultiNodeConfig.Echo>())' "router2");                    //it may take some time until router receives cluster member events                  AwaitAssert(() =>                  {                      CurrentRoutees(router2).Should().HaveCount(6);                  });                  var routees = CurrentRoutees(router2);                  var routerMembers = routees.Select(x => FullAddress(((ActorRefRoutee)x).Actor)).Distinct().ToList();                  routerMembers.Should().BeEquivalentTo(Roles.Select(GetAddress).ToList());              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterConsistentHashingRouterSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterConsistentHashingRouterSpec.cs,A_cluster_router_with_consistent_hashing_pool_must_handle_combination_of_configured_router_and_programatically_defined_hash_mapping_and_cluster_config,The following statement contains a magic number: RunOn(() =>              {                  ConsistentHashMapping hashMapping = msg =>                  {                      if (msg is string) return msg;                      return null;                  };                    var router4 =                      Sys.ActorOf(                          new ClusterRouterPool(                              local: new ConsistentHashingPool(0).WithHashMapping(hashMapping)'                              settings: new ClusterRouterPoolSettings(                                  10'                                  1'                                  allowLocalRoutees: true'                                  useRole: null)).Props(Props.Create<ConsistentHashingRouterMultiNodeConfig.Echo>())' "router4");                    AssertHashMapping(router4);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterConsistentHashingRouterSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterConsistentHashingRouterSpec.cs,A_cluster_router_with_consistent_hashing_pool_must_remove_routees_from_downed_node,The following statement contains a magic number: RunOn(() =>              {                  Cluster.Down(GetAddress(_config.Third));                  //removed                  AwaitAssert(() => Assert.DoesNotContain(GetAddress(_config.Third)' ClusterView.UnreachableMembers.Select(x => x.Address)));                  AwaitAssert(() => Assert.DoesNotContain(GetAddress(_config.Third)' ClusterView.Members.Select(x => x.Address)));                    // it may take some time until router receives cluster member events                  AwaitAssert(() =>                  {                      CurrentRoutees(router1.Value).Count().ShouldBe(4);                  });                  var routees = CurrentRoutees(router1.Value);                  var routerMembers = routees.Select(x => FullAddress(((ActorRefRoutee)x).Actor)).Distinct().ToList();                  routerMembers.ShouldBe(new List<Address>() { GetAddress(_config.First)' GetAddress(_config.Second) });                }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,ClusterRoundRobinSpec,The following statement contains a magic number: router2 = new Lazy<IActorRef>(() => Sys.ActorOf(                  new ClusterRouterPool(                      new RoundRobinPool(0)'                      new ClusterRouterPoolSettings(3' 1' true' null)).Props(Props.Create<ClusterRoundRobinSpecConfig.SomeActor>())'                  "router2"));
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,ReceiveReplays,The following statement contains a magic number: var replays = ReceiveWhile(5.Seconds()' msg =>              {                  var routee = msg as ClusterRoundRobinSpecConfig.Reply;                  if (routee != null && routee.RouteeType.GetType() == routeeType.GetType())                      return FullAddress(routee.ActorRef);                  return null;              }' expectedReplies).Aggregate(zero' (replyMap' address) =>              {                  replyMap[address]++;                  return replyMap;              });
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,A_cluster_router_with_a_RoundRobin_router_must_deploy_routees_to_the_member_nodes_in_the_cluster,The following statement contains a magic number: RunOn(() =>              {                  router1.Value.Should().BeOfType<RoutedActorRef>();                    // max-nr-of-instances-per-node=2 times 2 nodes                  AwaitAssert(() => CurrentRoutees(router1.Value).Count().Should().Be(4));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router1.Value.Tell("hit");                  }                    var replays = ReceiveReplays(new ClusterRoundRobinSpecConfig.PoolRoutee()' iterationCount);                    replays[GetAddress(_config.First)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().Be(0);                  replays[GetAddress(_config.Fourth)].Should().Be(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,A_cluster_router_with_a_RoundRobin_router_must_deploy_routees_to_the_member_nodes_in_the_cluster,The following statement contains a magic number: RunOn(() =>              {                  router1.Value.Should().BeOfType<RoutedActorRef>();                    // max-nr-of-instances-per-node=2 times 2 nodes                  AwaitAssert(() => CurrentRoutees(router1.Value).Count().Should().Be(4));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router1.Value.Tell("hit");                  }                    var replays = ReceiveReplays(new ClusterRoundRobinSpecConfig.PoolRoutee()' iterationCount);                    replays[GetAddress(_config.First)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().Be(0);                  replays[GetAddress(_config.Fourth)].Should().Be(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,A_cluster_router_with_a_RoundRobin_router_must_lookup_routees_on_the_member_nodes_in_the_cluster,The following statement contains a magic number: RunOn(() =>              {                  // 2 nodes' 2 routees on each node                  Within(10.Seconds()' () =>                  {                      AwaitAssert(() => CurrentRoutees(router4.Value).Count().Should().Be(4));                  });                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router4.Value.Tell("hit");                  }                    var replays = ReceiveReplays(new ClusterRoundRobinSpecConfig.GroupRoutee()' iterationCount);                    replays[GetAddress(_config.First)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().Be(0);                  replays[GetAddress(_config.Fourth)].Should().Be(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,A_cluster_router_with_a_RoundRobin_router_must_lookup_routees_on_the_member_nodes_in_the_cluster,The following statement contains a magic number: RunOn(() =>              {                  // 2 nodes' 2 routees on each node                  Within(10.Seconds()' () =>                  {                      AwaitAssert(() => CurrentRoutees(router4.Value).Count().Should().Be(4));                  });                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router4.Value.Tell("hit");                  }                    var replays = ReceiveReplays(new ClusterRoundRobinSpecConfig.GroupRoutee()' iterationCount);                    replays[GetAddress(_config.First)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().Be(0);                  replays[GetAddress(_config.Fourth)].Should().Be(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,A_cluster_router_with_a_RoundRobin_router_must_lookup_routees_on_the_member_nodes_in_the_cluster,The following statement contains a magic number: RunOn(() =>              {                  // 2 nodes' 2 routees on each node                  Within(10.Seconds()' () =>                  {                      AwaitAssert(() => CurrentRoutees(router4.Value).Count().Should().Be(4));                  });                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router4.Value.Tell("hit");                  }                    var replays = ReceiveReplays(new ClusterRoundRobinSpecConfig.GroupRoutee()' iterationCount);                    replays[GetAddress(_config.First)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().Be(0);                  replays[GetAddress(_config.Fourth)].Should().Be(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,A_cluster_router_with_a_RoundRobin_router_must_deploy_routees_to_new_nodes_in_the_cluster,The following statement contains a magic number: RunOn(() =>              {                  // max-nr-of-instances-per-node=2 times 4 nodes                  AwaitAssert(() => CurrentRoutees(router1.Value).Count().Should().Be(8));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router1.Value.Tell("hit");                  }                    var replays = ReceiveReplays(new ClusterRoundRobinSpecConfig.PoolRoutee()' iterationCount);                    replays.Values.ForEach(x => x.Should().BeGreaterThan(0));                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,A_cluster_router_with_a_RoundRobin_router_must_deploy_routees_to_new_nodes_in_the_cluster,The following statement contains a magic number: RunOn(() =>              {                  // max-nr-of-instances-per-node=2 times 4 nodes                  AwaitAssert(() => CurrentRoutees(router1.Value).Count().Should().Be(8));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router1.Value.Tell("hit");                  }                    var replays = ReceiveReplays(new ClusterRoundRobinSpecConfig.PoolRoutee()' iterationCount);                    replays.Values.ForEach(x => x.Should().BeGreaterThan(0));                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,A_cluster_router_with_a_RoundRobin_router_must_lookup_routees_on_new_nodes_in_the_cluster,The following statement contains a magic number: RunOn(() =>              {                  // 4 nodes' 2 routee on each node                  AwaitAssert(() => CurrentRoutees(router4.Value).Count().Should().Be(8));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router4.Value.Tell("hit");                  }                    var replays = ReceiveReplays(new ClusterRoundRobinSpecConfig.GroupRoutee()' iterationCount);                    replays.Values.ForEach(x => x.Should().BeGreaterThan(0));                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,A_cluster_router_with_a_RoundRobin_router_must_lookup_routees_on_new_nodes_in_the_cluster,The following statement contains a magic number: RunOn(() =>              {                  // 4 nodes' 2 routee on each node                  AwaitAssert(() => CurrentRoutees(router4.Value).Count().Should().Be(8));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router4.Value.Tell("hit");                  }                    var replays = ReceiveReplays(new ClusterRoundRobinSpecConfig.GroupRoutee()' iterationCount);                    replays.Values.ForEach(x => x.Should().BeGreaterThan(0));                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,A_cluster_router_with_a_RoundRobin_router_must_deploy_routees_to_only_remote_nodes_when_allowlocalrouteesoff,The following statement contains a magic number: RunOn(() =>              {                  // max-nr-of-instances-per-node=1 times 3 nodes                  AwaitAssert(() => CurrentRoutees(router3.Value).Count().Should().Be(3));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router3.Value.Tell("hit");                  }                    var replays = ReceiveReplays(new ClusterRoundRobinSpecConfig.PoolRoutee()' iterationCount);                    replays[GetAddress(_config.First)].Should().Be(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Fourth)].Should().BeGreaterThan(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,A_cluster_router_with_a_RoundRobin_router_must_deploy_routees_to_only_remote_nodes_when_allowlocalrouteesoff,The following statement contains a magic number: RunOn(() =>              {                  // max-nr-of-instances-per-node=1 times 3 nodes                  AwaitAssert(() => CurrentRoutees(router3.Value).Count().Should().Be(3));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router3.Value.Tell("hit");                  }                    var replays = ReceiveReplays(new ClusterRoundRobinSpecConfig.PoolRoutee()' iterationCount);                    replays[GetAddress(_config.First)].Should().Be(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Fourth)].Should().BeGreaterThan(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,A_cluster_router_with_a_RoundRobin_router_must_deploy_routees_to_specified_node_role,The following statement contains a magic number: RunOn(() =>              {                  AwaitAssert(() => CurrentRoutees(router5.Value).Count().Should().Be(2));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router5.Value.Tell("hit");                  }                    var replays = ReceiveReplays(new ClusterRoundRobinSpecConfig.PoolRoutee()' iterationCount);                    replays[GetAddress(_config.First)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().Be(0);                  replays[GetAddress(_config.Fourth)].Should().Be(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,A_cluster_router_with_a_RoundRobin_router_must_deploy_routees_to_specified_node_role,The following statement contains a magic number: RunOn(() =>              {                  AwaitAssert(() => CurrentRoutees(router5.Value).Count().Should().Be(2));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router5.Value.Tell("hit");                  }                    var replays = ReceiveReplays(new ClusterRoundRobinSpecConfig.PoolRoutee()' iterationCount);                    replays[GetAddress(_config.First)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().Be(0);                  replays[GetAddress(_config.Fourth)].Should().Be(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,A_cluster_router_with_a_RoundRobin_router_must_deploy_programatically_defined_routees_to_the_member_nodes_in_the_cluster,The following statement contains a magic number: RunOn(() =>              {                  router2.Value.Should().BeOfType<RoutedActorRef>();                    // totalInstances = 3' maxInstancesPerNode = 1                  AwaitAssert(() => CurrentRoutees(router2.Value).Count().Should().Be(3));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router2.Value.Tell("hit");                  }                    var replays = ReceiveReplays(new ClusterRoundRobinSpecConfig.PoolRoutee()' iterationCount);                                    // note that router2 has totalInstances = 3' maxInstancesPerNode = 1                  var routees = CurrentRoutees(router2.Value);                  var routeeAddresses = routees.Where(c => c is ActorRefRoutee).Select(c => FullAddress(((ActorRefRoutee)c).Actor));                    routeeAddresses.Count().Should().Be(3);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,A_cluster_router_with_a_RoundRobin_router_must_deploy_programatically_defined_routees_to_the_member_nodes_in_the_cluster,The following statement contains a magic number: RunOn(() =>              {                  router2.Value.Should().BeOfType<RoutedActorRef>();                    // totalInstances = 3' maxInstancesPerNode = 1                  AwaitAssert(() => CurrentRoutees(router2.Value).Count().Should().Be(3));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router2.Value.Tell("hit");                  }                    var replays = ReceiveReplays(new ClusterRoundRobinSpecConfig.PoolRoutee()' iterationCount);                                    // note that router2 has totalInstances = 3' maxInstancesPerNode = 1                  var routees = CurrentRoutees(router2.Value);                  var routeeAddresses = routees.Where(c => c is ActorRefRoutee).Select(c => FullAddress(((ActorRefRoutee)c).Actor));                    routeeAddresses.Count().Should().Be(3);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,A_cluster_router_with_a_RoundRobin_router_must_deploy_programatically_defined_routees_to_the_member_nodes_in_the_cluster,The following statement contains a magic number: RunOn(() =>              {                  router2.Value.Should().BeOfType<RoutedActorRef>();                    // totalInstances = 3' maxInstancesPerNode = 1                  AwaitAssert(() => CurrentRoutees(router2.Value).Count().Should().Be(3));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router2.Value.Tell("hit");                  }                    var replays = ReceiveReplays(new ClusterRoundRobinSpecConfig.PoolRoutee()' iterationCount);                                    // note that router2 has totalInstances = 3' maxInstancesPerNode = 1                  var routees = CurrentRoutees(router2.Value);                  var routeeAddresses = routees.Where(c => c is ActorRefRoutee).Select(c => FullAddress(((ActorRefRoutee)c).Actor));                    routeeAddresses.Count().Should().Be(3);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,A_cluster_router_with_a_RoundRobin_router_must_remove_routees_for_unreachable_nodes_and_add_when_reachable_again,The following statement contains a magic number: Within(30.Seconds()' () =>              {                  // myservice is already running                    Func<List<Routee>> routees = () => CurrentRoutees(router4.Value).ToList();                  Func<List<Address>> routeeAddresses = () => routees()                          .Where(c => c is ActorSelectionRoutee)                          .Select(c => FullAddress(((ActorSelectionRoutee)c).Selection.Anchor))                          .ToList();                    RunOn(() =>                  {                      // 4 nodes' 2 routees on each node                      AwaitAssert(() => CurrentRoutees(router4.Value).Count().Should().Be(8));                        TestConductor.Blackhole(_config.First' _config.Second' ThrottleTransportAdapter.Direction.Both).Wait();                        AwaitAssert(() => routees().Count.Should().Be(6));                      routeeAddresses().Should().NotContain(GetAddress(_config.Second));                        TestConductor.PassThrough(_config.First' _config.Second' ThrottleTransportAdapter.Direction.Both);                      AwaitAssert(() => routees().Count.Should().Be(8));                      routeeAddresses().Should().Contain(GetAddress(_config.Second));                  }' _config.First);              });
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,A_cluster_router_with_a_RoundRobin_router_must_remove_routees_for_unreachable_nodes_and_add_when_reachable_again,The following statement contains a magic number: Within(30.Seconds()' () =>              {                  // myservice is already running                    Func<List<Routee>> routees = () => CurrentRoutees(router4.Value).ToList();                  Func<List<Address>> routeeAddresses = () => routees()                          .Where(c => c is ActorSelectionRoutee)                          .Select(c => FullAddress(((ActorSelectionRoutee)c).Selection.Anchor))                          .ToList();                    RunOn(() =>                  {                      // 4 nodes' 2 routees on each node                      AwaitAssert(() => CurrentRoutees(router4.Value).Count().Should().Be(8));                        TestConductor.Blackhole(_config.First' _config.Second' ThrottleTransportAdapter.Direction.Both).Wait();                        AwaitAssert(() => routees().Count.Should().Be(6));                      routeeAddresses().Should().NotContain(GetAddress(_config.Second));                        TestConductor.PassThrough(_config.First' _config.Second' ThrottleTransportAdapter.Direction.Both);                      AwaitAssert(() => routees().Count.Should().Be(8));                      routeeAddresses().Should().Contain(GetAddress(_config.Second));                  }' _config.First);              });
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,A_cluster_router_with_a_RoundRobin_router_must_remove_routees_for_unreachable_nodes_and_add_when_reachable_again,The following statement contains a magic number: Within(30.Seconds()' () =>              {                  // myservice is already running                    Func<List<Routee>> routees = () => CurrentRoutees(router4.Value).ToList();                  Func<List<Address>> routeeAddresses = () => routees()                          .Where(c => c is ActorSelectionRoutee)                          .Select(c => FullAddress(((ActorSelectionRoutee)c).Selection.Anchor))                          .ToList();                    RunOn(() =>                  {                      // 4 nodes' 2 routees on each node                      AwaitAssert(() => CurrentRoutees(router4.Value).Count().Should().Be(8));                        TestConductor.Blackhole(_config.First' _config.Second' ThrottleTransportAdapter.Direction.Both).Wait();                        AwaitAssert(() => routees().Count.Should().Be(6));                      routeeAddresses().Should().NotContain(GetAddress(_config.Second));                        TestConductor.PassThrough(_config.First' _config.Second' ThrottleTransportAdapter.Direction.Both);                      AwaitAssert(() => routees().Count.Should().Be(8));                      routeeAddresses().Should().Contain(GetAddress(_config.Second));                  }' _config.First);              });
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,A_cluster_router_with_a_RoundRobin_router_must_remove_routees_for_unreachable_nodes_and_add_when_reachable_again,The following statement contains a magic number: Within(30.Seconds()' () =>              {                  // myservice is already running                    Func<List<Routee>> routees = () => CurrentRoutees(router4.Value).ToList();                  Func<List<Address>> routeeAddresses = () => routees()                          .Where(c => c is ActorSelectionRoutee)                          .Select(c => FullAddress(((ActorSelectionRoutee)c).Selection.Anchor))                          .ToList();                    RunOn(() =>                  {                      // 4 nodes' 2 routees on each node                      AwaitAssert(() => CurrentRoutees(router4.Value).Count().Should().Be(8));                        TestConductor.Blackhole(_config.First' _config.Second' ThrottleTransportAdapter.Direction.Both).Wait();                        AwaitAssert(() => routees().Count.Should().Be(6));                      routeeAddresses().Should().NotContain(GetAddress(_config.Second));                        TestConductor.PassThrough(_config.First' _config.Second' ThrottleTransportAdapter.Direction.Both);                      AwaitAssert(() => routees().Count.Should().Be(8));                      routeeAddresses().Should().Contain(GetAddress(_config.Second));                  }' _config.First);              });
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,A_cluster_router_with_a_RoundRobin_router_must_deploy_programatically_defined_routees_to_other_node_when_a_node_becomes_down,The following statement contains a magic number: RunOn(() =>              {                  Func<List<Routee>> routees = () => CurrentRoutees(router2.Value).ToList();                  Func<List<Address>> routeeAddresses = () => routees()                      .Where(c => c is ActorRefRoutee)                      .Select(c => FullAddress(((ActorRefRoutee)c).Actor)).ToList();                    routees().ForEach(actorRef =>                  {                      var actorRefRoutee = actorRef as ActorRefRoutee;                      if (actorRefRoutee != null)                      {                          Watch(actorRefRoutee.Actor);                      }                  });                    var notUsedAddress = Roles.Select(c => GetAddress(c)).Except(routeeAddresses()).First();                  var downAddress = routeeAddresses().Find(c => c != GetAddress(_config.First));                  var downRouteeRef = routees()                      .Where(c => c is ActorRefRoutee && ((ActorRefRoutee)c).Actor.Path.Address == downAddress)                      .Select(c => ((ActorRefRoutee)c).Actor).First();                    Cluster.Down(downAddress);                  ExpectMsg<Terminated>(15.Seconds()).ActorRef.Should().Be(downRouteeRef);                  AwaitAssert(() =>                  {                      routeeAddresses().Should().Contain(notUsedAddress);                      routeeAddresses().Should().NotContain(downAddress);                  });                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router2.Value.Tell("hit");                  }                    var replays = ReceiveReplays(new ClusterRoundRobinSpecConfig.PoolRoutee()' iterationCount);                  routeeAddresses().Count.Should().Be(3);                  replays.Values.Sum().Should().Be(iterationCount);                }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,A_cluster_router_with_a_RoundRobin_router_must_deploy_programatically_defined_routees_to_other_node_when_a_node_becomes_down,The following statement contains a magic number: RunOn(() =>              {                  Func<List<Routee>> routees = () => CurrentRoutees(router2.Value).ToList();                  Func<List<Address>> routeeAddresses = () => routees()                      .Where(c => c is ActorRefRoutee)                      .Select(c => FullAddress(((ActorRefRoutee)c).Actor)).ToList();                    routees().ForEach(actorRef =>                  {                      var actorRefRoutee = actorRef as ActorRefRoutee;                      if (actorRefRoutee != null)                      {                          Watch(actorRefRoutee.Actor);                      }                  });                    var notUsedAddress = Roles.Select(c => GetAddress(c)).Except(routeeAddresses()).First();                  var downAddress = routeeAddresses().Find(c => c != GetAddress(_config.First));                  var downRouteeRef = routees()                      .Where(c => c is ActorRefRoutee && ((ActorRefRoutee)c).Actor.Path.Address == downAddress)                      .Select(c => ((ActorRefRoutee)c).Actor).First();                    Cluster.Down(downAddress);                  ExpectMsg<Terminated>(15.Seconds()).ActorRef.Should().Be(downRouteeRef);                  AwaitAssert(() =>                  {                      routeeAddresses().Should().Contain(notUsedAddress);                      routeeAddresses().Should().NotContain(downAddress);                  });                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router2.Value.Tell("hit");                  }                    var replays = ReceiveReplays(new ClusterRoundRobinSpecConfig.PoolRoutee()' iterationCount);                  routeeAddresses().Count.Should().Be(3);                  replays.Values.Sum().Should().Be(iterationCount);                }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,ClusterRoundRobinSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\ClusterRoundRobinSpec.cs,A_cluster_router_with_a_RoundRobin_router_must_deploy_programatically_defined_routees_to_other_node_when_a_node_becomes_down,The following statement contains a magic number: RunOn(() =>              {                  Func<List<Routee>> routees = () => CurrentRoutees(router2.Value).ToList();                  Func<List<Address>> routeeAddresses = () => routees()                      .Where(c => c is ActorRefRoutee)                      .Select(c => FullAddress(((ActorRefRoutee)c).Actor)).ToList();                    routees().ForEach(actorRef =>                  {                      var actorRefRoutee = actorRef as ActorRefRoutee;                      if (actorRefRoutee != null)                      {                          Watch(actorRefRoutee.Actor);                      }                  });                    var notUsedAddress = Roles.Select(c => GetAddress(c)).Except(routeeAddresses()).First();                  var downAddress = routeeAddresses().Find(c => c != GetAddress(_config.First));                  var downRouteeRef = routees()                      .Where(c => c is ActorRefRoutee && ((ActorRefRoutee)c).Actor.Path.Address == downAddress)                      .Select(c => ((ActorRefRoutee)c).Actor).First();                    Cluster.Down(downAddress);                  ExpectMsg<Terminated>(15.Seconds()).ActorRef.Should().Be(downRouteeRef);                  AwaitAssert(() =>                  {                      routeeAddresses().Should().Contain(notUsedAddress);                      routeeAddresses().Should().NotContain(downAddress);                  });                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router2.Value.Tell("hit");                  }                    var replays = ReceiveReplays(new ClusterRoundRobinSpecConfig.PoolRoutee()' iterationCount);                  routeeAddresses().Count.Should().Be(3);                  replays.Values.Sum().Should().Be(iterationCount);                }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,ReceiveReplays,The following statement contains a magic number: var replays = ReceiveWhile(5.Seconds()' msg =>              {                  var routee = msg as UseRoleIgnoredSpecConfig.Reply;                  if (routee != null && routee.RouteeType.GetType() == routeeType.GetType())                      return FullAddress(routee.ActorRef);                  return null;              }' expectedReplies).Aggregate(zero' (replyMap' address) =>              {                  replyMap[address]++;                  return replyMap;              });
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_pool_local_off_roles_off,The following statement contains a magic number: RunOn(() =>              {                  var role = "b";                    var router = Sys.ActorOf(                      new ClusterRouterPool(                          new RoundRobinPool(6)'                          new ClusterRouterPoolSettings(6' 2' allowLocalRoutees: false' useRole: role)).Props(                              Props.Create<UseRoleIgnoredSpecConfig.SomeActor>())'                      "router-2");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(4));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.PoolRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().Be(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().BeGreaterThan(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_pool_local_off_roles_off,The following statement contains a magic number: RunOn(() =>              {                  var role = "b";                    var router = Sys.ActorOf(                      new ClusterRouterPool(                          new RoundRobinPool(6)'                          new ClusterRouterPoolSettings(6' 2' allowLocalRoutees: false' useRole: role)).Props(                              Props.Create<UseRoleIgnoredSpecConfig.SomeActor>())'                      "router-2");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(4));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.PoolRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().Be(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().BeGreaterThan(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_pool_local_off_roles_off,The following statement contains a magic number: RunOn(() =>              {                  var role = "b";                    var router = Sys.ActorOf(                      new ClusterRouterPool(                          new RoundRobinPool(6)'                          new ClusterRouterPoolSettings(6' 2' allowLocalRoutees: false' useRole: role)).Props(                              Props.Create<UseRoleIgnoredSpecConfig.SomeActor>())'                      "router-2");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(4));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.PoolRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().Be(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().BeGreaterThan(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_pool_local_off_roles_off,The following statement contains a magic number: RunOn(() =>              {                  var role = "b";                    var router = Sys.ActorOf(                      new ClusterRouterPool(                          new RoundRobinPool(6)'                          new ClusterRouterPoolSettings(6' 2' allowLocalRoutees: false' useRole: role)).Props(                              Props.Create<UseRoleIgnoredSpecConfig.SomeActor>())'                      "router-2");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(4));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.PoolRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().Be(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().BeGreaterThan(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_pool_local_off_roles_off,The following statement contains a magic number: RunOn(() =>              {                  var role = "b";                    var router = Sys.ActorOf(                      new ClusterRouterPool(                          new RoundRobinPool(6)'                          new ClusterRouterPoolSettings(6' 2' allowLocalRoutees: false' useRole: role)).Props(                              Props.Create<UseRoleIgnoredSpecConfig.SomeActor>())'                      "router-2");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(4));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.PoolRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().Be(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().BeGreaterThan(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_group_local_off_roles_off,The following statement contains a magic number: RunOn(() =>              {                  var role = "b";                    var router = Sys.ActorOf(                      new ClusterRouterGroup(                          new RoundRobinGroup(paths: null)'                          new ClusterRouterGroupSettings(6' ImmutableHashSet.Create("/user/foo"' "/user/bar")' allowLocalRoutees: false' useRole: role)).Props()'                      "router-2b");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(4));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.GroupRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().Be(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().BeGreaterThan(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_group_local_off_roles_off,The following statement contains a magic number: RunOn(() =>              {                  var role = "b";                    var router = Sys.ActorOf(                      new ClusterRouterGroup(                          new RoundRobinGroup(paths: null)'                          new ClusterRouterGroupSettings(6' ImmutableHashSet.Create("/user/foo"' "/user/bar")' allowLocalRoutees: false' useRole: role)).Props()'                      "router-2b");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(4));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.GroupRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().Be(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().BeGreaterThan(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_group_local_off_roles_off,The following statement contains a magic number: RunOn(() =>              {                  var role = "b";                    var router = Sys.ActorOf(                      new ClusterRouterGroup(                          new RoundRobinGroup(paths: null)'                          new ClusterRouterGroupSettings(6' ImmutableHashSet.Create("/user/foo"' "/user/bar")' allowLocalRoutees: false' useRole: role)).Props()'                      "router-2b");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(4));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.GroupRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().Be(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().BeGreaterThan(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_pool_local_on_role_b,The following statement contains a magic number: RunOn(() =>              {                  var role = "b";                    var router = Sys.ActorOf(                      new ClusterRouterPool(                          new RoundRobinPool(6)'                          new ClusterRouterPoolSettings(6' 2' allowLocalRoutees: true' useRole: role)).Props(                              Props.Create<UseRoleIgnoredSpecConfig.SomeActor>())'                      "router-3");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(4));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.PoolRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().Be(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().BeGreaterThan(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_pool_local_on_role_b,The following statement contains a magic number: RunOn(() =>              {                  var role = "b";                    var router = Sys.ActorOf(                      new ClusterRouterPool(                          new RoundRobinPool(6)'                          new ClusterRouterPoolSettings(6' 2' allowLocalRoutees: true' useRole: role)).Props(                              Props.Create<UseRoleIgnoredSpecConfig.SomeActor>())'                      "router-3");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(4));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.PoolRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().Be(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().BeGreaterThan(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_pool_local_on_role_b,The following statement contains a magic number: RunOn(() =>              {                  var role = "b";                    var router = Sys.ActorOf(                      new ClusterRouterPool(                          new RoundRobinPool(6)'                          new ClusterRouterPoolSettings(6' 2' allowLocalRoutees: true' useRole: role)).Props(                              Props.Create<UseRoleIgnoredSpecConfig.SomeActor>())'                      "router-3");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(4));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.PoolRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().Be(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().BeGreaterThan(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_pool_local_on_role_b,The following statement contains a magic number: RunOn(() =>              {                  var role = "b";                    var router = Sys.ActorOf(                      new ClusterRouterPool(                          new RoundRobinPool(6)'                          new ClusterRouterPoolSettings(6' 2' allowLocalRoutees: true' useRole: role)).Props(                              Props.Create<UseRoleIgnoredSpecConfig.SomeActor>())'                      "router-3");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(4));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.PoolRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().Be(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().BeGreaterThan(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_pool_local_on_role_b,The following statement contains a magic number: RunOn(() =>              {                  var role = "b";                    var router = Sys.ActorOf(                      new ClusterRouterPool(                          new RoundRobinPool(6)'                          new ClusterRouterPoolSettings(6' 2' allowLocalRoutees: true' useRole: role)).Props(                              Props.Create<UseRoleIgnoredSpecConfig.SomeActor>())'                      "router-3");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(4));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.PoolRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().Be(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().BeGreaterThan(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_group_local_on_role_b,The following statement contains a magic number: RunOn(() =>              {                  var role = "b";                    var router = Sys.ActorOf(                      new ClusterRouterGroup(                          new RoundRobinGroup(paths: null)'                          new ClusterRouterGroupSettings(6' ImmutableHashSet.Create("/user/foo"' "/user/bar")' allowLocalRoutees: true' useRole: role)).Props()'                      "router-3b");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(4));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.GroupRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().Be(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().BeGreaterThan(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_group_local_on_role_b,The following statement contains a magic number: RunOn(() =>              {                  var role = "b";                    var router = Sys.ActorOf(                      new ClusterRouterGroup(                          new RoundRobinGroup(paths: null)'                          new ClusterRouterGroupSettings(6' ImmutableHashSet.Create("/user/foo"' "/user/bar")' allowLocalRoutees: true' useRole: role)).Props()'                      "router-3b");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(4));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.GroupRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().Be(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().BeGreaterThan(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_group_local_on_role_b,The following statement contains a magic number: RunOn(() =>              {                  var role = "b";                    var router = Sys.ActorOf(                      new ClusterRouterGroup(                          new RoundRobinGroup(paths: null)'                          new ClusterRouterGroupSettings(6' ImmutableHashSet.Create("/user/foo"' "/user/bar")' allowLocalRoutees: true' useRole: role)).Props()'                      "router-3b");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(4));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.GroupRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().Be(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().BeGreaterThan(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_pool_local_on_role_a,The following statement contains a magic number: RunOn(() =>              {                  var role = "a";                    var router = Sys.ActorOf(                      new ClusterRouterPool(                          new RoundRobinPool(6)'                          new ClusterRouterPoolSettings(6' 2' allowLocalRoutees: true' useRole: role)).Props(                              Props.Create<UseRoleIgnoredSpecConfig.SomeActor>())'                      "router-4");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(2));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.PoolRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Second)].Should().Be(0);                  replays[GetAddress(_config.Third)].Should().Be(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_pool_local_on_role_a,The following statement contains a magic number: RunOn(() =>              {                  var role = "a";                    var router = Sys.ActorOf(                      new ClusterRouterPool(                          new RoundRobinPool(6)'                          new ClusterRouterPoolSettings(6' 2' allowLocalRoutees: true' useRole: role)).Props(                              Props.Create<UseRoleIgnoredSpecConfig.SomeActor>())'                      "router-4");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(2));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.PoolRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Second)].Should().Be(0);                  replays[GetAddress(_config.Third)].Should().Be(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_pool_local_on_role_a,The following statement contains a magic number: RunOn(() =>              {                  var role = "a";                    var router = Sys.ActorOf(                      new ClusterRouterPool(                          new RoundRobinPool(6)'                          new ClusterRouterPoolSettings(6' 2' allowLocalRoutees: true' useRole: role)).Props(                              Props.Create<UseRoleIgnoredSpecConfig.SomeActor>())'                      "router-4");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(2));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.PoolRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Second)].Should().Be(0);                  replays[GetAddress(_config.Third)].Should().Be(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_pool_local_on_role_a,The following statement contains a magic number: RunOn(() =>              {                  var role = "a";                    var router = Sys.ActorOf(                      new ClusterRouterPool(                          new RoundRobinPool(6)'                          new ClusterRouterPoolSettings(6' 2' allowLocalRoutees: true' useRole: role)).Props(                              Props.Create<UseRoleIgnoredSpecConfig.SomeActor>())'                      "router-4");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(2));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.PoolRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Second)].Should().Be(0);                  replays[GetAddress(_config.Third)].Should().Be(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_pool_local_on_role_a,The following statement contains a magic number: RunOn(() =>              {                  var role = "a";                    var router = Sys.ActorOf(                      new ClusterRouterPool(                          new RoundRobinPool(6)'                          new ClusterRouterPoolSettings(6' 2' allowLocalRoutees: true' useRole: role)).Props(                              Props.Create<UseRoleIgnoredSpecConfig.SomeActor>())'                      "router-4");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(2));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.PoolRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Second)].Should().Be(0);                  replays[GetAddress(_config.Third)].Should().Be(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_group_local_on_role_a,The following statement contains a magic number: RunOn(() =>              {                  var role = "a";                    var router = Sys.ActorOf(                      new ClusterRouterGroup(                          new RoundRobinGroup(paths: null)'                          new ClusterRouterGroupSettings(6' ImmutableHashSet.Create("/user/foo"' "/user/bar")' allowLocalRoutees: true' useRole: role)).Props()'                      "router-4b");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(2));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.GroupRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Second)].Should().Be(0);                  replays[GetAddress(_config.Third)].Should().Be(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_group_local_on_role_a,The following statement contains a magic number: RunOn(() =>              {                  var role = "a";                    var router = Sys.ActorOf(                      new ClusterRouterGroup(                          new RoundRobinGroup(paths: null)'                          new ClusterRouterGroupSettings(6' ImmutableHashSet.Create("/user/foo"' "/user/bar")' allowLocalRoutees: true' useRole: role)).Props()'                      "router-4b");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(2));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.GroupRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Second)].Should().Be(0);                  replays[GetAddress(_config.Third)].Should().Be(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_group_local_on_role_a,The following statement contains a magic number: RunOn(() =>              {                  var role = "a";                    var router = Sys.ActorOf(                      new ClusterRouterGroup(                          new RoundRobinGroup(paths: null)'                          new ClusterRouterGroupSettings(6' ImmutableHashSet.Create("/user/foo"' "/user/bar")' allowLocalRoutees: true' useRole: role)).Props()'                      "router-4b");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(2));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.GroupRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Second)].Should().Be(0);                  replays[GetAddress(_config.Third)].Should().Be(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_pool_local_on_role_c,The following statement contains a magic number: RunOn(() =>              {                  var role = "c";                    var router = Sys.ActorOf(                      new ClusterRouterPool(                          new RoundRobinPool(6)'                          new ClusterRouterPoolSettings(6' 2' allowLocalRoutees: true' useRole: role)).Props(                              Props.Create<UseRoleIgnoredSpecConfig.SomeActor>())'                      "router-5");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(6));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.PoolRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().BeGreaterThan(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_pool_local_on_role_c,The following statement contains a magic number: RunOn(() =>              {                  var role = "c";                    var router = Sys.ActorOf(                      new ClusterRouterPool(                          new RoundRobinPool(6)'                          new ClusterRouterPoolSettings(6' 2' allowLocalRoutees: true' useRole: role)).Props(                              Props.Create<UseRoleIgnoredSpecConfig.SomeActor>())'                      "router-5");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(6));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.PoolRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().BeGreaterThan(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_pool_local_on_role_c,The following statement contains a magic number: RunOn(() =>              {                  var role = "c";                    var router = Sys.ActorOf(                      new ClusterRouterPool(                          new RoundRobinPool(6)'                          new ClusterRouterPoolSettings(6' 2' allowLocalRoutees: true' useRole: role)).Props(                              Props.Create<UseRoleIgnoredSpecConfig.SomeActor>())'                      "router-5");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(6));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.PoolRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().BeGreaterThan(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_pool_local_on_role_c,The following statement contains a magic number: RunOn(() =>              {                  var role = "c";                    var router = Sys.ActorOf(                      new ClusterRouterPool(                          new RoundRobinPool(6)'                          new ClusterRouterPoolSettings(6' 2' allowLocalRoutees: true' useRole: role)).Props(                              Props.Create<UseRoleIgnoredSpecConfig.SomeActor>())'                      "router-5");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(6));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.PoolRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().BeGreaterThan(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_pool_local_on_role_c,The following statement contains a magic number: RunOn(() =>              {                  var role = "c";                    var router = Sys.ActorOf(                      new ClusterRouterPool(                          new RoundRobinPool(6)'                          new ClusterRouterPoolSettings(6' 2' allowLocalRoutees: true' useRole: role)).Props(                              Props.Create<UseRoleIgnoredSpecConfig.SomeActor>())'                      "router-5");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(6));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.PoolRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().BeGreaterThan(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_group_local_on_role_c,The following statement contains a magic number: RunOn(() =>              {                  var role = "c";                    var router = Sys.ActorOf(                      new ClusterRouterGroup(                          new RoundRobinGroup(paths: null)'                          new ClusterRouterGroupSettings(6' ImmutableHashSet.Create("/user/foo"' "/user/bar")' allowLocalRoutees: true' useRole: role)).Props()'                      "router-5b");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(6));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.GroupRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().BeGreaterThan(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_group_local_on_role_c,The following statement contains a magic number: RunOn(() =>              {                  var role = "c";                    var router = Sys.ActorOf(                      new ClusterRouterGroup(                          new RoundRobinGroup(paths: null)'                          new ClusterRouterGroupSettings(6' ImmutableHashSet.Create("/user/foo"' "/user/bar")' allowLocalRoutees: true' useRole: role)).Props()'                      "router-5b");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(6));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.GroupRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().BeGreaterThan(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
Magic Number,Akka.Cluster.Tests.MultiNode.Routing,UseRoleIgnoredSpec,D:\research\architectureSmells\repos\akkadotnet_akka.net\src\core\Akka.Cluster.Tests.MultiNode\Routing\UseRoleIgnoredSpec.cs,A_cluster_must_group_local_on_role_c,The following statement contains a magic number: RunOn(() =>              {                  var role = "c";                    var router = Sys.ActorOf(                      new ClusterRouterGroup(                          new RoundRobinGroup(paths: null)'                          new ClusterRouterGroupSettings(6' ImmutableHashSet.Create("/user/foo"' "/user/bar")' allowLocalRoutees: true' useRole: role)).Props()'                      "router-5b");                    AwaitAssert(() => CurrentRoutees(router).Count().Should().Be(6));                    var iterationCount = 10;                  for (int i = 0; i < iterationCount; i++)                  {                      router.Tell($"hit-{i}");                  }                    var replays = ReceiveReplays(new UseRoleIgnoredSpecConfig.GroupRoutee()' iterationCount);                    // should not be deployed locally' does not have required role                  replays[GetAddress(_config.First)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Second)].Should().BeGreaterThan(0);                  replays[GetAddress(_config.Third)].Should().BeGreaterThan(0);                  replays.Values.Sum().Should().Be(iterationCount);              }' _config.First);
