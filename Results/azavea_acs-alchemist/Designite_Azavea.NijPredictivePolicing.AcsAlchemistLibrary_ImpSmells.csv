Implementation smell,Namespace,Class,File,Method,Description
Long Method,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,CheckBuildVariableTable,The method has 152 lines of code.
Long Method,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,GetShapeRowsByLOGRECNO,The method has 140 lines of code.
Long Method,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,GetShapeFeaturesToExport,The method has 142 lines of code.
Long Method,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,ExportGriddedShapefile,The method has 203 lines of code.
Long Method,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,FileDownloader,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\FileDownloader.cs,GetFileByURL,The method has 106 lines of code.
Complex Method,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,DesiredColumnsReader,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\DesiredColumnsReader.cs,CheckForMOEDuplicates,Cyclomatic complexity of the method is 10
Complex Method,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,DesiredColumnsReader,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\DesiredColumnsReader.cs,CheckForDuplicates,Cyclomatic complexity of the method is 8
Complex Method,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,CreateColumnMappingsTable,Cyclomatic complexity of the method is 10
Complex Method,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,GetRequestedVariables,Cyclomatic complexity of the method is 9
Complex Method,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,GetFilteringGeometries,Cyclomatic complexity of the method is 8
Complex Method,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,GetShapeRowsByLOGRECNO,Cyclomatic complexity of the method is 9
Complex Method,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,ExportGriddedShapefile,Cyclomatic complexity of the method is 23
Long Parameter List,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,ShapefileHelper,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\ShapefileHelper.cs,ImportShapefile,The method has 5 parameters. Parameters: conn' client' filename' tableName' srid
Long Statement,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,DesiredColumnsReader,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\DesiredColumnsReader.cs,CheckForReserved,The length of the statement  "                //_log.ErrorFormat("The File {0} contained reserved column names that cannot be used.\r\nPlease remove these conflicts to continue:\r\n{1} "' filename' reservedSB.ToString()); " is 175.
Long Statement,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,DesiredColumnsReader,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\DesiredColumnsReader.cs,CheckForMOEDuplicates,The length of the statement  "            //dupsSB.AppendFormat("The File {0} contained duplicate or conflicting columns.{1}Please resolve these conflicts to continue:{1}"' this._filename' Environment.NewLine); " is 168.
Long Statement,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,DesiredColumnsReader,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\DesiredColumnsReader.cs,CheckForMOEDuplicates,The length of the statement  "            //dupsSB.AppendFormat("Note that all variables include a Margin of Error column named \"{0}\" + [column name] which can cause duplicates to be created."' Settings.MoEPrefix); " is 174.
Long Statement,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,DesiredColumnsReader,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\DesiredColumnsReader.cs,CheckForDuplicates,The length of the statement  "                    dupsSB.AppendFormat("The File {0} contained duplicate or conflicting columns.{1}Please resolve these conflicts to continue:{1}"' " is 128.
Long Statement,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,DesiredColumnsReader,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\DesiredColumnsReader.cs,CheckForDuplicates,The length of the statement  "                    dupsSB.AppendFormat("Note that all variables include a Margin of Error column named \"{0}\" + [column name] which can cause duplicates to be created.{1}"' " is 154.
Long Statement,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,ShapefileHelper,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\ShapefileHelper.cs,LoadShapefile,The length of the statement  "                    _log.ErrorFormat("LoadShapefile failed: {0} conflicts with a reserved census shapefile name' please rename"' fileWithoutExt); " is 125.
Long Statement,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,ShapefileHelper,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\ShapefileHelper.cs,ImportShapefile,The length of the statement  "                string sql = string.Format("CREATE VIRTUAL TABLE " + tableName + " USING VirtualShape('{0}'' CP1252' {1});"' filename' srid); " is 125.
Long Statement,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,CreateColumnMappingsTable,The length of the statement  "            DbClient.GetCommand(string.Format("DROP TABLE IF EXISTS \"{0}\";"' DbConstants.TABLE_ColumnMappings)' conn).ExecuteNonQuery(); " is 126.
Long Statement,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,CreateColumnMappingsTable,The length of the statement  "            string createMappingsTableSql = DataClient.GenerateTableSQLFromFields(DbConstants.TABLE_ColumnMappings' SequenceFileReader.Columns); " is 132.
Long Statement,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,CheckBuildVariableTable,The length of the statement  "                        var seqFile = Directory.GetFiles(this.GetAggregateDataPath()' "e*" + sequenceNo.ToString("0000") + "000.txt");    //0001000 " is 123.
Long Statement,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,CheckBuildVariableTable,The length of the statement  "                        var errorFile = Directory.GetFiles(this.GetAggregateDataPath()' "m*" + sequenceNo.ToString("0000") + "000.txt");    //0001000 " is 125.
Long Statement,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,GetShapeRowsByLOGRECNO,The length of the statement  "                //    geomSQL = "select LOGRECNO' trim(COUNTY) as county' GEOID from geographies_all where SUMLEVEL = '050' order by county "; " is 126.
Long Statement,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,GetShapeRowsByLOGRECNO,The length of the statement  "                //    shapeSQL = "select trim(COUNTY) as county'  trim(COUSUB) as cousub' AsBinary(Geometry) as Geometry' '' as GEOID from county_subdivisions "; " is 145.
Long Statement,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,GetShapeRowsByLOGRECNO,The length of the statement  "                //    geomSQL = "select LOGRECNO' trim(COUNTY) as county' trim(COUSUB) as cousub' GEOID from geographies_all  where SUMLEVEL = '060' order by county' cousub"; " is 158.
Long Statement,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,GetShapeRowsByLOGRECNO,The length of the statement  "                    shapeSQL = "select trim(COUNTY) as county' trim(TRACT) as tract' '' as blkgroup' AsBinary(Geometry) as Geometry' '' as GEOID from census_tracts order by county' tract' blkgroup"; " is 178.
Long Statement,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,GetShapeRowsByLOGRECNO,The length of the statement  "                    geomSQL = "select LOGRECNO' trim(COUNTY) as county' trim(TRACT) as tract' trim(BLKGRP) as blkgroup' GEOID from geographies where SUMLEVEL = '140' order by county' tract' blkgrp "; " is 179.
Long Statement,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,GetShapeRowsByLOGRECNO,The length of the statement  "                    shapeSQL = string.Format("select trim(COUNTY) as county' trim(TRACT) as tract' trim({0}) as blkgroup' AsBinary(Geometry) as Geometry' '' as GEOID from census_blockgroups order by county' tract' blkgroup"' " is 204.
Long Statement,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,GetShapeRowsByLOGRECNO,The length of the statement  "                    geomSQL = "select LOGRECNO' trim(COUNTY) as county' trim(TRACT) as tract' trim(BLKGRP) as blkgroup' GEOID from geographies  where SUMLEVEL = '150' order by county' tract' blkgrp "; " is 180.
Long Statement,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,GetShapeRowsByLOGRECNO,The length of the statement  "                                _log.Debug("Geometry merge succeeded!  Please double check all features in the output that match the above logrecno for consistency."); " is 135.
Long Statement,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,ExportGriddedShapefile,The length of the statement  "                    var variablesDT = DataClient.GetMagicTable(conn' DbClient' string.Format("SELECT * FROM \"{0}\" where 0 = 1 "' tableName)); " is 123.
Long Statement,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,FileDownloader,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\FileDownloader.cs,GetFileByURL,The length of the statement  "                    string msg = "The importer couldn't save the file' please run this application as administrator' or set the output directory."; " is 127.
Long Statement,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,FileDownloader,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\FileDownloader.cs,GetFileByURL,The length of the statement  "            _log.FatalFormat("Could not download file at {0} to location {1} after {2} retries.  Please re-run the program to try again.  If this problem persists' you can try manually downloading the file and copying it to the above path."' desiredURL' filePath' retries); " is 261.
Complex Conditional,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,ShapefileHelper,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\ShapefileHelper.cs,AddColumn,The conditional expression  "t == typeof(short) || t == typeof(int) || t == typeof(long)                  || t == typeof(ushort) || t == typeof(uint) || t == typeof(ulong)"  is complex.
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,DesiredColumnsReader,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\DesiredColumnsReader.cs,ReadVariablesFile,The following statement contains a magic number: try              {                  if (string.IsNullOrEmpty(_filename))                  {                      if (!this.LoadFile(filename))                      {                          _log.ErrorFormat("ImportDesiredVariables failed: the file couldn't be read");                      }                  }                  foreach (List<string> row in this)                  {                      line++;     //base 1                        if ((row.Count < 1) || (string.IsNullOrEmpty(row[0])) || (row[0].StartsWith("#")))                      {                          //skip blank lines / comments                          continue;                      }                      if (row.Count > 2)                      {                          _log.WarnFormat("Line {0}: too many fields ({1}) provided' using first two"' line' row.Count);                      }                          string variableID = row[0];                      string variableAlias = (row.Count > 1) ? row[1] : row[0];                      //string marginErrorAlias = Utilities.EnsureMaxLength(Settings.MoEPrefix + variableAlias' 10);                      if (variableAlias.Length > 10)                      {                          _log.WarnFormat("Line {0}: \"{1}\" name was too long' truncating to 10 characters"' line' variableAlias);                          variableAlias = Utilities.EnsureMaxLength(variableAlias' 10);                      }                        //////Track duplicates                      //AddIntToDict(columnConflicts' line' variableAlias' marginErrorAlias);                      //IfSetAddIntToDict(reservedColumns' reservedConflicts' line' variableAlias' marginErrorAlias);                        //uniqueColumnNames.Add(variableAlias);                      //uniqueColumnNames.Add(marginErrorAlias);                          dt.Rows.Add(variableID' variableAlias);//' marginErrorAlias' line);                  }              }              catch (Exception ex)              {                  _log.Error("ReadVariablesFile: Exception thrown!"' ex);                  _log.ErrorFormat("Variable Import made it to line {0}:{1}"' filename' line);              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,DesiredColumnsReader,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\DesiredColumnsReader.cs,ReadVariablesFile,The following statement contains a magic number: try              {                  if (string.IsNullOrEmpty(_filename))                  {                      if (!this.LoadFile(filename))                      {                          _log.ErrorFormat("ImportDesiredVariables failed: the file couldn't be read");                      }                  }                  foreach (List<string> row in this)                  {                      line++;     //base 1                        if ((row.Count < 1) || (string.IsNullOrEmpty(row[0])) || (row[0].StartsWith("#")))                      {                          //skip blank lines / comments                          continue;                      }                      if (row.Count > 2)                      {                          _log.WarnFormat("Line {0}: too many fields ({1}) provided' using first two"' line' row.Count);                      }                          string variableID = row[0];                      string variableAlias = (row.Count > 1) ? row[1] : row[0];                      //string marginErrorAlias = Utilities.EnsureMaxLength(Settings.MoEPrefix + variableAlias' 10);                      if (variableAlias.Length > 10)                      {                          _log.WarnFormat("Line {0}: \"{1}\" name was too long' truncating to 10 characters"' line' variableAlias);                          variableAlias = Utilities.EnsureMaxLength(variableAlias' 10);                      }                        //////Track duplicates                      //AddIntToDict(columnConflicts' line' variableAlias' marginErrorAlias);                      //IfSetAddIntToDict(reservedColumns' reservedConflicts' line' variableAlias' marginErrorAlias);                        //uniqueColumnNames.Add(variableAlias);                      //uniqueColumnNames.Add(marginErrorAlias);                          dt.Rows.Add(variableID' variableAlias);//' marginErrorAlias' line);                  }              }              catch (Exception ex)              {                  _log.Error("ReadVariablesFile: Exception thrown!"' ex);                  _log.ErrorFormat("Variable Import made it to line {0}:{1}"' filename' line);              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,DesiredColumnsReader,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\DesiredColumnsReader.cs,ReadVariablesFile,The following statement contains a magic number: try              {                  if (string.IsNullOrEmpty(_filename))                  {                      if (!this.LoadFile(filename))                      {                          _log.ErrorFormat("ImportDesiredVariables failed: the file couldn't be read");                      }                  }                  foreach (List<string> row in this)                  {                      line++;     //base 1                        if ((row.Count < 1) || (string.IsNullOrEmpty(row[0])) || (row[0].StartsWith("#")))                      {                          //skip blank lines / comments                          continue;                      }                      if (row.Count > 2)                      {                          _log.WarnFormat("Line {0}: too many fields ({1}) provided' using first two"' line' row.Count);                      }                          string variableID = row[0];                      string variableAlias = (row.Count > 1) ? row[1] : row[0];                      //string marginErrorAlias = Utilities.EnsureMaxLength(Settings.MoEPrefix + variableAlias' 10);                      if (variableAlias.Length > 10)                      {                          _log.WarnFormat("Line {0}: \"{1}\" name was too long' truncating to 10 characters"' line' variableAlias);                          variableAlias = Utilities.EnsureMaxLength(variableAlias' 10);                      }                        //////Track duplicates                      //AddIntToDict(columnConflicts' line' variableAlias' marginErrorAlias);                      //IfSetAddIntToDict(reservedColumns' reservedConflicts' line' variableAlias' marginErrorAlias);                        //uniqueColumnNames.Add(variableAlias);                      //uniqueColumnNames.Add(marginErrorAlias);                          dt.Rows.Add(variableID' variableAlias);//' marginErrorAlias' line);                  }              }              catch (Exception ex)              {                  _log.Error("ReadVariablesFile: Exception thrown!"' ex);                  _log.ErrorFormat("Variable Import made it to line {0}:{1}"' filename' line);              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,DesiredColumnsReader,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\DesiredColumnsReader.cs,CheckForMaxColumns,The following statement contains a magic number: if (dt.Rows.Count > 100)              {                  return string.Format(@"This file contained {0} variables. \n "                   + "A maximum of 100 variables are allowed per export job. \n"                   + "Please split your requested variables into multiple files and try again."'                      dt.Rows.Count);              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,DesiredColumnsReader,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\DesiredColumnsReader.cs,CheckForReserved,The following statement contains a magic number: StringBuilder errSB = new StringBuilder(512);
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,DesiredColumnsReader,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\DesiredColumnsReader.cs,CheckForMOEDuplicates,The following statement contains a magic number: for (int i = 0; i < dt.Rows.Count; i++)              {                  var original = (dt.Rows[i][1] as string).ToLower();                  orignalColumns[original] = i;                    string errorColumn = Utilities.EnsureMaxLength(Settings.MoEPrefix + original' 10);                  if (!errorColumns.ContainsKey(errorColumn))                      errorColumns[errorColumn] = new List<int>();                  errorColumns[errorColumn].Add(i);              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,DesiredColumnsReader,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\DesiredColumnsReader.cs,CheckForMOEDuplicates,The following statement contains a magic number: StringBuilder dupsSB = new StringBuilder(512);
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,DesiredColumnsReader,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\DesiredColumnsReader.cs,CheckForDuplicates,The following statement contains a magic number: StringBuilder dupsSB = new StringBuilder(512);
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,ShapefileHelper,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\ShapefileHelper.cs,GetGeomFactory,The following statement contains a magic number: return new GeometryFactory(new PrecisionModel()' 4269);
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,ShapefileHelper,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\ShapefileHelper.cs,SetupHeader,The following statement contains a magic number: foreach (DataColumn col in table.Columns)              {                  Type t = col.DataType;                  string columnName = Utilities.EnsureMaxLength(col.ColumnName' 10);                    AddColumn(header' columnName' t);              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,ShapefileHelper,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\ShapefileHelper.cs,AddColumn,The following statement contains a magic number: columnName = Utilities.EnsureMaxLength(columnName' 10);
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,ShapefileHelper,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\ShapefileHelper.cs,AddColumn,The following statement contains a magic number: if (t == typeof(bool))              {                  header.AddColumn(columnName' 'L'' 1' 0);              }              else if (t == typeof(string))              {                  header.AddColumn(columnName' 'C'' 254' 0);              }              else if (t == typeof(DateTime))              {                  header.AddColumn(columnName' 'C'' 22' 0);              }              else if (t == typeof(float) || t == typeof(double) || t == typeof(decimal))              {                  header.AddColumn(columnName' 'N'' 18' 10);              }              else if (t == typeof(short) || t == typeof(int) || t == typeof(long)                  || t == typeof(ushort) || t == typeof(uint) || t == typeof(ulong))              {                  header.AddColumn(columnName' 'N'' 18' 0);              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,ShapefileHelper,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\ShapefileHelper.cs,AddColumn,The following statement contains a magic number: if (t == typeof(bool))              {                  header.AddColumn(columnName' 'L'' 1' 0);              }              else if (t == typeof(string))              {                  header.AddColumn(columnName' 'C'' 254' 0);              }              else if (t == typeof(DateTime))              {                  header.AddColumn(columnName' 'C'' 22' 0);              }              else if (t == typeof(float) || t == typeof(double) || t == typeof(decimal))              {                  header.AddColumn(columnName' 'N'' 18' 10);              }              else if (t == typeof(short) || t == typeof(int) || t == typeof(long)                  || t == typeof(ushort) || t == typeof(uint) || t == typeof(ulong))              {                  header.AddColumn(columnName' 'N'' 18' 0);              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,ShapefileHelper,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\ShapefileHelper.cs,AddColumn,The following statement contains a magic number: if (t == typeof(bool))              {                  header.AddColumn(columnName' 'L'' 1' 0);              }              else if (t == typeof(string))              {                  header.AddColumn(columnName' 'C'' 254' 0);              }              else if (t == typeof(DateTime))              {                  header.AddColumn(columnName' 'C'' 22' 0);              }              else if (t == typeof(float) || t == typeof(double) || t == typeof(decimal))              {                  header.AddColumn(columnName' 'N'' 18' 10);              }              else if (t == typeof(short) || t == typeof(int) || t == typeof(long)                  || t == typeof(ushort) || t == typeof(uint) || t == typeof(ulong))              {                  header.AddColumn(columnName' 'N'' 18' 0);              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,ShapefileHelper,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\ShapefileHelper.cs,AddColumn,The following statement contains a magic number: if (t == typeof(bool))              {                  header.AddColumn(columnName' 'L'' 1' 0);              }              else if (t == typeof(string))              {                  header.AddColumn(columnName' 'C'' 254' 0);              }              else if (t == typeof(DateTime))              {                  header.AddColumn(columnName' 'C'' 22' 0);              }              else if (t == typeof(float) || t == typeof(double) || t == typeof(decimal))              {                  header.AddColumn(columnName' 'N'' 18' 10);              }              else if (t == typeof(short) || t == typeof(int) || t == typeof(long)                  || t == typeof(ushort) || t == typeof(uint) || t == typeof(ulong))              {                  header.AddColumn(columnName' 'N'' 18' 0);              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,ShapefileHelper,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\ShapefileHelper.cs,AddColumn,The following statement contains a magic number: if (t == typeof(bool))              {                  header.AddColumn(columnName' 'L'' 1' 0);              }              else if (t == typeof(string))              {                  header.AddColumn(columnName' 'C'' 254' 0);              }              else if (t == typeof(DateTime))              {                  header.AddColumn(columnName' 'C'' 22' 0);              }              else if (t == typeof(float) || t == typeof(double) || t == typeof(decimal))              {                  header.AddColumn(columnName' 'N'' 18' 10);              }              else if (t == typeof(short) || t == typeof(int) || t == typeof(long)                  || t == typeof(ushort) || t == typeof(uint) || t == typeof(ulong))              {                  header.AddColumn(columnName' 'N'' 18' 0);              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.FileFormats,ShapefileHelper,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\FileFormats\ShapefileHelper.cs,IsForbiddenShapefileName,The following statement contains a magic number: StringBuilder newRegex = new StringBuilder(512);
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,DownloadAndImportShapefile,The following statement contains a magic number: using (var conn = client.GetConnection())              {                    if (DataClient.HasTable(conn' client' tablename))                  {                      DbClient.GetCommand(string.Format("DROP TABLE IF EXISTS \"{0}\";"' tablename)' conn).ExecuteNonQuery();                  }                    {                      _log.DebugFormat("{0} table not found' importing..."' tablename);                        var filenames = FileUtilities.FindFileNameInZipLike(destFilepath' "*.shp");                      if ((filenames == null) || (filenames.Count == 0))                      {                          _log.ErrorFormat("Compressed file {0} didn't contain a shapefile!"' destFilepath);                          return false;                      }                        foreach (string filename in filenames)                      {                          string fullShapefilename = Path.Combine(this.ShapePath' filename);                            ShapefileHelper.MakeCensusProjFile(fullShapefilename);                          ShapefileHelper.ImportShapefile(conn' this.DbClient'                              fullShapefilename' tablename' 4269);                            //TODO: multiple shape files in one zip?                          break;                      }                  }              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,CreateColumnMappingsTable,The following statement contains a magic number: if (Directory.Exists(colMapDir))              {                  _log.Debug("Importing Sequence Files...");                    int ixid = 0;                  // Note: this used to search only the top directory' but the 2014 data uses subdirectories'                  // so those must now be searched as well.                  foreach (string file in Directory.GetFiles(colMapDir' "Seq*.xls"' SearchOption.AllDirectories))                  {                      //Extract sequence number from filename                      string localFilename = Path.GetFileName(file);                      Regex sequenceFormat = new Regex(@"^Seq(\d{1'4})\.xls$");                      Match match = sequenceFormat.Match(localFilename);                      if (!match.Groups[0].Success)                      {                          _log.Warn("Malformed filename found in sequence files folder; skipping\n\t" + file);                          continue;                      }                      int seqNo = int.Parse(match.Groups[1].Value);                        //Read data from file                      var reader = new SequenceFileReader(file).GetReader();                      if (reader == null)                      {                          _log.Error("One of the sequence files is missing; skipping\n\t" + file);                          continue;                      }                        DataSet fileData = reader.AsDataSet(false);                      if (fileData.Tables == null || fileData.Tables.Count == 0)                      {                          _log.ErrorFormat("Sequence File had no readable variables: {0} "' file);                          continue;                      }                      else if (fileData.Tables.Count > 1)                      {                          _log.WarnFormat("Sequence File had multiple worksheets : {0} "' file);                      }                        DataTable firstWorksheet = fileData.Tables[0];                      if (firstWorksheet.Rows == null || firstWorksheet.Rows.Count < 2)                      {                          _log.ErrorFormat("Sequence File didn't have enough rows: {0} "' file);                          continue;                      }                      else if (firstWorksheet.Rows.Count > 2)                      {                          _log.WarnFormat("Sequence File had too many rows: {0} "' file);                      }                        //Expected values of row: FILEID'FILETYPE'STUSAB'CHARITER'SEQUENCE'LOGRECNO'...                      DataRow columnIDRow = firstWorksheet.Rows[0];                      DataRow columnNameRow = firstWorksheet.Rows[1];                        if (columnIDRow.ItemArray == null || columnIDRow.ItemArray.Length < 7)                      {                          _log.Error("One of the sequence files had bad data' skipping\n\t" + file);                          continue;                      }                        //Add data to database                      for (int i = 6; i < columnIDRow.ItemArray.Length; i++)                      {                          //This file has _ separating Table Number and offset' everywhere else doesn't                          string columnID = columnIDRow[i].ToString().Trim().Replace("_"' "");                          string columnName = (columnNameRow[i] as string);                            //                         ixid' CENSUS_TABLE_ID' NAME' COLNO' SEQNO                          var toAdd = new object[] { ixid++' columnID' columnName' i' seqNo };                          table.Rows.Add(toAdd);                      }                  }                    if ((table != null) && (table.Rows.Count > 0))                  {                      _log.Debug("Saving... (This may take a while)");                      adapter.Update(table);                      table.AcceptChanges();                  }                  else                  {                      _log.Error("Could not read any of the sequence files!");                      return false;                  }                    _log.Debug("Importing Sequence Files... Done!");                  return true;              }              else              {                  _log.Error("Could not find column mappings directory file' table not initialized!");                  return false;              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,CreateColumnMappingsTable,The following statement contains a magic number: if (Directory.Exists(colMapDir))              {                  _log.Debug("Importing Sequence Files...");                    int ixid = 0;                  // Note: this used to search only the top directory' but the 2014 data uses subdirectories'                  // so those must now be searched as well.                  foreach (string file in Directory.GetFiles(colMapDir' "Seq*.xls"' SearchOption.AllDirectories))                  {                      //Extract sequence number from filename                      string localFilename = Path.GetFileName(file);                      Regex sequenceFormat = new Regex(@"^Seq(\d{1'4})\.xls$");                      Match match = sequenceFormat.Match(localFilename);                      if (!match.Groups[0].Success)                      {                          _log.Warn("Malformed filename found in sequence files folder; skipping\n\t" + file);                          continue;                      }                      int seqNo = int.Parse(match.Groups[1].Value);                        //Read data from file                      var reader = new SequenceFileReader(file).GetReader();                      if (reader == null)                      {                          _log.Error("One of the sequence files is missing; skipping\n\t" + file);                          continue;                      }                        DataSet fileData = reader.AsDataSet(false);                      if (fileData.Tables == null || fileData.Tables.Count == 0)                      {                          _log.ErrorFormat("Sequence File had no readable variables: {0} "' file);                          continue;                      }                      else if (fileData.Tables.Count > 1)                      {                          _log.WarnFormat("Sequence File had multiple worksheets : {0} "' file);                      }                        DataTable firstWorksheet = fileData.Tables[0];                      if (firstWorksheet.Rows == null || firstWorksheet.Rows.Count < 2)                      {                          _log.ErrorFormat("Sequence File didn't have enough rows: {0} "' file);                          continue;                      }                      else if (firstWorksheet.Rows.Count > 2)                      {                          _log.WarnFormat("Sequence File had too many rows: {0} "' file);                      }                        //Expected values of row: FILEID'FILETYPE'STUSAB'CHARITER'SEQUENCE'LOGRECNO'...                      DataRow columnIDRow = firstWorksheet.Rows[0];                      DataRow columnNameRow = firstWorksheet.Rows[1];                        if (columnIDRow.ItemArray == null || columnIDRow.ItemArray.Length < 7)                      {                          _log.Error("One of the sequence files had bad data' skipping\n\t" + file);                          continue;                      }                        //Add data to database                      for (int i = 6; i < columnIDRow.ItemArray.Length; i++)                      {                          //This file has _ separating Table Number and offset' everywhere else doesn't                          string columnID = columnIDRow[i].ToString().Trim().Replace("_"' "");                          string columnName = (columnNameRow[i] as string);                            //                         ixid' CENSUS_TABLE_ID' NAME' COLNO' SEQNO                          var toAdd = new object[] { ixid++' columnID' columnName' i' seqNo };                          table.Rows.Add(toAdd);                      }                  }                    if ((table != null) && (table.Rows.Count > 0))                  {                      _log.Debug("Saving... (This may take a while)");                      adapter.Update(table);                      table.AcceptChanges();                  }                  else                  {                      _log.Error("Could not read any of the sequence files!");                      return false;                  }                    _log.Debug("Importing Sequence Files... Done!");                  return true;              }              else              {                  _log.Error("Could not find column mappings directory file' table not initialized!");                  return false;              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,CreateColumnMappingsTable,The following statement contains a magic number: if (Directory.Exists(colMapDir))              {                  _log.Debug("Importing Sequence Files...");                    int ixid = 0;                  // Note: this used to search only the top directory' but the 2014 data uses subdirectories'                  // so those must now be searched as well.                  foreach (string file in Directory.GetFiles(colMapDir' "Seq*.xls"' SearchOption.AllDirectories))                  {                      //Extract sequence number from filename                      string localFilename = Path.GetFileName(file);                      Regex sequenceFormat = new Regex(@"^Seq(\d{1'4})\.xls$");                      Match match = sequenceFormat.Match(localFilename);                      if (!match.Groups[0].Success)                      {                          _log.Warn("Malformed filename found in sequence files folder; skipping\n\t" + file);                          continue;                      }                      int seqNo = int.Parse(match.Groups[1].Value);                        //Read data from file                      var reader = new SequenceFileReader(file).GetReader();                      if (reader == null)                      {                          _log.Error("One of the sequence files is missing; skipping\n\t" + file);                          continue;                      }                        DataSet fileData = reader.AsDataSet(false);                      if (fileData.Tables == null || fileData.Tables.Count == 0)                      {                          _log.ErrorFormat("Sequence File had no readable variables: {0} "' file);                          continue;                      }                      else if (fileData.Tables.Count > 1)                      {                          _log.WarnFormat("Sequence File had multiple worksheets : {0} "' file);                      }                        DataTable firstWorksheet = fileData.Tables[0];                      if (firstWorksheet.Rows == null || firstWorksheet.Rows.Count < 2)                      {                          _log.ErrorFormat("Sequence File didn't have enough rows: {0} "' file);                          continue;                      }                      else if (firstWorksheet.Rows.Count > 2)                      {                          _log.WarnFormat("Sequence File had too many rows: {0} "' file);                      }                        //Expected values of row: FILEID'FILETYPE'STUSAB'CHARITER'SEQUENCE'LOGRECNO'...                      DataRow columnIDRow = firstWorksheet.Rows[0];                      DataRow columnNameRow = firstWorksheet.Rows[1];                        if (columnIDRow.ItemArray == null || columnIDRow.ItemArray.Length < 7)                      {                          _log.Error("One of the sequence files had bad data' skipping\n\t" + file);                          continue;                      }                        //Add data to database                      for (int i = 6; i < columnIDRow.ItemArray.Length; i++)                      {                          //This file has _ separating Table Number and offset' everywhere else doesn't                          string columnID = columnIDRow[i].ToString().Trim().Replace("_"' "");                          string columnName = (columnNameRow[i] as string);                            //                         ixid' CENSUS_TABLE_ID' NAME' COLNO' SEQNO                          var toAdd = new object[] { ixid++' columnID' columnName' i' seqNo };                          table.Rows.Add(toAdd);                      }                  }                    if ((table != null) && (table.Rows.Count > 0))                  {                      _log.Debug("Saving... (This may take a while)");                      adapter.Update(table);                      table.AcceptChanges();                  }                  else                  {                      _log.Error("Could not read any of the sequence files!");                      return false;                  }                    _log.Debug("Importing Sequence Files... Done!");                  return true;              }              else              {                  _log.Error("Could not find column mappings directory file' table not initialized!");                  return false;              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,CreateColumnMappingsTable,The following statement contains a magic number: if (Directory.Exists(colMapDir))              {                  _log.Debug("Importing Sequence Files...");                    int ixid = 0;                  // Note: this used to search only the top directory' but the 2014 data uses subdirectories'                  // so those must now be searched as well.                  foreach (string file in Directory.GetFiles(colMapDir' "Seq*.xls"' SearchOption.AllDirectories))                  {                      //Extract sequence number from filename                      string localFilename = Path.GetFileName(file);                      Regex sequenceFormat = new Regex(@"^Seq(\d{1'4})\.xls$");                      Match match = sequenceFormat.Match(localFilename);                      if (!match.Groups[0].Success)                      {                          _log.Warn("Malformed filename found in sequence files folder; skipping\n\t" + file);                          continue;                      }                      int seqNo = int.Parse(match.Groups[1].Value);                        //Read data from file                      var reader = new SequenceFileReader(file).GetReader();                      if (reader == null)                      {                          _log.Error("One of the sequence files is missing; skipping\n\t" + file);                          continue;                      }                        DataSet fileData = reader.AsDataSet(false);                      if (fileData.Tables == null || fileData.Tables.Count == 0)                      {                          _log.ErrorFormat("Sequence File had no readable variables: {0} "' file);                          continue;                      }                      else if (fileData.Tables.Count > 1)                      {                          _log.WarnFormat("Sequence File had multiple worksheets : {0} "' file);                      }                        DataTable firstWorksheet = fileData.Tables[0];                      if (firstWorksheet.Rows == null || firstWorksheet.Rows.Count < 2)                      {                          _log.ErrorFormat("Sequence File didn't have enough rows: {0} "' file);                          continue;                      }                      else if (firstWorksheet.Rows.Count > 2)                      {                          _log.WarnFormat("Sequence File had too many rows: {0} "' file);                      }                        //Expected values of row: FILEID'FILETYPE'STUSAB'CHARITER'SEQUENCE'LOGRECNO'...                      DataRow columnIDRow = firstWorksheet.Rows[0];                      DataRow columnNameRow = firstWorksheet.Rows[1];                        if (columnIDRow.ItemArray == null || columnIDRow.ItemArray.Length < 7)                      {                          _log.Error("One of the sequence files had bad data' skipping\n\t" + file);                          continue;                      }                        //Add data to database                      for (int i = 6; i < columnIDRow.ItemArray.Length; i++)                      {                          //This file has _ separating Table Number and offset' everywhere else doesn't                          string columnID = columnIDRow[i].ToString().Trim().Replace("_"' "");                          string columnName = (columnNameRow[i] as string);                            //                         ixid' CENSUS_TABLE_ID' NAME' COLNO' SEQNO                          var toAdd = new object[] { ixid++' columnID' columnName' i' seqNo };                          table.Rows.Add(toAdd);                      }                  }                    if ((table != null) && (table.Rows.Count > 0))                  {                      _log.Debug("Saving... (This may take a while)");                      adapter.Update(table);                      table.AcceptChanges();                  }                  else                  {                      _log.Error("Could not read any of the sequence files!");                      return false;                  }                    _log.Debug("Importing Sequence Files... Done!");                  return true;              }              else              {                  _log.Error("Could not find column mappings directory file' table not initialized!");                  return false;              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,CheckBuildVariableTable,The following statement contains a magic number: try              {                  using (var conn = DbClient.GetConnection())                  {                      if (DataClient.HasTable(conn' DbClient' tableName))                      {                          if (!ReusePreviousJobTable)                          {                              DbClient.GetCommand(string.Format("DROP TABLE IF EXISTS \"{0}\";"' tableName)' conn).ExecuteNonQuery();                          }                          else                          {                              _log.DebugFormat("Table {0} was already built"' tableName);                              return true;                          }                      }                          //gets a list of the LRUs we want                      HashSet<string> requestedLRNs = GetFilteredLRUs(conn);                        //gets all the variable mapping information we need                      DataTable reqVariablesDT = GetRequestedVariables(conn);                      if ((reqVariablesDT == null) || (reqVariablesDT.Rows.Count == 0))                      {                          _log.Info("Zero variables found: I couldn't understand those variables' can you check them and try again?");                          //_log.Warn("I didn't understand those variables' can you check them and try again?");                          return false;                      }                          DataTable newTable = new DataTable();                      newTable.Columns.Add("LOGRECNO"' typeof(string));                      Dictionary<string' DataRow> rowsByLRN = new Dictionary<string' DataRow>(requestedLRNs.Count);                      foreach (var id in requestedLRNs)                      {                          var row = newTable.NewRow();                          row[0] = id;                          newTable.Rows.Add(row);                            rowsByLRN[id] = row;                      }                        bool shouldNotParseErrorValues = PreserveJam;                        _log.Debug("Importing Columns");                      int varNum = 0;                      foreach (DataRow variableRow in reqVariablesDT.Rows)                      {                          if (this.IsCancelled()) { return false; }                            varNum++;                            var sequenceNo = Utilities.GetAs<int>(variableRow["SEQNO"] as string' -1);                          var seqFile = Directory.GetFiles(this.GetAggregateDataPath()' "e*" + sequenceNo.ToString("0000") + "000.txt");    //0001000                          if ((seqFile == null) || (seqFile.Length == 0))                          {                              _log.DebugFormat("Couldn't find sequence file {0}"' sequenceNo);                              continue;                          }                            var errorFile = Directory.GetFiles(this.GetAggregateDataPath()' "m*" + sequenceNo.ToString("0000") + "000.txt");    //0001000                          if ((errorFile == null) || (errorFile.Length == 0))                          {                              _log.DebugFormat("Couldn't find error margin file {0}"' sequenceNo);                          }                            //These next two if statement checks should probably be removed once                          //#19869 is resolved                          //Until that case is resolved' we can't guarantee rows in reqVariablesDT will be                          //unique so they should stay.                            //TODO: alternate column naming?                          string newColumnName = variableRow["COLNAME"] as string;                          if (newTable.Columns.Contains(newColumnName))                          {                              newColumnName = newColumnName + varNum;                          }                          newTable.Columns.Add(newColumnName' typeof(double));                            //this really ought to be unique.                          string newErrorMarginColumnName = "m" + newColumnName;                          if (newTable.Columns.Contains(newErrorMarginColumnName))                          {                              newErrorMarginColumnName = newErrorMarginColumnName + varNum;                          }                            if (shouldNotParseErrorValues)                          {                              newTable.Columns.Add(newErrorMarginColumnName' typeof(string));                          }                          else                          {                              newTable.Columns.Add(newErrorMarginColumnName' typeof(double));                          }                                _log.DebugFormat("Importing {0}..."' newColumnName);                          int columnIDX = Utilities.GetAs<int>(variableRow["COLNO"] as string' -1);                                CommaSeparatedValueReader reader = new CommaSeparatedValueReader(seqFile[0]' false);                          foreach (List<string> values in reader)                          {                              string lrn = values[5];                              if (!requestedLRNs.Contains(lrn))                                  continue;                                if (columnIDX < values.Count)                              {                                  double val = Utilities.GetAs<double>(values[columnIDX]' double.NaN);                                  if (!double.IsNaN(val))                                  {                                      rowsByLRN[lrn][newColumnName] = val;                                  }                              }                                if (this.IsCancelled()) { break; }                          }                          reader.Close();                            //these error files better have the exact same format!                          reader = new CommaSeparatedValueReader(errorFile[0]' false);                          foreach (List<string> values in reader)                          {                              string lrn = values[5];                              if (!requestedLRNs.Contains(lrn))                                  continue;                                if (columnIDX < values.Count)                              {                                  if (shouldNotParseErrorValues)                                  {                                      rowsByLRN[lrn][newErrorMarginColumnName] = values[columnIDX];                                  }                                  else                                  {                                      double val = Utilities.GetAs<double>(values[columnIDX]' double.NaN);                                      if (!double.IsNaN(val))                                      {                                          rowsByLRN[lrn][newErrorMarginColumnName] = val;                                      }                                      rowsByLRN[lrn][newErrorMarginColumnName] = val;                                  }                              }                                if (this.IsCancelled()) { break; }                          }                          reader.Close();                      }                        if (this.IsCancelled()) { return false; }                      _log.DebugFormat("Creating Table {0}"' tableName);                      string createTableSQL = SqliteDataClient.GenerateTableSQLFromTable(tableName' newTable' "LOGRECNO");                      DbClient.GetCommand(createTableSQL' conn).ExecuteNonQuery();                        if (this.IsCancelled()) { return false; }                      _log.DebugFormat("Saving Table {0}..."' tableName);                      var dba = DataClient.GetMagicAdapter(conn' DbClient' string.Format("SELECT * FROM \"{0}\""' tableName));                      dba.Update(newTable);                      _log.Debug("Done!");                            _log.Debug("Import complete!");                        //TODO: save the table to the database                  }                  return true;              }              catch (Exception ex)              {                  _log.Error("Error while building table"' ex);              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,CheckBuildVariableTable,The following statement contains a magic number: try              {                  using (var conn = DbClient.GetConnection())                  {                      if (DataClient.HasTable(conn' DbClient' tableName))                      {                          if (!ReusePreviousJobTable)                          {                              DbClient.GetCommand(string.Format("DROP TABLE IF EXISTS \"{0}\";"' tableName)' conn).ExecuteNonQuery();                          }                          else                          {                              _log.DebugFormat("Table {0} was already built"' tableName);                              return true;                          }                      }                          //gets a list of the LRUs we want                      HashSet<string> requestedLRNs = GetFilteredLRUs(conn);                        //gets all the variable mapping information we need                      DataTable reqVariablesDT = GetRequestedVariables(conn);                      if ((reqVariablesDT == null) || (reqVariablesDT.Rows.Count == 0))                      {                          _log.Info("Zero variables found: I couldn't understand those variables' can you check them and try again?");                          //_log.Warn("I didn't understand those variables' can you check them and try again?");                          return false;                      }                          DataTable newTable = new DataTable();                      newTable.Columns.Add("LOGRECNO"' typeof(string));                      Dictionary<string' DataRow> rowsByLRN = new Dictionary<string' DataRow>(requestedLRNs.Count);                      foreach (var id in requestedLRNs)                      {                          var row = newTable.NewRow();                          row[0] = id;                          newTable.Rows.Add(row);                            rowsByLRN[id] = row;                      }                        bool shouldNotParseErrorValues = PreserveJam;                        _log.Debug("Importing Columns");                      int varNum = 0;                      foreach (DataRow variableRow in reqVariablesDT.Rows)                      {                          if (this.IsCancelled()) { return false; }                            varNum++;                            var sequenceNo = Utilities.GetAs<int>(variableRow["SEQNO"] as string' -1);                          var seqFile = Directory.GetFiles(this.GetAggregateDataPath()' "e*" + sequenceNo.ToString("0000") + "000.txt");    //0001000                          if ((seqFile == null) || (seqFile.Length == 0))                          {                              _log.DebugFormat("Couldn't find sequence file {0}"' sequenceNo);                              continue;                          }                            var errorFile = Directory.GetFiles(this.GetAggregateDataPath()' "m*" + sequenceNo.ToString("0000") + "000.txt");    //0001000                          if ((errorFile == null) || (errorFile.Length == 0))                          {                              _log.DebugFormat("Couldn't find error margin file {0}"' sequenceNo);                          }                            //These next two if statement checks should probably be removed once                          //#19869 is resolved                          //Until that case is resolved' we can't guarantee rows in reqVariablesDT will be                          //unique so they should stay.                            //TODO: alternate column naming?                          string newColumnName = variableRow["COLNAME"] as string;                          if (newTable.Columns.Contains(newColumnName))                          {                              newColumnName = newColumnName + varNum;                          }                          newTable.Columns.Add(newColumnName' typeof(double));                            //this really ought to be unique.                          string newErrorMarginColumnName = "m" + newColumnName;                          if (newTable.Columns.Contains(newErrorMarginColumnName))                          {                              newErrorMarginColumnName = newErrorMarginColumnName + varNum;                          }                            if (shouldNotParseErrorValues)                          {                              newTable.Columns.Add(newErrorMarginColumnName' typeof(string));                          }                          else                          {                              newTable.Columns.Add(newErrorMarginColumnName' typeof(double));                          }                                _log.DebugFormat("Importing {0}..."' newColumnName);                          int columnIDX = Utilities.GetAs<int>(variableRow["COLNO"] as string' -1);                                CommaSeparatedValueReader reader = new CommaSeparatedValueReader(seqFile[0]' false);                          foreach (List<string> values in reader)                          {                              string lrn = values[5];                              if (!requestedLRNs.Contains(lrn))                                  continue;                                if (columnIDX < values.Count)                              {                                  double val = Utilities.GetAs<double>(values[columnIDX]' double.NaN);                                  if (!double.IsNaN(val))                                  {                                      rowsByLRN[lrn][newColumnName] = val;                                  }                              }                                if (this.IsCancelled()) { break; }                          }                          reader.Close();                            //these error files better have the exact same format!                          reader = new CommaSeparatedValueReader(errorFile[0]' false);                          foreach (List<string> values in reader)                          {                              string lrn = values[5];                              if (!requestedLRNs.Contains(lrn))                                  continue;                                if (columnIDX < values.Count)                              {                                  if (shouldNotParseErrorValues)                                  {                                      rowsByLRN[lrn][newErrorMarginColumnName] = values[columnIDX];                                  }                                  else                                  {                                      double val = Utilities.GetAs<double>(values[columnIDX]' double.NaN);                                      if (!double.IsNaN(val))                                      {                                          rowsByLRN[lrn][newErrorMarginColumnName] = val;                                      }                                      rowsByLRN[lrn][newErrorMarginColumnName] = val;                                  }                              }                                if (this.IsCancelled()) { break; }                          }                          reader.Close();                      }                        if (this.IsCancelled()) { return false; }                      _log.DebugFormat("Creating Table {0}"' tableName);                      string createTableSQL = SqliteDataClient.GenerateTableSQLFromTable(tableName' newTable' "LOGRECNO");                      DbClient.GetCommand(createTableSQL' conn).ExecuteNonQuery();                        if (this.IsCancelled()) { return false; }                      _log.DebugFormat("Saving Table {0}..."' tableName);                      var dba = DataClient.GetMagicAdapter(conn' DbClient' string.Format("SELECT * FROM \"{0}\""' tableName));                      dba.Update(newTable);                      _log.Debug("Done!");                            _log.Debug("Import complete!");                        //TODO: save the table to the database                  }                  return true;              }              catch (Exception ex)              {                  _log.Error("Error while building table"' ex);              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,GetGeometryRowKeyGenerator,The following statement contains a magic number: if ((this.SummaryLevel == "140") || (this.SummaryLevel == "150"))              {                  keyDelegate = (DataRow row) =>                  {                      string county = Utilities.GetAs<string>(row["COUNTY"]' "-1");                      string tract = Utilities.GetAs<string>(row["TRACT"]' "-1");                      string blkgroup = Utilities.GetAs<string>(row["BLKGROUP"]' "-1");                      if (tract.Trim().Length != 6)                          tract += "00";                        return string.Format("{0}_{1}_{2}"' county' tract' blkgroup);                  };              }              else if (this.SummaryLevel == "060")              {                  keyDelegate = (DataRow row) =>                  {                      string county = Utilities.GetAs<string>(row["COUNTY"]' "-1");                      string cousub = Utilities.GetAs<string>(row["COUSUB"]' "-1");                        return string.Format("{0}_{1}"' county' cousub);                  };              }              else if (this.SummaryLevel == "050")              {                  keyDelegate = (DataRow row) =>                  {                      return Utilities.GetAs<string>(row["COUNTY"]' "-1");                  };              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,GetShapeFeaturesToExport,The following statement contains a magic number: using (var conn = DbClient.GetConnection())              {                  Dictionary<string' DataRow> shapeDict = GetShapeRowsByLOGRECNO(conn);                  var variablesDT = DataClient.GetMagicTable(conn' DbClient' string.Format("select * from \"{0}\" "' tableName));                  if ((variablesDT == null) || (variablesDT.Rows.Count == 0))                  {                      _log.Warn("Nothing to export' data table is empty");                      _log.Error("Nothing to export' data table is empty");                      return null;                  }                    bool shouldReproject = (!string.IsNullOrEmpty(this.OutputProjectionFilename));                  ICoordinateTransformation reprojector = null;                  ICoordinateSystem destCRS = null;                  if (!string.IsNullOrEmpty(this.OutputProjectionFilename))                  {                      destCRS = Utilities.GetCoordinateSystemByWKTFile(this.OutputProjectionFilename);                      reprojector = Utilities.BuildTransformationObject(GeographicCoordinateSystem.WGS84' destCRS);                  }                    //TODO:                  bool shouldAddMissingShapes = this.IncludeEmptyGridCells;                  HashSet<string> allShapeIDs = new HashSet<string>(shapeDict.Keys);                    //Build hashset' remove by shapeid as shapes are added'                  //go through and add missing shapes if 'shouldAddMissingShapes' is set...                  bool variablesHaveGeoID = variablesDT.Columns.Contains("GEOID");                    List<IGeometry> filteringGeoms = null;                  if (!string.IsNullOrEmpty(this.ExportFilterFilename))                  {                      filteringGeoms = (spatialFilter) ? GetFilteringGeometries(this.ExportFilterFilename' destCRS) : null;                      //Die if we're supposed to have a filter but don't                      if (spatialFilter && filteringGeoms == null)                      {                          return null;                      }                  }                      GisSharpBlog.NetTopologySuite.IO.WKBReader binReader = new WKBReader(                      ShapefileHelper.GetGeomFactory());                  var features = new List<Feature>(variablesDT.Rows.Count);                    foreach (DataRow row in variablesDT.Rows)                  {                      var id = row["LOGRECNO"] as string;                      if (!shapeDict.ContainsKey(id))                          continue;                        allShapeIDs.Remove(id);                        AttributesTable t = new AttributesTable();                      foreach (DataColumn col in variablesDT.Columns)                      {                          //produces more sane results.                          t.AddAttribute(                              Utilities.EnsureMaxLength(col.ColumnName' 10)'                              Utilities.GetAsType(col.DataType' row[col.Ordinal]' null)                              );                      }                        byte[] geomBytes = (byte[])shapeDict[id]["Geometry"];                      IGeometry geom = binReader.Read(geomBytes);                      if (geom == null)                      {                          _log.WarnFormat("Geometry for LRN {0} was empty!"' id);                          continue;                      }                        if (shouldReproject)                      {                          geom = Utilities.ReprojectGeometry(geom' reprojector);                      }                        if (spatialFilter)                      {                          if (!IsIncluded(geom' filteringGeoms))                          {                              continue;                          }                      }                        if (!variablesHaveGeoID)                      {                          t.AddAttribute("GEOID"' shapeDict[id]["GEOID"]);                      }                        if (this.AddStrippedGEOIDcolumn)                      {                          t.AddAttribute("GEOID_STRP"' (t["GEOID"] as string).Replace(Settings.GeoidPrefix' ""));                      }                        if (this.AddGeometryAttributesToOutput)                      {                          t.AddAttribute("AREA"' geom.Area);                          t.AddAttribute("PERIMETER"' geom.Length);                            var centroid = geom.Centroid;                          t.AddAttribute("CENTROID_X"' centroid.X);                          t.AddAttribute("CENTROID_Y"' centroid.Y);                      }                        features.Add(new Feature(geom' t));                  }                    if (shouldAddMissingShapes)                  {                      _log.DebugFormat("Adding {0} missing shapes"' allShapeIDs.Count);                      foreach (string id in allShapeIDs)                      {                          byte[] geomBytes = (byte[])shapeDict[id]["Geometry"];                          IGeometry geom = binReader.Read(geomBytes);                          if (geom == null)                          {                              _log.WarnFormat("Geometry for LRN {0} was empty!"' id);                              continue;                          }                            if (shouldReproject)                          {                              geom = Utilities.ReprojectGeometry(geom' reprojector);                          }                            if (spatialFilter)                          {                              if (!IsIncluded(geom' filteringGeoms))                              {                                  continue;                              }                          }                            AttributesTable t = new AttributesTable();                          foreach (DataColumn col in variablesDT.Columns)                          {                              //produces more sane results.                              t.AddAttribute(Utilities.EnsureMaxLength(col.ColumnName' 10)' null);                          }                            if (!variablesHaveGeoID)                          {                              t.AddAttribute("GEOID"' shapeDict[id]["GEOID"]);                          }                            if (this.AddStrippedGEOIDcolumn)                          {                              t.AddAttribute("GEOID_STRP"' (t["GEOID"] as string).Replace(Settings.GeoidPrefix' ""));                          }                            if (this.AddGeometryAttributesToOutput)                          {                              t.AddAttribute("AREA"' geom.Area);                              t.AddAttribute("PERIMETER"' geom.Length);                                var centroid = geom.Centroid;                              t.AddAttribute("CENTROID_X"' centroid.X);                              t.AddAttribute("CENTROID_Y"' centroid.Y);                          }                            t["LOGRECNO"] = id;                          features.Add(new Feature(geom' t));                      }                  }                    return features;              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,GetShapeFeaturesToExport,The following statement contains a magic number: using (var conn = DbClient.GetConnection())              {                  Dictionary<string' DataRow> shapeDict = GetShapeRowsByLOGRECNO(conn);                  var variablesDT = DataClient.GetMagicTable(conn' DbClient' string.Format("select * from \"{0}\" "' tableName));                  if ((variablesDT == null) || (variablesDT.Rows.Count == 0))                  {                      _log.Warn("Nothing to export' data table is empty");                      _log.Error("Nothing to export' data table is empty");                      return null;                  }                    bool shouldReproject = (!string.IsNullOrEmpty(this.OutputProjectionFilename));                  ICoordinateTransformation reprojector = null;                  ICoordinateSystem destCRS = null;                  if (!string.IsNullOrEmpty(this.OutputProjectionFilename))                  {                      destCRS = Utilities.GetCoordinateSystemByWKTFile(this.OutputProjectionFilename);                      reprojector = Utilities.BuildTransformationObject(GeographicCoordinateSystem.WGS84' destCRS);                  }                    //TODO:                  bool shouldAddMissingShapes = this.IncludeEmptyGridCells;                  HashSet<string> allShapeIDs = new HashSet<string>(shapeDict.Keys);                    //Build hashset' remove by shapeid as shapes are added'                  //go through and add missing shapes if 'shouldAddMissingShapes' is set...                  bool variablesHaveGeoID = variablesDT.Columns.Contains("GEOID");                    List<IGeometry> filteringGeoms = null;                  if (!string.IsNullOrEmpty(this.ExportFilterFilename))                  {                      filteringGeoms = (spatialFilter) ? GetFilteringGeometries(this.ExportFilterFilename' destCRS) : null;                      //Die if we're supposed to have a filter but don't                      if (spatialFilter && filteringGeoms == null)                      {                          return null;                      }                  }                      GisSharpBlog.NetTopologySuite.IO.WKBReader binReader = new WKBReader(                      ShapefileHelper.GetGeomFactory());                  var features = new List<Feature>(variablesDT.Rows.Count);                    foreach (DataRow row in variablesDT.Rows)                  {                      var id = row["LOGRECNO"] as string;                      if (!shapeDict.ContainsKey(id))                          continue;                        allShapeIDs.Remove(id);                        AttributesTable t = new AttributesTable();                      foreach (DataColumn col in variablesDT.Columns)                      {                          //produces more sane results.                          t.AddAttribute(                              Utilities.EnsureMaxLength(col.ColumnName' 10)'                              Utilities.GetAsType(col.DataType' row[col.Ordinal]' null)                              );                      }                        byte[] geomBytes = (byte[])shapeDict[id]["Geometry"];                      IGeometry geom = binReader.Read(geomBytes);                      if (geom == null)                      {                          _log.WarnFormat("Geometry for LRN {0} was empty!"' id);                          continue;                      }                        if (shouldReproject)                      {                          geom = Utilities.ReprojectGeometry(geom' reprojector);                      }                        if (spatialFilter)                      {                          if (!IsIncluded(geom' filteringGeoms))                          {                              continue;                          }                      }                        if (!variablesHaveGeoID)                      {                          t.AddAttribute("GEOID"' shapeDict[id]["GEOID"]);                      }                        if (this.AddStrippedGEOIDcolumn)                      {                          t.AddAttribute("GEOID_STRP"' (t["GEOID"] as string).Replace(Settings.GeoidPrefix' ""));                      }                        if (this.AddGeometryAttributesToOutput)                      {                          t.AddAttribute("AREA"' geom.Area);                          t.AddAttribute("PERIMETER"' geom.Length);                            var centroid = geom.Centroid;                          t.AddAttribute("CENTROID_X"' centroid.X);                          t.AddAttribute("CENTROID_Y"' centroid.Y);                      }                        features.Add(new Feature(geom' t));                  }                    if (shouldAddMissingShapes)                  {                      _log.DebugFormat("Adding {0} missing shapes"' allShapeIDs.Count);                      foreach (string id in allShapeIDs)                      {                          byte[] geomBytes = (byte[])shapeDict[id]["Geometry"];                          IGeometry geom = binReader.Read(geomBytes);                          if (geom == null)                          {                              _log.WarnFormat("Geometry for LRN {0} was empty!"' id);                              continue;                          }                            if (shouldReproject)                          {                              geom = Utilities.ReprojectGeometry(geom' reprojector);                          }                            if (spatialFilter)                          {                              if (!IsIncluded(geom' filteringGeoms))                              {                                  continue;                              }                          }                            AttributesTable t = new AttributesTable();                          foreach (DataColumn col in variablesDT.Columns)                          {                              //produces more sane results.                              t.AddAttribute(Utilities.EnsureMaxLength(col.ColumnName' 10)' null);                          }                            if (!variablesHaveGeoID)                          {                              t.AddAttribute("GEOID"' shapeDict[id]["GEOID"]);                          }                            if (this.AddStrippedGEOIDcolumn)                          {                              t.AddAttribute("GEOID_STRP"' (t["GEOID"] as string).Replace(Settings.GeoidPrefix' ""));                          }                            if (this.AddGeometryAttributesToOutput)                          {                              t.AddAttribute("AREA"' geom.Area);                              t.AddAttribute("PERIMETER"' geom.Length);                                var centroid = geom.Centroid;                              t.AddAttribute("CENTROID_X"' centroid.X);                              t.AddAttribute("CENTROID_Y"' centroid.Y);                          }                            t["LOGRECNO"] = id;                          features.Add(new Feature(geom' t));                      }                  }                    return features;              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,ExportGriddedShapefile,The following statement contains a magic number: try              {                  _log.DebugFormat("Retrieving contents of job {0}"' tableName);                  //don't filter out geometries' we'll do that at the cell level                  var exportFeatures = GetShapeFeaturesToExport(tableName' false);                  if ((exportFeatures == null) || (exportFeatures.Count == 0))                  {                      _log.ErrorFormat("Export of Job \"{0}\" failed' no features to export!"' tableName);                      return false;                  }                    ICoordinateSystem outputCrs = GeographicCoordinateSystem.WGS84;                  if (!string.IsNullOrEmpty(this.OutputProjectionFilename))                  {                      outputCrs = Utilities.GetCoordinateSystemByWKTFile(this.OutputProjectionFilename);                  }                    //if we need to reproject:                  List<IGeometry> filteringGeoms = GetFilteringGeometries(this.ExportFilterFilename' outputCrs);                    //put everything into a basic spatial index                  Envelope env = new Envelope();                  var index = new GisSharpBlog.NetTopologySuite.Index.Strtree.STRtree();                  for (int i = 0; i < exportFeatures.Count; i++)                  {                      Feature f = exportFeatures[i];                      index.Insert(f.Geometry.EnvelopeInternal' f);                      env.ExpandToInclude(f.Geometry.EnvelopeInternal);                  }                  if (IsCancelled()) { _log.Debug("Job Cancelled..."); return false; }                  index.Build();                                          //adjust envelope to only scan area inside filtering geometries                                  if (!string.IsNullOrEmpty(this.GridEnvelopeFilename))                  {                      //a specified envelope file overrides the envelope of the filtering geometries                      env = GetGridEnvelope();                  }                  else if ((filteringGeoms != null) && (filteringGeoms.Count > 0))                  {                      //in the absence ... //TODO: finish--                      env = new Envelope();                      for (int i = 0; i < filteringGeoms.Count; i++)                      {                          env.ExpandToInclude(filteringGeoms[i].EnvelopeInternal);                      }                  }                        //progress tracking                  DateTime start = DateTime.Now' lastCheck = DateTime.Now;                  int lastProgress = 0;                      var features = new List<Feature>(exportFeatures.Count);                    double cellWidth = GridCellWidth;                  double cellHeight = GridCellHeight;                  bool discardEmptyGridCells = !IncludeEmptyGridCells;                      int numRows = (int)Math.Ceiling(env.Height / cellHeight);                  int numCols = (int)Math.Ceiling(env.Width / cellWidth);                  int expectedCells = numRows * numCols;                    if (expectedCells > 1000000)                  {                      _log.Warn("**********************");                      _log.Warn("Your selected area will produce a shapefile with over a million cells' is that a good idea?");                      _log.WarnFormat("Area of {0}' Expected Cell Count of {1}"' env.Area' expectedCells);                      _log.Warn("**********************");                  }                    DbaseFileHeader header = null;                  using (var conn = DbClient.GetConnection())                  {                      //Dictionary<string' DataRow> shapeDict = GetShapeRowsByLOGRECNO(conn);                      var variablesDT = DataClient.GetMagicTable(conn' DbClient' string.Format("SELECT * FROM \"{0}\" where 0 = 1 "' tableName));                      header = ShapefileHelper.SetupHeader(variablesDT);                  }                  ShapefileHelper.AddColumn(header' "CELLID"' typeof(string));                  ShapefileHelper.AddColumn(header' "GEOID"' typeof(string));                  if (this.AddStrippedGEOIDcolumn)                  {                      ShapefileHelper.AddColumn(header' "GEOID_STRP"' typeof(string));                  }                    //lets not add these to the fishnet exports just yet                  //if (this.AddGeometryAttributesToOutput)                  //{                  //    ShapefileHelper.AddColumn(header' "AREA"' typeof(double));                  //    ShapefileHelper.AddColumn(header' "PERIMETER"' typeof(double));                  //    ShapefileHelper.AddColumn(header' "CENTROID"' typeof(double));                  //}                    int cellCount = 0;                  int xidx = 0;                  for (double x = env.MinX; x < env.MaxX; x += cellWidth)                  {                      xidx++;                      int yidx = 0;                      for (double y = env.MinY; y < env.MaxY; y += cellHeight)                      {                          yidx++;                          cellCount++;                          string cellID = string.Format("{0}_{1}"' xidx' yidx);                            Envelope cellEnv = new Envelope(x' x + cellWidth' y' y + cellHeight);                          IGeometry cellCenter = new Point(cellEnv.Centre);                          IGeometry cellGeom = Utilities.IEnvToIGeometry(cellEnv);                            Feature found = null;                          IList mightMatch = index.Query(cellGeom.EnvelopeInternal);                          foreach (Feature f in mightMatch)                          {                              if (f.Geometry.Contains(cellCenter))                              {                                  found = f;                                  break;                              }                          }                            if ((found == null) && (discardEmptyGridCells))                          {                              //_log.DebugFormat("No feature found for cell {0}"' cellID);                              continue;                          }                              //if we have filtering geometries' skip a cell if it isn't included                          if (!IsIncluded(cellGeom' filteringGeoms))                          {                              continue;                          }                            if ((cellCount % 1000) == 0)                          {                              int step = (int)((((double)cellCount) / ((double)expectedCells)) * 100.0);                              TimeSpan elapsed = (DateTime.Now - lastCheck);                              if ((step != lastProgress) && (elapsed.TotalSeconds > 1))                              {                                  _log.DebugFormat("{0:###.##}% complete' {1:#0.0#} seconds' {2} built' {3} checked' {4} left"'                                     step' (DateTime.Now - start).TotalSeconds'                                     features.Count'                                     cellCount'                                     expectedCells - cellCount                                     );                                  lastCheck = DateTime.Now;                                  lastProgress = step;                                    if (IsCancelled()) { _log.Debug("Job Cancelled..."); return false; }                              }                          }                            //this is a lot of work just to add an id...                          AttributesTable attribs = new AttributesTable();                          if (found != null)                          {                              //if (!found.Attributes.GetNames().Contains("GEOID"))                              //    throw new Exception("GEOID NOT FOUND!!!!");                              foreach (string name in found.Attributes.GetNames())                              {                                  attribs.AddAttribute(name' found.Attributes[name]);                              }                              attribs.AddAttribute("CELLID"' cellID);                          }                          else                          {                              foreach (var field in header.Fields)                              {                                  attribs.AddAttribute(field.Name' null);                              }                              attribs["CELLID"] = cellID;                          }                            features.Add(new Feature(cellGeom' attribs));                      }                  }                  _log.Debug("Done building cells' Saving Shapefile...");                  header.NumRecords = features.Count;                    if (features.Count == 0)                  {                      _log.Error("No features found' exiting!");                      return false;                  }                    string newShapefilename = Path.Combine(Environment.CurrentDirectory' tableName);                  if (!string.IsNullOrEmpty(OutputFolder))                  {                      newShapefilename = Path.Combine(OutputFolder' tableName);                  }                    if (IsCancelled()) { _log.Debug("Job Cancelled..."); return false; }                  var writer = new ShapefileDataWriter(newShapefilename' ShapefileHelper.GetGeomFactory());                  writer.Header = header;                  writer.Write(features);                      if (!string.IsNullOrEmpty(this.OutputProjectionFilename))                  {                      //Reproject everything in this file to the requested projection...                                                              ShapefileHelper.MakeOutputProjFile(this.OutputProjectionFilename' newShapefilename);                  }                  else                  {                      ShapefileHelper.MakeCensusProjFile(newShapefilename);                  }                    _log.Debug("Done! Shapefile exported successfully");                  return true;              }              catch (FileNotFoundException notFound)              {                  string msg = "A needed file couldn't be found: " + notFound.FileName;                  _log.Error(msg);                  _log.Fatal("The export cannot continue.  Exiting...");                  throw new ApplicationException(msg);              }              catch (Exception ex)              {                  _log.Error("Error while exporting shapefile"' ex);              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,ExportGriddedShapefile,The following statement contains a magic number: try              {                  _log.DebugFormat("Retrieving contents of job {0}"' tableName);                  //don't filter out geometries' we'll do that at the cell level                  var exportFeatures = GetShapeFeaturesToExport(tableName' false);                  if ((exportFeatures == null) || (exportFeatures.Count == 0))                  {                      _log.ErrorFormat("Export of Job \"{0}\" failed' no features to export!"' tableName);                      return false;                  }                    ICoordinateSystem outputCrs = GeographicCoordinateSystem.WGS84;                  if (!string.IsNullOrEmpty(this.OutputProjectionFilename))                  {                      outputCrs = Utilities.GetCoordinateSystemByWKTFile(this.OutputProjectionFilename);                  }                    //if we need to reproject:                  List<IGeometry> filteringGeoms = GetFilteringGeometries(this.ExportFilterFilename' outputCrs);                    //put everything into a basic spatial index                  Envelope env = new Envelope();                  var index = new GisSharpBlog.NetTopologySuite.Index.Strtree.STRtree();                  for (int i = 0; i < exportFeatures.Count; i++)                  {                      Feature f = exportFeatures[i];                      index.Insert(f.Geometry.EnvelopeInternal' f);                      env.ExpandToInclude(f.Geometry.EnvelopeInternal);                  }                  if (IsCancelled()) { _log.Debug("Job Cancelled..."); return false; }                  index.Build();                                          //adjust envelope to only scan area inside filtering geometries                                  if (!string.IsNullOrEmpty(this.GridEnvelopeFilename))                  {                      //a specified envelope file overrides the envelope of the filtering geometries                      env = GetGridEnvelope();                  }                  else if ((filteringGeoms != null) && (filteringGeoms.Count > 0))                  {                      //in the absence ... //TODO: finish--                      env = new Envelope();                      for (int i = 0; i < filteringGeoms.Count; i++)                      {                          env.ExpandToInclude(filteringGeoms[i].EnvelopeInternal);                      }                  }                        //progress tracking                  DateTime start = DateTime.Now' lastCheck = DateTime.Now;                  int lastProgress = 0;                      var features = new List<Feature>(exportFeatures.Count);                    double cellWidth = GridCellWidth;                  double cellHeight = GridCellHeight;                  bool discardEmptyGridCells = !IncludeEmptyGridCells;                      int numRows = (int)Math.Ceiling(env.Height / cellHeight);                  int numCols = (int)Math.Ceiling(env.Width / cellWidth);                  int expectedCells = numRows * numCols;                    if (expectedCells > 1000000)                  {                      _log.Warn("**********************");                      _log.Warn("Your selected area will produce a shapefile with over a million cells' is that a good idea?");                      _log.WarnFormat("Area of {0}' Expected Cell Count of {1}"' env.Area' expectedCells);                      _log.Warn("**********************");                  }                    DbaseFileHeader header = null;                  using (var conn = DbClient.GetConnection())                  {                      //Dictionary<string' DataRow> shapeDict = GetShapeRowsByLOGRECNO(conn);                      var variablesDT = DataClient.GetMagicTable(conn' DbClient' string.Format("SELECT * FROM \"{0}\" where 0 = 1 "' tableName));                      header = ShapefileHelper.SetupHeader(variablesDT);                  }                  ShapefileHelper.AddColumn(header' "CELLID"' typeof(string));                  ShapefileHelper.AddColumn(header' "GEOID"' typeof(string));                  if (this.AddStrippedGEOIDcolumn)                  {                      ShapefileHelper.AddColumn(header' "GEOID_STRP"' typeof(string));                  }                    //lets not add these to the fishnet exports just yet                  //if (this.AddGeometryAttributesToOutput)                  //{                  //    ShapefileHelper.AddColumn(header' "AREA"' typeof(double));                  //    ShapefileHelper.AddColumn(header' "PERIMETER"' typeof(double));                  //    ShapefileHelper.AddColumn(header' "CENTROID"' typeof(double));                  //}                    int cellCount = 0;                  int xidx = 0;                  for (double x = env.MinX; x < env.MaxX; x += cellWidth)                  {                      xidx++;                      int yidx = 0;                      for (double y = env.MinY; y < env.MaxY; y += cellHeight)                      {                          yidx++;                          cellCount++;                          string cellID = string.Format("{0}_{1}"' xidx' yidx);                            Envelope cellEnv = new Envelope(x' x + cellWidth' y' y + cellHeight);                          IGeometry cellCenter = new Point(cellEnv.Centre);                          IGeometry cellGeom = Utilities.IEnvToIGeometry(cellEnv);                            Feature found = null;                          IList mightMatch = index.Query(cellGeom.EnvelopeInternal);                          foreach (Feature f in mightMatch)                          {                              if (f.Geometry.Contains(cellCenter))                              {                                  found = f;                                  break;                              }                          }                            if ((found == null) && (discardEmptyGridCells))                          {                              //_log.DebugFormat("No feature found for cell {0}"' cellID);                              continue;                          }                              //if we have filtering geometries' skip a cell if it isn't included                          if (!IsIncluded(cellGeom' filteringGeoms))                          {                              continue;                          }                            if ((cellCount % 1000) == 0)                          {                              int step = (int)((((double)cellCount) / ((double)expectedCells)) * 100.0);                              TimeSpan elapsed = (DateTime.Now - lastCheck);                              if ((step != lastProgress) && (elapsed.TotalSeconds > 1))                              {                                  _log.DebugFormat("{0:###.##}% complete' {1:#0.0#} seconds' {2} built' {3} checked' {4} left"'                                     step' (DateTime.Now - start).TotalSeconds'                                     features.Count'                                     cellCount'                                     expectedCells - cellCount                                     );                                  lastCheck = DateTime.Now;                                  lastProgress = step;                                    if (IsCancelled()) { _log.Debug("Job Cancelled..."); return false; }                              }                          }                            //this is a lot of work just to add an id...                          AttributesTable attribs = new AttributesTable();                          if (found != null)                          {                              //if (!found.Attributes.GetNames().Contains("GEOID"))                              //    throw new Exception("GEOID NOT FOUND!!!!");                              foreach (string name in found.Attributes.GetNames())                              {                                  attribs.AddAttribute(name' found.Attributes[name]);                              }                              attribs.AddAttribute("CELLID"' cellID);                          }                          else                          {                              foreach (var field in header.Fields)                              {                                  attribs.AddAttribute(field.Name' null);                              }                              attribs["CELLID"] = cellID;                          }                            features.Add(new Feature(cellGeom' attribs));                      }                  }                  _log.Debug("Done building cells' Saving Shapefile...");                  header.NumRecords = features.Count;                    if (features.Count == 0)                  {                      _log.Error("No features found' exiting!");                      return false;                  }                    string newShapefilename = Path.Combine(Environment.CurrentDirectory' tableName);                  if (!string.IsNullOrEmpty(OutputFolder))                  {                      newShapefilename = Path.Combine(OutputFolder' tableName);                  }                    if (IsCancelled()) { _log.Debug("Job Cancelled..."); return false; }                  var writer = new ShapefileDataWriter(newShapefilename' ShapefileHelper.GetGeomFactory());                  writer.Header = header;                  writer.Write(features);                      if (!string.IsNullOrEmpty(this.OutputProjectionFilename))                  {                      //Reproject everything in this file to the requested projection...                                                              ShapefileHelper.MakeOutputProjFile(this.OutputProjectionFilename' newShapefilename);                  }                  else                  {                      ShapefileHelper.MakeCensusProjFile(newShapefilename);                  }                    _log.Debug("Done! Shapefile exported successfully");                  return true;              }              catch (FileNotFoundException notFound)              {                  string msg = "A needed file couldn't be found: " + notFound.FileName;                  _log.Error(msg);                  _log.Fatal("The export cannot continue.  Exiting...");                  throw new ApplicationException(msg);              }              catch (Exception ex)              {                  _log.Error("Error while exporting shapefile"' ex);              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,ExportGriddedShapefile,The following statement contains a magic number: try              {                  _log.DebugFormat("Retrieving contents of job {0}"' tableName);                  //don't filter out geometries' we'll do that at the cell level                  var exportFeatures = GetShapeFeaturesToExport(tableName' false);                  if ((exportFeatures == null) || (exportFeatures.Count == 0))                  {                      _log.ErrorFormat("Export of Job \"{0}\" failed' no features to export!"' tableName);                      return false;                  }                    ICoordinateSystem outputCrs = GeographicCoordinateSystem.WGS84;                  if (!string.IsNullOrEmpty(this.OutputProjectionFilename))                  {                      outputCrs = Utilities.GetCoordinateSystemByWKTFile(this.OutputProjectionFilename);                  }                    //if we need to reproject:                  List<IGeometry> filteringGeoms = GetFilteringGeometries(this.ExportFilterFilename' outputCrs);                    //put everything into a basic spatial index                  Envelope env = new Envelope();                  var index = new GisSharpBlog.NetTopologySuite.Index.Strtree.STRtree();                  for (int i = 0; i < exportFeatures.Count; i++)                  {                      Feature f = exportFeatures[i];                      index.Insert(f.Geometry.EnvelopeInternal' f);                      env.ExpandToInclude(f.Geometry.EnvelopeInternal);                  }                  if (IsCancelled()) { _log.Debug("Job Cancelled..."); return false; }                  index.Build();                                          //adjust envelope to only scan area inside filtering geometries                                  if (!string.IsNullOrEmpty(this.GridEnvelopeFilename))                  {                      //a specified envelope file overrides the envelope of the filtering geometries                      env = GetGridEnvelope();                  }                  else if ((filteringGeoms != null) && (filteringGeoms.Count > 0))                  {                      //in the absence ... //TODO: finish--                      env = new Envelope();                      for (int i = 0; i < filteringGeoms.Count; i++)                      {                          env.ExpandToInclude(filteringGeoms[i].EnvelopeInternal);                      }                  }                        //progress tracking                  DateTime start = DateTime.Now' lastCheck = DateTime.Now;                  int lastProgress = 0;                      var features = new List<Feature>(exportFeatures.Count);                    double cellWidth = GridCellWidth;                  double cellHeight = GridCellHeight;                  bool discardEmptyGridCells = !IncludeEmptyGridCells;                      int numRows = (int)Math.Ceiling(env.Height / cellHeight);                  int numCols = (int)Math.Ceiling(env.Width / cellWidth);                  int expectedCells = numRows * numCols;                    if (expectedCells > 1000000)                  {                      _log.Warn("**********************");                      _log.Warn("Your selected area will produce a shapefile with over a million cells' is that a good idea?");                      _log.WarnFormat("Area of {0}' Expected Cell Count of {1}"' env.Area' expectedCells);                      _log.Warn("**********************");                  }                    DbaseFileHeader header = null;                  using (var conn = DbClient.GetConnection())                  {                      //Dictionary<string' DataRow> shapeDict = GetShapeRowsByLOGRECNO(conn);                      var variablesDT = DataClient.GetMagicTable(conn' DbClient' string.Format("SELECT * FROM \"{0}\" where 0 = 1 "' tableName));                      header = ShapefileHelper.SetupHeader(variablesDT);                  }                  ShapefileHelper.AddColumn(header' "CELLID"' typeof(string));                  ShapefileHelper.AddColumn(header' "GEOID"' typeof(string));                  if (this.AddStrippedGEOIDcolumn)                  {                      ShapefileHelper.AddColumn(header' "GEOID_STRP"' typeof(string));                  }                    //lets not add these to the fishnet exports just yet                  //if (this.AddGeometryAttributesToOutput)                  //{                  //    ShapefileHelper.AddColumn(header' "AREA"' typeof(double));                  //    ShapefileHelper.AddColumn(header' "PERIMETER"' typeof(double));                  //    ShapefileHelper.AddColumn(header' "CENTROID"' typeof(double));                  //}                    int cellCount = 0;                  int xidx = 0;                  for (double x = env.MinX; x < env.MaxX; x += cellWidth)                  {                      xidx++;                      int yidx = 0;                      for (double y = env.MinY; y < env.MaxY; y += cellHeight)                      {                          yidx++;                          cellCount++;                          string cellID = string.Format("{0}_{1}"' xidx' yidx);                            Envelope cellEnv = new Envelope(x' x + cellWidth' y' y + cellHeight);                          IGeometry cellCenter = new Point(cellEnv.Centre);                          IGeometry cellGeom = Utilities.IEnvToIGeometry(cellEnv);                            Feature found = null;                          IList mightMatch = index.Query(cellGeom.EnvelopeInternal);                          foreach (Feature f in mightMatch)                          {                              if (f.Geometry.Contains(cellCenter))                              {                                  found = f;                                  break;                              }                          }                            if ((found == null) && (discardEmptyGridCells))                          {                              //_log.DebugFormat("No feature found for cell {0}"' cellID);                              continue;                          }                              //if we have filtering geometries' skip a cell if it isn't included                          if (!IsIncluded(cellGeom' filteringGeoms))                          {                              continue;                          }                            if ((cellCount % 1000) == 0)                          {                              int step = (int)((((double)cellCount) / ((double)expectedCells)) * 100.0);                              TimeSpan elapsed = (DateTime.Now - lastCheck);                              if ((step != lastProgress) && (elapsed.TotalSeconds > 1))                              {                                  _log.DebugFormat("{0:###.##}% complete' {1:#0.0#} seconds' {2} built' {3} checked' {4} left"'                                     step' (DateTime.Now - start).TotalSeconds'                                     features.Count'                                     cellCount'                                     expectedCells - cellCount                                     );                                  lastCheck = DateTime.Now;                                  lastProgress = step;                                    if (IsCancelled()) { _log.Debug("Job Cancelled..."); return false; }                              }                          }                            //this is a lot of work just to add an id...                          AttributesTable attribs = new AttributesTable();                          if (found != null)                          {                              //if (!found.Attributes.GetNames().Contains("GEOID"))                              //    throw new Exception("GEOID NOT FOUND!!!!");                              foreach (string name in found.Attributes.GetNames())                              {                                  attribs.AddAttribute(name' found.Attributes[name]);                              }                              attribs.AddAttribute("CELLID"' cellID);                          }                          else                          {                              foreach (var field in header.Fields)                              {                                  attribs.AddAttribute(field.Name' null);                              }                              attribs["CELLID"] = cellID;                          }                            features.Add(new Feature(cellGeom' attribs));                      }                  }                  _log.Debug("Done building cells' Saving Shapefile...");                  header.NumRecords = features.Count;                    if (features.Count == 0)                  {                      _log.Error("No features found' exiting!");                      return false;                  }                    string newShapefilename = Path.Combine(Environment.CurrentDirectory' tableName);                  if (!string.IsNullOrEmpty(OutputFolder))                  {                      newShapefilename = Path.Combine(OutputFolder' tableName);                  }                    if (IsCancelled()) { _log.Debug("Job Cancelled..."); return false; }                  var writer = new ShapefileDataWriter(newShapefilename' ShapefileHelper.GetGeomFactory());                  writer.Header = header;                  writer.Write(features);                      if (!string.IsNullOrEmpty(this.OutputProjectionFilename))                  {                      //Reproject everything in this file to the requested projection...                                                              ShapefileHelper.MakeOutputProjFile(this.OutputProjectionFilename' newShapefilename);                  }                  else                  {                      ShapefileHelper.MakeCensusProjFile(newShapefilename);                  }                    _log.Debug("Done! Shapefile exported successfully");                  return true;              }              catch (FileNotFoundException notFound)              {                  string msg = "A needed file couldn't be found: " + notFound.FileName;                  _log.Error(msg);                  _log.Fatal("The export cannot continue.  Exiting...");                  throw new ApplicationException(msg);              }              catch (Exception ex)              {                  _log.Error("Error while exporting shapefile"' ex);              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,GetGridEnvelope,The following statement contains a magic number: if (!string.IsNullOrEmpty(GridEnvelopeFilename))              {                  string[] lines = File.ReadAllLines(GridEnvelopeFilename);                  foreach (string line in lines)                  {                      if (line.StartsWith("#") || line.StartsWith("//"))                          continue;                        string[] chunks = line.Split(" ':".ToCharArray()' StringSplitOptions.RemoveEmptyEntries);                      env = new Envelope(                          Utilities.GetAs<double>(chunks[0]' -1)'     //env.MinX                          Utilities.GetAs<double>(chunks[2]' -1)'  //env.MaxX                          Utilities.GetAs<double>(chunks[1]' -1)'   //env.MinY                          Utilities.GetAs<double>(chunks[3]' -1)    //env.MaxY                      );                      break;                  }              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,GetGridEnvelope,The following statement contains a magic number: if (!string.IsNullOrEmpty(GridEnvelopeFilename))              {                  string[] lines = File.ReadAllLines(GridEnvelopeFilename);                  foreach (string line in lines)                  {                      if (line.StartsWith("#") || line.StartsWith("//"))                          continue;                        string[] chunks = line.Split(" ':".ToCharArray()' StringSplitOptions.RemoveEmptyEntries);                      env = new Envelope(                          Utilities.GetAs<double>(chunks[0]' -1)'     //env.MinX                          Utilities.GetAs<double>(chunks[2]' -1)'  //env.MaxX                          Utilities.GetAs<double>(chunks[1]' -1)'   //env.MinY                          Utilities.GetAs<double>(chunks[3]' -1)    //env.MaxY                      );                      break;                  }              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,SetGridParam,The following statement contains a magic number: if (chunks.Length > 0)              {                  //only provided the one' make em square!                  this.GridCellWidth = Utilities.GetAs<double>(chunks[0]' 10000);                  this.GridCellHeight = this.GridCellWidth;              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,SetGridParam,The following statement contains a magic number: if (chunks.Length > 1)              {                  //they provided both                  this.GridCellHeight = Utilities.GetAs<double>(chunks[0]' 10000);                  this.GridCellHeight = Utilities.GetAs<double>(chunks[1]' 10000);              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,SetGridParam,The following statement contains a magic number: if (chunks.Length > 1)              {                  //they provided both                  this.GridCellHeight = Utilities.GetAs<double>(chunks[0]' 10000);                  this.GridCellHeight = Utilities.GetAs<double>(chunks[1]' 10000);              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,FileDownloader,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\FileDownloader.cs,GetFileByURL,The following statement contains a magic number: if (File.Exists(filePath))              {                  //don't keep harassing the server if the file is less than one week old' for Pete's sake.                  TimeSpan elapsed = (DateTime.Now - File.GetCreationTime(filePath));                  preExists = true;                  if (elapsed.TotalDays < 7)                  {                      _log.DebugFormat("File {0} is less than 7 days old' skipping"' Path.GetFileName(filePath));                      System.Threading.Thread.Sleep(100); //give the disk a chance to catch up                      return true;                  }              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,FileDownloader,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\FileDownloader.cs,GetFileByURL,The following statement contains a magic number: if (File.Exists(filePath))              {                  //don't keep harassing the server if the file is less than one week old' for Pete's sake.                  TimeSpan elapsed = (DateTime.Now - File.GetCreationTime(filePath));                  preExists = true;                  if (elapsed.TotalDays < 7)                  {                      _log.DebugFormat("File {0} is less than 7 days old' skipping"' Path.GetFileName(filePath));                      System.Threading.Thread.Sleep(100); //give the disk a chance to catch up                      return true;                  }              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,FileDownloader,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\FileDownloader.cs,GetFileByURL,The following statement contains a magic number: while ((!File.Exists(filePath) || preExists) && retries < 4)              {                  try                  {                      if (workOffline && File.Exists(filePath))                      {                          _log.DebugFormat("Working Offline! - Skipping file stamp check");                          return true;                      }                          _lastQuery = DateTime.Now;                      System.Threading.Thread.Sleep(250); //just a little pre-nap so we don't hammer the server                        HttpWebRequest request = (HttpWebRequest)WebRequest.Create(desiredURL);                      request.KeepAlive = false;  //We're only doing this once                      request.Credentials = CredentialCache.DefaultCredentials;                      request.Timeout = Settings.TimeOutMs;                      using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())                      {                          Stream downloadStream = response.GetResponseStream();                          long expectedLength = response.ContentLength;                          DateTime lastModified = response.LastModified;                              if (File.Exists(filePath))                          {                              string srcDate = response.LastModified.ToShortDateString();                              string localDate = File.GetLastWriteTime(filePath).ToShortDateString();                              if (localDate == srcDate)                              {                                  _log.DebugFormat("File {0} already exists' and date stamps match' skipping"'                                      Path.GetFileName(filePath));                                    FileUtilities.TryChangeCreationTime(filePath' DateTime.Now);                                  return true;                              }                          }                            FileStream output = new FileStream(filePath' FileMode.Create);                          Utilities.CopyToWithProgress(downloadStream' expectedLength' output' ref cancelled);                                                    downloadStream.Close();                          output.Close();                          response.Close();                          request.Abort();                            if (cancelled)                          {                              //try to clean up after ourselves                              FileUtilities.TryDelete(filePath);                              _log.DebugFormat("Cancelling... Attempting to delete partially downloaded file {0}"' Path.GetFileName(filePath));                          }                                                    if (!cancelled)                          {                              FileUtilities.TryChangeLastWriteTime(filePath' response.LastModified);                              _log.DebugFormat("Downloaded of {0} was successful"' Path.GetFileName(filePath));                              if (Settings.ShowFilePaths)                              {                                  _log.InfoFormat("Downloaded File {0} saved to {1}"' Path.GetFileName(filePath)' filePath);                              }                          }                          else                          {                              return false;                          }                      }                        return true;                  }                  catch (UnauthorizedAccessException cantWriteEx)                  {                      string msg = "The importer couldn't save the file' please run this application as administrator' or set the output directory.";                      _log.Error(msg);                      _log.Fatal("The importer cannot continue.  Exiting...");                      throw new ApplicationException(msg);                  }                  catch (Exception ex)                  {                      _log.Error("Error downloading file' retrying"' ex);                        //This is to avoid the server blocking too many connection requests                      if ((DateTime.Now - _lastQuery).Milliseconds < WaitTimeMs)                      {                          int nap = (int)Math.Pow(2' retries) * WaitTimeMs - (DateTime.Now - _lastQuery).Milliseconds;                          if (nap > 0)                          {                              _log.DebugFormat("Sleeping for {0}ms before starting download"' nap);                              System.Threading.Thread.Sleep(nap);                          }                      }                  }                    retries++;              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,FileDownloader,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\FileDownloader.cs,GetFileByURL,The following statement contains a magic number: while ((!File.Exists(filePath) || preExists) && retries < 4)              {                  try                  {                      if (workOffline && File.Exists(filePath))                      {                          _log.DebugFormat("Working Offline! - Skipping file stamp check");                          return true;                      }                          _lastQuery = DateTime.Now;                      System.Threading.Thread.Sleep(250); //just a little pre-nap so we don't hammer the server                        HttpWebRequest request = (HttpWebRequest)WebRequest.Create(desiredURL);                      request.KeepAlive = false;  //We're only doing this once                      request.Credentials = CredentialCache.DefaultCredentials;                      request.Timeout = Settings.TimeOutMs;                      using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())                      {                          Stream downloadStream = response.GetResponseStream();                          long expectedLength = response.ContentLength;                          DateTime lastModified = response.LastModified;                              if (File.Exists(filePath))                          {                              string srcDate = response.LastModified.ToShortDateString();                              string localDate = File.GetLastWriteTime(filePath).ToShortDateString();                              if (localDate == srcDate)                              {                                  _log.DebugFormat("File {0} already exists' and date stamps match' skipping"'                                      Path.GetFileName(filePath));                                    FileUtilities.TryChangeCreationTime(filePath' DateTime.Now);                                  return true;                              }                          }                            FileStream output = new FileStream(filePath' FileMode.Create);                          Utilities.CopyToWithProgress(downloadStream' expectedLength' output' ref cancelled);                                                    downloadStream.Close();                          output.Close();                          response.Close();                          request.Abort();                            if (cancelled)                          {                              //try to clean up after ourselves                              FileUtilities.TryDelete(filePath);                              _log.DebugFormat("Cancelling... Attempting to delete partially downloaded file {0}"' Path.GetFileName(filePath));                          }                                                    if (!cancelled)                          {                              FileUtilities.TryChangeLastWriteTime(filePath' response.LastModified);                              _log.DebugFormat("Downloaded of {0} was successful"' Path.GetFileName(filePath));                              if (Settings.ShowFilePaths)                              {                                  _log.InfoFormat("Downloaded File {0} saved to {1}"' Path.GetFileName(filePath)' filePath);                              }                          }                          else                          {                              return false;                          }                      }                        return true;                  }                  catch (UnauthorizedAccessException cantWriteEx)                  {                      string msg = "The importer couldn't save the file' please run this application as administrator' or set the output directory.";                      _log.Error(msg);                      _log.Fatal("The importer cannot continue.  Exiting...");                      throw new ApplicationException(msg);                  }                  catch (Exception ex)                  {                      _log.Error("Error downloading file' retrying"' ex);                        //This is to avoid the server blocking too many connection requests                      if ((DateTime.Now - _lastQuery).Milliseconds < WaitTimeMs)                      {                          int nap = (int)Math.Pow(2' retries) * WaitTimeMs - (DateTime.Now - _lastQuery).Milliseconds;                          if (nap > 0)                          {                              _log.DebugFormat("Sleeping for {0}ms before starting download"' nap);                              System.Threading.Thread.Sleep(nap);                          }                      }                  }                    retries++;              }
Magic Number,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,FileDownloader,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\FileDownloader.cs,GetFileByURL,The following statement contains a magic number: while ((!File.Exists(filePath) || preExists) && retries < 4)              {                  try                  {                      if (workOffline && File.Exists(filePath))                      {                          _log.DebugFormat("Working Offline! - Skipping file stamp check");                          return true;                      }                          _lastQuery = DateTime.Now;                      System.Threading.Thread.Sleep(250); //just a little pre-nap so we don't hammer the server                        HttpWebRequest request = (HttpWebRequest)WebRequest.Create(desiredURL);                      request.KeepAlive = false;  //We're only doing this once                      request.Credentials = CredentialCache.DefaultCredentials;                      request.Timeout = Settings.TimeOutMs;                      using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())                      {                          Stream downloadStream = response.GetResponseStream();                          long expectedLength = response.ContentLength;                          DateTime lastModified = response.LastModified;                              if (File.Exists(filePath))                          {                              string srcDate = response.LastModified.ToShortDateString();                              string localDate = File.GetLastWriteTime(filePath).ToShortDateString();                              if (localDate == srcDate)                              {                                  _log.DebugFormat("File {0} already exists' and date stamps match' skipping"'                                      Path.GetFileName(filePath));                                    FileUtilities.TryChangeCreationTime(filePath' DateTime.Now);                                  return true;                              }                          }                            FileStream output = new FileStream(filePath' FileMode.Create);                          Utilities.CopyToWithProgress(downloadStream' expectedLength' output' ref cancelled);                                                    downloadStream.Close();                          output.Close();                          response.Close();                          request.Abort();                            if (cancelled)                          {                              //try to clean up after ourselves                              FileUtilities.TryDelete(filePath);                              _log.DebugFormat("Cancelling... Attempting to delete partially downloaded file {0}"' Path.GetFileName(filePath));                          }                                                    if (!cancelled)                          {                              FileUtilities.TryChangeLastWriteTime(filePath' response.LastModified);                              _log.DebugFormat("Downloaded of {0} was successful"' Path.GetFileName(filePath));                              if (Settings.ShowFilePaths)                              {                                  _log.InfoFormat("Downloaded File {0} saved to {1}"' Path.GetFileName(filePath)' filePath);                              }                          }                          else                          {                              return false;                          }                      }                        return true;                  }                  catch (UnauthorizedAccessException cantWriteEx)                  {                      string msg = "The importer couldn't save the file' please run this application as administrator' or set the output directory.";                      _log.Error(msg);                      _log.Fatal("The importer cannot continue.  Exiting...");                      throw new ApplicationException(msg);                  }                  catch (Exception ex)                  {                      _log.Error("Error downloading file' retrying"' ex);                        //This is to avoid the server blocking too many connection requests                      if ((DateTime.Now - _lastQuery).Milliseconds < WaitTimeMs)                      {                          int nap = (int)Math.Pow(2' retries) * WaitTimeMs - (DateTime.Now - _lastQuery).Milliseconds;                          if (nap > 0)                          {                              _log.DebugFormat("Sleeping for {0}ms before starting download"' nap);                              System.Threading.Thread.Sleep(nap);                          }                      }                  }                    retries++;              }
Duplicate Code,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,GetShapeFeaturesToExport,The method contains a code clone-set at the following line numbers (starting from the method definition): ((64' 84)' (113' 133))
Duplicate Code,Azavea.NijPredictivePolicing.ACSAlchemistLibrary.Transfer,AcsDataManager,C:\repos\azavea_acs-alchemist\csharp\Azavea.NijPredictivePolicing.AcsImporterLibrary\Transfer\AcsDataManager.cs,GetShapeFeaturesToExport,The method contains a code clone-set at the following line numbers (starting from the method definition): ((83' 104)' (139' 160))
