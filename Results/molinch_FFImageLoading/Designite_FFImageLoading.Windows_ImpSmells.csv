Implementation smell,Namespace,Class,File,Method,Description
Long Method,FFImageLoading,FFImage,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\FFImage.cs,LoadImage,The method has 119 lines of code.
Long Method,FFImageLoading.Views,MvxCachedImageView,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Views\MvxCachedImageView.cs,UpdateImageLoadingTask,The method has 129 lines of code.
Complex Method,FFImageLoading,FFImage,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\FFImage.cs,LoadImage,Cyclomatic complexity of the method is 14
Complex Method,FFImageLoading.Views,MvxCachedImageView,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Views\MvxCachedImageView.cs,UpdateImageLoadingTask,Cyclomatic complexity of the method is 25
Complex Method,FFImageLoading.Views,MvxCachedImageView,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Views\MvxCachedImageView.cs,GetImageSourceBinding,Cyclomatic complexity of the method is 9
Long Parameter List,FFImageLoading.Extensions,ImageExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ImageExtensions.cs,ToBitmapImageAsync,The method has 6 parameters. Parameters: imageStream' downscale' downscaleDipUnits' mode' allowUpscale' imageInformation
Long Parameter List,FFImageLoading.Extensions,ImageExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ImageExtensions.cs,ToBitmapHolderAsync,The method has 6 parameters. Parameters: imageStream' downscale' downscaleDipUnits' mode' allowUpscale' imageInformation
Long Parameter List,FFImageLoading.Extensions,ImageExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ImageExtensions.cs,ResizeImage,The method has 7 parameters. Parameters: imageStream' width' height' interpolationMode' useDipUnits' allowUpscale' imageInformation
Long Parameter List,FFImageLoading.Transformations,TransformationBase,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Transformations\TransformationBase.cs,Transform,The method has 5 parameters. Parameters: bitmapHolder' path' source' isPlaceholder' key
Long Parameter List,FFImageLoading.Transformations,TransformationBase,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Transformations\TransformationBase.cs,Transform,The method has 5 parameters. Parameters: bitmapHolder' path' source' isPlaceholder' key
Long Parameter List,FFImageLoading.Work,PlatformImageLoaderTask<TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Work\PlatformImageLoaderTask.cs,TransformAsync,The method has 5 parameters. Parameters: bitmap' transformations' path' source' isPlaceholder
Long Parameter List,FFImageLoading.Decoders,BaseDecoder,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Decoders\BaseDecoder.cs,DecodeAsync,The method has 5 parameters. Parameters: imageData' path' source' imageInformation' parameters
Long Identifier,FFImageLoading,FFImage,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\FFImage.cs,,The length of the parameter HorizontalImageAlignmentProperty is 32.
Long Identifier,FFImageLoading,FFImage,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\FFImage.cs,,The length of the parameter VerticalImageAlignmentProperty is 30.
Long Identifier,FFImageLoading.Views,MvxCachedImageView,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Views\MvxCachedImageView.cs,,The length of the parameter FadeAnimationForCachedImagesProperty is 36.
Long Identifier,FFImageLoading.Views,MvxCachedImageView,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Views\MvxCachedImageView.cs,,The length of the parameter CustomLoadingPlaceholderDataResolverProperty is 44.
Long Identifier,FFImageLoading.Views,MvxCachedImageView,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Views\MvxCachedImageView.cs,,The length of the parameter CustomErrorPlaceholderDataResolverProperty is 42.
Long Identifier,FFImageLoading.Views,MvxCachedImageView,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Views\MvxCachedImageView.cs,,The length of the parameter LoadingPlaceholderImagePathProperty is 35.
Long Identifier,FFImageLoading.Views,MvxCachedImageView,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Views\MvxCachedImageView.cs,,The length of the parameter ErrorPlaceholderImagePathProperty is 33.
Long Identifier,FFImageLoading.Views,MvxCachedImageView,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Views\MvxCachedImageView.cs,,The length of the parameter HorizontalImageAlignmentProperty is 32.
Long Identifier,FFImageLoading.Views,MvxCachedImageView,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Views\MvxCachedImageView.cs,,The length of the parameter VerticalImageAlignmentProperty is 30.
Long Statement,FFImageLoading.Cache,ImageCache,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Cache\ImageCache.cs,RemoveSimilar,The length of the statement  "            var keysToRemove = _reusableBitmaps.Keys.Where(i => i.StartsWith(pattern' StringComparison.OrdinalIgnoreCase)).ToList(); " is 120.
Long Statement,FFImageLoading.Cache,SimpleDiskCache,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Cache\SimpleDiskCache.cs,InitializeEntries,The length of the statement  "                entries.TryAdd(key' new CacheEntry() { Origin = file.DateCreated.UtcDateTime' TimeToLive = duration' FileName = file.Name }); " is 125.
Long Statement,FFImageLoading.Cache,SimpleDiskCache,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Cache\SimpleDiskCache.cs,AddToSavingQueueIfNotExistsAsync,The length of the statement  "            await _currentWriteLock.WaitAsync().ConfigureAwait(false); // Make sure we don't add multiple continuations to the same task " is 124.
Long Statement,FFImageLoading.Extensions,ImageExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ImageExtensions.cs,ToBitmapImageAsync,The length of the statement  "                    using (var downscaledImage = await image.ResizeImage(downscale.Item1' downscale.Item2' mode' downscaleDipUnits' allowUpscale' imageInformation).ConfigureAwait(false)) " is 166.
Long Statement,FFImageLoading.Extensions,ImageExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ImageExtensions.cs,ToBitmapHolderAsync,The length of the statement  "                    using (var downscaledImage = await image.ResizeImage(downscale.Item1' downscale.Item2' mode' downscaleDipUnits' allowUpscale' imageInformation).ConfigureAwait(false)) " is 166.
Long Statement,FFImageLoading.Extensions,WriteableBitmapExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\WriteableBitmapExtensions.cs,AsPngStreamAsync,The length of the statement  "            encoder.SetPixelData(BitmapPixelFormat.Bgra8' BitmapAlphaMode.Premultiplied' (uint)bitmap.PixelWidth' (uint)bitmap.PixelHeight' 96' 96' pixels); " is 144.
Long Statement,FFImageLoading.Extensions,WriteableBitmapExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\WriteableBitmapExtensions.cs,AsJpegStreamAsync,The length of the statement  "            encoder.SetPixelData(BitmapPixelFormat.Bgra8' BitmapAlphaMode.Premultiplied' (uint)bitmap.PixelWidth' (uint)bitmap.PixelHeight' 96' 96' pixels); " is 144.
Long Statement,FFImageLoading.Views,MvxCachedImageView,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Views\MvxCachedImageView.cs,UpdateImageLoadingTask,The length of the statement  "                    imageLoader.DownloadStarted((downloadInformation) => OnDownloadStarted(this' new Args.DownloadStartedEventArgs(downloadInformation))); " is 134.
Long Statement,FFImageLoading.Work,PlatformImageLoaderTask<TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Work\PlatformImageLoaderTask.cs,TransformAsync,The length of the statement  "            await _decodingLock.WaitAsync(CancellationTokenSource.Token).ConfigureAwait(false); // Applying transformations is both CPU and memory intensive " is 144.
Long Statement,FFImageLoading.Decoders,BaseDecoder,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Decoders\BaseDecoder.cs,DecodeAsync,The length of the statement  "            imageIn = await imageData.ToBitmapHolderAsync(parameters.DownSampleSize' parameters.DownSampleUseDipUnits' parameters.DownSampleInterpolationMode' allowUpscale' imageInformation).ConfigureAwait(false); " is 201.
Long Statement,FFImageLoading.Decoders,BaseDecoder,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Decoders\BaseDecoder.cs,DecodeAsync,The length of the statement  "            // imageData.ToBitmapImageAsync(Parameters.DownSampleSize' Parameters.DownSampleUseDipUnits' Parameters.DownSampleInterpolationMode' allowUpscale' imageInformation).ConfigureAwait(false); " is 187.
Complex Conditional,FFImageLoading.Extensions,ImageExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ImageExtensions.cs,ResizeImage,The conditional expression  "(height > 0 && decoder.PixelHeight > height) || (width > 0 && decoder.PixelWidth > width) || allowUpscale"  is complex.
Virtual Method Call from Constructor,FFImageLoading.Cache,SimpleDiskCache,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Cache\SimpleDiskCache.cs,SimpleDiskCache,The constructor "SimpleDiskCache" calls a virtual method "Init".
Virtual Method Call from Constructor,FFImageLoading.Cache,SimpleDiskCache,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Cache\SimpleDiskCache.cs,SimpleDiskCache,The constructor "SimpleDiskCache" calls a virtual method "Init".
Empty Catch Block,FFImageLoading.Cache,FFSourceBindingCache,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Cache\FFSourceBindingCache.cs,GetFileAsync,The method has an empty catch block.
Empty Catch Block,FFImageLoading.Cache,SimpleDiskCache,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Cache\SimpleDiskCache.cs,Init,The method has an empty catch block.
Empty Catch Block,FFImageLoading.Cache,SimpleDiskCache,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Cache\SimpleDiskCache.cs,CleanCallback,The method has an empty catch block.
Empty Catch Block,FFImageLoading.Cache,SimpleDiskCache,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Cache\SimpleDiskCache.cs,RemoveAsync,The method has an empty catch block.
Empty Catch Block,FFImageLoading.DataResolvers,FileDataResolver,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\DataResolvers\FileDataResolver.cs,Resolve,The method has an empty catch block.
Empty Catch Block,FFImageLoading.DataResolvers,ResourceDataResolver,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\DataResolvers\ResourceDataResolver.cs,Resolve,The method has an empty catch block.
Empty Catch Block,FFImageLoading,ImageService,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\ImageService.cs,SetTaskForTarget,The method has an empty catch block.
Empty Catch Block,FFImageLoading,ImageService,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\ImageService.cs,CancelWorkForView,The method has an empty catch block.
Empty Catch Block,FFImageLoading.Helpers,ScaleHelper,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Helpers\ScaleHelper.cs,Init,The method has an empty catch block.
Empty Catch Block,FFImageLoading.Views,MvxCachedImageView,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Views\MvxCachedImageView.cs,Cancel,The method has an empty catch block.
Magic Number,FFImageLoading.Cache,FFSourceBindingCache,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Cache\FFSourceBindingCache.cs,IsFileAsync,The following statement contains a magic number: if (_cache.ContainsKey(path))              {                  return _cache[path].Item1;              }              else              {                  if (_cache.Count >= 128)                  {                      _cache.Clear();                  }                    StorageFile file = await GetFileAsync(path);                  _cache.Add(path' new Tuple<bool' StorageFile>(file != null' file));                  return file != null;              }
Magic Number,FFImageLoading.Cache,ImageCache,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Cache\ImageCache.cs,ImageCache,The following statement contains a magic number: if (maxCacheSize == 0)              {                  //TODO Does anyone know how we could get available app ram from WinRT API?                  EasClientDeviceInformation deviceInfo = new EasClientDeviceInformation();                  if (deviceInfo.OperatingSystem.ToLowerInvariant().Contains("phone"))                      maxCacheSize = 1000000 * 64; //64MB                  else                      maxCacheSize = 1000000 * 256; //256MB                    _logger?.Debug($"Memory cache size: {maxCacheSize} bytes");              }
Magic Number,FFImageLoading.Cache,ImageCache,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Cache\ImageCache.cs,ImageCache,The following statement contains a magic number: if (maxCacheSize == 0)              {                  //TODO Does anyone know how we could get available app ram from WinRT API?                  EasClientDeviceInformation deviceInfo = new EasClientDeviceInformation();                  if (deviceInfo.OperatingSystem.ToLowerInvariant().Contains("phone"))                      maxCacheSize = 1000000 * 64; //64MB                  else                      maxCacheSize = 1000000 * 256; //256MB                    _logger?.Debug($"Memory cache size: {maxCacheSize} bytes");              }
Magic Number,FFImageLoading.Cache,ImageCache,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Cache\ImageCache.cs,ImageCache,The following statement contains a magic number: if (maxCacheSize == 0)              {                  //TODO Does anyone know how we could get available app ram from WinRT API?                  EasClientDeviceInformation deviceInfo = new EasClientDeviceInformation();                  if (deviceInfo.OperatingSystem.ToLowerInvariant().Contains("phone"))                      maxCacheSize = 1000000 * 64; //64MB                  else                      maxCacheSize = 1000000 * 256; //256MB                    _logger?.Debug($"Memory cache size: {maxCacheSize} bytes");              }
Magic Number,FFImageLoading.Cache,ImageCache,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Cache\ImageCache.cs,ImageCache,The following statement contains a magic number: if (maxCacheSize == 0)              {                  //TODO Does anyone know how we could get available app ram from WinRT API?                  EasClientDeviceInformation deviceInfo = new EasClientDeviceInformation();                  if (deviceInfo.OperatingSystem.ToLowerInvariant().Contains("phone"))                      maxCacheSize = 1000000 * 64; //64MB                  else                      maxCacheSize = 1000000 * 256; //256MB                    _logger?.Debug($"Memory cache size: {maxCacheSize} bytes");              }
Magic Number,FFImageLoading.Cache,SimpleDiskCache,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Cache\SimpleDiskCache.cs,ClearAsync,The following statement contains a magic number: while (fileWritePendingTasks.Count != 0)              {                  await Task.Delay(20).ConfigureAwait(false);              }
Magic Number,FFImageLoading.Cache,SimpleDiskCache,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Cache\SimpleDiskCache.cs,WaitForPendingWriteIfExists,The following statement contains a magic number: while (fileWritePendingTasks.ContainsKey(key))              {                  await Task.Delay(20).ConfigureAwait(false);              }
Magic Number,FFImageLoading.Cache,WriteableBitmapLRUCache,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Cache\WriteableBitmapLRUCache.cs,GetValueSize,The following statement contains a magic number: return value.Item2.CurrentHeight * value.Item2.CurrentWidth * 4;
Magic Number,FFImageLoading.DataResolvers,ResourceDataResolver,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\DataResolvers\ResourceDataResolver.cs,Resolve,The following statement contains a magic number: try              {                  string resPath = identifier.TrimStart('\\'' '/');                    if (!resPath.StartsWith(@"Assets\") && !resPath.StartsWith("Assets/"))                  {                      resPath = @"Assets\" + resPath;                  }                    var imgUri = new Uri("ms-appx:///" + resPath);                  var key = imgUri.ToString();                  if (!_cache.TryGetValue(key' out file))                  {                      file = await StorageFile.GetFileFromApplicationUriAsync(imgUri);                        if (_cache.Count >= 128)                          _cache.Clear();                        _cache[key] = file;                  }              }              catch (Exception)              {                  try                  {                      var imgUri = new Uri("ms-appx:///" + identifier);                      var key = imgUri.ToString();                      if (!_cache.TryGetValue(key' out file))                      {                          file = await StorageFile.GetFileFromApplicationUriAsync(imgUri);                            if (_cache.Count >= 128)                              _cache.Clear();                            _cache[key] = file;                      }                  }                  catch (Exception)                  {                  }              }              finally              {                  _cacheLock.Release();              }
Magic Number,FFImageLoading.DataResolvers,ResourceDataResolver,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\DataResolvers\ResourceDataResolver.cs,Resolve,The following statement contains a magic number: try              {                  string resPath = identifier.TrimStart('\\'' '/');                    if (!resPath.StartsWith(@"Assets\") && !resPath.StartsWith("Assets/"))                  {                      resPath = @"Assets\" + resPath;                  }                    var imgUri = new Uri("ms-appx:///" + resPath);                  var key = imgUri.ToString();                  if (!_cache.TryGetValue(key' out file))                  {                      file = await StorageFile.GetFileFromApplicationUriAsync(imgUri);                        if (_cache.Count >= 128)                          _cache.Clear();                        _cache[key] = file;                  }              }              catch (Exception)              {                  try                  {                      var imgUri = new Uri("ms-appx:///" + identifier);                      var key = imgUri.ToString();                      if (!_cache.TryGetValue(key' out file))                      {                          file = await StorageFile.GetFileFromApplicationUriAsync(imgUri);                            if (_cache.Count >= 128)                              _cache.Clear();                            _cache[key] = file;                      }                  }                  catch (Exception)                  {                  }              }              finally              {                  _cacheLock.Release();              }
Magic Number,FFImageLoading.Extensions,ColorExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ColorExtensions.cs,ToColorFromHex,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(a' r' g' b);                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(255' r' g' b);                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(a' r' g' b);                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(255' r' g' b);                      }                  default:                      throw new FormatException(string.Format("The {0} string is not a recognized HexColor format."' hexColor));              }
Magic Number,FFImageLoading.Extensions,ColorExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ColorExtensions.cs,ToColorFromHex,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(a' r' g' b);                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(255' r' g' b);                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(a' r' g' b);                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(255' r' g' b);                      }                  default:                      throw new FormatException(string.Format("The {0} string is not a recognized HexColor format."' hexColor));              }
Magic Number,FFImageLoading.Extensions,ColorExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ColorExtensions.cs,ToColorFromHex,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(a' r' g' b);                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(255' r' g' b);                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(a' r' g' b);                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(255' r' g' b);                      }                  default:                      throw new FormatException(string.Format("The {0} string is not a recognized HexColor format."' hexColor));              }
Magic Number,FFImageLoading.Extensions,ColorExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ColorExtensions.cs,ToColorFromHex,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(a' r' g' b);                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(255' r' g' b);                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(a' r' g' b);                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(255' r' g' b);                      }                  default:                      throw new FormatException(string.Format("The {0} string is not a recognized HexColor format."' hexColor));              }
Magic Number,FFImageLoading.Extensions,ColorExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ColorExtensions.cs,ToColorFromHex,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(a' r' g' b);                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(255' r' g' b);                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(a' r' g' b);                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(255' r' g' b);                      }                  default:                      throw new FormatException(string.Format("The {0} string is not a recognized HexColor format."' hexColor));              }
Magic Number,FFImageLoading.Extensions,ColorExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ColorExtensions.cs,ToColorFromHex,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(a' r' g' b);                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(255' r' g' b);                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(a' r' g' b);                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(255' r' g' b);                      }                  default:                      throw new FormatException(string.Format("The {0} string is not a recognized HexColor format."' hexColor));              }
Magic Number,FFImageLoading.Extensions,ColorExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ColorExtensions.cs,ToColorFromHex,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(a' r' g' b);                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(255' r' g' b);                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(a' r' g' b);                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(255' r' g' b);                      }                  default:                      throw new FormatException(string.Format("The {0} string is not a recognized HexColor format."' hexColor));              }
Magic Number,FFImageLoading.Extensions,ColorExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ColorExtensions.cs,ToColorFromHex,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(a' r' g' b);                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(255' r' g' b);                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(a' r' g' b);                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(255' r' g' b);                      }                  default:                      throw new FormatException(string.Format("The {0} string is not a recognized HexColor format."' hexColor));              }
Magic Number,FFImageLoading.Extensions,ColorExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ColorExtensions.cs,ToColorFromHex,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(a' r' g' b);                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(255' r' g' b);                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(a' r' g' b);                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(255' r' g' b);                      }                  default:                      throw new FormatException(string.Format("The {0} string is not a recognized HexColor format."' hexColor));              }
Magic Number,FFImageLoading.Extensions,ColorExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ColorExtensions.cs,ToColorFromHex,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(a' r' g' b);                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(255' r' g' b);                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(a' r' g' b);                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(255' r' g' b);                      }                  default:                      throw new FormatException(string.Format("The {0} string is not a recognized HexColor format."' hexColor));              }
Magic Number,FFImageLoading.Extensions,ColorExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ColorExtensions.cs,ToColorFromHex,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(a' r' g' b);                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(255' r' g' b);                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(a' r' g' b);                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(255' r' g' b);                      }                  default:                      throw new FormatException(string.Format("The {0} string is not a recognized HexColor format."' hexColor));              }
Magic Number,FFImageLoading.Extensions,ColorExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ColorExtensions.cs,ToColorFromHex,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(a' r' g' b);                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(255' r' g' b);                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(a' r' g' b);                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(255' r' g' b);                      }                  default:                      throw new FormatException(string.Format("The {0} string is not a recognized HexColor format."' hexColor));              }
Magic Number,FFImageLoading.Extensions,ColorExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ColorExtensions.cs,ToColorFromHex,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(a' r' g' b);                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(255' r' g' b);                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(a' r' g' b);                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(255' r' g' b);                      }                  default:                      throw new FormatException(string.Format("The {0} string is not a recognized HexColor format."' hexColor));              }
Magic Number,FFImageLoading.Extensions,ColorExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ColorExtensions.cs,ToColorFromHex,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(a' r' g' b);                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(255' r' g' b);                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(a' r' g' b);                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(255' r' g' b);                      }                  default:                      throw new FormatException(string.Format("The {0} string is not a recognized HexColor format."' hexColor));              }
Magic Number,FFImageLoading.Extensions,ColorExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ColorExtensions.cs,ToColorFromHex,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(a' r' g' b);                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(255' r' g' b);                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(a' r' g' b);                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(255' r' g' b);                      }                  default:                      throw new FormatException(string.Format("The {0} string is not a recognized HexColor format."' hexColor));              }
Magic Number,FFImageLoading.Extensions,ColorExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ColorExtensions.cs,ToColorFromHex,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(a' r' g' b);                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(255' r' g' b);                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(a' r' g' b);                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(255' r' g' b);                      }                  default:                      throw new FormatException(string.Format("The {0} string is not a recognized HexColor format."' hexColor));              }
Magic Number,FFImageLoading.Extensions,ColorExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ColorExtensions.cs,ToColorFromHex,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(a' r' g' b);                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(255' r' g' b);                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(a' r' g' b);                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(255' r' g' b);                      }                  default:                      throw new FormatException(string.Format("The {0} string is not a recognized HexColor format."' hexColor));              }
Magic Number,FFImageLoading.Extensions,ColorExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ColorExtensions.cs,ToColorFromHex,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(a' r' g' b);                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(255' r' g' b);                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(a' r' g' b);                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(255' r' g' b);                      }                  default:                      throw new FormatException(string.Format("The {0} string is not a recognized HexColor format."' hexColor));              }
Magic Number,FFImageLoading.Extensions,ColorExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ColorExtensions.cs,ToColorFromHex,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(a' r' g' b);                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(255' r' g' b);                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(a' r' g' b);                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(255' r' g' b);                      }                  default:                      throw new FormatException(string.Format("The {0} string is not a recognized HexColor format."' hexColor));              }
Magic Number,FFImageLoading.Extensions,ColorExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ColorExtensions.cs,ToColorFromHex,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(a' r' g' b);                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(255' r' g' b);                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(a' r' g' b);                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(255' r' g' b);                      }                  default:                      throw new FormatException(string.Format("The {0} string is not a recognized HexColor format."' hexColor));              }
Magic Number,FFImageLoading.Extensions,ColorExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ColorExtensions.cs,ToColorFromHex,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(a' r' g' b);                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(255' r' g' b);                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(a' r' g' b);                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(255' r' g' b);                      }                  default:                      throw new FormatException(string.Format("The {0} string is not a recognized HexColor format."' hexColor));              }
Magic Number,FFImageLoading.Extensions,ColorExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ColorExtensions.cs,ToColorFromHex,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(a' r' g' b);                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(255' r' g' b);                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(a' r' g' b);                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(255' r' g' b);                      }                  default:                      throw new FormatException(string.Format("The {0} string is not a recognized HexColor format."' hexColor));              }
Magic Number,FFImageLoading.Extensions,ColorExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ColorExtensions.cs,ToColorFromHex,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(a' r' g' b);                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(255' r' g' b);                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(a' r' g' b);                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(255' r' g' b);                      }                  default:                      throw new FormatException(string.Format("The {0} string is not a recognized HexColor format."' hexColor));              }
Magic Number,FFImageLoading.Extensions,ColorExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ColorExtensions.cs,ToColorFromHex,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(a' r' g' b);                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(255' r' g' b);                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(a' r' g' b);                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(255' r' g' b);                      }                  default:                      throw new FormatException(string.Format("The {0} string is not a recognized HexColor format."' hexColor));              }
Magic Number,FFImageLoading.Extensions,ColorExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ColorExtensions.cs,ToColorFromHex,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(a' r' g' b);                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(255' r' g' b);                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(a' r' g' b);                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(255' r' g' b);                      }                  default:                      throw new FormatException(string.Format("The {0} string is not a recognized HexColor format."' hexColor));              }
Magic Number,FFImageLoading.Extensions,ColorExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ColorExtensions.cs,ToColorFromHex,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(a' r' g' b);                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(255' r' g' b);                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(a' r' g' b);                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(255' r' g' b);                      }                  default:                      throw new FormatException(string.Format("The {0} string is not a recognized HexColor format."' hexColor));              }
Magic Number,FFImageLoading.Extensions,ColorExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ColorExtensions.cs,ToColorFromHex,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(a' r' g' b);                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);                            return new ColorHolder(255' r' g' b);                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(a' r' g' b);                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);                            return new ColorHolder(255' r' g' b);                      }                  default:                      throw new FormatException(string.Format("The {0} string is not a recognized HexColor format."' hexColor));              }
Magic Number,FFImageLoading.Extensions,ImageExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ImageExtensions.cs,CopyPixels,The following statement contains a magic number: fixed (byte* srcPtr = data)              {                  fixed (int* dstPtr = pixels)                  {                      for (var i = 0; i < length; i++)                      {                          dstPtr[i] = (srcPtr[i * 4 + 3] << 24)                                    | (srcPtr[i * 4 + 2] << 16)                                    | (srcPtr[i * 4 + 1] << 8)                                    | srcPtr[i * 4 + 0];                      }                  }              }
Magic Number,FFImageLoading.Extensions,ImageExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ImageExtensions.cs,CopyPixels,The following statement contains a magic number: fixed (byte* srcPtr = data)              {                  fixed (int* dstPtr = pixels)                  {                      for (var i = 0; i < length; i++)                      {                          dstPtr[i] = (srcPtr[i * 4 + 3] << 24)                                    | (srcPtr[i * 4 + 2] << 16)                                    | (srcPtr[i * 4 + 1] << 8)                                    | srcPtr[i * 4 + 0];                      }                  }              }
Magic Number,FFImageLoading.Extensions,ImageExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ImageExtensions.cs,CopyPixels,The following statement contains a magic number: fixed (byte* srcPtr = data)              {                  fixed (int* dstPtr = pixels)                  {                      for (var i = 0; i < length; i++)                      {                          dstPtr[i] = (srcPtr[i * 4 + 3] << 24)                                    | (srcPtr[i * 4 + 2] << 16)                                    | (srcPtr[i * 4 + 1] << 8)                                    | srcPtr[i * 4 + 0];                      }                  }              }
Magic Number,FFImageLoading.Extensions,ImageExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ImageExtensions.cs,CopyPixels,The following statement contains a magic number: fixed (byte* srcPtr = data)              {                  fixed (int* dstPtr = pixels)                  {                      for (var i = 0; i < length; i++)                      {                          dstPtr[i] = (srcPtr[i * 4 + 3] << 24)                                    | (srcPtr[i * 4 + 2] << 16)                                    | (srcPtr[i * 4 + 1] << 8)                                    | srcPtr[i * 4 + 0];                      }                  }              }
Magic Number,FFImageLoading.Extensions,ImageExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ImageExtensions.cs,CopyPixels,The following statement contains a magic number: fixed (byte* srcPtr = data)              {                  fixed (int* dstPtr = pixels)                  {                      for (var i = 0; i < length; i++)                      {                          dstPtr[i] = (srcPtr[i * 4 + 3] << 24)                                    | (srcPtr[i * 4 + 2] << 16)                                    | (srcPtr[i * 4 + 1] << 8)                                    | srcPtr[i * 4 + 0];                      }                  }              }
Magic Number,FFImageLoading.Extensions,ImageExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ImageExtensions.cs,CopyPixels,The following statement contains a magic number: fixed (byte* srcPtr = data)              {                  fixed (int* dstPtr = pixels)                  {                      for (var i = 0; i < length; i++)                      {                          dstPtr[i] = (srcPtr[i * 4 + 3] << 24)                                    | (srcPtr[i * 4 + 2] << 16)                                    | (srcPtr[i * 4 + 1] << 8)                                    | srcPtr[i * 4 + 0];                      }                  }              }
Magic Number,FFImageLoading.Extensions,ImageExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ImageExtensions.cs,CopyPixels,The following statement contains a magic number: fixed (byte* srcPtr = data)              {                  fixed (int* dstPtr = pixels)                  {                      for (var i = 0; i < length; i++)                      {                          dstPtr[i] = (srcPtr[i * 4 + 3] << 24)                                    | (srcPtr[i * 4 + 2] << 16)                                    | (srcPtr[i * 4 + 1] << 8)                                    | srcPtr[i * 4 + 0];                      }                  }              }
Magic Number,FFImageLoading.Extensions,ImageExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ImageExtensions.cs,CopyPixels,The following statement contains a magic number: fixed (byte* srcPtr = data)              {                  fixed (int* dstPtr = pixels)                  {                      for (var i = 0; i < length; i++)                      {                          dstPtr[i] = (srcPtr[i * 4 + 3] << 24)                                    | (srcPtr[i * 4 + 2] << 16)                                    | (srcPtr[i * 4 + 1] << 8)                                    | srcPtr[i * 4 + 0];                      }                  }              }
Magic Number,FFImageLoading.Extensions,ImageExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\ImageExtensions.cs,CopyPixels,The following statement contains a magic number: fixed (byte* srcPtr = data)              {                  fixed (int* dstPtr = pixels)                  {                      for (var i = 0; i < length; i++)                      {                          dstPtr[i] = (srcPtr[i * 4 + 3] << 24)                                    | (srcPtr[i * 4 + 2] << 16)                                    | (srcPtr[i * 4 + 1] << 8)                                    | srcPtr[i * 4 + 0];                      }                  }              }
Magic Number,FFImageLoading.Extensions,WriteableBitmapExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\WriteableBitmapExtensions.cs,AsPngStreamAsync,The following statement contains a magic number: encoder.SetPixelData(BitmapPixelFormat.Bgra8' BitmapAlphaMode.Premultiplied' (uint)bitmap.PixelWidth' (uint)bitmap.PixelHeight' 96' 96' pixels);
Magic Number,FFImageLoading.Extensions,WriteableBitmapExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\WriteableBitmapExtensions.cs,AsPngStreamAsync,The following statement contains a magic number: encoder.SetPixelData(BitmapPixelFormat.Bgra8' BitmapAlphaMode.Premultiplied' (uint)bitmap.PixelWidth' (uint)bitmap.PixelHeight' 96' 96' pixels);
Magic Number,FFImageLoading.Extensions,WriteableBitmapExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\WriteableBitmapExtensions.cs,AsJpegStreamAsync,The following statement contains a magic number: encoder.SetPixelData(BitmapPixelFormat.Bgra8' BitmapAlphaMode.Premultiplied' (uint)bitmap.PixelWidth' (uint)bitmap.PixelHeight' 96' 96' pixels);
Magic Number,FFImageLoading.Extensions,WriteableBitmapExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Extensions\WriteableBitmapExtensions.cs,AsJpegStreamAsync,The following statement contains a magic number: encoder.SetPixelData(BitmapPixelFormat.Bgra8' BitmapAlphaMode.Premultiplied' (uint)bitmap.PixelWidth' (uint)bitmap.PixelHeight' 96' 96' pixels);
Magic Number,FFImageLoading,FFImageSourceBinding,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\FFImageSourceBinding.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hash = 17;                  hash = hash * 23 + this.ImageSource.GetHashCode();                  hash = hash * 23 + Path.GetHashCode();                  return hash;              }
Magic Number,FFImageLoading,FFImageSourceBinding,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\FFImageSourceBinding.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hash = 17;                  hash = hash * 23 + this.ImageSource.GetHashCode();                  hash = hash * 23 + Path.GetHashCode();                  return hash;              }
Magic Number,FFImageLoading,FFImageSourceBinding,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\FFImageSourceBinding.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int hash = 17;                  hash = hash * 23 + this.ImageSource.GetHashCode();                  hash = hash * 23 + Path.GetHashCode();                  return hash;              }
Magic Number,FFImageLoading,ColorHolder,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Helpers\ColorHolder.cs,ColorHolder,The following statement contains a magic number: A = Convert.ToByte(Math.Min(Math.Max(0' a)' 255));
Magic Number,FFImageLoading,ColorHolder,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Helpers\ColorHolder.cs,ColorHolder,The following statement contains a magic number: if (a > 0)              {                  R = Convert.ToByte(Math.Min(Math.Max(0' r)' 255));                  G = Convert.ToByte(Math.Min(Math.Max(0' g)' 255));                  B = Convert.ToByte(Math.Min(Math.Max(0' b)' 255));              }              else              {                  R = 0;                  G = 0;                  B = 0;              }
Magic Number,FFImageLoading,ColorHolder,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Helpers\ColorHolder.cs,ColorHolder,The following statement contains a magic number: if (a > 0)              {                  R = Convert.ToByte(Math.Min(Math.Max(0' r)' 255));                  G = Convert.ToByte(Math.Min(Math.Max(0' g)' 255));                  B = Convert.ToByte(Math.Min(Math.Max(0' b)' 255));              }              else              {                  R = 0;                  G = 0;                  B = 0;              }
Magic Number,FFImageLoading,ColorHolder,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Helpers\ColorHolder.cs,ColorHolder,The following statement contains a magic number: if (a > 0)              {                  R = Convert.ToByte(Math.Min(Math.Max(0' r)' 255));                  G = Convert.ToByte(Math.Min(Math.Max(0' g)' 255));                  B = Convert.ToByte(Math.Min(Math.Max(0' b)' 255));              }              else              {                  R = 0;                  G = 0;                  B = 0;              }
Magic Number,FFImageLoading,ColorHolder,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Helpers\ColorHolder.cs,ColorHolder,The following statement contains a magic number: A = 255;
Magic Number,FFImageLoading,ColorHolder,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Helpers\ColorHolder.cs,ColorHolder,The following statement contains a magic number: R = Convert.ToByte(Math.Min(Math.Max(0' r)' 255));
Magic Number,FFImageLoading,ColorHolder,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Helpers\ColorHolder.cs,ColorHolder,The following statement contains a magic number: G = Convert.ToByte(Math.Min(Math.Max(0' g)' 255));
Magic Number,FFImageLoading,ColorHolder,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Helpers\ColorHolder.cs,ColorHolder,The following statement contains a magic number: B = Convert.ToByte(Math.Min(Math.Max(0' b)' 255));
Magic Number,FFImageLoading,FFImage,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\FFImage.cs,GetImageAsPngAsync,The following statement contains a magic number: return GetImageAsByteAsync(BitmapEncoder.PngEncoderId' 90' desiredWidth' desiredHeight);
Magic Number,FFImageLoading,FFImage,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\FFImage.cs,GetImageAsByteAsync,The following statement contains a magic number: if (desiredWidth != 0 || desiredHeight != 0)              {                  double widthRatio = (double)desiredWidth / (double)bitmap.PixelWidth;                  double heightRatio = (double)desiredHeight / (double)bitmap.PixelHeight;                    double scaleRatio = Math.Min(widthRatio' heightRatio);                    if (desiredWidth == 0)                      scaleRatio = heightRatio;                    if (desiredHeight == 0)                      scaleRatio = widthRatio;                    uint aspectWidth = (uint)((double)bitmap.PixelWidth * scaleRatio);                  uint aspectHeight = (uint)((double)bitmap.PixelHeight * scaleRatio);                    using (var tempStream = new InMemoryRandomAccessStream())                  {                      byte[] tempPixels = await GetBytesFromBitmapAsync(bitmap);                        var encoder = await BitmapEncoder.CreateAsync(BitmapEncoder.PngEncoderId' tempStream);                      encoder.SetPixelData(BitmapPixelFormat.Bgra8' BitmapAlphaMode.Premultiplied'                          pixelsWidth' pixelsHeight' 96' 96' tempPixels);                      await encoder.FlushAsync();                      tempStream.Seek(0);                        BitmapDecoder decoder = await BitmapDecoder.CreateAsync(tempStream);                      BitmapTransform transform = new BitmapTransform()                      {                          ScaledWidth = aspectWidth'                          ScaledHeight = aspectHeight'                          InterpolationMode = BitmapInterpolationMode.Linear                      };                      PixelDataProvider pixelData = await decoder.GetPixelDataAsync(                          BitmapPixelFormat.Bgra8'                          BitmapAlphaMode.Premultiplied'                          transform'                          ExifOrientationMode.RespectExifOrientation'                          ColorManagementMode.DoNotColorManage);                        pixels = pixelData.DetachPixelData();                      pixelsWidth = aspectWidth;                      pixelsHeight = aspectHeight;                  }              }              else              {                  pixels = await GetBytesFromBitmapAsync(bitmap);              }
Magic Number,FFImageLoading,FFImage,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\FFImage.cs,GetImageAsByteAsync,The following statement contains a magic number: if (desiredWidth != 0 || desiredHeight != 0)              {                  double widthRatio = (double)desiredWidth / (double)bitmap.PixelWidth;                  double heightRatio = (double)desiredHeight / (double)bitmap.PixelHeight;                    double scaleRatio = Math.Min(widthRatio' heightRatio);                    if (desiredWidth == 0)                      scaleRatio = heightRatio;                    if (desiredHeight == 0)                      scaleRatio = widthRatio;                    uint aspectWidth = (uint)((double)bitmap.PixelWidth * scaleRatio);                  uint aspectHeight = (uint)((double)bitmap.PixelHeight * scaleRatio);                    using (var tempStream = new InMemoryRandomAccessStream())                  {                      byte[] tempPixels = await GetBytesFromBitmapAsync(bitmap);                        var encoder = await BitmapEncoder.CreateAsync(BitmapEncoder.PngEncoderId' tempStream);                      encoder.SetPixelData(BitmapPixelFormat.Bgra8' BitmapAlphaMode.Premultiplied'                          pixelsWidth' pixelsHeight' 96' 96' tempPixels);                      await encoder.FlushAsync();                      tempStream.Seek(0);                        BitmapDecoder decoder = await BitmapDecoder.CreateAsync(tempStream);                      BitmapTransform transform = new BitmapTransform()                      {                          ScaledWidth = aspectWidth'                          ScaledHeight = aspectHeight'                          InterpolationMode = BitmapInterpolationMode.Linear                      };                      PixelDataProvider pixelData = await decoder.GetPixelDataAsync(                          BitmapPixelFormat.Bgra8'                          BitmapAlphaMode.Premultiplied'                          transform'                          ExifOrientationMode.RespectExifOrientation'                          ColorManagementMode.DoNotColorManage);                        pixels = pixelData.DetachPixelData();                      pixelsWidth = aspectWidth;                      pixelsHeight = aspectHeight;                  }              }              else              {                  pixels = await GetBytesFromBitmapAsync(bitmap);              }
Magic Number,FFImageLoading,FFImage,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\FFImage.cs,GetImageAsByteAsync,The following statement contains a magic number: using (var stream = new InMemoryRandomAccessStream())              {                  var encoder = await BitmapEncoder.CreateAsync(format' stream);                    encoder.SetPixelData(BitmapPixelFormat.Bgra8' BitmapAlphaMode.Premultiplied'                      pixelsWidth' pixelsHeight' 96' 96' pixels);                  await encoder.FlushAsync();                  stream.Seek(0);                    var bytes = new byte[stream.Size];                  await stream.ReadAsync(bytes.AsBuffer()' (uint)stream.Size' InputStreamOptions.None);                    return bytes;              }
Magic Number,FFImageLoading,FFImage,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\FFImage.cs,GetImageAsByteAsync,The following statement contains a magic number: using (var stream = new InMemoryRandomAccessStream())              {                  var encoder = await BitmapEncoder.CreateAsync(format' stream);                    encoder.SetPixelData(BitmapPixelFormat.Bgra8' BitmapAlphaMode.Premultiplied'                      pixelsWidth' pixelsHeight' 96' 96' pixels);                  await encoder.FlushAsync();                  stream.Seek(0);                    var bytes = new byte[stream.Size];                  await stream.ReadAsync(bytes.AsBuffer()' (uint)stream.Size' InputStreamOptions.None);                    return bytes;              }
Magic Number,FFImageLoading.Views,ImageSourceBinding,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Views\MvxCachedImageView.cs,GetHashCode,The following statement contains a magic number: unchecked                  {                      int hash = 17;                      hash = hash * 23 + this.ImageSource.GetHashCode();                      hash = hash * 23 + Path.GetHashCode();                      hash = hash * 23 + Stream.GetHashCode();                      return hash;                  }
Magic Number,FFImageLoading.Views,ImageSourceBinding,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Views\MvxCachedImageView.cs,GetHashCode,The following statement contains a magic number: unchecked                  {                      int hash = 17;                      hash = hash * 23 + this.ImageSource.GetHashCode();                      hash = hash * 23 + Path.GetHashCode();                      hash = hash * 23 + Stream.GetHashCode();                      return hash;                  }
Magic Number,FFImageLoading.Views,ImageSourceBinding,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Views\MvxCachedImageView.cs,GetHashCode,The following statement contains a magic number: unchecked                  {                      int hash = 17;                      hash = hash * 23 + this.ImageSource.GetHashCode();                      hash = hash * 23 + Path.GetHashCode();                      hash = hash * 23 + Stream.GetHashCode();                      return hash;                  }
Magic Number,FFImageLoading.Views,ImageSourceBinding,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Views\MvxCachedImageView.cs,GetHashCode,The following statement contains a magic number: unchecked                  {                      int hash = 17;                      hash = hash * 23 + this.ImageSource.GetHashCode();                      hash = hash * 23 + Path.GetHashCode();                      hash = hash * 23 + Stream.GetHashCode();                      return hash;                  }
Magic Number,FFImageLoading.Work,BitmapHolder,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Work\BitmapHolder.cs,SetPixel,The following statement contains a magic number: int bytePos = pos * 4;
Magic Number,FFImageLoading.Work,BitmapHolder,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Work\BitmapHolder.cs,SetPixel,The following statement contains a magic number: PixelData[bytePos + 2] = color.R;
Magic Number,FFImageLoading.Work,BitmapHolder,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Work\BitmapHolder.cs,SetPixel,The following statement contains a magic number: PixelData[bytePos + 3] = color.A;
Magic Number,FFImageLoading.Work,BitmapHolder,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Work\BitmapHolder.cs,GetPixel,The following statement contains a magic number: int bytePos = pos * 4;
Magic Number,FFImageLoading.Work,BitmapHolder,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Work\BitmapHolder.cs,GetPixel,The following statement contains a magic number: var r = PixelData[bytePos + 2];
Magic Number,FFImageLoading.Work,BitmapHolder,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\Work\BitmapHolder.cs,GetPixel,The following statement contains a magic number: var a = PixelData[bytePos + 3];
Missing Default,FFImageLoading,FFImage,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Windows\FFImage.cs,ClearCacheAsync,The following switch statement is missing a default case: switch (cacheType)              {                  case CacheType.Memory:                      ImageService.Instance.InvalidateMemoryCache();                      break;                  case CacheType.Disk:                      await ImageService.Instance.InvalidateDiskCacheAsync().ConfigureAwait(false);                      break;                  case CacheType.All:                      ImageService.Instance.InvalidateMemoryCache();                      await ImageService.Instance.InvalidateDiskCacheAsync().ConfigureAwait(false);                      break;              }
