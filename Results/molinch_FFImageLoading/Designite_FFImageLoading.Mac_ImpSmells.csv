Implementation smell,Namespace,Class,File,Method,Description
Long Method,FFImageLoading.Decoders,GifDecoder,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Decoders\GifDecoder.cs,SourceRegfToDecodedImageAsync,The method has 124 lines of code.
Complex Method,FFImageLoading.Targets,NSImageViewTarget,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Mac\Targets\NSImageViewTarget.cs,Set,Cyclomatic complexity of the method is 8
Complex Method,FFImageLoading.DataResolvers,FileDataResolver,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\DataResolvers\FileDataResolver.cs,Resolve,Cyclomatic complexity of the method is 8
Complex Method,FFImageLoading.Decoders,GifDecoder,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Decoders\GifDecoder.cs,SourceRegfToDecodedImageAsync,Cyclomatic complexity of the method is 13
Complex Method,FFImageLoading.Decoders,GifDecoder,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Decoders\GifDecoder.cs,RCTTargetRect,Cyclomatic complexity of the method is 10
Long Parameter List,FFImageLoading.Extensions,NSDataExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\NSDataExtensions.cs,ToImageAsync,The method has 8 parameters. Parameters: data' destSize' destScale' config' parameters' resizeMode' imageinformation' allowUpscale
Long Parameter List,FFImageLoading.Transformations,TransformationBase,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Transformations\TransformationBase.cs,Transform,The method has 5 parameters. Parameters: bitmapHolder' path' source' isPlaceholder' key
Long Parameter List,FFImageLoading.Transformations,TransformationBase,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Transformations\TransformationBase.cs,Transform,The method has 5 parameters. Parameters: sourceBitmap' path' source' isPlaceholder' key
Long Parameter List,FFImageLoading.Work,PlatformImageLoaderTask<TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Work\PlatformImageLoaderTask.cs,TransformAsync,The method has 5 parameters. Parameters: bitmap' transformations' path' source' isPlaceholder
Long Parameter List,FFImageLoading.Decoders,GifDecoder,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Decoders\GifDecoder.cs,DecodeAsync,The method has 5 parameters. Parameters: stream' path' source' imageInformation' parameters
Long Parameter List,FFImageLoading.Decoders,GifDecoder,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Decoders\GifDecoder.cs,SourceRegfToDecodedImageAsync,The method has 8 parameters. Parameters: nsdata' destSize' destScale' config' parameters' resizeMode' imageinformation' allowUpscale
Long Parameter List,FFImageLoading.Decoders,GifDecoder,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Decoders\GifDecoder.cs,RCTTargetSize,The method has 6 parameters. Parameters: sourceSize' sourceScale' destSize' destScale' resizeMode' allowUpscaling
Long Parameter List,FFImageLoading.Decoders,WebPDecoder,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Decoders\WebPDecoder.cs,DecodeAsync,The method has 5 parameters. Parameters: stream' path' source' imageInformation' parameters
Long Statement,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The length of the statement  "                    throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor)); " is 128.
Long Statement,FFImageLoading,PlatformPerformance,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Helpers\PlatformPerformance.cs,GetMemoryInfo,The length of the statement  "            return string.Format("[PERFORMANCE] Memory - resident_size: {0:0}MB' resident_size_max: {1:0}MB' virtual_size: {2:0}MB"' " is 120.
Long Statement,FFImageLoading.Cache,ImageCache,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Cache\ImageCache.cs,RemoveSimilar,The length of the statement  "            var keysToRemove = _imageInformations.Keys.Where(i => i.StartsWith(pattern' StringComparison.InvariantCultureIgnoreCase)).ToList(); " is 131.
Long Statement,FFImageLoading.Cache,SimpleDiskCache,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared\Cache\SimpleDiskCache.cs,AddToSavingQueueIfNotExistsAsync,The length of the statement  "            await _currentWriteLock.WaitAsync().ConfigureAwait(false); // Make sure we don't add multiple continuations to the same task " is 124.
Long Statement,FFImageLoading.DataResolvers,BundleDataResolver,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\DataResolvers\BundleDataResolver.cs,ResolveFromAssetCatalogAsync,The length of the statement  "                await ImageService.Instance.Config.MainThreadDispatcher.PostAsync(() => asset = new NSDataAsset(identifier' NSBundle.MainBundle)).ConfigureAwait(false); " is 152.
Long Statement,FFImageLoading.DataResolvers,BundleDataResolver,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\DataResolvers\BundleDataResolver.cs,ResolveFromAssetCatalogAsync,The length of the statement  "                    await ImageService.Instance.Config.MainThreadDispatcher.PostAsync(() => asset = new NSDataAsset(fileName' NSBundle.MainBundle)).ConfigureAwait(false); " is 150.
Long Statement,FFImageLoading.DataResolvers,BundleDataResolver,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\DataResolvers\BundleDataResolver.cs,ResolveFromNamedResourceAsync,The length of the statement  "                await ImageService.Instance.Config.MainThreadDispatcher.PostAsync(() => image = PImage.FromBundle(identifier)).ConfigureAwait(false); " is 133.
Long Statement,FFImageLoading.DataResolvers,BundleDataResolver,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\DataResolvers\BundleDataResolver.cs,ResolveFromNamedResourceAsync,The length of the statement  "                await ImageService.Instance.Config.MainThreadDispatcher.PostAsync(() => image = PImage.ImageNamed(identifier)).ConfigureAwait(false); " is 133.
Long Statement,FFImageLoading.DataResolvers,BundleDataResolver,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\DataResolvers\BundleDataResolver.cs,ResolveFromNamedResourceAsync,The length of the statement  "                    await ImageService.Instance.Config.MainThreadDispatcher.PostAsync(() => image = PImage.FromBundle(fileName)).ConfigureAwait(false); " is 131.
Long Statement,FFImageLoading.DataResolvers,BundleDataResolver,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\DataResolvers\BundleDataResolver.cs,ResolveFromNamedResourceAsync,The length of the statement  "					await ImageService.Instance.Config.MainThreadDispatcher.PostAsync(() => image = PImage.ImageNamed(fileName)).ConfigureAwait(false); " is 131.
Long Statement,FFImageLoading.Work,PlatformImageLoaderTask<TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Work\PlatformImageLoaderTask.cs,TransformAsync,The length of the statement  "            await StaticLocks.DecodingLock.WaitAsync(CancellationTokenSource.Token).ConfigureAwait(false); // Applying transformations is both CPU and memory intensive " is 155.
Long Statement,FFImageLoading.Work,PlatformImageLoaderTask<TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Work\PlatformImageLoaderTask.cs,GenerateImageFromDecoderContainerAsync,The length of the statement  "                    using (var destintation = CGImageDestination.Create(mutableData' MobileCoreServices.UTType.GIF' decoded.AnimatedImages.Length' fileOptions)) " is 140.
Long Statement,FFImageLoading.Work,PlatformImageLoaderTask<TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Work\PlatformImageLoaderTask.cs,GenerateImageFromDecoderContainerAsync,The length of the statement  "                            options.GifDictionary[ImageIO.CGImageProperties.GIFUnclampedDelayTime] = new NSString(decoded.AnimatedImages[i].Delay.ToString()); " is 130.
Long Statement,FFImageLoading.Decoders,GifDecoder,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Decoders\GifDecoder.cs,DecodeAsync,The length of the statement  "                var result = await SourceRegfToDecodedImageAsync(nsdata' new CGSize(downsampleWidth' downsampleHeight)' ScaleHelper.Scale' " is 122.
Long Statement,FFImageLoading.Decoders,WebPDecoder,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Decoders\WebPDecoder.cs,DecodeAsync,The length of the statement  "                var interpolationMode = parameters.DownSampleInterpolationMode == InterpolationMode.Default ? Configuration.DownsampleInterpolationMode : parameters.DownSampleInterpolationMode; " is 177.
Complex Conditional,FFImageLoading.Work,PlatformImageLoaderTask<TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Work\PlatformImageLoaderTask.cs,TransformAsync,The conditional expression  "old != null && old.Handle != IntPtr.Zero && old != bitmap && old.Handle != bitmap.Handle"  is complex.
Empty Catch Block,FFImageLoading,ImageService,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Mac\ImageService.cs,SetTaskForTarget,The method has an empty catch block.
Empty Catch Block,FFImageLoading,ImageService,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Mac\ImageService.cs,CancelWorkForView,The method has an empty catch block.
Empty Catch Block,FFImageLoading.Cache,SimpleDiskCache,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared\Cache\SimpleDiskCache.cs,ClearAsync,The method has an empty catch block.
Empty Catch Block,FFImageLoading.Cache,SimpleDiskCache,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared\Cache\SimpleDiskCache.cs,CleanCallback,The method has an empty catch block.
Empty Catch Block,FFImageLoading.DataResolvers,BundleDataResolver,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\DataResolvers\BundleDataResolver.cs,ResolveFromAssetCatalogAsync,The method has an empty catch block.
Empty Catch Block,FFImageLoading.DataResolvers,BundleDataResolver,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\DataResolvers\BundleDataResolver.cs,ResolveFromAssetCatalogAsync,The method has an empty catch block.
Empty Catch Block,FFImageLoading.DataResolvers,BundleDataResolver,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\DataResolvers\BundleDataResolver.cs,ResolveFromNamedResourceAsync,The method has an empty catch block.
Empty Catch Block,FFImageLoading.DataResolvers,BundleDataResolver,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\DataResolvers\BundleDataResolver.cs,ResolveFromNamedResourceAsync,The method has an empty catch block.
Magic Number,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);    #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  default:                      throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor));              }
Magic Number,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);    #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  default:                      throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor));              }
Magic Number,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);    #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  default:                      throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor));              }
Magic Number,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);    #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  default:                      throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor));              }
Magic Number,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);    #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  default:                      throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor));              }
Magic Number,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);    #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  default:                      throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor));              }
Magic Number,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);    #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  default:                      throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor));              }
Magic Number,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);    #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  default:                      throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor));              }
Magic Number,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);    #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  default:                      throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor));              }
Magic Number,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);    #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  default:                      throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor));              }
Magic Number,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);    #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  default:                      throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor));              }
Magic Number,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);    #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  default:                      throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor));              }
Magic Number,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);    #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  default:                      throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor));              }
Magic Number,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);    #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  default:                      throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor));              }
Magic Number,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);    #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  default:                      throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor));              }
Magic Number,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);    #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  default:                      throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor));              }
Magic Number,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);    #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  default:                      throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor));              }
Magic Number,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);    #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  default:                      throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor));              }
Magic Number,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);    #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  default:                      throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor));              }
Magic Number,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);    #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  default:                      throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor));              }
Magic Number,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);    #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  default:                      throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor));              }
Magic Number,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);    #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  default:                      throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor));              }
Magic Number,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);    #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  default:                      throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor));              }
Magic Number,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);    #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  default:                      throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor));              }
Magic Number,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);    #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  default:                      throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor));              }
Magic Number,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);    #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  default:                      throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor));              }
Magic Number,FFImageLoading,ColorExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Extensions\ColorExtensions.cs,ToUIColor,The following statement contains a magic number: switch (hexColor.Length)              {                  case 9:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 24);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 7:                      {                          var cuint = Convert.ToUInt32(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 16) & 0xff);                          var g = (byte)((cuint >> 8) & 0xff);                          var b = (byte)(cuint & 0xff);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  case 5:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var a = (byte)(cuint >> 12);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          a = (byte)(a << 4 | a);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);  #if __MACOS__                          color = PColor.FromRgba(r' g' b' a);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' a);  #endif                          break;                      }                  case 4:                      {                          var cuint = Convert.ToUInt16(hexColor.Substring(1)' 16);                          var r = (byte)((cuint >> 8) & 0xf);                          var g = (byte)((cuint >> 4) & 0xf);                          var b = (byte)(cuint & 0xf);                          r = (byte)(r << 4 | r);                          g = (byte)(g << 4 | g);                          b = (byte)(b << 4 | b);    #if __MACOS__                          color = PColor.FromRgba(r' g' b' (byte)255);  #elif __IOS__                          color = PColor.FromRGBA(r' g' b' (byte)255);  #endif                          break;                      }                  default:                      throw new FormatException(string.Format("The {0} string passed in the c argument is not a recognized Color format."' hexColor));              }
Magic Number,FFImageLoading,PlatformPerformance,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Helpers\PlatformPerformance.cs,GetMemoryInfo,The following statement contains a magic number: virtualSize = (double)memoryInfo.Value.virtual_size / 1048576d;
Magic Number,FFImageLoading,PlatformPerformance,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Helpers\PlatformPerformance.cs,GetMemoryInfo,The following statement contains a magic number: residentSize = (double)memoryInfo.Value.resident_size / 1048576d;
Magic Number,FFImageLoading,PlatformPerformance,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Helpers\PlatformPerformance.cs,GetMemoryInfo,The following statement contains a magic number: residentSizeMax = (double)memoryInfo.Value.resident_size_max / 1048576d;
Magic Number,FFImageLoading.Cache,ImageCache,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Cache\ImageCache.cs,ImageCache,The following statement contains a magic number: _cache.TotalCostLimit = (nuint)(NSProcessInfo.ProcessInfo.PhysicalMemory * 0.2d);
Magic Number,FFImageLoading.Cache,ImageCache,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Cache\ImageCache.cs,ImageCache,The following statement contains a magic number: var sizeInMB = Math.Round(_cache.TotalCostLimit / 1024d / 1024d' 2);
Magic Number,FFImageLoading.Cache,ImageCache,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Cache\ImageCache.cs,ImageCache,The following statement contains a magic number: var sizeInMB = Math.Round(_cache.TotalCostLimit / 1024d / 1024d' 2);
Magic Number,FFImageLoading.Cache,ImageCache,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Cache\ImageCache.cs,ImageCache,The following statement contains a magic number: var sizeInMB = Math.Round(_cache.TotalCostLimit / 1024d / 1024d' 2);
Magic Number,FFImageLoading.Cache,SimpleDiskCache,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared\Cache\SimpleDiskCache.cs,ClearAsync,The following statement contains a magic number: await Task.Delay(20).ConfigureAwait(false);
Magic Number,FFImageLoading.Cache,SimpleDiskCache,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared\Cache\SimpleDiskCache.cs,WaitForPendingWriteIfExists,The following statement contains a magic number: await Task.Delay(20).ConfigureAwait(false);
Magic Number,FFImageLoading.Decoders,GifDecoder,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Decoders\GifDecoder.cs,GetDelays,The following statement contains a magic number: delayMs = (int)(delayAsDouble * 1000);
Magic Number,FFImageLoading.Decoders,GifDecoder,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Decoders\GifDecoder.cs,RCTTargetRect,The following statement contains a magic number: switch (resizeMode)              {                  case RCTResizeMode.ScaleToFill:                      return new CGRect(CGPoint.Empty' RCTCeilSize(destSize' destScale));                    case RCTResizeMode.ScaleAspectFit:                      if (targetAspect <= aspect) // target is taller than content                      {                          sourceSize.Width = destSize.Width = destSize.Width;                          sourceSize.Height = sourceSize.Width / aspect;                        }                      else // target is wider than content                      {                          sourceSize.Height = destSize.Height = destSize.Height;                          sourceSize.Width = sourceSize.Height * aspect;                      }                        return new CGRect(                          new CGPoint(                              RCTFloorValue((destSize.Width - sourceSize.Width) / 2' destScale)'                              RCTFloorValue((destSize.Height - sourceSize.Height) / 2' destScale)                          )'                          RCTCeilSize(sourceSize' destScale)                      );                    default:                      if (targetAspect <= aspect)                      { // target is taller than content                            sourceSize.Height = destSize.Height = destSize.Height;                          sourceSize.Width = sourceSize.Height * aspect;                          destSize.Width = destSize.Height * targetAspect;                          return new CGRect(                              new CGPoint(                                  RCTFloorValue((destSize.Width - sourceSize.Width) / 2' destScale)'                                  0                              )'                              RCTCeilSize(sourceSize' destScale)                          );                      }                      else // target is wider than content                      {                          sourceSize.Width = destSize.Width = destSize.Width;                          sourceSize.Height = sourceSize.Width / aspect;                          destSize.Height = destSize.Width / targetAspect;                          return new CGRect(                              new CGPoint(                                  0'                                  RCTFloorValue((destSize.Height - sourceSize.Height) / 2' destScale)                              )'                              RCTCeilSize(sourceSize' destScale)                          );                      }              }
Magic Number,FFImageLoading.Decoders,GifDecoder,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Decoders\GifDecoder.cs,RCTTargetRect,The following statement contains a magic number: switch (resizeMode)              {                  case RCTResizeMode.ScaleToFill:                      return new CGRect(CGPoint.Empty' RCTCeilSize(destSize' destScale));                    case RCTResizeMode.ScaleAspectFit:                      if (targetAspect <= aspect) // target is taller than content                      {                          sourceSize.Width = destSize.Width = destSize.Width;                          sourceSize.Height = sourceSize.Width / aspect;                        }                      else // target is wider than content                      {                          sourceSize.Height = destSize.Height = destSize.Height;                          sourceSize.Width = sourceSize.Height * aspect;                      }                        return new CGRect(                          new CGPoint(                              RCTFloorValue((destSize.Width - sourceSize.Width) / 2' destScale)'                              RCTFloorValue((destSize.Height - sourceSize.Height) / 2' destScale)                          )'                          RCTCeilSize(sourceSize' destScale)                      );                    default:                      if (targetAspect <= aspect)                      { // target is taller than content                            sourceSize.Height = destSize.Height = destSize.Height;                          sourceSize.Width = sourceSize.Height * aspect;                          destSize.Width = destSize.Height * targetAspect;                          return new CGRect(                              new CGPoint(                                  RCTFloorValue((destSize.Width - sourceSize.Width) / 2' destScale)'                                  0                              )'                              RCTCeilSize(sourceSize' destScale)                          );                      }                      else // target is wider than content                      {                          sourceSize.Width = destSize.Width = destSize.Width;                          sourceSize.Height = sourceSize.Width / aspect;                          destSize.Height = destSize.Width / targetAspect;                          return new CGRect(                              new CGPoint(                                  0'                                  RCTFloorValue((destSize.Height - sourceSize.Height) / 2' destScale)                              )'                              RCTCeilSize(sourceSize' destScale)                          );                      }              }
Magic Number,FFImageLoading.Decoders,GifDecoder,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Decoders\GifDecoder.cs,RCTTargetRect,The following statement contains a magic number: switch (resizeMode)              {                  case RCTResizeMode.ScaleToFill:                      return new CGRect(CGPoint.Empty' RCTCeilSize(destSize' destScale));                    case RCTResizeMode.ScaleAspectFit:                      if (targetAspect <= aspect) // target is taller than content                      {                          sourceSize.Width = destSize.Width = destSize.Width;                          sourceSize.Height = sourceSize.Width / aspect;                        }                      else // target is wider than content                      {                          sourceSize.Height = destSize.Height = destSize.Height;                          sourceSize.Width = sourceSize.Height * aspect;                      }                        return new CGRect(                          new CGPoint(                              RCTFloorValue((destSize.Width - sourceSize.Width) / 2' destScale)'                              RCTFloorValue((destSize.Height - sourceSize.Height) / 2' destScale)                          )'                          RCTCeilSize(sourceSize' destScale)                      );                    default:                      if (targetAspect <= aspect)                      { // target is taller than content                            sourceSize.Height = destSize.Height = destSize.Height;                          sourceSize.Width = sourceSize.Height * aspect;                          destSize.Width = destSize.Height * targetAspect;                          return new CGRect(                              new CGPoint(                                  RCTFloorValue((destSize.Width - sourceSize.Width) / 2' destScale)'                                  0                              )'                              RCTCeilSize(sourceSize' destScale)                          );                      }                      else // target is wider than content                      {                          sourceSize.Width = destSize.Width = destSize.Width;                          sourceSize.Height = sourceSize.Width / aspect;                          destSize.Height = destSize.Width / targetAspect;                          return new CGRect(                              new CGPoint(                                  0'                                  RCTFloorValue((destSize.Height - sourceSize.Height) / 2' destScale)                              )'                              RCTCeilSize(sourceSize' destScale)                          );                      }              }
Magic Number,FFImageLoading.Decoders,GifDecoder,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Shared.IosMac\Decoders\GifDecoder.cs,RCTTargetRect,The following statement contains a magic number: switch (resizeMode)              {                  case RCTResizeMode.ScaleToFill:                      return new CGRect(CGPoint.Empty' RCTCeilSize(destSize' destScale));                    case RCTResizeMode.ScaleAspectFit:                      if (targetAspect <= aspect) // target is taller than content                      {                          sourceSize.Width = destSize.Width = destSize.Width;                          sourceSize.Height = sourceSize.Width / aspect;                        }                      else // target is wider than content                      {                          sourceSize.Height = destSize.Height = destSize.Height;                          sourceSize.Width = sourceSize.Height * aspect;                      }                        return new CGRect(                          new CGPoint(                              RCTFloorValue((destSize.Width - sourceSize.Width) / 2' destScale)'                              RCTFloorValue((destSize.Height - sourceSize.Height) / 2' destScale)                          )'                          RCTCeilSize(sourceSize' destScale)                      );                    default:                      if (targetAspect <= aspect)                      { // target is taller than content                            sourceSize.Height = destSize.Height = destSize.Height;                          sourceSize.Width = sourceSize.Height * aspect;                          destSize.Width = destSize.Height * targetAspect;                          return new CGRect(                              new CGPoint(                                  RCTFloorValue((destSize.Width - sourceSize.Width) / 2' destScale)'                                  0                              )'                              RCTCeilSize(sourceSize' destScale)                          );                      }                      else // target is wider than content                      {                          sourceSize.Width = destSize.Width = destSize.Width;                          sourceSize.Height = sourceSize.Width / aspect;                          destSize.Height = destSize.Width / targetAspect;                          return new CGRect(                              new CGPoint(                                  0'                                  RCTFloorValue((destSize.Height - sourceSize.Height) / 2' destScale)                              )'                              RCTCeilSize(sourceSize' destScale)                          );                      }              }
