Implementation smell,Namespace,Class,File,Method,Description
Long Method,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,RunAsync,The method has 133 lines of code.
Long Method,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,SetPixelsAsync,The method has 156 lines of code.
Long Method,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,DecodeBitmapDataAsync,The method has 121 lines of code.
Long Method,FFImageLoading.Concurrency,GenericPriorityQueue<TItem;TPriority>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Concurrency\FastPriorityQueue\GenericPriorityQueue.cs,CascadeDown,The method has 129 lines of code.
Complex Method,FFImageLoading.Helpers,FileHeader,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\FileHeader.cs,GetImageType,Cyclomatic complexity of the method is 9
Complex Method,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,SetKeys,Cyclomatic complexity of the method is 19
Complex Method,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,ShowPlaceholder,Cyclomatic complexity of the method is 9
Complex Method,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,SetPixelsAsync,Cyclomatic complexity of the method is 19
Complex Method,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,DecodeBitmapDataAsync,Cyclomatic complexity of the method is 19
Complex Method,FFImageLoading.Concurrency,GenericPriorityQueue<TItem;TPriority>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Concurrency\FastPriorityQueue\GenericPriorityQueue.cs,CascadeDown,Cyclomatic complexity of the method is 10
Long Parameter List,FFImageLoading.Work,ITransformation,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ITransformation.cs,Transform,The method has 5 parameters. Parameters: sourceBitmap' path' source' isPlaceholder' key
Long Parameter List,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,TransformAsync,The method has 5 parameters. Parameters: bitmap' transformations' path' source' isPlaceholder
Long Parameter List,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,GenerateImageAsync,The method has 6 parameters. Parameters: path' source' imageData' imageInformation' enableTransformations' isPlaceholder
Long Parameter List,FFImageLoading.Cache,DownloadCache,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Cache\DownloadCache.cs,DownloadAsync,The method has 5 parameters. Parameters: url' token' client' progressAction' parameters
Long Parameter List,FFImageLoading,DownloadInformation,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\DownloadInformation.cs,DownloadInformation,The method has 5 parameters. Parameters: url' customCacheKey' fileName' allowDiskCaching' cacheValidity
Long Parameter List,FFImageLoading.Decoders,IDecoder,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Decoders\IDecoder.cs,DecodeAsync,The method has 5 parameters. Parameters: stream' path' source' imageInformation' parameters
Long Identifier,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,TryLoadFromMemoryCacheAsync,The length of the parameter isFadeAnimationEnabledForCached is 31.
Long Statement,FFImageLoading.Work,WorkScheduler,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\WorkScheduler.cs,TakeFromPendingTasksAndRun,The length of the statement  "            }' CancellationToken.None' TaskCreationOptions.DenyChildAttach | TaskCreationOptions.HideScheduler' TaskScheduler.Default).ConfigureAwait(false); " is 145.
Long Statement,FFImageLoading.Work,WorkScheduler,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\WorkScheduler.cs,TakeFromPendingTasksAndRunAsync,The length of the statement  "                    urlTasksCount = RunningTasks.Count(v => v.Value != null && (!v.Value.Parameters.Preload && v.Value.Parameters.Source == ImageSource.Url)); " is 138.
Long Statement,FFImageLoading.Work,WorkScheduler,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\WorkScheduler.cs,RunImageLoadingTaskAsync,The length of the statement  "                    Logger.Debug(string.Format("[PERFORMANCE] RunAsync - NetManagedThreadId: {0}' NativeThreadId: {1}' Execution: {2} ms' Key: {3}"' " is 128.
Long Statement,FFImageLoading.Work,WorkScheduler,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\WorkScheduler.cs,LogSchedulerStats,The length of the statement  "            Logger.Debug(string.Format("[PERFORMANCE] Scheduler - Max: {0}' Pending: {1}' Running: {2}' TotalPending: {3}' TotalRunning: {4}' TotalMemoryCacheHit: {5}' TotalWaiting: {6}"' " is 175.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,Init,The length of the statement  "            if (Parameters.Source == ImageSource.Stream && Configuration.StreamChecksumsAsKeys && string.IsNullOrWhiteSpace(Parameters.CustomCacheKey)) " is 139.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,SetKeys,The length of the statement  "                    KeyRaw = string.Format("{0};(size={1}x{2}'dip={3}'replace=({4}))"' KeyRaw' vect.VectorWidth' vect.VectorHeight' vect.UseDipUnits' " is 129.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,SetKeys,The length of the statement  "                    KeyDownsamplingOnly = string.Concat(";"' DpiToPixels(Parameters.DownSampleSize.Item1)' "x"' DpiToPixels(Parameters.DownSampleSize.Item2)); " is 138.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,SetKeys,The length of the statement  "                    KeyForLoadingPlaceholder = string.Concat(Parameters.LoadingPlaceholderPath' KeyDownsamplingOnly' KeyTransformationsOnly); " is 121.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,SetKeys,The length of the statement  "                        KeyForLoadingPlaceholder = string.Format("{0};(size={1}x{2}'dip={3})"' KeyForLoadingPlaceholder' vectLo.VectorWidth' vectLo.VectorHeight' vectLo.UseDipUnits); " is 158.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,SetKeys,The length of the statement  "                        KeyForLoadingPlaceholder = string.Format("{0};(size={1}x{2}'dip={3}'replace=({4}))"' KeyForLoadingPlaceholder' vectLo.VectorWidth' vectLo.VectorHeight' vectLo.UseDipUnits' " is 171.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,SetKeys,The length of the statement  "                        KeyForErrorPlaceholder = string.Format("{0};(size={1}x{2}'dip={3})"' KeyForErrorPlaceholder' vectEr.VectorWidth' vectEr.VectorHeight' vectEr.UseDipUnits); " is 154.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,SetKeys,The length of the statement  "                        KeyForErrorPlaceholder = string.Format("{0};(size={1}x{2}'dip={3}'replace=({4}))"' KeyForErrorPlaceholder' vectEr.VectorWidth' vectEr.VectorHeight' vectEr.UseDipUnits' " is 167.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,GenerateImageAsync,The length of the statement  "                            decoderContainer.AnimatedImages[i].Image = await TransformAsync(decoderContainer.AnimatedImages[i].Image' transformations' path' source' isPlaceholder); " is 152.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,TryLoadFromMemoryCacheAsync,The length of the statement  "                bool isFadeAnimationEnabledForCached = Parameters.FadeAnimationForCachedImagesEnabled.HasValue ? Parameters.FadeAnimationForCachedImagesEnabled.Value : Configuration.FadeAnimationForCachedImages; " is 195.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,TryLoadFromMemoryCacheAsync,The length of the statement  "                var result = await TryLoadFromMemoryCacheAsync(Key' true' isFadeAnimationEnabledForCached' false).ConfigureAwait(false); " is 120.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,ShowPlaceholder,The length of the statement  "                    var customResolver = isLoadingPlaceholder ? Parameters.CustomLoadingPlaceholderDataResolver : Parameters.CustomErrorPlaceholderDataResolver; " is 140.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,ShowPlaceholder,The length of the statement  "                    if (!await _placeholdersResolveLock.WaitAsync(TimeSpan.FromSeconds(10)' CancellationTokenSource.Token).ConfigureAwait(false)) " is 125.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,ShowPlaceholder,The length of the statement  "                            loadImage = await GenerateImageAsync(path' source' loadImageData.Item1' loadImageData.Item3' TransformPlaceholders' true).ConfigureAwait(false); " is 144.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,RunAsync,The length of the statement  "                    var resolver = Parameters.CustomDataResolver ?? DataResolverFactory.GetResolver(Parameters.Path' Parameters.Source' Parameters' Configuration); " is 143.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,RunAsync,The length of the statement  "                    var imageData = await resolver.Resolve(Parameters.Path' Parameters' CancellationTokenSource.Token).ConfigureAwait(false); " is 121.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,RunAsync,The length of the statement  "                        var image = await GenerateImageAsync(Parameters.Path' Parameters.Source' imageData.Item1' imageData.Item3' true' false).ConfigureAwait(false); " is 142.
Long Statement,FFImageLoading.Cache,DownloadCache,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Cache\DownloadCache.cs,DownloadAndCacheIfNeededAsync,The length of the statement  "                async () => await DownloadAsync(url' token' configuration.HttpClient' parameters.OnDownloadProgress' parameters).ConfigureAwait(false)' " is 135.
Long Statement,FFImageLoading.Cache,DownloadCache,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Cache\DownloadCache.cs,DownloadAndCacheIfNeededAsync,The length of the statement  "                await configuration.DiskCache.AddToSavingQueueIfNotExistsAsync(filename' responseBytes' duration' finishedAction).ConfigureAwait(false); " is 136.
Long Statement,FFImageLoading.Cache,DownloadCache,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Cache\DownloadCache.cs,DownloadAsync,The length of the statement  "                        using (var response = await client.GetAsync(url' HttpCompletionOption.ResponseHeadersRead' linkedHeadersToken.Token).ConfigureAwait(false)) " is 139.
Long Statement,FFImageLoading,StringExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Extensions\StringExtensions.cs,IsSvgFileUrl,The length of the statement  "                && str.Split(new[] { '?' }' StringSplitOptions.RemoveEmptyEntries)[0].EndsWith("svg"' StringComparison.OrdinalIgnoreCase); " is 122.
Long Statement,FFImageLoading,ImageServiceBase<TImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\ImageServiceBase.cs,Initialize,The length of the statement  "                    configuration.SchedulerMaxParallelTasksFactory = configuration.SchedulerMaxParallelTasksFactory ?? _config.SchedulerMaxParallelTasksFactory; " is 140.
Long Statement,FFImageLoading,ImageServiceBase<TImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\ImageServiceBase.cs,InitializeIfNeeded,The length of the statement  "                var httpClient = userDefinedConfig.HttpClient ?? new HttpClient(new HttpClientHandler() { AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate }); " is 175.
Long Statement,FFImageLoading,ImageServiceBase<TImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\ImageServiceBase.cs,InitializeIfNeeded,The length of the statement  "                userDefinedConfig.Logger = new MiniLoggerWrapper(userDefinedConfig.Logger ?? CreatePlatformLoggerInstance(userDefinedConfig)' userDefinedConfig.VerboseLogging); " is 160.
Long Statement,FFImageLoading,ImageServiceBase<TImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\ImageServiceBase.cs,InitializeIfNeeded,The length of the statement  "                userDefinedConfig.Scheduler = userDefinedConfig.Scheduler ?? new WorkScheduler(userDefinedConfig' (userDefinedConfig.VerbosePerformanceLogging ? CreatePlatformPerformanceInstance(userDefinedConfig) : new EmptyPlatformPerformance())); " is 233.
Long Statement,FFImageLoading,ImageServiceBase<TImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\ImageServiceBase.cs,InitializeIfNeeded,The length of the statement  "                userDefinedConfig.MainThreadDispatcher = userDefinedConfig.MainThreadDispatcher ?? CreateMainThreadDispatcherInstance(userDefinedConfig); " is 137.
Long Statement,FFImageLoading,ImageServiceBase<TImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\ImageServiceBase.cs,InitializeIfNeeded,The length of the statement  "                userDefinedConfig.DataResolverFactory = userDefinedConfig.DataResolverFactory ?? CreateDataResolverFactoryInstance(userDefinedConfig); " is 134.
Long Statement,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,DecodeBitmapDataAsync,The length of the statement  "            int available' clear' code_mask' code_size' end_of_information' in_code' old_code' bits' code' count' i' datum' data_size' first' top' bi' pi; " is 142.
Long Statement,FFImageLoading.Concurrency,GenericPriorityQueue<TItem;TPriority>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Concurrency\FastPriorityQueue\GenericPriorityQueue.cs,Contains,The length of the statement  "                throw new InvalidOperationException("node.QueueIndex has been corrupted. Did you change it manually? Or add this node to another queue?"); " is 138.
Long Statement,FFImageLoading.Concurrency,GenericPriorityQueue<TItem;TPriority>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Concurrency\FastPriorityQueue\GenericPriorityQueue.cs,Dequeue,The length of the statement  "                throw new InvalidOperationException("Queue has been corrupted (Did you update a node priority manually instead of calling UpdatePriority()?" + " is 142.
Long Statement,FFImageLoading.Concurrency,GenericPriorityQueue<TItem;TPriority>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Concurrency\FastPriorityQueue\GenericPriorityQueue.cs,Resize,The length of the statement  "                throw new InvalidOperationException("Called Resize(" + maxNodes + ")' but current queue contains " + _numNodes + " nodes"); " is 123.
Long Statement,FFImageLoading.Concurrency,GenericPriorityQueue<TItem;TPriority>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Concurrency\FastPriorityQueue\GenericPriorityQueue.cs,IsValidQueue,The length of the statement  "                    if (childLeftIndex < _nodes.Length && _nodes[childLeftIndex] != null && HasHigherPriority(_nodes[childLeftIndex]' _nodes[i])) " is 125.
Long Statement,FFImageLoading.Concurrency,GenericPriorityQueue<TItem;TPriority>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Concurrency\FastPriorityQueue\GenericPriorityQueue.cs,IsValidQueue,The length of the statement  "                    if (childRightIndex < _nodes.Length && _nodes[childRightIndex] != null && HasHigherPriority(_nodes[childRightIndex]' _nodes[i])) " is 128.
Long Statement,FFImageLoading.DataResolvers,UrlDataResolver,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\DataResolvers\UrlDataResolver.cs,Resolve,The length of the statement  "            var downloadedData = await DownloadCache.DownloadAndCacheIfNeededAsync(identifier' parameters' Configuration' token).ConfigureAwait(false); " is 139.
Long Statement,FFImageLoading.DataResolvers,UrlDataResolver,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\DataResolvers\UrlDataResolver.cs,Resolve,The length of the statement  "                downloadedData?.ImageStream' downloadedData.RetrievedFromDiskCache ? LoadingResult.DiskCache : LoadingResult.Internet' imageInformation); " is 137.
Complex Conditional,FFImageLoading,GifHelper,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelper.cs,CheckIfAnimated,The conditional expression  "sequenceStartCand && readByte == 0x21 && st.ReadByte() == 0xF9 && st.ReadByte() == 0x04                          && st.ReadByte() != -1 && st.ReadByte() != -1 && st.ReadByte() != -1 && st.ReadByte() != -1                          && st.ReadByte() == 0x00"  is complex.
Empty Catch Block,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,ThrowIfCancellationRequested,The method has an empty catch block.
Empty Catch Block,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,Cancel,The method has an empty catch block.
Empty Catch Block,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,RunAsync,The method has an empty catch block.
Empty Catch Block,FFImageLoading,ObjectExtensions,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Extensions\ObjectExtensions.cs,TryDispose,The method has an empty catch block.
Empty Catch Block,FFImageLoading,ImageServiceBase<TImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\ImageServiceBase.cs,InitializeIfNeeded,The method has an empty catch block.
Magic Number,FFImageLoading.Helpers,Delay,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Delay.cs,DelayAsync,The following statement contains a magic number: if (miliseconds >= 60)                  return Task.Delay(miliseconds);
Magic Number,FFImageLoading.Work,WorkScheduler,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\WorkScheduler.cs,LoadImage,The following statement contains a magic number: try              {                  Interlocked.Increment(ref _loadCount);                    if (task == null)                      return;                    if (task.IsCancelled || task.IsCompleted || ExitTasksEarly)                  {                      if (!task.IsCompleted)                          task.TryDispose();                      return;                  }                    if (Configuration.VerbosePerformanceLogging && (_loadCount % 10) == 0)                  {                      LogSchedulerStats();                  }                    if (task?.Parameters?.Source != ImageSource.Stream && string.IsNullOrWhiteSpace(task?.Parameters?.Path))                  {                      Logger.Error("ImageService: null path ignored");                      task.TryDispose();                      return;                  }                    await task.Init();                    // If we have the image in memory then it's pointless to schedule the job: just display it straight away                  if (task.CanUseMemoryCache && await task.TryLoadFromMemoryCacheAsync().ConfigureAwait(false))                  {                      Interlocked.Increment(ref _statsTotalMemoryCacheHits);                      task.TryDispose();                      return;                  }                    QueueImageLoadingTask(task);              }              catch (Exception ex)              {                  Logger.Error(string.Format("Image loaded failed: {0}"' task?.Key)' ex);              }
Magic Number,FFImageLoading.Work,WorkScheduler,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\WorkScheduler.cs,TakeFromPendingTasksAndRunAsync,The following statement contains a magic number: lock (_lock)              {                  if (RunningTasks.Count >= MaxParallelTasks)                  {                      urlTasksCount = RunningTasks.Count(v => v.Value != null && (!v.Value.Parameters.Preload && v.Value.Parameters.Source == ImageSource.Url));                      preloadTasksCount = RunningTasks.Count(v => v.Value != null && v.Value.Parameters.Preload);                      preloadOrUrlTasksCount = preloadTasksCount + urlTasksCount;                        if (preloadOrUrlTasksCount == 0 || preloadOrUrlTasksCount != MaxParallelTasks)                          return;                        // Allow only half of MaxParallelTasks as additional allowed tasks when preloading occurs to prevent starvation                      if (RunningTasks.Count - Math.Max(1' Math.Min(preloadOrUrlTasksCount' MaxParallelTasks / 2)) >= MaxParallelTasks)                          return;                  }                    int numberOfTasks = MaxParallelTasks - RunningTasks.Count + Math.Min(preloadOrUrlTasksCount' MaxParallelTasks / 2);                  tasksToRun = new Dictionary<string' IImageLoaderTask>();                  IImageLoaderTask task = null;                    while (tasksToRun.Count < numberOfTasks && PendingTasks.TryDequeue(out task))                  {                      if (task == null || task.IsCancelled || task.IsCompleted)                          continue;                        // We don't want to load' at the same time' images that have same key or same raw key at the same time                      // This way we prevent concurrent downloads and benefit from caches                      string rawKey = task.KeyRaw;                      if (RunningTasks.ContainsKey(rawKey) || tasksToRun.ContainsKey(rawKey))                      {                          SimilarTasks.Add(task);                          continue;                      }                        if (preloadOrUrlTasksCount != 0)                      {                          if (!task.Parameters.Preload && (urlTasksCount == 0 || task.Parameters.Source != ImageSource.Url))                              tasksToRun.Add(rawKey' task);                          else                          {                              Enqueue(task);                              break;                          }                      }                      else                      {                          tasksToRun.Add(rawKey' task);                      }                  }                    foreach (var item in tasksToRun)                  {                      RunningTasks.Add(item.Key' item.Value);                      Interlocked.Increment(ref _statsTotalRunning);                  }              }
Magic Number,FFImageLoading.Work,WorkScheduler,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\WorkScheduler.cs,TakeFromPendingTasksAndRunAsync,The following statement contains a magic number: lock (_lock)              {                  if (RunningTasks.Count >= MaxParallelTasks)                  {                      urlTasksCount = RunningTasks.Count(v => v.Value != null && (!v.Value.Parameters.Preload && v.Value.Parameters.Source == ImageSource.Url));                      preloadTasksCount = RunningTasks.Count(v => v.Value != null && v.Value.Parameters.Preload);                      preloadOrUrlTasksCount = preloadTasksCount + urlTasksCount;                        if (preloadOrUrlTasksCount == 0 || preloadOrUrlTasksCount != MaxParallelTasks)                          return;                        // Allow only half of MaxParallelTasks as additional allowed tasks when preloading occurs to prevent starvation                      if (RunningTasks.Count - Math.Max(1' Math.Min(preloadOrUrlTasksCount' MaxParallelTasks / 2)) >= MaxParallelTasks)                          return;                  }                    int numberOfTasks = MaxParallelTasks - RunningTasks.Count + Math.Min(preloadOrUrlTasksCount' MaxParallelTasks / 2);                  tasksToRun = new Dictionary<string' IImageLoaderTask>();                  IImageLoaderTask task = null;                    while (tasksToRun.Count < numberOfTasks && PendingTasks.TryDequeue(out task))                  {                      if (task == null || task.IsCancelled || task.IsCompleted)                          continue;                        // We don't want to load' at the same time' images that have same key or same raw key at the same time                      // This way we prevent concurrent downloads and benefit from caches                      string rawKey = task.KeyRaw;                      if (RunningTasks.ContainsKey(rawKey) || tasksToRun.ContainsKey(rawKey))                      {                          SimilarTasks.Add(task);                          continue;                      }                        if (preloadOrUrlTasksCount != 0)                      {                          if (!task.Parameters.Preload && (urlTasksCount == 0 || task.Parameters.Source != ImageSource.Url))                              tasksToRun.Add(rawKey' task);                          else                          {                              Enqueue(task);                              break;                          }                      }                      else                      {                          tasksToRun.Add(rawKey' task);                      }                  }                    foreach (var item in tasksToRun)                  {                      RunningTasks.Add(item.Key' item.Value);                      Interlocked.Increment(ref _statsTotalRunning);                  }              }
Magic Number,FFImageLoading.Work,WorkScheduler,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\WorkScheduler.cs,GetDefaultPriority,The following statement contains a magic number: if (source == ImageSource.ApplicationBundle || source == ImageSource.CompiledResource)                  return (int)LoadingPriority.Normal + 2;
Magic Number,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,ShowPlaceholder,The following statement contains a magic number: if (!await TryLoadFromMemoryCacheAsync(key' false' false' isLoadingPlaceholder).ConfigureAwait(false))              {                  try                  {                      var customResolver = isLoadingPlaceholder ? Parameters.CustomLoadingPlaceholderDataResolver : Parameters.CustomErrorPlaceholderDataResolver;                      var loadResolver = customResolver ?? DataResolverFactory.GetResolver(path' source' Parameters' Configuration);                      loadResolver = new WrappedDataResolver(loadResolver);                      Tuple<Stream' LoadingResult' ImageInformation> loadImageData;                      TImageContainer loadImage;                        if (!await _placeholdersResolveLock.WaitAsync(TimeSpan.FromSeconds(10)' CancellationTokenSource.Token).ConfigureAwait(false))                          return;                        try                      {                                                  ThrowIfCancellationRequested();                            if (await TryLoadFromMemoryCacheAsync(key' false' false' isLoadingPlaceholder).ConfigureAwait(false))                          {                              if (isLoadingPlaceholder)                                  _isLoadingPlaceholderLoaded = true;                                                            return;                          }                            ThrowIfCancellationRequested();                          loadImageData = await loadResolver.Resolve(path' Parameters' CancellationTokenSource.Token).ConfigureAwait(false);                          ThrowIfCancellationRequested();                            using (loadImageData.Item1)                          {                              loadImage = await GenerateImageAsync(path' source' loadImageData.Item1' loadImageData.Item3' TransformPlaceholders' true).ConfigureAwait(false);                              if (loadImage != default(TImageContainer))                                  MemoryCache.Add(key' loadImageData.Item3' loadImage);                          }                      }                      finally                      {                          _placeholdersResolveLock.Release();                      }                        ThrowIfCancellationRequested();                        if (isLoadingPlaceholder)                          PlaceholderWeakReference = new WeakReference<TImageContainer>(loadImage);                        if (Target != null)                          await SetTargetAsync(loadImage' false).ConfigureAwait(false);                        if (isLoadingPlaceholder)                          _isLoadingPlaceholderLoaded = true;                  }                  catch (Exception ex)                  {                      if (ex is OperationCanceledException)                          throw;                        Logger.Error("Setting placeholder failed"' ex);                  }              }              else if (isLoadingPlaceholder)              {                  _isLoadingPlaceholderLoaded = true;              }
Magic Number,FFImageLoading.Config,Configuration,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Config\Configuration.cs,Configuration,The following statement contains a magic number: FadeAnimationDuration = 300;
Magic Number,FFImageLoading.Config,Configuration,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Config\Configuration.cs,Configuration,The following statement contains a magic number: HttpHeadersTimeout = 10;
Magic Number,FFImageLoading.Config,Configuration,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Config\Configuration.cs,Configuration,The following statement contains a magic number: HttpReadTimeout = 30;
Magic Number,FFImageLoading.Config,Configuration,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Config\Configuration.cs,Configuration,The following statement contains a magic number: HttpReadBufferSize = 8192;
Magic Number,FFImageLoading.Config,Configuration,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Config\Configuration.cs,Configuration,The following statement contains a magic number: SchedulerMaxParallelTasks = Math.Min(4' Math.Max(2' (int)(Environment.ProcessorCount / 2d)));
Magic Number,FFImageLoading.Config,Configuration,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Config\Configuration.cs,Configuration,The following statement contains a magic number: SchedulerMaxParallelTasks = Math.Min(4' Math.Max(2' (int)(Environment.ProcessorCount / 2d)));
Magic Number,FFImageLoading.Config,Configuration,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Config\Configuration.cs,Configuration,The following statement contains a magic number: DelayInMs = 14;
Magic Number,FFImageLoading.Cache,DownloadCache,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Cache\DownloadCache.cs,DownloadAsync,The following statement contains a magic number: using (var cancelHeadersToken = new CancellationTokenSource())              {                  cancelHeadersToken.CancelAfter(TimeSpan.FromSeconds(Configuration.HttpHeadersTimeout));                    using (var linkedHeadersToken = CancellationTokenSource.CreateLinkedTokenSource(token' cancelHeadersToken.Token))                  {                      try                      {                          using (var response = await client.GetAsync(url' HttpCompletionOption.ResponseHeadersRead' linkedHeadersToken.Token).ConfigureAwait(false))                          {                              if (!response.IsSuccessStatusCode)                                  throw new HttpRequestException(response.StatusCode.ToString());                                if (response.Content == null)                                  throw new HttpRequestException("No Content");                                var mediaType = response.Content.Headers?.ContentType?.MediaType;                              if (!string.IsNullOrWhiteSpace(mediaType) && !mediaType.StartsWith("image/"' StringComparison.OrdinalIgnoreCase))                              {                                  if (InvalidContentTypes.Any(v => mediaType.StartsWith(v' StringComparison.OrdinalIgnoreCase)))                                      throw new HttpRequestException($"Invalid response content type ({mediaType})");                              }                                ModifyParametersAfterResponse(response' parameters);                                using (var cancelReadTimeoutToken = new CancellationTokenSource())                              {                                  var readTimeoutToken = cancelReadTimeoutToken.Token;                                  cancelReadTimeoutToken.CancelAfter(TimeSpan.FromSeconds(Configuration.HttpReadTimeout));                                    int total = (int)(response.Content.Headers.ContentLength ?? -1);                                  var canReportProgress = progressAction != null;                                    try                                  {                                      using (var outputStream = new MemoryStream())                                      using (var sourceStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))                                      {                                          int totalRead = 0;                                          var buffer = new byte[Configuration.HttpReadBufferSize];                                            int read = 0;                                          while ((read = await sourceStream.ReadAsync(buffer' 0' buffer.Length)) > 0)                                          {                                              token.ThrowIfCancellationRequested();                                              readTimeoutToken.ThrowIfCancellationRequested();                                              outputStream.Write(buffer' 0' read);                                              totalRead += read;                                                if (canReportProgress)                                                  progressAction(new DownloadProgress() { Total = total' Current = totalRead });                                          }                                            if (outputStream.Length == 0)                                              throw new InvalidDataException("Zero length stream");                                            if (outputStream.Length < 32)                                              throw new InvalidDataException("Invalid stream");                                            return outputStream.ToArray();                                      }                                  }                                  catch (OperationCanceledException)                                  {                                      if (cancelReadTimeoutToken.IsCancellationRequested)                                          throw new Exception("HttpReadTimeout");                                      else                                          throw;                                  }                              }                          }                      }                      catch (OperationCanceledException)                      {                          if (cancelHeadersToken.IsCancellationRequested)                              throw new Exception("HttpHeadersTimeout");                          else                              throw;                      }                  }              }
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,SetPixelsAsync,The following statement contains a magic number: if (lastDispose > 0)              {                  if (lastDispose == 3)                  {                      // use image before last                      int n = frameCount - 2;                      if (n > 0)                      {                          lastBitmap1 = currentBitmap;                      }                      else                      {                          lastBitmap1 = null;                      }                  }                  if (currentBitmap != null)                  {                      result = lastBitmap1;                        // copy pixels                      if (lastDispose == 2)                      {                          // fill last image rect area with background color                          int c = 0;                          if (!transparency)                          {                              c = lastBgColor;                          }                          for (int i = 0; i < lrh; i++)                          {                              int n1 = (lry + i) * width + lrx;                              int n2 = n1 + lrw;                              for (int k = n1; k < n2; k++)                              {                                  result[k] = c;                              }                          }                      }                  }              }
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,SetPixelsAsync,The following statement contains a magic number: if (lastDispose > 0)              {                  if (lastDispose == 3)                  {                      // use image before last                      int n = frameCount - 2;                      if (n > 0)                      {                          lastBitmap1 = currentBitmap;                      }                      else                      {                          lastBitmap1 = null;                      }                  }                  if (currentBitmap != null)                  {                      result = lastBitmap1;                        // copy pixels                      if (lastDispose == 2)                      {                          // fill last image rect area with background color                          int c = 0;                          if (!transparency)                          {                              c = lastBgColor;                          }                          for (int i = 0; i < lrh; i++)                          {                              int n1 = (lry + i) * width + lrx;                              int n2 = n1 + lrw;                              for (int k = n1; k < n2; k++)                              {                                  result[k] = c;                              }                          }                      }                  }              }
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,SetPixelsAsync,The following statement contains a magic number: if (lastDispose > 0)              {                  if (lastDispose == 3)                  {                      // use image before last                      int n = frameCount - 2;                      if (n > 0)                      {                          lastBitmap1 = currentBitmap;                      }                      else                      {                          lastBitmap1 = null;                      }                  }                  if (currentBitmap != null)                  {                      result = lastBitmap1;                        // copy pixels                      if (lastDispose == 2)                      {                          // fill last image rect area with background color                          int c = 0;                          if (!transparency)                          {                              c = lastBgColor;                          }                          for (int i = 0; i < lrh; i++)                          {                              int n1 = (lry + i) * width + lrx;                              int n2 = n1 + lrw;                              for (int k = n1; k < n2; k++)                              {                                  result[k] = c;                              }                          }                      }                  }              }
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,SetPixelsAsync,The following statement contains a magic number: int inc = 8;
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,SetPixelsAsync,The following statement contains a magic number: for (int i = 0; i < ih; i++)              {                  int line = i;                  if (interlace)                  {                      if (iline >= ih)                      {                          pass++;                          switch (pass)                          {                              case 2:                                  iline = 4;                                  break;                              case 3:                                  iline = 2;                                  inc = 4;                                  break;                              case 4:                                  iline = 1;                                  inc = 2;                                  break;                              default:                                  break;                          }                      }                      line = iline;                      iline += inc;                  }                  line += iy;                  if (line < height)                  {                      int k = line * width;                      int dx = k + ix; // start of line in dest                      int dlim = dx + iw; // end of dest line                      if ((k + width) < dlim)                      {                          dlim = k + width; // past dest edge                      }                      int sx = i * iw; // start of line in source                      while (dx < dlim)                      {                          // map color and insert in destination                          int index = ((int)pixels[sx++]) & 0xff;                          int c = act[index];                          if (c != 0)                          {                              result[dx] = c;                          }                          dx++;                      }                  }              }
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,SetPixelsAsync,The following statement contains a magic number: for (int i = 0; i < ih; i++)              {                  int line = i;                  if (interlace)                  {                      if (iline >= ih)                      {                          pass++;                          switch (pass)                          {                              case 2:                                  iline = 4;                                  break;                              case 3:                                  iline = 2;                                  inc = 4;                                  break;                              case 4:                                  iline = 1;                                  inc = 2;                                  break;                              default:                                  break;                          }                      }                      line = iline;                      iline += inc;                  }                  line += iy;                  if (line < height)                  {                      int k = line * width;                      int dx = k + ix; // start of line in dest                      int dlim = dx + iw; // end of dest line                      if ((k + width) < dlim)                      {                          dlim = k + width; // past dest edge                      }                      int sx = i * iw; // start of line in source                      while (dx < dlim)                      {                          // map color and insert in destination                          int index = ((int)pixels[sx++]) & 0xff;                          int c = act[index];                          if (c != 0)                          {                              result[dx] = c;                          }                          dx++;                      }                  }              }
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,SetPixelsAsync,The following statement contains a magic number: for (int i = 0; i < ih; i++)              {                  int line = i;                  if (interlace)                  {                      if (iline >= ih)                      {                          pass++;                          switch (pass)                          {                              case 2:                                  iline = 4;                                  break;                              case 3:                                  iline = 2;                                  inc = 4;                                  break;                              case 4:                                  iline = 1;                                  inc = 2;                                  break;                              default:                                  break;                          }                      }                      line = iline;                      iline += inc;                  }                  line += iy;                  if (line < height)                  {                      int k = line * width;                      int dx = k + ix; // start of line in dest                      int dlim = dx + iw; // end of dest line                      if ((k + width) < dlim)                      {                          dlim = k + width; // past dest edge                      }                      int sx = i * iw; // start of line in source                      while (dx < dlim)                      {                          // map color and insert in destination                          int index = ((int)pixels[sx++]) & 0xff;                          int c = act[index];                          if (c != 0)                          {                              result[dx] = c;                          }                          dx++;                      }                  }              }
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,SetPixelsAsync,The following statement contains a magic number: for (int i = 0; i < ih; i++)              {                  int line = i;                  if (interlace)                  {                      if (iline >= ih)                      {                          pass++;                          switch (pass)                          {                              case 2:                                  iline = 4;                                  break;                              case 3:                                  iline = 2;                                  inc = 4;                                  break;                              case 4:                                  iline = 1;                                  inc = 2;                                  break;                              default:                                  break;                          }                      }                      line = iline;                      iline += inc;                  }                  line += iy;                  if (line < height)                  {                      int k = line * width;                      int dx = k + ix; // start of line in dest                      int dlim = dx + iw; // end of dest line                      if ((k + width) < dlim)                      {                          dlim = k + width; // past dest edge                      }                      int sx = i * iw; // start of line in source                      while (dx < dlim)                      {                          // map color and insert in destination                          int index = ((int)pixels[sx++]) & 0xff;                          int c = act[index];                          if (c != 0)                          {                              result[dx] = c;                          }                          dx++;                      }                  }              }
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,SetPixelsAsync,The following statement contains a magic number: for (int i = 0; i < ih; i++)              {                  int line = i;                  if (interlace)                  {                      if (iline >= ih)                      {                          pass++;                          switch (pass)                          {                              case 2:                                  iline = 4;                                  break;                              case 3:                                  iline = 2;                                  inc = 4;                                  break;                              case 4:                                  iline = 1;                                  inc = 2;                                  break;                              default:                                  break;                          }                      }                      line = iline;                      iline += inc;                  }                  line += iy;                  if (line < height)                  {                      int k = line * width;                      int dx = k + ix; // start of line in dest                      int dlim = dx + iw; // end of dest line                      if ((k + width) < dlim)                      {                          dlim = k + width; // past dest edge                      }                      int sx = i * iw; // start of line in source                      while (dx < dlim)                      {                          // map color and insert in destination                          int index = ((int)pixels[sx++]) & 0xff;                          int c = act[index];                          if (c != 0)                          {                              result[dx] = c;                          }                          dx++;                      }                  }              }
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,SetPixelsAsync,The following statement contains a magic number: for (int i = 0; i < ih; i++)              {                  int line = i;                  if (interlace)                  {                      if (iline >= ih)                      {                          pass++;                          switch (pass)                          {                              case 2:                                  iline = 4;                                  break;                              case 3:                                  iline = 2;                                  inc = 4;                                  break;                              case 4:                                  iline = 1;                                  inc = 2;                                  break;                              default:                                  break;                          }                      }                      line = iline;                      iline += inc;                  }                  line += iy;                  if (line < height)                  {                      int k = line * width;                      int dx = k + ix; // start of line in dest                      int dlim = dx + iw; // end of dest line                      if ((k + width) < dlim)                      {                          dlim = k + width; // past dest edge                      }                      int sx = i * iw; // start of line in source                      while (dx < dlim)                      {                          // map color and insert in destination                          int index = ((int)pixels[sx++]) & 0xff;                          int c = act[index];                          if (c != 0)                          {                              result[dx] = c;                          }                          dx++;                      }                  }              }
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,SetPixelsAsync,The following statement contains a magic number: for (int i = 0; i < ih; i++)              {                  int line = i;                  if (interlace)                  {                      if (iline >= ih)                      {                          pass++;                          switch (pass)                          {                              case 2:                                  iline = 4;                                  break;                              case 3:                                  iline = 2;                                  inc = 4;                                  break;                              case 4:                                  iline = 1;                                  inc = 2;                                  break;                              default:                                  break;                          }                      }                      line = iline;                      iline += inc;                  }                  line += iy;                  if (line < height)                  {                      int k = line * width;                      int dx = k + ix; // start of line in dest                      int dlim = dx + iw; // end of dest line                      if ((k + width) < dlim)                      {                          dlim = k + width; // past dest edge                      }                      int sx = i * iw; // start of line in source                      while (dx < dlim)                      {                          // map color and insert in destination                          int index = ((int)pixels[sx++]) & 0xff;                          int c = act[index];                          if (c != 0)                          {                              result[dx] = c;                          }                          dx++;                      }                  }              }
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,DecodeBitmapDataAsync,The following statement contains a magic number: available = clear + 2;
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,DecodeBitmapDataAsync,The following statement contains a magic number: for (i = 0; i < npix;)              {                  if (top == 0)                  {                      if (bits < code_size)                      {                          // Load bytes until there are enough bits for a code.                          if (count == 0)                          {                              // Read a new data block.                              count = await ReadBlockAsync().ConfigureAwait(false);                              if (count <= 0)                              {                                  break;                              }                              bi = 0;                          }                          datum += (((int)block[bi]) & 0xff) << bits;                          bits += 8;                          bi++;                          count--;                          continue;                      }                      // Get the next code.                      code = datum & code_mask;                      datum >>= code_size;                      bits -= code_size;                      // Interpret the code                      if ((code > available) || (code == end_of_information))                      {                          break;                      }                      if (code == clear)                      {                          // Reset decoder.                          code_size = data_size + 1;                          code_mask = (1 << code_size) - 1;                          available = clear + 2;                          old_code = nullCode;                          continue;                      }                      if (old_code == nullCode)                      {                          pixelStack[top++] = suffix[code];                          old_code = code;                          first = code;                          continue;                      }                      in_code = code;                      if (code == available)                      {                          pixelStack[top++] = (byte)first;                          code = old_code;                      }                      while (code > clear)                      {                          pixelStack[top++] = suffix[code];                          code = prefix[code];                      }                      first = ((int)suffix[code]) & 0xff;                      // Add a new string to the string table'                      if (available >= MAX_STACK_SIZE)                      {                          break;                      }                      pixelStack[top++] = (byte)first;                      prefix[available] = (short)old_code;                      suffix[available] = (byte)first;                      available++;                      if (((available & code_mask) == 0) && (available < MAX_STACK_SIZE))                      {                          code_size++;                          code_mask += available;                      }                      old_code = in_code;                  }                  // Pop a pixel off the pixel stack.                  top--;                  pixels[pi++] = pixelStack[top];                  i++;              }
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,DecodeBitmapDataAsync,The following statement contains a magic number: for (i = 0; i < npix;)              {                  if (top == 0)                  {                      if (bits < code_size)                      {                          // Load bytes until there are enough bits for a code.                          if (count == 0)                          {                              // Read a new data block.                              count = await ReadBlockAsync().ConfigureAwait(false);                              if (count <= 0)                              {                                  break;                              }                              bi = 0;                          }                          datum += (((int)block[bi]) & 0xff) << bits;                          bits += 8;                          bi++;                          count--;                          continue;                      }                      // Get the next code.                      code = datum & code_mask;                      datum >>= code_size;                      bits -= code_size;                      // Interpret the code                      if ((code > available) || (code == end_of_information))                      {                          break;                      }                      if (code == clear)                      {                          // Reset decoder.                          code_size = data_size + 1;                          code_mask = (1 << code_size) - 1;                          available = clear + 2;                          old_code = nullCode;                          continue;                      }                      if (old_code == nullCode)                      {                          pixelStack[top++] = suffix[code];                          old_code = code;                          first = code;                          continue;                      }                      in_code = code;                      if (code == available)                      {                          pixelStack[top++] = (byte)first;                          code = old_code;                      }                      while (code > clear)                      {                          pixelStack[top++] = suffix[code];                          code = prefix[code];                      }                      first = ((int)suffix[code]) & 0xff;                      // Add a new string to the string table'                      if (available >= MAX_STACK_SIZE)                      {                          break;                      }                      pixelStack[top++] = (byte)first;                      prefix[available] = (short)old_code;                      suffix[available] = (byte)first;                      available++;                      if (((available & code_mask) == 0) && (available < MAX_STACK_SIZE))                      {                          code_size++;                          code_mask += available;                      }                      old_code = in_code;                  }                  // Pop a pixel off the pixel stack.                  top--;                  pixels[pi++] = pixelStack[top];                  i++;              }
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,ReadColorTableAsync,The following statement contains a magic number: int nbytes = 3 * ncolors;
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,ReadColorTableAsync,The following statement contains a magic number: if (n < nbytes)              {                  status = STATUS_FORMAT_ERROR;              }              else              {                  tab = new int[256]; // max size to avoid bounds checks                  int i = 0;                  int j = 0;                  while (i < ncolors)                  {                      int r = ((int)c[j++]) & 0xff;                      int g = ((int)c[j++]) & 0xff;                      int b = ((int)c[j++]) & 0xff;                      var rgb = (r << 16) | (g << 8) | b;                      tab[i++] = (int)(0xff000000 | rgb);                  }              }
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,ReadColorTableAsync,The following statement contains a magic number: if (n < nbytes)              {                  status = STATUS_FORMAT_ERROR;              }              else              {                  tab = new int[256]; // max size to avoid bounds checks                  int i = 0;                  int j = 0;                  while (i < ncolors)                  {                      int r = ((int)c[j++]) & 0xff;                      int g = ((int)c[j++]) & 0xff;                      int b = ((int)c[j++]) & 0xff;                      var rgb = (r << 16) | (g << 8) | b;                      tab[i++] = (int)(0xff000000 | rgb);                  }              }
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,ReadColorTableAsync,The following statement contains a magic number: if (n < nbytes)              {                  status = STATUS_FORMAT_ERROR;              }              else              {                  tab = new int[256]; // max size to avoid bounds checks                  int i = 0;                  int j = 0;                  while (i < ncolors)                  {                      int r = ((int)c[j++]) & 0xff;                      int g = ((int)c[j++]) & 0xff;                      int b = ((int)c[j++]) & 0xff;                      var rgb = (r << 16) | (g << 8) | b;                      tab[i++] = (int)(0xff000000 | rgb);                  }              }
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,ReadContentsAsync,The following statement contains a magic number: while (!(done || Err))              {                  int code = Read();                  switch (code)                  {                      case 0x2C: // image separator                          await ReadBitmapAsync().ConfigureAwait(false);                          break;                      case 0x21: // extension                          code = Read();                          switch (code)                          {                              case 0xf9: // graphics control extension                                  ReadGraphicControlExt();                                  break;                              case 0xff: // application extension                                  await ReadBlockAsync().ConfigureAwait(false);                                  String app = "";                                  for (int i = 0; i < 11; i++)                                  {                                      app += (char)block[i];                                  }                                  if (app.Equals("NETSCAPE2.0"' StringComparison.OrdinalIgnoreCase))                                  {                                      await ReadNetscapeExtAsync().ConfigureAwait(false);                                  }                                  else                                  {                                      await SkipAsync().ConfigureAwait(false); // don't care                                  }                                  break;                              case 0xfe:// comment extension                                  await SkipAsync().ConfigureAwait(false);                                  break;                              case 0x01:// plain text extension                                  await SkipAsync().ConfigureAwait(false);                                  break;                              default: // uninteresting extension                                  await SkipAsync().ConfigureAwait(false);                                  break;                          }                          break;                      case 0x3b: // terminator                          done = true;                          break;                      case 0x00: // bad byte' but keep going and see what happens break;                      default:                          status = STATUS_FORMAT_ERROR;                          break;                  }              }
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,ReadGraphicControlExt,The following statement contains a magic number: dispose = (packed & 0x1c) >> 2;
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,ReadGraphicControlExt,The following statement contains a magic number: delay = Math.Max(100' ReadShort() * 10);
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,ReadGraphicControlExt,The following statement contains a magic number: delay = Math.Max(100' ReadShort() * 10);
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,ReadHeaderAsync,The following statement contains a magic number: for (int i = 0; i < 6; i++)              {                  id += (char)Read();              }
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,ReadBitmapAsync,The following statement contains a magic number: lctSize = (int)Math.Pow(2' (packed & 0x07) + 1);
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,ReadLSD,The following statement contains a magic number: gctSize = 2 << (packed & 7);
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,ReadLSD,The following statement contains a magic number: gctSize = 2 << (packed & 7);
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,ReadNetscapeExtAsync,The following statement contains a magic number: do              {                  await ReadBlockAsync().ConfigureAwait(false);                  if (block[0] == 1)                  {                      // loop count sub-block                      int b1 = ((int)block[1]) & 0xff;                      int b2 = ((int)block[2]) & 0xff;                      loopCount = (b2 << 8) | b1;                  }              } while ((blockSize > 0) && !Err);
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,ReadNetscapeExtAsync,The following statement contains a magic number: do              {                  await ReadBlockAsync().ConfigureAwait(false);                  if (block[0] == 1)                  {                      // loop count sub-block                      int b1 = ((int)block[1]) & 0xff;                      int b2 = ((int)block[2]) & 0xff;                      loopCount = (b2 << 8) | b1;                  }              } while ((blockSize > 0) && !Err);
Magic Number,FFImageLoading,GifHelperBase<TNativeImageContainer>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\GifHelperBase.cs,ReadShort,The following statement contains a magic number: return Read() | (Read() << 8);
Magic Number,FFImageLoading.Concurrency,SimplePriorityQueue<TItem;TPriority>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Concurrency\FastPriorityQueue\SimplePriorityQueue.cs,EnqueueNoLockOrCache,The following statement contains a magic number: if (_queue.Count == _queue.MaxSize)              {                  _queue.Resize(_queue.MaxSize * 2 + 1);              }
Magic Number,FFImageLoading.Concurrency,GenericPriorityQueue<TItem;TPriority>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Concurrency\FastPriorityQueue\GenericPriorityQueue.cs,CascadeDown,The following statement contains a magic number: int childLeftIndex = 2 * finalQueueIndex;
Magic Number,FFImageLoading.Concurrency,GenericPriorityQueue<TItem;TPriority>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Concurrency\FastPriorityQueue\GenericPriorityQueue.cs,CascadeDown,The following statement contains a magic number: while (true)              {                  childLeftIndex = 2 * finalQueueIndex;                    // If leaf node' we're done                  if (childLeftIndex > _numNodes)                  {                      node.QueueIndex = finalQueueIndex;                      _nodes[finalQueueIndex] = node;                      break;                  }                    // Check if the left-child is higher-priority than the current node                  childRightIndex = childLeftIndex + 1;                  childLeft = _nodes[childLeftIndex];                  if (HasHigherPriority(childLeft' node))                  {                      // Check if there is a right child. If not' swap and finish.                      if (childRightIndex > _numNodes)                      {                          node.QueueIndex = childLeftIndex;                          childLeft.QueueIndex = finalQueueIndex;                          _nodes[finalQueueIndex] = childLeft;                          _nodes[childLeftIndex] = node;                          break;                      }                      // Check if the left-child is higher-priority than the right-child                      TItem childRight = _nodes[childRightIndex];                      if (HasHigherPriority(childLeft' childRight))                      {                          // left is highest' move it up and continue                          childLeft.QueueIndex = finalQueueIndex;                          _nodes[finalQueueIndex] = childLeft;                          finalQueueIndex = childLeftIndex;                      }                      else                      {                          // right is even higher' move it up and continue                          childRight.QueueIndex = finalQueueIndex;                          _nodes[finalQueueIndex] = childRight;                          finalQueueIndex = childRightIndex;                      }                  }                  // Not swapping with left-child' does right-child exist?                  else if (childRightIndex > _numNodes)                  {                      node.QueueIndex = finalQueueIndex;                      _nodes[finalQueueIndex] = node;                      break;                  }                  else                  {                      // Check if the right-child is higher-priority than the current node                      TItem childRight = _nodes[childRightIndex];                      if (HasHigherPriority(childRight' node))                      {                          childRight.QueueIndex = finalQueueIndex;                          _nodes[finalQueueIndex] = childRight;                          finalQueueIndex = childRightIndex;                      }                      // Neither child is higher-priority than current' so finish and stop.                      else                      {                          node.QueueIndex = finalQueueIndex;                          _nodes[finalQueueIndex] = node;                          break;                      }                  }              }
Magic Number,FFImageLoading.Concurrency,GenericPriorityQueue<TItem;TPriority>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Concurrency\FastPriorityQueue\GenericPriorityQueue.cs,IsValidQueue,The following statement contains a magic number: for (int i = 1; i < _nodes.Length; i++)              {                  if (_nodes[i] != null)                  {                      int childLeftIndex = 2 * i;                      if (childLeftIndex < _nodes.Length && _nodes[childLeftIndex] != null && HasHigherPriority(_nodes[childLeftIndex]' _nodes[i]))                          return false;                        int childRightIndex = childLeftIndex + 1;                      if (childRightIndex < _nodes.Length && _nodes[childRightIndex] != null && HasHigherPriority(_nodes[childRightIndex]' _nodes[i]))                          return false;                  }              }
Magic Number,FFImageLoading.DataResolvers,EmbeddedResourceResolver,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\DataResolvers\EmbeddedResourceResolver.cs,Resolve,The following statement contains a magic number: var parts = uri.OriginalString.Substring(11).Split('?');
Magic Number,FFImageLoading.DataResolvers,EmbeddedResourceResolver,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\DataResolvers\EmbeddedResourceResolver.cs,Resolve,The following statement contains a magic number: if (parts.Count() > 1)              {                  var name = Uri.UnescapeDataString(uri.Query.Substring(10));                  var assemblyName = new AssemblyName(name);                  assembly = Assembly.Load(assemblyName);              }
Magic Number,FFImageLoading.DataResolvers,WrappedDataResolver,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\DataResolvers\WrappedDataResolver.cs,Resolve,The following statement contains a magic number: if (resolved.Item1.Length < 32)                  throw new InvalidDataException("Invalid stream");
Magic Number,FFImageLoading.DataResolvers,WrappedDataResolver,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\DataResolvers\WrappedDataResolver.cs,Resolve,The following statement contains a magic number: if (resolved.Item3.Type == ImageInformation.ImageType.Unknown)              {                  //READ HEADER                  const int headerLength = 4;                  byte[] header = new byte[headerLength];                  int offset = 0;                  while (offset < headerLength)                  {                      int read = await resolved.Item1.ReadAsync(header' offset' headerLength - offset);                      offset += read;                  }                    resolved.Item1.Position = 0;                  resolved.Item3.SetType(FileHeader.GetImageType(header));              }
Duplicate Code,FFImageLoading.Concurrency,GenericPriorityQueue<TItem;TPriority>,C:\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Concurrency\FastPriorityQueue\GenericPriorityQueue.cs,CascadeDown,The method contains a code clone-set at the following line numbers (starting from the method definition): ((25' 45)' (90' 110))
