Implementation smell,Namespace,Class,File,Method,Description
Long Method,FFImageLoading.Concurrency,GenericPriorityQueue<TItem;TPriority>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Concurrency\FastPriorityQueue\GenericPriorityQueue.cs,CascadeDown,The method has 129 lines of code.
Long Method,FFImageLoading.Helpers.Exif,DirectoryExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\DirectoryExtensions.cs,GetString,The method has 149 lines of code.
Long Method,FFImageLoading.Helpers.Exif,ExifDirectoryBase,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\ExifIfd0Directory.cs,AddExifTagNames,The method has 159 lines of code.
Long Method,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessIfd,The method has 143 lines of code.
Long Method,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessTag,The method has 173 lines of code.
Long Method,FFImageLoading.Helpers.Gif,GifHelperBase<TNativeImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHelperBase.cs,CopyCopyIntoScratchRobust,The method has 111 lines of code.
Long Method,FFImageLoading.Helpers.Gif,GifHelperBase<TNativeImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHelperBase.cs,DecodeBitmapDataAsync,The method has 131 lines of code.
Long Method,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,SetKeys,The method has 126 lines of code.
Long Method,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,RunAsync,The method has 137 lines of code.
Complex Method,FFImageLoading.Cache,DownloadCache,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Cache\DownloadCache.cs,DownloadAsync,Cyclomatic complexity of the method is 12
Complex Method,FFImageLoading.Concurrency,GenericPriorityQueue<TItem;TPriority>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Concurrency\FastPriorityQueue\GenericPriorityQueue.cs,CascadeDown,Cyclomatic complexity of the method is 14
Complex Method,FFImageLoading.DataResolvers,WrappedDataResolver,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\DataResolvers\WrappedDataResolver.cs,Resolve,Cyclomatic complexity of the method is 8
Complex Method,FFImageLoading.Helpers,FileHeader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\FileHeader.cs,GetImageType,Cyclomatic complexity of the method is 10
Complex Method,FFImageLoading.Helpers.Exif,DirectoryExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\DirectoryExtensions.cs,GetString,Cyclomatic complexity of the method is 43
Complex Method,FFImageLoading.Helpers.Exif,ExifTiffHandler,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\ExifTiffHandler.cs,ProcessBinary,Cyclomatic complexity of the method is 8
Complex Method,FFImageLoading.Helpers.Exif,TiffDataFormat,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffDataFormat.cs,FromTiffFormatCode,Cyclomatic complexity of the method is 12
Complex Method,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessIfd,Cyclomatic complexity of the method is 21
Complex Method,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessTag,Cyclomatic complexity of the method is 35
Complex Method,FFImageLoading.Helpers.Gif,GifHeaderParser,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHeaderParser.cs,ReadContentsAsync,Cyclomatic complexity of the method is 12
Complex Method,FFImageLoading.Helpers.Gif,GifHelperBase<TNativeImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHelperBase.cs,GetNextFrameAsync,Cyclomatic complexity of the method is 8
Complex Method,FFImageLoading.Helpers.Gif,GifHelperBase<TNativeImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHelperBase.cs,SetPixelsAsync,Cyclomatic complexity of the method is 14
Complex Method,FFImageLoading.Helpers.Gif,GifHelperBase<TNativeImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHelperBase.cs,CopyCopyIntoScratchRobust,Cyclomatic complexity of the method is 17
Complex Method,FFImageLoading.Helpers.Gif,GifHelperBase<TNativeImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHelperBase.cs,DecodeBitmapDataAsync,Cyclomatic complexity of the method is 19
Complex Method,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,SetKeys,Cyclomatic complexity of the method is 19
Complex Method,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,ShowPlaceholder,Cyclomatic complexity of the method is 12
Complex Method,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,RunAsync,Cyclomatic complexity of the method is 9
Complex Method,FFImageLoading.Work,WorkScheduler,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\WorkScheduler.cs,QueueImageLoadingTask,Cyclomatic complexity of the method is 8
Complex Method,FFImageLoading.Work,WorkScheduler,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\WorkScheduler.cs,TakeFromPendingTasksAndRunAsync,Cyclomatic complexity of the method is 12
Long Parameter List,FFImageLoading.Cache,DownloadCache,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Cache\DownloadCache.cs,DownloadAsync,The method has 5 parameters. Parameters: url' token' client' parameters' downloadInformation
Long Parameter List,FFImageLoading,DownloadInformation,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\DownloadInformation.cs,DownloadInformation,The method has 5 parameters. Parameters: url' customCacheKey' fileName' allowDiskCaching' cacheValidity
Long Parameter List,FFImageLoading.Decoders,IDecoder,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Decoders\IDecoder.cs,DecodeAsync,The method has 5 parameters. Parameters: stream' path' source' imageInformation' parameters
Long Parameter List,FFImageLoading.Helpers.Exif,DirectoryTiffHandler,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\DirectoryTiffHandler.cs,CustomProcessTag,The method has 5 parameters. Parameters: tagOffset' processedIfdOffsets' reader' tagId' byteCount
Long Parameter List,FFImageLoading.Helpers.Exif,ExifTiffHandler,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\ExifTiffHandler.cs,CustomProcessTag,The method has 5 parameters. Parameters: tagOffset' processedIfdOffsets' reader' tagId' byteCount
Long Parameter List,FFImageLoading.Helpers.Exif,ExifTiffHandler,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\ExifTiffHandler.cs,ProcessBinary,The method has 6 parameters. Parameters: directory' tagValueOffset' reader' byteCount' issigned' arrayLength
Long Parameter List,FFImageLoading.Helpers.Exif,ITiffHandler,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\ITiffHandler.cs,CustomProcessTag,The method has 5 parameters. Parameters: tagOffset' processedIfdOffsets' reader' tagId' byteCount
Long Parameter List,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessTag,The method has 6 parameters. Parameters: handler' tagId' tagValueOffset' componentCount' formatCode' reader
Long Parameter List,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,TransformAsync,The method has 5 parameters. Parameters: bitmap' transformations' path' source' isPlaceholder
Long Parameter List,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,GenerateImageAsync,The method has 6 parameters. Parameters: path' source' imageData' imageInformation' enableTransformations' isPlaceholder
Long Parameter List,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,GenerateImageAsync,The method has 6 parameters. Parameters: path' source' decoded' imageInformation' enableTransformations' isPlaceholder
Long Parameter List,FFImageLoading.Work,ITransformation,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ITransformation.cs,Transform,The method has 5 parameters. Parameters: sourceBitmap' path' source' isPlaceholder' key
Long Identifier,FFImageLoading.Helpers.Exif,ExifDirectoryBase,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\ExifIfd0Directory.cs,,The length of the parameter TagOptoElectricConversionFunction is 33.
Long Identifier,FFImageLoading.Helpers.Exif,ExifDirectoryBase,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\ExifIfd0Directory.cs,,The length of the parameter TagCompressedAverageBitsPerPixel is 32.
Long Identifier,FFImageLoading.Helpers.Exif,ExifDirectoryBase,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\ExifIfd0Directory.cs,,The length of the parameter TagFocalPlaneXResolutionTiffEp is 30.
Long Identifier,FFImageLoading.Helpers.Exif,ExifDirectoryBase,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\ExifIfd0Directory.cs,,The length of the parameter TagFocalPlaneYResolutionTiffEp is 30.
Long Identifier,FFImageLoading.Helpers.Gif,GifHeaderParser,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHeaderParser.cs,,The length of the parameter LABEL_GRAPHIC_CONTROL_EXTENSION is 31.
Long Identifier,FFImageLoading.Helpers.Gif,GifHeaderParser,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHeaderParser.cs,,The length of the parameter GCE_MASK_TRANSPARENT_COLOR_FLAG is 31.
Long Identifier,FFImageLoading.Helpers.Gif,GifHeaderParser,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHeaderParser.cs,,The length of the parameter DESCRIPTOR_MASK_INTERLACE_FLAG is 30.
Long Identifier,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,TryLoadFromMemoryCacheAsync,The length of the parameter isFadeAnimationEnabledForCached is 31.
Long Statement,FFImageLoading.Cache,DownloadCache,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Cache\DownloadCache.cs,DownloadAndCacheIfNeededAsync,The length of the statement  "                await configuration.DiskCache.AddToSavingQueueIfNotExistsAsync(filename' responseBytes' downloadInfo.CacheValidity' finishedAction).ConfigureAwait(false); " is 154.
Long Statement,FFImageLoading.Cache,DownloadCache,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Cache\DownloadCache.cs,DownloadAsync,The length of the statement  "            using (var headersTimeoutTokenSource = CancellationTokenSource.CreateLinkedTokenSource(token' httpHeadersTimeoutTokenSource.Token)) " is 131.
Long Statement,FFImageLoading.Cache,DownloadCache,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Cache\DownloadCache.cs,DownloadAsync,The length of the statement  "                    using (var response = await client.GetAsync(url' HttpCompletionOption.ResponseHeadersRead' headerTimeoutToken).ConfigureAwait(false)) " is 133.
Long Statement,FFImageLoading.Cache,DownloadCache,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Cache\DownloadCache.cs,DownloadAsync,The length of the statement  "                        using (var readTimeoutTokenSource = CancellationTokenSource.CreateLinkedTokenSource(token' httpReadTimeoutTokenSource.Token)) " is 125.
Long Statement,FFImageLoading.Concurrency,GenericPriorityQueue<TItem;TPriority>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Concurrency\FastPriorityQueue\GenericPriorityQueue.cs,Contains,The length of the statement  "                throw new InvalidOperationException("node.QueueIndex has been corrupted. Did you change it manually? Or add this node to another queue?"); " is 138.
Long Statement,FFImageLoading.Concurrency,GenericPriorityQueue<TItem;TPriority>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Concurrency\FastPriorityQueue\GenericPriorityQueue.cs,Dequeue,The length of the statement  "                throw new InvalidOperationException("Queue has been corrupted (Did you update a node priority manually instead of calling UpdatePriority()?" + " is 142.
Long Statement,FFImageLoading.Concurrency,GenericPriorityQueue<TItem;TPriority>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Concurrency\FastPriorityQueue\GenericPriorityQueue.cs,Resize,The length of the statement  "                throw new InvalidOperationException("Called Resize(" + maxNodes + ")' but current queue contains " + _numNodes + " nodes"); " is 123.
Long Statement,FFImageLoading.Concurrency,GenericPriorityQueue<TItem;TPriority>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Concurrency\FastPriorityQueue\GenericPriorityQueue.cs,IsValidQueue,The length of the statement  "                    if (childLeftIndex < _nodes.Length && _nodes[childLeftIndex] != null && HasHigherPriority(_nodes[childLeftIndex]' _nodes[i])) " is 125.
Long Statement,FFImageLoading.Concurrency,GenericPriorityQueue<TItem;TPriority>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Concurrency\FastPriorityQueue\GenericPriorityQueue.cs,IsValidQueue,The length of the statement  "                    if (childRightIndex < _nodes.Length && _nodes[childRightIndex] != null && HasHigherPriority(_nodes[childRightIndex]' _nodes[i])) " is 128.
Long Statement,FFImageLoading,StringExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Extensions\StringExtensions.cs,IsSvgFileUrl,The length of the statement  "                && str.Split(new[] { '?' }' StringSplitOptions.RemoveEmptyEntries)[0].EndsWith("svg"' StringComparison.OrdinalIgnoreCase); " is 122.
Long Statement,FFImageLoading,ImageServiceBase<TImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\ImageServiceBase.cs,Initialize,The length of the statement  "                    configuration.SchedulerMaxParallelTasksFactory = configuration.SchedulerMaxParallelTasksFactory ?? _config.SchedulerMaxParallelTasksFactory; " is 140.
Long Statement,FFImageLoading,ImageServiceBase<TImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\ImageServiceBase.cs,InitializeIfNeeded,The length of the statement  "                var httpClient = userDefinedConfig.HttpClient ?? new HttpClient(new HttpClientHandler() { AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate }); " is 175.
Long Statement,FFImageLoading,ImageServiceBase<TImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\ImageServiceBase.cs,InitializeIfNeeded,The length of the statement  "					StaticLocks.DecodingLock = new SemaphoreSlim(userDefinedConfig.DecodingMaxParallelTasks' userDefinedConfig.DecodingMaxParallelTasks); " is 133.
Long Statement,FFImageLoading,ImageServiceBase<TImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\ImageServiceBase.cs,InitializeIfNeeded,The length of the statement  "                    userDefinedConfig.Logger = new MiniLoggerWrapper(userDefinedConfig.Logger ?? CreatePlatformLoggerInstance(userDefinedConfig)' userDefinedConfig.VerboseLogging); " is 160.
Long Statement,FFImageLoading,ImageServiceBase<TImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\ImageServiceBase.cs,InitializeIfNeeded,The length of the statement  "                userDefinedConfig.Scheduler = userDefinedConfig.Scheduler ?? new WorkScheduler(userDefinedConfig' (userDefinedConfig.VerbosePerformanceLogging ? CreatePlatformPerformanceInstance(userDefinedConfig) : new EmptyPlatformPerformance())); " is 233.
Long Statement,FFImageLoading,ImageServiceBase<TImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\ImageServiceBase.cs,InitializeIfNeeded,The length of the statement  "                userDefinedConfig.MainThreadDispatcher = userDefinedConfig.MainThreadDispatcher ?? CreateMainThreadDispatcherInstance(userDefinedConfig); " is 137.
Long Statement,FFImageLoading,ImageServiceBase<TImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\ImageServiceBase.cs,InitializeIfNeeded,The length of the statement  "                userDefinedConfig.DataResolverFactory = userDefinedConfig.DataResolverFactory ?? CreateDataResolverFactoryInstance(userDefinedConfig); " is 134.
Long Statement,FFImageLoading.DataResolvers,UrlDataResolver,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\DataResolvers\UrlDataResolver.cs,Resolve,The length of the statement  "            var downloadedData = await DownloadCache.DownloadAndCacheIfNeededAsync(identifier' parameters' Configuration' token).ConfigureAwait(false); " is 139.
Long Statement,FFImageLoading.DataResolvers,UrlDataResolver,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\DataResolvers\UrlDataResolver.cs,Resolve,The length of the statement  "                downloadedData?.ImageStream' downloadedData.RetrievedFromDiskCache ? LoadingResult.DiskCache : LoadingResult.Internet' imageInformation); " is 137.
Long Statement,FFImageLoading.Helpers.Exif,ExifReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\ExifReader.cs,ReadJpegSegments,The length of the statement  "                .Where(segment => segment.Bytes.Length >= JpegSegmentPreamble.Length && Encoding.UTF8.GetString(segment.Bytes' 0' JpegSegmentPreamble.Length) == JpegSegmentPreamble) " is 165.
Long Statement,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessIfd,The length of the statement  "                // Check for directories we've already visited to avoid stack overflows when recursive/cyclic directory structures exist. " is 121.
Long Statement,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessIfd,The length of the statement  "                    if (!isIfdPointer && !handler.CustomProcessTag((int)tagValueOffset' processedGlobalIfdOffsets' reader' tagId' (int)byteCount)) " is 126.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,Init,The length of the statement  "			if (Parameters.Source == ImageSource.Stream && Configuration.StreamChecksumsAsKeys && string.IsNullOrWhiteSpace(Parameters.CustomCacheKey)) " is 139.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,SetKeys,The length of the statement  "					KeyForLoadingPlaceholder = string.Concat(Parameters.LoadingPlaceholderPath' KeyDownsamplingOnly' KeyTransformationsOnly); " is 121.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,GenerateImageAsync,The length of the statement  "				return await GenerateImageFromDecoderContainerAsync(decoderContainer' imageInformation' isPlaceholder).ConfigureAwait(false); " is 125.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,GenerateImageAsync,The length of the statement  "			return await GenerateImageFromDecoderContainerAsync(decoderContainer' imageInformation' isPlaceholder).ConfigureAwait(false); " is 125.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,TryLoadFromMemoryCacheAsync,The length of the statement  "				var isFadeAnimationEnabledForCached = Parameters.FadeAnimationForCachedImagesEnabled ?? Configuration.FadeAnimationForCachedImages; " is 131.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,TryLoadFromMemoryCacheAsync,The length of the statement  "				var result = await TryLoadFromMemoryCacheAsync(Key' true' isFadeAnimationEnabledForCached' false).ConfigureAwait(false); " is 120.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,ShowPlaceholder,The length of the statement  "					var customResolver = isLoadingPlaceholder ? Parameters.CustomLoadingPlaceholderDataResolver : Parameters.CustomErrorPlaceholderDataResolver; " is 140.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,ShowPlaceholder,The length of the statement  "					if (!await _placeholdersResolveLock.WaitAsync(TimeSpan.FromSeconds(10)' CancellationTokenSource.Token).ConfigureAwait(false)) " is 125.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,ShowPlaceholder,The length of the statement  "								loadImage = await GenerateImageAsync(path' source' loadImageData.Stream' loadImageData.ImageInformation' TransformPlaceholders' true).ConfigureAwait(false); " is 156.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,ShowPlaceholder,The length of the statement  "							loadImage = await GenerateImageAsync(path' source' loadImageData.Decoded' loadImageData.ImageInformation' TransformPlaceholders' true).ConfigureAwait(false); " is 157.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,RunAsync,The length of the statement  "					var resolver = Parameters.CustomDataResolver ?? DataResolverFactory.GetResolver(Parameters.Path' Parameters.Source' Parameters' Configuration); " is 143.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,RunAsync,The length of the statement  "					var imageData = await resolver.Resolve(Parameters.Path' Parameters' CancellationTokenSource.Token).ConfigureAwait(false); " is 121.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,RunAsync,The length of the statement  "							image = await GenerateImageAsync(Parameters.Path' Parameters.Source' imageData.Stream' imageData.ImageInformation' true' false).ConfigureAwait(false); " is 150.
Long Statement,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,RunAsync,The length of the statement  "						image = await GenerateImageAsync(Parameters.Path' Parameters.Source' imageData.Decoded' imageData.ImageInformation' true' false).ConfigureAwait(false); " is 151.
Long Statement,FFImageLoading.Work,WorkScheduler,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\WorkScheduler.cs,TakeFromPendingTasksAndRunAsync,The length of the statement  "                    urlTasksCount = RunningTasks.Count(v => v.Value != null && !v.Value.Parameters.Preload && v.Value.Parameters.Source == ImageSource.Url); " is 136.
Long Statement,FFImageLoading.Work,WorkScheduler,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\WorkScheduler.cs,TakeFromPendingTasksAndRunAsync,The length of the statement  "					}' CancellationToken.None' TaskCreationOptions.PreferFairness | TaskCreationOptions.DenyChildAttach | TaskCreationOptions.HideScheduler' TaskScheduler.Default).ConfigureAwait(false); " is 182.
Long Statement,FFImageLoading.Work,WorkScheduler,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\WorkScheduler.cs,RunImageLoadingTaskAsync,The length of the statement  "                    Logger.Debug(string.Format("[PERFORMANCE] RunAsync - NetManagedThreadId: {0}' NativeThreadId: {1}' Execution: {2} ms' Key: {3}"' " is 128.
Long Statement,FFImageLoading.Work,WorkScheduler,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\WorkScheduler.cs,LogSchedulerStats,The length of the statement  "            Logger.Debug(string.Format("[PERFORMANCE] Scheduler - Max: {0}' Pending: {1}' Running: {2}' TotalPending: {3}' TotalRunning: {4}' TotalMemoryCacheHit: {5}' TotalWaiting: {6}"' " is 175.
Complex Conditional,FFImageLoading.Cache,DownloadCache,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Cache\DownloadCache.cs,DownloadAsync,The conditional expression  "!parameters.CacheDuration.HasValue && Configuration.TryToReadDiskCacheDurationFromHttpHeaders                              && response.Headers?.CacheControl?.MaxAge != null && response.Headers.CacheControl.MaxAge > TimeSpan.Zero"  is complex.
Complex Conditional,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,TryLoadFromMemoryCacheAsync,The conditional expression  "Parameters.Preload && Parameters.CacheType.HasValue &&  					(Parameters.CacheType.Value == CacheType.Disk || Parameters.CacheType.Value == CacheType.None)"  is complex.
Empty Catch Block,FFImageLoading,ObjectExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Extensions\ObjectExtensions.cs,TryDispose,The method has an empty catch block.
Empty Catch Block,FFImageLoading,ImageServiceBase<TImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\ImageServiceBase.cs,InitializeIfNeeded,The method has an empty catch block.
Empty Catch Block,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,ThrowIfCancellationRequested,The method has an empty catch block.
Empty Catch Block,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,Cancel,The method has an empty catch block.
Empty Catch Block,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,RunAsync,The method has an empty catch block.
Magic Number,FFImageLoading.Cache,DownloadCache,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Cache\DownloadCache.cs,DownloadAsync,The following statement contains a magic number: await Task.Delay(25).ConfigureAwait(false);
Magic Number,FFImageLoading.Concurrency,GenericPriorityQueue<TItem;TPriority>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Concurrency\FastPriorityQueue\GenericPriorityQueue.cs,CascadeDown,The following statement contains a magic number: int childLeftIndex = 2 * finalQueueIndex;
Magic Number,FFImageLoading.Concurrency,GenericPriorityQueue<TItem;TPriority>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Concurrency\FastPriorityQueue\GenericPriorityQueue.cs,CascadeDown,The following statement contains a magic number: childLeftIndex = 2 * finalQueueIndex;
Magic Number,FFImageLoading.Concurrency,GenericPriorityQueue<TItem;TPriority>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Concurrency\FastPriorityQueue\GenericPriorityQueue.cs,IsValidQueue,The following statement contains a magic number: int childLeftIndex = 2 * i;
Magic Number,FFImageLoading.Concurrency,SimplePriorityQueue<TItem;TPriority>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Concurrency\FastPriorityQueue\SimplePriorityQueue.cs,EnqueueNoLockOrCache,The following statement contains a magic number: _queue.Resize(_queue.MaxSize * 2 + 1);
Magic Number,FFImageLoading,IntExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Extensions\IntExtensions.cs,HighestOneBit,The following statement contains a magic number: return (int)Math.Pow(2' Convert.ToString(number' 2).Length - 1);
Magic Number,FFImageLoading,IntExtensions,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Extensions\IntExtensions.cs,HighestOneBit,The following statement contains a magic number: return (int)Math.Pow(2' Convert.ToString(number' 2).Length - 1);
Magic Number,FFImageLoading.Config,Configuration,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Config\Configuration.cs,Configuration,The following statement contains a magic number: FadeAnimationDuration = 300;
Magic Number,FFImageLoading.Config,Configuration,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Config\Configuration.cs,Configuration,The following statement contains a magic number: HttpHeadersTimeout = 3;
Magic Number,FFImageLoading.Config,Configuration,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Config\Configuration.cs,Configuration,The following statement contains a magic number: HttpReadTimeout = 15;
Magic Number,FFImageLoading.Config,Configuration,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Config\Configuration.cs,Configuration,The following statement contains a magic number: HttpReadBufferSize = 8192;
Magic Number,FFImageLoading.Config,Configuration,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Config\Configuration.cs,Configuration,The following statement contains a magic number: DecodingMaxParallelTasks = Environment.ProcessorCount <= 2 ? 1 : 2;
Magic Number,FFImageLoading.Config,Configuration,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Config\Configuration.cs,Configuration,The following statement contains a magic number: DecodingMaxParallelTasks = Environment.ProcessorCount <= 2 ? 1 : 2;
Magic Number,FFImageLoading.Config,Configuration,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Config\Configuration.cs,Configuration,The following statement contains a magic number: SchedulerMaxParallelTasks = Math.Max(16' 4 + Environment.ProcessorCount);
Magic Number,FFImageLoading.Config,Configuration,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Config\Configuration.cs,Configuration,The following statement contains a magic number: SchedulerMaxParallelTasks = Math.Max(16' 4 + Environment.ProcessorCount);
Magic Number,FFImageLoading.Config,Configuration,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Config\Configuration.cs,Configuration,The following statement contains a magic number: DiskCacheDuration = TimeSpan.FromDays(30d);
Magic Number,FFImageLoading.Config,Configuration,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Config\Configuration.cs,Configuration,The following statement contains a magic number: DelayInMs = 10;
Magic Number,FFImageLoading.DataResolvers,EmbeddedResourceResolver,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\DataResolvers\EmbeddedResourceResolver.cs,Resolve,The following statement contains a magic number: var parts = uri.OriginalString.Substring(11).Split('?');
Magic Number,FFImageLoading.DataResolvers,EmbeddedResourceResolver,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\DataResolvers\EmbeddedResourceResolver.cs,Resolve,The following statement contains a magic number: var name = Uri.UnescapeDataString(uri.Query.Substring(10));
Magic Number,FFImageLoading.DataResolvers,WrappedDataResolver,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\DataResolvers\WrappedDataResolver.cs,Resolve,The following statement contains a magic number: resolved.Stream.Length < 32
Magic Number,FFImageLoading.DataResolvers,WrappedDataResolver,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\DataResolvers\WrappedDataResolver.cs,Resolve,The following statement contains a magic number: const int headerLength = 4;
Magic Number,FFImageLoading.Helpers.Exif,ExifTiffHandler,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\ExifTiffHandler.cs,TryCustomProcessFormat,The following statement contains a magic number: byteCount = 4 * componentCount;
Magic Number,FFImageLoading.Helpers.Exif,ExifTiffHandler,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\ExifTiffHandler.cs,TryCustomProcessFormat,The following statement contains a magic number: (ushort)formatCode == 13u
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetBit,The following statement contains a magic number: var byteIndex = index / 8;
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetBit,The following statement contains a magic number: var bitIndex = index % 8;
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetUInt16,The following statement contains a magic number: ValidateIndex(index' 2);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetUInt16,The following statement contains a magic number: return (ushort)                      (GetByte(index    ) << 8 |                       GetByte(index + 1));
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetUInt16,The following statement contains a magic number: return (ushort)                  (GetByte(index + 1) << 8 |                   GetByte(index    ));
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt16,The following statement contains a magic number: ValidateIndex(index' 2);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt16,The following statement contains a magic number: return (short)                      (GetByte(index    ) << 8 |                       GetByte(index + 1));
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt16,The following statement contains a magic number: return (short)                  (GetByte(index + 1) << 8 |                   GetByte(index));
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt24,The following statement contains a magic number: ValidateIndex(index' 3);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt24,The following statement contains a magic number: return                      GetByte(index    ) << 16 |                      GetByte(index + 1)  << 8 |                      GetByte(index + 2);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt24,The following statement contains a magic number: return                      GetByte(index    ) << 16 |                      GetByte(index + 1)  << 8 |                      GetByte(index + 2);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt24,The following statement contains a magic number: return                      GetByte(index    ) << 16 |                      GetByte(index + 1)  << 8 |                      GetByte(index + 2);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt24,The following statement contains a magic number: return                  GetByte(index + 2) << 16 |                  GetByte(index + 1) <<  8 |                  GetByte(index    );
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt24,The following statement contains a magic number: return                  GetByte(index + 2) << 16 |                  GetByte(index + 1) <<  8 |                  GetByte(index    );
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt24,The following statement contains a magic number: return                  GetByte(index + 2) << 16 |                  GetByte(index + 1) <<  8 |                  GetByte(index    );
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetUInt32,The following statement contains a magic number: ValidateIndex(index' 4);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetUInt32,The following statement contains a magic number: return (uint)                      (GetByte(index    ) << 24 |                       GetByte(index + 1) << 16 |                       GetByte(index + 2) <<  8 |                       GetByte(index + 3));
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetUInt32,The following statement contains a magic number: return (uint)                      (GetByte(index    ) << 24 |                       GetByte(index + 1) << 16 |                       GetByte(index + 2) <<  8 |                       GetByte(index + 3));
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetUInt32,The following statement contains a magic number: return (uint)                      (GetByte(index    ) << 24 |                       GetByte(index + 1) << 16 |                       GetByte(index + 2) <<  8 |                       GetByte(index + 3));
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetUInt32,The following statement contains a magic number: return (uint)                      (GetByte(index    ) << 24 |                       GetByte(index + 1) << 16 |                       GetByte(index + 2) <<  8 |                       GetByte(index + 3));
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetUInt32,The following statement contains a magic number: return (uint)                      (GetByte(index    ) << 24 |                       GetByte(index + 1) << 16 |                       GetByte(index + 2) <<  8 |                       GetByte(index + 3));
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetUInt32,The following statement contains a magic number: return (uint)                  (GetByte(index + 3) << 24 |                   GetByte(index + 2) << 16 |                   GetByte(index + 1) <<  8 |                   GetByte(index    ));
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetUInt32,The following statement contains a magic number: return (uint)                  (GetByte(index + 3) << 24 |                   GetByte(index + 2) << 16 |                   GetByte(index + 1) <<  8 |                   GetByte(index    ));
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetUInt32,The following statement contains a magic number: return (uint)                  (GetByte(index + 3) << 24 |                   GetByte(index + 2) << 16 |                   GetByte(index + 1) <<  8 |                   GetByte(index    ));
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetUInt32,The following statement contains a magic number: return (uint)                  (GetByte(index + 3) << 24 |                   GetByte(index + 2) << 16 |                   GetByte(index + 1) <<  8 |                   GetByte(index    ));
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetUInt32,The following statement contains a magic number: return (uint)                  (GetByte(index + 3) << 24 |                   GetByte(index + 2) << 16 |                   GetByte(index + 1) <<  8 |                   GetByte(index    ));
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt32,The following statement contains a magic number: ValidateIndex(index' 4);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt32,The following statement contains a magic number: return                      GetByte(index    ) << 24 |                      GetByte(index + 1) << 16 |                      GetByte(index + 2) <<  8 |                      GetByte(index + 3);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt32,The following statement contains a magic number: return                      GetByte(index    ) << 24 |                      GetByte(index + 1) << 16 |                      GetByte(index + 2) <<  8 |                      GetByte(index + 3);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt32,The following statement contains a magic number: return                      GetByte(index    ) << 24 |                      GetByte(index + 1) << 16 |                      GetByte(index + 2) <<  8 |                      GetByte(index + 3);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt32,The following statement contains a magic number: return                      GetByte(index    ) << 24 |                      GetByte(index + 1) << 16 |                      GetByte(index + 2) <<  8 |                      GetByte(index + 3);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt32,The following statement contains a magic number: return                      GetByte(index    ) << 24 |                      GetByte(index + 1) << 16 |                      GetByte(index + 2) <<  8 |                      GetByte(index + 3);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt32,The following statement contains a magic number: return                  GetByte(index + 3) << 24 |                  GetByte(index + 2) << 16 |                  GetByte(index + 1) <<  8 |                  GetByte(index    );
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt32,The following statement contains a magic number: return                  GetByte(index + 3) << 24 |                  GetByte(index + 2) << 16 |                  GetByte(index + 1) <<  8 |                  GetByte(index    );
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt32,The following statement contains a magic number: return                  GetByte(index + 3) << 24 |                  GetByte(index + 2) << 16 |                  GetByte(index + 1) <<  8 |                  GetByte(index    );
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt32,The following statement contains a magic number: return                  GetByte(index + 3) << 24 |                  GetByte(index + 2) << 16 |                  GetByte(index + 1) <<  8 |                  GetByte(index    );
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt32,The following statement contains a magic number: return                  GetByte(index + 3) << 24 |                  GetByte(index + 2) << 16 |                  GetByte(index + 1) <<  8 |                  GetByte(index    );
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt64,The following statement contains a magic number: ValidateIndex(index' 8);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt64,The following statement contains a magic number: return                      (long)GetByte(index    ) << 56 |                      (long)GetByte(index + 1) << 48 |                      (long)GetByte(index + 2) << 40 |                      (long)GetByte(index + 3) << 32 |                      (long)GetByte(index + 4) << 24 |                      (long)GetByte(index + 5) << 16 |                      (long)GetByte(index + 6) <<  8 |                            GetByte(index + 7);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt64,The following statement contains a magic number: return                      (long)GetByte(index    ) << 56 |                      (long)GetByte(index + 1) << 48 |                      (long)GetByte(index + 2) << 40 |                      (long)GetByte(index + 3) << 32 |                      (long)GetByte(index + 4) << 24 |                      (long)GetByte(index + 5) << 16 |                      (long)GetByte(index + 6) <<  8 |                            GetByte(index + 7);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt64,The following statement contains a magic number: return                      (long)GetByte(index    ) << 56 |                      (long)GetByte(index + 1) << 48 |                      (long)GetByte(index + 2) << 40 |                      (long)GetByte(index + 3) << 32 |                      (long)GetByte(index + 4) << 24 |                      (long)GetByte(index + 5) << 16 |                      (long)GetByte(index + 6) <<  8 |                            GetByte(index + 7);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt64,The following statement contains a magic number: return                      (long)GetByte(index    ) << 56 |                      (long)GetByte(index + 1) << 48 |                      (long)GetByte(index + 2) << 40 |                      (long)GetByte(index + 3) << 32 |                      (long)GetByte(index + 4) << 24 |                      (long)GetByte(index + 5) << 16 |                      (long)GetByte(index + 6) <<  8 |                            GetByte(index + 7);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt64,The following statement contains a magic number: return                      (long)GetByte(index    ) << 56 |                      (long)GetByte(index + 1) << 48 |                      (long)GetByte(index + 2) << 40 |                      (long)GetByte(index + 3) << 32 |                      (long)GetByte(index + 4) << 24 |                      (long)GetByte(index + 5) << 16 |                      (long)GetByte(index + 6) <<  8 |                            GetByte(index + 7);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt64,The following statement contains a magic number: return                      (long)GetByte(index    ) << 56 |                      (long)GetByte(index + 1) << 48 |                      (long)GetByte(index + 2) << 40 |                      (long)GetByte(index + 3) << 32 |                      (long)GetByte(index + 4) << 24 |                      (long)GetByte(index + 5) << 16 |                      (long)GetByte(index + 6) <<  8 |                            GetByte(index + 7);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt64,The following statement contains a magic number: return                      (long)GetByte(index    ) << 56 |                      (long)GetByte(index + 1) << 48 |                      (long)GetByte(index + 2) << 40 |                      (long)GetByte(index + 3) << 32 |                      (long)GetByte(index + 4) << 24 |                      (long)GetByte(index + 5) << 16 |                      (long)GetByte(index + 6) <<  8 |                            GetByte(index + 7);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt64,The following statement contains a magic number: return                      (long)GetByte(index    ) << 56 |                      (long)GetByte(index + 1) << 48 |                      (long)GetByte(index + 2) << 40 |                      (long)GetByte(index + 3) << 32 |                      (long)GetByte(index + 4) << 24 |                      (long)GetByte(index + 5) << 16 |                      (long)GetByte(index + 6) <<  8 |                            GetByte(index + 7);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt64,The following statement contains a magic number: return                      (long)GetByte(index    ) << 56 |                      (long)GetByte(index + 1) << 48 |                      (long)GetByte(index + 2) << 40 |                      (long)GetByte(index + 3) << 32 |                      (long)GetByte(index + 4) << 24 |                      (long)GetByte(index + 5) << 16 |                      (long)GetByte(index + 6) <<  8 |                            GetByte(index + 7);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt64,The following statement contains a magic number: return                      (long)GetByte(index    ) << 56 |                      (long)GetByte(index + 1) << 48 |                      (long)GetByte(index + 2) << 40 |                      (long)GetByte(index + 3) << 32 |                      (long)GetByte(index + 4) << 24 |                      (long)GetByte(index + 5) << 16 |                      (long)GetByte(index + 6) <<  8 |                            GetByte(index + 7);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt64,The following statement contains a magic number: return                      (long)GetByte(index    ) << 56 |                      (long)GetByte(index + 1) << 48 |                      (long)GetByte(index + 2) << 40 |                      (long)GetByte(index + 3) << 32 |                      (long)GetByte(index + 4) << 24 |                      (long)GetByte(index + 5) << 16 |                      (long)GetByte(index + 6) <<  8 |                            GetByte(index + 7);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt64,The following statement contains a magic number: return                      (long)GetByte(index    ) << 56 |                      (long)GetByte(index + 1) << 48 |                      (long)GetByte(index + 2) << 40 |                      (long)GetByte(index + 3) << 32 |                      (long)GetByte(index + 4) << 24 |                      (long)GetByte(index + 5) << 16 |                      (long)GetByte(index + 6) <<  8 |                            GetByte(index + 7);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt64,The following statement contains a magic number: return                      (long)GetByte(index    ) << 56 |                      (long)GetByte(index + 1) << 48 |                      (long)GetByte(index + 2) << 40 |                      (long)GetByte(index + 3) << 32 |                      (long)GetByte(index + 4) << 24 |                      (long)GetByte(index + 5) << 16 |                      (long)GetByte(index + 6) <<  8 |                            GetByte(index + 7);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt64,The following statement contains a magic number: return                  (long)GetByte(index + 7) << 56 |                  (long)GetByte(index + 6) << 48 |                  (long)GetByte(index + 5) << 40 |                  (long)GetByte(index + 4) << 32 |                  (long)GetByte(index + 3) << 24 |                  (long)GetByte(index + 2) << 16 |                  (long)GetByte(index + 1) <<  8 |                        GetByte(index    );
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt64,The following statement contains a magic number: return                  (long)GetByte(index + 7) << 56 |                  (long)GetByte(index + 6) << 48 |                  (long)GetByte(index + 5) << 40 |                  (long)GetByte(index + 4) << 32 |                  (long)GetByte(index + 3) << 24 |                  (long)GetByte(index + 2) << 16 |                  (long)GetByte(index + 1) <<  8 |                        GetByte(index    );
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt64,The following statement contains a magic number: return                  (long)GetByte(index + 7) << 56 |                  (long)GetByte(index + 6) << 48 |                  (long)GetByte(index + 5) << 40 |                  (long)GetByte(index + 4) << 32 |                  (long)GetByte(index + 3) << 24 |                  (long)GetByte(index + 2) << 16 |                  (long)GetByte(index + 1) <<  8 |                        GetByte(index    );
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt64,The following statement contains a magic number: return                  (long)GetByte(index + 7) << 56 |                  (long)GetByte(index + 6) << 48 |                  (long)GetByte(index + 5) << 40 |                  (long)GetByte(index + 4) << 32 |                  (long)GetByte(index + 3) << 24 |                  (long)GetByte(index + 2) << 16 |                  (long)GetByte(index + 1) <<  8 |                        GetByte(index    );
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt64,The following statement contains a magic number: return                  (long)GetByte(index + 7) << 56 |                  (long)GetByte(index + 6) << 48 |                  (long)GetByte(index + 5) << 40 |                  (long)GetByte(index + 4) << 32 |                  (long)GetByte(index + 3) << 24 |                  (long)GetByte(index + 2) << 16 |                  (long)GetByte(index + 1) <<  8 |                        GetByte(index    );
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt64,The following statement contains a magic number: return                  (long)GetByte(index + 7) << 56 |                  (long)GetByte(index + 6) << 48 |                  (long)GetByte(index + 5) << 40 |                  (long)GetByte(index + 4) << 32 |                  (long)GetByte(index + 3) << 24 |                  (long)GetByte(index + 2) << 16 |                  (long)GetByte(index + 1) <<  8 |                        GetByte(index    );
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt64,The following statement contains a magic number: return                  (long)GetByte(index + 7) << 56 |                  (long)GetByte(index + 6) << 48 |                  (long)GetByte(index + 5) << 40 |                  (long)GetByte(index + 4) << 32 |                  (long)GetByte(index + 3) << 24 |                  (long)GetByte(index + 2) << 16 |                  (long)GetByte(index + 1) <<  8 |                        GetByte(index    );
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt64,The following statement contains a magic number: return                  (long)GetByte(index + 7) << 56 |                  (long)GetByte(index + 6) << 48 |                  (long)GetByte(index + 5) << 40 |                  (long)GetByte(index + 4) << 32 |                  (long)GetByte(index + 3) << 24 |                  (long)GetByte(index + 2) << 16 |                  (long)GetByte(index + 1) <<  8 |                        GetByte(index    );
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt64,The following statement contains a magic number: return                  (long)GetByte(index + 7) << 56 |                  (long)GetByte(index + 6) << 48 |                  (long)GetByte(index + 5) << 40 |                  (long)GetByte(index + 4) << 32 |                  (long)GetByte(index + 3) << 24 |                  (long)GetByte(index + 2) << 16 |                  (long)GetByte(index + 1) <<  8 |                        GetByte(index    );
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt64,The following statement contains a magic number: return                  (long)GetByte(index + 7) << 56 |                  (long)GetByte(index + 6) << 48 |                  (long)GetByte(index + 5) << 40 |                  (long)GetByte(index + 4) << 32 |                  (long)GetByte(index + 3) << 24 |                  (long)GetByte(index + 2) << 16 |                  (long)GetByte(index + 1) <<  8 |                        GetByte(index    );
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt64,The following statement contains a magic number: return                  (long)GetByte(index + 7) << 56 |                  (long)GetByte(index + 6) << 48 |                  (long)GetByte(index + 5) << 40 |                  (long)GetByte(index + 4) << 32 |                  (long)GetByte(index + 3) << 24 |                  (long)GetByte(index + 2) << 16 |                  (long)GetByte(index + 1) <<  8 |                        GetByte(index    );
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt64,The following statement contains a magic number: return                  (long)GetByte(index + 7) << 56 |                  (long)GetByte(index + 6) << 48 |                  (long)GetByte(index + 5) << 40 |                  (long)GetByte(index + 4) << 32 |                  (long)GetByte(index + 3) << 24 |                  (long)GetByte(index + 2) << 16 |                  (long)GetByte(index + 1) <<  8 |                        GetByte(index    );
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetInt64,The following statement contains a magic number: return                  (long)GetByte(index + 7) << 56 |                  (long)GetByte(index + 6) << 48 |                  (long)GetByte(index + 5) << 40 |                  (long)GetByte(index + 4) << 32 |                  (long)GetByte(index + 3) << 24 |                  (long)GetByte(index + 2) << 16 |                  (long)GetByte(index + 1) <<  8 |                        GetByte(index    );
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetS15Fixed16,The following statement contains a magic number: ValidateIndex(index' 4);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetS15Fixed16,The following statement contains a magic number: float res = GetByte(index) << 8 | GetByte(index + 1);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetS15Fixed16,The following statement contains a magic number: var d = GetByte(index + 2) << 8 | GetByte(index + 3);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetS15Fixed16,The following statement contains a magic number: var d = GetByte(index + 2) << 8 | GetByte(index + 3);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetS15Fixed16,The following statement contains a magic number: var d = GetByte(index + 2) << 8 | GetByte(index + 3);
Magic Number,FFImageLoading.Helpers.Exif,IndexedReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\IndexedReader.cs,GetS15Fixed16,The following statement contains a magic number: return (float)(res + d / 65536.0);
Magic Number,FFImageLoading.Helpers.Exif,JpegSegmentReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\JpegSegmentReader.cs,ReadSegments,The following statement contains a magic number: segmentLength -= 2;
Magic Number,FFImageLoading.Helpers.Exif,Rational,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\Rational.cs,ToSimpleString,The following statement contains a magic number: doubleString.Length < 5
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetUInt16,The following statement contains a magic number: return (ushort)                      (GetByte() << 8 |                       GetByte());
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetUInt16,The following statement contains a magic number: return (ushort)                  (GetByte() |                   GetByte() << 8);
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetInt16,The following statement contains a magic number: return (short)                      (GetByte() << 8 |                       GetByte());
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetInt16,The following statement contains a magic number: return (short)                  (GetByte() |                   GetByte() << 8);
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetUInt32,The following statement contains a magic number: return (uint)                      (GetByte() << 24 |                       GetByte() << 16 |                       GetByte() << 8 |                       GetByte());
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetUInt32,The following statement contains a magic number: return (uint)                      (GetByte() << 24 |                       GetByte() << 16 |                       GetByte() << 8 |                       GetByte());
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetUInt32,The following statement contains a magic number: return (uint)                      (GetByte() << 24 |                       GetByte() << 16 |                       GetByte() << 8 |                       GetByte());
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetUInt32,The following statement contains a magic number: return (uint)                  (GetByte() |                   GetByte() << 8 |                   GetByte() << 16 |                   GetByte() << 24);
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetUInt32,The following statement contains a magic number: return (uint)                  (GetByte() |                   GetByte() << 8 |                   GetByte() << 16 |                   GetByte() << 24);
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetUInt32,The following statement contains a magic number: return (uint)                  (GetByte() |                   GetByte() << 8 |                   GetByte() << 16 |                   GetByte() << 24);
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetInt32,The following statement contains a magic number: return                      GetByte() << 24 |                      GetByte() << 16 |                      GetByte() << 8 |                      GetByte();
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetInt32,The following statement contains a magic number: return                      GetByte() << 24 |                      GetByte() << 16 |                      GetByte() << 8 |                      GetByte();
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetInt32,The following statement contains a magic number: return                      GetByte() << 24 |                      GetByte() << 16 |                      GetByte() << 8 |                      GetByte();
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetInt32,The following statement contains a magic number: return                  GetByte() |                  GetByte() << 8 |                  GetByte() << 16 |                  GetByte() << 24;
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetInt32,The following statement contains a magic number: return                  GetByte() |                  GetByte() << 8 |                  GetByte() << 16 |                  GetByte() << 24;
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetInt32,The following statement contains a magic number: return                  GetByte() |                  GetByte() << 8 |                  GetByte() << 16 |                  GetByte() << 24;
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetInt64,The following statement contains a magic number: return                      (long)GetByte() << 56 |                      (long)GetByte() << 48 |                      (long)GetByte() << 40 |                      (long)GetByte() << 32 |                      (long)GetByte() << 24 |                      (long)GetByte() << 16 |                      (long)GetByte() << 8 |                            GetByte();
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetInt64,The following statement contains a magic number: return                      (long)GetByte() << 56 |                      (long)GetByte() << 48 |                      (long)GetByte() << 40 |                      (long)GetByte() << 32 |                      (long)GetByte() << 24 |                      (long)GetByte() << 16 |                      (long)GetByte() << 8 |                            GetByte();
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetInt64,The following statement contains a magic number: return                      (long)GetByte() << 56 |                      (long)GetByte() << 48 |                      (long)GetByte() << 40 |                      (long)GetByte() << 32 |                      (long)GetByte() << 24 |                      (long)GetByte() << 16 |                      (long)GetByte() << 8 |                            GetByte();
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetInt64,The following statement contains a magic number: return                      (long)GetByte() << 56 |                      (long)GetByte() << 48 |                      (long)GetByte() << 40 |                      (long)GetByte() << 32 |                      (long)GetByte() << 24 |                      (long)GetByte() << 16 |                      (long)GetByte() << 8 |                            GetByte();
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetInt64,The following statement contains a magic number: return                      (long)GetByte() << 56 |                      (long)GetByte() << 48 |                      (long)GetByte() << 40 |                      (long)GetByte() << 32 |                      (long)GetByte() << 24 |                      (long)GetByte() << 16 |                      (long)GetByte() << 8 |                            GetByte();
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetInt64,The following statement contains a magic number: return                      (long)GetByte() << 56 |                      (long)GetByte() << 48 |                      (long)GetByte() << 40 |                      (long)GetByte() << 32 |                      (long)GetByte() << 24 |                      (long)GetByte() << 16 |                      (long)GetByte() << 8 |                            GetByte();
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetInt64,The following statement contains a magic number: return                      (long)GetByte() << 56 |                      (long)GetByte() << 48 |                      (long)GetByte() << 40 |                      (long)GetByte() << 32 |                      (long)GetByte() << 24 |                      (long)GetByte() << 16 |                      (long)GetByte() << 8 |                            GetByte();
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetInt64,The following statement contains a magic number: return                        GetByte() |                  (long)GetByte() << 8 |                  (long)GetByte() << 16 |                  (long)GetByte() << 24 |                  (long)GetByte() << 32 |                  (long)GetByte() << 40 |                  (long)GetByte() << 48 |                  (long)GetByte() << 56;
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetInt64,The following statement contains a magic number: return                        GetByte() |                  (long)GetByte() << 8 |                  (long)GetByte() << 16 |                  (long)GetByte() << 24 |                  (long)GetByte() << 32 |                  (long)GetByte() << 40 |                  (long)GetByte() << 48 |                  (long)GetByte() << 56;
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetInt64,The following statement contains a magic number: return                        GetByte() |                  (long)GetByte() << 8 |                  (long)GetByte() << 16 |                  (long)GetByte() << 24 |                  (long)GetByte() << 32 |                  (long)GetByte() << 40 |                  (long)GetByte() << 48 |                  (long)GetByte() << 56;
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetInt64,The following statement contains a magic number: return                        GetByte() |                  (long)GetByte() << 8 |                  (long)GetByte() << 16 |                  (long)GetByte() << 24 |                  (long)GetByte() << 32 |                  (long)GetByte() << 40 |                  (long)GetByte() << 48 |                  (long)GetByte() << 56;
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetInt64,The following statement contains a magic number: return                        GetByte() |                  (long)GetByte() << 8 |                  (long)GetByte() << 16 |                  (long)GetByte() << 24 |                  (long)GetByte() << 32 |                  (long)GetByte() << 40 |                  (long)GetByte() << 48 |                  (long)GetByte() << 56;
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetInt64,The following statement contains a magic number: return                        GetByte() |                  (long)GetByte() << 8 |                  (long)GetByte() << 16 |                  (long)GetByte() << 24 |                  (long)GetByte() << 32 |                  (long)GetByte() << 40 |                  (long)GetByte() << 48 |                  (long)GetByte() << 56;
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetInt64,The following statement contains a magic number: return                        GetByte() |                  (long)GetByte() << 8 |                  (long)GetByte() << 16 |                  (long)GetByte() << 24 |                  (long)GetByte() << 32 |                  (long)GetByte() << 40 |                  (long)GetByte() << 48 |                  (long)GetByte() << 56;
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetS15Fixed16,The following statement contains a magic number: float res = GetByte() << 8 | GetByte();
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetS15Fixed16,The following statement contains a magic number: var d = GetByte() << 8 | GetByte();
Magic Number,FFImageLoading.Helpers.Exif,SequentialReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\SequentialReader.cs,GetS15Fixed16,The following statement contains a magic number: return (float)(res + d / 65536.0);
Magic Number,FFImageLoading.Helpers.Exif,TagDescriptor<T>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TagDescriptor.cs,GetDescription,The following statement contains a magic number: obj is Array array && array.Length > 16
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessTiff,The following statement contains a magic number: int tiffMarker = reader.GetUInt16(2);
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessTiff,The following statement contains a magic number: var firstIfdOffset = reader.GetInt32(4);
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessTiff,The following statement contains a magic number: firstIfdOffset = 2 + 2 + 4;
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessTiff,The following statement contains a magic number: firstIfdOffset = 2 + 2 + 4;
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessTiff,The following statement contains a magic number: firstIfdOffset = 2 + 2 + 4;
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessIfd,The following statement contains a magic number: dirTagCount >>= 8;
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessIfd,The following statement contains a magic number: var dirLength = 2 + 12 * dirTagCount + 4;
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessIfd,The following statement contains a magic number: var dirLength = 2 + 12 * dirTagCount + 4;
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessIfd,The following statement contains a magic number: var dirLength = 2 + 12 * dirTagCount + 4;
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessIfd,The following statement contains a magic number: var formatCode = (TiffDataFormatCode)reader.GetUInt16(tagOffset + 2);
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessIfd,The following statement contains a magic number: var componentCount = reader.GetUInt32(tagOffset + 4);
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessIfd,The following statement contains a magic number: ++invalidTiffFormatCodeCount > 5
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessIfd,The following statement contains a magic number: tagValueOffset = reader.GetUInt32(tagOffset + 8);
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessIfd,The following statement contains a magic number: byteCount > 4
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessIfd,The following statement contains a magic number: var subDirOffset = reader.GetUInt32((int)(tagValueOffset + i * 4));
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessIfd,The following statement contains a magic number: byteCount == checked(4L * componentCount)
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessTag,The following statement contains a magic number: switch (formatCode)              {                  case TiffDataFormatCode.Undefined:                      {                          // this includes exif user comments                          handler.SetByteArray(tagId' reader.GetBytes(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.String:                      {                          handler.SetString(tagId' reader.GetNullTerminatedStringValue(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.RationalS:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetInt32(tagValueOffset)' reader.GetInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetInt32(tagValueOffset + 8 * i)' reader.GetInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.RationalU:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetUInt32(tagValueOffset)' reader.GetUInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetUInt32(tagValueOffset + 8 * i)' reader.GetUInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Single:                      {                          if (componentCount == 1)                          {                              handler.SetFloat(tagId' reader.GetFloat32(tagValueOffset));                          }                          else                          {                              var array = new float[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetFloat32(tagValueOffset + i * 4);                              handler.SetFloatArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Double:                      {                          if (componentCount == 1)                          {                              handler.SetDouble(tagId' reader.GetDouble64(tagValueOffset));                          }                          else                          {                              var array = new double[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetDouble64(tagValueOffset + i * 4);                              handler.SetDoubleArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8S:                      {                          if (componentCount == 1)                          {                              handler.SetInt8S(tagId' reader.GetSByte(tagValueOffset));                          }                          else                          {                              var array = new sbyte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetSByte(tagValueOffset + i);                              handler.SetInt8SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8U:                      {                          if (componentCount == 1)                          {                              handler.SetInt8U(tagId' reader.GetByte(tagValueOffset));                          }                          else                          {                              var array = new byte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetByte(tagValueOffset + i);                              handler.SetInt8UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16S:                      {                          if (componentCount == 1)                          {                              handler.SetInt16S(tagId' reader.GetInt16(tagValueOffset));                          }                          else                          {                              var array = new short[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt16(tagValueOffset + i * 2);                              handler.SetInt16SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16U:                      {                          if (componentCount == 1)                          {                              handler.SetInt16U(tagId' reader.GetUInt16(tagValueOffset));                          }                          else                          {                              var array = new ushort[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt16(tagValueOffset + i * 2);                              handler.SetInt16UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32S:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32S(tagId' reader.GetInt32(tagValueOffset));                          }                          else                          {                              var array = new int[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt32(tagValueOffset + i * 4);                              handler.SetInt32SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32U:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32U(tagId' reader.GetUInt32(tagValueOffset));                          }                          else                          {                              var array = new uint[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt32(tagValueOffset + i * 4);                              handler.SetInt32UArray(tagId' array);                          }                          break;                      }                  default:                      {                          handler.Error($"Invalid TIFF tag format code {formatCode} for tag 0x{tagId:X4}");                          break;                      }              }
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessTag,The following statement contains a magic number: switch (formatCode)              {                  case TiffDataFormatCode.Undefined:                      {                          // this includes exif user comments                          handler.SetByteArray(tagId' reader.GetBytes(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.String:                      {                          handler.SetString(tagId' reader.GetNullTerminatedStringValue(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.RationalS:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetInt32(tagValueOffset)' reader.GetInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetInt32(tagValueOffset + 8 * i)' reader.GetInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.RationalU:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetUInt32(tagValueOffset)' reader.GetUInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetUInt32(tagValueOffset + 8 * i)' reader.GetUInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Single:                      {                          if (componentCount == 1)                          {                              handler.SetFloat(tagId' reader.GetFloat32(tagValueOffset));                          }                          else                          {                              var array = new float[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetFloat32(tagValueOffset + i * 4);                              handler.SetFloatArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Double:                      {                          if (componentCount == 1)                          {                              handler.SetDouble(tagId' reader.GetDouble64(tagValueOffset));                          }                          else                          {                              var array = new double[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetDouble64(tagValueOffset + i * 4);                              handler.SetDoubleArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8S:                      {                          if (componentCount == 1)                          {                              handler.SetInt8S(tagId' reader.GetSByte(tagValueOffset));                          }                          else                          {                              var array = new sbyte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetSByte(tagValueOffset + i);                              handler.SetInt8SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8U:                      {                          if (componentCount == 1)                          {                              handler.SetInt8U(tagId' reader.GetByte(tagValueOffset));                          }                          else                          {                              var array = new byte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetByte(tagValueOffset + i);                              handler.SetInt8UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16S:                      {                          if (componentCount == 1)                          {                              handler.SetInt16S(tagId' reader.GetInt16(tagValueOffset));                          }                          else                          {                              var array = new short[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt16(tagValueOffset + i * 2);                              handler.SetInt16SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16U:                      {                          if (componentCount == 1)                          {                              handler.SetInt16U(tagId' reader.GetUInt16(tagValueOffset));                          }                          else                          {                              var array = new ushort[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt16(tagValueOffset + i * 2);                              handler.SetInt16UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32S:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32S(tagId' reader.GetInt32(tagValueOffset));                          }                          else                          {                              var array = new int[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt32(tagValueOffset + i * 4);                              handler.SetInt32SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32U:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32U(tagId' reader.GetUInt32(tagValueOffset));                          }                          else                          {                              var array = new uint[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt32(tagValueOffset + i * 4);                              handler.SetInt32UArray(tagId' array);                          }                          break;                      }                  default:                      {                          handler.Error($"Invalid TIFF tag format code {formatCode} for tag 0x{tagId:X4}");                          break;                      }              }
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessTag,The following statement contains a magic number: switch (formatCode)              {                  case TiffDataFormatCode.Undefined:                      {                          // this includes exif user comments                          handler.SetByteArray(tagId' reader.GetBytes(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.String:                      {                          handler.SetString(tagId' reader.GetNullTerminatedStringValue(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.RationalS:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetInt32(tagValueOffset)' reader.GetInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetInt32(tagValueOffset + 8 * i)' reader.GetInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.RationalU:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetUInt32(tagValueOffset)' reader.GetUInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetUInt32(tagValueOffset + 8 * i)' reader.GetUInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Single:                      {                          if (componentCount == 1)                          {                              handler.SetFloat(tagId' reader.GetFloat32(tagValueOffset));                          }                          else                          {                              var array = new float[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetFloat32(tagValueOffset + i * 4);                              handler.SetFloatArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Double:                      {                          if (componentCount == 1)                          {                              handler.SetDouble(tagId' reader.GetDouble64(tagValueOffset));                          }                          else                          {                              var array = new double[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetDouble64(tagValueOffset + i * 4);                              handler.SetDoubleArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8S:                      {                          if (componentCount == 1)                          {                              handler.SetInt8S(tagId' reader.GetSByte(tagValueOffset));                          }                          else                          {                              var array = new sbyte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetSByte(tagValueOffset + i);                              handler.SetInt8SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8U:                      {                          if (componentCount == 1)                          {                              handler.SetInt8U(tagId' reader.GetByte(tagValueOffset));                          }                          else                          {                              var array = new byte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetByte(tagValueOffset + i);                              handler.SetInt8UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16S:                      {                          if (componentCount == 1)                          {                              handler.SetInt16S(tagId' reader.GetInt16(tagValueOffset));                          }                          else                          {                              var array = new short[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt16(tagValueOffset + i * 2);                              handler.SetInt16SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16U:                      {                          if (componentCount == 1)                          {                              handler.SetInt16U(tagId' reader.GetUInt16(tagValueOffset));                          }                          else                          {                              var array = new ushort[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt16(tagValueOffset + i * 2);                              handler.SetInt16UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32S:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32S(tagId' reader.GetInt32(tagValueOffset));                          }                          else                          {                              var array = new int[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt32(tagValueOffset + i * 4);                              handler.SetInt32SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32U:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32U(tagId' reader.GetUInt32(tagValueOffset));                          }                          else                          {                              var array = new uint[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt32(tagValueOffset + i * 4);                              handler.SetInt32UArray(tagId' array);                          }                          break;                      }                  default:                      {                          handler.Error($"Invalid TIFF tag format code {formatCode} for tag 0x{tagId:X4}");                          break;                      }              }
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessTag,The following statement contains a magic number: switch (formatCode)              {                  case TiffDataFormatCode.Undefined:                      {                          // this includes exif user comments                          handler.SetByteArray(tagId' reader.GetBytes(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.String:                      {                          handler.SetString(tagId' reader.GetNullTerminatedStringValue(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.RationalS:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetInt32(tagValueOffset)' reader.GetInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetInt32(tagValueOffset + 8 * i)' reader.GetInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.RationalU:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetUInt32(tagValueOffset)' reader.GetUInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetUInt32(tagValueOffset + 8 * i)' reader.GetUInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Single:                      {                          if (componentCount == 1)                          {                              handler.SetFloat(tagId' reader.GetFloat32(tagValueOffset));                          }                          else                          {                              var array = new float[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetFloat32(tagValueOffset + i * 4);                              handler.SetFloatArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Double:                      {                          if (componentCount == 1)                          {                              handler.SetDouble(tagId' reader.GetDouble64(tagValueOffset));                          }                          else                          {                              var array = new double[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetDouble64(tagValueOffset + i * 4);                              handler.SetDoubleArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8S:                      {                          if (componentCount == 1)                          {                              handler.SetInt8S(tagId' reader.GetSByte(tagValueOffset));                          }                          else                          {                              var array = new sbyte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetSByte(tagValueOffset + i);                              handler.SetInt8SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8U:                      {                          if (componentCount == 1)                          {                              handler.SetInt8U(tagId' reader.GetByte(tagValueOffset));                          }                          else                          {                              var array = new byte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetByte(tagValueOffset + i);                              handler.SetInt8UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16S:                      {                          if (componentCount == 1)                          {                              handler.SetInt16S(tagId' reader.GetInt16(tagValueOffset));                          }                          else                          {                              var array = new short[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt16(tagValueOffset + i * 2);                              handler.SetInt16SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16U:                      {                          if (componentCount == 1)                          {                              handler.SetInt16U(tagId' reader.GetUInt16(tagValueOffset));                          }                          else                          {                              var array = new ushort[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt16(tagValueOffset + i * 2);                              handler.SetInt16UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32S:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32S(tagId' reader.GetInt32(tagValueOffset));                          }                          else                          {                              var array = new int[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt32(tagValueOffset + i * 4);                              handler.SetInt32SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32U:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32U(tagId' reader.GetUInt32(tagValueOffset));                          }                          else                          {                              var array = new uint[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt32(tagValueOffset + i * 4);                              handler.SetInt32UArray(tagId' array);                          }                          break;                      }                  default:                      {                          handler.Error($"Invalid TIFF tag format code {formatCode} for tag 0x{tagId:X4}");                          break;                      }              }
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessTag,The following statement contains a magic number: switch (formatCode)              {                  case TiffDataFormatCode.Undefined:                      {                          // this includes exif user comments                          handler.SetByteArray(tagId' reader.GetBytes(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.String:                      {                          handler.SetString(tagId' reader.GetNullTerminatedStringValue(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.RationalS:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetInt32(tagValueOffset)' reader.GetInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetInt32(tagValueOffset + 8 * i)' reader.GetInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.RationalU:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetUInt32(tagValueOffset)' reader.GetUInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetUInt32(tagValueOffset + 8 * i)' reader.GetUInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Single:                      {                          if (componentCount == 1)                          {                              handler.SetFloat(tagId' reader.GetFloat32(tagValueOffset));                          }                          else                          {                              var array = new float[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetFloat32(tagValueOffset + i * 4);                              handler.SetFloatArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Double:                      {                          if (componentCount == 1)                          {                              handler.SetDouble(tagId' reader.GetDouble64(tagValueOffset));                          }                          else                          {                              var array = new double[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetDouble64(tagValueOffset + i * 4);                              handler.SetDoubleArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8S:                      {                          if (componentCount == 1)                          {                              handler.SetInt8S(tagId' reader.GetSByte(tagValueOffset));                          }                          else                          {                              var array = new sbyte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetSByte(tagValueOffset + i);                              handler.SetInt8SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8U:                      {                          if (componentCount == 1)                          {                              handler.SetInt8U(tagId' reader.GetByte(tagValueOffset));                          }                          else                          {                              var array = new byte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetByte(tagValueOffset + i);                              handler.SetInt8UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16S:                      {                          if (componentCount == 1)                          {                              handler.SetInt16S(tagId' reader.GetInt16(tagValueOffset));                          }                          else                          {                              var array = new short[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt16(tagValueOffset + i * 2);                              handler.SetInt16SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16U:                      {                          if (componentCount == 1)                          {                              handler.SetInt16U(tagId' reader.GetUInt16(tagValueOffset));                          }                          else                          {                              var array = new ushort[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt16(tagValueOffset + i * 2);                              handler.SetInt16UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32S:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32S(tagId' reader.GetInt32(tagValueOffset));                          }                          else                          {                              var array = new int[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt32(tagValueOffset + i * 4);                              handler.SetInt32SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32U:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32U(tagId' reader.GetUInt32(tagValueOffset));                          }                          else                          {                              var array = new uint[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt32(tagValueOffset + i * 4);                              handler.SetInt32UArray(tagId' array);                          }                          break;                      }                  default:                      {                          handler.Error($"Invalid TIFF tag format code {formatCode} for tag 0x{tagId:X4}");                          break;                      }              }
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessTag,The following statement contains a magic number: switch (formatCode)              {                  case TiffDataFormatCode.Undefined:                      {                          // this includes exif user comments                          handler.SetByteArray(tagId' reader.GetBytes(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.String:                      {                          handler.SetString(tagId' reader.GetNullTerminatedStringValue(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.RationalS:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetInt32(tagValueOffset)' reader.GetInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetInt32(tagValueOffset + 8 * i)' reader.GetInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.RationalU:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetUInt32(tagValueOffset)' reader.GetUInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetUInt32(tagValueOffset + 8 * i)' reader.GetUInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Single:                      {                          if (componentCount == 1)                          {                              handler.SetFloat(tagId' reader.GetFloat32(tagValueOffset));                          }                          else                          {                              var array = new float[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetFloat32(tagValueOffset + i * 4);                              handler.SetFloatArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Double:                      {                          if (componentCount == 1)                          {                              handler.SetDouble(tagId' reader.GetDouble64(tagValueOffset));                          }                          else                          {                              var array = new double[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetDouble64(tagValueOffset + i * 4);                              handler.SetDoubleArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8S:                      {                          if (componentCount == 1)                          {                              handler.SetInt8S(tagId' reader.GetSByte(tagValueOffset));                          }                          else                          {                              var array = new sbyte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetSByte(tagValueOffset + i);                              handler.SetInt8SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8U:                      {                          if (componentCount == 1)                          {                              handler.SetInt8U(tagId' reader.GetByte(tagValueOffset));                          }                          else                          {                              var array = new byte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetByte(tagValueOffset + i);                              handler.SetInt8UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16S:                      {                          if (componentCount == 1)                          {                              handler.SetInt16S(tagId' reader.GetInt16(tagValueOffset));                          }                          else                          {                              var array = new short[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt16(tagValueOffset + i * 2);                              handler.SetInt16SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16U:                      {                          if (componentCount == 1)                          {                              handler.SetInt16U(tagId' reader.GetUInt16(tagValueOffset));                          }                          else                          {                              var array = new ushort[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt16(tagValueOffset + i * 2);                              handler.SetInt16UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32S:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32S(tagId' reader.GetInt32(tagValueOffset));                          }                          else                          {                              var array = new int[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt32(tagValueOffset + i * 4);                              handler.SetInt32SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32U:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32U(tagId' reader.GetUInt32(tagValueOffset));                          }                          else                          {                              var array = new uint[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt32(tagValueOffset + i * 4);                              handler.SetInt32UArray(tagId' array);                          }                          break;                      }                  default:                      {                          handler.Error($"Invalid TIFF tag format code {formatCode} for tag 0x{tagId:X4}");                          break;                      }              }
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessTag,The following statement contains a magic number: switch (formatCode)              {                  case TiffDataFormatCode.Undefined:                      {                          // this includes exif user comments                          handler.SetByteArray(tagId' reader.GetBytes(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.String:                      {                          handler.SetString(tagId' reader.GetNullTerminatedStringValue(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.RationalS:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetInt32(tagValueOffset)' reader.GetInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetInt32(tagValueOffset + 8 * i)' reader.GetInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.RationalU:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetUInt32(tagValueOffset)' reader.GetUInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetUInt32(tagValueOffset + 8 * i)' reader.GetUInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Single:                      {                          if (componentCount == 1)                          {                              handler.SetFloat(tagId' reader.GetFloat32(tagValueOffset));                          }                          else                          {                              var array = new float[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetFloat32(tagValueOffset + i * 4);                              handler.SetFloatArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Double:                      {                          if (componentCount == 1)                          {                              handler.SetDouble(tagId' reader.GetDouble64(tagValueOffset));                          }                          else                          {                              var array = new double[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetDouble64(tagValueOffset + i * 4);                              handler.SetDoubleArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8S:                      {                          if (componentCount == 1)                          {                              handler.SetInt8S(tagId' reader.GetSByte(tagValueOffset));                          }                          else                          {                              var array = new sbyte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetSByte(tagValueOffset + i);                              handler.SetInt8SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8U:                      {                          if (componentCount == 1)                          {                              handler.SetInt8U(tagId' reader.GetByte(tagValueOffset));                          }                          else                          {                              var array = new byte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetByte(tagValueOffset + i);                              handler.SetInt8UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16S:                      {                          if (componentCount == 1)                          {                              handler.SetInt16S(tagId' reader.GetInt16(tagValueOffset));                          }                          else                          {                              var array = new short[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt16(tagValueOffset + i * 2);                              handler.SetInt16SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16U:                      {                          if (componentCount == 1)                          {                              handler.SetInt16U(tagId' reader.GetUInt16(tagValueOffset));                          }                          else                          {                              var array = new ushort[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt16(tagValueOffset + i * 2);                              handler.SetInt16UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32S:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32S(tagId' reader.GetInt32(tagValueOffset));                          }                          else                          {                              var array = new int[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt32(tagValueOffset + i * 4);                              handler.SetInt32SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32U:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32U(tagId' reader.GetUInt32(tagValueOffset));                          }                          else                          {                              var array = new uint[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt32(tagValueOffset + i * 4);                              handler.SetInt32UArray(tagId' array);                          }                          break;                      }                  default:                      {                          handler.Error($"Invalid TIFF tag format code {formatCode} for tag 0x{tagId:X4}");                          break;                      }              }
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessTag,The following statement contains a magic number: switch (formatCode)              {                  case TiffDataFormatCode.Undefined:                      {                          // this includes exif user comments                          handler.SetByteArray(tagId' reader.GetBytes(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.String:                      {                          handler.SetString(tagId' reader.GetNullTerminatedStringValue(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.RationalS:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetInt32(tagValueOffset)' reader.GetInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetInt32(tagValueOffset + 8 * i)' reader.GetInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.RationalU:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetUInt32(tagValueOffset)' reader.GetUInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetUInt32(tagValueOffset + 8 * i)' reader.GetUInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Single:                      {                          if (componentCount == 1)                          {                              handler.SetFloat(tagId' reader.GetFloat32(tagValueOffset));                          }                          else                          {                              var array = new float[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetFloat32(tagValueOffset + i * 4);                              handler.SetFloatArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Double:                      {                          if (componentCount == 1)                          {                              handler.SetDouble(tagId' reader.GetDouble64(tagValueOffset));                          }                          else                          {                              var array = new double[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetDouble64(tagValueOffset + i * 4);                              handler.SetDoubleArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8S:                      {                          if (componentCount == 1)                          {                              handler.SetInt8S(tagId' reader.GetSByte(tagValueOffset));                          }                          else                          {                              var array = new sbyte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetSByte(tagValueOffset + i);                              handler.SetInt8SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8U:                      {                          if (componentCount == 1)                          {                              handler.SetInt8U(tagId' reader.GetByte(tagValueOffset));                          }                          else                          {                              var array = new byte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetByte(tagValueOffset + i);                              handler.SetInt8UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16S:                      {                          if (componentCount == 1)                          {                              handler.SetInt16S(tagId' reader.GetInt16(tagValueOffset));                          }                          else                          {                              var array = new short[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt16(tagValueOffset + i * 2);                              handler.SetInt16SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16U:                      {                          if (componentCount == 1)                          {                              handler.SetInt16U(tagId' reader.GetUInt16(tagValueOffset));                          }                          else                          {                              var array = new ushort[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt16(tagValueOffset + i * 2);                              handler.SetInt16UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32S:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32S(tagId' reader.GetInt32(tagValueOffset));                          }                          else                          {                              var array = new int[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt32(tagValueOffset + i * 4);                              handler.SetInt32SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32U:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32U(tagId' reader.GetUInt32(tagValueOffset));                          }                          else                          {                              var array = new uint[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt32(tagValueOffset + i * 4);                              handler.SetInt32UArray(tagId' array);                          }                          break;                      }                  default:                      {                          handler.Error($"Invalid TIFF tag format code {formatCode} for tag 0x{tagId:X4}");                          break;                      }              }
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessTag,The following statement contains a magic number: switch (formatCode)              {                  case TiffDataFormatCode.Undefined:                      {                          // this includes exif user comments                          handler.SetByteArray(tagId' reader.GetBytes(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.String:                      {                          handler.SetString(tagId' reader.GetNullTerminatedStringValue(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.RationalS:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetInt32(tagValueOffset)' reader.GetInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetInt32(tagValueOffset + 8 * i)' reader.GetInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.RationalU:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetUInt32(tagValueOffset)' reader.GetUInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetUInt32(tagValueOffset + 8 * i)' reader.GetUInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Single:                      {                          if (componentCount == 1)                          {                              handler.SetFloat(tagId' reader.GetFloat32(tagValueOffset));                          }                          else                          {                              var array = new float[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetFloat32(tagValueOffset + i * 4);                              handler.SetFloatArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Double:                      {                          if (componentCount == 1)                          {                              handler.SetDouble(tagId' reader.GetDouble64(tagValueOffset));                          }                          else                          {                              var array = new double[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetDouble64(tagValueOffset + i * 4);                              handler.SetDoubleArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8S:                      {                          if (componentCount == 1)                          {                              handler.SetInt8S(tagId' reader.GetSByte(tagValueOffset));                          }                          else                          {                              var array = new sbyte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetSByte(tagValueOffset + i);                              handler.SetInt8SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8U:                      {                          if (componentCount == 1)                          {                              handler.SetInt8U(tagId' reader.GetByte(tagValueOffset));                          }                          else                          {                              var array = new byte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetByte(tagValueOffset + i);                              handler.SetInt8UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16S:                      {                          if (componentCount == 1)                          {                              handler.SetInt16S(tagId' reader.GetInt16(tagValueOffset));                          }                          else                          {                              var array = new short[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt16(tagValueOffset + i * 2);                              handler.SetInt16SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16U:                      {                          if (componentCount == 1)                          {                              handler.SetInt16U(tagId' reader.GetUInt16(tagValueOffset));                          }                          else                          {                              var array = new ushort[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt16(tagValueOffset + i * 2);                              handler.SetInt16UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32S:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32S(tagId' reader.GetInt32(tagValueOffset));                          }                          else                          {                              var array = new int[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt32(tagValueOffset + i * 4);                              handler.SetInt32SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32U:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32U(tagId' reader.GetUInt32(tagValueOffset));                          }                          else                          {                              var array = new uint[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt32(tagValueOffset + i * 4);                              handler.SetInt32UArray(tagId' array);                          }                          break;                      }                  default:                      {                          handler.Error($"Invalid TIFF tag format code {formatCode} for tag 0x{tagId:X4}");                          break;                      }              }
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessTag,The following statement contains a magic number: switch (formatCode)              {                  case TiffDataFormatCode.Undefined:                      {                          // this includes exif user comments                          handler.SetByteArray(tagId' reader.GetBytes(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.String:                      {                          handler.SetString(tagId' reader.GetNullTerminatedStringValue(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.RationalS:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetInt32(tagValueOffset)' reader.GetInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetInt32(tagValueOffset + 8 * i)' reader.GetInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.RationalU:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetUInt32(tagValueOffset)' reader.GetUInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetUInt32(tagValueOffset + 8 * i)' reader.GetUInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Single:                      {                          if (componentCount == 1)                          {                              handler.SetFloat(tagId' reader.GetFloat32(tagValueOffset));                          }                          else                          {                              var array = new float[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetFloat32(tagValueOffset + i * 4);                              handler.SetFloatArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Double:                      {                          if (componentCount == 1)                          {                              handler.SetDouble(tagId' reader.GetDouble64(tagValueOffset));                          }                          else                          {                              var array = new double[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetDouble64(tagValueOffset + i * 4);                              handler.SetDoubleArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8S:                      {                          if (componentCount == 1)                          {                              handler.SetInt8S(tagId' reader.GetSByte(tagValueOffset));                          }                          else                          {                              var array = new sbyte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetSByte(tagValueOffset + i);                              handler.SetInt8SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8U:                      {                          if (componentCount == 1)                          {                              handler.SetInt8U(tagId' reader.GetByte(tagValueOffset));                          }                          else                          {                              var array = new byte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetByte(tagValueOffset + i);                              handler.SetInt8UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16S:                      {                          if (componentCount == 1)                          {                              handler.SetInt16S(tagId' reader.GetInt16(tagValueOffset));                          }                          else                          {                              var array = new short[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt16(tagValueOffset + i * 2);                              handler.SetInt16SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16U:                      {                          if (componentCount == 1)                          {                              handler.SetInt16U(tagId' reader.GetUInt16(tagValueOffset));                          }                          else                          {                              var array = new ushort[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt16(tagValueOffset + i * 2);                              handler.SetInt16UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32S:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32S(tagId' reader.GetInt32(tagValueOffset));                          }                          else                          {                              var array = new int[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt32(tagValueOffset + i * 4);                              handler.SetInt32SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32U:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32U(tagId' reader.GetUInt32(tagValueOffset));                          }                          else                          {                              var array = new uint[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt32(tagValueOffset + i * 4);                              handler.SetInt32UArray(tagId' array);                          }                          break;                      }                  default:                      {                          handler.Error($"Invalid TIFF tag format code {formatCode} for tag 0x{tagId:X4}");                          break;                      }              }
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessTag,The following statement contains a magic number: switch (formatCode)              {                  case TiffDataFormatCode.Undefined:                      {                          // this includes exif user comments                          handler.SetByteArray(tagId' reader.GetBytes(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.String:                      {                          handler.SetString(tagId' reader.GetNullTerminatedStringValue(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.RationalS:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetInt32(tagValueOffset)' reader.GetInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetInt32(tagValueOffset + 8 * i)' reader.GetInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.RationalU:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetUInt32(tagValueOffset)' reader.GetUInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetUInt32(tagValueOffset + 8 * i)' reader.GetUInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Single:                      {                          if (componentCount == 1)                          {                              handler.SetFloat(tagId' reader.GetFloat32(tagValueOffset));                          }                          else                          {                              var array = new float[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetFloat32(tagValueOffset + i * 4);                              handler.SetFloatArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Double:                      {                          if (componentCount == 1)                          {                              handler.SetDouble(tagId' reader.GetDouble64(tagValueOffset));                          }                          else                          {                              var array = new double[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetDouble64(tagValueOffset + i * 4);                              handler.SetDoubleArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8S:                      {                          if (componentCount == 1)                          {                              handler.SetInt8S(tagId' reader.GetSByte(tagValueOffset));                          }                          else                          {                              var array = new sbyte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetSByte(tagValueOffset + i);                              handler.SetInt8SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8U:                      {                          if (componentCount == 1)                          {                              handler.SetInt8U(tagId' reader.GetByte(tagValueOffset));                          }                          else                          {                              var array = new byte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetByte(tagValueOffset + i);                              handler.SetInt8UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16S:                      {                          if (componentCount == 1)                          {                              handler.SetInt16S(tagId' reader.GetInt16(tagValueOffset));                          }                          else                          {                              var array = new short[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt16(tagValueOffset + i * 2);                              handler.SetInt16SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16U:                      {                          if (componentCount == 1)                          {                              handler.SetInt16U(tagId' reader.GetUInt16(tagValueOffset));                          }                          else                          {                              var array = new ushort[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt16(tagValueOffset + i * 2);                              handler.SetInt16UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32S:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32S(tagId' reader.GetInt32(tagValueOffset));                          }                          else                          {                              var array = new int[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt32(tagValueOffset + i * 4);                              handler.SetInt32SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32U:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32U(tagId' reader.GetUInt32(tagValueOffset));                          }                          else                          {                              var array = new uint[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt32(tagValueOffset + i * 4);                              handler.SetInt32UArray(tagId' array);                          }                          break;                      }                  default:                      {                          handler.Error($"Invalid TIFF tag format code {formatCode} for tag 0x{tagId:X4}");                          break;                      }              }
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessTag,The following statement contains a magic number: switch (formatCode)              {                  case TiffDataFormatCode.Undefined:                      {                          // this includes exif user comments                          handler.SetByteArray(tagId' reader.GetBytes(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.String:                      {                          handler.SetString(tagId' reader.GetNullTerminatedStringValue(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.RationalS:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetInt32(tagValueOffset)' reader.GetInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetInt32(tagValueOffset + 8 * i)' reader.GetInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.RationalU:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetUInt32(tagValueOffset)' reader.GetUInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetUInt32(tagValueOffset + 8 * i)' reader.GetUInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Single:                      {                          if (componentCount == 1)                          {                              handler.SetFloat(tagId' reader.GetFloat32(tagValueOffset));                          }                          else                          {                              var array = new float[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetFloat32(tagValueOffset + i * 4);                              handler.SetFloatArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Double:                      {                          if (componentCount == 1)                          {                              handler.SetDouble(tagId' reader.GetDouble64(tagValueOffset));                          }                          else                          {                              var array = new double[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetDouble64(tagValueOffset + i * 4);                              handler.SetDoubleArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8S:                      {                          if (componentCount == 1)                          {                              handler.SetInt8S(tagId' reader.GetSByte(tagValueOffset));                          }                          else                          {                              var array = new sbyte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetSByte(tagValueOffset + i);                              handler.SetInt8SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8U:                      {                          if (componentCount == 1)                          {                              handler.SetInt8U(tagId' reader.GetByte(tagValueOffset));                          }                          else                          {                              var array = new byte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetByte(tagValueOffset + i);                              handler.SetInt8UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16S:                      {                          if (componentCount == 1)                          {                              handler.SetInt16S(tagId' reader.GetInt16(tagValueOffset));                          }                          else                          {                              var array = new short[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt16(tagValueOffset + i * 2);                              handler.SetInt16SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16U:                      {                          if (componentCount == 1)                          {                              handler.SetInt16U(tagId' reader.GetUInt16(tagValueOffset));                          }                          else                          {                              var array = new ushort[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt16(tagValueOffset + i * 2);                              handler.SetInt16UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32S:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32S(tagId' reader.GetInt32(tagValueOffset));                          }                          else                          {                              var array = new int[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt32(tagValueOffset + i * 4);                              handler.SetInt32SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32U:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32U(tagId' reader.GetUInt32(tagValueOffset));                          }                          else                          {                              var array = new uint[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt32(tagValueOffset + i * 4);                              handler.SetInt32UArray(tagId' array);                          }                          break;                      }                  default:                      {                          handler.Error($"Invalid TIFF tag format code {formatCode} for tag 0x{tagId:X4}");                          break;                      }              }
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessTag,The following statement contains a magic number: switch (formatCode)              {                  case TiffDataFormatCode.Undefined:                      {                          // this includes exif user comments                          handler.SetByteArray(tagId' reader.GetBytes(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.String:                      {                          handler.SetString(tagId' reader.GetNullTerminatedStringValue(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.RationalS:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetInt32(tagValueOffset)' reader.GetInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetInt32(tagValueOffset + 8 * i)' reader.GetInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.RationalU:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetUInt32(tagValueOffset)' reader.GetUInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetUInt32(tagValueOffset + 8 * i)' reader.GetUInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Single:                      {                          if (componentCount == 1)                          {                              handler.SetFloat(tagId' reader.GetFloat32(tagValueOffset));                          }                          else                          {                              var array = new float[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetFloat32(tagValueOffset + i * 4);                              handler.SetFloatArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Double:                      {                          if (componentCount == 1)                          {                              handler.SetDouble(tagId' reader.GetDouble64(tagValueOffset));                          }                          else                          {                              var array = new double[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetDouble64(tagValueOffset + i * 4);                              handler.SetDoubleArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8S:                      {                          if (componentCount == 1)                          {                              handler.SetInt8S(tagId' reader.GetSByte(tagValueOffset));                          }                          else                          {                              var array = new sbyte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetSByte(tagValueOffset + i);                              handler.SetInt8SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8U:                      {                          if (componentCount == 1)                          {                              handler.SetInt8U(tagId' reader.GetByte(tagValueOffset));                          }                          else                          {                              var array = new byte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetByte(tagValueOffset + i);                              handler.SetInt8UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16S:                      {                          if (componentCount == 1)                          {                              handler.SetInt16S(tagId' reader.GetInt16(tagValueOffset));                          }                          else                          {                              var array = new short[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt16(tagValueOffset + i * 2);                              handler.SetInt16SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16U:                      {                          if (componentCount == 1)                          {                              handler.SetInt16U(tagId' reader.GetUInt16(tagValueOffset));                          }                          else                          {                              var array = new ushort[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt16(tagValueOffset + i * 2);                              handler.SetInt16UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32S:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32S(tagId' reader.GetInt32(tagValueOffset));                          }                          else                          {                              var array = new int[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt32(tagValueOffset + i * 4);                              handler.SetInt32SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32U:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32U(tagId' reader.GetUInt32(tagValueOffset));                          }                          else                          {                              var array = new uint[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt32(tagValueOffset + i * 4);                              handler.SetInt32UArray(tagId' array);                          }                          break;                      }                  default:                      {                          handler.Error($"Invalid TIFF tag format code {formatCode} for tag 0x{tagId:X4}");                          break;                      }              }
Magic Number,FFImageLoading.Helpers.Exif,TiffReader,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffReader.cs,ProcessTag,The following statement contains a magic number: switch (formatCode)              {                  case TiffDataFormatCode.Undefined:                      {                          // this includes exif user comments                          handler.SetByteArray(tagId' reader.GetBytes(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.String:                      {                          handler.SetString(tagId' reader.GetNullTerminatedStringValue(tagValueOffset' componentCount));                          break;                      }                  case TiffDataFormatCode.RationalS:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetInt32(tagValueOffset)' reader.GetInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetInt32(tagValueOffset + 8 * i)' reader.GetInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.RationalU:                      {                          if (componentCount == 1)                          {                              handler.SetRational(tagId' new Rational(reader.GetUInt32(tagValueOffset)' reader.GetUInt32(tagValueOffset + 4)));                          }                          else if (componentCount > 1)                          {                              var array = new Rational[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = new Rational(reader.GetUInt32(tagValueOffset + 8 * i)' reader.GetUInt32(tagValueOffset + 4 + 8 * i));                              handler.SetRationalArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Single:                      {                          if (componentCount == 1)                          {                              handler.SetFloat(tagId' reader.GetFloat32(tagValueOffset));                          }                          else                          {                              var array = new float[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetFloat32(tagValueOffset + i * 4);                              handler.SetFloatArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Double:                      {                          if (componentCount == 1)                          {                              handler.SetDouble(tagId' reader.GetDouble64(tagValueOffset));                          }                          else                          {                              var array = new double[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetDouble64(tagValueOffset + i * 4);                              handler.SetDoubleArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8S:                      {                          if (componentCount == 1)                          {                              handler.SetInt8S(tagId' reader.GetSByte(tagValueOffset));                          }                          else                          {                              var array = new sbyte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetSByte(tagValueOffset + i);                              handler.SetInt8SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int8U:                      {                          if (componentCount == 1)                          {                              handler.SetInt8U(tagId' reader.GetByte(tagValueOffset));                          }                          else                          {                              var array = new byte[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetByte(tagValueOffset + i);                              handler.SetInt8UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16S:                      {                          if (componentCount == 1)                          {                              handler.SetInt16S(tagId' reader.GetInt16(tagValueOffset));                          }                          else                          {                              var array = new short[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt16(tagValueOffset + i * 2);                              handler.SetInt16SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int16U:                      {                          if (componentCount == 1)                          {                              handler.SetInt16U(tagId' reader.GetUInt16(tagValueOffset));                          }                          else                          {                              var array = new ushort[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt16(tagValueOffset + i * 2);                              handler.SetInt16UArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32S:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32S(tagId' reader.GetInt32(tagValueOffset));                          }                          else                          {                              var array = new int[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetInt32(tagValueOffset + i * 4);                              handler.SetInt32SArray(tagId' array);                          }                          break;                      }                  case TiffDataFormatCode.Int32U:                      {                          // NOTE 'long' in this case means 32 bit' not 64                          if (componentCount == 1)                          {                              handler.SetInt32U(tagId' reader.GetUInt32(tagValueOffset));                          }                          else                          {                              var array = new uint[componentCount];                              for (var i = 0; i < componentCount; i++)                                  array[i] = reader.GetUInt32(tagValueOffset + i * 4);                              handler.SetInt32UArray(tagId' array);                          }                          break;                      }                  default:                      {                          handler.Error($"Invalid TIFF tag format code {formatCode} for tag 0x{tagId:X4}");                          break;                      }              }
Magic Number,FFImageLoading.Helpers.Gif,GifHeaderParser,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHeaderParser.cs,IsAnimatedAsync,The following statement contains a magic number: await ReadContentsAsync(2 /* maxFrames */).ConfigureAwait(false);
Magic Number,FFImageLoading.Helpers.Gif,GifHeaderParser,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHeaderParser.cs,ReadContentsAsync,The following statement contains a magic number: switch (code)  				{  					case IMAGE_SEPARATOR:  						// The Graphic Control Extension is optional' but will always come first if it exists.  						// If one did exist' there will be a non-null current frame which we should use.  						// However if one did not exist' the current frame will be null  						// and we must create it here. See issue #134.  						if (_header.CurrentFrame == null)  						{  							_header.CurrentFrame = new GifFrame();  						}  						ReadBitmap();  						break;  					case EXTENSION_INTRODUCER:  						int extensionLabel = Read();  						switch (extensionLabel)  						{  							case LABEL_GRAPHIC_CONTROL_EXTENSION:  								// Start a new frame.  								_header.CurrentFrame = new GifFrame();  								ReadGraphicControlExt();  								break;  							case LABEL_APPLICATION_EXTENSION:  								await ReadBlockAsync().ConfigureAwait(false);  								var app = new StringBuilder();  								for (int i = 0; i < 11; i++)  								{  									app.Append((char)_block[i]);  								}  								if (app.ToString().Equals("NETSCAPE2.0"))  								{  									await ReadNetscapeExtAsync().ConfigureAwait(false);  								}  								else  								{  									// Don't care.  									Skip();  								}  								break;  							case LABEL_COMMENT_EXTENSION:  								Skip();  								break;  							case LABEL_PLAIN_TEXT_EXTENSION:  								Skip();  								break;  							default:  								// Uninteresting extension.  								Skip();  								break;  						}  						break;  					case TRAILER:  						// This block is a single-field block indicating the end of the GIF Data Stream.  						done = true;  						break;  					// Bad byte' but keep going and see what happens  					case 0x00:  					default:  						_header.Status = GifDecodeStatus.STATUS_FORMAT_ERROR;  						break;  				}
Magic Number,FFImageLoading.Helpers.Gif,GifHeaderParser,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHeaderParser.cs,ReadGraphicControlExt,The following statement contains a magic number: _header.CurrentFrame.Delay = GifHelper.GetValidFrameDelay(delayInHundredthsOfASecond * 10);
Magic Number,FFImageLoading.Helpers.Gif,GifHeaderParser,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHeaderParser.cs,ReadBitmap,The following statement contains a magic number: int lctSize = (int)Math.Pow(2' (packed & DESCRIPTOR_MASK_LCT_SIZE) + 1);
Magic Number,FFImageLoading.Helpers.Gif,GifHeaderParser,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHeaderParser.cs,ReadNetscapeExtAsync,The following statement contains a magic number: int b2 = ((int)_block[2]) & MASK_INT_LOWEST_BYTE;
Magic Number,FFImageLoading.Helpers.Gif,GifHeaderParser,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHeaderParser.cs,ReadNetscapeExtAsync,The following statement contains a magic number: _header.LoopCount = (b2 << 8) | b1;
Magic Number,FFImageLoading.Helpers.Gif,GifHeaderParser,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHeaderParser.cs,ReadHeader,The following statement contains a magic number: i < 6
Magic Number,FFImageLoading.Helpers.Gif,GifHeaderParser,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHeaderParser.cs,ReadLSD,The following statement contains a magic number: _header.GCTSize = (int)Math.Pow(2' (packed & LSD_MASK_GCT_SIZE) + 1);
Magic Number,FFImageLoading.Helpers.Gif,GifHeaderParser,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHeaderParser.cs,ReadColorTable,The following statement contains a magic number: int nBytes = 3 * nColors;
Magic Number,FFImageLoading.Helpers.Gif,GifHeaderParser,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHeaderParser.cs,ReadColorTable,The following statement contains a magic number: tab[i++] = (int)(0xFF000000 | (r << 16) | (g << 8) | b);
Magic Number,FFImageLoading.Helpers.Gif,GifHeaderParser,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHeaderParser.cs,ReadColorTable,The following statement contains a magic number: tab[i++] = (int)(0xFF000000 | (r << 16) | (g << 8) | b);
Magic Number,FFImageLoading.Helpers.Gif,GifHeaderParser,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHeaderParser.cs,ReadShort,The following statement contains a magic number: return (short)(_rawData.ReadByte() | (_rawData.ReadByte() << 8));
Magic Number,FFImageLoading.Helpers.Gif,GifHelper,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHelper.cs,GetValidFrameDelay,The following statement contains a magic number: return 100;
Magic Number,FFImageLoading.Helpers.Gif,GifHelper,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHelper.cs,GetValidFrameDelay,The following statement contains a magic number: ms < 20
Magic Number,FFImageLoading.Helpers.Gif,GifHelperBase<TNativeImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHelperBase.cs,GetNextFrameAsync,The following statement contains a magic number: _block = new byte[255];
Magic Number,FFImageLoading.Helpers.Gif,GifHelperBase<TNativeImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHelperBase.cs,CopyCopyIntoScratchRobust,The following statement contains a magic number: int inc = 8;
Magic Number,FFImageLoading.Helpers.Gif,GifHelperBase<TNativeImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHelperBase.cs,CopyCopyIntoScratchRobust,The following statement contains a magic number: switch (pass)  						{  							case 2:  								iline = 4;  								break;  							case 3:  								iline = 2;  								inc = 4;  								break;  							case 4:  								iline = 1;  								inc = 2;  								break;  							default:  								break;  						}
Magic Number,FFImageLoading.Helpers.Gif,GifHelperBase<TNativeImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHelperBase.cs,CopyCopyIntoScratchRobust,The following statement contains a magic number: switch (pass)  						{  							case 2:  								iline = 4;  								break;  							case 3:  								iline = 2;  								inc = 4;  								break;  							case 4:  								iline = 1;  								inc = 2;  								break;  							default:  								break;  						}
Magic Number,FFImageLoading.Helpers.Gif,GifHelperBase<TNativeImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHelperBase.cs,CopyCopyIntoScratchRobust,The following statement contains a magic number: switch (pass)  						{  							case 2:  								iline = 4;  								break;  							case 3:  								iline = 2;  								inc = 4;  								break;  							case 4:  								iline = 1;  								inc = 2;  								break;  							default:  								break;  						}
Magic Number,FFImageLoading.Helpers.Gif,GifHelperBase<TNativeImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHelperBase.cs,CopyCopyIntoScratchRobust,The following statement contains a magic number: switch (pass)  						{  							case 2:  								iline = 4;  								break;  							case 3:  								iline = 2;  								inc = 4;  								break;  							case 4:  								iline = 1;  								inc = 2;  								break;  							default:  								break;  						}
Magic Number,FFImageLoading.Helpers.Gif,GifHelperBase<TNativeImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHelperBase.cs,CopyCopyIntoScratchRobust,The following statement contains a magic number: switch (pass)  						{  							case 2:  								iline = 4;  								break;  							case 3:  								iline = 2;  								inc = 4;  								break;  							case 4:  								iline = 1;  								inc = 2;  								break;  							default:  								break;  						}
Magic Number,FFImageLoading.Helpers.Gif,GifHelperBase<TNativeImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHelperBase.cs,CopyCopyIntoScratchRobust,The following statement contains a magic number: switch (pass)  						{  							case 2:  								iline = 4;  								break;  							case 3:  								iline = 2;  								inc = 4;  								break;  							case 4:  								iline = 1;  								inc = 2;  								break;  							default:  								break;  						}
Magic Number,FFImageLoading.Helpers.Gif,GifHelperBase<TNativeImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHelperBase.cs,CopyCopyIntoScratchRobust,The following statement contains a magic number: switch (pass)  						{  							case 2:  								iline = 4;  								break;  							case 3:  								iline = 2;  								inc = 4;  								break;  							case 4:  								iline = 1;  								inc = 2;  								break;  							default:  								break;  						}
Magic Number,FFImageLoading.Helpers.Gif,GifHelperBase<TNativeImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHelperBase.cs,AverageColorsNear,The following statement contains a magic number: alphaSum += currentColor >> 24 & MASK_INT_LOWEST_BYTE;
Magic Number,FFImageLoading.Helpers.Gif,GifHelperBase<TNativeImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHelperBase.cs,AverageColorsNear,The following statement contains a magic number: redSum += currentColor >> 16 & MASK_INT_LOWEST_BYTE;
Magic Number,FFImageLoading.Helpers.Gif,GifHelperBase<TNativeImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHelperBase.cs,AverageColorsNear,The following statement contains a magic number: greenSum += currentColor >> 8 & MASK_INT_LOWEST_BYTE;
Magic Number,FFImageLoading.Helpers.Gif,GifHelperBase<TNativeImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHelperBase.cs,AverageColorsNear,The following statement contains a magic number: alphaSum += currentColor >> 24 & MASK_INT_LOWEST_BYTE;
Magic Number,FFImageLoading.Helpers.Gif,GifHelperBase<TNativeImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHelperBase.cs,AverageColorsNear,The following statement contains a magic number: redSum += currentColor >> 16 & MASK_INT_LOWEST_BYTE;
Magic Number,FFImageLoading.Helpers.Gif,GifHelperBase<TNativeImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHelperBase.cs,AverageColorsNear,The following statement contains a magic number: greenSum += currentColor >> 8 & MASK_INT_LOWEST_BYTE;
Magic Number,FFImageLoading.Helpers.Gif,GifHelperBase<TNativeImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHelperBase.cs,DecodeBitmapDataAsync,The following statement contains a magic number: available = clear + 2;
Magic Number,FFImageLoading.Helpers.Gif,GifHelperBase<TNativeImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHelperBase.cs,DecodeBitmapDataAsync,The following statement contains a magic number: bits += 8;
Magic Number,FFImageLoading.Helpers.Gif,GifHelperBase<TNativeImageContainer>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Gif\GifHelperBase.cs,DecodeBitmapDataAsync,The following statement contains a magic number: available = clear + 2;
Magic Number,FFImageLoading.Transformations,FFColorMatrix,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Transformations\FFColorMatrix.cs,ColorToTintMatrix,The following statement contains a magic number: float progressR = (float)r / 128f;
Magic Number,FFImageLoading.Transformations,FFColorMatrix,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Transformations\FFColorMatrix.cs,ColorToTintMatrix,The following statement contains a magic number: float progressG = (float)g / 128f;
Magic Number,FFImageLoading.Transformations,FFColorMatrix,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Transformations\FFColorMatrix.cs,ColorToTintMatrix,The following statement contains a magic number: float progressB = (float)b / 128f;
Magic Number,FFImageLoading.Transformations,FFColorMatrix,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Transformations\FFColorMatrix.cs,ColorToTintMatrix,The following statement contains a magic number: float progressA = (float)a / 128f;
Magic Number,FFImageLoading.Work,ImageLoaderTask<TDecoderContainer;TImageContainer;TImageView>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\ImageLoaderTask.cs,ShowPlaceholder,The following statement contains a magic number: !await _placeholdersResolveLock.WaitAsync(TimeSpan.FromSeconds(10)' CancellationTokenSource.Token).ConfigureAwait(false)
Magic Number,FFImageLoading.Work,WorkScheduler,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\WorkScheduler.cs,LoadImage,The following statement contains a magic number: Configuration.VerbosePerformanceLogging && (_loadCount % 10) == 0
Magic Number,FFImageLoading.Work,WorkScheduler,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\WorkScheduler.cs,TakeFromPendingTasksAndRunAsync,The following statement contains a magic number: RunningTasks.Count - Math.Max(1' Math.Min(preloadOrUrlTasksCount' MaxParallelTasks / 2)) >= MaxParallelTasks
Magic Number,FFImageLoading.Work,WorkScheduler,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\WorkScheduler.cs,TakeFromPendingTasksAndRunAsync,The following statement contains a magic number: var numberOfTasks = MaxParallelTasks - RunningTasks.Count + Math.Min(preloadOrUrlTasksCount' MaxParallelTasks / 2);
Magic Number,FFImageLoading.Work,WorkScheduler,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Work\WorkScheduler.cs,GetDefaultPriority,The following statement contains a magic number: return (int)LoadingPriority.Normal + 2;
Duplicate Code,FFImageLoading.Concurrency,GenericPriorityQueue<TItem;TPriority>,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Concurrency\FastPriorityQueue\GenericPriorityQueue.cs,CascadeDown,The method contains a code clone-set at the following line numbers (starting from the method definition): ((25' 45)' (90' 110))
Missing Default,FFImageLoading.Helpers.Exif,TiffDataFormat,D:\research\architectureSmells\repos\molinch_FFImageLoading\source\FFImageLoading.Common\Helpers\Exif\TiffDataFormat.cs,FromTiffFormatCode,The following switch statement is missing a default case: switch (tiffFormatCode)              {                  case TiffDataFormatCode.Int8U: return Int8U;                  case TiffDataFormatCode.String: return String;                  case TiffDataFormatCode.Int16U: return Int16U;                  case TiffDataFormatCode.Int32U: return Int32U;                  case TiffDataFormatCode.RationalU: return RationalU;                  case TiffDataFormatCode.Int8S: return Int8S;                  case TiffDataFormatCode.Undefined: return Undefined;                  case TiffDataFormatCode.Int16S: return Int16S;                  case TiffDataFormatCode.Int32S: return Int32S;                  case TiffDataFormatCode.RationalS: return RationalS;                  case TiffDataFormatCode.Single: return Single;                  case TiffDataFormatCode.Double: return Double;              }
