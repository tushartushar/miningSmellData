Implementation smell,Namespace,Class,File,Method,Description
Long Method,NUnit.Core.Builders,NUnitTestCaseBuilder,C:\repos\nunit_nunitv2\src\NUnitCore\core\Builders\NUnitTestCaseBuilder.cs,CheckTestMethodSignature,The method has 102 lines of code.
Complex Method,NUnit.Core,TestSuite,C:\repos\nunit_nunitv2\src\NUnitCore\core\TestSuite.cs,RunAllTests,Cyclomatic complexity of the method is 8
Complex Method,NUnit.Core,TestSuiteBuilder,C:\repos\nunit_nunitv2\src\NUnitCore\core\TestSuiteBuilder.cs,Build,Cyclomatic complexity of the method is 8
Complex Method,NUnit.Core,TypeHelper,C:\repos\nunit_nunitv2\src\NUnitCore\core\TypeHelper.cs,GetDisplayName,Cyclomatic complexity of the method is 11
Complex Method,NUnit.Core,TypeHelper,C:\repos\nunit_nunitv2\src\NUnitCore\core\TypeHelper.cs,BestCommonType,Cyclomatic complexity of the method is 27
Complex Method,NUnit.Core,TypeHelper,C:\repos\nunit_nunitv2\src\NUnitCore\core\TypeHelper.cs,CanDeduceTypeArgsFromArgs,Cyclomatic complexity of the method is 8
Complex Method,NUnit.Core.Builders,NUnitTestCaseBuilder,C:\repos\nunit_nunitv2\src\NUnitCore\core\Builders\NUnitTestCaseBuilder.cs,BuildParameterizedMethodSuite,Cyclomatic complexity of the method is 8
Complex Method,NUnit.Core.Builders,NUnitTestCaseBuilder,C:\repos\nunit_nunitv2\src\NUnitCore\core\Builders\NUnitTestCaseBuilder.cs,BuildSingleTestMethod,Cyclomatic complexity of the method is 13
Complex Method,NUnit.Core.Builders,NUnitTestCaseBuilder,C:\repos\nunit_nunitv2\src\NUnitCore\core\Builders\NUnitTestCaseBuilder.cs,CheckTestMethodSignature,Cyclomatic complexity of the method is 17
Complex Method,NUnit.Core.Builders,NUnitTestFixtureBuilder,C:\repos\nunit_nunitv2\src\NUnitCore\core\Builders\NUnitTestFixtureBuilder.cs,BuildSingleFixture,Cyclomatic complexity of the method is 14
Complex Method,NUnit.Core.Builders,NUnitTestFixtureBuilder,C:\repos\nunit_nunitv2\src\NUnitCore\core\Builders\NUnitTestFixtureBuilder.cs,GetTestFixtureAttributes,Cyclomatic complexity of the method is 8
Complex Method,NUnit.Core.Builders,PairwiseTestCaseGenerator,C:\repos\nunit_nunitv2\src\NUnitCore\core\Builders\PairwiseStrategy.cs,MaximizeCoverage,Cyclomatic complexity of the method is 8
Complex Method,NUnit.Core.Builders,TestCaseParameterProvider,C:\repos\nunit_nunitv2\src\NUnitCore\core\Builders\TestCaseParameterProvider.cs,GetTestCasesFor,Cyclomatic complexity of the method is 9
Complex Method,NUnit.Core.Builders,TestCaseParameterProvider,C:\repos\nunit_nunitv2\src\NUnitCore\core\Builders\TestCaseParameterProvider.cs,PerformSpecialConversions,Cyclomatic complexity of the method is 8
Complex Method,NUnit.Core.Builders,TestCaseSourceProvider,C:\repos\nunit_nunitv2\src\NUnitCore\core\Builders\TestCaseSourceProvider.cs,GetTestCasesFor,Cyclomatic complexity of the method is 8
Long Parameter List,NUnit.Core,TestSuite,C:\repos\nunit_nunitv2\src\NUnitCore\core\TestSuite.cs,MarkTestsNotRun,The method has 6 parameters. Parameters: tests' resultState' ignoreReason' suiteResult' listener' filter
Long Parameter List,NUnit.Core,TestSuite,C:\repos\nunit_nunitv2\src\NUnitCore\core\TestSuite.cs,MarkTestNotRun,The method has 6 parameters. Parameters: test' resultState' ignoreReason' suiteResult' listener' filter
Long Identifier,NUnit.Framework,AsyncTaskInvocationRegion,C:\repos\nunit_nunitv2\src\NUnitFramework\framework\AsyncInvocationRegion.cs,,The length of the parameter TaskResultPropertyBindingFlags is 30.
Long Statement,NUnit.Framework,AsyncInvocationRegion,C:\repos\nunit_nunitv2\src\NUnitFramework\framework\AsyncInvocationRegion.cs,PreserveStackTrace,The length of the statement  "                    preserveStackTraceDelegate = (Action<Exception>)Delegate.CreateDelegate(typeof(Action<Exception>)' PreserveStackTraceMethod); " is 125.
Long Statement,NUnit.Framework,AsyncTaskInvocationRegion,C:\repos\nunit_nunitv2\src\NUnitFramework\framework\AsyncInvocationRegion.cs,WaitForPendingOperationsToComplete,The length of the statement  "				PropertyInfo taskResultProperty = invocationResult.GetType().GetProperty(TaskResultProperty' TaskResultPropertyBindingFlags); " is 125.
Long Statement,NUnit.Core,TestMethod,C:\repos\nunit_nunitv2\src\NUnitCore\core\TestMethod.cs,ExecuteActions,The length of the statement  "                    if (!(Parent is ParameterizedMethodSuite) && (action.DoesTarget(TestAction.TargetsDefault) || action.DoesTarget(TestAction.TargetsTest))) " is 137.
Long Statement,NUnit.Core,TestMethod,C:\repos\nunit_nunitv2\src\NUnitCore\core\TestMethod.cs,ExecuteActions,The length of the statement  "                    if (action.DoesTarget(TestAction.TargetsDefault) || (!(Parent is ParameterizedMethodSuite) && action.DoesTarget(TestAction.TargetsTest))) " is 137.
Long Statement,NUnit.Core.Builders,DatapointProvider,C:\repos\nunit_nunitv2\src\NUnitCore\core\Builders\DatapointProvider.cs,HasDataFor,The length of the statement  "            foreach (MemberInfo member in fixtureType.GetMembers(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance)) " is 145.
Long Statement,NUnit.Core.Builders,DatapointProvider,C:\repos\nunit_nunitv2\src\NUnitCore\core\Builders\DatapointProvider.cs,GetDataFor,The length of the statement  "            foreach (MemberInfo member in fixtureType.GetMembers(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance)) " is 145.
Long Statement,NUnit.Core.Builders,NUnitTestCaseBuilder,C:\repos\nunit_nunitv2\src\NUnitCore\core\Builders\NUnitTestCaseBuilder.cs,BuildParameterizedMethodSuite,The length of the statement  "                if (parentSuite.RunState == RunState.Ignored && methodSuite.RunState != RunState.Ignored && methodSuite.RunState != RunState.NotRunnable) " is 137.
Long Statement,NUnit.Core.Builders,NUnitTestCaseBuilder,C:\repos\nunit_nunitv2\src\NUnitCore\core\Builders\NUnitTestCaseBuilder.cs,BuildSingleTestMethod,The length of the statement  "                if (parentSuite.RunState == RunState.Ignored && testMethod.RunState != RunState.Ignored && testMethod.RunState != RunState.NotRunnable) " is 135.
Long Statement,NUnit.Core.Builders,NUnitTestCaseBuilder,C:\repos\nunit_nunitv2\src\NUnitCore\core\Builders\NUnitTestCaseBuilder.cs,CheckTestMethodSignature,The length of the statement  "			bool hasMeaningfulReturnType = isAsyncMethod ? testMethod.Method.ReturnType.IsGenericType : testMethod.Method.ReturnType != typeof(void); " is 137.
Long Statement,NUnit.Core.Builders,TestAssemblyBuilder,C:\repos\nunit_nunitv2\src\NUnitCore\core\Builders\TestAssemblyBuilder.cs,GetCandidateFixtureTypes,The length of the statement  "                    string msg = string.Format("Skipped loading assembly {0} because it references an unsupported version of the nunit.framework' {1}"' " is 131.
Complex Conditional,NUnit.Core,NUnitFramework,C:\repos\nunit_nunitv2\src\NUnitCore\core\NUnitFramework.cs,CheckSetUpTearDownMethods,The conditional expression  "theMethod.IsAbstract ||                       !theMethod.IsPublic && !theMethod.IsFamily ||                       theMethod.GetParameters().Length > 0 ||                       !theMethod.ReturnType.Equals(typeof(void))"  is complex.
Complex Conditional,NUnit.Core,TestSuite,C:\repos\nunit_nunitv2\src\NUnitCore\core\TestSuite.cs,RunAllTests,The conditional expression  "(result.IsError || result.IsFailure || result.ResultState == ResultState.NotRunnable) && stopOnError"  is complex.
Complex Conditional,NUnit.Core.Builders,NUnitTestCaseBuilder,C:\repos\nunit_nunitv2\src\NUnitCore\core\Builders\NUnitTestCaseBuilder.cs,CheckTestMethodSignature,The conditional expression  "hasMeaningfulReturnType && (parms == null || !parms.HasExpectedResult && parms.ExpectedExceptionName == null)"  is complex.
Empty Catch Block,NUnit.Core,Log4NetCapture,C:\repos\nunit_nunitv2\src\NUnitCore\core\Log4NetCapture.cs,InitializeTypes,The method has an empty catch block.
Empty Catch Block,NUnit.Core.Builders,NUnitTestCaseBuilder,C:\repos\nunit_nunitv2\src\NUnitCore\core\Builders\NUnitTestCaseBuilder.cs,CheckTestMethodSignature,The method has an empty catch block.
Magic Number,NUnit.Core,AssemblyReader,C:\repos\nunit_nunitv2\src\NUnitCore\core\AssemblyReader.cs,CalcHeaderOffsets,The following statement contains a magic number: if ( dos_magic == 0x5a4d )  			{  				fs.Position = 0x3c;  				peHeader = rdr.ReadUInt32();  				fileHeader = peHeader + 4;  				optionalHeader = fileHeader + 20;                    fs.Position = optionalHeader;                  peType = rdr.ReadUInt16();                    dataDirectory = peType == 0x20b                      ? optionalHeader + 112                      : optionalHeader + 96;                    fs.Position = dataDirectory - 4;                  numDataDirectoryEntries = rdr.ReadUInt32();    				fs.Position = peHeader;  				pe_signature = rdr.ReadUInt32();  				rdr.ReadUInt16(); // machine  				numberOfSections = rdr.ReadUInt16();  				fs.Position += 12;  				optionalHeaderSize = rdr.ReadUInt16();  				dataSections = optionalHeader + optionalHeaderSize;    				sections = new DataSection[numberOfSections];  				fs.Position = dataSections;  				for( int i = 0; i < numberOfSections; i++ )  				{  					fs.Position += 8;  					sections[i].virtualSize = rdr.ReadUInt32();  					sections[i].virtualAddress = rdr.ReadUInt32();  					uint rawDataSize = rdr.ReadUInt32();  					sections[i].fileOffset = rdr.ReadUInt32();  					if ( sections[i].virtualSize == 0 )  						sections[i].virtualSize = rawDataSize;    					fs.Position += 16;  				}  			}
Magic Number,NUnit.Core,AssemblyReader,C:\repos\nunit_nunitv2\src\NUnitCore\core\AssemblyReader.cs,CalcHeaderOffsets,The following statement contains a magic number: if ( dos_magic == 0x5a4d )  			{  				fs.Position = 0x3c;  				peHeader = rdr.ReadUInt32();  				fileHeader = peHeader + 4;  				optionalHeader = fileHeader + 20;                    fs.Position = optionalHeader;                  peType = rdr.ReadUInt16();                    dataDirectory = peType == 0x20b                      ? optionalHeader + 112                      : optionalHeader + 96;                    fs.Position = dataDirectory - 4;                  numDataDirectoryEntries = rdr.ReadUInt32();    				fs.Position = peHeader;  				pe_signature = rdr.ReadUInt32();  				rdr.ReadUInt16(); // machine  				numberOfSections = rdr.ReadUInt16();  				fs.Position += 12;  				optionalHeaderSize = rdr.ReadUInt16();  				dataSections = optionalHeader + optionalHeaderSize;    				sections = new DataSection[numberOfSections];  				fs.Position = dataSections;  				for( int i = 0; i < numberOfSections; i++ )  				{  					fs.Position += 8;  					sections[i].virtualSize = rdr.ReadUInt32();  					sections[i].virtualAddress = rdr.ReadUInt32();  					uint rawDataSize = rdr.ReadUInt32();  					sections[i].fileOffset = rdr.ReadUInt32();  					if ( sections[i].virtualSize == 0 )  						sections[i].virtualSize = rawDataSize;    					fs.Position += 16;  				}  			}
Magic Number,NUnit.Core,AssemblyReader,C:\repos\nunit_nunitv2\src\NUnitCore\core\AssemblyReader.cs,CalcHeaderOffsets,The following statement contains a magic number: if ( dos_magic == 0x5a4d )  			{  				fs.Position = 0x3c;  				peHeader = rdr.ReadUInt32();  				fileHeader = peHeader + 4;  				optionalHeader = fileHeader + 20;                    fs.Position = optionalHeader;                  peType = rdr.ReadUInt16();                    dataDirectory = peType == 0x20b                      ? optionalHeader + 112                      : optionalHeader + 96;                    fs.Position = dataDirectory - 4;                  numDataDirectoryEntries = rdr.ReadUInt32();    				fs.Position = peHeader;  				pe_signature = rdr.ReadUInt32();  				rdr.ReadUInt16(); // machine  				numberOfSections = rdr.ReadUInt16();  				fs.Position += 12;  				optionalHeaderSize = rdr.ReadUInt16();  				dataSections = optionalHeader + optionalHeaderSize;    				sections = new DataSection[numberOfSections];  				fs.Position = dataSections;  				for( int i = 0; i < numberOfSections; i++ )  				{  					fs.Position += 8;  					sections[i].virtualSize = rdr.ReadUInt32();  					sections[i].virtualAddress = rdr.ReadUInt32();  					uint rawDataSize = rdr.ReadUInt32();  					sections[i].fileOffset = rdr.ReadUInt32();  					if ( sections[i].virtualSize == 0 )  						sections[i].virtualSize = rawDataSize;    					fs.Position += 16;  				}  			}
Magic Number,NUnit.Core,AssemblyReader,C:\repos\nunit_nunitv2\src\NUnitCore\core\AssemblyReader.cs,CalcHeaderOffsets,The following statement contains a magic number: if ( dos_magic == 0x5a4d )  			{  				fs.Position = 0x3c;  				peHeader = rdr.ReadUInt32();  				fileHeader = peHeader + 4;  				optionalHeader = fileHeader + 20;                    fs.Position = optionalHeader;                  peType = rdr.ReadUInt16();                    dataDirectory = peType == 0x20b                      ? optionalHeader + 112                      : optionalHeader + 96;                    fs.Position = dataDirectory - 4;                  numDataDirectoryEntries = rdr.ReadUInt32();    				fs.Position = peHeader;  				pe_signature = rdr.ReadUInt32();  				rdr.ReadUInt16(); // machine  				numberOfSections = rdr.ReadUInt16();  				fs.Position += 12;  				optionalHeaderSize = rdr.ReadUInt16();  				dataSections = optionalHeader + optionalHeaderSize;    				sections = new DataSection[numberOfSections];  				fs.Position = dataSections;  				for( int i = 0; i < numberOfSections; i++ )  				{  					fs.Position += 8;  					sections[i].virtualSize = rdr.ReadUInt32();  					sections[i].virtualAddress = rdr.ReadUInt32();  					uint rawDataSize = rdr.ReadUInt32();  					sections[i].fileOffset = rdr.ReadUInt32();  					if ( sections[i].virtualSize == 0 )  						sections[i].virtualSize = rawDataSize;    					fs.Position += 16;  				}  			}
Magic Number,NUnit.Core,AssemblyReader,C:\repos\nunit_nunitv2\src\NUnitCore\core\AssemblyReader.cs,CalcHeaderOffsets,The following statement contains a magic number: if ( dos_magic == 0x5a4d )  			{  				fs.Position = 0x3c;  				peHeader = rdr.ReadUInt32();  				fileHeader = peHeader + 4;  				optionalHeader = fileHeader + 20;                    fs.Position = optionalHeader;                  peType = rdr.ReadUInt16();                    dataDirectory = peType == 0x20b                      ? optionalHeader + 112                      : optionalHeader + 96;                    fs.Position = dataDirectory - 4;                  numDataDirectoryEntries = rdr.ReadUInt32();    				fs.Position = peHeader;  				pe_signature = rdr.ReadUInt32();  				rdr.ReadUInt16(); // machine  				numberOfSections = rdr.ReadUInt16();  				fs.Position += 12;  				optionalHeaderSize = rdr.ReadUInt16();  				dataSections = optionalHeader + optionalHeaderSize;    				sections = new DataSection[numberOfSections];  				fs.Position = dataSections;  				for( int i = 0; i < numberOfSections; i++ )  				{  					fs.Position += 8;  					sections[i].virtualSize = rdr.ReadUInt32();  					sections[i].virtualAddress = rdr.ReadUInt32();  					uint rawDataSize = rdr.ReadUInt32();  					sections[i].fileOffset = rdr.ReadUInt32();  					if ( sections[i].virtualSize == 0 )  						sections[i].virtualSize = rawDataSize;    					fs.Position += 16;  				}  			}
Magic Number,NUnit.Core,AssemblyReader,C:\repos\nunit_nunitv2\src\NUnitCore\core\AssemblyReader.cs,CalcHeaderOffsets,The following statement contains a magic number: if ( dos_magic == 0x5a4d )  			{  				fs.Position = 0x3c;  				peHeader = rdr.ReadUInt32();  				fileHeader = peHeader + 4;  				optionalHeader = fileHeader + 20;                    fs.Position = optionalHeader;                  peType = rdr.ReadUInt16();                    dataDirectory = peType == 0x20b                      ? optionalHeader + 112                      : optionalHeader + 96;                    fs.Position = dataDirectory - 4;                  numDataDirectoryEntries = rdr.ReadUInt32();    				fs.Position = peHeader;  				pe_signature = rdr.ReadUInt32();  				rdr.ReadUInt16(); // machine  				numberOfSections = rdr.ReadUInt16();  				fs.Position += 12;  				optionalHeaderSize = rdr.ReadUInt16();  				dataSections = optionalHeader + optionalHeaderSize;    				sections = new DataSection[numberOfSections];  				fs.Position = dataSections;  				for( int i = 0; i < numberOfSections; i++ )  				{  					fs.Position += 8;  					sections[i].virtualSize = rdr.ReadUInt32();  					sections[i].virtualAddress = rdr.ReadUInt32();  					uint rawDataSize = rdr.ReadUInt32();  					sections[i].fileOffset = rdr.ReadUInt32();  					if ( sections[i].virtualSize == 0 )  						sections[i].virtualSize = rawDataSize;    					fs.Position += 16;  				}  			}
Magic Number,NUnit.Core,AssemblyReader,C:\repos\nunit_nunitv2\src\NUnitCore\core\AssemblyReader.cs,CalcHeaderOffsets,The following statement contains a magic number: if ( dos_magic == 0x5a4d )  			{  				fs.Position = 0x3c;  				peHeader = rdr.ReadUInt32();  				fileHeader = peHeader + 4;  				optionalHeader = fileHeader + 20;                    fs.Position = optionalHeader;                  peType = rdr.ReadUInt16();                    dataDirectory = peType == 0x20b                      ? optionalHeader + 112                      : optionalHeader + 96;                    fs.Position = dataDirectory - 4;                  numDataDirectoryEntries = rdr.ReadUInt32();    				fs.Position = peHeader;  				pe_signature = rdr.ReadUInt32();  				rdr.ReadUInt16(); // machine  				numberOfSections = rdr.ReadUInt16();  				fs.Position += 12;  				optionalHeaderSize = rdr.ReadUInt16();  				dataSections = optionalHeader + optionalHeaderSize;    				sections = new DataSection[numberOfSections];  				fs.Position = dataSections;  				for( int i = 0; i < numberOfSections; i++ )  				{  					fs.Position += 8;  					sections[i].virtualSize = rdr.ReadUInt32();  					sections[i].virtualAddress = rdr.ReadUInt32();  					uint rawDataSize = rdr.ReadUInt32();  					sections[i].fileOffset = rdr.ReadUInt32();  					if ( sections[i].virtualSize == 0 )  						sections[i].virtualSize = rawDataSize;    					fs.Position += 16;  				}  			}
Magic Number,NUnit.Core,AssemblyReader,C:\repos\nunit_nunitv2\src\NUnitCore\core\AssemblyReader.cs,CalcHeaderOffsets,The following statement contains a magic number: if ( dos_magic == 0x5a4d )  			{  				fs.Position = 0x3c;  				peHeader = rdr.ReadUInt32();  				fileHeader = peHeader + 4;  				optionalHeader = fileHeader + 20;                    fs.Position = optionalHeader;                  peType = rdr.ReadUInt16();                    dataDirectory = peType == 0x20b                      ? optionalHeader + 112                      : optionalHeader + 96;                    fs.Position = dataDirectory - 4;                  numDataDirectoryEntries = rdr.ReadUInt32();    				fs.Position = peHeader;  				pe_signature = rdr.ReadUInt32();  				rdr.ReadUInt16(); // machine  				numberOfSections = rdr.ReadUInt16();  				fs.Position += 12;  				optionalHeaderSize = rdr.ReadUInt16();  				dataSections = optionalHeader + optionalHeaderSize;    				sections = new DataSection[numberOfSections];  				fs.Position = dataSections;  				for( int i = 0; i < numberOfSections; i++ )  				{  					fs.Position += 8;  					sections[i].virtualSize = rdr.ReadUInt32();  					sections[i].virtualAddress = rdr.ReadUInt32();  					uint rawDataSize = rdr.ReadUInt32();  					sections[i].fileOffset = rdr.ReadUInt32();  					if ( sections[i].virtualSize == 0 )  						sections[i].virtualSize = rawDataSize;    					fs.Position += 16;  				}  			}
Magic Number,NUnit.Core,AssemblyReader,C:\repos\nunit_nunitv2\src\NUnitCore\core\AssemblyReader.cs,DataDirectoryRva,The following statement contains a magic number: fs.Position = dataDirectory + n * 8;
Magic Number,NUnit.Core,MethodHelper,C:\repos\nunit_nunitv2\src\NUnitCore\core\MethodHelper.cs,EscapeControlChar,The following statement contains a magic number: switch (c)              {                  case '\'':                      return "\\\'";                  case '\"':                      return "\\\"";                  case '\\':                      return "\\\\";                  case '\0':                      return "\\0";                  case '\a':                      return "\\a";                  case '\b':                      return "\\b";                  case '\f':                      return "\\f";                  case '\n':                      return "\\n";                  case '\r':                      return "\\r";                  case '\t':                      return "\\t";                  case '\v':                      return "\\v";                    case '\x0085':                  case '\x2028':                  case '\x2029':                      return string.Format("\\x{0:X4}"' (int)c);                    default:                      return char.IsControl(c) || (int)c > 128                          ? string.Format("\\x{0:X4}"' (int)c)                          : c.ToString();              }
Magic Number,NUnit.Core,PlatformHelper,C:\repos\nunit_nunitv2\src\NUnitCore\core\PlatformHelper.cs,IsRuntimeSupported,The following statement contains a magic number: if (parts.Length == 2)              {                  platformName = parts[0];                  versionSpecification = parts[1];              }
Magic Number,NUnit.Core,TestMethod,C:\repos\nunit_nunitv2\src\NUnitCore\core\TestMethod.cs,RunTest,The following statement contains a magic number: try  			{                  RunSetUp();  #if CLR_2_0 || CLR_4_0  			    RunBeforeActions(testResult);  #endif    				RunTestCase( testResult );  			}  			catch(Exception ex)  			{                  // doTestCase handles its own exceptions so                  // if we're here it's a setup exception                  if (ex is ThreadAbortException)                      Thread.ResetAbort();                    RecordException(ex' testResult' FailureSite.SetUp);  			}  			finally   			{  #if CLR_2_0 || CLR_4_0                  RunAfterActions(testResult);  #endif  				RunTearDown( testResult );    				DateTime stop = DateTime.Now;  				TimeSpan span = stop.Subtract(start);  				testResult.Time = (double)span.Ticks / (double)TimeSpan.TicksPerSecond;                    if (testResult.IsSuccess)  				{  					if (this.Properties.Contains("MaxTime"))                  	{                      int elapsedTime = (int)Math.Round(testResult.Time * 1000.0);                      int maxTime = (int)this.Properties["MaxTime"];                        if (maxTime > 0 && elapsedTime > maxTime)                          testResult.Failure(                              string.Format("Elapsed time of {0}ms exceeds maximum of {1}ms"'                                  elapsedTime' maxTime)'                              null);  					}  					  					if (testResult.IsSuccess && testResult.Message == null &&   					    Environment.CurrentDirectory != TestExecutionContext.CurrentContext.prior.CurrentDirectory)  					{  						// TODO: Introduce a warning result state in NUnit 3.0  						testResult.SetResult(ResultState.Success' "Warning: Test changed the CurrentDirectory"' null);  					}  				}  			}
Magic Number,NUnit.Core,TypeHelper,C:\repos\nunit_nunitv2\src\NUnitCore\core\TypeHelper.cs,GetDisplayName,The following statement contains a magic number: if (type.IsGenericType)              {                  string name = type.FullName;                  if (name == null)                      name = type.Name;                    int index = name.IndexOf("[[");                  if (index > 0)                  {                      int index2 = name.LastIndexOf("]]");                      if (index2 > index)                          name = name.Substring(0' index) + name.Substring(index2 + 2);                  }                    index = name.LastIndexOf('.');                  if (index >= 0) name = name.Substring(index + 1);                    index = name.IndexOf('`');                  while (index >= 0)                  {                      int index2 = name.IndexOf('+'' index);                      if (index2 >= 0)                          name = name.Substring(0' index) + name.Substring(index2);                      else                          name = name.Substring(0' index);                        index = name.IndexOf('`');                  }                    StringBuilder sb = new StringBuilder(name);                    sb.Append("<");                  int cnt = 0;                  foreach (Type t in type.GetGenericArguments())                  {                      if (cnt++ > 0) sb.Append("'");                      sb.Append(GetDisplayName(t));                  }                  sb.Append(">");                    return sb.ToString();              }
Magic Number,NUnit.Core.Builders,CombinatorialTestCaseProvider,C:\repos\nunit_nunitv2\src\NUnitCore\core\Builders\CombinatorialTestCaseProvider.cs,GetStrategy,The following statement contains a magic number: if (Reflect.HasAttribute(method' PairwiseAttribute' false) &&                  method.GetParameters().Length > 2)                      return new PairwiseStrategy(sources);
Magic Number,NUnit.Core.Builders,FleaRand,C:\repos\nunit_nunitv2\src\NUnitCore\core\Builders\PairwiseStrategy.cs,FleaRand,The following statement contains a magic number: for (int i = 0; i < 10; i++)  				{  					this.Batch();  				}
Magic Number,NUnit.Core.Builders,FleaRand,C:\repos\nunit_nunitv2\src\NUnitCore\core\Builders\PairwiseStrategy.cs,Batch,The following statement contains a magic number: for (int i = 0; i < this.r.Length; i++)  				{  					a = this.m[b % this.m.Length];  					this.m[b % this.m.Length] = d;  					d = (c << 19) + (c >> 13) + b;  					c = b ^ this.m[i];  					b = a + d;  					this.r[i] = c;  				}
Magic Number,NUnit.Core.Builders,FleaRand,C:\repos\nunit_nunitv2\src\NUnitCore\core\Builders\PairwiseStrategy.cs,Batch,The following statement contains a magic number: for (int i = 0; i < this.r.Length; i++)  				{  					a = this.m[b % this.m.Length];  					this.m[b % this.m.Length] = d;  					d = (c << 19) + (c >> 13) + b;  					c = b ^ this.m[i];  					b = a + d;  					this.r[i] = c;  				}
Magic Number,NUnit.Core.Builders,PairwiseTestCaseGenerator,C:\repos\nunit_nunitv2\src\NUnitCore\core\Builders\PairwiseStrategy.cs,FindGoodTestCase,The following statement contains a magic number: for (int i = 0; i < 5; i++)  				{  					TestCase test = new TestCase(this.dimensions.Length);    					int coverage = this.CreateTestCase(tuple' test);    					if (coverage > bestCoverage)  					{  						bestTest = test;  						bestCoverage = coverage;  					}  				}
Magic Number,NUnit.Core.Builders,TestAssemblyBuilder,C:\repos\nunit_nunitv2\src\NUnitCore\core\Builders\TestAssemblyBuilder.cs,GetCandidateFixtureTypes,The following statement contains a magic number: foreach(AssemblyName an in assembly.GetReferencedAssemblies())              {                  if((an.Name == "nunit.framework") && an.Version.Major > 2)                  {                      string msg = string.Format("Skipped loading assembly {0} because it references an unsupported version of the nunit.framework' {1}"'                          assembly.GetName().Name' an.Version);                      log.Warning(msg);                      throw new UnsupportedFrameworkException(msg);                  }              }
Missing Default,NUnit.Core.Builders,DatapointProvider,C:\repos\nunit_nunitv2\src\NUnitCore\core\Builders\DatapointProvider.cs,GetDataFor,The following switch statement is missing a default case: switch(member.MemberType)                          {                              case MemberTypes.Field:                                  FieldInfo field = member as FieldInfo;                                  instance = field.IsStatic ? null : ProviderCache.GetInstanceOf(fixtureType);                                  foreach (object data in (IEnumerable)field.GetValue(instance))                                      datapoints.Add(data);                                  break;                              case MemberTypes.Property:                                  PropertyInfo property = member as PropertyInfo;                                  MethodInfo getMethod = property.GetGetMethod(true);                                  instance = getMethod.IsStatic ? null : ProviderCache.GetInstanceOf(fixtureType);                                  foreach (object data in (IEnumerable)property.GetValue(instance' null))                                      datapoints.Add(data);                                  break;                              case MemberTypes.Method:                                  MethodInfo method = member as MethodInfo;                                  instance = method.IsStatic ? null : ProviderCache.GetInstanceOf(fixtureType);                                  foreach (object data in (IEnumerable)method.Invoke(instance' Type.EmptyTypes))                                      datapoints.Add(data);                                  break;                          }
Missing Default,NUnit.Core.Builders,ProviderReference,C:\repos\nunit_nunitv2\src\NUnitCore\core\Builders\ProviderInfo.cs,GetProviderObjectFromMember,The following switch statement is missing a default case: switch (member.MemberType)              {                  case MemberTypes.Property:                      PropertyInfo providerProperty = member as PropertyInfo;                      MethodInfo getMethod = providerProperty.GetGetMethod(true);                      if (!getMethod.IsStatic)                          //instance = ProviderCache.GetInstanceOf(providerType);                          instance = Reflect.Construct(providerType' providerArgs);                      providerObject = providerProperty.GetValue(instance' null);                      break;                    case MemberTypes.Method:                      MethodInfo providerMethod = member as MethodInfo;                      if (!providerMethod.IsStatic)                          //instance = ProviderCache.GetInstanceOf(providerType);                          instance = Reflect.Construct(providerType' providerArgs);                      providerObject = providerMethod.Invoke(instance' null);                      break;                    case MemberTypes.Field:                      FieldInfo providerField = member as FieldInfo;                      if (!providerField.IsStatic)                          //instance = ProviderCache.GetInstanceOf(providerType);                          instance = Reflect.Construct(providerType' providerArgs);                      providerObject = providerField.GetValue(instance);                      break;              }
