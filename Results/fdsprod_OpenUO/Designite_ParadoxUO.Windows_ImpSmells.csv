Implementation smell,Namespace,Class,File,Method,Description
Long Method,ParadoxUO.Net,NetworkClient,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Net\NetworkClient.cs,OnReceive,The method has 151 lines of code.
Complex Method,ParadoxUO.Net,NetworkClient,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Net\NetworkClient.cs,OnReceive,Cyclomatic complexity of the method is 15
Long Parameter List,ParadoxUO.Net,NetworkClient,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Net\NetworkClient.cs,RegisterExtended,The method has 5 parameters. Parameters: extendedId' subId' name' length' onReceive
Long Statement,ParadoxUO.Net,NetworkClient,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Net\NetworkClient.cs,Register,The length of the statement  "                throw new NetworkException(string.Format("Unable to register packet type {0} without a public constructor with a {1} parameter"' type' typeof (PacketReader))); " is 159.
Long Statement,ParadoxUO.Net,NetworkClient,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Net\NetworkClient.cs,Register,The length of the statement  "                throw new NetworkException(string.Format("Unable to register packet id {0:X2} because it is greater than byte.MaxValue"' id)); " is 126.
Long Statement,ParadoxUO.Net,NetworkClient,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Net\NetworkClient.cs,RegisterExtended,The length of the statement  "                throw new NetworkException(string.Format("Unable to register packet type {0} without a public constructor with a {1} parameter"' type' typeof (PacketReader))); " is 159.
Long Statement,ParadoxUO.Net,NetworkClient,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Net\NetworkClient.cs,RegisterExtended,The length of the statement  "                throw new NetworkException(string.Format("Unable to register packet extendedId {0:X2} because it is greater than byte.MaxValue"' extendedId)); " is 142.
Long Statement,ParadoxUO.Net,NetworkClient,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Net\NetworkClient.cs,RegisterExtended,The length of the statement  "                throw new NetworkException(string.Format("Unable to register packet subId {0:X2} because it is greater than byte.MaxValue"' subId)); " is 132.
Long Statement,ParadoxUO.Net,NetworkClient,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Net\NetworkClient.cs,RegisterExtended,The length of the statement  "            Tracer.Debug("Registering Extended Command: Id: 0x{0:X2} SubCommand: 0x{1:X2} Name: {2} Length: {3}"' extendedId' subId' name' length); " is 135.
Long Statement,ParadoxUO.Net,NetworkClient,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Net\NetworkClient.cs,InvokeHandlers,The length of the statement  "                    Tracer.Error(e' "An error occurred while handling a packet for Packet { Id: {0}' Name: {1} }."' handler.Id' handler.Name); " is 122.
Empty Catch Block,ParadoxUO.Net,NetworkClient,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Net\NetworkClient.cs,Disconnect,The method has an empty catch block.
Magic Number,OpenUO.Core.Configuration,GameSettings,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Configuration\GameSettings.cs,GameSettings,The following statement contains a magic number: Resolution = new Resolution(1024' 768);
Magic Number,OpenUO.Core.Configuration,GameSettings,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Configuration\GameSettings.cs,GameSettings,The following statement contains a magic number: Resolution = new Resolution(1024' 768);
Magic Number,OpenUO.Core.Configuration,GameSettings,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Configuration\GameSettings.cs,GameSettings,The following statement contains a magic number: GameResolution = new Resolution(800' 600);
Magic Number,OpenUO.Core.Configuration,GameSettings,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Configuration\GameSettings.cs,GameSettings,The following statement contains a magic number: GameResolution = new Resolution(800' 600);
Magic Number,OpenUO.Core.Configuration,ServerSettings,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Configuration\ServerSettings.cs,ServerSettings,The following statement contains a magic number: ServerPort = 2593;
Magic Number,ParadoxUO.Net,NetworkClient,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Net\NetworkClient.cs,Connect,The following statement contains a magic number: try              {                  if (!IPAddress.TryParse(ipAddressOrHostName' out _serverAddress))                  {                      var ipAddresses = Dns.GetHostAddresses(ipAddressOrHostName);                        if (ipAddresses.Length == 0)                      {                          throw new NetworkException("Host address was unreachable or invalid' unable to obtain an ip address.");                      }                        // On Vista and later' the first ip address is an empty one '::1'.                      // This makes sure we choose the first valid ip address.                      foreach (var address in ipAddresses)                      {                          if (address.ToString().Length > 7)                          {                              _serverAddress = address;                              break;                          }                      }                  }                    _serverEndPoint = new IPEndPoint(_serverAddress' port);                    Tracer.Debug("Connecting...");                    _serverSocket = new Socket(AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp);                  _serverSocket.Connect(_serverEndPoint);                    if (_serverSocket.Connected)                  {                      Tracer.Debug("Connected.");                        var state = new SocketState(_serverSocket' ushort.MaxValue);                      _serverSocket.BeginReceive(state.Buffer' 0' state.Buffer.Length' SocketFlags.None' OnReceive' state);                  }              }              catch              {                  success = false;              }
Magic Number,ParadoxUO.Net,NetworkClient,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Net\NetworkClient.cs,OnReceive,The following statement contains a magic number: try              {                  var socket = state.Socket;                  if (socket.Connected == false)                  {                      Disconnect();                      return;                  }                  var length = socket.EndReceive(result);                    if (length > 0)                  {                      var buffer = state.Buffer;                        if (_receiveBuffer == null)                      {                          _receiveBuffer = new byte[0x10000];                      }                        if (IsDecompressionEnabled)                      {                          var outsize = 0;                          byte[] data;                            if (_appendNextMessage)                          {                              _appendNextMessage = false;                              data = new byte[_appendData.Length + length];                                Buffer.BlockCopy(_appendData' 0' data' 0' _appendData.Length);                              Buffer.BlockCopy(buffer' 0' data' _appendData.Length' length);                          }                          else                          {                              data = new byte[length];                              Buffer.BlockCopy(buffer' 0' data' 0' length);                          }                            while (_decompression.DecompressOnePacket(ref data' data.Length' ref _receiveBuffer' ref outsize))                          {                              int realLength;                              var subId = _receiveBuffer.Length >= 5 ? (short) (_receiveBuffer[4] | (_receiveBuffer[3] << 8)) : (short) -1;                              var packetHandlers = GetHandlers(_receiveBuffer[0]);                              List<PacketHandler> extendedHandlers = null;                                if (_receiveBuffer.Length >= 5)                              {                                  extendedHandlers = GetExtendedHandlers(_receiveBuffer[0]' subId);                              }                                if (packetHandlers.Count == 0 && (extendedHandlers == null || extendedHandlers.Count == 0))                              {                                  if (subId != -1)                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}' possible subid: 0x{1:x2}"' _receiveBuffer[0]' subId);                                  }                                  else                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}"' _receiveBuffer[0]);                                  }                                    _receiveBufferPosition = 0;                                  break;                              }                                var isExtendedHandler = packetHandlers.Count == 0;                                if (extendedHandlers != null)                              {                                  packetHandlers.AddRange(extendedHandlers);                              }                                GetPacketSize(packetHandlers' out realLength);                                if (realLength != outsize)                              {                                  throw new Exception("Bad packet size!");                              }                                var name = packetHandlers[0].Name;                              var packetBuffer = new byte[realLength];                                Buffer.BlockCopy(_receiveBuffer' isExtendedHandler ? 5 : 0' packetBuffer' 0' realLength);                                AddPacket(name' packetHandlers' packetBuffer' realLength);                          }                            // We've run out of data to parse' or the packet was incomplete. If the packet was incomplete'                          // we should save what's left for socket receive event.                          if (data.Length > 0)                          {                              _appendNextMessage = true;                              _appendData = data;                          }                      }                      else                      {                          Buffer.BlockCopy(buffer' 0' _receiveBuffer' _receiveBufferPosition' length);                            _receiveBufferPosition += length;                            var currentIndex = 0;                            while (currentIndex < _receiveBufferPosition)                          {                              int realLength;                              var subId = _receiveBuffer.Length >= 5 ? (short) (_receiveBuffer[4] | (_receiveBuffer[3] << 8)) : (short) -1;                              var packetHandlers = GetHandlers(_receiveBuffer[0]);                              List<PacketHandler> extendedHandlers = null;                                if (_receiveBuffer.Length >= 5)                              {                                  extendedHandlers = GetExtendedHandlers(_receiveBuffer[0]' subId);                              }                                if (packetHandlers.Count == 0 && extendedHandlers == null)                              {                                  if (subId != -1)                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}' possible subid: 0x{1:x2}"' _receiveBuffer[0]' subId);                                  }                                  else                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}"' _receiveBuffer[0]);                                  }                                    _receiveBufferPosition = 0;                                  break;                              }                                var isExtendedHandler = packetHandlers.Count == 0;                                if (extendedHandlers != null)                              {                                  packetHandlers.AddRange(extendedHandlers);                              }                                GetPacketSize(packetHandlers' out realLength);                                if ((_receiveBufferPosition - currentIndex) >= realLength)                              {                                  var name = packetHandlers[0].Name;                                  var packetBuffer = new byte[realLength];                                    Buffer.BlockCopy(_receiveBuffer' currentIndex + (isExtendedHandler ? 4 : 0)' packetBuffer' 0' realLength);                                    AddPacket(name' packetHandlers' packetBuffer' realLength);                                    currentIndex += realLength;                              }                              else                              {                                  //Need more data                                  break;                              }                          }                            _receiveBufferPosition -= currentIndex;                            if (_receiveBufferPosition > 0)                          {                              Buffer.BlockCopy(_receiveBuffer' currentIndex' _receiveBuffer' 0' _receiveBufferPosition);                          }                      }                  }                    if (_serverSocket != null)                  {                      _serverSocket.BeginReceive(state.Buffer' 0' state.Buffer.Length' SocketFlags.None' OnReceive' state);                  }              }              catch (Exception e)              {                  Tracer.Debug(e.ToString());                  Disconnect();              }
Magic Number,ParadoxUO.Net,NetworkClient,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Net\NetworkClient.cs,OnReceive,The following statement contains a magic number: try              {                  var socket = state.Socket;                  if (socket.Connected == false)                  {                      Disconnect();                      return;                  }                  var length = socket.EndReceive(result);                    if (length > 0)                  {                      var buffer = state.Buffer;                        if (_receiveBuffer == null)                      {                          _receiveBuffer = new byte[0x10000];                      }                        if (IsDecompressionEnabled)                      {                          var outsize = 0;                          byte[] data;                            if (_appendNextMessage)                          {                              _appendNextMessage = false;                              data = new byte[_appendData.Length + length];                                Buffer.BlockCopy(_appendData' 0' data' 0' _appendData.Length);                              Buffer.BlockCopy(buffer' 0' data' _appendData.Length' length);                          }                          else                          {                              data = new byte[length];                              Buffer.BlockCopy(buffer' 0' data' 0' length);                          }                            while (_decompression.DecompressOnePacket(ref data' data.Length' ref _receiveBuffer' ref outsize))                          {                              int realLength;                              var subId = _receiveBuffer.Length >= 5 ? (short) (_receiveBuffer[4] | (_receiveBuffer[3] << 8)) : (short) -1;                              var packetHandlers = GetHandlers(_receiveBuffer[0]);                              List<PacketHandler> extendedHandlers = null;                                if (_receiveBuffer.Length >= 5)                              {                                  extendedHandlers = GetExtendedHandlers(_receiveBuffer[0]' subId);                              }                                if (packetHandlers.Count == 0 && (extendedHandlers == null || extendedHandlers.Count == 0))                              {                                  if (subId != -1)                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}' possible subid: 0x{1:x2}"' _receiveBuffer[0]' subId);                                  }                                  else                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}"' _receiveBuffer[0]);                                  }                                    _receiveBufferPosition = 0;                                  break;                              }                                var isExtendedHandler = packetHandlers.Count == 0;                                if (extendedHandlers != null)                              {                                  packetHandlers.AddRange(extendedHandlers);                              }                                GetPacketSize(packetHandlers' out realLength);                                if (realLength != outsize)                              {                                  throw new Exception("Bad packet size!");                              }                                var name = packetHandlers[0].Name;                              var packetBuffer = new byte[realLength];                                Buffer.BlockCopy(_receiveBuffer' isExtendedHandler ? 5 : 0' packetBuffer' 0' realLength);                                AddPacket(name' packetHandlers' packetBuffer' realLength);                          }                            // We've run out of data to parse' or the packet was incomplete. If the packet was incomplete'                          // we should save what's left for socket receive event.                          if (data.Length > 0)                          {                              _appendNextMessage = true;                              _appendData = data;                          }                      }                      else                      {                          Buffer.BlockCopy(buffer' 0' _receiveBuffer' _receiveBufferPosition' length);                            _receiveBufferPosition += length;                            var currentIndex = 0;                            while (currentIndex < _receiveBufferPosition)                          {                              int realLength;                              var subId = _receiveBuffer.Length >= 5 ? (short) (_receiveBuffer[4] | (_receiveBuffer[3] << 8)) : (short) -1;                              var packetHandlers = GetHandlers(_receiveBuffer[0]);                              List<PacketHandler> extendedHandlers = null;                                if (_receiveBuffer.Length >= 5)                              {                                  extendedHandlers = GetExtendedHandlers(_receiveBuffer[0]' subId);                              }                                if (packetHandlers.Count == 0 && extendedHandlers == null)                              {                                  if (subId != -1)                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}' possible subid: 0x{1:x2}"' _receiveBuffer[0]' subId);                                  }                                  else                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}"' _receiveBuffer[0]);                                  }                                    _receiveBufferPosition = 0;                                  break;                              }                                var isExtendedHandler = packetHandlers.Count == 0;                                if (extendedHandlers != null)                              {                                  packetHandlers.AddRange(extendedHandlers);                              }                                GetPacketSize(packetHandlers' out realLength);                                if ((_receiveBufferPosition - currentIndex) >= realLength)                              {                                  var name = packetHandlers[0].Name;                                  var packetBuffer = new byte[realLength];                                    Buffer.BlockCopy(_receiveBuffer' currentIndex + (isExtendedHandler ? 4 : 0)' packetBuffer' 0' realLength);                                    AddPacket(name' packetHandlers' packetBuffer' realLength);                                    currentIndex += realLength;                              }                              else                              {                                  //Need more data                                  break;                              }                          }                            _receiveBufferPosition -= currentIndex;                            if (_receiveBufferPosition > 0)                          {                              Buffer.BlockCopy(_receiveBuffer' currentIndex' _receiveBuffer' 0' _receiveBufferPosition);                          }                      }                  }                    if (_serverSocket != null)                  {                      _serverSocket.BeginReceive(state.Buffer' 0' state.Buffer.Length' SocketFlags.None' OnReceive' state);                  }              }              catch (Exception e)              {                  Tracer.Debug(e.ToString());                  Disconnect();              }
Magic Number,ParadoxUO.Net,NetworkClient,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Net\NetworkClient.cs,OnReceive,The following statement contains a magic number: try              {                  var socket = state.Socket;                  if (socket.Connected == false)                  {                      Disconnect();                      return;                  }                  var length = socket.EndReceive(result);                    if (length > 0)                  {                      var buffer = state.Buffer;                        if (_receiveBuffer == null)                      {                          _receiveBuffer = new byte[0x10000];                      }                        if (IsDecompressionEnabled)                      {                          var outsize = 0;                          byte[] data;                            if (_appendNextMessage)                          {                              _appendNextMessage = false;                              data = new byte[_appendData.Length + length];                                Buffer.BlockCopy(_appendData' 0' data' 0' _appendData.Length);                              Buffer.BlockCopy(buffer' 0' data' _appendData.Length' length);                          }                          else                          {                              data = new byte[length];                              Buffer.BlockCopy(buffer' 0' data' 0' length);                          }                            while (_decompression.DecompressOnePacket(ref data' data.Length' ref _receiveBuffer' ref outsize))                          {                              int realLength;                              var subId = _receiveBuffer.Length >= 5 ? (short) (_receiveBuffer[4] | (_receiveBuffer[3] << 8)) : (short) -1;                              var packetHandlers = GetHandlers(_receiveBuffer[0]);                              List<PacketHandler> extendedHandlers = null;                                if (_receiveBuffer.Length >= 5)                              {                                  extendedHandlers = GetExtendedHandlers(_receiveBuffer[0]' subId);                              }                                if (packetHandlers.Count == 0 && (extendedHandlers == null || extendedHandlers.Count == 0))                              {                                  if (subId != -1)                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}' possible subid: 0x{1:x2}"' _receiveBuffer[0]' subId);                                  }                                  else                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}"' _receiveBuffer[0]);                                  }                                    _receiveBufferPosition = 0;                                  break;                              }                                var isExtendedHandler = packetHandlers.Count == 0;                                if (extendedHandlers != null)                              {                                  packetHandlers.AddRange(extendedHandlers);                              }                                GetPacketSize(packetHandlers' out realLength);                                if (realLength != outsize)                              {                                  throw new Exception("Bad packet size!");                              }                                var name = packetHandlers[0].Name;                              var packetBuffer = new byte[realLength];                                Buffer.BlockCopy(_receiveBuffer' isExtendedHandler ? 5 : 0' packetBuffer' 0' realLength);                                AddPacket(name' packetHandlers' packetBuffer' realLength);                          }                            // We've run out of data to parse' or the packet was incomplete. If the packet was incomplete'                          // we should save what's left for socket receive event.                          if (data.Length > 0)                          {                              _appendNextMessage = true;                              _appendData = data;                          }                      }                      else                      {                          Buffer.BlockCopy(buffer' 0' _receiveBuffer' _receiveBufferPosition' length);                            _receiveBufferPosition += length;                            var currentIndex = 0;                            while (currentIndex < _receiveBufferPosition)                          {                              int realLength;                              var subId = _receiveBuffer.Length >= 5 ? (short) (_receiveBuffer[4] | (_receiveBuffer[3] << 8)) : (short) -1;                              var packetHandlers = GetHandlers(_receiveBuffer[0]);                              List<PacketHandler> extendedHandlers = null;                                if (_receiveBuffer.Length >= 5)                              {                                  extendedHandlers = GetExtendedHandlers(_receiveBuffer[0]' subId);                              }                                if (packetHandlers.Count == 0 && extendedHandlers == null)                              {                                  if (subId != -1)                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}' possible subid: 0x{1:x2}"' _receiveBuffer[0]' subId);                                  }                                  else                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}"' _receiveBuffer[0]);                                  }                                    _receiveBufferPosition = 0;                                  break;                              }                                var isExtendedHandler = packetHandlers.Count == 0;                                if (extendedHandlers != null)                              {                                  packetHandlers.AddRange(extendedHandlers);                              }                                GetPacketSize(packetHandlers' out realLength);                                if ((_receiveBufferPosition - currentIndex) >= realLength)                              {                                  var name = packetHandlers[0].Name;                                  var packetBuffer = new byte[realLength];                                    Buffer.BlockCopy(_receiveBuffer' currentIndex + (isExtendedHandler ? 4 : 0)' packetBuffer' 0' realLength);                                    AddPacket(name' packetHandlers' packetBuffer' realLength);                                    currentIndex += realLength;                              }                              else                              {                                  //Need more data                                  break;                              }                          }                            _receiveBufferPosition -= currentIndex;                            if (_receiveBufferPosition > 0)                          {                              Buffer.BlockCopy(_receiveBuffer' currentIndex' _receiveBuffer' 0' _receiveBufferPosition);                          }                      }                  }                    if (_serverSocket != null)                  {                      _serverSocket.BeginReceive(state.Buffer' 0' state.Buffer.Length' SocketFlags.None' OnReceive' state);                  }              }              catch (Exception e)              {                  Tracer.Debug(e.ToString());                  Disconnect();              }
Magic Number,ParadoxUO.Net,NetworkClient,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Net\NetworkClient.cs,OnReceive,The following statement contains a magic number: try              {                  var socket = state.Socket;                  if (socket.Connected == false)                  {                      Disconnect();                      return;                  }                  var length = socket.EndReceive(result);                    if (length > 0)                  {                      var buffer = state.Buffer;                        if (_receiveBuffer == null)                      {                          _receiveBuffer = new byte[0x10000];                      }                        if (IsDecompressionEnabled)                      {                          var outsize = 0;                          byte[] data;                            if (_appendNextMessage)                          {                              _appendNextMessage = false;                              data = new byte[_appendData.Length + length];                                Buffer.BlockCopy(_appendData' 0' data' 0' _appendData.Length);                              Buffer.BlockCopy(buffer' 0' data' _appendData.Length' length);                          }                          else                          {                              data = new byte[length];                              Buffer.BlockCopy(buffer' 0' data' 0' length);                          }                            while (_decompression.DecompressOnePacket(ref data' data.Length' ref _receiveBuffer' ref outsize))                          {                              int realLength;                              var subId = _receiveBuffer.Length >= 5 ? (short) (_receiveBuffer[4] | (_receiveBuffer[3] << 8)) : (short) -1;                              var packetHandlers = GetHandlers(_receiveBuffer[0]);                              List<PacketHandler> extendedHandlers = null;                                if (_receiveBuffer.Length >= 5)                              {                                  extendedHandlers = GetExtendedHandlers(_receiveBuffer[0]' subId);                              }                                if (packetHandlers.Count == 0 && (extendedHandlers == null || extendedHandlers.Count == 0))                              {                                  if (subId != -1)                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}' possible subid: 0x{1:x2}"' _receiveBuffer[0]' subId);                                  }                                  else                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}"' _receiveBuffer[0]);                                  }                                    _receiveBufferPosition = 0;                                  break;                              }                                var isExtendedHandler = packetHandlers.Count == 0;                                if (extendedHandlers != null)                              {                                  packetHandlers.AddRange(extendedHandlers);                              }                                GetPacketSize(packetHandlers' out realLength);                                if (realLength != outsize)                              {                                  throw new Exception("Bad packet size!");                              }                                var name = packetHandlers[0].Name;                              var packetBuffer = new byte[realLength];                                Buffer.BlockCopy(_receiveBuffer' isExtendedHandler ? 5 : 0' packetBuffer' 0' realLength);                                AddPacket(name' packetHandlers' packetBuffer' realLength);                          }                            // We've run out of data to parse' or the packet was incomplete. If the packet was incomplete'                          // we should save what's left for socket receive event.                          if (data.Length > 0)                          {                              _appendNextMessage = true;                              _appendData = data;                          }                      }                      else                      {                          Buffer.BlockCopy(buffer' 0' _receiveBuffer' _receiveBufferPosition' length);                            _receiveBufferPosition += length;                            var currentIndex = 0;                            while (currentIndex < _receiveBufferPosition)                          {                              int realLength;                              var subId = _receiveBuffer.Length >= 5 ? (short) (_receiveBuffer[4] | (_receiveBuffer[3] << 8)) : (short) -1;                              var packetHandlers = GetHandlers(_receiveBuffer[0]);                              List<PacketHandler> extendedHandlers = null;                                if (_receiveBuffer.Length >= 5)                              {                                  extendedHandlers = GetExtendedHandlers(_receiveBuffer[0]' subId);                              }                                if (packetHandlers.Count == 0 && extendedHandlers == null)                              {                                  if (subId != -1)                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}' possible subid: 0x{1:x2}"' _receiveBuffer[0]' subId);                                  }                                  else                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}"' _receiveBuffer[0]);                                  }                                    _receiveBufferPosition = 0;                                  break;                              }                                var isExtendedHandler = packetHandlers.Count == 0;                                if (extendedHandlers != null)                              {                                  packetHandlers.AddRange(extendedHandlers);                              }                                GetPacketSize(packetHandlers' out realLength);                                if ((_receiveBufferPosition - currentIndex) >= realLength)                              {                                  var name = packetHandlers[0].Name;                                  var packetBuffer = new byte[realLength];                                    Buffer.BlockCopy(_receiveBuffer' currentIndex + (isExtendedHandler ? 4 : 0)' packetBuffer' 0' realLength);                                    AddPacket(name' packetHandlers' packetBuffer' realLength);                                    currentIndex += realLength;                              }                              else                              {                                  //Need more data                                  break;                              }                          }                            _receiveBufferPosition -= currentIndex;                            if (_receiveBufferPosition > 0)                          {                              Buffer.BlockCopy(_receiveBuffer' currentIndex' _receiveBuffer' 0' _receiveBufferPosition);                          }                      }                  }                    if (_serverSocket != null)                  {                      _serverSocket.BeginReceive(state.Buffer' 0' state.Buffer.Length' SocketFlags.None' OnReceive' state);                  }              }              catch (Exception e)              {                  Tracer.Debug(e.ToString());                  Disconnect();              }
Magic Number,ParadoxUO.Net,NetworkClient,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Net\NetworkClient.cs,OnReceive,The following statement contains a magic number: try              {                  var socket = state.Socket;                  if (socket.Connected == false)                  {                      Disconnect();                      return;                  }                  var length = socket.EndReceive(result);                    if (length > 0)                  {                      var buffer = state.Buffer;                        if (_receiveBuffer == null)                      {                          _receiveBuffer = new byte[0x10000];                      }                        if (IsDecompressionEnabled)                      {                          var outsize = 0;                          byte[] data;                            if (_appendNextMessage)                          {                              _appendNextMessage = false;                              data = new byte[_appendData.Length + length];                                Buffer.BlockCopy(_appendData' 0' data' 0' _appendData.Length);                              Buffer.BlockCopy(buffer' 0' data' _appendData.Length' length);                          }                          else                          {                              data = new byte[length];                              Buffer.BlockCopy(buffer' 0' data' 0' length);                          }                            while (_decompression.DecompressOnePacket(ref data' data.Length' ref _receiveBuffer' ref outsize))                          {                              int realLength;                              var subId = _receiveBuffer.Length >= 5 ? (short) (_receiveBuffer[4] | (_receiveBuffer[3] << 8)) : (short) -1;                              var packetHandlers = GetHandlers(_receiveBuffer[0]);                              List<PacketHandler> extendedHandlers = null;                                if (_receiveBuffer.Length >= 5)                              {                                  extendedHandlers = GetExtendedHandlers(_receiveBuffer[0]' subId);                              }                                if (packetHandlers.Count == 0 && (extendedHandlers == null || extendedHandlers.Count == 0))                              {                                  if (subId != -1)                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}' possible subid: 0x{1:x2}"' _receiveBuffer[0]' subId);                                  }                                  else                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}"' _receiveBuffer[0]);                                  }                                    _receiveBufferPosition = 0;                                  break;                              }                                var isExtendedHandler = packetHandlers.Count == 0;                                if (extendedHandlers != null)                              {                                  packetHandlers.AddRange(extendedHandlers);                              }                                GetPacketSize(packetHandlers' out realLength);                                if (realLength != outsize)                              {                                  throw new Exception("Bad packet size!");                              }                                var name = packetHandlers[0].Name;                              var packetBuffer = new byte[realLength];                                Buffer.BlockCopy(_receiveBuffer' isExtendedHandler ? 5 : 0' packetBuffer' 0' realLength);                                AddPacket(name' packetHandlers' packetBuffer' realLength);                          }                            // We've run out of data to parse' or the packet was incomplete. If the packet was incomplete'                          // we should save what's left for socket receive event.                          if (data.Length > 0)                          {                              _appendNextMessage = true;                              _appendData = data;                          }                      }                      else                      {                          Buffer.BlockCopy(buffer' 0' _receiveBuffer' _receiveBufferPosition' length);                            _receiveBufferPosition += length;                            var currentIndex = 0;                            while (currentIndex < _receiveBufferPosition)                          {                              int realLength;                              var subId = _receiveBuffer.Length >= 5 ? (short) (_receiveBuffer[4] | (_receiveBuffer[3] << 8)) : (short) -1;                              var packetHandlers = GetHandlers(_receiveBuffer[0]);                              List<PacketHandler> extendedHandlers = null;                                if (_receiveBuffer.Length >= 5)                              {                                  extendedHandlers = GetExtendedHandlers(_receiveBuffer[0]' subId);                              }                                if (packetHandlers.Count == 0 && extendedHandlers == null)                              {                                  if (subId != -1)                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}' possible subid: 0x{1:x2}"' _receiveBuffer[0]' subId);                                  }                                  else                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}"' _receiveBuffer[0]);                                  }                                    _receiveBufferPosition = 0;                                  break;                              }                                var isExtendedHandler = packetHandlers.Count == 0;                                if (extendedHandlers != null)                              {                                  packetHandlers.AddRange(extendedHandlers);                              }                                GetPacketSize(packetHandlers' out realLength);                                if ((_receiveBufferPosition - currentIndex) >= realLength)                              {                                  var name = packetHandlers[0].Name;                                  var packetBuffer = new byte[realLength];                                    Buffer.BlockCopy(_receiveBuffer' currentIndex + (isExtendedHandler ? 4 : 0)' packetBuffer' 0' realLength);                                    AddPacket(name' packetHandlers' packetBuffer' realLength);                                    currentIndex += realLength;                              }                              else                              {                                  //Need more data                                  break;                              }                          }                            _receiveBufferPosition -= currentIndex;                            if (_receiveBufferPosition > 0)                          {                              Buffer.BlockCopy(_receiveBuffer' currentIndex' _receiveBuffer' 0' _receiveBufferPosition);                          }                      }                  }                    if (_serverSocket != null)                  {                      _serverSocket.BeginReceive(state.Buffer' 0' state.Buffer.Length' SocketFlags.None' OnReceive' state);                  }              }              catch (Exception e)              {                  Tracer.Debug(e.ToString());                  Disconnect();              }
Magic Number,ParadoxUO.Net,NetworkClient,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Net\NetworkClient.cs,OnReceive,The following statement contains a magic number: try              {                  var socket = state.Socket;                  if (socket.Connected == false)                  {                      Disconnect();                      return;                  }                  var length = socket.EndReceive(result);                    if (length > 0)                  {                      var buffer = state.Buffer;                        if (_receiveBuffer == null)                      {                          _receiveBuffer = new byte[0x10000];                      }                        if (IsDecompressionEnabled)                      {                          var outsize = 0;                          byte[] data;                            if (_appendNextMessage)                          {                              _appendNextMessage = false;                              data = new byte[_appendData.Length + length];                                Buffer.BlockCopy(_appendData' 0' data' 0' _appendData.Length);                              Buffer.BlockCopy(buffer' 0' data' _appendData.Length' length);                          }                          else                          {                              data = new byte[length];                              Buffer.BlockCopy(buffer' 0' data' 0' length);                          }                            while (_decompression.DecompressOnePacket(ref data' data.Length' ref _receiveBuffer' ref outsize))                          {                              int realLength;                              var subId = _receiveBuffer.Length >= 5 ? (short) (_receiveBuffer[4] | (_receiveBuffer[3] << 8)) : (short) -1;                              var packetHandlers = GetHandlers(_receiveBuffer[0]);                              List<PacketHandler> extendedHandlers = null;                                if (_receiveBuffer.Length >= 5)                              {                                  extendedHandlers = GetExtendedHandlers(_receiveBuffer[0]' subId);                              }                                if (packetHandlers.Count == 0 && (extendedHandlers == null || extendedHandlers.Count == 0))                              {                                  if (subId != -1)                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}' possible subid: 0x{1:x2}"' _receiveBuffer[0]' subId);                                  }                                  else                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}"' _receiveBuffer[0]);                                  }                                    _receiveBufferPosition = 0;                                  break;                              }                                var isExtendedHandler = packetHandlers.Count == 0;                                if (extendedHandlers != null)                              {                                  packetHandlers.AddRange(extendedHandlers);                              }                                GetPacketSize(packetHandlers' out realLength);                                if (realLength != outsize)                              {                                  throw new Exception("Bad packet size!");                              }                                var name = packetHandlers[0].Name;                              var packetBuffer = new byte[realLength];                                Buffer.BlockCopy(_receiveBuffer' isExtendedHandler ? 5 : 0' packetBuffer' 0' realLength);                                AddPacket(name' packetHandlers' packetBuffer' realLength);                          }                            // We've run out of data to parse' or the packet was incomplete. If the packet was incomplete'                          // we should save what's left for socket receive event.                          if (data.Length > 0)                          {                              _appendNextMessage = true;                              _appendData = data;                          }                      }                      else                      {                          Buffer.BlockCopy(buffer' 0' _receiveBuffer' _receiveBufferPosition' length);                            _receiveBufferPosition += length;                            var currentIndex = 0;                            while (currentIndex < _receiveBufferPosition)                          {                              int realLength;                              var subId = _receiveBuffer.Length >= 5 ? (short) (_receiveBuffer[4] | (_receiveBuffer[3] << 8)) : (short) -1;                              var packetHandlers = GetHandlers(_receiveBuffer[0]);                              List<PacketHandler> extendedHandlers = null;                                if (_receiveBuffer.Length >= 5)                              {                                  extendedHandlers = GetExtendedHandlers(_receiveBuffer[0]' subId);                              }                                if (packetHandlers.Count == 0 && extendedHandlers == null)                              {                                  if (subId != -1)                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}' possible subid: 0x{1:x2}"' _receiveBuffer[0]' subId);                                  }                                  else                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}"' _receiveBuffer[0]);                                  }                                    _receiveBufferPosition = 0;                                  break;                              }                                var isExtendedHandler = packetHandlers.Count == 0;                                if (extendedHandlers != null)                              {                                  packetHandlers.AddRange(extendedHandlers);                              }                                GetPacketSize(packetHandlers' out realLength);                                if ((_receiveBufferPosition - currentIndex) >= realLength)                              {                                  var name = packetHandlers[0].Name;                                  var packetBuffer = new byte[realLength];                                    Buffer.BlockCopy(_receiveBuffer' currentIndex + (isExtendedHandler ? 4 : 0)' packetBuffer' 0' realLength);                                    AddPacket(name' packetHandlers' packetBuffer' realLength);                                    currentIndex += realLength;                              }                              else                              {                                  //Need more data                                  break;                              }                          }                            _receiveBufferPosition -= currentIndex;                            if (_receiveBufferPosition > 0)                          {                              Buffer.BlockCopy(_receiveBuffer' currentIndex' _receiveBuffer' 0' _receiveBufferPosition);                          }                      }                  }                    if (_serverSocket != null)                  {                      _serverSocket.BeginReceive(state.Buffer' 0' state.Buffer.Length' SocketFlags.None' OnReceive' state);                  }              }              catch (Exception e)              {                  Tracer.Debug(e.ToString());                  Disconnect();              }
Magic Number,ParadoxUO.Net,NetworkClient,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Net\NetworkClient.cs,OnReceive,The following statement contains a magic number: try              {                  var socket = state.Socket;                  if (socket.Connected == false)                  {                      Disconnect();                      return;                  }                  var length = socket.EndReceive(result);                    if (length > 0)                  {                      var buffer = state.Buffer;                        if (_receiveBuffer == null)                      {                          _receiveBuffer = new byte[0x10000];                      }                        if (IsDecompressionEnabled)                      {                          var outsize = 0;                          byte[] data;                            if (_appendNextMessage)                          {                              _appendNextMessage = false;                              data = new byte[_appendData.Length + length];                                Buffer.BlockCopy(_appendData' 0' data' 0' _appendData.Length);                              Buffer.BlockCopy(buffer' 0' data' _appendData.Length' length);                          }                          else                          {                              data = new byte[length];                              Buffer.BlockCopy(buffer' 0' data' 0' length);                          }                            while (_decompression.DecompressOnePacket(ref data' data.Length' ref _receiveBuffer' ref outsize))                          {                              int realLength;                              var subId = _receiveBuffer.Length >= 5 ? (short) (_receiveBuffer[4] | (_receiveBuffer[3] << 8)) : (short) -1;                              var packetHandlers = GetHandlers(_receiveBuffer[0]);                              List<PacketHandler> extendedHandlers = null;                                if (_receiveBuffer.Length >= 5)                              {                                  extendedHandlers = GetExtendedHandlers(_receiveBuffer[0]' subId);                              }                                if (packetHandlers.Count == 0 && (extendedHandlers == null || extendedHandlers.Count == 0))                              {                                  if (subId != -1)                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}' possible subid: 0x{1:x2}"' _receiveBuffer[0]' subId);                                  }                                  else                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}"' _receiveBuffer[0]);                                  }                                    _receiveBufferPosition = 0;                                  break;                              }                                var isExtendedHandler = packetHandlers.Count == 0;                                if (extendedHandlers != null)                              {                                  packetHandlers.AddRange(extendedHandlers);                              }                                GetPacketSize(packetHandlers' out realLength);                                if (realLength != outsize)                              {                                  throw new Exception("Bad packet size!");                              }                                var name = packetHandlers[0].Name;                              var packetBuffer = new byte[realLength];                                Buffer.BlockCopy(_receiveBuffer' isExtendedHandler ? 5 : 0' packetBuffer' 0' realLength);                                AddPacket(name' packetHandlers' packetBuffer' realLength);                          }                            // We've run out of data to parse' or the packet was incomplete. If the packet was incomplete'                          // we should save what's left for socket receive event.                          if (data.Length > 0)                          {                              _appendNextMessage = true;                              _appendData = data;                          }                      }                      else                      {                          Buffer.BlockCopy(buffer' 0' _receiveBuffer' _receiveBufferPosition' length);                            _receiveBufferPosition += length;                            var currentIndex = 0;                            while (currentIndex < _receiveBufferPosition)                          {                              int realLength;                              var subId = _receiveBuffer.Length >= 5 ? (short) (_receiveBuffer[4] | (_receiveBuffer[3] << 8)) : (short) -1;                              var packetHandlers = GetHandlers(_receiveBuffer[0]);                              List<PacketHandler> extendedHandlers = null;                                if (_receiveBuffer.Length >= 5)                              {                                  extendedHandlers = GetExtendedHandlers(_receiveBuffer[0]' subId);                              }                                if (packetHandlers.Count == 0 && extendedHandlers == null)                              {                                  if (subId != -1)                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}' possible subid: 0x{1:x2}"' _receiveBuffer[0]' subId);                                  }                                  else                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}"' _receiveBuffer[0]);                                  }                                    _receiveBufferPosition = 0;                                  break;                              }                                var isExtendedHandler = packetHandlers.Count == 0;                                if (extendedHandlers != null)                              {                                  packetHandlers.AddRange(extendedHandlers);                              }                                GetPacketSize(packetHandlers' out realLength);                                if ((_receiveBufferPosition - currentIndex) >= realLength)                              {                                  var name = packetHandlers[0].Name;                                  var packetBuffer = new byte[realLength];                                    Buffer.BlockCopy(_receiveBuffer' currentIndex + (isExtendedHandler ? 4 : 0)' packetBuffer' 0' realLength);                                    AddPacket(name' packetHandlers' packetBuffer' realLength);                                    currentIndex += realLength;                              }                              else                              {                                  //Need more data                                  break;                              }                          }                            _receiveBufferPosition -= currentIndex;                            if (_receiveBufferPosition > 0)                          {                              Buffer.BlockCopy(_receiveBuffer' currentIndex' _receiveBuffer' 0' _receiveBufferPosition);                          }                      }                  }                    if (_serverSocket != null)                  {                      _serverSocket.BeginReceive(state.Buffer' 0' state.Buffer.Length' SocketFlags.None' OnReceive' state);                  }              }              catch (Exception e)              {                  Tracer.Debug(e.ToString());                  Disconnect();              }
Magic Number,ParadoxUO.Net,NetworkClient,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Net\NetworkClient.cs,OnReceive,The following statement contains a magic number: try              {                  var socket = state.Socket;                  if (socket.Connected == false)                  {                      Disconnect();                      return;                  }                  var length = socket.EndReceive(result);                    if (length > 0)                  {                      var buffer = state.Buffer;                        if (_receiveBuffer == null)                      {                          _receiveBuffer = new byte[0x10000];                      }                        if (IsDecompressionEnabled)                      {                          var outsize = 0;                          byte[] data;                            if (_appendNextMessage)                          {                              _appendNextMessage = false;                              data = new byte[_appendData.Length + length];                                Buffer.BlockCopy(_appendData' 0' data' 0' _appendData.Length);                              Buffer.BlockCopy(buffer' 0' data' _appendData.Length' length);                          }                          else                          {                              data = new byte[length];                              Buffer.BlockCopy(buffer' 0' data' 0' length);                          }                            while (_decompression.DecompressOnePacket(ref data' data.Length' ref _receiveBuffer' ref outsize))                          {                              int realLength;                              var subId = _receiveBuffer.Length >= 5 ? (short) (_receiveBuffer[4] | (_receiveBuffer[3] << 8)) : (short) -1;                              var packetHandlers = GetHandlers(_receiveBuffer[0]);                              List<PacketHandler> extendedHandlers = null;                                if (_receiveBuffer.Length >= 5)                              {                                  extendedHandlers = GetExtendedHandlers(_receiveBuffer[0]' subId);                              }                                if (packetHandlers.Count == 0 && (extendedHandlers == null || extendedHandlers.Count == 0))                              {                                  if (subId != -1)                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}' possible subid: 0x{1:x2}"' _receiveBuffer[0]' subId);                                  }                                  else                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}"' _receiveBuffer[0]);                                  }                                    _receiveBufferPosition = 0;                                  break;                              }                                var isExtendedHandler = packetHandlers.Count == 0;                                if (extendedHandlers != null)                              {                                  packetHandlers.AddRange(extendedHandlers);                              }                                GetPacketSize(packetHandlers' out realLength);                                if (realLength != outsize)                              {                                  throw new Exception("Bad packet size!");                              }                                var name = packetHandlers[0].Name;                              var packetBuffer = new byte[realLength];                                Buffer.BlockCopy(_receiveBuffer' isExtendedHandler ? 5 : 0' packetBuffer' 0' realLength);                                AddPacket(name' packetHandlers' packetBuffer' realLength);                          }                            // We've run out of data to parse' or the packet was incomplete. If the packet was incomplete'                          // we should save what's left for socket receive event.                          if (data.Length > 0)                          {                              _appendNextMessage = true;                              _appendData = data;                          }                      }                      else                      {                          Buffer.BlockCopy(buffer' 0' _receiveBuffer' _receiveBufferPosition' length);                            _receiveBufferPosition += length;                            var currentIndex = 0;                            while (currentIndex < _receiveBufferPosition)                          {                              int realLength;                              var subId = _receiveBuffer.Length >= 5 ? (short) (_receiveBuffer[4] | (_receiveBuffer[3] << 8)) : (short) -1;                              var packetHandlers = GetHandlers(_receiveBuffer[0]);                              List<PacketHandler> extendedHandlers = null;                                if (_receiveBuffer.Length >= 5)                              {                                  extendedHandlers = GetExtendedHandlers(_receiveBuffer[0]' subId);                              }                                if (packetHandlers.Count == 0 && extendedHandlers == null)                              {                                  if (subId != -1)                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}' possible subid: 0x{1:x2}"' _receiveBuffer[0]' subId);                                  }                                  else                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}"' _receiveBuffer[0]);                                  }                                    _receiveBufferPosition = 0;                                  break;                              }                                var isExtendedHandler = packetHandlers.Count == 0;                                if (extendedHandlers != null)                              {                                  packetHandlers.AddRange(extendedHandlers);                              }                                GetPacketSize(packetHandlers' out realLength);                                if ((_receiveBufferPosition - currentIndex) >= realLength)                              {                                  var name = packetHandlers[0].Name;                                  var packetBuffer = new byte[realLength];                                    Buffer.BlockCopy(_receiveBuffer' currentIndex + (isExtendedHandler ? 4 : 0)' packetBuffer' 0' realLength);                                    AddPacket(name' packetHandlers' packetBuffer' realLength);                                    currentIndex += realLength;                              }                              else                              {                                  //Need more data                                  break;                              }                          }                            _receiveBufferPosition -= currentIndex;                            if (_receiveBufferPosition > 0)                          {                              Buffer.BlockCopy(_receiveBuffer' currentIndex' _receiveBuffer' 0' _receiveBufferPosition);                          }                      }                  }                    if (_serverSocket != null)                  {                      _serverSocket.BeginReceive(state.Buffer' 0' state.Buffer.Length' SocketFlags.None' OnReceive' state);                  }              }              catch (Exception e)              {                  Tracer.Debug(e.ToString());                  Disconnect();              }
Magic Number,ParadoxUO.Net,NetworkClient,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Net\NetworkClient.cs,OnReceive,The following statement contains a magic number: try              {                  var socket = state.Socket;                  if (socket.Connected == false)                  {                      Disconnect();                      return;                  }                  var length = socket.EndReceive(result);                    if (length > 0)                  {                      var buffer = state.Buffer;                        if (_receiveBuffer == null)                      {                          _receiveBuffer = new byte[0x10000];                      }                        if (IsDecompressionEnabled)                      {                          var outsize = 0;                          byte[] data;                            if (_appendNextMessage)                          {                              _appendNextMessage = false;                              data = new byte[_appendData.Length + length];                                Buffer.BlockCopy(_appendData' 0' data' 0' _appendData.Length);                              Buffer.BlockCopy(buffer' 0' data' _appendData.Length' length);                          }                          else                          {                              data = new byte[length];                              Buffer.BlockCopy(buffer' 0' data' 0' length);                          }                            while (_decompression.DecompressOnePacket(ref data' data.Length' ref _receiveBuffer' ref outsize))                          {                              int realLength;                              var subId = _receiveBuffer.Length >= 5 ? (short) (_receiveBuffer[4] | (_receiveBuffer[3] << 8)) : (short) -1;                              var packetHandlers = GetHandlers(_receiveBuffer[0]);                              List<PacketHandler> extendedHandlers = null;                                if (_receiveBuffer.Length >= 5)                              {                                  extendedHandlers = GetExtendedHandlers(_receiveBuffer[0]' subId);                              }                                if (packetHandlers.Count == 0 && (extendedHandlers == null || extendedHandlers.Count == 0))                              {                                  if (subId != -1)                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}' possible subid: 0x{1:x2}"' _receiveBuffer[0]' subId);                                  }                                  else                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}"' _receiveBuffer[0]);                                  }                                    _receiveBufferPosition = 0;                                  break;                              }                                var isExtendedHandler = packetHandlers.Count == 0;                                if (extendedHandlers != null)                              {                                  packetHandlers.AddRange(extendedHandlers);                              }                                GetPacketSize(packetHandlers' out realLength);                                if (realLength != outsize)                              {                                  throw new Exception("Bad packet size!");                              }                                var name = packetHandlers[0].Name;                              var packetBuffer = new byte[realLength];                                Buffer.BlockCopy(_receiveBuffer' isExtendedHandler ? 5 : 0' packetBuffer' 0' realLength);                                AddPacket(name' packetHandlers' packetBuffer' realLength);                          }                            // We've run out of data to parse' or the packet was incomplete. If the packet was incomplete'                          // we should save what's left for socket receive event.                          if (data.Length > 0)                          {                              _appendNextMessage = true;                              _appendData = data;                          }                      }                      else                      {                          Buffer.BlockCopy(buffer' 0' _receiveBuffer' _receiveBufferPosition' length);                            _receiveBufferPosition += length;                            var currentIndex = 0;                            while (currentIndex < _receiveBufferPosition)                          {                              int realLength;                              var subId = _receiveBuffer.Length >= 5 ? (short) (_receiveBuffer[4] | (_receiveBuffer[3] << 8)) : (short) -1;                              var packetHandlers = GetHandlers(_receiveBuffer[0]);                              List<PacketHandler> extendedHandlers = null;                                if (_receiveBuffer.Length >= 5)                              {                                  extendedHandlers = GetExtendedHandlers(_receiveBuffer[0]' subId);                              }                                if (packetHandlers.Count == 0 && extendedHandlers == null)                              {                                  if (subId != -1)                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}' possible subid: 0x{1:x2}"' _receiveBuffer[0]' subId);                                  }                                  else                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}"' _receiveBuffer[0]);                                  }                                    _receiveBufferPosition = 0;                                  break;                              }                                var isExtendedHandler = packetHandlers.Count == 0;                                if (extendedHandlers != null)                              {                                  packetHandlers.AddRange(extendedHandlers);                              }                                GetPacketSize(packetHandlers' out realLength);                                if ((_receiveBufferPosition - currentIndex) >= realLength)                              {                                  var name = packetHandlers[0].Name;                                  var packetBuffer = new byte[realLength];                                    Buffer.BlockCopy(_receiveBuffer' currentIndex + (isExtendedHandler ? 4 : 0)' packetBuffer' 0' realLength);                                    AddPacket(name' packetHandlers' packetBuffer' realLength);                                    currentIndex += realLength;                              }                              else                              {                                  //Need more data                                  break;                              }                          }                            _receiveBufferPosition -= currentIndex;                            if (_receiveBufferPosition > 0)                          {                              Buffer.BlockCopy(_receiveBuffer' currentIndex' _receiveBuffer' 0' _receiveBufferPosition);                          }                      }                  }                    if (_serverSocket != null)                  {                      _serverSocket.BeginReceive(state.Buffer' 0' state.Buffer.Length' SocketFlags.None' OnReceive' state);                  }              }              catch (Exception e)              {                  Tracer.Debug(e.ToString());                  Disconnect();              }
Magic Number,ParadoxUO.Net,NetworkClient,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Net\NetworkClient.cs,OnReceive,The following statement contains a magic number: try              {                  var socket = state.Socket;                  if (socket.Connected == false)                  {                      Disconnect();                      return;                  }                  var length = socket.EndReceive(result);                    if (length > 0)                  {                      var buffer = state.Buffer;                        if (_receiveBuffer == null)                      {                          _receiveBuffer = new byte[0x10000];                      }                        if (IsDecompressionEnabled)                      {                          var outsize = 0;                          byte[] data;                            if (_appendNextMessage)                          {                              _appendNextMessage = false;                              data = new byte[_appendData.Length + length];                                Buffer.BlockCopy(_appendData' 0' data' 0' _appendData.Length);                              Buffer.BlockCopy(buffer' 0' data' _appendData.Length' length);                          }                          else                          {                              data = new byte[length];                              Buffer.BlockCopy(buffer' 0' data' 0' length);                          }                            while (_decompression.DecompressOnePacket(ref data' data.Length' ref _receiveBuffer' ref outsize))                          {                              int realLength;                              var subId = _receiveBuffer.Length >= 5 ? (short) (_receiveBuffer[4] | (_receiveBuffer[3] << 8)) : (short) -1;                              var packetHandlers = GetHandlers(_receiveBuffer[0]);                              List<PacketHandler> extendedHandlers = null;                                if (_receiveBuffer.Length >= 5)                              {                                  extendedHandlers = GetExtendedHandlers(_receiveBuffer[0]' subId);                              }                                if (packetHandlers.Count == 0 && (extendedHandlers == null || extendedHandlers.Count == 0))                              {                                  if (subId != -1)                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}' possible subid: 0x{1:x2}"' _receiveBuffer[0]' subId);                                  }                                  else                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}"' _receiveBuffer[0]);                                  }                                    _receiveBufferPosition = 0;                                  break;                              }                                var isExtendedHandler = packetHandlers.Count == 0;                                if (extendedHandlers != null)                              {                                  packetHandlers.AddRange(extendedHandlers);                              }                                GetPacketSize(packetHandlers' out realLength);                                if (realLength != outsize)                              {                                  throw new Exception("Bad packet size!");                              }                                var name = packetHandlers[0].Name;                              var packetBuffer = new byte[realLength];                                Buffer.BlockCopy(_receiveBuffer' isExtendedHandler ? 5 : 0' packetBuffer' 0' realLength);                                AddPacket(name' packetHandlers' packetBuffer' realLength);                          }                            // We've run out of data to parse' or the packet was incomplete. If the packet was incomplete'                          // we should save what's left for socket receive event.                          if (data.Length > 0)                          {                              _appendNextMessage = true;                              _appendData = data;                          }                      }                      else                      {                          Buffer.BlockCopy(buffer' 0' _receiveBuffer' _receiveBufferPosition' length);                            _receiveBufferPosition += length;                            var currentIndex = 0;                            while (currentIndex < _receiveBufferPosition)                          {                              int realLength;                              var subId = _receiveBuffer.Length >= 5 ? (short) (_receiveBuffer[4] | (_receiveBuffer[3] << 8)) : (short) -1;                              var packetHandlers = GetHandlers(_receiveBuffer[0]);                              List<PacketHandler> extendedHandlers = null;                                if (_receiveBuffer.Length >= 5)                              {                                  extendedHandlers = GetExtendedHandlers(_receiveBuffer[0]' subId);                              }                                if (packetHandlers.Count == 0 && extendedHandlers == null)                              {                                  if (subId != -1)                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}' possible subid: 0x{1:x2}"' _receiveBuffer[0]' subId);                                  }                                  else                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}"' _receiveBuffer[0]);                                  }                                    _receiveBufferPosition = 0;                                  break;                              }                                var isExtendedHandler = packetHandlers.Count == 0;                                if (extendedHandlers != null)                              {                                  packetHandlers.AddRange(extendedHandlers);                              }                                GetPacketSize(packetHandlers' out realLength);                                if ((_receiveBufferPosition - currentIndex) >= realLength)                              {                                  var name = packetHandlers[0].Name;                                  var packetBuffer = new byte[realLength];                                    Buffer.BlockCopy(_receiveBuffer' currentIndex + (isExtendedHandler ? 4 : 0)' packetBuffer' 0' realLength);                                    AddPacket(name' packetHandlers' packetBuffer' realLength);                                    currentIndex += realLength;                              }                              else                              {                                  //Need more data                                  break;                              }                          }                            _receiveBufferPosition -= currentIndex;                            if (_receiveBufferPosition > 0)                          {                              Buffer.BlockCopy(_receiveBuffer' currentIndex' _receiveBuffer' 0' _receiveBufferPosition);                          }                      }                  }                    if (_serverSocket != null)                  {                      _serverSocket.BeginReceive(state.Buffer' 0' state.Buffer.Length' SocketFlags.None' OnReceive' state);                  }              }              catch (Exception e)              {                  Tracer.Debug(e.ToString());                  Disconnect();              }
Magic Number,ParadoxUO.Net,NetworkClient,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Net\NetworkClient.cs,OnReceive,The following statement contains a magic number: try              {                  var socket = state.Socket;                  if (socket.Connected == false)                  {                      Disconnect();                      return;                  }                  var length = socket.EndReceive(result);                    if (length > 0)                  {                      var buffer = state.Buffer;                        if (_receiveBuffer == null)                      {                          _receiveBuffer = new byte[0x10000];                      }                        if (IsDecompressionEnabled)                      {                          var outsize = 0;                          byte[] data;                            if (_appendNextMessage)                          {                              _appendNextMessage = false;                              data = new byte[_appendData.Length + length];                                Buffer.BlockCopy(_appendData' 0' data' 0' _appendData.Length);                              Buffer.BlockCopy(buffer' 0' data' _appendData.Length' length);                          }                          else                          {                              data = new byte[length];                              Buffer.BlockCopy(buffer' 0' data' 0' length);                          }                            while (_decompression.DecompressOnePacket(ref data' data.Length' ref _receiveBuffer' ref outsize))                          {                              int realLength;                              var subId = _receiveBuffer.Length >= 5 ? (short) (_receiveBuffer[4] | (_receiveBuffer[3] << 8)) : (short) -1;                              var packetHandlers = GetHandlers(_receiveBuffer[0]);                              List<PacketHandler> extendedHandlers = null;                                if (_receiveBuffer.Length >= 5)                              {                                  extendedHandlers = GetExtendedHandlers(_receiveBuffer[0]' subId);                              }                                if (packetHandlers.Count == 0 && (extendedHandlers == null || extendedHandlers.Count == 0))                              {                                  if (subId != -1)                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}' possible subid: 0x{1:x2}"' _receiveBuffer[0]' subId);                                  }                                  else                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}"' _receiveBuffer[0]);                                  }                                    _receiveBufferPosition = 0;                                  break;                              }                                var isExtendedHandler = packetHandlers.Count == 0;                                if (extendedHandlers != null)                              {                                  packetHandlers.AddRange(extendedHandlers);                              }                                GetPacketSize(packetHandlers' out realLength);                                if (realLength != outsize)                              {                                  throw new Exception("Bad packet size!");                              }                                var name = packetHandlers[0].Name;                              var packetBuffer = new byte[realLength];                                Buffer.BlockCopy(_receiveBuffer' isExtendedHandler ? 5 : 0' packetBuffer' 0' realLength);                                AddPacket(name' packetHandlers' packetBuffer' realLength);                          }                            // We've run out of data to parse' or the packet was incomplete. If the packet was incomplete'                          // we should save what's left for socket receive event.                          if (data.Length > 0)                          {                              _appendNextMessage = true;                              _appendData = data;                          }                      }                      else                      {                          Buffer.BlockCopy(buffer' 0' _receiveBuffer' _receiveBufferPosition' length);                            _receiveBufferPosition += length;                            var currentIndex = 0;                            while (currentIndex < _receiveBufferPosition)                          {                              int realLength;                              var subId = _receiveBuffer.Length >= 5 ? (short) (_receiveBuffer[4] | (_receiveBuffer[3] << 8)) : (short) -1;                              var packetHandlers = GetHandlers(_receiveBuffer[0]);                              List<PacketHandler> extendedHandlers = null;                                if (_receiveBuffer.Length >= 5)                              {                                  extendedHandlers = GetExtendedHandlers(_receiveBuffer[0]' subId);                              }                                if (packetHandlers.Count == 0 && extendedHandlers == null)                              {                                  if (subId != -1)                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}' possible subid: 0x{1:x2}"' _receiveBuffer[0]' subId);                                  }                                  else                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}"' _receiveBuffer[0]);                                  }                                    _receiveBufferPosition = 0;                                  break;                              }                                var isExtendedHandler = packetHandlers.Count == 0;                                if (extendedHandlers != null)                              {                                  packetHandlers.AddRange(extendedHandlers);                              }                                GetPacketSize(packetHandlers' out realLength);                                if ((_receiveBufferPosition - currentIndex) >= realLength)                              {                                  var name = packetHandlers[0].Name;                                  var packetBuffer = new byte[realLength];                                    Buffer.BlockCopy(_receiveBuffer' currentIndex + (isExtendedHandler ? 4 : 0)' packetBuffer' 0' realLength);                                    AddPacket(name' packetHandlers' packetBuffer' realLength);                                    currentIndex += realLength;                              }                              else                              {                                  //Need more data                                  break;                              }                          }                            _receiveBufferPosition -= currentIndex;                            if (_receiveBufferPosition > 0)                          {                              Buffer.BlockCopy(_receiveBuffer' currentIndex' _receiveBuffer' 0' _receiveBufferPosition);                          }                      }                  }                    if (_serverSocket != null)                  {                      _serverSocket.BeginReceive(state.Buffer' 0' state.Buffer.Length' SocketFlags.None' OnReceive' state);                  }              }              catch (Exception e)              {                  Tracer.Debug(e.ToString());                  Disconnect();              }
Magic Number,ParadoxUO.Net,NetworkClient,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Net\NetworkClient.cs,OnReceive,The following statement contains a magic number: try              {                  var socket = state.Socket;                  if (socket.Connected == false)                  {                      Disconnect();                      return;                  }                  var length = socket.EndReceive(result);                    if (length > 0)                  {                      var buffer = state.Buffer;                        if (_receiveBuffer == null)                      {                          _receiveBuffer = new byte[0x10000];                      }                        if (IsDecompressionEnabled)                      {                          var outsize = 0;                          byte[] data;                            if (_appendNextMessage)                          {                              _appendNextMessage = false;                              data = new byte[_appendData.Length + length];                                Buffer.BlockCopy(_appendData' 0' data' 0' _appendData.Length);                              Buffer.BlockCopy(buffer' 0' data' _appendData.Length' length);                          }                          else                          {                              data = new byte[length];                              Buffer.BlockCopy(buffer' 0' data' 0' length);                          }                            while (_decompression.DecompressOnePacket(ref data' data.Length' ref _receiveBuffer' ref outsize))                          {                              int realLength;                              var subId = _receiveBuffer.Length >= 5 ? (short) (_receiveBuffer[4] | (_receiveBuffer[3] << 8)) : (short) -1;                              var packetHandlers = GetHandlers(_receiveBuffer[0]);                              List<PacketHandler> extendedHandlers = null;                                if (_receiveBuffer.Length >= 5)                              {                                  extendedHandlers = GetExtendedHandlers(_receiveBuffer[0]' subId);                              }                                if (packetHandlers.Count == 0 && (extendedHandlers == null || extendedHandlers.Count == 0))                              {                                  if (subId != -1)                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}' possible subid: 0x{1:x2}"' _receiveBuffer[0]' subId);                                  }                                  else                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}"' _receiveBuffer[0]);                                  }                                    _receiveBufferPosition = 0;                                  break;                              }                                var isExtendedHandler = packetHandlers.Count == 0;                                if (extendedHandlers != null)                              {                                  packetHandlers.AddRange(extendedHandlers);                              }                                GetPacketSize(packetHandlers' out realLength);                                if (realLength != outsize)                              {                                  throw new Exception("Bad packet size!");                              }                                var name = packetHandlers[0].Name;                              var packetBuffer = new byte[realLength];                                Buffer.BlockCopy(_receiveBuffer' isExtendedHandler ? 5 : 0' packetBuffer' 0' realLength);                                AddPacket(name' packetHandlers' packetBuffer' realLength);                          }                            // We've run out of data to parse' or the packet was incomplete. If the packet was incomplete'                          // we should save what's left for socket receive event.                          if (data.Length > 0)                          {                              _appendNextMessage = true;                              _appendData = data;                          }                      }                      else                      {                          Buffer.BlockCopy(buffer' 0' _receiveBuffer' _receiveBufferPosition' length);                            _receiveBufferPosition += length;                            var currentIndex = 0;                            while (currentIndex < _receiveBufferPosition)                          {                              int realLength;                              var subId = _receiveBuffer.Length >= 5 ? (short) (_receiveBuffer[4] | (_receiveBuffer[3] << 8)) : (short) -1;                              var packetHandlers = GetHandlers(_receiveBuffer[0]);                              List<PacketHandler> extendedHandlers = null;                                if (_receiveBuffer.Length >= 5)                              {                                  extendedHandlers = GetExtendedHandlers(_receiveBuffer[0]' subId);                              }                                if (packetHandlers.Count == 0 && extendedHandlers == null)                              {                                  if (subId != -1)                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}' possible subid: 0x{1:x2}"' _receiveBuffer[0]' subId);                                  }                                  else                                  {                                      Tracer.Warn("Unhandled packet with id: 0x{0:x2}"' _receiveBuffer[0]);                                  }                                    _receiveBufferPosition = 0;                                  break;                              }                                var isExtendedHandler = packetHandlers.Count == 0;                                if (extendedHandlers != null)                              {                                  packetHandlers.AddRange(extendedHandlers);                              }                                GetPacketSize(packetHandlers' out realLength);                                if ((_receiveBufferPosition - currentIndex) >= realLength)                              {                                  var name = packetHandlers[0].Name;                                  var packetBuffer = new byte[realLength];                                    Buffer.BlockCopy(_receiveBuffer' currentIndex + (isExtendedHandler ? 4 : 0)' packetBuffer' 0' realLength);                                    AddPacket(name' packetHandlers' packetBuffer' realLength);                                    currentIndex += realLength;                              }                              else                              {                                  //Need more data                                  break;                              }                          }                            _receiveBufferPosition -= currentIndex;                            if (_receiveBufferPosition > 0)                          {                              Buffer.BlockCopy(_receiveBuffer' currentIndex' _receiveBuffer' 0' _receiveBufferPosition);                          }                      }                  }                    if (_serverSocket != null)                  {                      _serverSocket.BeginReceive(state.Buffer' 0' state.Buffer.Length' SocketFlags.None' OnReceive' state);                  }              }              catch (Exception e)              {                  Tracer.Debug(e.ToString());                  Disconnect();              }
Magic Number,ParadoxUO.Net,NetworkClient,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Net\NetworkClient.cs,GetPacketSize,The following statement contains a magic number: if (packetHandlers.Count > 0)              {                  if (packetHandlers[0].Length == -1)                  {                      realLength = _receiveBuffer[2] | (_receiveBuffer[1] << 8);                  }                  else                  {                      realLength = packetHandlers[0].Length;                  }              }
Magic Number,ParadoxUO.Net,NetworkClient,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Net\NetworkClient.cs,GetPacketSize,The following statement contains a magic number: if (packetHandlers.Count > 0)              {                  if (packetHandlers[0].Length == -1)                  {                      realLength = _receiveBuffer[2] | (_receiveBuffer[1] << 8);                  }                  else                  {                      realLength = packetHandlers[0].Length;                  }              }
Duplicate Code,ParadoxUO.Net,NetworkClient,C:\repos\fdsprod_OpenUO\ParadoxUO\ParadoxUO.Windows\Net\NetworkClient.cs,OnReceive,The method contains a code clone-set at the following line numbers (starting from the method definition): ((61' 83)' (126' 148))
