Implementation smell,Namespace,Class,File,Method,Description
Complex Method,OpenUO.Core.Net,PacketReader,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketReader.cs,ReadUTF8StringSafe,Cyclomatic complexity of the method is 9
Complex Method,OpenUO.Core.Net,PacketReader,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketReader.cs,ReadUTF8StringSafe,Cyclomatic complexity of the method is 8
Long Parameter List,OpenUO.Core.Net.Compression,ZlibCompression,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\Compression\ZlibDecompression.cs,Pack,The method has 5 parameters. Parameters: dest' destLength' source' sourceLength' quality
Long Parameter List,OpenUO.Core.Net.Compression,IZLibCompressor,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\Compression\ZlibDecompression.cs,Compress,The method has 5 parameters. Parameters: dest' destLength' source' sourceLength' quality
Long Parameter List,OpenUO.Core.Net.Compression,Compressor32,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\Compression\ZlibDecompression.cs,Compress,The method has 5 parameters. Parameters: dest' destLength' source' sourceLength' quality
Long Parameter List,OpenUO.Core.Net.Compression,Compressor32,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\Compression\ZlibDecompression.cs,compress2,The method has 5 parameters. Parameters: dest' destLength' source' sourceLength' quality
Long Parameter List,OpenUO.Core.Net.Compression,Compressor64,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\Compression\ZlibDecompression.cs,Compress,The method has 5 parameters. Parameters: dest' destLength' source' sourceLength' quality
Long Parameter List,OpenUO.Core.Net.Compression,Compressor64,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\Compression\ZlibDecompression.cs,compress2,The method has 5 parameters. Parameters: dest' destLength' source' sourceLength' quality
Long Parameter List,OpenUO.Core.Net.Compression,CompressorUnix,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\Compression\ZlibDecompression.cs,Compress,The method has 5 parameters. Parameters: dest' destLength' source' sourceLength' quality
Long Parameter List,OpenUO.Core.Net.Compression,CompressorUnix,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\Compression\ZlibDecompression.cs,compress2,The method has 5 parameters. Parameters: dest' destLength' source' sourceLength' quality
Long Parameter List,OpenUO.Core.Net,INetworkClient,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\INetworkClient.cs,RegisterExtended,The method has 5 parameters. Parameters: extendedId' subId' name' length' handler
Long Statement,OpenUO.Core.Net,PacketWriter,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketWriter.cs,WriteBigUniNull,The length of the statement  "            BaseStream.Position += Encoding.BigEndianUnicode.GetBytes(value' 0' length' BaseStream.GetBuffer()' (int) BaseStream.Position); " is 127.
Long Statement,OpenUO.Core.Net,PacketWriter,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketWriter.cs,WriteBigUniFixed,The length of the statement  "                BaseStream.Position += Encoding.BigEndianUnicode.GetBytes(value' 0' length' BaseStream.GetBuffer()' (int) BaseStream.Position); " is 127.
Magic Number,OpenUO.Core.Net.Compression,HuffmanDecompression,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\Compression\HuffmanDecompression.cs,DecompressOnePacket,The following statement contains a magic number: int node = 0' leaf = 0' leaf_value = 0' dest_pos = 0' bit_num = 8' src_pos = 0;
Magic Number,OpenUO.Core.Net.Compression,HuffmanDecompression,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\Compression\HuffmanDecompression.cs,DecompressOnePacket,The following statement contains a magic number: while (src_pos < src_size)              {                  leaf = GetBit(src[src_pos]' bit_num);                  leaf_value = dec_tree[node' leaf];                    // all numbers below 1 (0..-256) are codewords                  // if the halt codeword has been found' skip this byte                  if (leaf_value == -256)                  {                      bit_num = 8;                      node = 0;                      src_pos++;                      var newsource = new byte[src_size - src_pos];                      Array.Copy(src' src_pos' newsource' 0' src_size - src_pos);                      src = newsource;                      dest_size = dest_pos;                      return true;                  }                  if (leaf_value < 1)                  {                      dest[dest_pos] = (byte) -leaf_value;                      leaf_value = 0;                      dest_pos++;                  }                    bit_num--;                  node = leaf_value;                  /* if its the end of the byte' go to the next byte */                  if (bit_num < 1)                  {                      bit_num = 8;                      src_pos++;                  }                    // check to see if the current codeword has no end                  // if not' make it an incomplete byte                  if (src_pos == src_size)                  {                      if (node != 0)                      {                          return false;                      }                      return false;                        //throw new Exception("Incomplete byte at node = 0");                  }                  /*if(obj != NULL && src_pos == *src_size && node)                  {                  obj->incomplete_byte = src[src_pos-1];                  obj->has_incomplete = 1;                  }*/              }
Magic Number,OpenUO.Core.Net.Compression,HuffmanDecompression,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\Compression\HuffmanDecompression.cs,DecompressOnePacket,The following statement contains a magic number: while (src_pos < src_size)              {                  leaf = GetBit(src[src_pos]' bit_num);                  leaf_value = dec_tree[node' leaf];                    // all numbers below 1 (0..-256) are codewords                  // if the halt codeword has been found' skip this byte                  if (leaf_value == -256)                  {                      bit_num = 8;                      node = 0;                      src_pos++;                      var newsource = new byte[src_size - src_pos];                      Array.Copy(src' src_pos' newsource' 0' src_size - src_pos);                      src = newsource;                      dest_size = dest_pos;                      return true;                  }                  if (leaf_value < 1)                  {                      dest[dest_pos] = (byte) -leaf_value;                      leaf_value = 0;                      dest_pos++;                  }                    bit_num--;                  node = leaf_value;                  /* if its the end of the byte' go to the next byte */                  if (bit_num < 1)                  {                      bit_num = 8;                      src_pos++;                  }                    // check to see if the current codeword has no end                  // if not' make it an incomplete byte                  if (src_pos == src_size)                  {                      if (node != 0)                      {                          return false;                      }                      return false;                        //throw new Exception("Incomplete byte at node = 0");                  }                  /*if(obj != NULL && src_pos == *src_size && node)                  {                  obj->incomplete_byte = src[src_pos-1];                  obj->has_incomplete = 1;                  }*/              }
Magic Number,OpenUO.Core.Net.Compression,HuffmanDecompression,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\Compression\HuffmanDecompression.cs,DecompressOnePacket,The following statement contains a magic number: while (src_pos < src_size)              {                  leaf = GetBit(src[src_pos]' bit_num);                  leaf_value = dec_tree[node' leaf];                    // all numbers below 1 (0..-256) are codewords                  // if the halt codeword has been found' skip this byte                  if (leaf_value == -256)                  {                      bit_num = 8;                      node = 0;                      src_pos++;                      var newsource = new byte[src_size - src_pos];                      Array.Copy(src' src_pos' newsource' 0' src_size - src_pos);                      src = newsource;                      dest_size = dest_pos;                      return true;                  }                  if (leaf_value < 1)                  {                      dest[dest_pos] = (byte) -leaf_value;                      leaf_value = 0;                      dest_pos++;                  }                    bit_num--;                  node = leaf_value;                  /* if its the end of the byte' go to the next byte */                  if (bit_num < 1)                  {                      bit_num = 8;                      src_pos++;                  }                    // check to see if the current codeword has no end                  // if not' make it an incomplete byte                  if (src_pos == src_size)                  {                      if (node != 0)                      {                          return false;                      }                      return false;                        //throw new Exception("Incomplete byte at node = 0");                  }                  /*if(obj != NULL && src_pos == *src_size && node)                  {                  obj->incomplete_byte = src[src_pos-1];                  obj->has_incomplete = 1;                  }*/              }
Magic Number,OpenUO.Core.Net.Compression,HuffmanDecompression,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\Compression\HuffmanDecompression.cs,DecompressAll,The following statement contains a magic number: int node = 0' leaf = 0' leaf_value = 0' dest_pos = 0' bit_num = 8' src_pos = 0;
Magic Number,OpenUO.Core.Net.Compression,HuffmanDecompression,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\Compression\HuffmanDecompression.cs,DecompressAll,The following statement contains a magic number: while (src_pos < src_size)              {                  leaf = GetBit(src[src_pos]' bit_num);                  leaf_value = dec_tree[node' leaf];                    // all numbers below 1 (0..-256) are codewords                  // if the halt codeword has been found' skip this byte                  if (leaf_value == -256)                  {                      bit_num = 8;                      node = 0;                      src_pos++;                      continue;                  }                  if (leaf_value < 1)                  {                      dest[dest_pos] = (byte) -leaf_value;                      leaf_value = 0;                      dest_pos++;                  }                    bit_num--;                  node = leaf_value;                  /* if its the end of the byte' go to the next byte */                  if (bit_num < 1)                  {                      bit_num = 8;                      src_pos++;                  }                    // check to see if the current codeword has no end                  // if not' make it an incomplete byte                  /*if(obj != NULL && src_pos == *src_size && node)                  {                  obj->incomplete_byte = src[src_pos-1];                  obj->has_incomplete = 1;                  }*/              }
Magic Number,OpenUO.Core.Net.Compression,HuffmanDecompression,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\Compression\HuffmanDecompression.cs,DecompressAll,The following statement contains a magic number: while (src_pos < src_size)              {                  leaf = GetBit(src[src_pos]' bit_num);                  leaf_value = dec_tree[node' leaf];                    // all numbers below 1 (0..-256) are codewords                  // if the halt codeword has been found' skip this byte                  if (leaf_value == -256)                  {                      bit_num = 8;                      node = 0;                      src_pos++;                      continue;                  }                  if (leaf_value < 1)                  {                      dest[dest_pos] = (byte) -leaf_value;                      leaf_value = 0;                      dest_pos++;                  }                    bit_num--;                  node = leaf_value;                  /* if its the end of the byte' go to the next byte */                  if (bit_num < 1)                  {                      bit_num = 8;                      src_pos++;                  }                    // check to see if the current codeword has no end                  // if not' make it an incomplete byte                  /*if(obj != NULL && src_pos == *src_size && node)                  {                  obj->incomplete_byte = src[src_pos-1];                  obj->has_incomplete = 1;                  }*/              }
Magic Number,OpenUO.Core.Net.Compression,HuffmanDecompression,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\Compression\HuffmanDecompression.cs,DecompressAll,The following statement contains a magic number: while (src_pos < src_size)              {                  leaf = GetBit(src[src_pos]' bit_num);                  leaf_value = dec_tree[node' leaf];                    // all numbers below 1 (0..-256) are codewords                  // if the halt codeword has been found' skip this byte                  if (leaf_value == -256)                  {                      bit_num = 8;                      node = 0;                      src_pos++;                      continue;                  }                  if (leaf_value < 1)                  {                      dest[dest_pos] = (byte) -leaf_value;                      leaf_value = 0;                      dest_pos++;                  }                    bit_num--;                  node = leaf_value;                  /* if its the end of the byte' go to the next byte */                  if (bit_num < 1)                  {                      bit_num = 8;                      src_pos++;                  }                    // check to see if the current codeword has no end                  // if not' make it an incomplete byte                  /*if(obj != NULL && src_pos == *src_size && node)                  {                  obj->incomplete_byte = src[src_pos-1];                  obj->has_incomplete = 1;                  }*/              }
Magic Number,OpenUO.Core.Net.Compression,ZlibCompression,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\Compression\ZlibDecompression.cs,Compress,The following statement contains a magic number: lock (m_syncRoot)              {                  var bitCount = 0;                  var bitValue = 0;                    fixed (int* pTable = m_huffmanTable)                  {                      int* pEntry;                        fixed (byte* pInputBuffer = input)                      {                          byte* pInput = pInputBuffer + offset' pInputEnd = pInput + count;                            fixed (byte* pOutputBuffer = m_outputBuffer)                          {                              byte* pOutput = pOutputBuffer' pOutputEnd = pOutput + BufferSize;                                while (pInput < pInputEnd)                              {                                  pEntry = &pTable[*pInput++ << 1];                                    bitCount += pEntry[CountIndex];                                    bitValue <<= pEntry[CountIndex];                                  bitValue |= pEntry[ValueIndex];                                    while (bitCount >= 8)                                  {                                      bitCount -= 8;                                        if (pOutput < pOutputEnd)                                      {                                          *pOutput++ = (byte) (bitValue >> bitCount);                                      }                                      else                                      {                                          return null;                                      }                                  }                              }                                // terminal code                              pEntry = &pTable[0x200];                                bitCount += pEntry[CountIndex];                                bitValue <<= pEntry[CountIndex];                              bitValue |= pEntry[ValueIndex];                                // align on byte boundary                              if ((bitCount & 7) != 0)                              {                                  bitValue <<= (8 - (bitCount & 7));                                  bitCount += (8 - (bitCount & 7));                              }                                while (bitCount >= 8)                              {                                  bitCount -= 8;                                    if (pOutput < pOutputEnd)                                  {                                      *pOutput++ = (byte) (bitValue >> bitCount);                                  }                                  else                                  {                                      return null;                                  }                              }                                length = (int) (pOutput - pOutputBuffer);                              return m_outputBuffer;                          }                      }                  }              }
Magic Number,OpenUO.Core.Net.Compression,ZlibCompression,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\Compression\ZlibDecompression.cs,Compress,The following statement contains a magic number: lock (m_syncRoot)              {                  var bitCount = 0;                  var bitValue = 0;                    fixed (int* pTable = m_huffmanTable)                  {                      int* pEntry;                        fixed (byte* pInputBuffer = input)                      {                          byte* pInput = pInputBuffer + offset' pInputEnd = pInput + count;                            fixed (byte* pOutputBuffer = m_outputBuffer)                          {                              byte* pOutput = pOutputBuffer' pOutputEnd = pOutput + BufferSize;                                while (pInput < pInputEnd)                              {                                  pEntry = &pTable[*pInput++ << 1];                                    bitCount += pEntry[CountIndex];                                    bitValue <<= pEntry[CountIndex];                                  bitValue |= pEntry[ValueIndex];                                    while (bitCount >= 8)                                  {                                      bitCount -= 8;                                        if (pOutput < pOutputEnd)                                      {                                          *pOutput++ = (byte) (bitValue >> bitCount);                                      }                                      else                                      {                                          return null;                                      }                                  }                              }                                // terminal code                              pEntry = &pTable[0x200];                                bitCount += pEntry[CountIndex];                                bitValue <<= pEntry[CountIndex];                              bitValue |= pEntry[ValueIndex];                                // align on byte boundary                              if ((bitCount & 7) != 0)                              {                                  bitValue <<= (8 - (bitCount & 7));                                  bitCount += (8 - (bitCount & 7));                              }                                while (bitCount >= 8)                              {                                  bitCount -= 8;                                    if (pOutput < pOutputEnd)                                  {                                      *pOutput++ = (byte) (bitValue >> bitCount);                                  }                                  else                                  {                                      return null;                                  }                              }                                length = (int) (pOutput - pOutputBuffer);                              return m_outputBuffer;                          }                      }                  }              }
Magic Number,OpenUO.Core.Net.Compression,ZlibCompression,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\Compression\ZlibDecompression.cs,Compress,The following statement contains a magic number: lock (m_syncRoot)              {                  var bitCount = 0;                  var bitValue = 0;                    fixed (int* pTable = m_huffmanTable)                  {                      int* pEntry;                        fixed (byte* pInputBuffer = input)                      {                          byte* pInput = pInputBuffer + offset' pInputEnd = pInput + count;                            fixed (byte* pOutputBuffer = m_outputBuffer)                          {                              byte* pOutput = pOutputBuffer' pOutputEnd = pOutput + BufferSize;                                while (pInput < pInputEnd)                              {                                  pEntry = &pTable[*pInput++ << 1];                                    bitCount += pEntry[CountIndex];                                    bitValue <<= pEntry[CountIndex];                                  bitValue |= pEntry[ValueIndex];                                    while (bitCount >= 8)                                  {                                      bitCount -= 8;                                        if (pOutput < pOutputEnd)                                      {                                          *pOutput++ = (byte) (bitValue >> bitCount);                                      }                                      else                                      {                                          return null;                                      }                                  }                              }                                // terminal code                              pEntry = &pTable[0x200];                                bitCount += pEntry[CountIndex];                                bitValue <<= pEntry[CountIndex];                              bitValue |= pEntry[ValueIndex];                                // align on byte boundary                              if ((bitCount & 7) != 0)                              {                                  bitValue <<= (8 - (bitCount & 7));                                  bitCount += (8 - (bitCount & 7));                              }                                while (bitCount >= 8)                              {                                  bitCount -= 8;                                    if (pOutput < pOutputEnd)                                  {                                      *pOutput++ = (byte) (bitValue >> bitCount);                                  }                                  else                                  {                                      return null;                                  }                              }                                length = (int) (pOutput - pOutputBuffer);                              return m_outputBuffer;                          }                      }                  }              }
Magic Number,OpenUO.Core.Net.Compression,ZlibCompression,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\Compression\ZlibDecompression.cs,Compress,The following statement contains a magic number: lock (m_syncRoot)              {                  var bitCount = 0;                  var bitValue = 0;                    fixed (int* pTable = m_huffmanTable)                  {                      int* pEntry;                        fixed (byte* pInputBuffer = input)                      {                          byte* pInput = pInputBuffer + offset' pInputEnd = pInput + count;                            fixed (byte* pOutputBuffer = m_outputBuffer)                          {                              byte* pOutput = pOutputBuffer' pOutputEnd = pOutput + BufferSize;                                while (pInput < pInputEnd)                              {                                  pEntry = &pTable[*pInput++ << 1];                                    bitCount += pEntry[CountIndex];                                    bitValue <<= pEntry[CountIndex];                                  bitValue |= pEntry[ValueIndex];                                    while (bitCount >= 8)                                  {                                      bitCount -= 8;                                        if (pOutput < pOutputEnd)                                      {                                          *pOutput++ = (byte) (bitValue >> bitCount);                                      }                                      else                                      {                                          return null;                                      }                                  }                              }                                // terminal code                              pEntry = &pTable[0x200];                                bitCount += pEntry[CountIndex];                                bitValue <<= pEntry[CountIndex];                              bitValue |= pEntry[ValueIndex];                                // align on byte boundary                              if ((bitCount & 7) != 0)                              {                                  bitValue <<= (8 - (bitCount & 7));                                  bitCount += (8 - (bitCount & 7));                              }                                while (bitCount >= 8)                              {                                  bitCount -= 8;                                    if (pOutput < pOutputEnd)                                  {                                      *pOutput++ = (byte) (bitValue >> bitCount);                                  }                                  else                                  {                                      return null;                                  }                              }                                length = (int) (pOutput - pOutputBuffer);                              return m_outputBuffer;                          }                      }                  }              }
Magic Number,OpenUO.Core.Net.Compression,ZlibCompression,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\Compression\ZlibDecompression.cs,Compress,The following statement contains a magic number: lock (m_syncRoot)              {                  var bitCount = 0;                  var bitValue = 0;                    fixed (int* pTable = m_huffmanTable)                  {                      int* pEntry;                        fixed (byte* pInputBuffer = input)                      {                          byte* pInput = pInputBuffer + offset' pInputEnd = pInput + count;                            fixed (byte* pOutputBuffer = m_outputBuffer)                          {                              byte* pOutput = pOutputBuffer' pOutputEnd = pOutput + BufferSize;                                while (pInput < pInputEnd)                              {                                  pEntry = &pTable[*pInput++ << 1];                                    bitCount += pEntry[CountIndex];                                    bitValue <<= pEntry[CountIndex];                                  bitValue |= pEntry[ValueIndex];                                    while (bitCount >= 8)                                  {                                      bitCount -= 8;                                        if (pOutput < pOutputEnd)                                      {                                          *pOutput++ = (byte) (bitValue >> bitCount);                                      }                                      else                                      {                                          return null;                                      }                                  }                              }                                // terminal code                              pEntry = &pTable[0x200];                                bitCount += pEntry[CountIndex];                                bitValue <<= pEntry[CountIndex];                              bitValue |= pEntry[ValueIndex];                                // align on byte boundary                              if ((bitCount & 7) != 0)                              {                                  bitValue <<= (8 - (bitCount & 7));                                  bitCount += (8 - (bitCount & 7));                              }                                while (bitCount >= 8)                              {                                  bitCount -= 8;                                    if (pOutput < pOutputEnd)                                  {                                      *pOutput++ = (byte) (bitValue >> bitCount);                                  }                                  else                                  {                                      return null;                                  }                              }                                length = (int) (pOutput - pOutputBuffer);                              return m_outputBuffer;                          }                      }                  }              }
Magic Number,OpenUO.Core.Net.Compression,ZlibCompression,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\Compression\ZlibDecompression.cs,Compress,The following statement contains a magic number: lock (m_syncRoot)              {                  var bitCount = 0;                  var bitValue = 0;                    fixed (int* pTable = m_huffmanTable)                  {                      int* pEntry;                        fixed (byte* pInputBuffer = input)                      {                          byte* pInput = pInputBuffer + offset' pInputEnd = pInput + count;                            fixed (byte* pOutputBuffer = m_outputBuffer)                          {                              byte* pOutput = pOutputBuffer' pOutputEnd = pOutput + BufferSize;                                while (pInput < pInputEnd)                              {                                  pEntry = &pTable[*pInput++ << 1];                                    bitCount += pEntry[CountIndex];                                    bitValue <<= pEntry[CountIndex];                                  bitValue |= pEntry[ValueIndex];                                    while (bitCount >= 8)                                  {                                      bitCount -= 8;                                        if (pOutput < pOutputEnd)                                      {                                          *pOutput++ = (byte) (bitValue >> bitCount);                                      }                                      else                                      {                                          return null;                                      }                                  }                              }                                // terminal code                              pEntry = &pTable[0x200];                                bitCount += pEntry[CountIndex];                                bitValue <<= pEntry[CountIndex];                              bitValue |= pEntry[ValueIndex];                                // align on byte boundary                              if ((bitCount & 7) != 0)                              {                                  bitValue <<= (8 - (bitCount & 7));                                  bitCount += (8 - (bitCount & 7));                              }                                while (bitCount >= 8)                              {                                  bitCount -= 8;                                    if (pOutput < pOutputEnd)                                  {                                      *pOutput++ = (byte) (bitValue >> bitCount);                                  }                                  else                                  {                                      return null;                                  }                              }                                length = (int) (pOutput - pOutputBuffer);                              return m_outputBuffer;                          }                      }                  }              }
Magic Number,OpenUO.Core.Net.Compression,ZlibCompression,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\Compression\ZlibDecompression.cs,Compress,The following statement contains a magic number: lock (m_syncRoot)              {                  var bitCount = 0;                  var bitValue = 0;                    fixed (int* pTable = m_huffmanTable)                  {                      int* pEntry;                        fixed (byte* pInputBuffer = input)                      {                          byte* pInput = pInputBuffer + offset' pInputEnd = pInput + count;                            fixed (byte* pOutputBuffer = m_outputBuffer)                          {                              byte* pOutput = pOutputBuffer' pOutputEnd = pOutput + BufferSize;                                while (pInput < pInputEnd)                              {                                  pEntry = &pTable[*pInput++ << 1];                                    bitCount += pEntry[CountIndex];                                    bitValue <<= pEntry[CountIndex];                                  bitValue |= pEntry[ValueIndex];                                    while (bitCount >= 8)                                  {                                      bitCount -= 8;                                        if (pOutput < pOutputEnd)                                      {                                          *pOutput++ = (byte) (bitValue >> bitCount);                                      }                                      else                                      {                                          return null;                                      }                                  }                              }                                // terminal code                              pEntry = &pTable[0x200];                                bitCount += pEntry[CountIndex];                                bitValue <<= pEntry[CountIndex];                              bitValue |= pEntry[ValueIndex];                                // align on byte boundary                              if ((bitCount & 7) != 0)                              {                                  bitValue <<= (8 - (bitCount & 7));                                  bitCount += (8 - (bitCount & 7));                              }                                while (bitCount >= 8)                              {                                  bitCount -= 8;                                    if (pOutput < pOutputEnd)                                  {                                      *pOutput++ = (byte) (bitValue >> bitCount);                                  }                                  else                                  {                                      return null;                                  }                              }                                length = (int) (pOutput - pOutputBuffer);                              return m_outputBuffer;                          }                      }                  }              }
Magic Number,OpenUO.Core.Net.Compression,ZlibCompression,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\Compression\ZlibDecompression.cs,Compress,The following statement contains a magic number: lock (m_syncRoot)              {                  var bitCount = 0;                  var bitValue = 0;                    fixed (int* pTable = m_huffmanTable)                  {                      int* pEntry;                        fixed (byte* pInputBuffer = input)                      {                          byte* pInput = pInputBuffer + offset' pInputEnd = pInput + count;                            fixed (byte* pOutputBuffer = m_outputBuffer)                          {                              byte* pOutput = pOutputBuffer' pOutputEnd = pOutput + BufferSize;                                while (pInput < pInputEnd)                              {                                  pEntry = &pTable[*pInput++ << 1];                                    bitCount += pEntry[CountIndex];                                    bitValue <<= pEntry[CountIndex];                                  bitValue |= pEntry[ValueIndex];                                    while (bitCount >= 8)                                  {                                      bitCount -= 8;                                        if (pOutput < pOutputEnd)                                      {                                          *pOutput++ = (byte) (bitValue >> bitCount);                                      }                                      else                                      {                                          return null;                                      }                                  }                              }                                // terminal code                              pEntry = &pTable[0x200];                                bitCount += pEntry[CountIndex];                                bitValue <<= pEntry[CountIndex];                              bitValue |= pEntry[ValueIndex];                                // align on byte boundary                              if ((bitCount & 7) != 0)                              {                                  bitValue <<= (8 - (bitCount & 7));                                  bitCount += (8 - (bitCount & 7));                              }                                while (bitCount >= 8)                              {                                  bitCount -= 8;                                    if (pOutput < pOutputEnd)                                  {                                      *pOutput++ = (byte) (bitValue >> bitCount);                                  }                                  else                                  {                                      return null;                                  }                              }                                length = (int) (pOutput - pOutputBuffer);                              return m_outputBuffer;                          }                      }                  }              }
Magic Number,OpenUO.Core.Net.Compression,ZlibCompression,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\Compression\ZlibDecompression.cs,Compress,The following statement contains a magic number: lock (m_syncRoot)              {                  var bitCount = 0;                  var bitValue = 0;                    fixed (int* pTable = m_huffmanTable)                  {                      int* pEntry;                        fixed (byte* pInputBuffer = input)                      {                          byte* pInput = pInputBuffer + offset' pInputEnd = pInput + count;                            fixed (byte* pOutputBuffer = m_outputBuffer)                          {                              byte* pOutput = pOutputBuffer' pOutputEnd = pOutput + BufferSize;                                while (pInput < pInputEnd)                              {                                  pEntry = &pTable[*pInput++ << 1];                                    bitCount += pEntry[CountIndex];                                    bitValue <<= pEntry[CountIndex];                                  bitValue |= pEntry[ValueIndex];                                    while (bitCount >= 8)                                  {                                      bitCount -= 8;                                        if (pOutput < pOutputEnd)                                      {                                          *pOutput++ = (byte) (bitValue >> bitCount);                                      }                                      else                                      {                                          return null;                                      }                                  }                              }                                // terminal code                              pEntry = &pTable[0x200];                                bitCount += pEntry[CountIndex];                                bitValue <<= pEntry[CountIndex];                              bitValue |= pEntry[ValueIndex];                                // align on byte boundary                              if ((bitCount & 7) != 0)                              {                                  bitValue <<= (8 - (bitCount & 7));                                  bitCount += (8 - (bitCount & 7));                              }                                while (bitCount >= 8)                              {                                  bitCount -= 8;                                    if (pOutput < pOutputEnd)                                  {                                      *pOutput++ = (byte) (bitValue >> bitCount);                                  }                                  else                                  {                                      return null;                                  }                              }                                length = (int) (pOutput - pOutputBuffer);                              return m_outputBuffer;                          }                      }                  }              }
Magic Number,OpenUO.Core.Net,PacketReader,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketReader.cs,PacketReader,The following statement contains a magic number: Index = fixedSize ? 1 : 3;
Magic Number,OpenUO.Core.Net,PacketReader,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketReader.cs,CreateInstance,The following statement contains a magic number: lock (m_pool)              {                  if (m_pool.Count > 0)                  {                      reader = m_pool.Pop();                        if (reader != null)                      {                          reader.Buffer = buffer;                          reader.Size = length;                          reader.Index = fixedSize ? 1 : 3;                      }                  }              }
Magic Number,OpenUO.Core.Net,PacketReader,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketReader.cs,ReadInt32,The following statement contains a magic number: if ((Index + 4) > Size)              {                  return 0;              }
Magic Number,OpenUO.Core.Net,PacketReader,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketReader.cs,ReadInt32,The following statement contains a magic number: return (Buffer[Index++] << 24)                     | (Buffer[Index++] << 16)                     | (Buffer[Index++] << 8)                     | Buffer[Index++];
Magic Number,OpenUO.Core.Net,PacketReader,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketReader.cs,ReadInt32,The following statement contains a magic number: return (Buffer[Index++] << 24)                     | (Buffer[Index++] << 16)                     | (Buffer[Index++] << 8)                     | Buffer[Index++];
Magic Number,OpenUO.Core.Net,PacketReader,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketReader.cs,ReadInt32,The following statement contains a magic number: return (Buffer[Index++] << 24)                     | (Buffer[Index++] << 16)                     | (Buffer[Index++] << 8)                     | Buffer[Index++];
Magic Number,OpenUO.Core.Net,PacketReader,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketReader.cs,ReadInt16,The following statement contains a magic number: if ((Index + 2) > Size)              {                  return 0;              }
Magic Number,OpenUO.Core.Net,PacketReader,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketReader.cs,ReadInt16,The following statement contains a magic number: return (short) ((Buffer[Index++] << 8) | Buffer[Index++]);
Magic Number,OpenUO.Core.Net,PacketReader,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketReader.cs,ReadUInt32,The following statement contains a magic number: if ((Index + 4) > Size)              {                  return 0;              }
Magic Number,OpenUO.Core.Net,PacketReader,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketReader.cs,ReadUInt32,The following statement contains a magic number: return (uint) ((Buffer[Index++] << 24) | (Buffer[Index++] << 16) | (Buffer[Index++] << 8) | Buffer[Index++]);
Magic Number,OpenUO.Core.Net,PacketReader,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketReader.cs,ReadUInt32,The following statement contains a magic number: return (uint) ((Buffer[Index++] << 24) | (Buffer[Index++] << 16) | (Buffer[Index++] << 8) | Buffer[Index++]);
Magic Number,OpenUO.Core.Net,PacketReader,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketReader.cs,ReadUInt32,The following statement contains a magic number: return (uint) ((Buffer[Index++] << 24) | (Buffer[Index++] << 16) | (Buffer[Index++] << 8) | Buffer[Index++]);
Magic Number,OpenUO.Core.Net,PacketReader,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketReader.cs,ReadUInt16,The following statement contains a magic number: if ((Index + 2) > Size)              {                  return 0;              }
Magic Number,OpenUO.Core.Net,PacketReader,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketReader.cs,ReadUInt16,The following statement contains a magic number: return (ushort) ((Buffer[Index++] << 8) | Buffer[Index++]);
Magic Number,OpenUO.Core.Net,PacketReader,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketReader.cs,ReadUnicodeStringLE,The following statement contains a magic number: while ((Index + 1) < Size && (c = (Buffer[Index++] | (Buffer[Index++] << 8))) != 0)              {                  sb.Append((char) c);              }
Magic Number,OpenUO.Core.Net,PacketReader,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketReader.cs,ReadUnicodeStringLESafe,The following statement contains a magic number: while ((Index + 1) < bound && (c = (Buffer[Index++] | (Buffer[Index++] << 8))) != 0)              {                  if (IsSafeChar(c))                  {                      sb.Append((char) c);                  }              }
Magic Number,OpenUO.Core.Net,PacketReader,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketReader.cs,ReadUnicodeStringLESafe,The following statement contains a magic number: while ((Index + 1) < Size && (c = (Buffer[Index++] | (Buffer[Index++] << 8))) != 0)              {                  if (IsSafeChar(c))                  {                      sb.Append((char) c);                  }              }
Magic Number,OpenUO.Core.Net,PacketReader,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketReader.cs,ReadUnicodeStringSafe,The following statement contains a magic number: while ((Index + 1) < Size && (c = ((Buffer[Index++] << 8) | Buffer[Index++])) != 0)              {                  if (IsSafeChar(c))                  {                      sb.Append((char) c);                  }              }
Magic Number,OpenUO.Core.Net,PacketReader,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketReader.cs,ReadUnicodeString,The following statement contains a magic number: while ((Index + 1) < Size && (c = ((Buffer[Index++] << 8) | Buffer[Index++])) != 0)              {                  sb.Append((char) c);              }
Magic Number,OpenUO.Core.Net,PacketReader,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketReader.cs,ReadUnicodeStringSafe,The following statement contains a magic number: while ((Index + 1) < bound && (c = ((Buffer[Index++] << 8) | Buffer[Index++])) != 0)              {                  if (IsSafeChar(c))                  {                      sb.Append((char) c);                  }              }
Magic Number,OpenUO.Core.Net,PacketReader,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketReader.cs,ReadUnicodeStringSafeReverse,The following statement contains a magic number: while ((Index + 1) < Size && (c = ((Buffer[Index++]) | Buffer[Index++] << 8)) != 0)              {                  if (IsSafeChar(c))                  {                      sb.Append((char) c);                  }              }
Magic Number,OpenUO.Core.Net,PacketReader,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketReader.cs,ReadUnicodeStringReverse,The following statement contains a magic number: while ((Index + 1) < bound && (c = ((Buffer[Index++]) | Buffer[Index++] << 8)) != 0)              {                  sb.Append((char) c);              }
Magic Number,OpenUO.Core.Net,PacketReader,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketReader.cs,ReadUnicodeString,The following statement contains a magic number: while ((Index + 1) < bound && (c = ((Buffer[Index++] << 8) | Buffer[Index++])) != 0)              {                  sb.Append((char) c);              }
Magic Number,OpenUO.Core.Net,PacketWriter,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketWriter.cs,CreateInstance,The following statement contains a magic number: return CreateInstance(32);
Magic Number,OpenUO.Core.Net,PacketWriter,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketWriter.cs,Write,The following statement contains a magic number: m_buffer[0] = (byte) (value >> 8);
Magic Number,OpenUO.Core.Net,PacketWriter,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketWriter.cs,Write,The following statement contains a magic number: BaseStream.Write(m_buffer' 0' 2);
Magic Number,OpenUO.Core.Net,PacketWriter,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketWriter.cs,Write,The following statement contains a magic number: m_buffer[0] = (byte) (value >> 8);
Magic Number,OpenUO.Core.Net,PacketWriter,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketWriter.cs,Write,The following statement contains a magic number: BaseStream.Write(m_buffer' 0' 2);
Magic Number,OpenUO.Core.Net,PacketWriter,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketWriter.cs,Write,The following statement contains a magic number: m_buffer[0] = (byte) (value >> 24);
Magic Number,OpenUO.Core.Net,PacketWriter,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketWriter.cs,Write,The following statement contains a magic number: m_buffer[1] = (byte) (value >> 16);
Magic Number,OpenUO.Core.Net,PacketWriter,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketWriter.cs,Write,The following statement contains a magic number: m_buffer[2] = (byte) (value >> 8);
Magic Number,OpenUO.Core.Net,PacketWriter,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketWriter.cs,Write,The following statement contains a magic number: m_buffer[2] = (byte) (value >> 8);
Magic Number,OpenUO.Core.Net,PacketWriter,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketWriter.cs,Write,The following statement contains a magic number: m_buffer[3] = (byte) value;
Magic Number,OpenUO.Core.Net,PacketWriter,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketWriter.cs,Write,The following statement contains a magic number: BaseStream.Write(m_buffer' 0' 4);
Magic Number,OpenUO.Core.Net,PacketWriter,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketWriter.cs,Write,The following statement contains a magic number: m_buffer[0] = (byte) (value >> 24);
Magic Number,OpenUO.Core.Net,PacketWriter,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketWriter.cs,Write,The following statement contains a magic number: m_buffer[1] = (byte) (value >> 16);
Magic Number,OpenUO.Core.Net,PacketWriter,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketWriter.cs,Write,The following statement contains a magic number: m_buffer[2] = (byte) (value >> 8);
Magic Number,OpenUO.Core.Net,PacketWriter,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketWriter.cs,Write,The following statement contains a magic number: m_buffer[2] = (byte) (value >> 8);
Magic Number,OpenUO.Core.Net,PacketWriter,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketWriter.cs,Write,The following statement contains a magic number: m_buffer[3] = (byte) value;
Magic Number,OpenUO.Core.Net,PacketWriter,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketWriter.cs,Write,The following statement contains a magic number: BaseStream.Write(m_buffer' 0' 4);
Magic Number,OpenUO.Core.Net,PacketWriter,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketWriter.cs,WriteLittleUniNull,The following statement contains a magic number: BaseStream.SetLength(BaseStream.Length + ((length + 1)*2));
Magic Number,OpenUO.Core.Net,PacketWriter,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketWriter.cs,WriteLittleUniNull,The following statement contains a magic number: BaseStream.Position += 2;
Magic Number,OpenUO.Core.Net,PacketWriter,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketWriter.cs,WriteLittleUniFixed,The following statement contains a magic number: size *= 2;
Magic Number,OpenUO.Core.Net,PacketWriter,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketWriter.cs,WriteLittleUniFixed,The following statement contains a magic number: if ((length*2) >= size)              {                  BaseStream.Position += Encoding.Unicode.GetBytes(value' 0' length' BaseStream.GetBuffer()' (int) BaseStream.Position);              }              else              {                  Encoding.Unicode.GetBytes(value' 0' length' BaseStream.GetBuffer()' (int) BaseStream.Position);                  BaseStream.Position += size;              }
Magic Number,OpenUO.Core.Net,PacketWriter,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketWriter.cs,WriteBigUniNull,The following statement contains a magic number: BaseStream.SetLength(BaseStream.Length + ((length + 1)*2));
Magic Number,OpenUO.Core.Net,PacketWriter,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketWriter.cs,WriteBigUniNull,The following statement contains a magic number: BaseStream.Position += 2;
Magic Number,OpenUO.Core.Net,PacketWriter,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketWriter.cs,WriteBigUniFixed,The following statement contains a magic number: size *= 2;
Magic Number,OpenUO.Core.Net,PacketWriter,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketWriter.cs,WriteBigUniFixed,The following statement contains a magic number: if ((length*2) >= size)              {                  BaseStream.Position += Encoding.BigEndianUnicode.GetBytes(value' 0' length' BaseStream.GetBuffer()' (int) BaseStream.Position);              }              else              {                  Encoding.BigEndianUnicode.GetBytes(value' 0' length' BaseStream.GetBuffer()' (int) BaseStream.Position);                  BaseStream.Position += size;              }
Missing Default,OpenUO.Core.Net,PacketReader,C:\repos\fdsprod_OpenUO\OpenUO.Ultima.Network\IO\PacketReader.cs,Seek,The following switch statement is missing a default case: switch (origin)              {                  case SeekOrigin.Begin:                      Index = offset;                      break;                  case SeekOrigin.Current:                      Index += offset;                      break;                  case SeekOrigin.End:                      Index = Size - offset;                      break;              }
