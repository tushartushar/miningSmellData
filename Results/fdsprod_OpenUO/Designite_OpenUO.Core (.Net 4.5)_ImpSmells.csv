Implementation smell,Namespace,Class,File,Method,Description
Long Method,OpenUO.Core.Patterns,Container,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,ResolveInternal,The method has 107 lines of code.
Complex Method,OpenUO.Core,StreamExtensions,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Extensions\StreamExtensions.cs,ToFormattedString,Cyclomatic complexity of the method is 10
Complex Method,OpenUO.Core,StreamExtensions,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Extensions\StreamExtensions.cs,ToFormattedString,Cyclomatic complexity of the method is 10
Complex Method,OpenUO.Core.Patterns,ExecutionChainBase<T>,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\Chaining\ExecutionChainBase.cs,ComputeChainSequence,Cyclomatic complexity of the method is 8
Complex Method,OpenUO.Core.Patterns,GenericMethodCacheKey,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,Equals,Cyclomatic complexity of the method is 10
Complex Method,OpenUO.Core.Patterns,Container,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,CanResolveInternal,Cyclomatic complexity of the method is 13
Complex Method,OpenUO.Core.Patterns,Container,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,ResolveInternal,Cyclomatic complexity of the method is 12
Complex Method,OpenUO.Core.Reflection,BaseMethodInvoker,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Reflection\BaseMethodInvoker.cs,GetMethodInvoker,Cyclomatic complexity of the method is 11
Complex Method,OpenUO.Core.Reflection,BasePropertyAccessor,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Reflection\BasePropertyAccessor.cs,GetMethodInvoker4Set,Cyclomatic complexity of the method is 11
Long Parameter List,OpenUO.Core.IO,BufferPool,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\IO\BufferPool.cs,GetInfo,The method has 6 parameters. Parameters: name' freeCount' initialCapacity' currentCapacity' bufferSize' misses
Long Parameter List,OpenUO.Core.IO,ZlibCompression,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\IO\ZlibCompression.cs,Pack,The method has 5 parameters. Parameters: dest' destLength' source' sourceLength' quality
Long Parameter List,OpenUO.Core.IO,ICompressor,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\IO\ZlibCompression.cs,Compress,The method has 5 parameters. Parameters: dest' destLength' source' sourceLength' quality
Long Parameter List,OpenUO.Core.IO,Compressor32,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\IO\ZlibCompression.cs,Compress,The method has 5 parameters. Parameters: dest' destLength' source' sourceLength' quality
Long Parameter List,OpenUO.Core.IO,Compressor32,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\IO\ZlibCompression.cs,compress2,The method has 5 parameters. Parameters: dest' destLength' source' sourceLength' quality
Long Parameter List,OpenUO.Core.IO,Compressor64,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\IO\ZlibCompression.cs,Compress,The method has 5 parameters. Parameters: dest' destLength' source' sourceLength' quality
Long Parameter List,OpenUO.Core.IO,Compressor64,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\IO\ZlibCompression.cs,compress2,The method has 5 parameters. Parameters: dest' destLength' source' sourceLength' quality
Long Parameter List,Framework,NativeMethods,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\NativeMethods.cs,CallWindowProc,The method has 5 parameters. Parameters: lpPrevWndFunc' hWnd' Msg' wParam' lParam
Long Parameter List,Framework,NativeMethods,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\NativeMethods.cs,MultiByteToWideChar,The method has 6 parameters. Parameters: CodePage' dwFlags' lpMultiByteStr' cchMultiByte' lpWideCharStr' cchWideChar
Long Parameter List,OpenUO.Core.Patterns,TypeExtensions,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,GetGenericMethod,The method has 5 parameters. Parameters: sourceType' bindingFlags' methodName' genericTypes' parameterTypes
Long Parameter List,OpenUO.Core.Patterns,TypeExtensions,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,GetMethod,The method has 5 parameters. Parameters: sourceType' bindingFlags' methodName' genericTypes' parameterTypes
Long Parameter List,OpenUO.Core.Patterns,Container,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,TryResolve,The method has 5 parameters. Parameters: resolveType' name' parameters' options' resolvedType
Long Parameter List,OpenUO.Core.Patterns,Container,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,ConstructType,The method has 5 parameters. Parameters: requestedType' implementationType' constructor' parameters' options
Long Parameter List,OpenUO.Core.Patterns,IContainer,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\IContainer.cs,TryResolve,The method has 5 parameters. Parameters: resolveType' name' parameters' options' resolvedType
Long Identifier,OpenUO.Core.Patterns,Container,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,AutoRegister,The length of the parameter ignoreDuplicateImplementations is 30.
Long Identifier,OpenUO.Core.Patterns,Container,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,AutoRegister,The length of the parameter ignoreDuplicateImplementations is 30.
Long Identifier,OpenUO.Core.Patterns,Container,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,AutoRegister,The length of the parameter ignoreDuplicateImplementations is 30.
Long Identifier,OpenUO.Core.Patterns,Container,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,AutoRegister,The length of the parameter ignoreDuplicateImplementations is 30.
Long Identifier,OpenUO.Core.Patterns,Container,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,AutoRegisterInternal,The length of the parameter ignoreDuplicateImplementations is 30.
Long Identifier,OpenUO.Core.Patterns,IContainer,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\IContainer.cs,AutoRegister,The length of the parameter ignoreDuplicateImplementations is 30.
Long Identifier,OpenUO.Core.Patterns,IContainer,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\IContainer.cs,AutoRegister,The length of the parameter ignoreDuplicateImplementations is 30.
Long Identifier,OpenUO.Core.Patterns,IContainer,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\IContainer.cs,AutoRegister,The length of the parameter ignoreDuplicateImplementations is 30.
Long Identifier,OpenUO.Core.Patterns,IContainer,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\IContainer.cs,AutoRegister,The length of the parameter ignoreDuplicateImplementations is 30.
Long Statement,OpenUO.Core.Collections,SafeDictionary<TKey;TValue>,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Collections\SafeDictionary.cs,Dispose,The length of the statement  "                    IEnumerable<IDisposable> disposableItems = _dictionary.Values.Where(o => o is IDisposable).Cast<IDisposable>().ToArray(); " is 121.
Long Statement,OpenUO.Core.Patterns,ExecutionChainBase<T>,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\Chaining\ExecutionChainBase.cs,ComputeChainSequence,The length of the statement  "                                "Cannot execute chain '{0}' because step '{1}' has a mandatory dependency on step '{2}' and '{2}' cannot be found in the {0} chain."' " is 133.
Long Statement,OpenUO.Core.Patterns,Container,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,AutoRegister,The length of the statement  "            AutoRegisterInternal(AppDomain.CurrentDomain.GetAssemblies().Where(a => !IsIgnoredAssembly(a))' true' registrationPredicate); " is 125.
Long Statement,OpenUO.Core.Patterns,Container,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,AutoRegister,The length of the statement  "            AutoRegisterInternal(AppDomain.CurrentDomain.GetAssemblies().Where(a => !IsIgnoredAssembly(a))' ignoreDuplicateImplementations' null); " is 134.
Long Statement,OpenUO.Core.Patterns,Container,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,AutoRegister,The length of the statement  "                AppDomain.CurrentDomain.GetAssemblies().Where(a => !IsIgnoredAssembly(a))' ignoreDuplicateImplementations' registrationPredicate); " is 130.
Long Statement,OpenUO.Core.Patterns,Container,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,AutoRegister,The length of the statement  "            AutoRegisterInternal(new Assembly[] { this.GetType().Assembly }' ignoreDuplicateImplementations' registrationPredicate); " is 120.
Long Statement,OpenUO.Core.Patterns,Container,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,Register,The length of the statement  "            return RegisterInternal(registerType' string.Empty' new InstanceFactory(registerType' registerImplementation' instance)); " is 121.
Long Statement,OpenUO.Core.Patterns,Container,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,Resolve,The length of the statement  "            return ResolveInternal(new TypeRegistration(resolveType' name)' NamedParameterOverloads.Default' ResolveOptions.Default); " is 121.
Long Statement,OpenUO.Core.Patterns,Container,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,CanResolve,The length of the statement  "            return CanResolveInternal(new TypeRegistration(resolveType' name)' NamedParameterOverloads.Default' ResolveOptions.Default); " is 124.
Long Statement,OpenUO.Core.Patterns,Container,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,CanResolveInternal,The length of the statement  "            if (!String.IsNullOrEmpty(name) && options.NamedResolutionFailureAction == NamedResolutionFailureActions.AttemptUnnamedResolution) " is 130.
Long Statement,OpenUO.Core.Patterns,Container,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,ResolveInternal,The length of the statement  "            if (!String.IsNullOrEmpty(registration.Name) && options.NamedResolutionFailureAction == NamedResolutionFailureActions.Fail) " is 123.
Long Statement,OpenUO.Core.Patterns,Container,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,ResolveInternal,The length of the statement  "                (registration.Type.IsGenericType && options.UnregisteredResolutionAction == UnregisteredResolutionActions.GenericsOnly)) " is 120.
Long Statement,OpenUO.Core.Patterns,Container,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,ConstructType,The length of the statement  "                constructor = GetBestConstructor(typeToConstruct' parameters' options) ?? GetTypeConstructors(typeToConstruct).LastOrDefault(); " is 127.
Long Statement,OpenUO.Core.Patterns,Container,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,BuildUpInternal,The length of the statement  "                            input' ResolveInternal(new TypeRegistration(property.PropertyType)' NamedParameterOverloads.Default' resolveOptions)' null); " is 124.
Long Statement,OpenUO.Core.Patterns,Container,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,ResolveAllInternal,The length of the statement  "            return registrations.Select(registration => ResolveInternal(registration' NamedParameterOverloads.Default' ResolveOptions.Default)); " is 132.
Long Statement,OpenUO.Core.Patterns,DelegateFactory,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,SetConstructor,The length of the statement  "                throw new IoCConstructorResolutionException("Constructor selection is not possible for delegate factory registrations"); " is 120.
Long Statement,OpenUO.Core.Patterns,WeakDelegateFactory,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,SetConstructor,The length of the statement  "                throw new IoCConstructorResolutionException("Constructor selection is not possible for delegate factory registrations"); " is 120.
Long Statement,OpenUO.Core.Patterns,InstanceFactory,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,SetConstructor,The length of the statement  "                throw new IoCConstructorResolutionException("Constructor selection is not possible for instance factory registrations"); " is 120.
Long Statement,OpenUO.Core.Patterns,WeakInstanceFactory,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,SetConstructor,The length of the statement  "                throw new IoCConstructorResolutionException("Constructor selection is not possible for instance factory registrations"); " is 120.
Long Statement,OpenUO.Core.Reflection,BaseFieldAccessor,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Reflection\BaseFieldAccessor.cs,SetFieldInvoker,The length of the statement  "                return (FieldFastSetInvokeHandler<TargetType' FieldType>) dm.CreateDelegate(typeof (FieldFastSetInvokeHandler<TargetType' FieldType>)); " is 135.
Empty Catch Block,OpenUO.Core,ConsoleManager,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\ConsoleManager.cs,PushColor,The method has an empty catch block.
Empty Catch Block,OpenUO.Core,ConsoleManager,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\ConsoleManager.cs,PopColor,The method has an empty catch block.
Empty Catch Block,OpenUO.Core.Patterns,Container,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,AutoRegisterInternal,The method has an empty catch block.
Empty Catch Block,OpenUO.Core.Patterns,Container,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,AutoRegisterInternal,The method has an empty catch block.
Empty Catch Block,OpenUO.Core.Patterns,Container,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,BuildUpInternal,The method has an empty catch block.
Magic Number,OpenUO.Core,StreamExtensions,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Extensions\StreamExtensions.cs,ToFormattedString,The following statement contains a magic number: var whole = length >> 4;
Magic Number,OpenUO.Core,StreamExtensions,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Extensions\StreamExtensions.cs,ToFormattedString,The following statement contains a magic number: for (var i = 0; i < whole; ++i' byteIndex += 16)              {                  var bytes = new StringBuilder(49);                  var chars = new StringBuilder(16);                    for (var j = 0; j < 16; ++j)                  {                      var c = input.ReadByte();                        bytes.Append(c.ToString("X2"));                        if (j != 7)                      {                          bytes.Append(' ');                      }                      else                      {                          bytes.Append("  ");                      }                        if (c >= 0x20 && c < 0x80)                      {                          chars.Append((char) c);                      }                      else                      {                          chars.Append('.');                      }                  }                    builder.Append(byteIndex.ToString("X4"));                  builder.Append("   ");                  builder.Append(bytes);                  builder.Append("  ");                  builder.AppendLine(chars.ToString());              }
Magic Number,OpenUO.Core,StreamExtensions,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Extensions\StreamExtensions.cs,ToFormattedString,The following statement contains a magic number: for (var i = 0; i < whole; ++i' byteIndex += 16)              {                  var bytes = new StringBuilder(49);                  var chars = new StringBuilder(16);                    for (var j = 0; j < 16; ++j)                  {                      var c = input.ReadByte();                        bytes.Append(c.ToString("X2"));                        if (j != 7)                      {                          bytes.Append(' ');                      }                      else                      {                          bytes.Append("  ");                      }                        if (c >= 0x20 && c < 0x80)                      {                          chars.Append((char) c);                      }                      else                      {                          chars.Append('.');                      }                  }                    builder.Append(byteIndex.ToString("X4"));                  builder.Append("   ");                  builder.Append(bytes);                  builder.Append("  ");                  builder.AppendLine(chars.ToString());              }
Magic Number,OpenUO.Core,StreamExtensions,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Extensions\StreamExtensions.cs,ToFormattedString,The following statement contains a magic number: for (var i = 0; i < whole; ++i' byteIndex += 16)              {                  var bytes = new StringBuilder(49);                  var chars = new StringBuilder(16);                    for (var j = 0; j < 16; ++j)                  {                      var c = input.ReadByte();                        bytes.Append(c.ToString("X2"));                        if (j != 7)                      {                          bytes.Append(' ');                      }                      else                      {                          bytes.Append("  ");                      }                        if (c >= 0x20 && c < 0x80)                      {                          chars.Append((char) c);                      }                      else                      {                          chars.Append('.');                      }                  }                    builder.Append(byteIndex.ToString("X4"));                  builder.Append("   ");                  builder.Append(bytes);                  builder.Append("  ");                  builder.AppendLine(chars.ToString());              }
Magic Number,OpenUO.Core,StreamExtensions,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Extensions\StreamExtensions.cs,ToFormattedString,The following statement contains a magic number: for (var i = 0; i < whole; ++i' byteIndex += 16)              {                  var bytes = new StringBuilder(49);                  var chars = new StringBuilder(16);                    for (var j = 0; j < 16; ++j)                  {                      var c = input.ReadByte();                        bytes.Append(c.ToString("X2"));                        if (j != 7)                      {                          bytes.Append(' ');                      }                      else                      {                          bytes.Append("  ");                      }                        if (c >= 0x20 && c < 0x80)                      {                          chars.Append((char) c);                      }                      else                      {                          chars.Append('.');                      }                  }                    builder.Append(byteIndex.ToString("X4"));                  builder.Append("   ");                  builder.Append(bytes);                  builder.Append("  ");                  builder.AppendLine(chars.ToString());              }
Magic Number,OpenUO.Core,StreamExtensions,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Extensions\StreamExtensions.cs,ToFormattedString,The following statement contains a magic number: for (var i = 0; i < whole; ++i' byteIndex += 16)              {                  var bytes = new StringBuilder(49);                  var chars = new StringBuilder(16);                    for (var j = 0; j < 16; ++j)                  {                      var c = input.ReadByte();                        bytes.Append(c.ToString("X2"));                        if (j != 7)                      {                          bytes.Append(' ');                      }                      else                      {                          bytes.Append("  ");                      }                        if (c >= 0x20 && c < 0x80)                      {                          chars.Append((char) c);                      }                      else                      {                          chars.Append('.');                      }                  }                    builder.Append(byteIndex.ToString("X4"));                  builder.Append("   ");                  builder.Append(bytes);                  builder.Append("  ");                  builder.AppendLine(chars.ToString());              }
Magic Number,OpenUO.Core,StreamExtensions,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Extensions\StreamExtensions.cs,ToFormattedString,The following statement contains a magic number: if (rem != 0)              {                  var bytes = new StringBuilder(49);                  var chars = new StringBuilder(rem);                    for (var j = 0; j < 16; ++j)                  {                      if (j < rem)                      {                          var c = input.ReadByte();                            bytes.Append(c.ToString("X2"));                            if (j != 7)                          {                              bytes.Append(' ');                          }                          else                          {                              bytes.Append("  ");                          }                            if (c >= 0x20 && c < 0x80)                          {                              chars.Append((char) c);                          }                          else                          {                              chars.Append('.');                          }                      }                      else                      {                          bytes.Append("   ");                      }                  }                    builder.Append(byteIndex.ToString("X4"));                  builder.Append("   ");                  builder.Append(bytes);                  builder.Append("  ");                  builder.AppendLine(chars.ToString());              }
Magic Number,OpenUO.Core,StreamExtensions,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Extensions\StreamExtensions.cs,ToFormattedString,The following statement contains a magic number: if (rem != 0)              {                  var bytes = new StringBuilder(49);                  var chars = new StringBuilder(rem);                    for (var j = 0; j < 16; ++j)                  {                      if (j < rem)                      {                          var c = input.ReadByte();                            bytes.Append(c.ToString("X2"));                            if (j != 7)                          {                              bytes.Append(' ');                          }                          else                          {                              bytes.Append("  ");                          }                            if (c >= 0x20 && c < 0x80)                          {                              chars.Append((char) c);                          }                          else                          {                              chars.Append('.');                          }                      }                      else                      {                          bytes.Append("   ");                      }                  }                    builder.Append(byteIndex.ToString("X4"));                  builder.Append("   ");                  builder.Append(bytes);                  builder.Append("  ");                  builder.AppendLine(chars.ToString());              }
Magic Number,OpenUO.Core,StreamExtensions,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Extensions\StreamExtensions.cs,ToFormattedString,The following statement contains a magic number: if (rem != 0)              {                  var bytes = new StringBuilder(49);                  var chars = new StringBuilder(rem);                    for (var j = 0; j < 16; ++j)                  {                      if (j < rem)                      {                          var c = input.ReadByte();                            bytes.Append(c.ToString("X2"));                            if (j != 7)                          {                              bytes.Append(' ');                          }                          else                          {                              bytes.Append("  ");                          }                            if (c >= 0x20 && c < 0x80)                          {                              chars.Append((char) c);                          }                          else                          {                              chars.Append('.');                          }                      }                      else                      {                          bytes.Append("   ");                      }                  }                    builder.Append(byteIndex.ToString("X4"));                  builder.Append("   ");                  builder.Append(bytes);                  builder.Append("  ");                  builder.AppendLine(chars.ToString());              }
Magic Number,OpenUO.Core,StreamExtensions,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Extensions\StreamExtensions.cs,ToFormattedString,The following statement contains a magic number: var whole = length >> 4;
Magic Number,OpenUO.Core,StreamExtensions,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Extensions\StreamExtensions.cs,ToFormattedString,The following statement contains a magic number: for (var i = 0; i < whole; ++i' byteIndex += 16)              {                  var bytes = new StringBuilder(49);                  var chars = new StringBuilder(16);                    for (var j = 0; j < 16; ++j)                  {                      var c = input.ReadByte();                        bytes.Append(c.ToString("X2"));                        if (j != 7)                      {                          bytes.Append(' ');                      }                      else                      {                          bytes.Append("  ");                      }                        if (c >= 0x20 && c < 0x80)                      {                          chars.Append((char) c);                      }                      else                      {                          chars.Append('.');                      }                  }                    writer.Write(byteIndex.ToString("X4"));                  writer.Write("   ");                  writer.Write(bytes.ToString());                  writer.Write("  ");                  writer.WriteLine(chars.ToString());              }
Magic Number,OpenUO.Core,StreamExtensions,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Extensions\StreamExtensions.cs,ToFormattedString,The following statement contains a magic number: for (var i = 0; i < whole; ++i' byteIndex += 16)              {                  var bytes = new StringBuilder(49);                  var chars = new StringBuilder(16);                    for (var j = 0; j < 16; ++j)                  {                      var c = input.ReadByte();                        bytes.Append(c.ToString("X2"));                        if (j != 7)                      {                          bytes.Append(' ');                      }                      else                      {                          bytes.Append("  ");                      }                        if (c >= 0x20 && c < 0x80)                      {                          chars.Append((char) c);                      }                      else                      {                          chars.Append('.');                      }                  }                    writer.Write(byteIndex.ToString("X4"));                  writer.Write("   ");                  writer.Write(bytes.ToString());                  writer.Write("  ");                  writer.WriteLine(chars.ToString());              }
Magic Number,OpenUO.Core,StreamExtensions,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Extensions\StreamExtensions.cs,ToFormattedString,The following statement contains a magic number: for (var i = 0; i < whole; ++i' byteIndex += 16)              {                  var bytes = new StringBuilder(49);                  var chars = new StringBuilder(16);                    for (var j = 0; j < 16; ++j)                  {                      var c = input.ReadByte();                        bytes.Append(c.ToString("X2"));                        if (j != 7)                      {                          bytes.Append(' ');                      }                      else                      {                          bytes.Append("  ");                      }                        if (c >= 0x20 && c < 0x80)                      {                          chars.Append((char) c);                      }                      else                      {                          chars.Append('.');                      }                  }                    writer.Write(byteIndex.ToString("X4"));                  writer.Write("   ");                  writer.Write(bytes.ToString());                  writer.Write("  ");                  writer.WriteLine(chars.ToString());              }
Magic Number,OpenUO.Core,StreamExtensions,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Extensions\StreamExtensions.cs,ToFormattedString,The following statement contains a magic number: for (var i = 0; i < whole; ++i' byteIndex += 16)              {                  var bytes = new StringBuilder(49);                  var chars = new StringBuilder(16);                    for (var j = 0; j < 16; ++j)                  {                      var c = input.ReadByte();                        bytes.Append(c.ToString("X2"));                        if (j != 7)                      {                          bytes.Append(' ');                      }                      else                      {                          bytes.Append("  ");                      }                        if (c >= 0x20 && c < 0x80)                      {                          chars.Append((char) c);                      }                      else                      {                          chars.Append('.');                      }                  }                    writer.Write(byteIndex.ToString("X4"));                  writer.Write("   ");                  writer.Write(bytes.ToString());                  writer.Write("  ");                  writer.WriteLine(chars.ToString());              }
Magic Number,OpenUO.Core,StreamExtensions,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Extensions\StreamExtensions.cs,ToFormattedString,The following statement contains a magic number: for (var i = 0; i < whole; ++i' byteIndex += 16)              {                  var bytes = new StringBuilder(49);                  var chars = new StringBuilder(16);                    for (var j = 0; j < 16; ++j)                  {                      var c = input.ReadByte();                        bytes.Append(c.ToString("X2"));                        if (j != 7)                      {                          bytes.Append(' ');                      }                      else                      {                          bytes.Append("  ");                      }                        if (c >= 0x20 && c < 0x80)                      {                          chars.Append((char) c);                      }                      else                      {                          chars.Append('.');                      }                  }                    writer.Write(byteIndex.ToString("X4"));                  writer.Write("   ");                  writer.Write(bytes.ToString());                  writer.Write("  ");                  writer.WriteLine(chars.ToString());              }
Magic Number,OpenUO.Core,StreamExtensions,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Extensions\StreamExtensions.cs,ToFormattedString,The following statement contains a magic number: if (rem != 0)              {                  var bytes = new StringBuilder(49);                  var chars = new StringBuilder(rem);                    for (var j = 0; j < 16; ++j)                  {                      if (j < rem)                      {                          var c = input.ReadByte();                            bytes.Append(c.ToString("X2"));                            if (j != 7)                          {                              bytes.Append(' ');                          }                          else                          {                              bytes.Append("  ");                          }                            if (c >= 0x20 && c < 0x80)                          {                              chars.Append((char) c);                          }                          else                          {                              chars.Append('.');                          }                      }                      else                      {                          bytes.Append("   ");                      }                  }                    writer.Write(byteIndex.ToString("X4"));                  writer.Write("   ");                  writer.Write(bytes.ToString());                  writer.Write("  ");                  writer.WriteLine(chars.ToString());              }
Magic Number,OpenUO.Core,StreamExtensions,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Extensions\StreamExtensions.cs,ToFormattedString,The following statement contains a magic number: if (rem != 0)              {                  var bytes = new StringBuilder(49);                  var chars = new StringBuilder(rem);                    for (var j = 0; j < 16; ++j)                  {                      if (j < rem)                      {                          var c = input.ReadByte();                            bytes.Append(c.ToString("X2"));                            if (j != 7)                          {                              bytes.Append(' ');                          }                          else                          {                              bytes.Append("  ");                          }                            if (c >= 0x20 && c < 0x80)                          {                              chars.Append((char) c);                          }                          else                          {                              chars.Append('.');                          }                      }                      else                      {                          bytes.Append("   ");                      }                  }                    writer.Write(byteIndex.ToString("X4"));                  writer.Write("   ");                  writer.Write(bytes.ToString());                  writer.Write("  ");                  writer.WriteLine(chars.ToString());              }
Magic Number,OpenUO.Core,StreamExtensions,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Extensions\StreamExtensions.cs,ToFormattedString,The following statement contains a magic number: if (rem != 0)              {                  var bytes = new StringBuilder(49);                  var chars = new StringBuilder(rem);                    for (var j = 0; j < 16; ++j)                  {                      if (j < rem)                      {                          var c = input.ReadByte();                            bytes.Append(c.ToString("X2"));                            if (j != 7)                          {                              bytes.Append(' ');                          }                          else                          {                              bytes.Append("  ");                          }                            if (c >= 0x20 && c < 0x80)                          {                              chars.Append((char) c);                          }                          else                          {                              chars.Append('.');                          }                      }                      else                      {                          bytes.Append("   ");                      }                  }                    writer.Write(byteIndex.ToString("X4"));                  writer.Write("   ");                  writer.Write(bytes.ToString());                  writer.Write("  ");                  writer.WriteLine(chars.ToString());              }
Magic Number,OpenUO.Core,ProgressEventArgs,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\ProgressEventArgs.cs,ProgressEventArgs,The following statement contains a magic number: PercentComplete = (int) (((float) position/length)*100);
Magic Number,OpenUO.Core.Configuration,SettingsFile,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Configuration\SettingsFile.cs,SettingsFile,The following statement contains a magic number: _saveTimer = new Timer              {                  Interval = 300'                  AutoReset = true              };
Magic Number,OpenUO.Core.IO,HuffmanCompression,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\IO\HuffmanCompression.cs,Compress,The following statement contains a magic number: lock (_syncRoot)              {                  var bitCount = 0;                  var bitValue = 0;                    fixed (int* pTable = _huffmanTable)                  {                      fixed (byte* pInputBuffer = input)                      {                          byte* pInput = pInputBuffer + offset' pInputEnd = pInput + count;                            fixed (byte* pOutputBuffer = _outputBuffer)                          {                              byte* pOutput = pOutputBuffer' pOutputEnd = pOutput + BufferSize;                              int* pEntry;                                while (pInput < pInputEnd)                              {                                  pEntry = &pTable[*pInput++ << 1];                                    bitCount += pEntry[CountIndex];                                    bitValue <<= pEntry[CountIndex];                                  bitValue |= pEntry[ValueIndex];                                    while (bitCount >= 8)                                  {                                      bitCount -= 8;                                        if (pOutput < pOutputEnd)                                      {                                          *pOutput++ = (byte) (bitValue >> bitCount);                                      }                                      else                                      {                                          return null;                                      }                                  }                              }                                // terminal code                              pEntry = &pTable[0x200];                                bitCount += pEntry[CountIndex];                                bitValue <<= pEntry[CountIndex];                              bitValue |= pEntry[ValueIndex];                                // align on byte boundary                              if ((bitCount & 7) != 0)                              {                                  bitValue <<= (8 - (bitCount & 7));                                  bitCount += (8 - (bitCount & 7));                              }                                while (bitCount >= 8)                              {                                  bitCount -= 8;                                    if (pOutput < pOutputEnd)                                  {                                      *pOutput++ = (byte) (bitValue >> bitCount);                                  }                                  else                                  {                                      return null;                                  }                              }                                length = (int) (pOutput - pOutputBuffer);                              return _outputBuffer;                          }                      }                  }              }
Magic Number,OpenUO.Core.IO,HuffmanCompression,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\IO\HuffmanCompression.cs,Compress,The following statement contains a magic number: lock (_syncRoot)              {                  var bitCount = 0;                  var bitValue = 0;                    fixed (int* pTable = _huffmanTable)                  {                      fixed (byte* pInputBuffer = input)                      {                          byte* pInput = pInputBuffer + offset' pInputEnd = pInput + count;                            fixed (byte* pOutputBuffer = _outputBuffer)                          {                              byte* pOutput = pOutputBuffer' pOutputEnd = pOutput + BufferSize;                              int* pEntry;                                while (pInput < pInputEnd)                              {                                  pEntry = &pTable[*pInput++ << 1];                                    bitCount += pEntry[CountIndex];                                    bitValue <<= pEntry[CountIndex];                                  bitValue |= pEntry[ValueIndex];                                    while (bitCount >= 8)                                  {                                      bitCount -= 8;                                        if (pOutput < pOutputEnd)                                      {                                          *pOutput++ = (byte) (bitValue >> bitCount);                                      }                                      else                                      {                                          return null;                                      }                                  }                              }                                // terminal code                              pEntry = &pTable[0x200];                                bitCount += pEntry[CountIndex];                                bitValue <<= pEntry[CountIndex];                              bitValue |= pEntry[ValueIndex];                                // align on byte boundary                              if ((bitCount & 7) != 0)                              {                                  bitValue <<= (8 - (bitCount & 7));                                  bitCount += (8 - (bitCount & 7));                              }                                while (bitCount >= 8)                              {                                  bitCount -= 8;                                    if (pOutput < pOutputEnd)                                  {                                      *pOutput++ = (byte) (bitValue >> bitCount);                                  }                                  else                                  {                                      return null;                                  }                              }                                length = (int) (pOutput - pOutputBuffer);                              return _outputBuffer;                          }                      }                  }              }
Magic Number,OpenUO.Core.IO,HuffmanCompression,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\IO\HuffmanCompression.cs,Compress,The following statement contains a magic number: lock (_syncRoot)              {                  var bitCount = 0;                  var bitValue = 0;                    fixed (int* pTable = _huffmanTable)                  {                      fixed (byte* pInputBuffer = input)                      {                          byte* pInput = pInputBuffer + offset' pInputEnd = pInput + count;                            fixed (byte* pOutputBuffer = _outputBuffer)                          {                              byte* pOutput = pOutputBuffer' pOutputEnd = pOutput + BufferSize;                              int* pEntry;                                while (pInput < pInputEnd)                              {                                  pEntry = &pTable[*pInput++ << 1];                                    bitCount += pEntry[CountIndex];                                    bitValue <<= pEntry[CountIndex];                                  bitValue |= pEntry[ValueIndex];                                    while (bitCount >= 8)                                  {                                      bitCount -= 8;                                        if (pOutput < pOutputEnd)                                      {                                          *pOutput++ = (byte) (bitValue >> bitCount);                                      }                                      else                                      {                                          return null;                                      }                                  }                              }                                // terminal code                              pEntry = &pTable[0x200];                                bitCount += pEntry[CountIndex];                                bitValue <<= pEntry[CountIndex];                              bitValue |= pEntry[ValueIndex];                                // align on byte boundary                              if ((bitCount & 7) != 0)                              {                                  bitValue <<= (8 - (bitCount & 7));                                  bitCount += (8 - (bitCount & 7));                              }                                while (bitCount >= 8)                              {                                  bitCount -= 8;                                    if (pOutput < pOutputEnd)                                  {                                      *pOutput++ = (byte) (bitValue >> bitCount);                                  }                                  else                                  {                                      return null;                                  }                              }                                length = (int) (pOutput - pOutputBuffer);                              return _outputBuffer;                          }                      }                  }              }
Magic Number,OpenUO.Core.IO,HuffmanCompression,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\IO\HuffmanCompression.cs,Compress,The following statement contains a magic number: lock (_syncRoot)              {                  var bitCount = 0;                  var bitValue = 0;                    fixed (int* pTable = _huffmanTable)                  {                      fixed (byte* pInputBuffer = input)                      {                          byte* pInput = pInputBuffer + offset' pInputEnd = pInput + count;                            fixed (byte* pOutputBuffer = _outputBuffer)                          {                              byte* pOutput = pOutputBuffer' pOutputEnd = pOutput + BufferSize;                              int* pEntry;                                while (pInput < pInputEnd)                              {                                  pEntry = &pTable[*pInput++ << 1];                                    bitCount += pEntry[CountIndex];                                    bitValue <<= pEntry[CountIndex];                                  bitValue |= pEntry[ValueIndex];                                    while (bitCount >= 8)                                  {                                      bitCount -= 8;                                        if (pOutput < pOutputEnd)                                      {                                          *pOutput++ = (byte) (bitValue >> bitCount);                                      }                                      else                                      {                                          return null;                                      }                                  }                              }                                // terminal code                              pEntry = &pTable[0x200];                                bitCount += pEntry[CountIndex];                                bitValue <<= pEntry[CountIndex];                              bitValue |= pEntry[ValueIndex];                                // align on byte boundary                              if ((bitCount & 7) != 0)                              {                                  bitValue <<= (8 - (bitCount & 7));                                  bitCount += (8 - (bitCount & 7));                              }                                while (bitCount >= 8)                              {                                  bitCount -= 8;                                    if (pOutput < pOutputEnd)                                  {                                      *pOutput++ = (byte) (bitValue >> bitCount);                                  }                                  else                                  {                                      return null;                                  }                              }                                length = (int) (pOutput - pOutputBuffer);                              return _outputBuffer;                          }                      }                  }              }
Magic Number,OpenUO.Core.IO,HuffmanCompression,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\IO\HuffmanCompression.cs,Compress,The following statement contains a magic number: lock (_syncRoot)              {                  var bitCount = 0;                  var bitValue = 0;                    fixed (int* pTable = _huffmanTable)                  {                      fixed (byte* pInputBuffer = input)                      {                          byte* pInput = pInputBuffer + offset' pInputEnd = pInput + count;                            fixed (byte* pOutputBuffer = _outputBuffer)                          {                              byte* pOutput = pOutputBuffer' pOutputEnd = pOutput + BufferSize;                              int* pEntry;                                while (pInput < pInputEnd)                              {                                  pEntry = &pTable[*pInput++ << 1];                                    bitCount += pEntry[CountIndex];                                    bitValue <<= pEntry[CountIndex];                                  bitValue |= pEntry[ValueIndex];                                    while (bitCount >= 8)                                  {                                      bitCount -= 8;                                        if (pOutput < pOutputEnd)                                      {                                          *pOutput++ = (byte) (bitValue >> bitCount);                                      }                                      else                                      {                                          return null;                                      }                                  }                              }                                // terminal code                              pEntry = &pTable[0x200];                                bitCount += pEntry[CountIndex];                                bitValue <<= pEntry[CountIndex];                              bitValue |= pEntry[ValueIndex];                                // align on byte boundary                              if ((bitCount & 7) != 0)                              {                                  bitValue <<= (8 - (bitCount & 7));                                  bitCount += (8 - (bitCount & 7));                              }                                while (bitCount >= 8)                              {                                  bitCount -= 8;                                    if (pOutput < pOutputEnd)                                  {                                      *pOutput++ = (byte) (bitValue >> bitCount);                                  }                                  else                                  {                                      return null;                                  }                              }                                length = (int) (pOutput - pOutputBuffer);                              return _outputBuffer;                          }                      }                  }              }
Magic Number,OpenUO.Core.IO,HuffmanCompression,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\IO\HuffmanCompression.cs,Compress,The following statement contains a magic number: lock (_syncRoot)              {                  var bitCount = 0;                  var bitValue = 0;                    fixed (int* pTable = _huffmanTable)                  {                      fixed (byte* pInputBuffer = input)                      {                          byte* pInput = pInputBuffer + offset' pInputEnd = pInput + count;                            fixed (byte* pOutputBuffer = _outputBuffer)                          {                              byte* pOutput = pOutputBuffer' pOutputEnd = pOutput + BufferSize;                              int* pEntry;                                while (pInput < pInputEnd)                              {                                  pEntry = &pTable[*pInput++ << 1];                                    bitCount += pEntry[CountIndex];                                    bitValue <<= pEntry[CountIndex];                                  bitValue |= pEntry[ValueIndex];                                    while (bitCount >= 8)                                  {                                      bitCount -= 8;                                        if (pOutput < pOutputEnd)                                      {                                          *pOutput++ = (byte) (bitValue >> bitCount);                                      }                                      else                                      {                                          return null;                                      }                                  }                              }                                // terminal code                              pEntry = &pTable[0x200];                                bitCount += pEntry[CountIndex];                                bitValue <<= pEntry[CountIndex];                              bitValue |= pEntry[ValueIndex];                                // align on byte boundary                              if ((bitCount & 7) != 0)                              {                                  bitValue <<= (8 - (bitCount & 7));                                  bitCount += (8 - (bitCount & 7));                              }                                while (bitCount >= 8)                              {                                  bitCount -= 8;                                    if (pOutput < pOutputEnd)                                  {                                      *pOutput++ = (byte) (bitValue >> bitCount);                                  }                                  else                                  {                                      return null;                                  }                              }                                length = (int) (pOutput - pOutputBuffer);                              return _outputBuffer;                          }                      }                  }              }
Magic Number,OpenUO.Core.IO,HuffmanCompression,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\IO\HuffmanCompression.cs,Compress,The following statement contains a magic number: lock (_syncRoot)              {                  var bitCount = 0;                  var bitValue = 0;                    fixed (int* pTable = _huffmanTable)                  {                      fixed (byte* pInputBuffer = input)                      {                          byte* pInput = pInputBuffer + offset' pInputEnd = pInput + count;                            fixed (byte* pOutputBuffer = _outputBuffer)                          {                              byte* pOutput = pOutputBuffer' pOutputEnd = pOutput + BufferSize;                              int* pEntry;                                while (pInput < pInputEnd)                              {                                  pEntry = &pTable[*pInput++ << 1];                                    bitCount += pEntry[CountIndex];                                    bitValue <<= pEntry[CountIndex];                                  bitValue |= pEntry[ValueIndex];                                    while (bitCount >= 8)                                  {                                      bitCount -= 8;                                        if (pOutput < pOutputEnd)                                      {                                          *pOutput++ = (byte) (bitValue >> bitCount);                                      }                                      else                                      {                                          return null;                                      }                                  }                              }                                // terminal code                              pEntry = &pTable[0x200];                                bitCount += pEntry[CountIndex];                                bitValue <<= pEntry[CountIndex];                              bitValue |= pEntry[ValueIndex];                                // align on byte boundary                              if ((bitCount & 7) != 0)                              {                                  bitValue <<= (8 - (bitCount & 7));                                  bitCount += (8 - (bitCount & 7));                              }                                while (bitCount >= 8)                              {                                  bitCount -= 8;                                    if (pOutput < pOutputEnd)                                  {                                      *pOutput++ = (byte) (bitValue >> bitCount);                                  }                                  else                                  {                                      return null;                                  }                              }                                length = (int) (pOutput - pOutputBuffer);                              return _outputBuffer;                          }                      }                  }              }
Magic Number,OpenUO.Core.IO,HuffmanCompression,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\IO\HuffmanCompression.cs,Compress,The following statement contains a magic number: lock (_syncRoot)              {                  var bitCount = 0;                  var bitValue = 0;                    fixed (int* pTable = _huffmanTable)                  {                      fixed (byte* pInputBuffer = input)                      {                          byte* pInput = pInputBuffer + offset' pInputEnd = pInput + count;                            fixed (byte* pOutputBuffer = _outputBuffer)                          {                              byte* pOutput = pOutputBuffer' pOutputEnd = pOutput + BufferSize;                              int* pEntry;                                while (pInput < pInputEnd)                              {                                  pEntry = &pTable[*pInput++ << 1];                                    bitCount += pEntry[CountIndex];                                    bitValue <<= pEntry[CountIndex];                                  bitValue |= pEntry[ValueIndex];                                    while (bitCount >= 8)                                  {                                      bitCount -= 8;                                        if (pOutput < pOutputEnd)                                      {                                          *pOutput++ = (byte) (bitValue >> bitCount);                                      }                                      else                                      {                                          return null;                                      }                                  }                              }                                // terminal code                              pEntry = &pTable[0x200];                                bitCount += pEntry[CountIndex];                                bitValue <<= pEntry[CountIndex];                              bitValue |= pEntry[ValueIndex];                                // align on byte boundary                              if ((bitCount & 7) != 0)                              {                                  bitValue <<= (8 - (bitCount & 7));                                  bitCount += (8 - (bitCount & 7));                              }                                while (bitCount >= 8)                              {                                  bitCount -= 8;                                    if (pOutput < pOutputEnd)                                  {                                      *pOutput++ = (byte) (bitValue >> bitCount);                                  }                                  else                                  {                                      return null;                                  }                              }                                length = (int) (pOutput - pOutputBuffer);                              return _outputBuffer;                          }                      }                  }              }
Magic Number,OpenUO.Core.IO,HuffmanCompression,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\IO\HuffmanCompression.cs,Compress,The following statement contains a magic number: lock (_syncRoot)              {                  var bitCount = 0;                  var bitValue = 0;                    fixed (int* pTable = _huffmanTable)                  {                      fixed (byte* pInputBuffer = input)                      {                          byte* pInput = pInputBuffer + offset' pInputEnd = pInput + count;                            fixed (byte* pOutputBuffer = _outputBuffer)                          {                              byte* pOutput = pOutputBuffer' pOutputEnd = pOutput + BufferSize;                              int* pEntry;                                while (pInput < pInputEnd)                              {                                  pEntry = &pTable[*pInput++ << 1];                                    bitCount += pEntry[CountIndex];                                    bitValue <<= pEntry[CountIndex];                                  bitValue |= pEntry[ValueIndex];                                    while (bitCount >= 8)                                  {                                      bitCount -= 8;                                        if (pOutput < pOutputEnd)                                      {                                          *pOutput++ = (byte) (bitValue >> bitCount);                                      }                                      else                                      {                                          return null;                                      }                                  }                              }                                // terminal code                              pEntry = &pTable[0x200];                                bitCount += pEntry[CountIndex];                                bitValue <<= pEntry[CountIndex];                              bitValue |= pEntry[ValueIndex];                                // align on byte boundary                              if ((bitCount & 7) != 0)                              {                                  bitValue <<= (8 - (bitCount & 7));                                  bitCount += (8 - (bitCount & 7));                              }                                while (bitCount >= 8)                              {                                  bitCount -= 8;                                    if (pOutput < pOutputEnd)                                  {                                      *pOutput++ = (byte) (bitValue >> bitCount);                                  }                                  else                                  {                                      return null;                                  }                              }                                length = (int) (pOutput - pOutputBuffer);                              return _outputBuffer;                          }                      }                  }              }
Magic Number,OpenUO.Core.IO,ZlibCompression,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\IO\ZlibCompression.cs,ZlibCompression,The following statement contains a magic number: if (IntPtr.Size == 8)              {                  Compressor = new Compressor64();              }              else              {                  Compressor = new Compressor32();              }
Magic Number,OpenUO.Core.Patterns,GenericMethodCacheKey,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,GenerateHashCode,The following statement contains a magic number: unchecked                  {                      var result = _sourceType.GetHashCode();                        result = (result*397) ^ _methodName.GetHashCode();                        for (var i = 0; i < _genericTypes.Length; ++i)                      {                          result = (result*397) ^ _genericTypes[i].GetHashCode();                      }                        for (var i = 0; i < _parameterTypes.Length; ++i)                      {                          result = (result*397) ^ _parameterTypes[i].GetHashCode();                      }                        return result;                  }
Magic Number,OpenUO.Core.Patterns,GenericMethodCacheKey,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,GenerateHashCode,The following statement contains a magic number: unchecked                  {                      var result = _sourceType.GetHashCode();                        result = (result*397) ^ _methodName.GetHashCode();                        for (var i = 0; i < _genericTypes.Length; ++i)                      {                          result = (result*397) ^ _genericTypes[i].GetHashCode();                      }                        for (var i = 0; i < _parameterTypes.Length; ++i)                      {                          result = (result*397) ^ _parameterTypes[i].GetHashCode();                      }                        return result;                  }
Magic Number,OpenUO.Core.Patterns,GenericMethodCacheKey,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,GenerateHashCode,The following statement contains a magic number: unchecked                  {                      var result = _sourceType.GetHashCode();                        result = (result*397) ^ _methodName.GetHashCode();                        for (var i = 0; i < _genericTypes.Length; ++i)                      {                          result = (result*397) ^ _genericTypes[i].GetHashCode();                      }                        for (var i = 0; i < _parameterTypes.Length; ++i)                      {                          result = (result*397) ^ _parameterTypes[i].GetHashCode();                      }                        return result;                  }
Magic Number,OpenUO.Core.Patterns,Container,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Patterns\IoC\Container.cs,GetLazyAutomaticFactoryRequest,The following statement contains a magic number: if ((genericType == typeof (Func<''>) && type.GetGenericArguments()[0] == typeof (string) &&                   type.GetGenericArguments()[1] == typeof (IDictionary<string' object>)))              {                  var returnType = genericArguments[2];                    var name = Expression.Parameter(typeof (string)' "name");                  var parameters = Expression.Parameter(typeof (IDictionary<string' object>)' "parameters");                    var resolveMethod = typeof (Container).GetMethod("Resolve"' new[]                  {                      typeof (String)' typeof (NamedParameterOverloads)                  });                  resolveMethod = resolveMethod.MakeGenericMethod(returnType);                    var resolveCall = Expression.Call(                      Expression.Constant(this)'                      resolveMethod'                      name'                      Expression.Call(typeof (NamedParameterOverloads)' "FromIDictionary"' null' parameters));                    var resolveLambda = Expression.Lambda(resolveCall' name' parameters).Compile();                    return resolveLambda;              }
Magic Number,OpenUO.Core.Reflection,BaseMethodInvoker,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Reflection\BaseMethodInvoker.cs,EmitFastInt,The following statement contains a magic number: switch (value)              {                  case -1:                      il.Emit(OpCodes.Ldc_I4_M1);                      return;                  case 0:                      il.Emit(OpCodes.Ldc_I4_0);                      return;                  case 1:                      il.Emit(OpCodes.Ldc_I4_1);                      return;                  case 2:                      il.Emit(OpCodes.Ldc_I4_2);                      return;                  case 3:                      il.Emit(OpCodes.Ldc_I4_3);                      return;                  case 4:                      il.Emit(OpCodes.Ldc_I4_4);                      return;                  case 5:                      il.Emit(OpCodes.Ldc_I4_5);                      return;                  case 6:                      il.Emit(OpCodes.Ldc_I4_6);                      return;                  case 7:                      il.Emit(OpCodes.Ldc_I4_7);                      return;                  case 8:                      il.Emit(OpCodes.Ldc_I4_8);                      return;              }
Magic Number,OpenUO.Core.Reflection,BaseMethodInvoker,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Reflection\BaseMethodInvoker.cs,EmitFastInt,The following statement contains a magic number: switch (value)              {                  case -1:                      il.Emit(OpCodes.Ldc_I4_M1);                      return;                  case 0:                      il.Emit(OpCodes.Ldc_I4_0);                      return;                  case 1:                      il.Emit(OpCodes.Ldc_I4_1);                      return;                  case 2:                      il.Emit(OpCodes.Ldc_I4_2);                      return;                  case 3:                      il.Emit(OpCodes.Ldc_I4_3);                      return;                  case 4:                      il.Emit(OpCodes.Ldc_I4_4);                      return;                  case 5:                      il.Emit(OpCodes.Ldc_I4_5);                      return;                  case 6:                      il.Emit(OpCodes.Ldc_I4_6);                      return;                  case 7:                      il.Emit(OpCodes.Ldc_I4_7);                      return;                  case 8:                      il.Emit(OpCodes.Ldc_I4_8);                      return;              }
Magic Number,OpenUO.Core.Reflection,BaseMethodInvoker,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Reflection\BaseMethodInvoker.cs,EmitFastInt,The following statement contains a magic number: switch (value)              {                  case -1:                      il.Emit(OpCodes.Ldc_I4_M1);                      return;                  case 0:                      il.Emit(OpCodes.Ldc_I4_0);                      return;                  case 1:                      il.Emit(OpCodes.Ldc_I4_1);                      return;                  case 2:                      il.Emit(OpCodes.Ldc_I4_2);                      return;                  case 3:                      il.Emit(OpCodes.Ldc_I4_3);                      return;                  case 4:                      il.Emit(OpCodes.Ldc_I4_4);                      return;                  case 5:                      il.Emit(OpCodes.Ldc_I4_5);                      return;                  case 6:                      il.Emit(OpCodes.Ldc_I4_6);                      return;                  case 7:                      il.Emit(OpCodes.Ldc_I4_7);                      return;                  case 8:                      il.Emit(OpCodes.Ldc_I4_8);                      return;              }
Magic Number,OpenUO.Core.Reflection,BaseMethodInvoker,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Reflection\BaseMethodInvoker.cs,EmitFastInt,The following statement contains a magic number: switch (value)              {                  case -1:                      il.Emit(OpCodes.Ldc_I4_M1);                      return;                  case 0:                      il.Emit(OpCodes.Ldc_I4_0);                      return;                  case 1:                      il.Emit(OpCodes.Ldc_I4_1);                      return;                  case 2:                      il.Emit(OpCodes.Ldc_I4_2);                      return;                  case 3:                      il.Emit(OpCodes.Ldc_I4_3);                      return;                  case 4:                      il.Emit(OpCodes.Ldc_I4_4);                      return;                  case 5:                      il.Emit(OpCodes.Ldc_I4_5);                      return;                  case 6:                      il.Emit(OpCodes.Ldc_I4_6);                      return;                  case 7:                      il.Emit(OpCodes.Ldc_I4_7);                      return;                  case 8:                      il.Emit(OpCodes.Ldc_I4_8);                      return;              }
Magic Number,OpenUO.Core.Reflection,BaseMethodInvoker,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Reflection\BaseMethodInvoker.cs,EmitFastInt,The following statement contains a magic number: switch (value)              {                  case -1:                      il.Emit(OpCodes.Ldc_I4_M1);                      return;                  case 0:                      il.Emit(OpCodes.Ldc_I4_0);                      return;                  case 1:                      il.Emit(OpCodes.Ldc_I4_1);                      return;                  case 2:                      il.Emit(OpCodes.Ldc_I4_2);                      return;                  case 3:                      il.Emit(OpCodes.Ldc_I4_3);                      return;                  case 4:                      il.Emit(OpCodes.Ldc_I4_4);                      return;                  case 5:                      il.Emit(OpCodes.Ldc_I4_5);                      return;                  case 6:                      il.Emit(OpCodes.Ldc_I4_6);                      return;                  case 7:                      il.Emit(OpCodes.Ldc_I4_7);                      return;                  case 8:                      il.Emit(OpCodes.Ldc_I4_8);                      return;              }
Magic Number,OpenUO.Core.Reflection,BaseMethodInvoker,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Reflection\BaseMethodInvoker.cs,EmitFastInt,The following statement contains a magic number: switch (value)              {                  case -1:                      il.Emit(OpCodes.Ldc_I4_M1);                      return;                  case 0:                      il.Emit(OpCodes.Ldc_I4_0);                      return;                  case 1:                      il.Emit(OpCodes.Ldc_I4_1);                      return;                  case 2:                      il.Emit(OpCodes.Ldc_I4_2);                      return;                  case 3:                      il.Emit(OpCodes.Ldc_I4_3);                      return;                  case 4:                      il.Emit(OpCodes.Ldc_I4_4);                      return;                  case 5:                      il.Emit(OpCodes.Ldc_I4_5);                      return;                  case 6:                      il.Emit(OpCodes.Ldc_I4_6);                      return;                  case 7:                      il.Emit(OpCodes.Ldc_I4_7);                      return;                  case 8:                      il.Emit(OpCodes.Ldc_I4_8);                      return;              }
Magic Number,OpenUO.Core.Reflection,BaseMethodInvoker,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Reflection\BaseMethodInvoker.cs,EmitFastInt,The following statement contains a magic number: switch (value)              {                  case -1:                      il.Emit(OpCodes.Ldc_I4_M1);                      return;                  case 0:                      il.Emit(OpCodes.Ldc_I4_0);                      return;                  case 1:                      il.Emit(OpCodes.Ldc_I4_1);                      return;                  case 2:                      il.Emit(OpCodes.Ldc_I4_2);                      return;                  case 3:                      il.Emit(OpCodes.Ldc_I4_3);                      return;                  case 4:                      il.Emit(OpCodes.Ldc_I4_4);                      return;                  case 5:                      il.Emit(OpCodes.Ldc_I4_5);                      return;                  case 6:                      il.Emit(OpCodes.Ldc_I4_6);                      return;                  case 7:                      il.Emit(OpCodes.Ldc_I4_7);                      return;                  case 8:                      il.Emit(OpCodes.Ldc_I4_8);                      return;              }
Magic Number,OpenUO.Core.Reflection,BaseMethodInvoker,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Reflection\BaseMethodInvoker.cs,EmitFastInt,The following statement contains a magic number: if (value > -129 && value < 128)              {                  il.Emit(OpCodes.Ldc_I4_S' (SByte) value);              }              else              {                  il.Emit(OpCodes.Ldc_I4' value);              }
Magic Number,OpenUO.Core.Reflection,BaseMethodInvoker,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Reflection\BaseMethodInvoker.cs,EmitFastInt,The following statement contains a magic number: if (value > -129 && value < 128)              {                  il.Emit(OpCodes.Ldc_I4_S' (SByte) value);              }              else              {                  il.Emit(OpCodes.Ldc_I4' value);              }
Magic Number,OpenUO.Core.Reflection,BasePropertyAccessor,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Reflection\BasePropertyAccessor.cs,EmitFastInt,The following statement contains a magic number: switch (value)              {                  case -1:                      il.Emit(OpCodes.Ldc_I4_M1);                      return;                  case 0:                      il.Emit(OpCodes.Ldc_I4_0);                      return;                  case 1:                      il.Emit(OpCodes.Ldc_I4_1);                      return;                  case 2:                      il.Emit(OpCodes.Ldc_I4_2);                      return;                  case 3:                      il.Emit(OpCodes.Ldc_I4_3);                      return;                  case 4:                      il.Emit(OpCodes.Ldc_I4_4);                      return;                  case 5:                      il.Emit(OpCodes.Ldc_I4_5);                      return;                  case 6:                      il.Emit(OpCodes.Ldc_I4_6);                      return;                  case 7:                      il.Emit(OpCodes.Ldc_I4_7);                      return;                  case 8:                      il.Emit(OpCodes.Ldc_I4_8);                      return;              }
Magic Number,OpenUO.Core.Reflection,BasePropertyAccessor,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Reflection\BasePropertyAccessor.cs,EmitFastInt,The following statement contains a magic number: switch (value)              {                  case -1:                      il.Emit(OpCodes.Ldc_I4_M1);                      return;                  case 0:                      il.Emit(OpCodes.Ldc_I4_0);                      return;                  case 1:                      il.Emit(OpCodes.Ldc_I4_1);                      return;                  case 2:                      il.Emit(OpCodes.Ldc_I4_2);                      return;                  case 3:                      il.Emit(OpCodes.Ldc_I4_3);                      return;                  case 4:                      il.Emit(OpCodes.Ldc_I4_4);                      return;                  case 5:                      il.Emit(OpCodes.Ldc_I4_5);                      return;                  case 6:                      il.Emit(OpCodes.Ldc_I4_6);                      return;                  case 7:                      il.Emit(OpCodes.Ldc_I4_7);                      return;                  case 8:                      il.Emit(OpCodes.Ldc_I4_8);                      return;              }
Magic Number,OpenUO.Core.Reflection,BasePropertyAccessor,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Reflection\BasePropertyAccessor.cs,EmitFastInt,The following statement contains a magic number: switch (value)              {                  case -1:                      il.Emit(OpCodes.Ldc_I4_M1);                      return;                  case 0:                      il.Emit(OpCodes.Ldc_I4_0);                      return;                  case 1:                      il.Emit(OpCodes.Ldc_I4_1);                      return;                  case 2:                      il.Emit(OpCodes.Ldc_I4_2);                      return;                  case 3:                      il.Emit(OpCodes.Ldc_I4_3);                      return;                  case 4:                      il.Emit(OpCodes.Ldc_I4_4);                      return;                  case 5:                      il.Emit(OpCodes.Ldc_I4_5);                      return;                  case 6:                      il.Emit(OpCodes.Ldc_I4_6);                      return;                  case 7:                      il.Emit(OpCodes.Ldc_I4_7);                      return;                  case 8:                      il.Emit(OpCodes.Ldc_I4_8);                      return;              }
Magic Number,OpenUO.Core.Reflection,BasePropertyAccessor,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Reflection\BasePropertyAccessor.cs,EmitFastInt,The following statement contains a magic number: switch (value)              {                  case -1:                      il.Emit(OpCodes.Ldc_I4_M1);                      return;                  case 0:                      il.Emit(OpCodes.Ldc_I4_0);                      return;                  case 1:                      il.Emit(OpCodes.Ldc_I4_1);                      return;                  case 2:                      il.Emit(OpCodes.Ldc_I4_2);                      return;                  case 3:                      il.Emit(OpCodes.Ldc_I4_3);                      return;                  case 4:                      il.Emit(OpCodes.Ldc_I4_4);                      return;                  case 5:                      il.Emit(OpCodes.Ldc_I4_5);                      return;                  case 6:                      il.Emit(OpCodes.Ldc_I4_6);                      return;                  case 7:                      il.Emit(OpCodes.Ldc_I4_7);                      return;                  case 8:                      il.Emit(OpCodes.Ldc_I4_8);                      return;              }
Magic Number,OpenUO.Core.Reflection,BasePropertyAccessor,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Reflection\BasePropertyAccessor.cs,EmitFastInt,The following statement contains a magic number: switch (value)              {                  case -1:                      il.Emit(OpCodes.Ldc_I4_M1);                      return;                  case 0:                      il.Emit(OpCodes.Ldc_I4_0);                      return;                  case 1:                      il.Emit(OpCodes.Ldc_I4_1);                      return;                  case 2:                      il.Emit(OpCodes.Ldc_I4_2);                      return;                  case 3:                      il.Emit(OpCodes.Ldc_I4_3);                      return;                  case 4:                      il.Emit(OpCodes.Ldc_I4_4);                      return;                  case 5:                      il.Emit(OpCodes.Ldc_I4_5);                      return;                  case 6:                      il.Emit(OpCodes.Ldc_I4_6);                      return;                  case 7:                      il.Emit(OpCodes.Ldc_I4_7);                      return;                  case 8:                      il.Emit(OpCodes.Ldc_I4_8);                      return;              }
Magic Number,OpenUO.Core.Reflection,BasePropertyAccessor,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Reflection\BasePropertyAccessor.cs,EmitFastInt,The following statement contains a magic number: switch (value)              {                  case -1:                      il.Emit(OpCodes.Ldc_I4_M1);                      return;                  case 0:                      il.Emit(OpCodes.Ldc_I4_0);                      return;                  case 1:                      il.Emit(OpCodes.Ldc_I4_1);                      return;                  case 2:                      il.Emit(OpCodes.Ldc_I4_2);                      return;                  case 3:                      il.Emit(OpCodes.Ldc_I4_3);                      return;                  case 4:                      il.Emit(OpCodes.Ldc_I4_4);                      return;                  case 5:                      il.Emit(OpCodes.Ldc_I4_5);                      return;                  case 6:                      il.Emit(OpCodes.Ldc_I4_6);                      return;                  case 7:                      il.Emit(OpCodes.Ldc_I4_7);                      return;                  case 8:                      il.Emit(OpCodes.Ldc_I4_8);                      return;              }
Magic Number,OpenUO.Core.Reflection,BasePropertyAccessor,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Reflection\BasePropertyAccessor.cs,EmitFastInt,The following statement contains a magic number: switch (value)              {                  case -1:                      il.Emit(OpCodes.Ldc_I4_M1);                      return;                  case 0:                      il.Emit(OpCodes.Ldc_I4_0);                      return;                  case 1:                      il.Emit(OpCodes.Ldc_I4_1);                      return;                  case 2:                      il.Emit(OpCodes.Ldc_I4_2);                      return;                  case 3:                      il.Emit(OpCodes.Ldc_I4_3);                      return;                  case 4:                      il.Emit(OpCodes.Ldc_I4_4);                      return;                  case 5:                      il.Emit(OpCodes.Ldc_I4_5);                      return;                  case 6:                      il.Emit(OpCodes.Ldc_I4_6);                      return;                  case 7:                      il.Emit(OpCodes.Ldc_I4_7);                      return;                  case 8:                      il.Emit(OpCodes.Ldc_I4_8);                      return;              }
Magic Number,OpenUO.Core.Reflection,BasePropertyAccessor,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Reflection\BasePropertyAccessor.cs,EmitFastInt,The following statement contains a magic number: if (value > -129 && value < 128)              {                  il.Emit(OpCodes.Ldc_I4_S' (SByte) value);              }              else              {                  il.Emit(OpCodes.Ldc_I4' value);              }
Magic Number,OpenUO.Core.Reflection,BasePropertyAccessor,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Reflection\BasePropertyAccessor.cs,EmitFastInt,The following statement contains a magic number: if (value > -129 && value < 128)              {                  il.Emit(OpCodes.Ldc_I4_S' (SByte) value);              }              else              {                  il.Emit(OpCodes.Ldc_I4' value);              }
Magic Number,OpenUO.Core.Reflection,FieldAccessor<TargetType;FieldType>,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Reflection\FieldAccessor.cs,ToString,The following statement contains a magic number: return "Property Invoker : " + getMethodHandler.Method.Name.Substring(4);
Magic Number,OpenUO.Core.Reflection,PropertyAccessor<TargetType;PropertyType>,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Reflection\PropertyAccesor.cs,ToString,The following statement contains a magic number: return "Property Invoker : " + getMethodHandler.Method.Name.Substring(4);
Magic Number,OpenUO.Core.Reflection,PropertyAccessor,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Reflection\PropertyAccesor.cs,ToString,The following statement contains a magic number: return "Property Invoker : " + getMethodHandler.Method.Name.Substring(4);
Duplicate Code,OpenUO.Core,StreamExtensions,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Extensions\StreamExtensions.cs,ToFormattedString,The method contains a code clone-set at the following line numbers (starting from the method definition): ((17' 39)' (56' 78))
Duplicate Code,OpenUO.Core,StreamExtensions,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Extensions\StreamExtensions.cs,ToFormattedString,The method contains a code clone-set at the following line numbers (starting from the method definition): ((17' 39)' (56' 78))
Missing Default,OpenUO.Core.Diagnostics.Tracing.Listeners,ConsoleOutputEventListener,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Diagnostics\Listeners\ConsoleOutputEventListener.cs,OnEventWritten,The following switch statement is missing a default case: switch (e.Level)              {                  case EventLevel.Informational:                      color = ConsoleColor.White;                      break;                  case EventLevel.Warning:                      color = ConsoleColor.Yellow;                      break;                  case EventLevel.Error:                  case EventLevel.Critical:                      color = ConsoleColor.Red;                      break;              }
Missing Default,OpenUO.Core.Reflection,BaseMethodInvoker,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Reflection\BaseMethodInvoker.cs,EmitFastInt,The following switch statement is missing a default case: switch (value)              {                  case -1:                      il.Emit(OpCodes.Ldc_I4_M1);                      return;                  case 0:                      il.Emit(OpCodes.Ldc_I4_0);                      return;                  case 1:                      il.Emit(OpCodes.Ldc_I4_1);                      return;                  case 2:                      il.Emit(OpCodes.Ldc_I4_2);                      return;                  case 3:                      il.Emit(OpCodes.Ldc_I4_3);                      return;                  case 4:                      il.Emit(OpCodes.Ldc_I4_4);                      return;                  case 5:                      il.Emit(OpCodes.Ldc_I4_5);                      return;                  case 6:                      il.Emit(OpCodes.Ldc_I4_6);                      return;                  case 7:                      il.Emit(OpCodes.Ldc_I4_7);                      return;                  case 8:                      il.Emit(OpCodes.Ldc_I4_8);                      return;              }
Missing Default,OpenUO.Core.Reflection,BasePropertyAccessor,C:\repos\fdsprod_OpenUO\OpenUO.Core.Net45\Reflection\BasePropertyAccessor.cs,EmitFastInt,The following switch statement is missing a default case: switch (value)              {                  case -1:                      il.Emit(OpCodes.Ldc_I4_M1);                      return;                  case 0:                      il.Emit(OpCodes.Ldc_I4_0);                      return;                  case 1:                      il.Emit(OpCodes.Ldc_I4_1);                      return;                  case 2:                      il.Emit(OpCodes.Ldc_I4_2);                      return;                  case 3:                      il.Emit(OpCodes.Ldc_I4_3);                      return;                  case 4:                      il.Emit(OpCodes.Ldc_I4_4);                      return;                  case 5:                      il.Emit(OpCodes.Ldc_I4_5);                      return;                  case 6:                      il.Emit(OpCodes.Ldc_I4_6);                      return;                  case 7:                      il.Emit(OpCodes.Ldc_I4_7);                      return;                  case 8:                      il.Emit(OpCodes.Ldc_I4_8);                      return;              }
